/// Auto-generated code for STM32U585
/// Generated by Alloy Code Generator
/// Source: st_stm32u585.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:00
#ifndef ALLOY_GENERATED_STM32U585_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32U585_PERIPHERALS_HPP

#include <stdint.h>

namespace alloy::generated::stm32u585 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_sec = true;
    constexpr uint32_t num_sec_instances = 38;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 20;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 8;
    constexpr bool has_icache = true;
    constexpr uint32_t num_icache_instances = 1;
    constexpr bool has_dcache = true;
    constexpr uint32_t num_dcache_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 4;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 30;
    constexpr bool has_gtzc1 = true;
    constexpr uint32_t num_gtzc1_instances = 5;
    constexpr bool has_gtzc2 = true;
    constexpr uint32_t num_gtzc2_instances = 3;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 2;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_sai1 = true;
    constexpr uint32_t num_sai1_instances = 1;
    constexpr bool has_sai2 = true;
    constexpr uint32_t num_sai2_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 6;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 12;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_pka = true;
    constexpr uint32_t num_pka_instances = 1;
    constexpr bool has_dbgmcu = true;
    constexpr uint32_t num_dbgmcu_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 12;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 2;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;
    constexpr bool has_tsc = true;
    constexpr uint32_t num_tsc_instances = 1;
    constexpr bool has_ucpd1 = true;
    constexpr uint32_t num_ucpd1_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 4;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_crs = true;
    constexpr uint32_t num_crs_instances = 1;
    constexpr bool has_hash = true;
    constexpr uint32_t num_hash_instances = 1;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_mdf1 = true;
    constexpr uint32_t num_mdf1_instances = 1;
    constexpr bool has_adf1 = true;
    constexpr uint32_t num_adf1_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 6;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 2;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 4;
    constexpr bool has_fmac = true;
    constexpr uint32_t num_fmac_instances = 1;
    constexpr bool has_cordic = true;
    constexpr uint32_t num_cordic_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 4;
    constexpr bool has_opamp = true;
    constexpr uint32_t num_opamp_instances = 1;
    constexpr bool has_dlybos1 = true;
    constexpr uint32_t num_dlybos1_instances = 1;
    constexpr bool has_dlybos2 = true;
    constexpr uint32_t num_dlybos2_instances = 1;
    constexpr bool has_dlybsd1 = true;
    constexpr uint32_t num_dlybsd1_instances = 1;
    constexpr bool has_dlybsd2 = true;
    constexpr uint32_t num_dlybsd2_instances = 1;
    constexpr bool has_otg = true;
    constexpr uint32_t num_otg_instances = 1;
    constexpr bool has_pssi = true;
    constexpr uint32_t num_pssi_instances = 1;
    constexpr bool has_otfdec1 = true;
    constexpr uint32_t num_otfdec1_instances = 1;
    constexpr bool has_otfdec2 = true;
    constexpr uint32_t num_otfdec2_instances = 1;
    constexpr bool has_ramcfg = true;
    constexpr uint32_t num_ramcfg_instances = 1;
    constexpr bool has_dcmi = true;
    constexpr uint32_t num_dcmi_instances = 1;
    constexpr bool has_dcb = true;
    constexpr uint32_t num_dcb_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sec_tag> {
        static constexpr uint32_t value = 38;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 20;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct icache_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcache_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 30;
    };
    template<>
    struct peripheral_count<struct gtzc1_tag> {
        static constexpr uint32_t value = 5;
    };
    template<>
    struct peripheral_count<struct gtzc2_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sai1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 12;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pka_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dbgmcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 12;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ucpd1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct hash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mdf1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adf1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct fmac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct cordic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct opamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlybos1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlybos2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlybsd1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlybsd2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pssi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otfdec1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otfdec2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ramcfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcmi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcb_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 20;
    constexpr uint32_t max_gpio_pins = 320;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart1 = true;
    constexpr bool has_sec_lpuart1 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_sec_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_sec_usart2 = true;
    constexpr bool has_usart3 = true;
    constexpr bool has_sec_usart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_sec_uart4 = true;
    constexpr bool has_uart5 = true;
    constexpr bool has_sec_uart5 = true;
}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x46022000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t EXTI_RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t EXTI_FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t EXTI_SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t EXTI_RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register
        volatile uint32_t EXTI_FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register
        volatile uint32_t EXTI_SECCFGR1;  ///< Offset: 0x14 - EXTI security configuration register
        volatile uint32_t EXTI_PRIVCFGR1;  ///< Offset: 0x18 - EXTI privilege configuration register
        volatile uint32_t EXTI_EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register
        volatile uint32_t EXTI_LOCKR;  ///< Offset: 0x70 - EXTI lock register
        volatile uint32_t EXTI_IMR1;  ///< Offset: 0x80 - EXTI CPU wake-up with interrupt mask register
        volatile uint32_t EXTI_EMR1;  ///< Offset: 0x84 - EXTI CPU wake-up with event mask register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// EXTI_RTSR1 Register bits
    namespace exti_rtsr1_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT16 = (1U << 16);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT17 = (1U << 17);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT18 = (1U << 18);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT19 = (1U << 19);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT20 = (1U << 20);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT21 = (1U << 21);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT22 = (1U << 22);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT23 = (1U << 23);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT24 = (1U << 24);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT25 = (1U << 25);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_FTSR1 Register bits
    namespace exti_ftsr1_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT16 = (1U << 16);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT17 = (1U << 17);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT18 = (1U << 18);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT19 = (1U << 19);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT20 = (1U << 20);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT21 = (1U << 21);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT22 = (1U << 22);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT23 = (1U << 23);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT24 = (1U << 24);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT25 = (1U << 25);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_SWIER1 Register bits
    namespace exti_swier1_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI16 = (1U << 16);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI17 = (1U << 17);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI18 = (1U << 18);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI19 = (1U << 19);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI20 = (1U << 20);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI21 = (1U << 21);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI22 = (1U << 22);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI23 = (1U << 23);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI24 = (1U << 24);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI25 = (1U << 25);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_RPR1 Register bits
    namespace exti_rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF1 = (1U << 1);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF2 = (1U << 2);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF3 = (1U << 3);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF4 = (1U << 4);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF5 = (1U << 5);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF6 = (1U << 6);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF7 = (1U << 7);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF8 = (1U << 8);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF9 = (1U << 9);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF10 = (1U << 10);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF11 = (1U << 11);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF12 = (1U << 12);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF13 = (1U << 13);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF14 = (1U << 14);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF15 = (1U << 15);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF16 = (1U << 16);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF17 = (1U << 17);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF18 = (1U << 18);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF19 = (1U << 19);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF20 = (1U << 20);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF21 = (1U << 21);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF22 = (1U << 22);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF23 = (1U << 23);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF24 = (1U << 24);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF25 = (1U << 25);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_FPR1 Register bits
    namespace exti_fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF1 = (1U << 1);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF2 = (1U << 2);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF3 = (1U << 3);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF4 = (1U << 4);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF5 = (1U << 5);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF6 = (1U << 6);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF7 = (1U << 7);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF8 = (1U << 8);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF9 = (1U << 9);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF10 = (1U << 10);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF11 = (1U << 11);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF12 = (1U << 12);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF13 = (1U << 13);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF14 = (1U << 14);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF15 = (1U << 15);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF16 = (1U << 16);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF17 = (1U << 17);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF18 = (1U << 18);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF19 = (1U << 19);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF20 = (1U << 20);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF21 = (1U << 21);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF22 = (1U << 22);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF23 = (1U << 23);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF24 = (1U << 24);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF25 = (1U << 25);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_SECCFGR1 Register bits
    namespace exti_seccfgr1_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC1 = (1U << 1);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC2 = (1U << 2);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC3 = (1U << 3);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC4 = (1U << 4);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC5 = (1U << 5);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC6 = (1U << 6);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC7 = (1U << 7);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC8 = (1U << 8);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC9 = (1U << 9);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC10 = (1U << 10);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC11 = (1U << 11);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC12 = (1U << 12);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC13 = (1U << 13);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC14 = (1U << 14);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC15 = (1U << 15);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC16 = (1U << 16);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC17 = (1U << 17);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC18 = (1U << 18);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC19 = (1U << 19);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC20 = (1U << 20);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC21 = (1U << 21);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC22 = (1U << 22);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC23 = (1U << 23);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC24 = (1U << 24);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC25 = (1U << 25);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_PRIVCFGR1 Register bits
    namespace exti_privcfgr1_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV1 = (1U << 1);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV2 = (1U << 2);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV3 = (1U << 3);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV4 = (1U << 4);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV5 = (1U << 5);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV6 = (1U << 6);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV7 = (1U << 7);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV8 = (1U << 8);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV9 = (1U << 9);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV10 = (1U << 10);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV11 = (1U << 11);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV12 = (1U << 12);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV13 = (1U << 13);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV14 = (1U << 14);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV15 = (1U << 15);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV16 = (1U << 16);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV17 = (1U << 17);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV18 = (1U << 18);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV19 = (1U << 19);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV20 = (1U << 20);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV21 = (1U << 21);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV22 = (1U << 22);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV23 = (1U << 23);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV24 = (1U << 24);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV25 = (1U << 25);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_EXTICR1 Register bits
    namespace exti_exticr1_bits {
        constexpr uint32_t EXTI0 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI1 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI2 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI3 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR2 Register bits
    namespace exti_exticr2_bits {
        constexpr uint32_t EXTI4 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI5 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI6 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI7 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR3 Register bits
    namespace exti_exticr3_bits {
        constexpr uint32_t EXTI8 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI9 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI10 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI11 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR4 Register bits
    namespace exti_exticr4_bits {
        constexpr uint32_t EXTI12 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI13 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI14 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI15 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_LOCKR Register bits
    namespace exti_lockr_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< Global security and privilege configuration registers (EXTI_SECCFGR and EXTI_PRIVCFGR) lock This bit is written once after reset.
    }

    /// EXTI_IMR1 Register bits
    namespace exti_imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM16 = (1U << 16);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM17 = (1U << 17);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM18 = (1U << 18);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM20 = (1U << 20);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_EMR1 Register bits
    namespace exti_emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM16 = (1U << 16);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM17 = (1U << 17);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM18 = (1U << 18);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM20 = (1U << 20);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM22 = (1U << 22);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM24 = (1U << 24);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

}

// ============================================================================
// SEC Peripheral
// ============================================================================

namespace sec {
    /// Base addresses
    constexpr uint32_t SEC_EXTI_BASE = 0x56022000;
    constexpr uint32_t SEC_ICache_BASE = 0x50030400;
    constexpr uint32_t SEC_DCACHE_BASE = 0x50031400;
    constexpr uint32_t SEC_GTZC1_MPCBB1_BASE = 0x50032C00;
    constexpr uint32_t SEC_GTZC1_MPCBB2_BASE = 0x50033000;
    constexpr uint32_t SEC_GTZC1_MPCBB3_BASE = 0x50033400;
    constexpr uint32_t SEC_GTZC1_TZIC_BASE = 0x50032800;
    constexpr uint32_t SEC_GTZC1_TZSC_BASE = 0x50032400;
    constexpr uint32_t SEC_GTZC2_MPCBB4_BASE = 0x56023800;
    constexpr uint32_t SEC_GTZC2_TZIC_BASE = 0x56023400;
    constexpr uint32_t SEC_GTZC2_TZSC_BASE = 0x56023000;
    constexpr uint32_t SEC_SAI1_BASE = 0x50015400;
    constexpr uint32_t SEC_SAI2_BASE = 0x50015800;
    constexpr uint32_t SEC_SYSCFG_BASE = 0x56000400;
    constexpr uint32_t SEC_PKA_BASE = 0x520C2000;
    constexpr uint32_t SEC_VREFBUF_BASE = 0x56007400;
    constexpr uint32_t SEC_TSC_BASE = 0x50024000;
    constexpr uint32_t SEC_UCPD1_BASE = 0x5000DC00;
    constexpr uint32_t SEC_CRC_BASE = 0x50023000;
    constexpr uint32_t SEC_CRS_BASE = 0x50006000;
    constexpr uint32_t SEC_HASH_BASE = 0x520C0400;
    constexpr uint32_t SEC_TAMP_BASE = 0x56007C00;
    constexpr uint32_t SEC_MDF1_BASE = 0x50025000;
    constexpr uint32_t SEC_ADF1_BASE = 0x56024000;
    constexpr uint32_t SEC_FMC_BASE = 0x520D0400;
    constexpr uint32_t SEC_FMAC_BASE = 0x50021400;
    constexpr uint32_t SEC_CORDIC_BASE = 0x50021000;
    constexpr uint32_t SEC_OPAMP_BASE = 0x56005000;
    constexpr uint32_t SEC_DLYBOS1_BASE = 0x520CF000;
    constexpr uint32_t SEC_DLYBOS2_BASE = 0x520CF400;
    constexpr uint32_t SEC_DLYBSD1_BASE = 0x520C8400;
    constexpr uint32_t SEC_DLYBSD2_BASE = 0x520C8800;
    constexpr uint32_t SEC_OTG_FS_BASE = 0x52040000;
    constexpr uint32_t SEC_PSSI_BASE = 0x5202C400;
    constexpr uint32_t SEC_OTFDEC1_BASE = 0x520C5000;
    constexpr uint32_t SEC_OTFDEC2_BASE = 0x520C5400;
    constexpr uint32_t SEC_RAMCFG_BASE = 0x50026000;
    constexpr uint32_t SEC_DCMI_BASE = 0x5202C000;

    /// SEC Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SEC_EXTI = reinterpret_cast<Registers*>(SEC_EXTI_BASE);
    inline Registers* SEC_ICache = reinterpret_cast<Registers*>(SEC_ICache_BASE);
    inline Registers* SEC_DCACHE = reinterpret_cast<Registers*>(SEC_DCACHE_BASE);
    inline Registers* SEC_GTZC1_MPCBB1 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB1_BASE);
    inline Registers* SEC_GTZC1_MPCBB2 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB2_BASE);
    inline Registers* SEC_GTZC1_MPCBB3 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB3_BASE);
    inline Registers* SEC_GTZC1_TZIC = reinterpret_cast<Registers*>(SEC_GTZC1_TZIC_BASE);
    inline Registers* SEC_GTZC1_TZSC = reinterpret_cast<Registers*>(SEC_GTZC1_TZSC_BASE);
    inline Registers* SEC_GTZC2_MPCBB4 = reinterpret_cast<Registers*>(SEC_GTZC2_MPCBB4_BASE);
    inline Registers* SEC_GTZC2_TZIC = reinterpret_cast<Registers*>(SEC_GTZC2_TZIC_BASE);
    inline Registers* SEC_GTZC2_TZSC = reinterpret_cast<Registers*>(SEC_GTZC2_TZSC_BASE);
    inline Registers* SEC_SAI1 = reinterpret_cast<Registers*>(SEC_SAI1_BASE);
    inline Registers* SEC_SAI2 = reinterpret_cast<Registers*>(SEC_SAI2_BASE);
    inline Registers* SEC_SYSCFG = reinterpret_cast<Registers*>(SEC_SYSCFG_BASE);
    inline Registers* SEC_PKA = reinterpret_cast<Registers*>(SEC_PKA_BASE);
    inline Registers* SEC_VREFBUF = reinterpret_cast<Registers*>(SEC_VREFBUF_BASE);
    inline Registers* SEC_TSC = reinterpret_cast<Registers*>(SEC_TSC_BASE);
    inline Registers* SEC_UCPD1 = reinterpret_cast<Registers*>(SEC_UCPD1_BASE);
    inline Registers* SEC_CRC = reinterpret_cast<Registers*>(SEC_CRC_BASE);
    inline Registers* SEC_CRS = reinterpret_cast<Registers*>(SEC_CRS_BASE);
    inline Registers* SEC_HASH = reinterpret_cast<Registers*>(SEC_HASH_BASE);
    inline Registers* SEC_TAMP = reinterpret_cast<Registers*>(SEC_TAMP_BASE);
    inline Registers* SEC_MDF1 = reinterpret_cast<Registers*>(SEC_MDF1_BASE);
    inline Registers* SEC_ADF1 = reinterpret_cast<Registers*>(SEC_ADF1_BASE);
    inline Registers* SEC_FMC = reinterpret_cast<Registers*>(SEC_FMC_BASE);
    inline Registers* SEC_FMAC = reinterpret_cast<Registers*>(SEC_FMAC_BASE);
    inline Registers* SEC_CORDIC = reinterpret_cast<Registers*>(SEC_CORDIC_BASE);
    inline Registers* SEC_OPAMP = reinterpret_cast<Registers*>(SEC_OPAMP_BASE);
    inline Registers* SEC_DLYBOS1 = reinterpret_cast<Registers*>(SEC_DLYBOS1_BASE);
    inline Registers* SEC_DLYBOS2 = reinterpret_cast<Registers*>(SEC_DLYBOS2_BASE);
    inline Registers* SEC_DLYBSD1 = reinterpret_cast<Registers*>(SEC_DLYBSD1_BASE);
    inline Registers* SEC_DLYBSD2 = reinterpret_cast<Registers*>(SEC_DLYBSD2_BASE);
    inline Registers* SEC_OTG_FS = reinterpret_cast<Registers*>(SEC_OTG_FS_BASE);
    inline Registers* SEC_PSSI = reinterpret_cast<Registers*>(SEC_PSSI_BASE);
    inline Registers* SEC_OTFDEC1 = reinterpret_cast<Registers*>(SEC_OTFDEC1_BASE);
    inline Registers* SEC_OTFDEC2 = reinterpret_cast<Registers*>(SEC_OTFDEC2_BASE);
    inline Registers* SEC_RAMCFG = reinterpret_cast<Registers*>(SEC_RAMCFG_BASE);
    inline Registers* SEC_DCMI = reinterpret_cast<Registers*>(SEC_DCMI_BASE);

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;
    constexpr uint32_t SEC_FLASH_BASE = 0x50022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FLASH_ACR;  ///< Offset: 0x00 - FLASH access control register
        volatile uint32_t FLASH_NSKEYR;  ///< Offset: 0x08 - FLASH non-secure key register
        volatile uint32_t FLASH_SECKEYR;  ///< Offset: 0x0C - FLASH secure key register
        volatile uint32_t FLASH_OPTKEYR;  ///< Offset: 0x10 - FLASH option key register
        volatile uint32_t FLASH_PDKEY1R;  ///< Offset: 0x18 - FLASH bank 1 power-down key register
        volatile uint32_t FLASH_PDKEY2R;  ///< Offset: 0x1C - FLASH bank 2 power-down key register
        volatile uint32_t FLASH_NSSR;  ///< Offset: 0x20 - FLASH non-secure status register
        volatile uint32_t FLASH_SECSR;  ///< Offset: 0x24 - FLASH secure status register
        volatile uint32_t FLASH_NSCR;  ///< Offset: 0x28 - FLASH non-secure control register
        volatile uint32_t FLASH_SECCR;  ///< Offset: 0x2C - FLASH secure control register
        volatile uint32_t FLASH_ECCR;  ///< Offset: 0x30 - FLASH ECC register
        volatile uint32_t FLASH_OPSR;  ///< Offset: 0x34 - FLASH operation status register
        volatile uint32_t FLASH_OPTR;  ///< Offset: 0x40 - FLASH option register
        volatile uint32_t FLASH_NSBOOTADD0R;  ///< Offset: 0x44 - FLASH non-secure boot address 0 register
        volatile uint32_t FLASH_NSBOOTADD1R;  ///< Offset: 0x48 - FLASH non-secure boot address 1 register
        volatile uint32_t FLASH_SECBOOTADD0R;  ///< Offset: 0x4C - FLASH secure boot address 0 register
        volatile uint32_t FLASH_SECWM1R1;  ///< Offset: 0x50 - FLASH secure watermark1 register 1
        volatile uint32_t FLASH_SECWM1R2;  ///< Offset: 0x54 - FLASH secure watermark1 register 2
        volatile uint32_t FLASH_WRP1AR;  ///< Offset: 0x58 - FLASH WRP1 area A address register
        volatile uint32_t FLASH_WRP1BR;  ///< Offset: 0x5C - FLASH WRP1 area B address register
        volatile uint32_t FLASH_SECWM2R1;  ///< Offset: 0x60 - FLASH secure watermark2 register 1
        volatile uint32_t FLASH_SECWM2R2;  ///< Offset: 0x64 - FLASH secure watermark2 register 2
        volatile uint32_t FLASH_WRP2AR;  ///< Offset: 0x68 - FLASH WPR2 area A address register
        volatile uint32_t FLASH_WRP2BR;  ///< Offset: 0x6C - FLASH WPR2 area B address register
        volatile uint32_t FLASH_OEM1KEYR1;  ///< Offset: 0x70 - FLASH OEM1 key register 1
        volatile uint32_t FLASH_OEM1KEYR2;  ///< Offset: 0x74 - FLASH OEM1 key register 2
        volatile uint32_t FLASH_OEM2KEYR1;  ///< Offset: 0x78 - FLASH OEM2 key register 1
        volatile uint32_t FLASH_OEM2KEYR2;  ///< Offset: 0x7C - FLASH OEM2 key register 2
        volatile uint32_t FLASH_SEC1BBR1;  ///< Offset: 0x80 - FLASH secure block based bank 1 register 1
        volatile uint32_t FLASH_SEC1BBR2;  ///< Offset: 0x84 - FLASH secure block based bank 1 register 2
        volatile uint32_t FLASH_SEC1BBR3;  ///< Offset: 0x88 - FLASH secure block based bank 1 register 3
        volatile uint32_t FLASH_SEC1BBR4;  ///< Offset: 0x8C - FLASH secure block based bank 1 register 4
        volatile uint32_t FLASH_SEC2BBR1;  ///< Offset: 0xA0 - FLASH secure block based bank 2 register 1
        volatile uint32_t FLASH_SEC2BBR2;  ///< Offset: 0xA4 - FLASH secure block based bank 2 register 2
        volatile uint32_t FLASH_SEC2BBR3;  ///< Offset: 0xA8 - FLASH secure block based bank 2 register 3
        volatile uint32_t FLASH_SEC2BBR4;  ///< Offset: 0xAC - FLASH secure block based bank 2 register 4
        volatile uint32_t FLASH_SECHDPCR;  ///< Offset: 0xC0 - FLASH secure HDP control register
        volatile uint32_t FLASH_PRIVCFGR;  ///< Offset: 0xC4 - FLASH privilege configuration register
        volatile uint32_t FLASH_PRIV1BBR1;  ///< Offset: 0xD0 - FLASH privilege block based bank 1 register 1
        volatile uint32_t FLASH_PRIV1BBR2;  ///< Offset: 0xD4 - FLASH privilege block based bank 1 register 2
        volatile uint32_t FLASH_PRIV1BBR3;  ///< Offset: 0xD8 - FLASH privilege block based bank 1 register 3
        volatile uint32_t FLASH_PRIV1BBR4;  ///< Offset: 0xDC - FLASH privilege block based bank 1 register 4
        volatile uint32_t FLASH_PRIV2BBR1;  ///< Offset: 0xF0 - FLASH privilege block based bank 2 register 1
        volatile uint32_t FLASH_PRIV2BBR2;  ///< Offset: 0xF4 - FLASH privilege block based bank 2 register 2
        volatile uint32_t FLASH_PRIV2BBR3;  ///< Offset: 0xF8 - FLASH privilege block based bank 2 register 3
        volatile uint32_t FLASH_PRIV2BBR4;  ///< Offset: 0xFC - FLASH privilege block based bank 2 register 4
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);
    inline Registers* SEC_FLASH = reinterpret_cast<Registers*>(SEC_FLASH_BASE);

    // Bit definitions
    /// FLASH_ACR Register bits
    namespace flash_acr_bits {
        constexpr uint32_t LATENCY = (4 << 0);  ///< Latency These bits represent the ratio between the HCLK (AHB clock) period and the Flash memory access time. ...
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable This bit enables the prefetch buffer in the embedded Flash memory.
        constexpr uint32_t LPM = (1U << 11);  ///< Low-power read mode This bit puts the Flash memory in low-power read mode.
        constexpr uint32_t PDREQ1 = (1U << 12);  ///< Bank 1 power-down mode request This bit is write-protected with FLASH_PDKEY1R. This bit requests bank 1 to enter power-down mode. When bank 1 enters power-down mode, this bit is cleared by hardware and the PDKEY1R is locked.
        constexpr uint32_t PDREQ2 = (1U << 13);  ///< Bank 2 power-down mode request This bit is write-protected with FLASH_PDKEY2R. This bit requests bank 2 to enter power-down mode. When bank 2 enters power-down mode, this bit is cleared by hardware and the PDKEY2R is locked.
        constexpr uint32_t SLEEP_PD = (1U << 14);  ///< Flash memory power-down mode during Sleep mode This bit determines whether the Flash memory is in power-down mode or Idle mode when the device is in Sleep mode. The Flash must not be put in power-down while a program or an erase operation is on-going.
    }

    /// FLASH_NSKEYR Register bits
    namespace flash_nskeyr_bits {
        constexpr uint32_t NSKEY = (32 << 0);  ///< Flash memory non-secure key
    }

    /// FLASH_SECKEYR Register bits
    namespace flash_seckeyr_bits {
        constexpr uint32_t SECKEY = (32 << 0);  ///< Flash memory secure key
    }

    /// FLASH_OPTKEYR Register bits
    namespace flash_optkeyr_bits {
        constexpr uint32_t OPTKEY = (32 << 0);  ///< Option byte key
    }

    /// FLASH_PDKEY1R Register bits
    namespace flash_pdkey1r_bits {
        constexpr uint32_t PDKEY1 = (32 << 0);  ///< Bank 1 power-down key
    }

    /// FLASH_PDKEY2R Register bits
    namespace flash_pdkey2r_bits {
        constexpr uint32_t PDKEY2 = (32 << 0);  ///< Bank 2 power-down key
    }

    /// FLASH_NSSR Register bits
    namespace flash_nssr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< Non-secure end of operation
        constexpr uint32_t OPERR = (1U << 1);  ///< Non-secure operation error
        constexpr uint32_t PROGERR = (1U << 3);  ///< Non-secure programming error This bit is set by hardware when a non-secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1.
        constexpr uint32_t WRPERR = (1U << 4);  ///< Non-secure write protection error This bit is set by hardware when an non-secure address to be erased/programmed belongs to a write-protected part (by WRP, HDP or RDP level 1) of the Flash memory. This bit is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t PGAERR = (1U << 5);  ///< Non-secure programming alignment error This bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address. This bit is cleared by writing 1.
        constexpr uint32_t SIZERR = (1U << 6);  ///< Non-secure size error This bit is set by hardware when the size of the access is a byte or half-word during a non-secure program sequence. Only quad-word programming is allowed by means of successive word accesses. This bit is cleared by writing 1.
        constexpr uint32_t PGSERR = (1U << 7);  ///< Non-secure programming sequence error This bit is set by hardware when programming sequence is not correct. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t OPTWERR = (1U << 13);  ///< Option write error This bit is set by hardware when the options bytes are written with an invalid configuration. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t BSY = (1U << 16);  ///< Non-secure busy This indicates that a Flash memory secure or non-secure operation is in progress. This bit is set at the beginning of a Flash operation and reset when the operation finishes or when an error occurs.
        constexpr uint32_t WDW = (1U << 17);  ///< Non-secure wait data to write This bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory.
        constexpr uint32_t OEM1LOCK = (1U << 18);  ///< OEM1 lock This bit indicates that the OEM1 RDP key read during the OBL is not virgin. When set, the OEM1 RDP lock mechanism is active.
        constexpr uint32_t OEM2LOCK = (1U << 19);  ///< OEM2 lock This bit indicates that the OEM2 RDP key read during the OBL is not virgin. When set, the OEM2 RDP lock mechanism is active.
        constexpr uint32_t PD1 = (1U << 20);  ///< Bank 1 in power-down mode This bit indicates that the Flash memory bank 1 is in power-down state. It is reset when bank1 is in normal mode or being awaken.
        constexpr uint32_t PD2 = (1U << 21);  ///< Bank 2 in power-down mode This bit indicates that the Flash memory bank 2 is in power-down state. It is reset when bank2 is in normal mode or being awaken.
    }

    /// FLASH_SECSR Register bits
    namespace flash_secsr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< Secure end of operation This bit is set by hardware when one or more Flash memory secure operation (program/erase) has been completed successfully. This bit is set only if the secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_SECCR). This bit is cleared by writing1.
        constexpr uint32_t OPERR = (1U << 1);  ///< Secure operation error This bit is set by hardware when a Flash memory secure operation (program/erase) completes unsuccessfully. This bit is set only if secure error interrupts are enabled (SECERRIE = 1). This bit is cleared by writing 1.
        constexpr uint32_t PROGERR = (1U << 3);  ///< Secure programming error This bit is set by hardware when a secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1.
        constexpr uint32_t WRPERR = (1U << 4);  ///< Secure write protection error This bit is set by hardware when an secure address to be erased/programmed belongs to a write-protected part (by WRP, PCROP, HDP or RDP level 1) of the Flash memory.This bit is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t PGAERR = (1U << 5);  ///< Secure programming alignment error This bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address.This bit is cleared by writing 1.
        constexpr uint32_t SIZERR = (1U << 6);  ///< Secure size error This bit is set by hardware when the size of the access is a byte or half-word during a secure program sequence. Only quad-word programming is allowed by means of successive word accesses.This bit is cleared by writing 1.
        constexpr uint32_t PGSERR = (1U << 7);  ///< Secure programming sequence error This bit is set by hardware when programming sequence is not correct. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t BSY = (1U << 16);  ///< Secure busy This bit indicates that a Flash memory secure or non-secure operation is in progress. This is set on the beginning of a Flash operation and reset when the operation finishes or when an error occurs.
        constexpr uint32_t WDW = (1U << 17);  ///< Secure wait data to write This bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory.
    }

    /// FLASH_NSCR Register bits
    namespace flash_nscr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Non-secure programming
        constexpr uint32_t PER = (1U << 1);  ///< Non-secure page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Non-secure bank 1 mass erase This bit triggers the bank 1 non-secure mass erase (all bank 1 user pages) when set.
        constexpr uint32_t PNB = (7 << 3);  ///< Non-secure page number selection These bits select the page to erase. ...
        constexpr uint32_t BKER = (1U << 11);  ///< Non-secure bank selection for page erase
        constexpr uint32_t BWR = (1U << 14);  ///< Non-secure burst write programming mode When set, this bit selects the burst write programming mode.
        constexpr uint32_t MER2 = (1U << 15);  ///< Non-secure bank 2 mass erase This bit triggers the bank 2 non-secure mass erase (all bank 2 user pages) when set.
        constexpr uint32_t STRT = (1U << 16);  ///< Non-secure start This bit triggers a non-secure erase operation when set. If MER1, MER2 and PER bits are reset and the STRT bit is set, the PGSERR bit in FLASH_NSSR is set (this condition is forbidden). This bit is set only by software and is cleared when the BSY bit is cleared in FLASH_NSSR.
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start This bit triggers an options operation when set. It can not be written if OPTLOCK bit is set. This bit is set only by software, and is cleared when the BSY bit is cleared in FLASH_NSSR.
        constexpr uint32_t EOPIE = (1U << 24);  ///< Non-secure end of operation interrupt enable This bit enables the interrupt generation when the EOP bit in the FLASH_NSSR is set to 1.
        constexpr uint32_t ERRIE = (1U << 25);  ///< Non-secure error interrupt enable This bit enables the interrupt generation when the OPERR bit in the FLASH_NSSR is set to 1.
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading When set to 1, this bit forces the option byte reloading. This bit is cleared only when the option byte loading is complete. It cannot be written if OPTLOCK is set.
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Option lock This bit is set only. When set, all bits concerning user options in FLASH_NSCR register are locked. This bit is cleared by hardware after detecting the unlock sequence. The LOCK bit in the FLASH_NSCR must be cleared before doing the unlock sequence for OPTLOCK bit. In case of an unsuccessful unlock operation, this bit remains set until the next reset.
        constexpr uint32_t LOCK = (1U << 31);  ///< Non-secure lock This bit is set only. When set, the FLASH_NSCR register is locked. It is cleared by hardware after detecting the unlock sequence in FLASH_NSKEYR register. In case of an unsuccessful unlock operation, this bit remains set until the next system reset.
    }

    /// FLASH_SECCR Register bits
    namespace flash_seccr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Secure programming
        constexpr uint32_t PER = (1U << 1);  ///< Secure page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Secure bank 1 mass erase This bit triggers the bank 1 secure mass erase (all bank 1 user pages) when set.
        constexpr uint32_t PNB = (7 << 3);  ///< Secure page number selection These bits select the page to erase: ...
        constexpr uint32_t BKER = (1U << 11);  ///< Secure bank selection for page erase
        constexpr uint32_t BWR = (1U << 14);  ///< Secure burst write programming mode When set, this bit selects the burst write programming mode.
        constexpr uint32_t MER2 = (1U << 15);  ///< Secure bank 2 mass erase This bit triggers the bank 2 secure mass erase (all bank 2 user pages) when set.
        constexpr uint32_t STRT = (1U << 16);  ///< Secure start This bit triggers a secure erase operation when set. If MER1, MER2 and PER bits are reset and the STRT bit is set, the PGSERR in the FLASH_SECSR is set (this condition is forbidden). This bit is set only by software and is cleared when the BSY bit is cleared in FLASH_SECSR.
        constexpr uint32_t EOPIE = (1U << 24);  ///< Secure End of operation interrupt enable This bit enables the interrupt generation when the EOP bit in the FLASH_SECSR is set to 1.
        constexpr uint32_t ERRIE = (1U << 25);  ///< Secure error interrupt enable
        constexpr uint32_t RDERRIE = (1U << 26);  ///< Secure PCROP read error interrupt enable
        constexpr uint32_t INV = (1U << 29);  ///< Flash memory security state invert This bit inverts the Flash memory security state.
        constexpr uint32_t LOCK = (1U << 31);  ///< Secure lock This bit is set only. When set, the FLASH_SECCR register is locked. It is cleared by hardware after detecting the unlock sequence in FLASH_SECKEYR register. In case of an unsuccessful unlock operation, this bit remains set until the next system reset.
    }

    /// FLASH_ECCR Register bits
    namespace flash_eccr_bits {
        constexpr uint32_t ADDR_ECC = (20 << 0);  ///< ECC fail address
        constexpr uint32_t BK_ECC = (1U << 21);  ///< ECC fail bank
        constexpr uint32_t SYSF_ECC = (1U << 22);  ///< System Flash memory ECC fail This bit indicates that the ECC error correction or double ECC error detection is located in the system Flash memory.
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable This bit enables the interrupt generation when the ECCC bit in the FLASH_ECCR register is set.
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction This bit is set by hardware when one ECC error has been detected and corrected (only if ECCC and ECCD were previously cleared). An interrupt is generated if ECCIE is set. This bit is cleared by writing 1.
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection This bit is set by hardware when two ECC errors have been detected (only if ECCC and ECCD were previously cleared). When this bit is set, a NMI is generated. This bit is cleared by writing 1.
    }

    /// FLASH_OPSR Register bits
    namespace flash_opsr_bits {
        constexpr uint32_t ADDR_OP = (20 << 0);  ///< Interrupted operation address This field indicates which address in the Flash memory was accessed when reset occurred. The address is given by bank from address 0x00000 to 0xFFFF0.
        constexpr uint32_t BK_OP = (1U << 21);  ///< Interrupted operation bank This bit indicates which Flash memory bank was accessed when reset occurred
        constexpr uint32_t SYSF_OP = (1U << 22);  ///< Operation in system Flash memory interrupted This bit indicates that the reset occurred during an operation in the system Flash memory.
        constexpr uint32_t CODE_OP = (3 << 29);  ///< Flash memory operation code This field indicates which Flash memory operation has been interrupted by a system reset:
    }

    /// FLASH_OPTR Register bits
    namespace flash_optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Readout protection level Others: Level 1 (memories readout protection active) Note: Refer to for more details.
        constexpr uint32_t BOR_LEV = (3 << 8);  ///< BOR reset level These bits contain the VDD supply level threshold that activates/releases the reset.
        constexpr uint32_t nRST_STOP = (1U << 12);  ///< Reset generation in Stop mode
        constexpr uint32_t nRST_STDBY = (1U << 13);  ///< Reset generation in Standby mode
        constexpr uint32_t nRST_SHDW = (1U << 14);  ///< Reset generation in Shutdown mode
        constexpr uint32_t SRAM1345_RST = (1U << 15);  ///< SRAM1, SRAM3 and SRAM4 erase upon system reset
        constexpr uint32_t IWDG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t SWAP_BANK = (1U << 20);  ///< Swap banks
        constexpr uint32_t DUALBANK = (1U << 21);  ///< Dual-bank on 1-Mbyte and 512-Kbyte Flash memory devices
        constexpr uint32_t BKPRAM_ECC = (1U << 22);  ///< Backup RAM ECC detection and correction enable
        constexpr uint32_t SRAM3_ECC = (1U << 23);  ///< SRAM3 ECC detection and correction enable
        constexpr uint32_t SRAM2_ECC = (1U << 24);  ///< SRAM2 ECC detection and correction enable
        constexpr uint32_t SRAM2_RST = (1U << 25);  ///< SRAM2 erase when system reset
        constexpr uint32_t nSWBOOT0 = (1U << 26);  ///< Software BOOT0
        constexpr uint32_t nBOOT0 = (1U << 27);  ///< nBOOT0 option bit
        constexpr uint32_t PA15_PUPEN = (1U << 28);  ///< PA15 pull-up enable
        constexpr uint32_t IO_VDD_HSLV = (1U << 29);  ///< High-speed IO at low VDD voltage configuration bit This bit can be set only with VDD below 2.5V
        constexpr uint32_t IO_VDDIO2_HSLV = (1U << 30);  ///< High-speed IO at low VDDIO2 voltage configuration bit This bit can be set only with VDDIO2 below 2.5V.
        constexpr uint32_t TZEN = (1U << 31);  ///< Global TrustZone security enable
    }

    /// FLASH_NSBOOTADD0R Register bits
    namespace flash_nsbootadd0r_bits {
        constexpr uint32_t NSBOOTADD0 = (25 << 7);  ///< Non-secure boot base address 0 The non-secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: NSBOOTADD0[24:0] = 0x0100000: Boot from non-secure Flash memory (0x0800 0000) NSBOOTADD0[24:0] = 0x017F200: Boot from system memory bootloader (0x0BF9 0000) NSBOOTADD0[24:0] = 0x0400000: Boot from non-secure SRAM1 on S-Bus (0x2000 0000)
    }

    /// FLASH_NSBOOTADD1R Register bits
    namespace flash_nsbootadd1r_bits {
        constexpr uint32_t NSBOOTADD1 = (25 << 7);  ///< Non-secure boot address 1 The non-secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: NSBOOTADD1[24:0] = 0x0100000: Boot from non-secure Flash memory (0x0800 0000) NSBOOTADD1[24:0] = 0x017F200: Boot from system memory bootloader (0x0BF9 0000) NSBOOTADD1[24:0] = 0x0400000: Boot from non-secure SRAM1 on S-Bus (0x2000 0000)
    }

    /// FLASH_SECBOOTADD0R Register bits
    namespace flash_secbootadd0r_bits {
        constexpr uint32_t BOOT_LOCK = (1U << 0);  ///< Boot lock When set, the boot is always forced to base address value programmed in SECBOOTADD0[24:0] option bytes whatever the boot selection option. When set, this bit can only be cleared by an RDP at level 0.
        constexpr uint32_t SECBOOTADD0 = (25 << 7);  ///< Secure boot base address 0 The secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. This bits correspond to address [31:7] The SECBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: SECBOOTADD0[24:0] = 0x018 0000: Boot from secure Flash memory (0x0C00 0000) SECBOOTADD0[24:0] = 0x01F F000: Boot from RSS (0x0FF8 0000) SECBOOTADD0[24:0] = 0x060 0000: Boot from secure SRAM1 on S-Bus (0x3000 0000)
    }

    /// FLASH_SECWM1R1 Register bits
    namespace flash_secwm1r1_bits {
        constexpr uint32_t SECWM1_PSTRT = (7 << 0);  ///< Start page of first secure area This field contains the first page of the secure area in bank 1.
        constexpr uint32_t SECWM1_PEND = (7 << 16);  ///< End page of first secure area This field contains the last page of the secure area in bank 1.
    }

    /// FLASH_SECWM1R2 Register bits
    namespace flash_secwm1r2_bits {
        constexpr uint32_t HDP1_PEND = (7 << 16);  ///< End page of first hide protection area This field contains the last page of the HDP area in bank 1.
        constexpr uint32_t HDP1EN = (1U << 31);  ///< Hide protection first area enable
    }

    /// FLASH_WRP1AR Register bits
    namespace flash_wrp1ar_bits {
        constexpr uint32_t WRP1A_PSTRT = (7 << 0);  ///< bank 1 WPR first area A start page This field contains the first page of the first WPR area for bank 1.
        constexpr uint32_t WRP1A_PEND = (7 << 16);  ///< Bank 1 WPR first area A end page This field contains the last page of the first WPR area in bank 1.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 1 WPR first area A unlock
    }

    /// FLASH_WRP1BR Register bits
    namespace flash_wrp1br_bits {
        constexpr uint32_t WRP1B_PSTRT = (7 << 0);  ///< Bank 1 WRP second area B start page This field contains the first page of the second WRP area for bank 1.
        constexpr uint32_t WRP1B_PEND = (7 << 16);  ///< Bank 1 WRP second area B end page This field contains the last page of the second WRP area in bank 1.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 1 WPR second area B unlock
    }

    /// FLASH_SECWM2R1 Register bits
    namespace flash_secwm2r1_bits {
        constexpr uint32_t SECWM2_PSTRT = (7 << 0);  ///< Start page of second secure area This field contains the first page of the secure area in bank 2.
        constexpr uint32_t SECWM2_PEND = (7 << 16);  ///< End page of second secure area This field contains the last page of the secure area in bank 2.
    }

    /// FLASH_SECWM2R2 Register bits
    namespace flash_secwm2r2_bits {
        constexpr uint32_t HDP2_PEND = (7 << 16);  ///< End page of hide protection second area HDP2_PEND contains the last page of the HDP area in bank 2.
        constexpr uint32_t HDP2EN = (1U << 31);  ///< Hide protection second area enable
    }

    /// FLASH_WRP2AR Register bits
    namespace flash_wrp2ar_bits {
        constexpr uint32_t WRP2A_PSTRT = (7 << 0);  ///< Bank 2 WPR first area A start page This field contains the first page of the first WRP area for bank 2.
        constexpr uint32_t WRP2A_PEND = (7 << 16);  ///< Bank 2 WPR first area A end page This field contains the last page of the first WRP area in bank 2.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 2 WPR first area A unlock
    }

    /// FLASH_WRP2BR Register bits
    namespace flash_wrp2br_bits {
        constexpr uint32_t WRP2B_PSTRT = (7 << 0);  ///< Bank 2 WPR second area B start page This field contains the first page of the second WRP area for bank 2.
        constexpr uint32_t WRP2B_PEND = (7 << 16);  ///< Bank 2 WPR second area B end page This field contains the last page of the second WRP area in bank 2.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 2 WPR second area B unlock
    }

    /// FLASH_OEM1KEYR1 Register bits
    namespace flash_oem1keyr1_bits {
        constexpr uint32_t OEM1KEY = (32 << 0);  ///< OEM1 least significant bytes key
    }

    /// FLASH_OEM1KEYR2 Register bits
    namespace flash_oem1keyr2_bits {
        constexpr uint32_t OEM1KEY = (32 << 0);  ///< OEM1 most significant bytes key
    }

    /// FLASH_OEM2KEYR1 Register bits
    namespace flash_oem2keyr1_bits {
        constexpr uint32_t OEM2KEY = (32 << 0);  ///< OEM2 least significant bytes key
    }

    /// FLASH_OEM2KEYR2 Register bits
    namespace flash_oem2keyr2_bits {
        constexpr uint32_t OEM2KEY = (32 << 0);  ///< OEM2 most significant bytes key
    }

    /// FLASH_SEC1BBR1 Register bits
    namespace flash_sec1bbr1_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< page secure/non-secure attribution
    }

    /// FLASH_SEC1BBR2 Register bits
    namespace flash_sec1bbr2_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< page secure/non-secure attribution
    }

    /// FLASH_SEC1BBR3 Register bits
    namespace flash_sec1bbr3_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< page secure/non-secure attribution
    }

    /// FLASH_SEC1BBR4 Register bits
    namespace flash_sec1bbr4_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< page secure/non-secure attribution
    }

    /// FLASH_SEC2BBR1 Register bits
    namespace flash_sec2bbr1_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< page secure/non-secure attribution
    }

    /// FLASH_SEC2BBR2 Register bits
    namespace flash_sec2bbr2_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< page secure/non-secure attribution
    }

    /// FLASH_SEC2BBR3 Register bits
    namespace flash_sec2bbr3_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< page secure/non-secure attribution
    }

    /// FLASH_SEC2BBR4 Register bits
    namespace flash_sec2bbr4_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< page secure/non-secure attribution
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< page secure/non-secure attribution
    }

    /// FLASH_SECHDPCR Register bits
    namespace flash_sechdpcr_bits {
        constexpr uint32_t HDP1_ACCDIS = (1U << 0);  ///< HDP1 area access disable When set, this bit is only cleared by a system reset.
        constexpr uint32_t HDP2_ACCDIS = (1U << 1);  ///< HDP2 area access disable When set, this bit is only cleared by a system reset.
    }

    /// FLASH_PRIVCFGR Register bits
    namespace flash_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< Privileged protection for secure registers This bit can be accessed only when TrustZone is enabled (TZEN=1). This bit can be read by both privileged or unprivileged, secure and non-secure access. The SPRIV bit can be written only by a secure privileged access. A non-secure write access on SPRIV bit is ignored. A secure unprivileged write access on SPRIV bit is ignored.
        constexpr uint32_t NSPRIV = (1U << 1);  ///< Privileged protection for non-secure registers This bit can be read by both privileged or unprivileged, secure and non-secure access. The NSPRIV bit can be written by a secure or non-secure privileged access. A secure or non-secure unprivileged write access on NSPRIV bit is ignored.
    }

    /// FLASH_PRIV1BBR1 Register bits
    namespace flash_priv1bbr1_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< page privileged/unprivileged attribution
    }

    /// FLASH_PRIV1BBR2 Register bits
    namespace flash_priv1bbr2_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< page privileged/unprivileged attribution
    }

    /// FLASH_PRIV1BBR3 Register bits
    namespace flash_priv1bbr3_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< page privileged/unprivileged attribution
    }

    /// FLASH_PRIV1BBR4 Register bits
    namespace flash_priv1bbr4_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< page privileged/unprivileged attribution
    }

    /// FLASH_PRIV2BBR1 Register bits
    namespace flash_priv2bbr1_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< page privileged/unprivileged attribution
    }

    /// FLASH_PRIV2BBR2 Register bits
    namespace flash_priv2bbr2_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< page privileged/unprivileged attribution
    }

    /// FLASH_PRIV2BBR3 Register bits
    namespace flash_priv2bbr3_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< page privileged/unprivileged attribution
    }

    /// FLASH_PRIV2BBR4 Register bits
    namespace flash_priv2bbr4_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< page privileged/unprivileged attribution
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< page privileged/unprivileged attribution
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x42020000;
    constexpr uint32_t SEC_GPIOA_BASE = 0x52020000;
    constexpr uint32_t GPIOB_BASE = 0x42020400;
    constexpr uint32_t SEC_GPIOB_BASE = 0x52020400;
    constexpr uint32_t GPIOC_BASE = 0x42020800;
    constexpr uint32_t SEC_GPIOC_BASE = 0x52020800;
    constexpr uint32_t GPIOD_BASE = 0x42020C00;
    constexpr uint32_t SEC_GPIOD_BASE = 0x52020C00;
    constexpr uint32_t GPIOE_BASE = 0x42021000;
    constexpr uint32_t SEC_GPIOE_BASE = 0x52021000;
    constexpr uint32_t GPIOF_BASE = 0x42021400;
    constexpr uint32_t SEC_GPIOF_BASE = 0x52021400;
    constexpr uint32_t GPIOG_BASE = 0x42021800;
    constexpr uint32_t SEC_GPIOG_BASE = 0x52021800;
    constexpr uint32_t GPIOH_BASE = 0x42021C00;
    constexpr uint32_t SEC_GPIOH_BASE = 0x52021C00;
    constexpr uint32_t GPIOI_BASE = 0x42022000;
    constexpr uint32_t SEC_GPIOI_BASE = 0x52022000;
    constexpr uint32_t LPGPIO1_BASE = 0x46020000;
    constexpr uint32_t SEC_LPGPIO1_BASE = 0x56020000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t GPIO_MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t GPIO_OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t GPIO_OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t GPIO_PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t GPIO_IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t GPIO_ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t GPIO_BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t GPIO_LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t GPIO_AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t GPIO_AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t GPIO_BRR;  ///< Offset: 0x28 - GPIO port bit reset register
        volatile uint32_t GPIO_HSLVR;  ///< Offset: 0x2C - GPIO high-speed low-voltage register
        volatile uint32_t GPIO_SECCFGR;  ///< Offset: 0x30 - GPIO secure configuration register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* SEC_GPIOA = reinterpret_cast<Registers*>(SEC_GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* SEC_GPIOB = reinterpret_cast<Registers*>(SEC_GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* SEC_GPIOC = reinterpret_cast<Registers*>(SEC_GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* SEC_GPIOD = reinterpret_cast<Registers*>(SEC_GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* SEC_GPIOE = reinterpret_cast<Registers*>(SEC_GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* SEC_GPIOF = reinterpret_cast<Registers*>(SEC_GPIOF_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);
    inline Registers* SEC_GPIOG = reinterpret_cast<Registers*>(SEC_GPIOG_BASE);
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* SEC_GPIOH = reinterpret_cast<Registers*>(SEC_GPIOH_BASE);
    inline Registers* GPIOI = reinterpret_cast<Registers*>(GPIOI_BASE);
    inline Registers* SEC_GPIOI = reinterpret_cast<Registers*>(SEC_GPIOI_BASE);
    inline Registers* LPGPIO1 = reinterpret_cast<Registers*>(LPGPIO1_BASE);
    inline Registers* SEC_LPGPIO1 = reinterpret_cast<Registers*>(SEC_LPGPIO1_BASE);

    // Bit definitions
    /// GPIO_MODER Register bits
    namespace gpio_moder_bits {
        constexpr uint32_t MODE0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_OTYPER Register bits
    namespace gpio_otyper_bits {
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_OSPEEDR Register bits
    namespace gpio_ospeedr_bits {
        constexpr uint32_t OSPEED0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_PUPDR Register bits
    namespace gpio_pupdr_bits {
        constexpr uint32_t PUPD0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_IDR Register bits
    namespace gpio_idr_bits {
        constexpr uint32_t ID0 = (1U << 0);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID1 = (1U << 1);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID2 = (1U << 2);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID3 = (1U << 3);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID4 = (1U << 4);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID5 = (1U << 5);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID6 = (1U << 6);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID7 = (1U << 7);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID8 = (1U << 8);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID9 = (1U << 9);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID10 = (1U << 10);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID11 = (1U << 11);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID12 = (1U << 12);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID13 = (1U << 13);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID14 = (1U << 14);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID15 = (1U << 15);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_ODR Register bits
    namespace gpio_odr_bits {
        constexpr uint32_t OD0 = (1U << 0);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD1 = (1U << 1);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD2 = (1U << 2);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD3 = (1U << 3);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD4 = (1U << 4);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD5 = (1U << 5);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD6 = (1U << 6);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD7 = (1U << 7);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD8 = (1U << 8);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD9 = (1U << 9);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD10 = (1U << 10);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD11 = (1U << 11);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD12 = (1U << 12);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD13 = (1U << 13);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD14 = (1U << 14);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD15 = (1U << 15);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing toGPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_BSRR Register bits
    namespace gpio_bsrr_bits {
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_LCKR Register bits
    namespace gpio_lckr_bits {
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCKK = (1U << 16);  ///< Lock key This bit can be read any time. It can only be modified using the lock key write sequence. - LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] - LOCK key read RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the lock key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the LOCK. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
    }

    /// GPIO_AFRL Register bits
    namespace gpio_afrl_bits {
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_AFRH Register bits
    namespace gpio_afrh_bits {
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_BRR Register bits
    namespace gpio_brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR1 = (1U << 1);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR2 = (1U << 2);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR3 = (1U << 3);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR4 = (1U << 4);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR5 = (1U << 5);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR6 = (1U << 6);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR7 = (1U << 7);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR8 = (1U << 8);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR9 = (1U << 9);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR10 = (1U << 10);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR11 = (1U << 11);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR12 = (1U << 12);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR13 = (1U << 13);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR14 = (1U << 14);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR15 = (1U << 15);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_HSLVR Register bits
    namespace gpio_hslvr_bits {
        constexpr uint32_t HSLV0 = (1U << 0);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV1 = (1U << 1);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV2 = (1U << 2);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV3 = (1U << 3);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV4 = (1U << 4);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV5 = (1U << 5);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV6 = (1U << 6);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV7 = (1U << 7);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV8 = (1U << 8);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV9 = (1U << 9);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV10 = (1U << 10);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV11 = (1U << 11);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV12 = (1U << 12);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV13 = (1U << 13);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV14 = (1U << 14);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV15 = (1U << 15);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_SECCFGR Register bits
    namespace gpio_seccfgr_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC1 = (1U << 1);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC2 = (1U << 2);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC3 = (1U << 3);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC4 = (1U << 4);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC5 = (1U << 5);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC6 = (1U << 6);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC7 = (1U << 7);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC8 = (1U << 8);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC9 = (1U << 9);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC10 = (1U << 10);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC11 = (1U << 11);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC12 = (1U << 12);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC13 = (1U << 13);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC14 = (1U << 14);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC15 = (1U << 15);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t SEC_I2C1_BASE = 0x50005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t SEC_I2C2_BASE = 0x50005800;
    constexpr uint32_t I2C3_BASE = 0x46002800;
    constexpr uint32_t SEC_I2C3_BASE = 0x56002800;
    constexpr uint32_t I2C4_BASE = 0x40008400;
    constexpr uint32_t SEC_I2C4_BASE = 0x50008400;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t I2C_AUTOCR;  ///< Offset: 0x2C - I2C Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* SEC_I2C1 = reinterpret_cast<Registers*>(SEC_I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* SEC_I2C2 = reinterpret_cast<Registers*>(SEC_I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);
    inline Registers* SEC_I2C3 = reinterpret_cast<Registers*>(SEC_I2C3_BASE);
    inline Registers* I2C4 = reinterpret_cast<Registers*>(I2C4_BASE);
    inline Registers* SEC_I2C4 = reinterpret_cast<Registers*>(SEC_I2C4_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
        constexpr uint32_t FMP = (1U << 24);  ///< Fast-mode Plus 20 mA drive enable
        constexpr uint32_t ADDRACLR = (1U << 30);  ///< Address match flag (ADDR) automatic clear
        constexpr uint32_t STOPFACLR = (1U << 31);  ///< STOP detection flag (STOPF) automatic clear
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

    /// I2C_AUTOCR Register bits
    namespace i2c_autocr_bits {
        constexpr uint32_t TCDMAEN = (1U << 6);  ///< DMA request enable on Transfer Complete event
        constexpr uint32_t TCRDMAEN = (1U << 7);  ///< DMA request enable on Transfer Complete Reload event
        constexpr uint32_t TRIGSEL = (4 << 16);  ///< Trigger selection
        constexpr uint32_t TRIGPOL = (1U << 20);  ///< Trigger polarity
        constexpr uint32_t TRIGEN = (1U << 21);  ///< Trigger enable
    }

}

// ============================================================================
// ICache Peripheral
// ============================================================================

namespace icache {
    /// Base addresses
    constexpr uint32_t ICache_BASE = 0x40030400;

    /// ICache Register structure
    struct Registers {
        volatile uint32_t ICACHE_CR;  ///< Offset: 0x00 - ICACHE control register
        volatile uint32_t ICACHE_SR;  ///< Offset: 0x04 - ICACHE status register
        volatile uint32_t ICACHE_IER;  ///< Offset: 0x08 - ICACHE interrupt enable register
        volatile uint32_t ICACHE_FCR;  ///< Offset: 0x0C - ICACHE flag clear register
        volatile uint32_t ICACHE_HMONR;  ///< Offset: 0x10 - ICACHE hit monitor register
        volatile uint32_t ICACHE_MMONR;  ///< Offset: 0x14 - ICACHE miss monitor register
        volatile uint32_t ICACHE_CRR0;  ///< Offset: 0x20 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR1;  ///< Offset: 0x24 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR2;  ///< Offset: 0x28 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR3;  ///< Offset: 0x2C - ICACHE region configuration register
    };

    /// Peripheral instances
    inline Registers* ICache = reinterpret_cast<Registers*>(ICache_BASE);

    // Bit definitions
    /// ICACHE_CR Register bits
    namespace icache_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t CACHEINV = (1U << 1);  ///< CACHEINV
        constexpr uint32_t WAYSEL = (1U << 2);  ///< WAYSEL
        constexpr uint32_t HITMEN = (1U << 16);  ///< HITMEN
        constexpr uint32_t MISSMEN = (1U << 17);  ///< MISSMEN
        constexpr uint32_t HITMRST = (1U << 18);  ///< HITMRST
        constexpr uint32_t MISSMRST = (1U << 19);  ///< MISSMRST
    }

    /// ICACHE_SR Register bits
    namespace icache_sr_bits {
        constexpr uint32_t BUSYF = (1U << 0);  ///< BUSYF
        constexpr uint32_t BSYENDF = (1U << 1);  ///< BSYENDF
        constexpr uint32_t ERRF = (1U << 2);  ///< ERRF
    }

    /// ICACHE_IER Register bits
    namespace icache_ier_bits {
        constexpr uint32_t BSYENDIE = (1U << 1);  ///< BSYENDIE
        constexpr uint32_t ERRIE = (1U << 2);  ///< ERRIE
    }

    /// ICACHE_FCR Register bits
    namespace icache_fcr_bits {
        constexpr uint32_t CBSYENDF = (1U << 1);  ///< CBSYENDF
        constexpr uint32_t CERRF = (1U << 2);  ///< CERRF
    }

    /// ICACHE_HMONR Register bits
    namespace icache_hmonr_bits {
        constexpr uint32_t HITMON = (32 << 0);  ///< HITMON
    }

    /// ICACHE_MMONR Register bits
    namespace icache_mmonr_bits {
        constexpr uint32_t MISSMON = (16 << 0);  ///< MISSMON
    }

    /// ICACHE_CRR0 Register bits
    namespace icache_crr0_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR1 Register bits
    namespace icache_crr1_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR2 Register bits
    namespace icache_crr2_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR3 Register bits
    namespace icache_crr3_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

}

// ============================================================================
// DCACHE Peripheral
// ============================================================================

namespace dcache {
    /// Base addresses
    constexpr uint32_t DCACHE_BASE = 0x40031400;

    /// DCACHE Register structure
    struct Registers {
        volatile uint32_t DCACHE_CR;  ///< Offset: 0x00 - DCACHE control register
        volatile uint32_t DCACHE_SR;  ///< Offset: 0x04 - DCACHE status register
        volatile uint32_t DCACHE_IER;  ///< Offset: 0x08 - DCACHE interrupt enable register
        volatile uint32_t DCACHE_FCR;  ///< Offset: 0x0C - DCACHE flag clear register
        volatile uint32_t DCACHE_RHMONR;  ///< Offset: 0x10 - DCACHE read-hit monitor register
        volatile uint32_t DCACHE_RMMONR;  ///< Offset: 0x14 - DCACHE read-miss monitor register
        volatile uint32_t DCACHE_WHMONR;  ///< Offset: 0x20 - write-hit monitor register
        volatile uint32_t DCACHE_WMMONR;  ///< Offset: 0x24 - write-miss monitor register
        volatile uint32_t DCACHE_CMDRSADDRR;  ///< Offset: 0x28 - command range start address register
        volatile uint32_t DCACHE_CMDREADDRR;  ///< Offset: 0x2C - command range start address register
    };

    /// Peripheral instances
    inline Registers* DCACHE = reinterpret_cast<Registers*>(DCACHE_BASE);

    // Bit definitions
    /// DCACHE_CR Register bits
    namespace dcache_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t CACHEINV = (1U << 1);  ///< CACHEINV
        constexpr uint32_t CACHECMD = (3 << 8);  ///< CACHECMD
        constexpr uint32_t STARTCMD = (1U << 11);  ///< STARTCMD
        constexpr uint32_t RHITMEN = (1U << 16);  ///< RHITMEN
        constexpr uint32_t RMISSMEN = (1U << 17);  ///< RMISSMEN
        constexpr uint32_t RHITMRST = (1U << 18);  ///< RHITMRST
        constexpr uint32_t RMISSMRST = (1U << 19);  ///< RMISSMRST
        constexpr uint32_t WHITMEN = (1U << 20);  ///< WHITMEN
        constexpr uint32_t WMISSMEN = (1U << 21);  ///< WMISSMEN
        constexpr uint32_t WHITMRST = (1U << 22);  ///< WHITMRST
        constexpr uint32_t WMISSMRST = (1U << 23);  ///< WMISSMRST
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// DCACHE_SR Register bits
    namespace dcache_sr_bits {
        constexpr uint32_t BUSYF = (1U << 0);  ///< BUSYF
        constexpr uint32_t BSYENDF = (1U << 1);  ///< BSYENDF
        constexpr uint32_t ERRF = (1U << 2);  ///< ERRF
        constexpr uint32_t BUSYCMDF = (1U << 3);  ///< BUSYCMDF
        constexpr uint32_t CMDENDF = (1U << 4);  ///< CMDENDF
    }

    /// DCACHE_IER Register bits
    namespace dcache_ier_bits {
        constexpr uint32_t BSYENDIE = (1U << 1);  ///< BSYENDIE
        constexpr uint32_t ERRIE = (1U << 2);  ///< ERRIE
        constexpr uint32_t CMDENDIE = (1U << 4);  ///< CMDENDIE
    }

    /// DCACHE_FCR Register bits
    namespace dcache_fcr_bits {
        constexpr uint32_t CBSYENDF = (1U << 1);  ///< CBSYENDF
        constexpr uint32_t CERRF = (1U << 2);  ///< CERRF
        constexpr uint32_t CCMDENDF = (1U << 4);  ///< CCMDENDF
    }

    /// DCACHE_RHMONR Register bits
    namespace dcache_rhmonr_bits {
        constexpr uint32_t RHITMON = (32 << 0);  ///< RHITMON
    }

    /// DCACHE_RMMONR Register bits
    namespace dcache_rmmonr_bits {
        constexpr uint32_t MRISSMON = (16 << 0);  ///< RMISSMON
    }

    /// DCACHE_WHMONR Register bits
    namespace dcache_whmonr_bits {
        constexpr uint32_t WHITMON = (32 << 0);  ///< WHITMON
    }

    /// DCACHE_WMMONR Register bits
    namespace dcache_wmmonr_bits {
        constexpr uint32_t WMISSMON = (16 << 0);  ///< WMISSMON
    }

    /// DCACHE_CMDRSADDRR Register bits
    namespace dcache_cmdrsaddrr_bits {
        constexpr uint32_t CMDSTARTADDR = (32 << 0);  ///< CMDSTARTADDR
    }

    /// DCACHE_CMDREADDRR Register bits
    namespace dcache_cmdreaddrr_bits {
        constexpr uint32_t CMDENDADDR = (32 << 0);  ///< CMDENDADDR
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t SEC_IWDG_BASE = 0x50003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;
    constexpr uint32_t SEC_WWDG_BASE = 0x50002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
        volatile uint32_t EWCR;  ///< Offset: 0x14 - IWDG early wakeup interrupt register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* SEC_IWDG = reinterpret_cast<Registers*>(SEC_IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);
    inline Registers* SEC_WWDG = reinterpret_cast<Registers*>(SEC_WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (4 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EWIF = (1U << 14);  ///< Watchdog Early interrupt flag
        constexpr uint32_t EWU = (1U << 3);  ///< Watchdog interrupt comparator value update
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

    /// EWCR Register bits
    namespace ewcr_bits {
        constexpr uint32_t EWIT = (12 << 0);  ///< Watchdog counter window value
        constexpr uint32_t EWIC = (1U << 14);  ///< Watchdog early interrupt acknowledge
        constexpr uint32_t EWIE = (1U << 15);  ///< Watchdog early interrupt enable
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t LPTIM1_BASE = 0x46004400;
    constexpr uint32_t SEC_LPTIM1_BASE = 0x56004400;
    constexpr uint32_t LPTIM2_BASE = 0x40009400;
    constexpr uint32_t SEC_LPTIM2_BASE = 0x50009400;
    constexpr uint32_t LPTIM3_BASE = 0x46004800;
    constexpr uint32_t SEC_LPTIM3_BASE = 0x56004800;
    constexpr uint32_t LPTIM4_BASE = 0x46004C00;
    constexpr uint32_t SEC_LPTIM4_BASE = 0x56004C00;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t SEC_TIM1_BASE = 0x50012C00;
    constexpr uint32_t TIM8_BASE = 0x40013400;
    constexpr uint32_t SEC_TIM8_BASE = 0x50013400;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t SEC_TIM2_BASE = 0x50000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t SEC_TIM3_BASE = 0x50000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;
    constexpr uint32_t SEC_TIM4_BASE = 0x50000800;
    constexpr uint32_t TIM5_BASE = 0x40000C00;
    constexpr uint32_t SEC_TIM5_BASE = 0x50000C00;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t SEC_TIM15_BASE = 0x50014000;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t SEC_TIM16_BASE = 0x50014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t SEC_TIM17_BASE = 0x50014800;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t SEC_TIM6_BASE = 0x50001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t SEC_TIM7_BASE = 0x50001400;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t ISR_output;  ///< Offset: 0x00 - Interrupt and Status Register (output mode)
        volatile uint32_t ISR_input;  ///< Offset: 0x00 - Interrupt and Status Register (intput mode)
        volatile uint32_t ICR_output;  ///< Offset: 0x04 - Interrupt Clear Register (output mode)
        volatile uint32_t ICR_input;  ///< Offset: 0x04 - Interrupt Clear Register (intput mode)
        volatile uint32_t DIER_output;  ///< Offset: 0x08 - LPTIM interrupt Enable Register (output mode)
        volatile uint32_t DIER_input;  ///< Offset: 0x08 - LPTIM interrupt Enable Register (intput mode)
        volatile uint32_t CFGR;  ///< Offset: 0x0C - Configuration Register
        volatile uint32_t CR;  ///< Offset: 0x10 - Control Register
        volatile uint32_t CCR1;  ///< Offset: 0x14 - Compare Register
        volatile uint32_t ARR;  ///< Offset: 0x18 - Autoreload Register
        volatile uint32_t CNT;  ///< Offset: 0x1C - Counter Register
        volatile uint32_t CFGR2;  ///< Offset: 0x24 - LPTIM configuration register 2
        volatile uint32_t RCR;  ///< Offset: 0x28 - LPTIM repetition register
        volatile uint32_t CCMR1;  ///< Offset: 0x2C - LPTIM capture/compare mode register 1
        volatile uint32_t CCR2;  ///< Offset: 0x34 - LPTIM Compare Register 2
        volatile uint32_t HWCFGR2;  ///< Offset: 0x3EC - LPTIM peripheral hardware configuration register 2
        volatile uint32_t HWCFGR1;  ///< Offset: 0x3F0 - LPTIM peripheral hardware configuration register 1
    };

    /// Peripheral instances
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* SEC_LPTIM1 = reinterpret_cast<Registers*>(SEC_LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* SEC_LPTIM2 = reinterpret_cast<Registers*>(SEC_LPTIM2_BASE);
    inline Registers* LPTIM3 = reinterpret_cast<Registers*>(LPTIM3_BASE);
    inline Registers* SEC_LPTIM3 = reinterpret_cast<Registers*>(SEC_LPTIM3_BASE);
    inline Registers* LPTIM4 = reinterpret_cast<Registers*>(LPTIM4_BASE);
    inline Registers* SEC_LPTIM4 = reinterpret_cast<Registers*>(SEC_LPTIM4_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* SEC_TIM1 = reinterpret_cast<Registers*>(SEC_TIM1_BASE);
    inline Registers* TIM8 = reinterpret_cast<Registers*>(TIM8_BASE);
    inline Registers* SEC_TIM8 = reinterpret_cast<Registers*>(SEC_TIM8_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* SEC_TIM2 = reinterpret_cast<Registers*>(SEC_TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* SEC_TIM3 = reinterpret_cast<Registers*>(SEC_TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);
    inline Registers* SEC_TIM4 = reinterpret_cast<Registers*>(SEC_TIM4_BASE);
    inline Registers* TIM5 = reinterpret_cast<Registers*>(TIM5_BASE);
    inline Registers* SEC_TIM5 = reinterpret_cast<Registers*>(SEC_TIM5_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* SEC_TIM15 = reinterpret_cast<Registers*>(SEC_TIM15_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* SEC_TIM16 = reinterpret_cast<Registers*>(SEC_TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* SEC_TIM17 = reinterpret_cast<Registers*>(SEC_TIM17_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* SEC_TIM6 = reinterpret_cast<Registers*>(SEC_TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* SEC_TIM7 = reinterpret_cast<Registers*>(SEC_TIM7_BASE);

    // Bit definitions
    /// ISR_output Register bits
    namespace isr_output_bits {
        constexpr uint32_t DIEROK = (1U << 24);  ///< Interrupt enable register update OK
        constexpr uint32_t CMP2OK = (1U << 19);  ///< Compare register 2 update OK
        constexpr uint32_t CC2IF = (1U << 9);  ///< Compare 2 interrupt flag
        constexpr uint32_t REPOK = (1U << 8);  ///< Repetition register update Ok
        constexpr uint32_t UE = (1U << 7);  ///< LPTIM update event occurred
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK
        constexpr uint32_t CMP1OK = (1U << 3);  ///< Compare register 1 update OK
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match
        constexpr uint32_t CC1IF = (1U << 0);  ///< Compare 1 interrupt flag
    }

    /// ISR_input Register bits
    namespace isr_input_bits {
        constexpr uint32_t DIEROK = (1U << 24);  ///< Interrupt enable register update OK
        constexpr uint32_t CC2OF = (1U << 13);  ///< Capture 2 over-capture flag
        constexpr uint32_t CC1OF = (1U << 12);  ///< Capture 1 over-capture flag
        constexpr uint32_t CC2IF = (1U << 9);  ///< Capture 2 interrupt flag
        constexpr uint32_t REPOK = (1U << 8);  ///< Repetition register update Ok
        constexpr uint32_t UE = (1U << 7);  ///< LPTIM update event occurred
        constexpr uint32_t DOWN = (1U << 6);  ///< Counter direction change up to down
        constexpr uint32_t UP = (1U << 5);  ///< Counter direction change down to up
        constexpr uint32_t ARROK = (1U << 4);  ///< Autoreload register update OK
        constexpr uint32_t EXTTRIG = (1U << 2);  ///< External trigger edge event
        constexpr uint32_t ARRM = (1U << 1);  ///< Autoreload match
        constexpr uint32_t CC1IF = (1U << 0);  ///< Compare 1 interrupt flag
    }

    /// ICR_output Register bits
    namespace icr_output_bits {
        constexpr uint32_t DIEROKCF = (1U << 24);  ///< Interrupt enable register update OK clear flag
        constexpr uint32_t CMP2OKCF = (1U << 19);  ///< Compare register 2 update OK clear flag
        constexpr uint32_t CC2CF = (1U << 9);  ///< Capture/compare 2 clear flag
        constexpr uint32_t REPOKCF = (1U << 8);  ///< Repetition register update OK clear flag
        constexpr uint32_t UECF = (1U << 7);  ///< Update event clear flag
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down Clear Flag
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP Clear Flag
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK Clear Flag
        constexpr uint32_t CMP1OKCF = (1U << 3);  ///< Compare register 1 update OK Clear Flag
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge Clear Flag
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match Clear Flag
        constexpr uint32_t CC1IF = (1U << 0);  ///< Capture/compare 1 clear flag
    }

    /// ICR_input Register bits
    namespace icr_input_bits {
        constexpr uint32_t DIEROKCF = (1U << 24);  ///< Interrupt enable register update OK clear flag
        constexpr uint32_t CC2OCF = (1U << 13);  ///< Capture/compare 2 over-capture clear flag
        constexpr uint32_t CC1OCF = (1U << 12);  ///< Capture/compare 1 over-capture clear flag
        constexpr uint32_t CC2CF = (1U << 9);  ///< Capture/compare 2 clear flag
        constexpr uint32_t REPOKCF = (1U << 8);  ///< Repetition register update OK clear flag
        constexpr uint32_t UECF = (1U << 7);  ///< Update event clear flag
        constexpr uint32_t DOWNCF = (1U << 6);  ///< Direction change to down Clear Flag
        constexpr uint32_t UPCF = (1U << 5);  ///< Direction change to UP Clear Flag
        constexpr uint32_t ARROKCF = (1U << 4);  ///< Autoreload register update OK Clear Flag
        constexpr uint32_t EXTTRIGCF = (1U << 2);  ///< External trigger valid edge Clear Flag
        constexpr uint32_t ARRMCF = (1U << 1);  ///< Autoreload match Clear Flag
        constexpr uint32_t CC1IF = (1U << 0);  ///< Capture/compare 1 clear flag
    }

    /// DIER_output Register bits
    namespace dier_output_bits {
        constexpr uint32_t UEDE = (1U << 23);  ///< Update event DMA request enable
        constexpr uint32_t CMP2OKIE = (1U << 19);  ///< Compare register 2 update OK interrupt enable
        constexpr uint32_t CC2IE = (1U << 9);  ///< Capture/compare 2 interrupt enable
        constexpr uint32_t REPOKIE = (1U << 8);  ///< REPOKIE
        constexpr uint32_t UEIE = (1U << 7);  ///< Update event interrupt enable
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t CMP1OKIE = (1U << 3);  ///< Compare register 1 update OK Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t CC1IF = (1U << 0);  ///< Capture/compare 1 clear flag
    }

    /// DIER_input Register bits
    namespace dier_input_bits {
        constexpr uint32_t CC2DE = (1U << 25);  ///< Capture/compare 2 DMA request enable
        constexpr uint32_t CC1DE = (1U << 16);  ///< Capture/compare 1 DMA request enable
        constexpr uint32_t CC2OIE = (1U << 13);  ///< Capture/compare 2 over-capture interrupt enable
        constexpr uint32_t CC1OIE = (1U << 12);  ///< Capture/compare 1 over-capture interrupt enable
        constexpr uint32_t CC2IE = (1U << 9);  ///< Capture/compare 2 interrupt enable
        constexpr uint32_t REPOKIE = (1U << 8);  ///< REPOKIE
        constexpr uint32_t UEIE = (1U << 7);  ///< Update event interrupt enable
        constexpr uint32_t DOWNIE = (1U << 6);  ///< Direction change to down Interrupt Enable
        constexpr uint32_t UPIE = (1U << 5);  ///< Direction change to UP Interrupt Enable
        constexpr uint32_t ARROKIE = (1U << 4);  ///< Autoreload register update OK Interrupt Enable
        constexpr uint32_t EXTTRIGIE = (1U << 2);  ///< External trigger valid edge Interrupt Enable
        constexpr uint32_t ARRMIE = (1U << 1);  ///< Autoreload match Interrupt Enable
        constexpr uint32_t CC1IF = (1U << 0);  ///< Capture/compare 1 clear flag
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t ENC = (1U << 24);  ///< Encoder mode enable
        constexpr uint32_t COUNTMODE = (1U << 23);  ///< counter mode enabled
        constexpr uint32_t PRELOAD = (1U << 22);  ///< Registers update mode
        constexpr uint32_t WAVPOL = (1U << 21);  ///< Waveform shape polarity
        constexpr uint32_t WAVE = (1U << 20);  ///< Waveform shape
        constexpr uint32_t TIMOUT = (1U << 19);  ///< Timeout enable
        constexpr uint32_t TRIGEN = (2 << 17);  ///< Trigger enable and polarity
        constexpr uint32_t TRIGSEL = (3 << 13);  ///< Trigger selector
        constexpr uint32_t PRESC = (3 << 9);  ///< Clock prescaler
        constexpr uint32_t TRGFLT = (2 << 6);  ///< Configurable digital filter for trigger
        constexpr uint32_t CKFLT = (2 << 3);  ///< Configurable digital filter for external clock
        constexpr uint32_t CKPOL = (2 << 1);  ///< Clock Polarity
        constexpr uint32_t CKSEL = (1U << 0);  ///< Clock selector
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RSTARE = (1U << 4);  ///< Reset after read enable
        constexpr uint32_t COUNTRST = (1U << 3);  ///< Counter reset
        constexpr uint32_t CNTSTRT = (1U << 2);  ///< Timer start in continuous mode
        constexpr uint32_t SNGSTRT = (1U << 1);  ///< LPTIM start in single mode
        constexpr uint32_t ENABLE = (1U << 0);  ///< LPTIM Enable
    }

    /// CCR1 Register bits
    namespace ccr1_bits {
        constexpr uint32_t CCR1 = (16 << 0);  ///< Capture/compare 1 value
    }

    /// ARR Register bits
    namespace arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< Auto reload value
    }

    /// CNT Register bits
    namespace cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< Counter value
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t IC2SEL = (2 << 20);  ///< LPTIM input capture 2 selection
        constexpr uint32_t IC1SEL = (2 << 16);  ///< LPTIM input capture 1 selection
        constexpr uint32_t IN2SEL = (2 << 4);  ///< LPTIM input 2 selection
        constexpr uint32_t IN1SEL = (2 << 0);  ///< LPTIM input 1 selection
    }

    /// RCR Register bits
    namespace rcr_bits {
        constexpr uint32_t REP = (8 << 0);  ///< Repetition register value
    }

    /// CCMR1 Register bits
    namespace ccmr1_bits {
        constexpr uint32_t CC1SEL = (1U << 0);  ///< Capture/compare 1 selection
        constexpr uint32_t CC1E = (1U << 1);  ///< Capture/compare 1 output enable
        constexpr uint32_t CC1P = (2 << 2);  ///< Capture/compare 1 output polarity
        constexpr uint32_t IC1PSC = (2 << 8);  ///< Input capture 1 prescaler
        constexpr uint32_t IC1F = (2 << 12);  ///< Input capture 1 filter
        constexpr uint32_t CC2SEL = (1U << 16);  ///< Capture/compare 2 selection
        constexpr uint32_t CC2E = (1U << 17);  ///< Capture/compare 2 output enable
        constexpr uint32_t CC2P = (2 << 18);  ///< Capture/compare 2 output polarity
        constexpr uint32_t IC2PSC = (2 << 24);  ///< Input capture 2 prescaler
        constexpr uint32_t IC2F = (2 << 28);  ///< Input capture 2 filter
    }

    /// CCR2 Register bits
    namespace ccr2_bits {
        constexpr uint32_t CCR2 = (16 << 0);  ///< Capture/compare 2 value
    }

    /// HWCFGR2 Register bits
    namespace hwcfgr2_bits {
        constexpr uint32_t CFG1 = (4 << 0);  ///< peripheral hardware configuration 1
        constexpr uint32_t CFG2 = (8 << 8);  ///< peripheral hardware configuration 2
        constexpr uint32_t CFG3 = (1U << 16);  ///< peripheral hardware configuration 3
    }

    /// HWCFGR1 Register bits
    namespace hwcfgr1_bits {
        constexpr uint32_t CFG1 = (8 << 0);  ///< peripheral hardware configuration 1
        constexpr uint32_t CFG2 = (8 << 8);  ///< peripheral hardware configuration 2
        constexpr uint32_t CFG3 = (4 << 16);  ///< peripheral hardware configuration 3
        constexpr uint32_t CFG4 = (8 << 24);  ///< peripheral hardware configuration 4
    }

}

// ============================================================================
// GTZC1 Peripheral
// ============================================================================

namespace gtzc1 {
    /// Base addresses
    constexpr uint32_t GTZC1_MPCBB1_BASE = 0x40032C00;
    constexpr uint32_t GTZC1_MPCBB2_BASE = 0x40033000;
    constexpr uint32_t GTZC1_MPCBB3_BASE = 0x40033400;
    constexpr uint32_t GTZC1_TZIC_BASE = 0x40032800;
    constexpr uint32_t GTZC1_TZSC_BASE = 0x40032400;

    /// GTZC1 Register structure
    struct Registers {
        volatile uint32_t MPCBB1_CR;  ///< Offset: 0x00 - MPCBB control register
        volatile uint32_t MPCBB1_CFGLOCKR1;  ///< Offset: 0x10 - GTZC1 SRAMz MPCBB configuration lock register
        volatile uint32_t MPCBB1_SECCFGR0;  ///< Offset: 0x100 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR1;  ///< Offset: 0x104 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR2;  ///< Offset: 0x108 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR3;  ///< Offset: 0x10C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR4;  ///< Offset: 0x110 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR5;  ///< Offset: 0x114 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR6;  ///< Offset: 0x118 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR7;  ///< Offset: 0x11C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR8;  ///< Offset: 0x120 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR9;  ///< Offset: 0x124 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR10;  ///< Offset: 0x128 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR11;  ///< Offset: 0x12C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR12;  ///< Offset: 0x130 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR13;  ///< Offset: 0x134 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR14;  ///< Offset: 0x138 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR15;  ///< Offset: 0x13C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR16;  ///< Offset: 0x140 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR17;  ///< Offset: 0x144 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR18;  ///< Offset: 0x148 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR19;  ///< Offset: 0x14C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR20;  ///< Offset: 0x150 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR21;  ///< Offset: 0x154 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR22;  ///< Offset: 0x158 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR23;  ///< Offset: 0x15C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR24;  ///< Offset: 0x160 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR25;  ///< Offset: 0x164 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR26;  ///< Offset: 0x168 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR27;  ///< Offset: 0x16C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR28;  ///< Offset: 0x170 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR29;  ///< Offset: 0x174 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR30;  ///< Offset: 0x178 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR31;  ///< Offset: 0x17C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR0;  ///< Offset: 0x200 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR1;  ///< Offset: 0x204 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR2;  ///< Offset: 0x208 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR3;  ///< Offset: 0x20C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR4;  ///< Offset: 0x210 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR5;  ///< Offset: 0x214 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR6;  ///< Offset: 0x218 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR7;  ///< Offset: 0x21C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR8;  ///< Offset: 0x220 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR9;  ///< Offset: 0x224 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR10;  ///< Offset: 0x228 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR11;  ///< Offset: 0x22C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR12;  ///< Offset: 0x230 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR13;  ///< Offset: 0x234 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR14;  ///< Offset: 0x238 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR15;  ///< Offset: 0x23C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR16;  ///< Offset: 0x240 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR17;  ///< Offset: 0x244 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR18;  ///< Offset: 0x248 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR19;  ///< Offset: 0x24C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR20;  ///< Offset: 0x250 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR21;  ///< Offset: 0x254 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR22;  ///< Offset: 0x258 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR23;  ///< Offset: 0x25C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR24;  ///< Offset: 0x260 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR25;  ///< Offset: 0x264 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR26;  ///< Offset: 0x268 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR27;  ///< Offset: 0x26C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR28;  ///< Offset: 0x270 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR29;  ///< Offset: 0x274 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR30;  ///< Offset: 0x278 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR31;  ///< Offset: 0x27C - MPCBB privileged configuration for super-block x register
    };

    /// Peripheral instances
    inline Registers* GTZC1_MPCBB1 = reinterpret_cast<Registers*>(GTZC1_MPCBB1_BASE);
    inline Registers* GTZC1_MPCBB2 = reinterpret_cast<Registers*>(GTZC1_MPCBB2_BASE);
    inline Registers* GTZC1_MPCBB3 = reinterpret_cast<Registers*>(GTZC1_MPCBB3_BASE);
    inline Registers* GTZC1_TZIC = reinterpret_cast<Registers*>(GTZC1_TZIC_BASE);
    inline Registers* GTZC1_TZSC = reinterpret_cast<Registers*>(GTZC1_TZSC_BASE);

    // Bit definitions
    /// MPCBB1_CR Register bits
    namespace mpcbb1_cr_bits {
        constexpr uint32_t GLOCK = (1U << 0);  ///< lock the control register of the MPCBB until next reset
        constexpr uint32_t INVSECSTATE = (1U << 30);  ///< SRAMx clocks security state
        constexpr uint32_t SRWILADIS = (1U << 31);  ///< secure read/write illegal access disable
    }

    /// MPCBB1_CFGLOCKR1 Register bits
    namespace mpcbb1_cfglockr1_bits {
        constexpr uint32_t SPLCK0 = (1U << 0);  ///< SPLCK0
        constexpr uint32_t SPLCK1 = (1U << 1);  ///< SPLCK1
        constexpr uint32_t SPLCK2 = (1U << 2);  ///< SPLCK2
        constexpr uint32_t SPLCK3 = (1U << 3);  ///< SPLCK3
        constexpr uint32_t SPLCK4 = (1U << 4);  ///< SPLCK4
        constexpr uint32_t SPLCK5 = (1U << 5);  ///< SPLCK5
        constexpr uint32_t SPLCK6 = (1U << 6);  ///< SPLCK6
        constexpr uint32_t SPLCK7 = (1U << 7);  ///< SPLCK7
        constexpr uint32_t SPLCK8 = (1U << 8);  ///< SPLCK8
        constexpr uint32_t SPLCK9 = (1U << 9);  ///< SPLCK9
        constexpr uint32_t SPLCK10 = (1U << 10);  ///< SPLCK10
        constexpr uint32_t SPLCK11 = (1U << 11);  ///< SPLCK11
        constexpr uint32_t SPLCK12 = (1U << 12);  ///< SPLCK12
        constexpr uint32_t SPLCK13 = (1U << 13);  ///< SPLCK13
        constexpr uint32_t SPLCK14 = (1U << 14);  ///< SPLCK14
        constexpr uint32_t SPLCK15 = (1U << 15);  ///< SPLCK15
        constexpr uint32_t SPLCK16 = (1U << 16);  ///< SPLCK16
        constexpr uint32_t SPLCK17 = (1U << 17);  ///< SPLCK17
        constexpr uint32_t SPLCK18 = (1U << 18);  ///< SPLCK18
        constexpr uint32_t SPLCK19 = (1U << 19);  ///< SPLCK19
        constexpr uint32_t SPLCK20 = (1U << 20);  ///< SPLCK20
        constexpr uint32_t SPLCK21 = (1U << 21);  ///< SPLCK21
        constexpr uint32_t SPLCK22 = (1U << 22);  ///< SPLCK22
        constexpr uint32_t SPLCK23 = (1U << 23);  ///< SPLCK23
        constexpr uint32_t SPLCK24 = (1U << 24);  ///< SPLCK24
        constexpr uint32_t SPLCK25 = (1U << 25);  ///< SPLCK25
        constexpr uint32_t SPLCK26 = (1U << 26);  ///< SPLCK26
        constexpr uint32_t SPLCK27 = (1U << 27);  ///< SPLCK27
        constexpr uint32_t SPLCK28 = (1U << 28);  ///< SPLCK28
        constexpr uint32_t SPLCK29 = (1U << 29);  ///< SPLCK29
        constexpr uint32_t SPLCK30 = (1U << 30);  ///< SPLCK30
        constexpr uint32_t SPLCK31 = (1U << 31);  ///< SPLCK31
    }

    /// MPCBB1_SECCFGR0 Register bits
    namespace mpcbb1_seccfgr0_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR1 Register bits
    namespace mpcbb1_seccfgr1_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR2 Register bits
    namespace mpcbb1_seccfgr2_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR3 Register bits
    namespace mpcbb1_seccfgr3_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR4 Register bits
    namespace mpcbb1_seccfgr4_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR5 Register bits
    namespace mpcbb1_seccfgr5_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR6 Register bits
    namespace mpcbb1_seccfgr6_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR7 Register bits
    namespace mpcbb1_seccfgr7_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR8 Register bits
    namespace mpcbb1_seccfgr8_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR9 Register bits
    namespace mpcbb1_seccfgr9_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR10 Register bits
    namespace mpcbb1_seccfgr10_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR11 Register bits
    namespace mpcbb1_seccfgr11_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR12 Register bits
    namespace mpcbb1_seccfgr12_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR13 Register bits
    namespace mpcbb1_seccfgr13_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR14 Register bits
    namespace mpcbb1_seccfgr14_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR15 Register bits
    namespace mpcbb1_seccfgr15_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR16 Register bits
    namespace mpcbb1_seccfgr16_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR17 Register bits
    namespace mpcbb1_seccfgr17_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR18 Register bits
    namespace mpcbb1_seccfgr18_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR19 Register bits
    namespace mpcbb1_seccfgr19_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR20 Register bits
    namespace mpcbb1_seccfgr20_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR21 Register bits
    namespace mpcbb1_seccfgr21_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR22 Register bits
    namespace mpcbb1_seccfgr22_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR23 Register bits
    namespace mpcbb1_seccfgr23_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR24 Register bits
    namespace mpcbb1_seccfgr24_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR25 Register bits
    namespace mpcbb1_seccfgr25_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR26 Register bits
    namespace mpcbb1_seccfgr26_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR27 Register bits
    namespace mpcbb1_seccfgr27_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR28 Register bits
    namespace mpcbb1_seccfgr28_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR29 Register bits
    namespace mpcbb1_seccfgr29_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR30 Register bits
    namespace mpcbb1_seccfgr30_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR31 Register bits
    namespace mpcbb1_seccfgr31_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_PRIVCFGR0 Register bits
    namespace mpcbb1_privcfgr0_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR1 Register bits
    namespace mpcbb1_privcfgr1_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR2 Register bits
    namespace mpcbb1_privcfgr2_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR3 Register bits
    namespace mpcbb1_privcfgr3_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR4 Register bits
    namespace mpcbb1_privcfgr4_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR5 Register bits
    namespace mpcbb1_privcfgr5_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR6 Register bits
    namespace mpcbb1_privcfgr6_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR7 Register bits
    namespace mpcbb1_privcfgr7_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR8 Register bits
    namespace mpcbb1_privcfgr8_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR9 Register bits
    namespace mpcbb1_privcfgr9_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR10 Register bits
    namespace mpcbb1_privcfgr10_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR11 Register bits
    namespace mpcbb1_privcfgr11_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR12 Register bits
    namespace mpcbb1_privcfgr12_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR13 Register bits
    namespace mpcbb1_privcfgr13_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR14 Register bits
    namespace mpcbb1_privcfgr14_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR15 Register bits
    namespace mpcbb1_privcfgr15_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR16 Register bits
    namespace mpcbb1_privcfgr16_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR17 Register bits
    namespace mpcbb1_privcfgr17_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR18 Register bits
    namespace mpcbb1_privcfgr18_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR19 Register bits
    namespace mpcbb1_privcfgr19_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR20 Register bits
    namespace mpcbb1_privcfgr20_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR21 Register bits
    namespace mpcbb1_privcfgr21_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR22 Register bits
    namespace mpcbb1_privcfgr22_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR23 Register bits
    namespace mpcbb1_privcfgr23_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR24 Register bits
    namespace mpcbb1_privcfgr24_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR25 Register bits
    namespace mpcbb1_privcfgr25_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR26 Register bits
    namespace mpcbb1_privcfgr26_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR27 Register bits
    namespace mpcbb1_privcfgr27_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR28 Register bits
    namespace mpcbb1_privcfgr28_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR29 Register bits
    namespace mpcbb1_privcfgr29_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR30 Register bits
    namespace mpcbb1_privcfgr30_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR31 Register bits
    namespace mpcbb1_privcfgr31_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

}

// ============================================================================
// GTZC2 Peripheral
// ============================================================================

namespace gtzc2 {
    /// Base addresses
    constexpr uint32_t GTZC2_MPCBB4_BASE = 0x46023800;
    constexpr uint32_t GTZC2_TZIC_BASE = 0x46023400;
    constexpr uint32_t GTZC2_TZSC_BASE = 0x46023000;

    /// GTZC2 Register structure
    struct Registers {
        volatile uint32_t MPCBB4_CR;  ///< Offset: 0x00 - MPCBB control register
        volatile uint32_t MPCBB4_CFGLOCK;  ///< Offset: 0x10 - GTZC2 SRAM4 MPCBB configuration lock register
        volatile uint32_t MPCBB4_SECCFGR0;  ///< Offset: 0x100 - MPCBB security configuration for super-block 0 register
        volatile uint32_t MPCBB4_PRIVCFGR0;  ///< Offset: 0x200 - MPCBB privileged configuration for super-block 0 register
    };

    /// Peripheral instances
    inline Registers* GTZC2_MPCBB4 = reinterpret_cast<Registers*>(GTZC2_MPCBB4_BASE);
    inline Registers* GTZC2_TZIC = reinterpret_cast<Registers*>(GTZC2_TZIC_BASE);
    inline Registers* GTZC2_TZSC = reinterpret_cast<Registers*>(GTZC2_TZSC_BASE);

    // Bit definitions
    /// MPCBB4_CR Register bits
    namespace mpcbb4_cr_bits {
        constexpr uint32_t GLOCK = (1U << 0);  ///< lock the control register of the MPCBB until next reset
        constexpr uint32_t INVSECSTATE = (1U << 30);  ///< SRAMx clocks security state
        constexpr uint32_t SRWILADIS = (1U << 31);  ///< secure read/write illegal access disable
    }

    /// MPCBB4_CFGLOCK Register bits
    namespace mpcbb4_cfglock_bits {
        constexpr uint32_t SPLCK0 = (1U << 0);  ///< Security/privilege configuration lock for super-block 0
    }

    /// MPCBB4_SECCFGR0 Register bits
    namespace mpcbb4_seccfgr0_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB4_PRIVCFGR0 Register bits
    namespace mpcbb4_privcfgr0_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x46020800;
    constexpr uint32_t SEC_PWR_BASE = 0x56020800;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWR_CR1;  ///< Offset: 0x00 - PWR control register 1
        volatile uint32_t PWR_CR2;  ///< Offset: 0x04 - PWR control register 2
        volatile uint32_t PWR_CR3;  ///< Offset: 0x08 - PWR control register 3
        volatile uint32_t PWR_VOSR;  ///< Offset: 0x0C - PWR voltage scaling register
        volatile uint32_t PWR_SVMCR;  ///< Offset: 0x10 - PWR supply voltage monitoring control register
        volatile uint32_t PWR_WUCR1;  ///< Offset: 0x14 - PWR wakeup control register 1
        volatile uint32_t PWR_WUCR2;  ///< Offset: 0x18 - PWR wakeup control register 2
        volatile uint32_t PWR_WUCR3;  ///< Offset: 0x1C - PWR wakeup control register 3
        volatile uint32_t PWR_BDCR1;  ///< Offset: 0x20 - PWR Backup domain control register 1
        volatile uint32_t PWR_BDCR2;  ///< Offset: 0x24 - PWR Backup domain control register 2
        volatile uint32_t PWR_DBPR;  ///< Offset: 0x28 - PWR disable Backup domain register
        volatile uint32_t PWR_UCPDR;  ///< Offset: 0x2C - PWR USB Type-C and Power Delivery register
        volatile uint32_t PWR_SECCFGR;  ///< Offset: 0x30 - PWR security configuration register
        volatile uint32_t PWR_PRIVCFGR;  ///< Offset: 0x34 - PWR privilege control register
        volatile uint32_t PWR_SR;  ///< Offset: 0x38 - PWR status register
        volatile uint32_t PWR_SVMSR;  ///< Offset: 0x3C - Regulator selection
        volatile uint32_t PWR_BDSR;  ///< Offset: 0x40 - PWR Backup domain status register
        volatile uint32_t PWR_WUSR;  ///< Offset: 0x44 - PWR wakeup status register
        volatile uint32_t PWR_WUSCR;  ///< Offset: 0x48 - PWR wakeup status clear register
        volatile uint32_t PWR_APCR;  ///< Offset: 0x4C - PWR apply pull configuration register
        volatile uint32_t PWR_PUCRA;  ///< Offset: 0x50 - PWR port A pull-up control register
        volatile uint32_t PWR_PDCRA;  ///< Offset: 0x54 - PWR port A pull-down control register
        volatile uint32_t PWR_PUCRB;  ///< Offset: 0x58 - PWR port B pull-up control register
        volatile uint32_t PWR_PDCRB;  ///< Offset: 0x5C - PWR port B pull-down control register
        volatile uint32_t PWR_PUCRC;  ///< Offset: 0x60 - PWR port C pull-up control register
        volatile uint32_t PWR_PDCRC;  ///< Offset: 0x64 - PWR port C pull-down control register
        volatile uint32_t PWR_PUCRD;  ///< Offset: 0x68 - PWR port D pull-up control register
        volatile uint32_t PWR_PDCRD;  ///< Offset: 0x6C - PWR port D pull-down control register
        volatile uint32_t PWR_PUCRE;  ///< Offset: 0x70 - PWR port E pull-up control register
        volatile uint32_t PWR_PDCRE;  ///< Offset: 0x74 - PWR port E pull-down control register
        volatile uint32_t PWR_PUCRF;  ///< Offset: 0x78 - PWR port F pull-up control register
        volatile uint32_t PWR_PDCRF;  ///< Offset: 0x7C - PWR port F pull-down control register
        volatile uint32_t PWR_PUCRG;  ///< Offset: 0x80 - PWR port G pull-up control register
        volatile uint32_t PWR_PDCRG;  ///< Offset: 0x84 - PWR port G pull-down control register
        volatile uint32_t PWR_PUCRH;  ///< Offset: 0x88 - PWR port H pull-up control register
        volatile uint32_t PWR_PDCRH;  ///< Offset: 0x8C - PWR port H pull-down control register
        volatile uint32_t PWR_PUCRI;  ///< Offset: 0x90 - PWR port I pull-up control register
        volatile uint32_t PWR_PDCRI;  ///< Offset: 0x94 - PWR port I pull-down control register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);
    inline Registers* SEC_PWR = reinterpret_cast<Registers*>(SEC_PWR_BASE);

    // Bit definitions
    /// PWR_CR1 Register bits
    namespace pwr_cr1_bits {
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection These bits select the low-power mode entered when the CPU enters the Deepsleep mode. 10x: Standby mode (Standby mode also entered if LPMS=11X in PWR_CR1 with BREN=1 in PWR_BDCR1) 11x: Shutdown mode if BREN = 0 in PWR_BDCR1
        constexpr uint32_t RRSB1 = (1U << 5);  ///< SRAM2 page 1 retention in Stop 3 and Standby modes This bit is used to keep the SRAM2 page 1 content in Stop 3 and Standby modes. The SRAM2 page 1 corresponds to the first 8 Kbytes of the SRAM2 (from SRAM2 base address to SRAM2 base address + 0x1FFF). Note: This bit has no effect in Shutdown mode.
        constexpr uint32_t RRSB2 = (1U << 6);  ///< SRAM2 page 2 retention in Stop 3 and Standby modes This bit is used to keep the SRAM2 page 2 content in Stop 3 and Standby modes. The SRAM2 page 2 corresponds to the last 56 Kbytes of the SRAM2 (from SRAM2 base address + 0x2000 to SRAM2 base address + 0xFFFF). Note: This bit has no effect in Shutdown mode.
        constexpr uint32_t ULPMEN = (1U << 7);  ///< BOR ultra-low power mode This bit is used to reduce the consumption by configuring the BOR in discontinuous mode. This bit must be set to reach the lowest power consumption in the low-power modes.
        constexpr uint32_t SRAM1PD = (1U << 8);  ///< SRAM1 power down This bit is used to reduce the consumption by powering off the SRAM1.
        constexpr uint32_t SRAM2PD = (1U << 9);  ///< SRAM2 power down This bit is used to reduce the consumption by powering off the SRAM2.
        constexpr uint32_t SRAM3PD = (1U << 10);  ///< SRAM3 power down This bit is used to reduce the consumption by powering off the SRAM3.
        constexpr uint32_t SRAM4PD = (1U << 11);  ///< SRAM4 power down This bit is used to reduce the consumption by powering off the SRAM4.
    }

    /// PWR_CR2 Register bits
    namespace pwr_cr2_bits {
        constexpr uint32_t SRAM1PDS1 = (1U << 0);  ///< SRAM1 page 1 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM1PDS2 = (1U << 1);  ///< SRAM1 page 2 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM1PDS3 = (1U << 2);  ///< SRAM1 page 3 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM2PDS1 = (1U << 4);  ///< SRAM2 page 1 (8 Kbytes) power-down in Stop modes (Stop 0, 1, 2) Note: The SRAM2 page 1 retention in Stop 3 is controlled by RRSB1 bit in PWR_CR1.
        constexpr uint32_t SRAM2PDS2 = (1U << 5);  ///< SRAM2 page 2 (56 Kbytes) power-down in Stop modes (Stop 0, 1, 2) Note: The SRAM2 page 2 retention in Stop 3 is controlled by RRSB2 bit in PWR_CR1.
        constexpr uint32_t SRAM4PDS = (1U << 6);  ///< SRAM4 power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t ICRAMPDS = (1U << 8);  ///< ICACHE SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t DC1RAMPDS = (1U << 9);  ///< DCACHE1 SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t DMA2DRAMPDS = (1U << 10);  ///< DMA2D SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t PRAMPDS = (1U << 11);  ///< FMAC, FDCAN and USB peripherals SRAM power-down in Stop modes (Stop0,1,2,3)
        constexpr uint32_t PKARAMPDS = (1U << 12);  ///< PKA SRAM power-down
        constexpr uint32_t SRAM4FWU = (1U << 13);  ///< SRAM4 fast wakeup from Stop 0, Stop 1 and Stop 2 modes This bit is used to obtain the best trade-off between low-power consumption and wakeup time. SRAM4 wakeup time increases the wakeup time when exiting Stop 0, 1 and 2 modes, and also increases the LPDMA access time to SRAM4 during Stop modes.
        constexpr uint32_t FLASHFWU = (1U << 14);  ///< Flash memory fast wakeup from Stop 0 and Stop 1 modes This bit is used to obtain the best trade-off between low-power consumption and wakeup time when exiting the Stop 0 or Stop 1 modes. When this bit is set, the Flash memory remains in normal mode in Stop 0 and Stop 1 modes, which offers a faster startup time with higher consumption.
        constexpr uint32_t SRAM3PDS1 = (1U << 16);  ///< SRAM3 page 1 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS2 = (1U << 17);  ///< SRAM3 page 2 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS3 = (1U << 18);  ///< SRAM3 page 3 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS4 = (1U << 19);  ///< SRAM3 page 4 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS5 = (1U << 20);  ///< SRAM3 page 5 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS6 = (1U << 21);  ///< SRAM3 page 6 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS7 = (1U << 22);  ///< SRAM3 page 7 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS8 = (1U << 23);  ///< SRAM3 page 8 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRDRUN = (1U << 31);  ///< SmartRun domain in Run mode
    }

    /// PWR_CR3 Register bits
    namespace pwr_cr3_bits {
        constexpr uint32_t REGSEL = (1U << 1);  ///< Regulator selection Note: REGSEL is reserved and must be kept at reset value in packages without SMPS.
        constexpr uint32_t FSTEN = (1U << 2);  ///< Fast soft start
    }

    /// PWR_VOSR Register bits
    namespace pwr_vosr_bits {
        constexpr uint32_t BOOSTRDY = (1U << 14);  ///< EPOD booster ready This bit is set to 1 by hardware when the power booster startup time is reached. The system clock frequency can be switched higher than 50 MHz only after this bit is set.
        constexpr uint32_t VOSRDY = (1U << 15);  ///< Ready bit for VCORE voltage scaling output selection
        constexpr uint32_t VOS = (2 << 16);  ///< Voltage scaling range selection This field is protected against non-secure access when SYSCLKSEC=1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC=1 in RCC_SECCFGR and SPRIV=1 in PWR_PRIVCFGR, or when SYSCLKSEC=0 and NSPRIV=1.
        constexpr uint32_t BOOSTEN = (1U << 18);  ///< EPOD booster enable
    }

    /// PWR_SVMCR Register bits
    namespace pwr_svmcr_bits {
        constexpr uint32_t PVDE = (1U << 4);  ///< Power voltage detector enable
        constexpr uint32_t PVDLS = (3 << 5);  ///< Power voltage detector level selection These bits select the voltage threshold detected by the power voltage detector:
        constexpr uint32_t UVMEN = (1U << 24);  ///< VDDUSB independent USB voltage monitor enable
        constexpr uint32_t IO2VMEN = (1U << 25);  ///< VDDIO2 independent I/Os voltage monitor enable
        constexpr uint32_t AVM1EN = (1U << 26);  ///< VDDA independent analog supply voltage monitor 1 enable (1.6V threshold)
        constexpr uint32_t AVM2EN = (1U << 27);  ///< VDDA independent analog supply voltage monitor 2 enable (1.8V threshold)
        constexpr uint32_t USV = (1U << 28);  ///< VDDUSB independent USB supply valid
        constexpr uint32_t IO2SV = (1U << 29);  ///< VDDIO2 independent I/Os supply valid This bit is used to validate the VDDIO2 supply for electrical and logical isolation purpose. Setting this bit is mandatory to use PG[15:2]. If VDDIO2 is not always present in the application, the VDDIO2 voltage monitor can be used to determine whether this supply is ready or not.
        constexpr uint32_t ASV = (1U << 30);  ///< VDDA independent analog supply valid
    }

    /// PWR_WUCR1 Register bits
    namespace pwr_wucr1_bits {
        constexpr uint32_t WUPEN1 = (1U << 0);  ///< Wakeup pin WKUP1 enable
        constexpr uint32_t WUPEN2 = (1U << 1);  ///< Wakeup pin WKUP2 enable
        constexpr uint32_t WUPEN3 = (1U << 2);  ///< Wakeup pin WKUP3 enable
        constexpr uint32_t WUPEN4 = (1U << 3);  ///< Wakeup pin WKUP4 enable
        constexpr uint32_t WUPEN5 = (1U << 4);  ///< Wakeup pin WKUP5 enable
        constexpr uint32_t WUPEN6 = (1U << 5);  ///< Wakeup pin WKUP6 enable
        constexpr uint32_t WUPEN7 = (1U << 6);  ///< Wakeup pin WKUP7 enable
        constexpr uint32_t WUPEN8 = (1U << 7);  ///< Wakeup pin WKUP8 enable
    }

    /// PWR_WUCR2 Register bits
    namespace pwr_wucr2_bits {
        constexpr uint32_t WUPP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity. This bit must be configured when WUPEN1 = 0.
        constexpr uint32_t WUPP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity This bit must be configured when WUPEN2 = 0.
        constexpr uint32_t WUPP3 = (1U << 2);  ///< Wakeup pin WKUP3 polarity This bit must be configured when WUPEN3 = 0.
        constexpr uint32_t WUPP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity This bit must be configured when WUPEN4 = 0.
        constexpr uint32_t WUPP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity This bit must be configured when WUPEN5 = 0.
        constexpr uint32_t WUPP6 = (1U << 5);  ///< Wakeup pin WKUP6 polarity This bit must be configured when WUPEN6 = 0.
        constexpr uint32_t WUPP7 = (1U << 6);  ///< Wakeup pin WKUP7 polarity This bit must be configured when WUPEN7 = 0.
        constexpr uint32_t WUPP8 = (1U << 7);  ///< Wakeup pin WKUP8 polarity This bit must be configured when WUPEN8=0.
    }

    /// PWR_WUCR3 Register bits
    namespace pwr_wucr3_bits {
        constexpr uint32_t WUSEL1 = (2 << 0);  ///< Wakeup pin WKUP1 selection This field must be configured when WUPEN1 = 0.
        constexpr uint32_t WUSEL2 = (2 << 2);  ///< Wakeup pin WKUP2 selection This field must be configured when WUPEN2 = 0.
        constexpr uint32_t WUSEL3 = (2 << 4);  ///< Wakeup pin WKUP3 selection This field must be configured when WUPEN3 = 0.
        constexpr uint32_t WUSEL4 = (2 << 6);  ///< Wakeup pin WKUP4 selection This field must be configured when WUPEN4 = 0.
        constexpr uint32_t WUSEL5 = (2 << 8);  ///< Wakeup pin WKUP5 selection This field must be configured when WUPEN5 = 0.
        constexpr uint32_t WUSEL6 = (2 << 10);  ///< Wakeup pin WKUP6 selection This field must be configured when WUPEN6 = 0.
        constexpr uint32_t WUSEL7 = (2 << 12);  ///< Wakeup pin WKUP7 selection This field must be configured when WUPEN7 = 0.
        constexpr uint32_t WUSEL8 = (2 << 14);  ///< Wakeup pin WKUP8 selection This field must be configured when WUPEN8 = 0.
    }

    /// PWR_BDCR1 Register bits
    namespace pwr_bdcr1_bits {
        constexpr uint32_t BREN = (1U << 0);  ///< Backup RAM retention in Standby and VBAT modes When this bit is set, the backup RAM content is kept in Standby and VBAT modes. If BREN is reset, the backup RAM can still be used in Run, Sleep and Stop modes. However, its content is lost in Standby, Shutdown and VBAT modes. This bit can be written only when the regulator is LDO, which must be configured before switching to SMPS. Note: Backup RAM cannot be preserved in Shutdown mode.
        constexpr uint32_t MONEN = (1U << 4);  ///< Backup domain voltage and temperature monitoring enable
    }

    /// PWR_BDCR2 Register bits
    namespace pwr_bdcr2_bits {
        constexpr uint32_t VBE = (1U << 0);  ///< VBAT charging enable
        constexpr uint32_t VBRS = (1U << 1);  ///< VBAT charging resistor selection
    }

    /// PWR_DBPR Register bits
    namespace pwr_dbpr_bits {
        constexpr uint32_t DBP = (1U << 0);  ///< Disable Backup domain write protection In reset state, all registers and SRAM in Backup domain are protected against parasitic write access. This bit must be set to enable the write access to these registers.
    }

    /// PWR_UCPDR Register bits
    namespace pwr_ucpdr_bits {
        constexpr uint32_t UCPD_DBDIS = (1U << 0);  ///< UCPD dead battery disable After exiting reset, the USB Type-C dead battery behavior is enabled, which may have a pull-down effect on CC1 and CC2 pins. It is recommended to disable it in all cases, either to stop this pull-down or to handover control to the UCPD (the UCPD must be initialized before doing the disable).
        constexpr uint32_t UCPD_STBY = (1U << 1);  ///< UCPD Standby mode When set, this bit is used to memorize the UCPD configuration in Standby mode. This bit must be written to 1 just before entering Standby mode when using UCPD. It must be written to 0 after exiting the Standby mode and before writing any UCPD registers.
    }

    /// PWR_SECCFGR Register bits
    namespace pwr_seccfgr_bits {
        constexpr uint32_t WUP1SEC = (1U << 0);  ///< WUP1 secure protection
        constexpr uint32_t WUP2SEC = (1U << 1);  ///< WUP2 secure protection
        constexpr uint32_t WUP3SEC = (1U << 2);  ///< WUP3 secure protection
        constexpr uint32_t WUP4SEC = (1U << 3);  ///< WUP4 secure protection
        constexpr uint32_t WUP5SEC = (1U << 4);  ///< WUP5 secure protection
        constexpr uint32_t WUP6SEC = (1U << 5);  ///< WUP6 secure protection
        constexpr uint32_t WUP7SEC = (1U << 6);  ///< WUP7 secure protection
        constexpr uint32_t WUP8SEC = (1U << 7);  ///< WUP8 secure protection
        constexpr uint32_t LPMSEC = (1U << 12);  ///< Low-power modes secure protection
        constexpr uint32_t VDMSEC = (1U << 13);  ///< Voltage detection and monitoring secure protection
        constexpr uint32_t VBSEC = (1U << 14);  ///< Backup domain secure protection
        constexpr uint32_t APCSEC = (1U << 15);  ///< Pull-up/pull-down secure protection
    }

    /// PWR_PRIVCFGR Register bits
    namespace pwr_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< PWR secure functions privilege configuration This bit is set and reset by software. It can be written only by a secure privileged access.
        constexpr uint32_t NSPRIV = (1U << 1);  ///< PWR non-secure functions privilege configuration This bit is set and reset by software. It can be written only by privileged access, secure or non-secure.
    }

    /// PWR_SR Register bits
    namespace pwr_sr_bits {
        constexpr uint32_t CSSF = (1U << 0);  ///< Clear Stop and Standby flags This bit is protected against non-secure access when LPMSEC=1 in PWR_SECCFGR. This bit is protected against unprivileged access when LPMSEC=1 and SPRIV=1 in PWR_PRIVCFGR, or when LPMSEC=0 and NSPRIV=1. Writing 1 to this bit clears the STOPF and SBF flags.
        constexpr uint32_t STOPF = (1U << 1);  ///< Stop flag This bit is set by hardware when the device enters a Stop mode, and is cleared by software by writing 1 to the CSSF bit.
        constexpr uint32_t SBF = (1U << 2);  ///< Standby flag This bit is set by hardware when the device enters the Standby mode, and is cleared by writing 1 to the CSSF bit, or by a power-on reset. It is not cleared by the system reset.
    }

    /// PWR_SVMSR Register bits
    namespace pwr_svmsr_bits {
        constexpr uint32_t REGS = (1U << 1);  ///< Regulator selection
        constexpr uint32_t PVDO = (1U << 4);  ///< VDD voltage detector output
        constexpr uint32_t ACTVOSRDY = (1U << 15);  ///< Voltage level ready for currently used VOS
        constexpr uint32_t ACTVOS = (2 << 16);  ///< VOS currently applied to VCORE This field provides the last VOS value.
        constexpr uint32_t VDDUSBRDY = (1U << 24);  ///< VDDUSB ready
        constexpr uint32_t VDDIO2RDY = (1U << 25);  ///< VDDIO2 ready
        constexpr uint32_t VDDA1RDY = (1U << 26);  ///< VDDA ready versus 1.6V voltage monitor
        constexpr uint32_t VDDA2RDY = (1U << 27);  ///< VDDA ready versus 1.8V voltage monitor
    }

    /// PWR_BDSR Register bits
    namespace pwr_bdsr_bits {
        constexpr uint32_t VBATH = (1U << 1);  ///< Backup domain voltage level monitoring versus high threshold
        constexpr uint32_t TEMPL = (1U << 2);  ///< Temperature level monitoring versus low threshold
        constexpr uint32_t TEMPH = (1U << 3);  ///< Temperature level monitoring versus high threshold
    }

    /// PWR_WUSR Register bits
    namespace pwr_wusr_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1 This bit is set when a wakeup event is detected on WKUP1 pin. This bit is cleared by writing 1 in the CWUF1 bit of PWR_WUSCR when WUSEL  11, or by hardware when WUPEN1=0.
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2 This bit is set when a wakeup event is detected on WKUP2 pin. This bit is cleared by writing 1 in the CWUF2 bit of PWR_WUSCR when WUSEL  11, or by hardware when WUPEN2=0.
        constexpr uint32_t WUF3 = (1U << 2);  ///< Wakeup flag 3 This bit is set when a wakeup event is detected on WKUP3 pin. This bit is cleared by writing 1 in the CWUF3 bit of PWR_WUSCR when WUSEL  11, or by hardware when WUPEN3=0.
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4 This bit is set when a wakeup event is detected on WKUP4 pin. This bit is cleared by writing 1 in the CWUF4 bit of PWR_WUSCR when WUSEL  11, or by hardware when WUPEN4=0.
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5 This bit is set when a wakeup event is detected on WKUP5 pin. This bit is cleared by writing 1 in the CWUF5 bit of PWR_WUSCR when WUSEL  11, or by hardware when WUPEN5=0.
        constexpr uint32_t WUF6 = (1U << 5);  ///< Wakeup flag 6 This bit is set when a wakeup event is detected on WKUP6 pin. This bit is cleared by writing 1 in the CWUF6 bit of PWR_WUSCR when WUSEL  11, or by hardware when WUPEN6=0. If WUSEL=11, this bit is cleared by hardware when all internal wakeup source are cleared.
        constexpr uint32_t WUF7 = (1U << 6);  ///< Wakeup flag 7 This bit is set when a wakeup event is detected on WKUP7 pin. This bit is cleared by writing 1 in the CWUF7 bit of PWR_WUSCR when WUSEL  11, or by hardware when WUPEN7=0. If WUSEL=11, this bit is cleared by hardware when all internal wakeup source are cleared.
        constexpr uint32_t WUF8 = (1U << 7);  ///< Wakeup flag 8 This bit is set when a wakeup event is detected on WKUP8 pin. This bit is cleared by writing 1 in the CWUF8 bit of PWR_WUSCR when WUSEL  11, or by hardware when WUPEN8=0. If WUSEL=11, this bit is cleared by hardware when all internal wakeup source are cleared.
    }

    /// PWR_WUSCR Register bits
    namespace pwr_wuscr_bits {
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Wakeup flag 1 Writing 1 to this bit clears the WUF1 flag in PWR_WUSR.
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Wakeup flag 2 Writing 1 to this bit clears the WUF2 flag in PWR_WUSR.
        constexpr uint32_t CWUF3 = (1U << 2);  ///< Wakeup flag 3 Writing 1 to this bit clears the WUF3 flag in PWR_WUSR.
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Wakeup flag 4 Writing 1 to this bit clears the WUF4 flag in PWR_WUSR.
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Wakeup flag 5 Writing 1 to this bit clears the WUF5 flag in PWR_WUSR.
        constexpr uint32_t CWUF6 = (1U << 5);  ///< Wakeup flag 6 Writing 1 to this bit clears the WUF6 flag in PWR_WUSR.
        constexpr uint32_t CWUF7 = (1U << 6);  ///< Wakeup flag 7 Writing 1 to this bit clears the WUF7 flag in PWR_WUSR.
        constexpr uint32_t CWUF8 = (1U << 7);  ///< Wakeup flag 8 Writing 1 to this bit clears the WUF8 flag in PWR_WUSR.
    }

    /// PWR_APCR Register bits
    namespace pwr_apcr_bits {
        constexpr uint32_t APC = (1U << 0);  ///< Apply pull-up and pull-down configuration When this bit is set, the I/O pull-up and pull-down configurations defined in PWR_PUCRx and PWR_PDCRx are applied. When this bit is cleared, PWR_PUCRx and PWR_PDCRx are not applied to the I/Os.
    }

    /// PWR_PUCRA Register bits
    namespace pwr_pucra_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port A pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port A pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port A pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port A pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port A pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port A pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port A pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port A pull-up bit
        constexpr uint32_t PU8 = (1U << 8);  ///< Port A pull-up bit
        constexpr uint32_t PU9 = (1U << 9);  ///< Port A pull-up bit
        constexpr uint32_t PU10 = (1U << 10);  ///< Port A pull-up bit
        constexpr uint32_t PU11 = (1U << 11);  ///< Port A pull-up bit
        constexpr uint32_t PU12 = (1U << 12);  ///< Port A pull-up bit
        constexpr uint32_t PU13 = (1U << 13);  ///< Port A pull-up bit
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit 15 When set, this bit activates the pull-up on PA15 when the APC bit is set in PWR_APCR. The pull-up is not activated if the corresponding PD15 bit is also set.
    }

    /// PWR_PDCRA Register bits
    namespace pwr_pdcra_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port A pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port A pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port A pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port A pull-down bit
        constexpr uint32_t PD4 = (1U << 4);  ///< Port A pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port A pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port A pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port A pull-down bit
        constexpr uint32_t PD8 = (1U << 8);  ///< Port A pull-down bit
        constexpr uint32_t PD9 = (1U << 9);  ///< Port A pull-down bit
        constexpr uint32_t PD10 = (1U << 10);  ///< Port A pull-down bit
        constexpr uint32_t PD11 = (1U << 11);  ///< Port A pull-down bit
        constexpr uint32_t PD12 = (1U << 12);  ///< Port A pull-down bit
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit
    }

    /// PWR_PUCRB Register bits
    namespace pwr_pucrb_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port B pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port B pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port B pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port B pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port B pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port B pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port B pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port B pull-up bit
        constexpr uint32_t PU8 = (1U << 8);  ///< Port B pull-up bit
        constexpr uint32_t PU9 = (1U << 9);  ///< Port B pull-up bit
        constexpr uint32_t PU10 = (1U << 10);  ///< Port B pull-up bit
        constexpr uint32_t PU11 = (1U << 11);  ///< Port B pull-up bit
        constexpr uint32_t PU12 = (1U << 12);  ///< Port B pull-up bit
        constexpr uint32_t PU13 = (1U << 13);  ///< Port B pull-up bit
        constexpr uint32_t PU14 = (1U << 14);  ///< Port B pull-up bit
        constexpr uint32_t PU15 = (1U << 15);  ///< Port B pull-up bit
    }

    /// PWR_PDCRB Register bits
    namespace pwr_pdcrb_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port B pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port B pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port B pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port B pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port B pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port B pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port B pull-down bit
        constexpr uint32_t PD8 = (1U << 8);  ///< Port B pull-down bit
        constexpr uint32_t PD9 = (1U << 9);  ///< Port B pull-down bit
        constexpr uint32_t PD10 = (1U << 10);  ///< Port B pull-down bit
        constexpr uint32_t PD11 = (1U << 11);  ///< Port B pull-down bit
        constexpr uint32_t PD12 = (1U << 12);  ///< Port B pull-down bit
        constexpr uint32_t PD13 = (1U << 13);  ///< Port B pull-down bit
        constexpr uint32_t PD14 = (1U << 14);  ///< Port B pull-down bit
        constexpr uint32_t PD15 = (1U << 15);  ///< Port B pull-down bit
    }

    /// PWR_PUCRC Register bits
    namespace pwr_pucrc_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port C pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port C pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port C pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port C pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port C pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port C pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port C pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port C pull-up bit
        constexpr uint32_t PU8 = (1U << 8);  ///< Port C pull-up bit
        constexpr uint32_t PU9 = (1U << 9);  ///< Port C pull-up bit
        constexpr uint32_t PU10 = (1U << 10);  ///< Port C pull-up bit
        constexpr uint32_t PU11 = (1U << 11);  ///< Port C pull-up bit
        constexpr uint32_t PU12 = (1U << 12);  ///< Port C pull-up bit
        constexpr uint32_t PU13 = (1U << 13);  ///< Port C pull-up bit
        constexpr uint32_t PU14 = (1U << 14);  ///< Port C pull-up bit
        constexpr uint32_t PU15 = (1U << 15);  ///< Port C pull-up bit
    }

    /// PWR_PDCRC Register bits
    namespace pwr_pdcrc_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port C pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port C pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port C pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port C pull-down bit
        constexpr uint32_t PD4 = (1U << 4);  ///< Port C pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port C pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port C pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port C pull-down bit
        constexpr uint32_t PD8 = (1U << 8);  ///< Port C pull-down bit
        constexpr uint32_t PD9 = (1U << 9);  ///< Port C pull-down bit
        constexpr uint32_t PD10 = (1U << 10);  ///< Port C pull-down bit
        constexpr uint32_t PD11 = (1U << 11);  ///< Port C pull-down bit
        constexpr uint32_t PD12 = (1U << 12);  ///< Port C pull-down bit
        constexpr uint32_t PD13 = (1U << 13);  ///< Port C pull-down bit
        constexpr uint32_t PD14 = (1U << 14);  ///< Port C pull-down bit
        constexpr uint32_t PD15 = (1U << 15);  ///< Port C pull-down bit
    }

    /// PWR_PUCRD Register bits
    namespace pwr_pucrd_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port D pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port D pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port D pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port D pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port D pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port D pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port D pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port D pull-up bit
        constexpr uint32_t PU8 = (1U << 8);  ///< Port D pull-up bit
        constexpr uint32_t PU9 = (1U << 9);  ///< Port D pull-up bit
        constexpr uint32_t PU10 = (1U << 10);  ///< Port D pull-up bit
        constexpr uint32_t PU11 = (1U << 11);  ///< Port D pull-up bit
        constexpr uint32_t PU12 = (1U << 12);  ///< Port D pull-up bit
        constexpr uint32_t PU13 = (1U << 13);  ///< Port D pull-up bit
        constexpr uint32_t PU14 = (1U << 14);  ///< Port D pull-up bit
        constexpr uint32_t PU15 = (1U << 15);  ///< Port D pull-up bit
    }

    /// PWR_PDCRD Register bits
    namespace pwr_pdcrd_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port D pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port D pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port D pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port D pull-down bit
        constexpr uint32_t PD4 = (1U << 4);  ///< Port D pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port D pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port D pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port D pull-down bit
        constexpr uint32_t PD8 = (1U << 8);  ///< Port D pull-down bit
        constexpr uint32_t PD9 = (1U << 9);  ///< Port D pull-down bit
        constexpr uint32_t PD10 = (1U << 10);  ///< Port D pull-down bit
        constexpr uint32_t PD11 = (1U << 11);  ///< Port D pull-down bit
        constexpr uint32_t PD12 = (1U << 12);  ///< Port D pull-down bit
        constexpr uint32_t PD13 = (1U << 13);  ///< Port D pull-down bit
        constexpr uint32_t PD14 = (1U << 14);  ///< Port D pull-down bit
        constexpr uint32_t PD15 = (1U << 15);  ///< Port D pull-down bit
    }

    /// PWR_PUCRE Register bits
    namespace pwr_pucre_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port E pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port E pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port E pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port E pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port E pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port E pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port E pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port E pull-up bit
        constexpr uint32_t PU8 = (1U << 8);  ///< Port E pull-up bit
        constexpr uint32_t PU9 = (1U << 9);  ///< Port E pull-up bit
        constexpr uint32_t PU10 = (1U << 10);  ///< Port E pull-up bit
        constexpr uint32_t PU11 = (1U << 11);  ///< Port E pull-up bit
        constexpr uint32_t PU12 = (1U << 12);  ///< Port E pull-up bit
        constexpr uint32_t PU13 = (1U << 13);  ///< Port E pull-up bit
        constexpr uint32_t PU14 = (1U << 14);  ///< Port E pull-up bit
        constexpr uint32_t PU15 = (1U << 15);  ///< Port E pull-up bit
    }

    /// PWR_PDCRE Register bits
    namespace pwr_pdcre_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port E pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port E pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port E pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port E pull-down bit
        constexpr uint32_t PD4 = (1U << 4);  ///< Port E pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port E pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port E pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port E pull-down bit
        constexpr uint32_t PD8 = (1U << 8);  ///< Port E pull-down bit
        constexpr uint32_t PD9 = (1U << 9);  ///< Port E pull-down bit
        constexpr uint32_t PD10 = (1U << 10);  ///< Port E pull-down bit
        constexpr uint32_t PD11 = (1U << 11);  ///< Port E pull-down bit
        constexpr uint32_t PD12 = (1U << 12);  ///< Port E pull-down bit
        constexpr uint32_t PD13 = (1U << 13);  ///< Port E pull-down bit
        constexpr uint32_t PD14 = (1U << 14);  ///< Port E pull-down bit
        constexpr uint32_t PD15 = (1U << 15);  ///< Port E pull-down bit
    }

    /// PWR_PUCRF Register bits
    namespace pwr_pucrf_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port F pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port F pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port F pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port F pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port F pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port F pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port F pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port F pull-up bit
        constexpr uint32_t PU8 = (1U << 8);  ///< Port F pull-up bit
        constexpr uint32_t PU9 = (1U << 9);  ///< Port F pull-up bit
        constexpr uint32_t PU10 = (1U << 10);  ///< Port F pull-up bit
        constexpr uint32_t PU11 = (1U << 11);  ///< Port F pull-up bit
        constexpr uint32_t PU12 = (1U << 12);  ///< Port F pull-up bit
        constexpr uint32_t PU13 = (1U << 13);  ///< Port F pull-up bit
        constexpr uint32_t PU14 = (1U << 14);  ///< Port F pull-up bit
        constexpr uint32_t PU15 = (1U << 15);  ///< Port F pull-up bit
    }

    /// PWR_PDCRF Register bits
    namespace pwr_pdcrf_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port F pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port F pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port F pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port F pull-down bit
        constexpr uint32_t PD4 = (1U << 4);  ///< Port F pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port F pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port F pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port F pull-down bit
        constexpr uint32_t PD8 = (1U << 8);  ///< Port F pull-down bit
        constexpr uint32_t PD9 = (1U << 9);  ///< Port F pull-down bit
        constexpr uint32_t PD10 = (1U << 10);  ///< Port F pull-down bit
        constexpr uint32_t PD11 = (1U << 11);  ///< Port F pull-down bit
        constexpr uint32_t PD12 = (1U << 12);  ///< Port F pull-down bit
        constexpr uint32_t PD13 = (1U << 13);  ///< Port F pull-down bit
        constexpr uint32_t PD14 = (1U << 14);  ///< Port F pull-down bit
        constexpr uint32_t PD15 = (1U << 15);  ///< Port F pull-down bit
    }

    /// PWR_PUCRG Register bits
    namespace pwr_pucrg_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port G pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port G pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port G pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port G pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port G pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port G pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port G pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port G pull-up bit
        constexpr uint32_t PU8 = (1U << 8);  ///< Port G pull-up bit
        constexpr uint32_t PU9 = (1U << 9);  ///< Port G pull-up bit
        constexpr uint32_t PU10 = (1U << 10);  ///< Port G pull-up bit
        constexpr uint32_t PU11 = (1U << 11);  ///< Port G pull-up bit
        constexpr uint32_t PU12 = (1U << 12);  ///< Port G pull-up bit
        constexpr uint32_t PU13 = (1U << 13);  ///< Port G pull-up bit
        constexpr uint32_t PU14 = (1U << 14);  ///< Port G pull-up bit
        constexpr uint32_t PU15 = (1U << 15);  ///< Port G pull-up bit
    }

    /// PWR_PDCRG Register bits
    namespace pwr_pdcrg_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port G pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port G pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port G pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port G pull-down bit
        constexpr uint32_t PD4 = (1U << 4);  ///< Port G pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port G pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port G pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port G pull-down bit
        constexpr uint32_t PD8 = (1U << 8);  ///< Port G pull-down bit
        constexpr uint32_t PD9 = (1U << 9);  ///< Port G pull-down bit
        constexpr uint32_t PD10 = (1U << 10);  ///< Port G pull-down bit
        constexpr uint32_t PD11 = (1U << 11);  ///< Port G pull-down bit
        constexpr uint32_t PD12 = (1U << 12);  ///< Port G pull-down bit
        constexpr uint32_t PD13 = (1U << 13);  ///< Port G pull-down bit
        constexpr uint32_t PD14 = (1U << 14);  ///< Port G pull-down bit
        constexpr uint32_t PD15 = (1U << 15);  ///< Port G pull-down bit
    }

    /// PWR_PUCRH Register bits
    namespace pwr_pucrh_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port H pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port H pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port H pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port H pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port H pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port H pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port H pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port H pull-up bit
        constexpr uint32_t PU8 = (1U << 8);  ///< Port H pull-up bit
        constexpr uint32_t PU9 = (1U << 9);  ///< Port H pull-up bit
        constexpr uint32_t PU10 = (1U << 10);  ///< Port H pull-up bit
        constexpr uint32_t PU11 = (1U << 11);  ///< Port H pull-up bit
        constexpr uint32_t PU12 = (1U << 12);  ///< Port H pull-up bit
        constexpr uint32_t PU13 = (1U << 13);  ///< Port H pull-up bit
        constexpr uint32_t PU14 = (1U << 14);  ///< Port H pull-up bit
        constexpr uint32_t PU15 = (1U << 15);  ///< Port H pull-up bit
    }

    /// PWR_PDCRH Register bits
    namespace pwr_pdcrh_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port H pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port H pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port H pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port H pull-down bit
        constexpr uint32_t PD4 = (1U << 4);  ///< Port H pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port H pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port H pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port H pull-down bit
        constexpr uint32_t PD8 = (1U << 8);  ///< Port H pull-down bit
        constexpr uint32_t PD9 = (1U << 9);  ///< Port H pull-down bit
        constexpr uint32_t PD10 = (1U << 10);  ///< Port H pull-down bit
        constexpr uint32_t PD11 = (1U << 11);  ///< Port H pull-down bit
        constexpr uint32_t PD12 = (1U << 12);  ///< Port H pull-down bit
        constexpr uint32_t PD13 = (1U << 13);  ///< Port H pull-down bit
        constexpr uint32_t PD14 = (1U << 14);  ///< Port H pull-down bit
        constexpr uint32_t PD15 = (1U << 15);  ///< Port H pull-down bit
    }

    /// PWR_PUCRI Register bits
    namespace pwr_pucri_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< Port I pull-up bit
        constexpr uint32_t PU1 = (1U << 1);  ///< Port I pull-up bit
        constexpr uint32_t PU2 = (1U << 2);  ///< Port I pull-up bit
        constexpr uint32_t PU3 = (1U << 3);  ///< Port I pull-up bit
        constexpr uint32_t PU4 = (1U << 4);  ///< Port I pull-up bit
        constexpr uint32_t PU5 = (1U << 5);  ///< Port I pull-up bit
        constexpr uint32_t PU6 = (1U << 6);  ///< Port I pull-up bit
        constexpr uint32_t PU7 = (1U << 7);  ///< Port I pull-up bit
    }

    /// PWR_PDCRI Register bits
    namespace pwr_pdcri_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< Port I pull-down bit
        constexpr uint32_t PD1 = (1U << 1);  ///< Port I pull-down bit
        constexpr uint32_t PD2 = (1U << 2);  ///< Port I pull-down bit
        constexpr uint32_t PD3 = (1U << 3);  ///< Port I pull-down bit
        constexpr uint32_t PD4 = (1U << 4);  ///< Port I pull-down bit
        constexpr uint32_t PD5 = (1U << 5);  ///< Port I pull-down bit
        constexpr uint32_t PD6 = (1U << 6);  ///< Port I pull-down bit
        constexpr uint32_t PD7 = (1U << 7);  ///< Port I pull-down bit
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x46020C00;
    constexpr uint32_t SEC_RCC_BASE = 0x56020C00;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t RCC_CR;  ///< Offset: 0x00 - RCC clock control register
        volatile uint32_t RCC_ICSCR1;  ///< Offset: 0x08 - RCC internal clock sources calibration register 1
        volatile uint32_t RCC_ICSCR2;  ///< Offset: 0x0C - RCC internal clock sources calibration register 2
        volatile uint32_t RCC_ICSCR3;  ///< Offset: 0x10 - RCC internal clock sources calibration register 3
        volatile uint32_t RCC_CRRCR;  ///< Offset: 0x14 - RCC clock recovery RC register
        volatile uint32_t RCC_CFGR1;  ///< Offset: 0x1C - RCC clock configuration register 1
        volatile uint32_t RCC_CFGR2;  ///< Offset: 0x20 - RCC clock configuration register 2
        volatile uint32_t RCC_CFGR3;  ///< Offset: 0x24 - RCC clock configuration register 3
        volatile uint32_t RCC_PLL1CFGR;  ///< Offset: 0x28 - RCC PLL1 configuration register
        volatile uint32_t RCC_PLL2CFGR;  ///< Offset: 0x2C - RCC PLL2 configuration register
        volatile uint32_t RCC_PLL3CFGR;  ///< Offset: 0x30 - RCC PLL3 configuration register
        volatile uint32_t RCC_PLL1DIVR;  ///< Offset: 0x34 - RCC PLL1 dividers register
        volatile uint32_t RCC_PLL1FRACR;  ///< Offset: 0x38 - RCC PLL1 fractional divider register
        volatile uint32_t RCC_PLL2DIVR;  ///< Offset: 0x3C - RCC PLL2 dividers configuration register
        volatile uint32_t RCC_PLL2FRACR;  ///< Offset: 0x40 - RCC PLL2 fractional divider register
        volatile uint32_t RCC_PLL3DIVR;  ///< Offset: 0x44 - RCC PLL3 dividers configuration register
        volatile uint32_t RCC_PLL3FRACR;  ///< Offset: 0x48 - RCC PLL3 fractional divider register
        volatile uint32_t RCC_CIER;  ///< Offset: 0x50 - RCC clock interrupt enable register
        volatile uint32_t RCC_CIFR;  ///< Offset: 0x54 - RCC clock interrupt flag register
        volatile uint32_t RCC_CICR;  ///< Offset: 0x58 - RCC clock interrupt clear register
        volatile uint32_t RCC_AHB1RSTR;  ///< Offset: 0x60 - RCC AHB1 peripheral reset register
        volatile uint32_t RCC_AHB2RSTR1;  ///< Offset: 0x64 - RCC AHB2 peripheral reset register 1
        volatile uint32_t RCC_AHB2RSTR2;  ///< Offset: 0x68 - RCC AHB2 peripheral reset register 2
        volatile uint32_t RCC_AHB3RSTR;  ///< Offset: 0x6C - RCC AHB3 peripheral reset register
        volatile uint32_t RCC_APB1RSTR1;  ///< Offset: 0x74 - RCC APB1 peripheral reset register 1
        volatile uint32_t RCC_APB1RSTR2;  ///< Offset: 0x78 - RCC APB1 peripheral reset register 2
        volatile uint32_t RCC_APB2RSTR;  ///< Offset: 0x7C - RCC APB2 peripheral reset register
        volatile uint32_t RCC_APB3RSTR;  ///< Offset: 0x80 - RCC APB3 peripheral reset register
        volatile uint32_t RCC_AHB1ENR;  ///< Offset: 0x88 - RCC AHB1 peripheral clock enable register
        volatile uint32_t RCC_AHB2ENR1;  ///< Offset: 0x8C - RCC AHB2 peripheral clock enable register 1
        volatile uint32_t RCC_AHB2ENR2;  ///< Offset: 0x90 - RCC AHB2 peripheral clock enable register 2
        volatile uint32_t RCC_AHB3ENR;  ///< Offset: 0x94 - RCC AHB3 peripheral clock enable register
        volatile uint32_t RCC_APB1ENR1;  ///< Offset: 0x9C - RCC APB1 peripheral clock enable register 1
        volatile uint32_t RCC_APB1ENR2;  ///< Offset: 0xA0 - RCC APB1 peripheral clock enable register 2
        volatile uint32_t RCC_APB2ENR;  ///< Offset: 0xA4 - RCC APB2 peripheral clock enable register
        volatile uint32_t RCC_APB3ENR;  ///< Offset: 0xA8 - RCC APB3 peripheral clock enable register
        volatile uint32_t RCC_AHB1SMENR;  ///< Offset: 0xB0 - RCC AHB1 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_AHB2SMENR1;  ///< Offset: 0xB4 - RCC AHB2 peripheral clock enable in Sleep and	Stop modes...
        volatile uint32_t RCC_AHB2SMENR2;  ///< Offset: 0xB8 - RCC AHB2 peripheral clock enable in Sleep and	Stop modes...
        volatile uint32_t RCC_AHB3SMENR;  ///< Offset: 0xBC - RCC AHB3 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_APB1SMENR1;  ///< Offset: 0xC4 - RCC APB1 peripheral clock enable in Sleep and Stop...
        volatile uint32_t RCC_APB1SMENR2;  ///< Offset: 0xC8 - RCC APB1 peripheral clocks enable in Sleep and	Stop...
        volatile uint32_t RCC_APB2SMENR;  ///< Offset: 0xCC - RCC APB2 peripheral clocks enable in Sleep and Stop...
        volatile uint32_t RCC_APB3SMENR;  ///< Offset: 0xD0 - RCC APB3 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_SRDAMR;  ///< Offset: 0xD8 - RCC SmartRun domain peripheral autonomous mode register
        volatile uint32_t RCC_CCIPR1;  ///< Offset: 0xE0 - RCC peripherals independent clock configuration register 1
        volatile uint32_t RCC_CCIPR2;  ///< Offset: 0xE4 - RCC peripherals independent clock configuration register 2
        volatile uint32_t RCC_CCIPR3;  ///< Offset: 0xE8 - RCC peripherals independent clock configuration register 3
        volatile uint32_t RCC_BDCR;  ///< Offset: 0xF0 - RCC backup domain control register
        volatile uint32_t RCC_CSR;  ///< Offset: 0xF4 - RCC control/status register
        volatile uint32_t RCC_SECCFGR;  ///< Offset: 0x110 - RCC secure configuration register
        volatile uint32_t RCC_PRIVCFGR;  ///< Offset: 0x114 - RCC privilege configuration register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);
    inline Registers* SEC_RCC = reinterpret_cast<Registers*>(SEC_RCC_BASE);

    // Bit definitions
    /// RCC_CR Register bits
    namespace rcc_cr_bits {
        constexpr uint32_t MSISON = (1U << 0);  ///< MSIS clock enable This bit is set and cleared by software. It is cleared by hardware to stop the MSIS oscillator when entering Stop, Standby or Shutdown mode. This bit is set by hardware to force theMSIS oscillator on when exiting Standby or Shutdown mode. It is set by hardware to force the MSIS oscillator ON when STOPWUCK = 0 when exiting Stop modes, or in case of a failure of the HSE oscillator. Set by hardware when used directly or indirectly as system clock.
        constexpr uint32_t MSIKERON = (1U << 1);  ///< MSI enable for some peripheral kernels This bit is set and cleared by software to force MSI ON even in Stop modes. Keeping the MSI on in Stop mode allows the communication speed not to be reduced by the MSI startup time. This bit has no effect on MSISON and MSIKON values (see Section11.4.24 for more details). This bit must be configured at 0 before entering Stop 3 mode.
        constexpr uint32_t MSISRDY = (1U << 2);  ///< MSIS clock ready flag This bit is set by hardware to indicate that the MSIS oscillator is stable. It is set only when MSIS is enabled by software (by setting MSISON). Note: Once the MSISON bit is cleared, MSISRDY goes low after six MSIS clock cycles.
        constexpr uint32_t MSIPLLEN = (1U << 3);  ///< MSI clock PLL-mode enable This bit is set and cleared by software to enable/disable the PLL part of the MSI clock source. MSIPLLEN must be enabled after LSE is enabled (LSEON enabled) and ready (LSERDY set by hardware). A hardware protection prevents from enabling MSIPLLEN if LSE is not ready. This bit is cleared by hardware when LSE is disabled (LSEON = 0) or when the CSS on LSE detects a LSE failure (see RCC_CSR).
        constexpr uint32_t MSIKON = (1U << 4);  ///< MSIK clock enable This bit is set and cleared by software. It is cleared by hardware to stop the MSIK when entering Stop, Standby, or Shutdown mode. This bit is set by hardware to force the MSIK oscillator ON when exiting Standby or Shutdown mode. It is set by hardware to force the MSIK oscillator on when STOPWUCK = 0 or STOPKERWUCK=0 when exiting Stop modes, or in case of a failure of the HSE oscillator.
        constexpr uint32_t MSIKRDY = (1U << 5);  ///< MSIK clock ready flag This bit is set by hardware to indicate that the MSIK is stable. It is set only when MSI kernel oscillator is enabled by software by setting MSIKON. Note: Once MSIKON bit is cleared, MSIKRDY goes low after six MSIK oscillator clock cycles.
        constexpr uint32_t MSIPLLSEL = (1U << 6);  ///< MSI clock with PLL mode selection This bit is set and cleared by software to select which MSI output clock uses the PLL mode. Itcan be written only when the MSI PLL mode is disabled (MSIPLLEN = 0). Note: If the MSI kernel clock output uses the same oscillator source than the MSI system clock output, then the PLL mode is applied to both clock outputs.
        constexpr uint32_t MSIPLLFAST = (1U << 7);  ///< MSI PLL mode fast startup This bit is set and reset by software to enable/disable the fast PLL mode start-up of the MSI clock source. This bit is used only if PLL mode is selected (MSIPLLEN = 1). The fast start-up feature is not active the first time the PLL mode is selected. Thefast start-up is active when the MSI in PLL mode returns from switch off.
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSI16 oscillator when entering Stop, Standby, or Shutdown mode. This bit is set by hardware to force theHSI16 oscillator on when STOPWUCK = 1 when leaving Stop modes, or in case of failure of the HSE crystal oscillator. This bit is set by hardware if the HSI16 is used directly or indirectly as system clock.
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 enable for some peripheral kernels This bit is set and cleared by software to force HSI16 ON even in Stop modes. Keeping HSI16 on in Stop mode allows the communication speed not to be reduced by the HSI16 startup time. This bit has no effect on HSION value. Refer to Section11.4.24 for more details. This bit must be configured at 0 before entering Stop 3 mode.
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag This bit is set by hardware to indicate that HSI16 oscillator is stable. It is set only when HSI16 is enabled by software (by setting HSION). Note: Once the HSION bit is cleared, HSIRDY goes low after six HSI16 clock cycles.
        constexpr uint32_t HSI48ON = (1U << 12);  ///< HSI48 clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSI48 when entering in Stop, Standby, or Shutdown modes.
        constexpr uint32_t HSI48RDY = (1U << 13);  ///< HSI48 clock ready flag This bit is set by hardware to indicate that HSI48 oscillator is stable. Itis set only when HSI48 is enabled by software (by setting HSI48ON).
        constexpr uint32_t SHSION = (1U << 14);  ///< SHSI clock enable This bit is set and cleared by software. It is cleared by hardware to stop the SHSI when entering in Stop, Standby, or Shutdown modes.
        constexpr uint32_t SHSIRDY = (1U << 15);  ///< SHSI clock ready flag This bit is set by hardware to indicate that the SHSI oscillator is stable. It is set only when SHSI is enabled by software (by setting SHSION). Note: Once the SHSION bit is cleared, SHSIRDY goes low after six SHSI clock cycles.
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSE oscillator when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag This bit is set by hardware to indicate that the HSE oscillator is stable. Note: Once the HSEON bit is cleared, HSERDY goes low after six HSE clock cycles.
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass This bit is set and cleared by software to bypass the oscillator with an external clock. Theexternal clock must be enabled with the HSEON bit set, to be used by the device. Thisbit can be written only if the HSE oscillator is disabled.
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable This bit is set by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset.
        constexpr uint32_t HSEEXT = (1U << 20);  ///< HSE external clock bypass mode This bit is set and reset by software to select the external clock mode in bypass mode. External clock mode must be configured with HSEON bit to be used by the device. This bit can be written only if the HSE oscillator is disabled. This bit is active only if the HSE bypass mode is enabled.
        constexpr uint32_t PLL1ON = (1U << 24);  ///< PLL1 enable This bit is set and cleared by software to enable the main PLL. It is cleared by hardware when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the PLL1 clock is used as the system clock.
        constexpr uint32_t PLL1RDY = (1U << 25);  ///< PLL1 clock ready flag This bit is set by hardware to indicate that the PLL1 is locked.
        constexpr uint32_t PLL2ON = (1U << 26);  ///< PLL2 enable This bit is set and cleared by software to enable PLL2. It is cleared by hardware when entering Stop, Standby, or Shutdown mode.
        constexpr uint32_t PLL2RDY = (1U << 27);  ///< PLL2 clock ready flag This bit is set by hardware to indicate that the PLL2 is locked.
        constexpr uint32_t PLL3ON = (1U << 28);  ///< PLL3 enable This bit is set and cleared by software to enable PLL3. It is cleared by hardware when entering Stop, Standby, or Shutdown mode.
        constexpr uint32_t PLL3RDY = (1U << 29);  ///< PLL3 clock ready flag This bit is set by hardware to indicate that the PLL3 is locked.
    }

    /// RCC_ICSCR1 Register bits
    namespace rcc_icscr1_bits {
        constexpr uint32_t MSICAL3 = (5 << 0);  ///< MSIRC3 clock calibration for MSI ranges 12 to 15 These bits are initialized at startup with the factory-programmed MSIRC3 calibration trim value for ranges 12 to 15. When MSITRIM3 is written, MSICAL3 is updated with the sum of MSITRIM3[4:0] and the factory calibration trim value MSIRC2[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL2 = (5 << 5);  ///< MSIRC2 clock calibration for MSI ranges 8 to 11 These bits are initialized at startup with the factory-programmed MSIRC2 calibration trim value for ranges 8 to 11. When MSITRIM2 is written, MSICAL2 is updated with the sum of MSITRIM2[4:0] and the factory calibration trim value MSIRC2[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL1 = (5 << 10);  ///< MSIRC1 clock calibration for MSI ranges 4 to 7 These bits are initialized at startup with the factory-programmed MSIRC1 calibration trim value for ranges 4 to 7. When MSITRIM1 is written, MSICAL1 is updated with the sum of MSITRIM1[4:0] and the factory calibration trim value MSIRC1[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL0 = (5 << 15);  ///< MSIRC0 clock calibration for MSI ranges 0 to 3 These bits are initialized at startup with the factory-programmed MSIRC0 calibration trim value for ranges 0 to 3. When MSITRIM0 is written, MSICAL0 is updated with the sum of MSITRIM0[4:0] and the factory-programmed calibration trim value MSIRC0[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSIBIAS = (1U << 22);  ///< MSI bias mode selection This bit is set by software to select the MSI bias mode. By default, the MSI bias is incontinuous mode in order to maintain the output clocks accuracy. Setting this bit reduces the MSI consumption when the regulator is in range 4, or when the device is in Stop 1 or Stop2 mode, but itdecreases the MSI accuracy
        constexpr uint32_t MSIRGSEL = (1U << 23);  ///< MSI clock range selection This bit is set by software to select the MSIS and MSIK clocks range with MSISRANGE[3:0] and MSIKRANGE[3:0]. Write 0 has no effect. After exiting Standby or Shutdown mode, or after a reset, this bit is at 0 and the MSIS and MSIK ranges are provided by MSISSRANGE[3:0] and MSIKSRANGE[3:0] in RCC_CSR.
        constexpr uint32_t MSIKRANGE = (4 << 24);  ///< MSIK clock ranges These bits are configured by software to choose the frequency range of MSIK oscillator when MSIRGSEL is set. 16 frequency ranges are available: Note: MSIKRANGE can be modified when MSIK is off (MSISON = 0) or when MSIK is ready (MSIKRDY=1). MSIKRANGE must NOT be modified when MSIK is on and NOT ready (MSIKON = 1 and MSIKRDY = 0) Note: MSIKRANGE is kept when the device wakes up from Stop mode, except when theMSIK range is above 24 MHz. In this case MSIKRANGE is changed by hardware intorange 2 (24 MHz).
        constexpr uint32_t MSISRANGE = (4 << 28);  ///< MSIS clock ranges These bits are configured by software to choose the frequency range of MSIS oscillator when MSIRGSEL is set. 16 frequency ranges are available: Note: MSISRANGE can be modified when MSIS is off (MSISON = 0) or when MSIS is ready (MSISRDY=1). MSISRANGE must NOT be modified when MSIS is on and NOT ready (MSISON=1 and MSISRDY=0) Note: MSISRANGE is kept when the device wakes up from Stop mode, except when theMSIS range is above 24 MHz. In this case MSISRANGE is changed by hardware into range 2 (24 MHz).
    }

    /// RCC_ICSCR2 Register bits
    namespace rcc_icscr2_bits {
        constexpr uint32_t MSITRIM3 = (5 << 0);  ///< MSI clock trimming for ranges 12 to 15 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC3[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM2 = (5 << 5);  ///< MSI clock trimming for ranges 8 to 11 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC2[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM1 = (5 << 10);  ///< MSI clock trimming for ranges 4 to 7 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC1[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM0 = (5 << 15);  ///< MSI clock trimming for ranges 0 to 3 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC0[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
    }

    /// RCC_ICSCR3 Register bits
    namespace rcc_icscr3_bits {
        constexpr uint32_t HSICAL = (12 << 0);  ///< HSI clock calibration These bits are initialized at startup with the factory-programmed HSI calibration trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value.
        constexpr uint32_t HSITRIM = (5 << 16);  ///< HSI clock trimming These bits provide an additional user-programmable trimming value that is added to HSICAL[11:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the HSI.
    }

    /// RCC_CRRCR Register bits
    namespace rcc_crrcr_bits {
        constexpr uint32_t HSI48CAL = (9 << 0);  ///< HSI48 clock calibration These bits are initialized at startup with the factory-programmed HSI48 calibration trim value.
    }

    /// RCC_CFGR1 Register bits
    namespace rcc_cfgr1_bits {
        constexpr uint32_t SW = (2 << 0);  ///< system clock switch This bitfield is set and cleared by software to select system clock source (SYSCLK). It is configured by hardware to force MSIS oscillator selection when exiting Standby or Shutdown mode. This bitfield is configured by hardware to force MSIS or HSI16 oscillator selection when exiting Stop mode or in case of HSE oscillator failure, depending on STOPWUCK.
        constexpr uint32_t SWS = (2 << 2);  ///< system clock switch status This bitfield is set and cleared by hardware to indicate which clock source is used as system clock.
        constexpr uint32_t STOPWUCK = (1U << 4);  ///< wake-up from Stop and CSS backup clock selection This bit is set and cleared by software to select the system clock used when exiting Stop mode. The selected clock is also used as emergency clock for the clock security system onHSE. STOPWUCK must not be modified when the CSS is enabled by HSECSSON inRCC_CR, and the system clock is HSE (SWS = 10) or a switch on HSE isrequested (SW=10).
        constexpr uint32_t STOPKERWUCK = (1U << 5);  ///< wake-up from Stop kernel clock automatic enable selection This bit is set and cleared by software to enable automatically another oscillator when exiting Stop mode. This oscillator can be used as independent kernel clock by peripherals.
        constexpr uint32_t MCOSEL = (4 << 24);  ///< microcontroller clock output This bitfield is set and cleared by software. Others: reserved Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.
        constexpr uint32_t MCOPRE = (3 << 28);  ///< microcontroller clock output prescaler This bitfield is set and cleared by software. It is highly recommended to change this prescaler before MCO output is enabled. Others: not allowed
    }

    /// RCC_CFGR2 Register bits
    namespace rcc_cfgr2_bits {
        constexpr uint32_t HPRE = (4 << 0);  ///< AHB prescaler This bitfiled is set and cleared by software to control the division factor of the AHB clock (HCLK). Depending on the device voltage range, the software must set these bits correctly to ensure that the system frequency does not exceed the maximum allowed frequency (for more details, refer to Table118). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account. 0xxx: SYSCLK not divided
        constexpr uint32_t PPRE1 = (3 << 4);  ///< APB1 prescaler This bitfiled is set and cleared by software to control the division factor of APB1 clock (PCLK1). 0xx: PCLK1 not divided
        constexpr uint32_t PPRE2 = (3 << 8);  ///< APB2 prescaler This bitfiled is set and cleared by software to control the division factor of APB2 clock (PCLK2). 0xx: PCLK2 not divided
        constexpr uint32_t DPRE = (3 << 12);  ///< DSI PHY prescaler This bitfiled is set and cleared by software to control the division factor of DSI PHY bus clock (DCLK). 0xx: DCLK not divided Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t AHB1DIS = (1U << 16);  ///< AHB1 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB1 peripherals (except those listed hereafter) are used and when their clocks are disabled in RCC_AHB1ENR. When this bit is set, all the AHB1 peripherals clocks are off, except for FLASH, BKPSRAM, ICACHE, DCACHE1 and SRAM1.
        constexpr uint32_t AHB2DIS1 = (1U << 17);  ///< AHB2_1 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB2 peripherals from RCC_AHB2ENR1 (except SRAM2 and SRAM3) are used and when their clocks are disabled in RCC_AHB2ENR1. When this bit is set, all the AHB2 peripherals clocks from RCC_AHB2ENR1 are off, except for SRAM2 and SRAM3.
        constexpr uint32_t AHB2DIS2 = (1U << 18);  ///< AHB2_2 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB2 peripherals from RCC_AHB2ENR2 are used and when their clocks are disabled in RCC_AHB2ENR2. When this bit is set, all the AHB2 peripherals clocks from RCC_AHB2ENR2 are off.
        constexpr uint32_t APB1DIS = (1U << 19);  ///< APB1 clock disable This bit can be set in order to further reduce power consumption, when none of the APB1 peripherals (except IWDG) are used and when their clocks are disabled in RCC_APB1ENR. When this bit is set, all the APB1 peripherals clocks are off, except for IWDG.
        constexpr uint32_t APB2DIS = (1U << 20);  ///< APB2 clock disable This bit can be set in order to further reduce power consumption, when none of the APB2 peripherals are used and when their clocks are disabled in RCC_APB2ENR. When this bit is set, all APB2 peripherals clocks are off.
    }

    /// RCC_CFGR3 Register bits
    namespace rcc_cfgr3_bits {
        constexpr uint32_t PPRE3 = (3 << 4);  ///< APB3 prescaler This bitfield is set and cleared by software to control the division factor of the APB3 clock (PCLK3). 0xx: HCLK not divided
        constexpr uint32_t AHB3DIS = (1U << 16);  ///< AHB3 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB3 peripherals (except SRAM4) are used and when their clocks are disabled in RCC_AHB3ENR. When this bit is set, all the AHB3 peripherals clocks are off, except for SRAM4.
        constexpr uint32_t APB3DIS = (1U << 17);  ///< APB3 clock disable This bit can be set in order to further reduce power consumption, when none of the APB3 peripherals from RCC_APB3ENR are used and when their clocks are disabled in RCC_APB3ENR. When this bit is set, all the APB3 peripherals clocks are off.
    }

    /// RCC_PLL1CFGR Register bits
    namespace rcc_pll1cfgr_bits {
        constexpr uint32_t PLL1SRC = (2 << 0);  ///< PLL1 entry clock source This bitfield is set and cleared by software to select PLL1 clock source. It can be written only when the PLL1 is disabled. In order to save power, when no PLL1 is used, this bitfield value must be zero.
        constexpr uint32_t PLL1RGE = (2 << 2);  ///< PLL1 input frequency range This bit is set and reset by software to select the proper reference frequency range used for PLL1. It must be written before enabling the PLL1. 00-01-10: PLL1 input (ref1_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL1FRACEN = (1U << 4);  ///< PLL1 fractional latch enable This bit is set and reset by software to latch the content of PLL1FRACN in the  modulator. Inorder to latch the PLL1FRACN value into the  modulator, PLL1FRACEN must be setto0, then set to 1: the transition 0 to 1 transfers the content of PLL1FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL1M = (4 << 8);  ///< Prescaler for PLL1 This bitfield is set and cleared by software to configure the prescaler of the PLL1. The VCO1 input frequency is PLL1 input clock frequency/PLL1M. This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1MBOOST = (4 << 12);  ///< Prescaler for EPOD booster input clock This bitfield is set and cleared by software to configure the prescaler of the PLL1, used for the EPOD booster. The EPOD booster input frequency is PLL1inputclockfrequency/PLL1MBOOST. This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0) and EPODboost mode is disabled (see Section10: Power control (PWR)). others: reserved
        constexpr uint32_t PLL1PEN = (1U << 16);  ///< PLL1 DIVP divider output enable This bit is set and reset by software to enable the pll1_p_ck output of the PLL1. To save power, PLL1PEN and PLL1P bits must be set to 0 when pll1_p_ck is not used.
        constexpr uint32_t PLL1QEN = (1U << 17);  ///< PLL1 DIVQ divider output enable This bit is set and reset by software to enable the pll1_q_ck output of the PLL1. To save power, PLL1QEN and PLL1Q bits must be set to 0 when pll1_q_ck is not used.
        constexpr uint32_t PLL1REN = (1U << 18);  ///< PLL1 DIVR divider output enable This bit is set and reset by software to enable the pll1_r_ck output of the PLL1. To save power, PLL1RENPLL2REN and PLL1R bits must be set to 0 when pll1_r_ck is not used. This bit can be cleared only when the PLL1 is not used as SYSCLK.
    }

    /// RCC_PLL2CFGR Register bits
    namespace rcc_pll2cfgr_bits {
        constexpr uint32_t PLL2SRC = (2 << 0);  ///< PLL2 entry clock source This bitfield is set and cleared by software to select PLL2 clock source. It can be written only when the PLL2 is disabled. To save power, when no PLL2 is used, this bitfield value must bezero.
        constexpr uint32_t PLL2RGE = (2 << 2);  ///< PLL2 input frequency range This bitfield is set and reset by software to select the proper reference frequency range used forPLL2. It must be written before enabling the PLL2. 00-01-10: PLL2 input (ref2_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL2FRACEN = (1U << 4);  ///< PLL2 fractional latch enable This bit is set and reset by software to latch the content of PLL2FRACN in the  modulator. In order to latch the PLL2FRACN value into the  modulator, PLL2FRACEN must be setto0, then set to 1: the transition 0 to 1 transfers the content of PLL2FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL2M = (4 << 8);  ///< Prescaler for PLL2 This bitfield is set and cleared by software to configure the prescaler of the PLL2. The VCO2 input frequency is PLL2 input clock frequency/PLL2M. This bit can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2PEN = (1U << 16);  ///< PLL2 DIVP divider output enable This bit is set and reset by software to enable the pll2_p_ck output of the PLL2. To save power, PLL2PEN and PLL2P bits must be set to 0 when pll2_p_ck is not used.
        constexpr uint32_t PLL2QEN = (1U << 17);  ///< PLL2 DIVQ divider output enable This bit is set and reset by software to enable the pll2_q_ck output of the PLL2. To save power, PLL2QEN and PLL2Q bits must be set to 0 when pll2_q_ck is not used.
        constexpr uint32_t PLL2REN = (1U << 18);  ///< PLL2 DIVR divider output enable This bit is set and reset by software to enable the pll2_r_ck output of the PLL2. To save power, PLL2REN and PLL2R bits must be set to 0 when pll2_r_ck is not used.
    }

    /// RCC_PLL3CFGR Register bits
    namespace rcc_pll3cfgr_bits {
        constexpr uint32_t PLL3SRC = (2 << 0);  ///< PLL3 entry clock source This bitfield is set and cleared by software to select PLL3 clock source. It can be written only when the PLL3 is disabled. To save power, when no PLL3 is used, this bitfield value must bezero.
        constexpr uint32_t PLL3RGE = (2 << 2);  ///< PLL3 input frequency range This bit is set and reset by software to select the proper reference frequency range used forPLL3. It must be written before enabling the PLL3. 00-01-10: PLL3 input (ref3_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL3FRACEN = (1U << 4);  ///< PLL3 fractional latch enable This bit is set and reset by software to latch the content of PLL3FRACN in the  modulator. In order to latch the PLL3FRACN value into the  modulator, PLL3FRACEN must be setto0, then set to 1: the transition 0 to 1 transfers the content of PLL3FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL3M = (4 << 8);  ///< Prescaler for PLL3 This bitfield is set and cleared by software to configure the prescaler of the PLL3. The VCO3 input frequency is PLL3 input clock frequency/PLL3M. This bitfield can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3PEN = (1U << 16);  ///< PLL3 DIVP divider output enable This bit is set and reset by software to enable the pll3_p_ck output of the PLL3. To save power, PLL3PEN and PLL3P bits must be set to 0 when pll3_p_ck is not used.
        constexpr uint32_t PLL3QEN = (1U << 17);  ///< PLL3 DIVQ divider output enable This bit is set and reset by software to enable the pll3_q_ck output of the PLL3. To save power, PLL3QEN and PLL3Q bits must be set to 0 when pll3_q_ck is not used.
        constexpr uint32_t PLL3REN = (1U << 18);  ///< PLL3 DIVR divider output enable This bit is set and reset by software to enable the pll3_r_ck output of the PLL3. To save power, PLL3REN and PLL3R bits must be set to 0 when pll3_r_ck is not used.
    }

    /// RCC_PLL1DIVR Register bits
    namespace rcc_pll1divr_bits {
        constexpr uint32_t PLL1N = (9 << 0);  ///< Multiplication factor for PLL1 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL1ON = 0 and PLL1RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref1_ck</sub> x PLL1N, when fractional value 0 has been loaded in PLL1FRACN, with: PLL1N between 4 and 512 input frequency F<sub>ref1_ck</sub> between 4 and 16MHz
        constexpr uint32_t PLL1P = (7 << 9);  ///< PLL1 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll1_p_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1Q = (7 << 16);  ///< PLL1 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll1_q_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1R = (7 << 24);  ///< PLL1 DIVR division factor This bitfield is set and reset by software to control frequency of the pll1_r_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). Only division by one and even division factors are allowed. ...
    }

    /// RCC_PLL1FRACR Register bits
    namespace rcc_pll1fracr_bits {
        constexpr uint32_t PLL1FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL1 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL1 VCO. VCO output frequency = F<sub>ref1_ck</sub> x (PLL1N + (PLL1FRACN / 2<sup>13</sup>)), with: PLL1N must be between 4 and 512. PLL1FRACN can be between 0 and 2<sup>13</sup>- 1. The input frequency F<sub>ref1_ck</sub> must be between 4 and 16 MHz. To change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed asfollows: Set PLL1FRACEN = 0. Write the new fractional value into PLL1FRACN. Set PLL1FRACEN = 1.
    }

    /// RCC_PLL2DIVR Register bits
    namespace rcc_pll2divr_bits {
        constexpr uint32_t PLL2N = (9 << 0);  ///< Multiplication factor for PLL2 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL2ON = 0 and PLL2RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref2_ck</sub> x PLL2N, when fractional value 0 has been loaded in PLL2FRACN, with: PLL2N between 4 and 512 input frequency F<sub>ref2_ck</sub> between 1MHz and 16MHz
        constexpr uint32_t PLL2P = (7 << 9);  ///< PLL2 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll2_p_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2Q = (7 << 16);  ///< PLL2 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll2_q_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2R = (7 << 24);  ///< PLL2 DIVR division factor This bitfield is set and reset by software to control the frequency of the pll2_r_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
    }

    /// RCC_PLL2FRACR Register bits
    namespace rcc_pll2fracr_bits {
        constexpr uint32_t PLL2FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL2 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL2 VCO. VCO output frequency = F<sub>ref2_ck</sub> x (PLL2N + (PLL2FRACN / 2<sup>13</sup>)), with PLL2N must be between 4 and 512. PLL2FRACN can be between 0 and 2<sup>13 </sup>- 1. The input frequency F<sub>ref2_ck</sub> must be between 4 and 16 MHz. In order to change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows: Set the bit PLL2FRACEN to 0. Write the new fractional value into PLL2FRACN. Set the bit PLL2FRACEN to 1.
    }

    /// RCC_PLL3DIVR Register bits
    namespace rcc_pll3divr_bits {
        constexpr uint32_t PLL3N = (9 << 0);  ///< Multiplication factor for PLL3 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL3ON = 0 and PLL3RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref3_ck</sub> x PLL3N, when fractional value 0 has been loaded in PLL3FRACN, with: PLL3N between 4 and 512 input frequency F<sub>ref3_ck</sub> between 4 and 16MHz
        constexpr uint32_t PLL3P = (7 << 9);  ///< PLL3 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll3_p_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3Q = (7 << 16);  ///< PLL3 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll3_q_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3R = (7 << 24);  ///< PLL3 DIVR division factor This bitfield is set and reset by software to control the frequency of the pll3_r_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
    }

    /// RCC_PLL3FRACR Register bits
    namespace rcc_pll3fracr_bits {
        constexpr uint32_t PLL3FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL3 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL3 VCO. VCO output frequency = F<sub>ref3_ck</sub> x (PLL3N + (PLL3FRACN / 2<sup>13</sup>)), with: PLL3N must be between 4 and 512. PLL3FRACN can be between 0 and 2<sup>13 </sup>- 1. The input frequency F<sub>ref3_ck</sub> must be between 4 and 16 MHz. In order to change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows: Set the bit PLL3FRACEN to 0. Write the new fractional value into PLL3FRACN. Set the bit PLL3FRACEN to 1.
    }

    /// RCC_CIER Register bits
    namespace rcc_cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization.
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization.
        constexpr uint32_t MSISRDYIE = (1U << 2);  ///< MSIS ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the MSIS oscillator stabilization.
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI16 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization.
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization.
        constexpr uint32_t HSI48RDYIE = (1U << 5);  ///< HSI48 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSI48 oscillator stabilization.
        constexpr uint32_t PLL1RDYIE = (1U << 6);  ///< PLL ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL1 lock.
        constexpr uint32_t PLL2RDYIE = (1U << 7);  ///< PLL2 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL2 lock.
        constexpr uint32_t PLL3RDYIE = (1U << 8);  ///< PLL3 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL3 lock.
        constexpr uint32_t MSIKRDYIE = (1U << 11);  ///< MSIK ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the MSIK oscillator stabilization.
        constexpr uint32_t SHSIRDYIE = (1U << 12);  ///< SHSI ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the SHSI oscillator stabilization.
    }

    /// RCC_CIFR Register bits
    namespace rcc_cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag This bit is set by hardware when the LSI clock becomes stable and LSIRDYIE is set. It is cleared by software bysetting the LSIRDYC bit.
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag This bit is set by hardware when the LSE clock becomes stable and LSERDYIE is set. It is cleared by software by setting the LSERDYC bit.
        constexpr uint32_t MSISRDYF = (1U << 2);  ///< MSIS ready interrupt flag This bit is set by hardware when the MSIS clock becomes stable and MSISRDYIE is set. Itis cleared by software by setting the MSISRDYC bit.
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI16 ready interrupt flag This bit is set by hardware when the HSI16 clock becomes stable and HSIRDYIE = 1 inresponse to setting the HSION (see RCC_CR). When HSION = 0 but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated. This bit is cleared by software by setting the HSIRDYC bit.
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag This bit is set by hardware when the HSE clock becomes stable and HSERDYIE is set. It is cleared by software by setting the HSERDYC bit.
        constexpr uint32_t HSI48RDYF = (1U << 5);  ///< HSI48 ready interrupt flag This bit is set by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set. itis cleared by software by setting the HSI48RDYC bit.
        constexpr uint32_t PLL1RDYF = (1U << 6);  ///< PLL1 ready interrupt flag This bit is set by hardware when the PLL1 locks and PLL1RDYIE is set. It is cleared by software by setting the PLL1RDYC bit.
        constexpr uint32_t PLL2RDYF = (1U << 7);  ///< PLL2 ready interrupt flag This bit is set by hardware when the PLL2 locks and PLL2RDYIE is set. It is cleared by software by setting the PLL2RDYC bit.
        constexpr uint32_t PLL3RDYF = (1U << 8);  ///< PLL3 ready interrupt flag This bit is set by hardware when the PLL3 locks and PLL3RDYIE is set. It is cleared by software by setting the PLL3RDYC bit.
        constexpr uint32_t CSSF = (1U << 10);  ///< Clock security system interrupt flag This bit is set by hardware when a failure is detected in the HSE oscillator. It is cleared by software by setting the CSSC bit.
        constexpr uint32_t MSIKRDYF = (1U << 11);  ///< MSIK ready interrupt flag This bit is set by hardware when the MSIK clock becomes stable and MSIKRDYIE is set. It is cleared by software by setting the MSIKRDYC bit.
        constexpr uint32_t SHSIRDYF = (1U << 12);  ///< SHSI ready interrupt flag This bit is set by hardware when the SHSI clock becomes stable and SHSIRDYIE is set. It is cleared by software by setting the SHSIRDYC bit.
    }

    /// RCC_CICR Register bits
    namespace rcc_cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear Writing this bit to 1 clears the LSIRDYF flag. Writing 0 has no effect.
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear Writing this bit to 1 clears the LSERDYF flag. Writing 0 has no effect.
        constexpr uint32_t MSISRDYC = (1U << 2);  ///< MSIS ready interrupt clear Writing this bit to 1 clears the MSISRDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI16 ready interrupt clear Writing this bit to 1 clears the HSIRDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear Writing this bit to 1 clears the HSERDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSI48RDYC = (1U << 5);  ///< HSI48 ready interrupt clear Writing this bit to 1 clears the HSI48RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL1RDYC = (1U << 6);  ///< PLL1 ready interrupt clear Writing this bit to 1 clears the PLL1RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL2RDYC = (1U << 7);  ///< PLL2 ready interrupt clear Writing this bit to 1 clears the PLL2RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL3RDYC = (1U << 8);  ///< PLL3 ready interrupt clear Writing this bit to 1 clears the PLL3RDYF flag. Writing 0 has no effect.
        constexpr uint32_t CSSC = (1U << 10);  ///< Clock security system interrupt clear Writing this bit to 1 clears the CSSF flag. Writing 0 has no effect.
        constexpr uint32_t MSIKRDYC = (1U << 11);  ///< MSIK oscillator ready interrupt clear Writing this bit to 1 clears the MSIKRDYF flag. Writing 0 has no effect.
        constexpr uint32_t SHSIRDYC = (1U << 12);  ///< SHSI oscillator ready interrupt clear Writing this bit to 1 clears the SHSIRDYF flag. Writing 0 has no effect.
    }

    /// RCC_AHB1RSTR Register bits
    namespace rcc_ahb1rstr_bits {
        constexpr uint32_t GPDMA1RST = (1U << 0);  ///< GPDMA1 reset This bit is set and cleared by software.
        constexpr uint32_t CORDICRST = (1U << 1);  ///< CORDIC reset This bit is set and cleared by software.
        constexpr uint32_t FMACRST = (1U << 2);  ///< FMAC reset This bit is set and cleared by software.
        constexpr uint32_t MDF1RST = (1U << 3);  ///< MDF1 reset This bit is set and cleared by software.
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset This bit is set and cleared by software.
        constexpr uint32_t JPEGRST = (1U << 15);  ///< JPEG reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCRST = (1U << 16);  ///< TSC reset This bit is set and cleared by software.
        constexpr uint32_t RAMCFGRST = (1U << 17);  ///< RAMCFG reset This bit is set and cleared by software.
        constexpr uint32_t DMA2DRST = (1U << 18);  ///< DMA2D reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMURST = (1U << 19);  ///< GFXMMU reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DRST = (1U << 20);  ///< GPU2D reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2RSTR1 Register bits
    namespace rcc_ahb2rstr1_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< I/O port A reset This bit is set and cleared by software.
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< I/O port B reset This bit is set and cleared by software.
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< I/O port C reset This bit is set and cleared by software.
        constexpr uint32_t GPIODRST = (1U << 3);  ///< I/O port D reset This bit is set and cleared by software.
        constexpr uint32_t GPIOERST = (1U << 4);  ///< I/O port E reset This bit is set and cleared by software.
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< I/O port F reset This bit is set and cleared by software. This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. Note: If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGRST = (1U << 6);  ///< I/O port G reset This bit is set and cleared by software.
        constexpr uint32_t GPIOHRST = (1U << 7);  ///< I/O port H reset This bit is set and cleared by software.
        constexpr uint32_t GPIOIRST = (1U << 8);  ///< I/O port I reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJRST = (1U << 9);  ///< I/O port J reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12RST = (1U << 10);  ///< ADC1 and ADC2 reset This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585, and ADC1/ADC2 inSTM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSIRST = (1U << 12);  ///< DCMI and PSSI reset This bit is set and cleared by software.
        constexpr uint32_t OTGRST = (1U << 14);  ///< OTG_FS or OTG_HS reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESRST = (1U << 16);  ///< AES hardware accelerator reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHRST = (1U << 17);  ///< HASH reset This bit is set and cleared by software.
        constexpr uint32_t RNGRST = (1U << 18);  ///< RNG reset This bit is set and cleared by software.
        constexpr uint32_t PKARST = (1U << 19);  ///< PKA reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESRST = (1U << 20);  ///< SAES hardware accelerator reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMRST = (1U << 21);  ///< OCTOSPIM reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1RST = (1U << 23);  ///< OTFDEC1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2RST = (1U << 24);  ///< OTFDEC2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1RST = (1U << 27);  ///< SDMMC1 reset This bit is set and cleared by software.
        constexpr uint32_t SDMMC2RST = (1U << 28);  ///< SDMMC2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2RSTR2 Register bits
    namespace rcc_ahb2rstr2_bits {
        constexpr uint32_t FSMCRST = (1U << 0);  ///< Flexible memory controller reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1RST = (1U << 4);  ///< OCTOSPI1 reset This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2RST = (1U << 8);  ///< OCTOSPI2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1RST = (1U << 12);  ///< HSPI1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3RSTR Register bits
    namespace rcc_ahb3rstr_bits {
        constexpr uint32_t LPGPIO1RST = (1U << 0);  ///< LPGPIO1 reset This bit is set and cleared by software.
        constexpr uint32_t ADC4RST = (1U << 5);  ///< ADC4 reset This bit is set and cleared by software.
        constexpr uint32_t DAC1RST = (1U << 6);  ///< DAC1 reset This bit is set and cleared by software.
        constexpr uint32_t LPDMA1RST = (1U << 9);  ///< LPDMA1 reset This bit is set and cleared by software.
        constexpr uint32_t ADF1RST = (1U << 10);  ///< ADF1 reset This bit is set and cleared by software.
    }

    /// RCC_APB1RSTR1 Register bits
    namespace rcc_apb1rstr1_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 reset This bit is set and cleared by software.
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 reset This bit is set and cleared by software.
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM4 reset This bit is set and cleared by software.
        constexpr uint32_t TIM5RST = (1U << 3);  ///< TIM5 reset This bit is set and cleared by software.
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 reset This bit is set and cleared by software.
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 reset This bit is set and cleared by software.
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset This bit is set and cleared by software.
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series.Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset This bit is set and cleared by software.
        constexpr uint32_t UART4RST = (1U << 19);  ///< UART4 reset This bit is set and cleared by software.
        constexpr uint32_t UART5RST = (1U << 20);  ///< UART5 reset This bit is set and cleared by software.
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset This bit is set and cleared by software.
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset This bit is set and cleared by software.
        constexpr uint32_t CRSRST = (1U << 24);  ///< CRS reset This bit is set and cleared by software.
        constexpr uint32_t USART6RST = (1U << 25);  ///< USART6 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1RSTR2 Register bits
    namespace rcc_apb1rstr2_bits {
        constexpr uint32_t I2C4RST = (1U << 1);  ///< I2C4 reset This bit is set and cleared by software
        constexpr uint32_t LPTIM2RST = (1U << 5);  ///< LPTIM2 reset This bit is set and cleared by software.
        constexpr uint32_t I2C5RST = (1U << 6);  ///< I2C5 reset This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6RST = (1U << 7);  ///< I2C6 reset This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1RST = (1U << 9);  ///< FDCAN1 reset This bit is set and cleared by software.
        constexpr uint32_t UCPD1RST = (1U << 23);  ///< UCPD1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2RSTR Register bits
    namespace rcc_apb2rstr_bits {
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 reset This bit is set and cleared by software.
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset This bit is set and cleared by software.
        constexpr uint32_t TIM8RST = (1U << 13);  ///< TIM8 reset This bit is set and cleared by software.
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset This bit is set and cleared by software.
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 reset This bit is set and cleared by software.
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 reset This bit is set and cleared by software.
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 reset This bit is set and cleared by software.
        constexpr uint32_t SAI1RST = (1U << 21);  ///< SAI1 reset This bit is set and cleared by software.
        constexpr uint32_t SAI2RST = (1U << 22);  ///< SAI2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBRST = (1U << 24);  ///< USB reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMRST = (1U << 25);  ///< GFXTIM reset This bit is set and cleared by software. Note: .This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCRST = (1U << 26);  ///< LTDC reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSIRST = (1U << 27);  ///< DSI reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3RSTR Register bits
    namespace rcc_apb3rstr_bits {
        constexpr uint32_t SYSCFGRST = (1U << 1);  ///< SYSCFG reset This bit is set and cleared by software.
        constexpr uint32_t SPI3RST = (1U << 5);  ///< SPI3 reset This bit is set and cleared by software.
        constexpr uint32_t LPUART1RST = (1U << 6);  ///< LPUART1 reset This bit is set and cleared by software.
        constexpr uint32_t I2C3RST = (1U << 7);  ///< I2C3 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM1RST = (1U << 11);  ///< LPTIM1 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM3RST = (1U << 12);  ///< LPTIM3 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM4RST = (1U << 13);  ///< LPTIM4 reset This bit is set and cleared by software.
        constexpr uint32_t OPAMPRST = (1U << 14);  ///< OPAMP reset This bit is set and cleared by software.
        constexpr uint32_t COMPRST = (1U << 15);  ///< COMP reset This bit is set and cleared by software.
        constexpr uint32_t VREFRST = (1U << 20);  ///< VREFBUF reset This bit is set and cleared by software.
    }

    /// RCC_AHB1ENR Register bits
    namespace rcc_ahb1enr_bits {
        constexpr uint32_t GPDMA1EN = (1U << 0);  ///< GPDMA1 clock enable This bit is set and cleared by software.
        constexpr uint32_t CORDICEN = (1U << 1);  ///< CORDIC clock enable This bit is set and cleared by software.
        constexpr uint32_t FMACEN = (1U << 2);  ///< FMAC clock enable This bit is set and reset by software.
        constexpr uint32_t MDF1EN = (1U << 3);  ///< MDF1 clock enable This bit is set and reset by software.
        constexpr uint32_t FLASHEN = (1U << 8);  ///< FLASH clock enable This bit is set and cleared by software. This bit can be disabled only when the flash memory is in power-down mode.
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable This bit is set and cleared by software.
        constexpr uint32_t JPEGEN = (1U << 15);  ///< JPEG clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCEN = (1U << 16);  ///< Touch sensing controller clock enable This bit is set and cleared by software.
        constexpr uint32_t RAMCFGEN = (1U << 17);  ///< RAMCFG clock enable This bit is set and cleared by software.
        constexpr uint32_t DMA2DEN = (1U << 18);  ///< DMA2D clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMUEN = (1U << 19);  ///< GFXMMU clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DEN = (1U << 20);  ///< GPU2D clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DCACHE2EN = (1U << 21);  ///< DCACHE2 clock enable This bit is set and reset by software. Note: DCACHE2 clock must be enabled to access memories, even if the DCACHE2 is bypassed. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GTZC1EN = (1U << 24);  ///< GTZC1 clock enable This bit is set and reset by software.
        constexpr uint32_t BKPSRAMEN = (1U << 28);  ///< BKPSRAM clock enable This bit is set and reset by software.
        constexpr uint32_t DCACHE1EN = (1U << 30);  ///< DCACHE1 clock enable This bit is set and reset by software. Note: DCACHE1 clock must be enabled when external memories are accessed through OCTOSPI1, OCTOSPI2, HSPI1 or FSMC, even if the DCACHE1 is bypassed.
        constexpr uint32_t SRAM1EN = (1U << 31);  ///< SRAM1 clock enable This bit is set and reset by software.
    }

    /// RCC_AHB2ENR1 Register bits
    namespace rcc_ahb2enr1_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< I/O port A clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< I/O port B clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< I/O port C clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIODEN = (1U << 3);  ///< I/O port D clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< I/O port E clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< I/O port F clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGEN = (1U << 6);  ///< I/O port G clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOHEN = (1U << 7);  ///< I/O port H clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOIEN = (1U << 8);  ///< I/O port I clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJEN = (1U << 9);  ///< I/O port J clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12EN = (1U << 10);  ///< ADC1 and ADC2 clock enable This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585, and ADC1/ADC2 inSTM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSIEN = (1U << 12);  ///< DCMI and PSSI clock enable This bit is set and cleared by software.
        constexpr uint32_t OTGEN = (1U << 14);  ///< OTG_FS or OTG_HS clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTGHSPHYEN = (1U << 15);  ///< OTG_HS PHY clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESEN = (1U << 16);  ///< AES clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHEN = (1U << 17);  ///< HASH clock enable This bit is set and cleared by software
        constexpr uint32_t RNGEN = (1U << 18);  ///< RNG clock enable This bit is set and cleared by software.
        constexpr uint32_t PKAEN = (1U << 19);  ///< PKA clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESEN = (1U << 20);  ///< SAES clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMEN = (1U << 21);  ///< OCTOSPIM clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1EN = (1U << 23);  ///< OTFDEC1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2EN = (1U << 24);  ///< OTFDEC2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1EN = (1U << 27);  ///< SDMMC1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SDMMC2EN = (1U << 28);  ///< SDMMC2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM2EN = (1U << 30);  ///< SRAM2 clock enable This bit is set and reset by software.
        constexpr uint32_t SRAM3EN = (1U << 31);  ///< SRAM3 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2ENR2 Register bits
    namespace rcc_ahb2enr2_bits {
        constexpr uint32_t FSMCEN = (1U << 0);  ///< FSMC clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1EN = (1U << 4);  ///< OCTOSPI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2EN = (1U << 8);  ///< OCTOSPI2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1EN = (1U << 12);  ///< HSPI1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM6EN = (1U << 30);  ///< SRAM6 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM5EN = (1U << 31);  ///< SRAM5 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3ENR Register bits
    namespace rcc_ahb3enr_bits {
        constexpr uint32_t LPGPIO1EN = (1U << 0);  ///< LPGPIO1 enable This bit is set and cleared by software.
        constexpr uint32_t PWREN = (1U << 2);  ///< PWR clock enable This bit is set and cleared by software.
        constexpr uint32_t ADC4EN = (1U << 5);  ///< ADC4 clock enable This bit is set and cleared by software.
        constexpr uint32_t DAC1EN = (1U << 6);  ///< DAC1 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPDMA1EN = (1U << 9);  ///< LPDMA1 clock enable This bit is set and cleared by software.
        constexpr uint32_t ADF1EN = (1U << 10);  ///< ADF1 clock enable This bit is set and cleared by software.
        constexpr uint32_t GTZC2EN = (1U << 12);  ///< GTZC2 clock enable This bit is set and cleared by software.
        constexpr uint32_t SRAM4EN = (1U << 31);  ///< SRAM4 clock enable This bit is set and reset by software.
    }

    /// RCC_APB1ENR1 Register bits
    namespace rcc_apb1enr1_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM4 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM5 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 clock enable This bit is set and cleared by software.
        constexpr uint32_t WWDGEN = (1U << 11);  ///< WWDG clock enable This bit is set by software to enable the window watchdog clock. It is reset by hardware system reset. This bit can also be set by hardware if the WWDG_SW option bit is reset.
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable This bit is set and cleared by software.
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable This bit is set and cleared by software.
        constexpr uint32_t UART4EN = (1U << 19);  ///< UART4 clock enable This bit is set and cleared by software.
        constexpr uint32_t UART5EN = (1U << 20);  ///< UART5 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable This bit is set and cleared by software.
        constexpr uint32_t CRSEN = (1U << 24);  ///< CRS clock enable This bit is set and cleared by software.
        constexpr uint32_t USART6EN = (1U << 25);  ///< USART6 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1ENR2 Register bits
    namespace rcc_apb1enr2_bits {
        constexpr uint32_t I2C4EN = (1U << 1);  ///< I2C4 clock enable This bit is set and cleared by software
        constexpr uint32_t LPTIM2EN = (1U << 5);  ///< LPTIM2 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C5EN = (1U << 6);  ///< I2C5 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6EN = (1U << 7);  ///< I2C6 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1EN = (1U << 9);  ///< FDCAN1 clock enable This bit is set and cleared by software.
        constexpr uint32_t UCPD1EN = (1U << 23);  ///< UCPD1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2ENR Register bits
    namespace rcc_apb2enr_bits {
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM8EN = (1U << 13);  ///< TIM8 clock enable This bit is set and cleared by software.
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM17 clock enable This bit is set and cleared by software.
        constexpr uint32_t SAI1EN = (1U << 21);  ///< SAI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SAI2EN = (1U << 22);  ///< SAI2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBEN = (1U << 24);  ///< USB clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMEN = (1U << 25);  ///< GFXTIM clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCEN = (1U << 26);  ///< LTDC clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSIEN = (1U << 27);  ///< DSI clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3ENR Register bits
    namespace rcc_apb3enr_bits {
        constexpr uint32_t SYSCFGEN = (1U << 1);  ///< SYSCFG clock enable This bit is set and cleared by software.
        constexpr uint32_t SPI3EN = (1U << 5);  ///< SPI3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPUART1EN = (1U << 6);  ///< LPUART1 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C3EN = (1U << 7);  ///< I2C3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM1EN = (1U << 11);  ///< LPTIM1 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM3EN = (1U << 12);  ///< LPTIM3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM4EN = (1U << 13);  ///< LPTIM4 clock enable This bit is set and cleared by software.
        constexpr uint32_t OPAMPEN = (1U << 14);  ///< OPAMP clock enable This bit is set and cleared by software.
        constexpr uint32_t COMPEN = (1U << 15);  ///< COMP clock enable This bit is set and cleared by software.
        constexpr uint32_t VREFEN = (1U << 20);  ///< VREFBUF clock enable This bit is set and cleared by software.
        constexpr uint32_t RTCAPBEN = (1U << 21);  ///< RTC and TAMP APB clock enable This bit is set and cleared by software.
    }

    /// RCC_AHB1SMENR Register bits
    namespace rcc_ahb1smenr_bits {
        constexpr uint32_t GPDMA1SMEN = (1U << 0);  ///< GPDMA1 clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t CORDICSMEN = (1U << 1);  ///< CORDIC clocks enable during Sleep and Stop modes This bit is set and cleared by software during Sleep mode.
        constexpr uint32_t FMACSMEN = (1U << 2);  ///< FMAC clocks enable during Sleep and Stop modes. This bit is set and cleared by software.
        constexpr uint32_t MDF1SMEN = (1U << 3);  ///< MDF1 clocks enable during Sleep and Stop modes. This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< FLASH clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t JPEGSMEN = (1U << 15);  ///< JPEG clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCSMEN = (1U << 16);  ///< TSC clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t RAMCFGSMEN = (1U << 17);  ///< RAMCFG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t DMA2DSMEN = (1U << 18);  ///< DMA2D clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMUSMEN = (1U << 19);  ///< GFXMMU clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DSMEN = (1U << 20);  ///< GPU2D clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DCACHE2SMEN = (1U << 21);  ///< DCACHE2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GTZC1SMEN = (1U << 24);  ///< GTZC1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t BKPSRAMSMEN = (1U << 28);  ///< BKPSRAM clock enable during Sleep and Stop modes This bit is set and cleared by software
        constexpr uint32_t ICACHESMEN = (1U << 29);  ///< ICACHE clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t DCACHE1SMEN = (1U << 30);  ///< DCACHE1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM1SMEN = (1U << 31);  ///< SRAM1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
    }

    /// RCC_AHB2SMENR1 Register bits
    namespace rcc_ahb2smenr1_bits {
        constexpr uint32_t GPIOASMEN = (1U << 0);  ///< I/O port A clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOBSMEN = (1U << 1);  ///< I/O port B clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOCSMEN = (1U << 2);  ///< I/O port C clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIODSMEN = (1U << 3);  ///< I/O port D clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOESMEN = (1U << 4);  ///< I/O port E clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOFSMEN = (1U << 5);  ///< I/O port F clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGSMEN = (1U << 6);  ///< I/O port G clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOHSMEN = (1U << 7);  ///< I/O port H clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOISMEN = (1U << 8);  ///< I/O port I clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJSMEN = (1U << 9);  ///< I/O port J clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12SMEN = (1U << 10);  ///< ADC1 and ADC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585 and ADC1/ADC2 inSTM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSISMEN = (1U << 12);  ///< DCMI and PSSI clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t OTGSMEN = (1U << 14);  ///< OTG_FS and OTG_HS clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTGHSPHYSMEN = (1U << 15);  ///< OTG_HS PHY clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESSMEN = (1U << 16);  ///< AES clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHSMEN = (1U << 17);  ///< HASH clock enable during Sleep and Stop modes This bit is set and cleared by software
        constexpr uint32_t RNGSMEN = (1U << 18);  ///< RNG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t PKASMEN = (1U << 19);  ///< PKA clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESSMEN = (1U << 20);  ///< SAES accelerator clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMSMEN = (1U << 21);  ///< OCTOSPIM clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1SMEN = (1U << 23);  ///< OTFDEC1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2SMEN = (1U << 24);  ///< OTFDEC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1SMEN = (1U << 27);  ///< SDMMC1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SDMMC2SMEN = (1U << 28);  ///< SDMMC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM2SMEN = (1U << 30);  ///< SRAM2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM3SMEN = (1U << 31);  ///< SRAM3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2SMENR2 Register bits
    namespace rcc_ahb2smenr2_bits {
        constexpr uint32_t FSMCSMEN = (1U << 0);  ///< FSMC clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1SMEN = (1U << 4);  ///< OCTOSPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2SMEN = (1U << 8);  ///< OCTOSPI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1SMEN = (1U << 12);  ///< HSPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM6SMEN = (1U << 30);  ///< SRAM6 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM5SMEN = (1U << 31);  ///< SRAM5 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3SMENR Register bits
    namespace rcc_ahb3smenr_bits {
        constexpr uint32_t LPGPIO1SMEN = (1U << 0);  ///< LPGPIO1 enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t PWRSMEN = (1U << 2);  ///< PWR clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t ADC4SMEN = (1U << 5);  ///< ADC4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t DAC1SMEN = (1U << 6);  ///< DAC1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPDMA1SMEN = (1U << 9);  ///< LPDMA1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADF1SMEN = (1U << 10);  ///< ADF1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t GTZC2SMEN = (1U << 12);  ///< GTZC2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM4SMEN = (1U << 31);  ///< SRAM4 clock enable during Sleep and Stop modes This bit is set and cleared by software.
    }

    /// RCC_APB1SMENR1 Register bits
    namespace rcc_apb1smenr1_bits {
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< TIM2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM4SMEN = (1U << 2);  ///< TIM4 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM5SMEN = (1U << 3);  ///< TIM5 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< Window watchdog clock enable during Sleep and Stop modes This bit is set and cleared by software. It is forced to one by hardware when the hardware WWDG option is activated.
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t UART4SMEN = (1U << 19);  ///< UART4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t UART5SMEN = (1U << 20);  ///< UART5 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t CRSSMEN = (1U << 24);  ///< CRS clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t USART6SMEN = (1U << 25);  ///< USART6 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1SMENR2 Register bits
    namespace rcc_apb1smenr2_bits {
        constexpr uint32_t I2C4SMEN = (1U << 1);  ///< I2C4 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM2SMEN = (1U << 5);  ///< LPTIM2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C5SMEN = (1U << 6);  ///< I2C5 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6SMEN = (1U << 7);  ///< I2C6 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1SMEN = (1U << 9);  ///< FDCAN1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t UCPD1SMEN = (1U << 23);  ///< UCPD1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2SMENR Register bits
    namespace rcc_apb2smenr_bits {
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t TIM8SMEN = (1U << 13);  ///< TIM8 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM17 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SAI1SMEN = (1U << 21);  ///< SAI1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SAI2SMEN = (1U << 22);  ///< SAI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series.Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBSMEN = (1U << 24);  ///< USB clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMSMEN = (1U << 25);  ///< GFXTIM clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCSMEN = (1U << 26);  ///< LTDC clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSISMEN = (1U << 27);  ///< DSI clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3SMENR Register bits
    namespace rcc_apb3smenr_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 1);  ///< SYSCFG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SPI3SMEN = (1U << 5);  ///< SPI3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPUART1SMEN = (1U << 6);  ///< LPUART1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C3SMEN = (1U << 7);  ///< I2C3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM1SMEN = (1U << 11);  ///< LPTIM1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM3SMEN = (1U << 12);  ///< LPTIM3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM4SMEN = (1U << 13);  ///< LPTIM4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t OPAMPSMEN = (1U << 14);  ///< OPAMP clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t COMPSMEN = (1U << 15);  ///< COMP clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t VREFSMEN = (1U << 20);  ///< VREFBUF clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t RTCAPBSMEN = (1U << 21);  ///< RTC and TAMP APB clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
    }

    /// RCC_SRDAMR Register bits
    namespace rcc_srdamr_bits {
        constexpr uint32_t SPI3AMEN = (1U << 5);  ///< SPI3 autonomous mode enable in Stop 0,1, 2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPUART1AMEN = (1U << 6);  ///< LPUART1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C3AMEN = (1U << 7);  ///< I2C3 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM1AMEN = (1U << 11);  ///< LPTIM1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM3AMEN = (1U << 12);  ///< LPTIM3 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM4AMEN = (1U << 13);  ///< LPTIM4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t OPAMPAMEN = (1U << 14);  ///< OPAMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t COMPAMEN = (1U << 15);  ///< COMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t VREFAMEN = (1U << 20);  ///< VREFBUF autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t RTCAPBAMEN = (1U << 21);  ///< RTC and TAMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADC4AMEN = (1U << 25);  ///< ADC4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPGPIO1AMEN = (1U << 26);  ///< LPGPIO1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t DAC1AMEN = (1U << 27);  ///< DAC1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPDMA1AMEN = (1U << 28);  ///< LPDMA1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADF1AMEN = (1U << 29);  ///< ADF1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t SRAM4AMEN = (1U << 31);  ///< SRAM4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
    }

    /// RCC_CCIPR1 Register bits
    namespace rcc_ccipr1_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 kernel clock source selection These bits are used to select the USART1 kernel clock source. Note: The USART1 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 kernel clock source selection These bits are used to select the USART2 kernel clock source. The USART2 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t USART3SEL = (2 << 4);  ///< USART3 kernel clock source selection These bits are used to select the USART3 kernel clock source. Note: The USART3 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t UART4SEL = (2 << 6);  ///< UART4 kernel clock source selection These bits are used to select the UART4 kernel clock source. Note: The UART4 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t UART5SEL = (2 << 8);  ///< UART5 kernel clock source selection These bits are used to select the UART5 kernel clock source. Note: The UART5 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t I2C1SEL = (2 << 10);  ///< I2C1 kernel clock source selection These bits are used to select the I2C1 kernel clock source. Note: The I2C1 is functional in Stop 0 and Stop 1 mode sonly when the kernel clock is HSI16or MSIK.
        constexpr uint32_t I2C2SEL = (2 << 12);  ///< I2C2 kernel clock source selection These bits are used to select the I2C2 kernel clock source. Note: The I2C2 is functional in Stop 0 and Stop 1 mode sonly when the kernel clock is HSI16or MSIK.
        constexpr uint32_t I2C4SEL = (2 << 14);  ///< I2C4 kernel clock source selection These bits are used to select the I2C4 kernel clock source. Note: The I2C4 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16or MSIK.
        constexpr uint32_t SPI2SEL = (2 << 16);  ///< SPI2 kernel clock source selection These bits are used to select the SPI2 kernel clock source. Note: The SPI2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t LPTIM2SEL = (2 << 18);  ///< Low-power timer 2 kernel clock source selection These bits are used to select the LPTIM2 kernel clock source. Note: The LPTIM2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is LSI, LSE or HSI16 if HSIKERON = 1.
        constexpr uint32_t SPI1SEL = (2 << 20);  ///< SPI1 kernel clock source selection These bits are used to select the SPI1 kernel clock source. Note: The SPI1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t SYSTICKSEL = (2 << 22);  ///< SysTick clock source selection These bits are used to select the SysTick clock source. Note: When LSE or LSI is selected, the AHB frequency must be at least four times higher than the LSI or LSE frequency. In addition, a jitter up to one HCLK cycle is introduced, due to the LSE or LSI sampling with HCLK in the SysTick circuitry.
        constexpr uint32_t FDCAN1SEL = (2 << 24);  ///< FDCAN1 kernel clock source selection These bits are used to select the FDCAN1 kernel clock source.
        constexpr uint32_t ICLKSEL = (2 << 26);  ///< Intermediate clock source selection These bits are used to select the clock source for the OTG_FS, the USB, and the SDMMC.
        constexpr uint32_t TIMICSEL = (3 << 29);  ///< Clock sources for TIM16,TIM17, and LPTIM2 internal input capture When TIMICSEL2 is set, the TIM16, TIM17, and LPTIM2 internal input capture can be connected either to HSI/256, MSI/4, or MSI/1024. Depending on TIMICSEL[1:0] value, MSI is either MSIK or MSIS. When TIMICSEL2 is cleared, the HSI, MSIK, and MSIS clock sources cannot be selected asTIM16, TIM17, or LPTIM2 internal input capture. 0xx: HSI, MSIK and MSIS dividers disabled Note: The clock division must be disabled (TIMICSEL configured to 0xx) before selecting or changing a clock sources division.
    }

    /// RCC_CCIPR2 Register bits
    namespace rcc_ccipr2_bits {
        constexpr uint32_t MDF1SEL = (3 << 0);  ///< MDF1 kernel clock source selection These bits are used to select the MDF1 kernel clock source. others: reserved
        constexpr uint32_t SAI1SEL = (3 << 5);  ///< SAI1 kernel clock source selection These bits are used to select the SAI1 kernel clock source. others: reserved Note: If the selected clock is the external clock and this clock is stopped, a switch to another clock is impossible.
        constexpr uint32_t SAI2SEL = (3 << 8);  ///< SAI2 kernel clock source selection These bits are used to select the SAI2 kernel clock source. others: reserved If the selected clock is the external clock and this clock is stopped, a switch to another clock is impossible. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t SAESSEL = (1U << 11);  ///< SAES kernel clock source selection This bit is used to select the SAES kernel clock source. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t RNGSEL = (2 << 12);  ///< RNG kernel clock source selection These bits are used to select the RNG kernel clock source.
        constexpr uint32_t SDMMCSEL = (1U << 14);  ///< SDMMC1 and SDMMC2 kernel clock source selection This bit is used to select the SDMMC kernel clock source. It is recommended to change it only after reset and before enabling the SDMMC.
        constexpr uint32_t DSISEL = (1U << 15);  ///< DSI kernel clock source selection This bit is used to select the DSI kernel clock source. This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. Note: If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART6SEL = (2 << 16);  ///< USART6 kernel clock source selection These bits are used to select the USART6 kernel clock source. The USART6 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t LTDCSEL = (1U << 18);  ///< LTDC kernel clock source selection This bit is used to select the LTDC kernel clock source. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPISEL = (2 << 20);  ///< OCTOSPI1 and OCTOSPI2 kernel clock source selection These bits are used to select the OCTOSPI1 and OCTOSPI2 kernel clock source.
        constexpr uint32_t HSPI1SEL = (2 << 22);  ///< HSPI1 kernel clock source selection These bits are used to select the HSPI1 kernel clock source. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t I2C5SEL = (2 << 24);  ///< I2C5 kernel clock source selection These bits are used to select the I2C5 kernel clock source. The I2C5 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16or MSIK. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t I2C6SEL = (2 << 26);  ///< I2C6 kernel clock source selection These bits are used to select the I2C6 kernel clock source. The I2C6 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16or MSIK. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t OTGHSSEL = (2 << 30);  ///< OTG_HS PHY kernel clock source selection These bits are used to select the OTG_HS PHY kernel clock source. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
    }

    /// RCC_CCIPR3 Register bits
    namespace rcc_ccipr3_bits {
        constexpr uint32_t LPUART1SEL = (3 << 0);  ///< LPUART1 kernel clock source selection These bits are used to select the LPUART1 kernel clock source. others: reserved Note: The LPUART1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16, LSE, or MSIK.
        constexpr uint32_t SPI3SEL = (2 << 3);  ///< SPI3 kernel clock source selection These bits are used to select the SPI3 kernel clock source. Note: The SPI3 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t I2C3SEL = (2 << 6);  ///< I2C3 kernel clock source selection These bits are used to select the I2C3 kernel clock source. Note: The I2C3 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t LPTIM34SEL = (2 << 8);  ///< LPTIM3 and LPTIM4 kernel clock source selection These bits are used to select the LPTIM3 and LPTIM4 kernel clock source. Note: The LPTIM3 and LPTIM4 are functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is LSI, LSE, HSI16 with HSIKERON = 1, or MSIK with MSIKERON=1.
        constexpr uint32_t LPTIM1SEL = (2 << 10);  ///< LPTIM1 kernel clock source selection These bits are used to select the LPTIM1 kernel clock source. Note: The LPTIM1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is LSI, LSE, HSI16 with HSIKERON = 1, or MSIK with MSIKERON = 1.
        constexpr uint32_t ADCDACSEL = (3 << 12);  ///< ADC1, ADC2, ADC4 and DAC1 kernel clock source selection These bits are used to select the ADC1, ADC2, ADC4, and DAC1 kernel clock source. others: reserved Note: The ADC1, ADC2, ADC4, and DAC1 are functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK (only ADC4 and DAC1 are functional inStop 2 mode).
        constexpr uint32_t DAC1SEL = (1U << 15);  ///< DAC1 sample-and-hold clock source selection This bit is used to select the DAC1 sample-and-hold clock source.
        constexpr uint32_t ADF1SEL = (3 << 16);  ///< ADF1 kernel clock source selection These bits are used to select the ADF1 kernel clock source. others: reserved Note: The ADF1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is AUDIOCLK or MSIK.
    }

    /// RCC_BDCR Register bits
    namespace rcc_bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable This bit is set and cleared by software.
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready This bit is set and cleared by hardware to indicate when the external 32kHz oscillator is stable. After LSEON is cleared, this LSERDY bit goes low after six external low-speed oscillator clock cycles.
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass This bit is set and cleared by software to bypass oscillator in debug mode. It can be written only when the external 32kHz oscillator is disabled (LSEON = 0 and LSERDY = 0).
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability This bitfield is set by software to modulate the drive capability of the LSE oscillator. It can be written only when the external 32 kHz oscillator is disabled (LSEON = 0 and LSERDY = 0). Note: The oscillator is in Xtal mode when it is not in bypass mode.
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable This bit is set by software to enable the CSS on LSE. It must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected. Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD=1). In that case, the software must disable this LSECSSON bit.
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure detection This bit is set by hardware to indicate when a failure is detected by the CCS on the external 32kHz oscillator (LSE).
        constexpr uint32_t LSESYSEN = (1U << 7);  ///< LSE system clock (LSESYS) enable This bit is set by software to enable always the LSE system clock generated by RCC, which can be used by any peripheral when its source clock is the LSE, or at system level if one of LSCOSEL, MCO, or MSI PLL mode is needed.
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC and TAMP clock source selection This bit is set by software to select the clock source for the RTC and TAMP. Once the RTC and TAMP clock source has been selected, it cannot be changed anymore unless thebackup domain is reset, or unless a failure is detected on LSE (LSECSSD is set). BDRST bit can be used to reset them.
        constexpr uint32_t LSESYSRDY = (1U << 11);  ///< LSE system clock (LSESYS) ready This bit is set and cleared by hardware to indicate when the LSE system clock is stable.When LSESYSEN is set, this LSESYSRDY flag is set after two LSE clock cycles. The LSE clock must be already enabled and stable (LSEON and LSERDY are set). When the LSEON bit is cleared, LSERDY goes low after six external low-speed oscillator clock cycles.
        constexpr uint32_t LSEGFON = (1U << 12);  ///< LSE clock glitch filter enable This bit is set and cleared by hardware to enable the LSE glitch filter. It can be written only when the LSE is disabled (LSEON = 0 and LSERDY = 0).
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC and TAMP clock enable This bit is set and cleared by software.
        constexpr uint32_t BDRST = (1U << 16);  ///< Backup domain software reset This bit is set and cleared by software.
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low-speed clock output (LSCO) enable This bit is set and cleared by software.
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low-speed clock output selection This bit is set and cleared by software.
        constexpr uint32_t LSION = (1U << 26);  ///< LSI oscillator enable This bit is set and cleared by software. The LSI oscillator is disabled 60s maximum after the LSION bit is cleared.
        constexpr uint32_t LSIRDY = (1U << 27);  ///< LSI oscillator ready This bit is set and cleared by hardware to indicate when the LSI oscillator is stable. AfterLSION is cleared, LSIRDY goes low after three internal low-speed oscillator clock cycles. This bit is set when the LSI is used by IWDG or RTC, even if LSION = 0.
        constexpr uint32_t LSIPREDIV = (1U << 28);  ///< Low-speed clock divider configuration This bit is set and cleared by software to enable the LSI division. It can be written only when the LSI is disabled (LSION = 0 and LSIRDY = 0). If the LSI was previously enabled, it is necessary to wait for at least 60 s after clearing LSION bit (synchronization time for LSI to be really disabled), before writing LSIPREDIV. The LSIPREDIV cannot be changed if the LSI is used by the IWDG or by the RTC.
    }

    /// RCC_CSR Register bits
    namespace rcc_csr_bits {
        constexpr uint32_t MSIKSRANGE = (4 << 8);  ///< MSIK range after Standby mode This bit is set by software to chose the MSIK frequency at startup. It is used after exiting Standby mode until MSIRGSEL is set. After a NRST pin or a power-on reset or when exiting Shutdown mode, the range is always 4MHz. MSIKSRANGE can be written only when MSIRGSEL = 1. others: reserved Note: Changing this bitfield does not change the current MSIK frequency.
        constexpr uint32_t MSISSRANGE = (4 << 12);  ///< MSIS range after Standby mode This bitfield is set by software to chose the MSIS frequency at startup. It is used after exiting Standby mode until MSIRGSEL is set. After a NRST pin or a power-on reset or when exiting Shutdown mode, the range is always 4MHz. MSISSRANGE can be written only when MSIRGSEL = 1. others: reserved Note: Changing this bitfield does not change the current MSIS frequency.
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flag This bit is set by software to clear the reset flags.
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option-byte loader reset flag This bit is set by hardware when a reset from the option-byte loading occurs. It is cleared bywriting to the RMVF bit.
        constexpr uint32_t PINRSTF = (1U << 26);  ///< NRST pin reset flag This bit is set by hardware when a reset from the NRST pin occurs. It is cleared by writing tothe RMVF bit.
        constexpr uint32_t BORRSTF = (1U << 27);  ///< Brownout reset or an exit from Shutdown mode reset flag This bit is set by hardware when a brownout reset or an exit from Shutdown mode reset occurs. It is cleared by writing to the RMVF bit.
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag This bit is set by hardware when a software reset occurs. It is cleared by writing to RMVF.
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent watchdog reset flag This bit is set by hardware when an independent watchdog reset domain occurs. It is cleared by writing to the RMVF bit.
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag This bit is set by hardware when a window watchdog reset occurs. It is cleared by writing tothe RMVF bit.
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag This bit is set by hardware when a reset occurs due to a Stop, Standby, or Shutdown mode entry, whereas the corresponding NRST_STOP, NRST_STBY, or NRST_SHDW option bit is cleared. This bit is cleared by writing to the RMVF bit.
    }

    /// RCC_SECCFGR Register bits
    namespace rcc_seccfgr_bits {
        constexpr uint32_t HSISEC = (1U << 0);  ///< HSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t HSESEC = (1U << 1);  ///< HSE clock configuration bits, status bit and HSE_CSS security This bit is set and reset by software.
        constexpr uint32_t MSISEC = (1U << 2);  ///< MSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t LSISEC = (1U << 3);  ///< LSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t LSESEC = (1U << 4);  ///< LSE clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t SYSCLKSEC = (1U << 5);  ///< SYSCLK clock selection, STOPWUCK bit, clock output on MCO configuration security This bit is set and reset by software.
        constexpr uint32_t PRESCSEC = (1U << 6);  ///< AHBx/APBx prescaler configuration bits security This bit is set and reset by software.
        constexpr uint32_t PLL1SEC = (1U << 7);  ///< PLL1 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t PLL2SEC = (1U << 8);  ///< PLL2 clock configuration and status bit security Set and reset by software.
        constexpr uint32_t PLL3SEC = (1U << 9);  ///< PLL3 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t ICLKSEC = (1U << 10);  ///< Intermediate clock source selection security This bit is set and reset by software.
        constexpr uint32_t HSI48SEC = (1U << 11);  ///< HSI48 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t RMVFSEC = (1U << 12);  ///< Remove reset flag security This bit is set and reset by software.
    }

    /// RCC_PRIVCFGR Register bits
    namespace rcc_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< RCC secure function privilege configuration This bit is set and reset by software. It can be written only by a secure privileged access.
        constexpr uint32_t NSPRIV = (1U << 1);  ///< RCC non-secure function privilege configuration This bit is set and reset by software. It can be written only by privileged access, secure or non-secure.
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x46007800;
    constexpr uint32_t SEC_RTC_BASE = 0x56007800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t SSR;  ///< Offset: 0x08 - RTC sub second register
        volatile uint32_t ICSR;  ///< Offset: 0x0C - RTC initialization control and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CR;  ///< Offset: 0x18 - RTC control register
        volatile uint32_t PRIVCR;  ///< Offset: 0x1C - RTC privilege mode control register
        volatile uint32_t SECCFGR;  ///< Offset: 0x20 - RTC secure mode control register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t CALR;  ///< Offset: 0x28 - calibration register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t ALRMAR;  ///< Offset: 0x40 - alarm A register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBR;  ///< Offset: 0x48 - alarm B register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x4C - alarm B sub second register
        volatile uint32_t SR;  ///< Offset: 0x50 - RTC status register
        volatile uint32_t MISR;  ///< Offset: 0x54 - RTC non-secure masked interrupt status register
        volatile uint32_t SMISR;  ///< Offset: 0x58 - RTC secure masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x5C - RTC status clear register
        volatile uint32_t ALRABINR;  ///< Offset: 0x70 - RTC alarm A binary mode register
        volatile uint32_t ALRBBINR;  ///< Offset: 0x74 - RTC alarm B binary mode register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);
    inline Registers* SEC_RTC = reinterpret_cast<Registers*>(SEC_RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< SS
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t BIN = (2 << 8);  ///< BIN
        constexpr uint32_t BCDU = (3 << 10);  ///< BCDU
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
        constexpr uint32_t WUTOCLR = (16 << 16);  ///< WUTOCLR
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< WUCKSEL
        constexpr uint32_t TSEDGE = (1U << 3);  ///< TSEDGE
        constexpr uint32_t REFCKON = (1U << 4);  ///< REFCKON
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< BYPSHAD
        constexpr uint32_t FMT = (1U << 6);  ///< FMT
        constexpr uint32_t SSRUIE = (1U << 7);  ///< SSRUIE
        constexpr uint32_t ALRAE = (1U << 8);  ///< ALRAE
        constexpr uint32_t ALRBE = (1U << 9);  ///< ALRBE
        constexpr uint32_t WUTE = (1U << 10);  ///< WUTE
        constexpr uint32_t TSE = (1U << 11);  ///< TSE
        constexpr uint32_t ALRAIE = (1U << 12);  ///< ALRAIE
        constexpr uint32_t ALRBIE = (1U << 13);  ///< ALRBIE
        constexpr uint32_t WUTIE = (1U << 14);  ///< WUTIE
        constexpr uint32_t TSIE = (1U << 15);  ///< TSIE
        constexpr uint32_t ADD1H = (1U << 16);  ///< ADD1H
        constexpr uint32_t SUB1H = (1U << 17);  ///< SUB1H
        constexpr uint32_t BKP = (1U << 18);  ///< BKP
        constexpr uint32_t COSEL = (1U << 19);  ///< COSEL
        constexpr uint32_t POL = (1U << 20);  ///< POL
        constexpr uint32_t OSEL = (2 << 21);  ///< OSEL
        constexpr uint32_t COE = (1U << 23);  ///< COE
        constexpr uint32_t ITSE = (1U << 24);  ///< ITSE
        constexpr uint32_t TAMPTS = (1U << 25);  ///< TAMPTS
        constexpr uint32_t TAMPOE = (1U << 26);  ///< TAMPOE
        constexpr uint32_t ALRAFCLR = (1U << 27);  ///< ALRAFCLR
        constexpr uint32_t ALRBFCLR = (1U << 28);  ///< ALRBFCLR
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM_PU
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM_TYPE
        constexpr uint32_t OUT2EN = (1U << 31);  ///< OUT2EN
    }

    /// PRIVCR Register bits
    namespace privcr_bits {
        constexpr uint32_t PRIV = (1U << 15);  ///< PRIV
        constexpr uint32_t INITPRIV = (1U << 14);  ///< INITPRIV
        constexpr uint32_t CALPRIV = (1U << 13);  ///< CALPRIV
        constexpr uint32_t TSPRIV = (1U << 3);  ///< TSPRIV
        constexpr uint32_t WUTPRIV = (1U << 2);  ///< WUTPRIV
        constexpr uint32_t ALRBPRIV = (1U << 1);  ///< ALRBPRIV
        constexpr uint32_t ALRAPRIV = (1U << 0);  ///< ALRAPRIV
    }

    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t SEC = (1U << 15);  ///< SEC
        constexpr uint32_t INITSEC = (1U << 14);  ///< INITSEC
        constexpr uint32_t CALSEC = (1U << 13);  ///< CALSEC
        constexpr uint32_t TSSEC = (1U << 3);  ///< TSSEC
        constexpr uint32_t WUTSEC = (1U << 2);  ///< WUTSEC
        constexpr uint32_t ALRBSEC = (1U << 1);  ///< ALRBSEC
        constexpr uint32_t ALRASEC = (1U << 0);  ///< ALRASEC
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t LPCAL = (1U << 12);  ///< LPCAL
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Sub second value
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t SSCLR = (1U << 31);  ///< SSCLR
        constexpr uint32_t MASKSS = (6 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t SSCLR = (1U << 31);  ///< SSCLR
        constexpr uint32_t MASKSS = (6 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< ALRAF
        constexpr uint32_t ALRBF = (1U << 1);  ///< ALRBF
        constexpr uint32_t WUTF = (1U << 2);  ///< WUTF
        constexpr uint32_t TSF = (1U << 3);  ///< TSF
        constexpr uint32_t TSOVF = (1U << 4);  ///< TSOVF
        constexpr uint32_t ITSF = (1U << 5);  ///< ITSF
        constexpr uint32_t SSRUF = (1U << 6);  ///< SSRUF
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
        constexpr uint32_t SSRUMF = (1U << 6);  ///< SSRUMF
    }

    /// SMISR Register bits
    namespace smisr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
        constexpr uint32_t SSRUMF = (1U << 6);  ///< SSRUMF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< CALRAF
        constexpr uint32_t CALRBF = (1U << 1);  ///< CALRBF
        constexpr uint32_t CWUTF = (1U << 2);  ///< CWUTF
        constexpr uint32_t CTSF = (1U << 3);  ///< CTSF
        constexpr uint32_t CTSOVF = (1U << 4);  ///< CTSOVF
        constexpr uint32_t CITSF = (1U << 5);  ///< CITSF
        constexpr uint32_t CSSRUF = (1U << 6);  ///< CSSRUF
    }

    /// ALRABINR Register bits
    namespace alrabinr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous counter alarm value in Binary mode
    }

    /// ALRBBINR Register bits
    namespace alrbbinr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous counter alarm value in Binary mode
    }

}

// ============================================================================
// SAI1 Peripheral
// ============================================================================

namespace sai1 {
    /// Base addresses
    constexpr uint32_t SAI1_BASE = 0x40015400;

    /// SAI1 Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - Global configuration register
        volatile uint32_t ACR1;  ///< Offset: 0x04 - A Configuration register 1
        volatile uint32_t BCR1;  ///< Offset: 0x24 - B Configuration register 1
        volatile uint32_t ACR2;  ///< Offset: 0x08 - A Configuration register 2
        volatile uint32_t BCR2;  ///< Offset: 0x28 - B Configuration register 2
        volatile uint32_t AFRCR;  ///< Offset: 0x0C - A frame configuration register
        volatile uint32_t BFRCR;  ///< Offset: 0x2C - B frame configuration register
        volatile uint32_t ASLOTR;  ///< Offset: 0x10 - A Slot register
        volatile uint32_t BSLOTR;  ///< Offset: 0x30 - B Slot register
        volatile uint32_t AIM;  ///< Offset: 0x14 - A Interrupt mask register
        volatile uint32_t BIM;  ///< Offset: 0x34 - B Interrupt mask register
        volatile uint32_t ASR;  ///< Offset: 0x18 - A Status register
        volatile uint32_t BSR;  ///< Offset: 0x38 - B Status register
        volatile uint32_t ACLRFR;  ///< Offset: 0x1C - A Clear flag register
        volatile uint32_t BCLRFR;  ///< Offset: 0x3C - B Clear flag register
        volatile uint32_t ADR;  ///< Offset: 0x20 - A Data register
        volatile uint32_t BDR;  ///< Offset: 0x40 - B Data register
        volatile uint32_t PDMCR;  ///< Offset: 0x44 - PDM control register
        volatile uint32_t PDMDLY;  ///< Offset: 0x48 - PDM delay register
    };

    /// Peripheral instances
    inline Registers* SAI1 = reinterpret_cast<Registers*>(SAI1_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t SYNCIN = (2 << 0);  ///< Synchronization inputs
        constexpr uint32_t SYNCOUT = (2 << 4);  ///< Synchronization outputs
    }

    /// ACR1 Register bits
    namespace acr1_bits {
        constexpr uint32_t MCKEN = (1U << 27);  ///< MCKEN
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
        constexpr uint32_t MCKDIV = (6 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OUTDRIV = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MCKEN = (1U << 27);  ///< MCKEN
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
        constexpr uint32_t MCKDIV = (6 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OUTDRIV = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// ACR2 Register bits
    namespace acr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUSH = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUSH = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// AFRCR Register bits
    namespace afrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// BFRCR Register bits
    namespace bfrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// ASLOTR Register bits
    namespace aslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// BSLOTR Register bits
    namespace bslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// AIM Register bits
    namespace aim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFGIE = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDETIE = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// BIM Register bits
    namespace bim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFGIE = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDETIE = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// ASR Register bits
    namespace asr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag. This bit is read only
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// BSR Register bits
    namespace bsr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// ACLRFR Register bits
    namespace aclrfr_bits {
        constexpr uint32_t CLFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CCNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t CWCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t CMUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t COVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// BCLRFR Register bits
    namespace bclrfr_bits {
        constexpr uint32_t CLFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CCNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t CWCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t CMUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t COVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// ADR Register bits
    namespace adr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// BDR Register bits
    namespace bdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// PDMCR Register bits
    namespace pdmcr_bits {
        constexpr uint32_t PDMEN = (1U << 0);  ///< PDM enable
        constexpr uint32_t MICNBR = (2 << 4);  ///< MICNBR
        constexpr uint32_t CKEN1 = (1U << 8);  ///< Clock enable of bitstream clock number 1
        constexpr uint32_t CKEN2 = (1U << 9);  ///< CKEN2
        constexpr uint32_t CKEN3 = (1U << 10);  ///< CKEN3
        constexpr uint32_t CKEN4 = (1U << 11);  ///< CKEN4
    }

    /// PDMDLY Register bits
    namespace pdmdly_bits {
        constexpr uint32_t DLYM1L = (3 << 0);  ///< Delay line adjust for first microphone of pair 1
        constexpr uint32_t DLYM1R = (3 << 4);  ///< Delay line adjust for second microphone of pair 1
        constexpr uint32_t DLYM2L = (3 << 8);  ///< Delay line for first microphone of pair 2
        constexpr uint32_t DLYM2R = (3 << 12);  ///< Delay line for second microphone of pair 2
        constexpr uint32_t DLYM3L = (3 << 16);  ///< DLYM3L
        constexpr uint32_t DLYM3R = (3 << 20);  ///< DLYM3R
        constexpr uint32_t DLYM4L = (3 << 24);  ///< DLYM4L
        constexpr uint32_t DLYM4R = (3 << 28);  ///< DLYM4R
    }

}

// ============================================================================
// SAI2 Peripheral
// ============================================================================

namespace sai2 {
    /// Base addresses
    constexpr uint32_t SAI2_BASE = 0x40015800;

    /// SAI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI2 = reinterpret_cast<Registers*>(SAI2_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t GPDMA1_BASE = 0x40020000;
    constexpr uint32_t SEC_GPDMA1_BASE = 0x50020000;
    constexpr uint32_t LPDMA1_BASE = 0x46025000;
    constexpr uint32_t SEC_LPDMA1_BASE = 0x56025000;
    constexpr uint32_t DMA2D_BASE = 0x4002B000;
    constexpr uint32_t SEC_DMA2D_BASE = 0x5002B000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t GPDMA_SECCFGR;  ///< Offset: 0x00 - GPDMA secure configuration register
        volatile uint32_t GPDMA_PRIVCFGR;  ///< Offset: 0x04 - GPDMA privileged configuration register
        volatile uint32_t GPDMA_RCFGLOCKR;  ///< Offset: 0x08 - GPDMA configuration lock register
        volatile uint32_t GPDMA_MISR;  ///< Offset: 0x0C - GPDMA non-secure masked interrupt status register
        volatile uint32_t GPDMA_SMISR;  ///< Offset: 0x10 - GPDMA secure masked interrupt status register
        volatile uint32_t GPDMA_C0LBAR;  ///< Offset: 0x50 - GPDMA channel 0 linked-list base address register
        volatile uint32_t GPDMA_C0FCR;  ///< Offset: 0x5C - GPDMA channel 0 flag clear register
        volatile uint32_t GPDMA_C0SR;  ///< Offset: 0x60 - GPDMA channel 0 status register
        volatile uint32_t GPDMA_C0CR;  ///< Offset: 0x64 - GPDMA channel 0 control register
        volatile uint32_t GPDMA_C0TR1;  ///< Offset: 0x90 - GPDMA channel 0 transfer register 1
        volatile uint32_t GPDMA_C0TR2;  ///< Offset: 0x94 - GPDMA channel 0 transfer register 2
        volatile uint32_t GPDMA_C0BR1;  ///< Offset: 0x98 - GPDMA channel 0 block register 1
        volatile uint32_t GPDMA_C0SAR;  ///< Offset: 0x9C - GPDMA channel 0 source address register
        volatile uint32_t GPDMA_C0DAR;  ///< Offset: 0xA0 - GPDMA channel 0 destination address register
        volatile uint32_t GPDMA_C0LLR;  ///< Offset: 0xCC - GPDMA channel 0 linked-list address register
        volatile uint32_t GPDMA_C1LBAR;  ///< Offset: 0xD0 - GPDMA channel 1 linked-list base address register
        volatile uint32_t GPDMA_C1FCR;  ///< Offset: 0xDC - GPDMA channel 1 flag clear register
        volatile uint32_t GPDMA_C1SR;  ///< Offset: 0xE0 - GPDMA channel 1 status register
        volatile uint32_t GPDMA_C1CR;  ///< Offset: 0xE4 - GPDMA channel 1 control register
        volatile uint32_t GPDMA_C1TR1;  ///< Offset: 0x110 - GPDMA channel 1 transfer register 1
        volatile uint32_t GPDMA_C1TR2;  ///< Offset: 0x114 - GPDMA channel 1 transfer register 2
        volatile uint32_t GPDMA_C1BR1;  ///< Offset: 0x118 - GPDMA channel 1 block register 1
        volatile uint32_t GPDMA_C1SAR;  ///< Offset: 0x11C - GPDMA channel 1 source address register
        volatile uint32_t GPDMA_C1DAR;  ///< Offset: 0x120 - GPDMA channel 1 destination address register
        volatile uint32_t GPDMA_C1LLR;  ///< Offset: 0x14C - GPDMA channel 1 linked-list address register
        volatile uint32_t GPDMA_C2LBAR;  ///< Offset: 0x150 - GPDMA channel 2 linked-list base address register
        volatile uint32_t GPDMA_C2FCR;  ///< Offset: 0x15C - GPDMA channel 2 flag clear register
        volatile uint32_t GPDMA_C2SR;  ///< Offset: 0x160 - GPDMA channel 2 status register
        volatile uint32_t GPDMA_C2CR;  ///< Offset: 0x164 - GPDMA channel 2 control register
        volatile uint32_t GPDMA_C2TR1;  ///< Offset: 0x190 - GPDMA channel 2 transfer register 1
        volatile uint32_t GPDMA_C2TR2;  ///< Offset: 0x194 - GPDMA channel 2 transfer register 2
        volatile uint32_t GPDMA_C2BR1;  ///< Offset: 0x198 - GPDMA channel 2 block register 1
        volatile uint32_t GPDMA_C2SAR;  ///< Offset: 0x19C - GPDMA channel 2 source address register
        volatile uint32_t GPDMA_C2DAR;  ///< Offset: 0x1A0 - GPDMA channel 2 destination address register
        volatile uint32_t GPDMA_C2LLR;  ///< Offset: 0x1CC - GPDMA channel 2 linked-list address register
        volatile uint32_t GPDMA_C3LBAR;  ///< Offset: 0x1D0 - GPDMA channel 3 linked-list base address register
        volatile uint32_t GPDMA_C3FCR;  ///< Offset: 0x1DC - GPDMA channel 3 flag clear register
        volatile uint32_t GPDMA_C3SR;  ///< Offset: 0x1E0 - GPDMA channel 3 status register
        volatile uint32_t GPDMA_C3CR;  ///< Offset: 0x1E4 - GPDMA channel 3 control register
        volatile uint32_t GPDMA_C3TR1;  ///< Offset: 0x210 - GPDMA channel 3 transfer register 1
        volatile uint32_t GPDMA_C3TR2;  ///< Offset: 0x214 - GPDMA channel 3 transfer register 2
        volatile uint32_t GPDMA_C3BR1;  ///< Offset: 0x218 - GPDMA channel 3 block register 1
        volatile uint32_t GPDMA_C3SAR;  ///< Offset: 0x21C - GPDMA channel 3 source address register
        volatile uint32_t GPDMA_C3DAR;  ///< Offset: 0x220 - GPDMA channel 3 destination address register
        volatile uint32_t GPDMA_C3LLR;  ///< Offset: 0x24C - GPDMA channel 3 linked-list address register
        volatile uint32_t GPDMA_C4LBAR;  ///< Offset: 0x250 - GPDMA channel 4 linked-list base address register
        volatile uint32_t GPDMA_C4FCR;  ///< Offset: 0x25C - GPDMA channel 4 flag clear register
        volatile uint32_t GPDMA_C4SR;  ///< Offset: 0x260 - GPDMA channel 4 status register
        volatile uint32_t GPDMA_C4CR;  ///< Offset: 0x264 - GPDMA channel 4 control register
        volatile uint32_t GPDMA_C4TR1;  ///< Offset: 0x290 - GPDMA channel 4 transfer register 1
        volatile uint32_t GPDMA_C4TR2;  ///< Offset: 0x294 - GPDMA channel 4 transfer register 2
        volatile uint32_t GPDMA_C4BR1;  ///< Offset: 0x298 - GPDMA channel 4 block register 1
        volatile uint32_t GPDMA_C4SAR;  ///< Offset: 0x29C - GPDMA channel 4 source address register
        volatile uint32_t GPDMA_C4DAR;  ///< Offset: 0x2A0 - GPDMA channel 4 destination address register
        volatile uint32_t GPDMA_C4LLR;  ///< Offset: 0x2CC - GPDMA channel 4 linked-list address register
        volatile uint32_t GPDMA_C5LBAR;  ///< Offset: 0x2D0 - GPDMA channel 5 linked-list base address register
        volatile uint32_t GPDMA_C5FCR;  ///< Offset: 0x2DC - GPDMA channel 5 flag clear register
        volatile uint32_t GPDMA_C5SR;  ///< Offset: 0x2E0 - GPDMA channel 5 status register
        volatile uint32_t GPDMA_C5CR;  ///< Offset: 0x2E4 - GPDMA channel 5 control register
        volatile uint32_t GPDMA_C5TR1;  ///< Offset: 0x310 - GPDMA channel 5 transfer register 1
        volatile uint32_t GPDMA_C5TR2;  ///< Offset: 0x314 - GPDMA channel 5 transfer register 2
        volatile uint32_t GPDMA_C5BR1;  ///< Offset: 0x318 - GPDMA channel 5 block register 1
        volatile uint32_t GPDMA_C5SAR;  ///< Offset: 0x31C - GPDMA channel 5 source address register
        volatile uint32_t GPDMA_C5DAR;  ///< Offset: 0x320 - GPDMA channel 5 destination address register
        volatile uint32_t GPDMA_C5LLR;  ///< Offset: 0x34C - GPDMA channel 5 linked-list address register
        volatile uint32_t GPDMA_C6LBAR;  ///< Offset: 0x350 - GPDMA channel 6 linked-list base address register
        volatile uint32_t GPDMA_C6FCR;  ///< Offset: 0x35C - GPDMA channel 6 flag clear register
        volatile uint32_t GPDMA_C6SR;  ///< Offset: 0x360 - GPDMA channel 6 status register
        volatile uint32_t GPDMA_C6CR;  ///< Offset: 0x364 - GPDMA channel 6 control register
        volatile uint32_t GPDMA_C6TR1;  ///< Offset: 0x390 - GPDMA channel 6 transfer register 1
        volatile uint32_t GPDMA_C6TR2;  ///< Offset: 0x394 - GPDMA channel 6 transfer register 2
        volatile uint32_t GPDMA_C6BR1;  ///< Offset: 0x398 - GPDMA channel 6 block register 1
        volatile uint32_t GPDMA_C6SAR;  ///< Offset: 0x39C - GPDMA channel 6 source address register
        volatile uint32_t GPDMA_C6DAR;  ///< Offset: 0x3A0 - GPDMA channel 6 destination address register
        volatile uint32_t GPDMA_C6LLR;  ///< Offset: 0x3CC - GPDMA channel 6 linked-list address register
        volatile uint32_t GPDMA_C7LBAR;  ///< Offset: 0x3D0 - GPDMA channel 7 linked-list base address register
        volatile uint32_t GPDMA_C7FCR;  ///< Offset: 0x3DC - GPDMA channel 7 flag clear register
        volatile uint32_t GPDMA_C7SR;  ///< Offset: 0x3E0 - GPDMA channel 7 status register
        volatile uint32_t GPDMA_C7CR;  ///< Offset: 0x3E4 - GPDMA channel 7 control register
        volatile uint32_t GPDMA_C7TR1;  ///< Offset: 0x410 - GPDMA channel 7 transfer register 1
        volatile uint32_t GPDMA_C7TR2;  ///< Offset: 0x414 - GPDMA channel 7 transfer register 2
        volatile uint32_t GPDMA_C7BR1;  ///< Offset: 0x418 - GPDMA channel 7 block register 1
        volatile uint32_t GPDMA_C7SAR;  ///< Offset: 0x41C - GPDMA channel 7 source address register
        volatile uint32_t GPDMA_C7DAR;  ///< Offset: 0x420 - GPDMA channel 7 destination address register
        volatile uint32_t GPDMA_C7LLR;  ///< Offset: 0x44C - GPDMA channel 7 linked-list address register
        volatile uint32_t GPDMA_C8LBAR;  ///< Offset: 0x450 - GPDMA channel 8 linked-list base address register
        volatile uint32_t GPDMA_C8FCR;  ///< Offset: 0x45C - GPDMA channel 8 flag clear register
        volatile uint32_t GPDMA_C8SR;  ///< Offset: 0x460 - GPDMA channel 8 status register
        volatile uint32_t GPDMA_C8CR;  ///< Offset: 0x464 - GPDMA channel 8 control register
        volatile uint32_t GPDMA_C8TR1;  ///< Offset: 0x490 - GPDMA channel 8 transfer register 1
        volatile uint32_t GPDMA_C8TR2;  ///< Offset: 0x494 - GPDMA channel 8 transfer register 2
        volatile uint32_t GPDMA_C8BR1;  ///< Offset: 0x498 - GPDMA channel 8 block register 1
        volatile uint32_t GPDMA_C8SAR;  ///< Offset: 0x49C - GPDMA channel 8 source address register
        volatile uint32_t GPDMA_C8DAR;  ///< Offset: 0x4A0 - GPDMA channel 8 destination address register
        volatile uint32_t GPDMA_C8LLR;  ///< Offset: 0x4CC - GPDMA channel 8 linked-list address register
        volatile uint32_t GPDMA_C9LBAR;  ///< Offset: 0x4D0 - GPDMA channel 9 linked-list base address register
        volatile uint32_t GPDMA_C9FCR;  ///< Offset: 0x4DC - GPDMA channel 9 flag clear register
        volatile uint32_t GPDMA_C9SR;  ///< Offset: 0x4E0 - GPDMA channel 9 status register
        volatile uint32_t GPDMA_C9CR;  ///< Offset: 0x4E4 - GPDMA channel 9 control register
        volatile uint32_t GPDMA_C9TR1;  ///< Offset: 0x510 - GPDMA channel 9 transfer register 1
        volatile uint32_t GPDMA_C9TR2;  ///< Offset: 0x514 - GPDMA channel 9 transfer register 2
        volatile uint32_t GPDMA_C9BR1;  ///< Offset: 0x518 - GPDMA channel 9 block register 1
        volatile uint32_t GPDMA_C9SAR;  ///< Offset: 0x51C - GPDMA channel 9 source address register
        volatile uint32_t GPDMA_C9DAR;  ///< Offset: 0x520 - GPDMA channel 9 destination address register
        volatile uint32_t GPDMA_C9LLR;  ///< Offset: 0x54C - GPDMA channel 9 linked-list address register
        volatile uint32_t GPDMA_C10LBAR;  ///< Offset: 0x550 - GPDMA channel 10 linked-list base address register
        volatile uint32_t GPDMA_C10FCR;  ///< Offset: 0x55C - GPDMA channel 10 flag clear register
        volatile uint32_t GPDMA_C10SR;  ///< Offset: 0x560 - GPDMA channel 10 status register
        volatile uint32_t GPDMA_C10CR;  ///< Offset: 0x564 - GPDMA channel 10 control register
        volatile uint32_t GPDMA_C10TR1;  ///< Offset: 0x590 - GPDMA channel 10 transfer register 1
        volatile uint32_t GPDMA_C10TR2;  ///< Offset: 0x594 - GPDMA channel 10 transfer register 2
        volatile uint32_t GPDMA_C10BR1;  ///< Offset: 0x598 - GPDMA channel 10 block register 1
        volatile uint32_t GPDMA_C10SAR;  ///< Offset: 0x59C - GPDMA channel 10 source address register
        volatile uint32_t GPDMA_C10DAR;  ///< Offset: 0x5A0 - GPDMA channel 10 destination address register
        volatile uint32_t GPDMA_C10LLR;  ///< Offset: 0x5CC - GPDMA channel 10 linked-list address register
        volatile uint32_t GPDMA_C11LBAR;  ///< Offset: 0x5D0 - GPDMA channel 11 linked-list base address register
        volatile uint32_t GPDMA_C11FCR;  ///< Offset: 0x5DC - GPDMA channel 11 flag clear register
        volatile uint32_t GPDMA_C11SR;  ///< Offset: 0x5E0 - GPDMA channel 11 status register
        volatile uint32_t GPDMA_C11CR;  ///< Offset: 0x5E4 - GPDMA channel 11 control register
        volatile uint32_t GPDMA_C11TR1;  ///< Offset: 0x610 - GPDMA channel 11 transfer register 1
        volatile uint32_t GPDMA_C11TR2;  ///< Offset: 0x614 - GPDMA channel 11 transfer register 2
        volatile uint32_t GPDMA_C11BR1;  ///< Offset: 0x618 - GPDMA channel 11 block register 1
        volatile uint32_t GPDMA_C11SAR;  ///< Offset: 0x61C - GPDMA channel 11 source address register
        volatile uint32_t GPDMA_C11DAR;  ///< Offset: 0x620 - GPDMA channel 11 destination address register
        volatile uint32_t GPDMA_C11LLR;  ///< Offset: 0x64C - GPDMA channel 11 linked-list address register
        volatile uint32_t GPDMA_C12LBAR;  ///< Offset: 0x650 - GPDMA channel 12 linked-list base address register
        volatile uint32_t GPDMA_C12FCR;  ///< Offset: 0x65C - GPDMA channel 12 flag clear register
        volatile uint32_t GPDMA_C12SR;  ///< Offset: 0x660 - GPDMA channel 12 status register
        volatile uint32_t GPDMA_C12CR;  ///< Offset: 0x664 - GPDMA channel 12 control register
        volatile uint32_t GPDMA_C12TR1;  ///< Offset: 0x690 - GPDMA channel 12 transfer register 1
        volatile uint32_t GPDMA_C12TR2;  ///< Offset: 0x694 - GPDMA channel 12 transfer register 2
        volatile uint32_t GPDMA_C12BR1;  ///< Offset: 0x698 - GPDMA channel 12 alternate block register 1
        volatile uint32_t GPDMA_C12SAR;  ///< Offset: 0x69C - GPDMA channel 12 source address register
        volatile uint32_t GPDMA_C12DAR;  ///< Offset: 0x6A0 - GPDMA channel 12 destination address register
        volatile uint32_t GPDMA_C12TR3;  ///< Offset: 0x6A4 - GPDMA channel 12 transfer register 3
        volatile uint32_t GPDMA_C12BR2;  ///< Offset: 0x6A8 - GPDMA channel 12 block register 2
        volatile uint32_t GPDMA_C12LLR;  ///< Offset: 0x6CC - GPDMA channel 12 alternate linked-list address register
        volatile uint32_t GPDMA_C13LBAR;  ///< Offset: 0x6D0 - GPDMA channel 13 linked-list base address register
        volatile uint32_t GPDMA_C13FCR;  ///< Offset: 0x6DC - GPDMA channel 13 flag clear register
        volatile uint32_t GPDMA_C13SR;  ///< Offset: 0x6E0 - GPDMA channel 13 status register
        volatile uint32_t GPDMA_C13CR;  ///< Offset: 0x6E4 - GPDMA channel 13 control register
        volatile uint32_t GPDMA_C13TR1;  ///< Offset: 0x710 - GPDMA channel 13 transfer register 1
        volatile uint32_t GPDMA_C13TR2;  ///< Offset: 0x714 - GPDMA channel 13 transfer register 2
        volatile uint32_t GPDMA_C13BR1;  ///< Offset: 0x718 - GPDMA channel 13 alternate block register 1
        volatile uint32_t GPDMA_C13SAR;  ///< Offset: 0x71C - GPDMA channel 13 source address register
        volatile uint32_t GPDMA_C13DAR;  ///< Offset: 0x720 - GPDMA channel 13 destination address register
        volatile uint32_t GPDMA_C13TR3;  ///< Offset: 0x724 - GPDMA channel 13 transfer register 3
        volatile uint32_t GPDMA_C13BR2;  ///< Offset: 0x728 - GPDMA channel 13 block register 2
        volatile uint32_t GPDMA_C13LLR;  ///< Offset: 0x74C - GPDMA channel 13 alternate linked-list address register
        volatile uint32_t GPDMA_C14LBAR;  ///< Offset: 0x750 - GPDMA channel 14 linked-list base address register
        volatile uint32_t GPDMA_C14FCR;  ///< Offset: 0x75C - GPDMA channel 14 flag clear register
        volatile uint32_t GPDMA_C14SR;  ///< Offset: 0x760 - GPDMA channel 14 status register
        volatile uint32_t GPDMA_C14CR;  ///< Offset: 0x764 - GPDMA channel 14 control register
        volatile uint32_t GPDMA_C14TR1;  ///< Offset: 0x790 - GPDMA channel 14 transfer register 1
        volatile uint32_t GPDMA_C14TR2;  ///< Offset: 0x794 - GPDMA channel 14 transfer register 2
        volatile uint32_t GPDMA_C14BR1;  ///< Offset: 0x798 - GPDMA channel 14 alternate block register 1
        volatile uint32_t GPDMA_C14SAR;  ///< Offset: 0x79C - GPDMA channel 14 source address register
        volatile uint32_t GPDMA_C14DAR;  ///< Offset: 0x7A0 - GPDMA channel 14 destination address register
        volatile uint32_t GPDMA_C14TR3;  ///< Offset: 0x7A4 - GPDMA channel 14 transfer register 3
        volatile uint32_t GPDMA_C14BR2;  ///< Offset: 0x7A8 - GPDMA channel 14 block register 2
        volatile uint32_t GPDMA_C14LLR;  ///< Offset: 0x7CC - GPDMA channel 14 alternate linked-list address register
        volatile uint32_t GPDMA_C15LBAR;  ///< Offset: 0x7D0 - GPDMA channel 15 linked-list base address register
        volatile uint32_t GPDMA_C15FCR;  ///< Offset: 0x7DC - GPDMA channel 15 flag clear register
        volatile uint32_t GPDMA_C15SR;  ///< Offset: 0x7E0 - GPDMA channel 15 status register
        volatile uint32_t GPDMA_C15CR;  ///< Offset: 0x7E4 - GPDMA channel 15 control register
        volatile uint32_t GPDMA_C15TR1;  ///< Offset: 0x810 - GPDMA channel 15 transfer register 1
        volatile uint32_t GPDMA_C15TR2;  ///< Offset: 0x814 - GPDMA channel 15 transfer register 2
        volatile uint32_t GPDMA_C15BR1;  ///< Offset: 0x818 - GPDMA channel 15 alternate block register 1
        volatile uint32_t GPDMA_C15SAR;  ///< Offset: 0x81C - GPDMA channel 15 source address register
        volatile uint32_t GPDMA_C15DAR;  ///< Offset: 0x820 - GPDMA channel 15 destination address register
        volatile uint32_t GPDMA_C15TR3;  ///< Offset: 0x824 - GPDMA channel 15 transfer register 3
        volatile uint32_t GPDMA_C15BR2;  ///< Offset: 0x828 - GPDMA channel 15 block register 2
        volatile uint32_t GPDMA_C15LLR;  ///< Offset: 0x84C - GPDMA channel 15 alternate linked-list address register
    };

    /// Peripheral instances
    inline Registers* GPDMA1 = reinterpret_cast<Registers*>(GPDMA1_BASE);
    inline Registers* SEC_GPDMA1 = reinterpret_cast<Registers*>(SEC_GPDMA1_BASE);
    inline Registers* LPDMA1 = reinterpret_cast<Registers*>(LPDMA1_BASE);
    inline Registers* SEC_LPDMA1 = reinterpret_cast<Registers*>(SEC_LPDMA1_BASE);
    inline Registers* DMA2D = reinterpret_cast<Registers*>(DMA2D_BASE);
    inline Registers* SEC_DMA2D = reinterpret_cast<Registers*>(SEC_DMA2D_BASE);

    // Bit definitions
    /// GPDMA_SECCFGR Register bits
    namespace gpdma_seccfgr_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
    }

    /// GPDMA_PRIVCFGR Register bits
    namespace gpdma_privcfgr_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
    }

    /// GPDMA_RCFGLOCKR Register bits
    namespace gpdma_rcfglockr_bits {
        constexpr uint32_t LOCK0 = (1U << 0);  ///< LOCK0
        constexpr uint32_t LOCK1 = (1U << 1);  ///< LOCK1
        constexpr uint32_t LOCK2 = (1U << 2);  ///< LOCK2
        constexpr uint32_t LOCK3 = (1U << 3);  ///< LOCK3
        constexpr uint32_t LOCK4 = (1U << 4);  ///< LOCK4
        constexpr uint32_t LOCK5 = (1U << 5);  ///< LOCK5
        constexpr uint32_t LOCK6 = (1U << 6);  ///< LOCK6
        constexpr uint32_t LOCK7 = (1U << 7);  ///< LOCK7
        constexpr uint32_t LOCK8 = (1U << 8);  ///< LOCK8
        constexpr uint32_t LOCK9 = (1U << 9);  ///< LOCK9
        constexpr uint32_t LOCK10 = (1U << 10);  ///< LOCK10
        constexpr uint32_t LOCK11 = (1U << 11);  ///< LOCK11
        constexpr uint32_t LOCK12 = (1U << 12);  ///< LOCK12
        constexpr uint32_t LOCK13 = (1U << 13);  ///< LOCK13
        constexpr uint32_t LOCK14 = (1U << 14);  ///< LOCK14
        constexpr uint32_t LOCK15 = (1U << 15);  ///< LOCK15
    }

    /// GPDMA_MISR Register bits
    namespace gpdma_misr_bits {
        constexpr uint32_t MIS0 = (1U << 0);  ///< MIS0
        constexpr uint32_t MIS1 = (1U << 1);  ///< MIS1
        constexpr uint32_t MIS2 = (1U << 2);  ///< MIS2
        constexpr uint32_t MIS3 = (1U << 3);  ///< MIS3
        constexpr uint32_t MIS4 = (1U << 4);  ///< MIS4
        constexpr uint32_t MIS5 = (1U << 5);  ///< MIS5
        constexpr uint32_t MIS6 = (1U << 6);  ///< MIS6
        constexpr uint32_t MIS7 = (1U << 7);  ///< MIS7
        constexpr uint32_t MIS8 = (1U << 8);  ///< MIS8
        constexpr uint32_t MIS9 = (1U << 9);  ///< MIS9
        constexpr uint32_t MIS10 = (1U << 10);  ///< MIS10
        constexpr uint32_t MIS11 = (1U << 11);  ///< MIS11
        constexpr uint32_t MIS12 = (1U << 12);  ///< MIS12
        constexpr uint32_t MIS13 = (1U << 13);  ///< MIS13
        constexpr uint32_t MIS14 = (1U << 14);  ///< MIS14
        constexpr uint32_t MIS15 = (1U << 15);  ///< MIS15
    }

    /// GPDMA_SMISR Register bits
    namespace gpdma_smisr_bits {
        constexpr uint32_t MIS0 = (1U << 0);  ///< MIS0
        constexpr uint32_t MIS1 = (1U << 1);  ///< MIS1
        constexpr uint32_t MIS2 = (1U << 2);  ///< MIS2
        constexpr uint32_t MIS3 = (1U << 3);  ///< MIS3
        constexpr uint32_t MIS4 = (1U << 4);  ///< MIS4
        constexpr uint32_t MIS5 = (1U << 5);  ///< MIS5
        constexpr uint32_t MIS6 = (1U << 6);  ///< MIS6
        constexpr uint32_t MIS7 = (1U << 7);  ///< MIS7
        constexpr uint32_t MIS8 = (1U << 8);  ///< MIS8
        constexpr uint32_t MIS9 = (1U << 9);  ///< MIS9
        constexpr uint32_t MIS10 = (1U << 10);  ///< MIS10
        constexpr uint32_t MIS11 = (1U << 11);  ///< MIS11
        constexpr uint32_t MIS12 = (1U << 12);  ///< MIS12
        constexpr uint32_t MIS13 = (1U << 13);  ///< MIS13
        constexpr uint32_t MIS14 = (1U << 14);  ///< MIS14
        constexpr uint32_t MIS15 = (1U << 15);  ///< MIS15
    }

    /// GPDMA_C0LBAR Register bits
    namespace gpdma_c0lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C0FCR Register bits
    namespace gpdma_c0fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C0SR Register bits
    namespace gpdma_c0sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C0CR Register bits
    namespace gpdma_c0cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C0TR1 Register bits
    namespace gpdma_c0tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C0TR2 Register bits
    namespace gpdma_c0tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C0BR1 Register bits
    namespace gpdma_c0br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C0SAR Register bits
    namespace gpdma_c0sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C0DAR Register bits
    namespace gpdma_c0dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C0LLR Register bits
    namespace gpdma_c0llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C1LBAR Register bits
    namespace gpdma_c1lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C1FCR Register bits
    namespace gpdma_c1fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C1SR Register bits
    namespace gpdma_c1sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C1CR Register bits
    namespace gpdma_c1cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C1TR1 Register bits
    namespace gpdma_c1tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C1TR2 Register bits
    namespace gpdma_c1tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C1BR1 Register bits
    namespace gpdma_c1br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C1SAR Register bits
    namespace gpdma_c1sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C1DAR Register bits
    namespace gpdma_c1dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C1LLR Register bits
    namespace gpdma_c1llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C2LBAR Register bits
    namespace gpdma_c2lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C2FCR Register bits
    namespace gpdma_c2fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C2SR Register bits
    namespace gpdma_c2sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C2CR Register bits
    namespace gpdma_c2cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C2TR1 Register bits
    namespace gpdma_c2tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C2TR2 Register bits
    namespace gpdma_c2tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C2BR1 Register bits
    namespace gpdma_c2br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C2SAR Register bits
    namespace gpdma_c2sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C2DAR Register bits
    namespace gpdma_c2dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C2LLR Register bits
    namespace gpdma_c2llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C3LBAR Register bits
    namespace gpdma_c3lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C3FCR Register bits
    namespace gpdma_c3fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C3SR Register bits
    namespace gpdma_c3sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C3CR Register bits
    namespace gpdma_c3cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C3TR1 Register bits
    namespace gpdma_c3tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C3TR2 Register bits
    namespace gpdma_c3tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C3BR1 Register bits
    namespace gpdma_c3br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C3SAR Register bits
    namespace gpdma_c3sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C3DAR Register bits
    namespace gpdma_c3dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C3LLR Register bits
    namespace gpdma_c3llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C4LBAR Register bits
    namespace gpdma_c4lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C4FCR Register bits
    namespace gpdma_c4fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C4SR Register bits
    namespace gpdma_c4sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C4CR Register bits
    namespace gpdma_c4cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C4TR1 Register bits
    namespace gpdma_c4tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C4TR2 Register bits
    namespace gpdma_c4tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C4BR1 Register bits
    namespace gpdma_c4br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C4SAR Register bits
    namespace gpdma_c4sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C4DAR Register bits
    namespace gpdma_c4dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C4LLR Register bits
    namespace gpdma_c4llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C5LBAR Register bits
    namespace gpdma_c5lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C5FCR Register bits
    namespace gpdma_c5fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C5SR Register bits
    namespace gpdma_c5sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C5CR Register bits
    namespace gpdma_c5cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C5TR1 Register bits
    namespace gpdma_c5tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C5TR2 Register bits
    namespace gpdma_c5tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C5BR1 Register bits
    namespace gpdma_c5br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C5SAR Register bits
    namespace gpdma_c5sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C5DAR Register bits
    namespace gpdma_c5dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C5LLR Register bits
    namespace gpdma_c5llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C6LBAR Register bits
    namespace gpdma_c6lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C6FCR Register bits
    namespace gpdma_c6fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C6SR Register bits
    namespace gpdma_c6sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C6CR Register bits
    namespace gpdma_c6cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C6TR1 Register bits
    namespace gpdma_c6tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C6TR2 Register bits
    namespace gpdma_c6tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C6BR1 Register bits
    namespace gpdma_c6br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C6SAR Register bits
    namespace gpdma_c6sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C6DAR Register bits
    namespace gpdma_c6dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C6LLR Register bits
    namespace gpdma_c6llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C7LBAR Register bits
    namespace gpdma_c7lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C7FCR Register bits
    namespace gpdma_c7fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C7SR Register bits
    namespace gpdma_c7sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C7CR Register bits
    namespace gpdma_c7cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C7TR1 Register bits
    namespace gpdma_c7tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C7TR2 Register bits
    namespace gpdma_c7tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C7BR1 Register bits
    namespace gpdma_c7br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C7SAR Register bits
    namespace gpdma_c7sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C7DAR Register bits
    namespace gpdma_c7dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C7LLR Register bits
    namespace gpdma_c7llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C8LBAR Register bits
    namespace gpdma_c8lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C8FCR Register bits
    namespace gpdma_c8fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C8SR Register bits
    namespace gpdma_c8sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C8CR Register bits
    namespace gpdma_c8cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C8TR1 Register bits
    namespace gpdma_c8tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C8TR2 Register bits
    namespace gpdma_c8tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C8BR1 Register bits
    namespace gpdma_c8br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C8SAR Register bits
    namespace gpdma_c8sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C8DAR Register bits
    namespace gpdma_c8dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C8LLR Register bits
    namespace gpdma_c8llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C9LBAR Register bits
    namespace gpdma_c9lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C9FCR Register bits
    namespace gpdma_c9fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C9SR Register bits
    namespace gpdma_c9sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C9CR Register bits
    namespace gpdma_c9cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C9TR1 Register bits
    namespace gpdma_c9tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C9TR2 Register bits
    namespace gpdma_c9tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C9BR1 Register bits
    namespace gpdma_c9br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C9SAR Register bits
    namespace gpdma_c9sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C9DAR Register bits
    namespace gpdma_c9dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C9LLR Register bits
    namespace gpdma_c9llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C10LBAR Register bits
    namespace gpdma_c10lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C10FCR Register bits
    namespace gpdma_c10fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C10SR Register bits
    namespace gpdma_c10sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C10CR Register bits
    namespace gpdma_c10cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C10TR1 Register bits
    namespace gpdma_c10tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C10TR2 Register bits
    namespace gpdma_c10tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C10BR1 Register bits
    namespace gpdma_c10br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C10SAR Register bits
    namespace gpdma_c10sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C10DAR Register bits
    namespace gpdma_c10dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C10LLR Register bits
    namespace gpdma_c10llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C11LBAR Register bits
    namespace gpdma_c11lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C11FCR Register bits
    namespace gpdma_c11fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C11SR Register bits
    namespace gpdma_c11sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C11CR Register bits
    namespace gpdma_c11cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C11TR1 Register bits
    namespace gpdma_c11tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C11TR2 Register bits
    namespace gpdma_c11tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C11BR1 Register bits
    namespace gpdma_c11br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]=0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C11SAR Register bits
    namespace gpdma_c11sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C11DAR Register bits
    namespace gpdma_c11dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C11LLR Register bits
    namespace gpdma_c11llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C12LBAR Register bits
    namespace gpdma_c12lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C12FCR Register bits
    namespace gpdma_c12fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C12SR Register bits
    namespace gpdma_c12sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C12CR Register bits
    namespace gpdma_c12cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C12TR1 Register bits
    namespace gpdma_c12tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C12TR2 Register bits
    namespace gpdma_c12tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C12BR1 Register bits
    namespace gpdma_c12br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
        constexpr uint32_t BRC = (11 << 16);  ///< Block repeat counter 	This field contains the number of repetitions of the current block (0 to 2047). 	When the channel is enabled, this field becomes read-only. After decrements, this field indicates the remaining number of blocks, excluding the current one. This counter is hardware decremented for each completed block transfer. 	Once the last block transfer is completed (BRC[10:0]=BNDT[15:0]=0): 	If GPDMA_CxLLR.UB1=1, all GPDMA_CxBR1 fields are updated by the next LLI in the memory. 	If GPDMA_CxLLR.UB1=0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value. 	if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	if GPDMA_CxLLR=0, this field is kept as zero following the last LLI and data transfer.
        constexpr uint32_t SDEC = (1U << 28);  ///< source address decrement
        constexpr uint32_t DDEC = (1U << 29);  ///< destination address decrement
        constexpr uint32_t BRSDEC = (1U << 30);  ///< Block repeat source address decrement 	Note: On top of this increment/decrement (depending on BRSDEC), GPDMA_CxSAR is in the same time also updated by the increment/decrement (depending on SDEC) of the GPDMA_CxTR3.SAO value, as it is done after any programmed burst transfer.
        constexpr uint32_t BRDDEC = (1U << 31);  ///< Block repeat destination address decrement 	Note: On top of this increment/decrement (depending on BRDDEC), GPDMA_CxDAR is in the same time also updated by the increment/decrement (depending on DDEC) of the GPDMA_CxTR3.DAO value, as it is usually done at the end of each programmed burst transfer.
    }

    /// GPDMA_C12SAR Register bits
    namespace gpdma_c12sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C12DAR Register bits
    namespace gpdma_c12dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C12TR3 Register bits
    namespace gpdma_c12tr3_bits {
        constexpr uint32_t SAO = (13 << 0);  ///< source address offset increment 	The source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.SINC=1). 	Note: A source address offset must be aligned with the programmed data width of a source burst (SAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued. 	When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
        constexpr uint32_t DAO = (13 << 16);  ///< destination address offset increment 	The destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.DINC=1). 	Note: A destination address offset must be aligned with the programmed data width of a destination burst (DAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C12BR2 Register bits
    namespace gpdma_c12br2_bits {
        constexpr uint32_t BRSAO = (16 << 0);  ///< Block repeated source address offset 	For a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (GPDMA_CxSAR) at the end of a block transfer. 	Note: A block repeated source address offset must be aligned with the programmed data width of a source burst (BRSAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
        constexpr uint32_t BRDAO = (16 << 16);  ///< Block repeated destination address offset 	For a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (GPDMA_CxDAR) at the end of a block transfer. 	Note: A block repeated destination address offset must be aligned with the programmed data width of a destination burst (BRDAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C12LLR Register bits
    namespace gpdma_c12llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UB2 = (1U << 25);  ///< Update GPDMA_CxBR2 from memory 	This bit controls the update of GPDMA_CxBR2 from the memory during the link transfer.
        constexpr uint32_t UT3 = (1U << 26);  ///< Update GPDMA_CxTR3 from memory 	This bit controls the update of GPDMA_CxTR3 from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C13LBAR Register bits
    namespace gpdma_c13lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C13FCR Register bits
    namespace gpdma_c13fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C13SR Register bits
    namespace gpdma_c13sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C13CR Register bits
    namespace gpdma_c13cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C13TR1 Register bits
    namespace gpdma_c13tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C13TR2 Register bits
    namespace gpdma_c13tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C13BR1 Register bits
    namespace gpdma_c13br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
        constexpr uint32_t BRC = (11 << 16);  ///< Block repeat counter 	This field contains the number of repetitions of the current block (0 to 2047). 	When the channel is enabled, this field becomes read-only. After decrements, this field indicates the remaining number of blocks, excluding the current one. This counter is hardware decremented for each completed block transfer. 	Once the last block transfer is completed (BRC[10:0]=BNDT[15:0]=0): 	If GPDMA_CxLLR.UB1=1, all GPDMA_CxBR1 fields are updated by the next LLI in the memory. 	If GPDMA_CxLLR.UB1=0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value. 	if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	if GPDMA_CxLLR=0, this field is kept as zero following the last LLI and data transfer.
        constexpr uint32_t SDEC = (1U << 28);  ///< source address decrement
        constexpr uint32_t DDEC = (1U << 29);  ///< destination address decrement
        constexpr uint32_t BRSDEC = (1U << 30);  ///< Block repeat source address decrement 	Note: On top of this increment/decrement (depending on BRSDEC), GPDMA_CxSAR is in the same time also updated by the increment/decrement (depending on SDEC) of the GPDMA_CxTR3.SAO value, as it is done after any programmed burst transfer.
        constexpr uint32_t BRDDEC = (1U << 31);  ///< Block repeat destination address decrement 	Note: On top of this increment/decrement (depending on BRDDEC), GPDMA_CxDAR is in the same time also updated by the increment/decrement (depending on DDEC) of the GPDMA_CxTR3.DAO value, as it is usually done at the end of each programmed burst transfer.
    }

    /// GPDMA_C13SAR Register bits
    namespace gpdma_c13sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C13DAR Register bits
    namespace gpdma_c13dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C13TR3 Register bits
    namespace gpdma_c13tr3_bits {
        constexpr uint32_t SAO = (13 << 0);  ///< source address offset increment 	The source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.SINC=1). 	Note: A source address offset must be aligned with the programmed data width of a source burst (SAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued. 	When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
        constexpr uint32_t DAO = (13 << 16);  ///< destination address offset increment 	The destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.DINC=1). 	Note: A destination address offset must be aligned with the programmed data width of a destination burst (DAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C13BR2 Register bits
    namespace gpdma_c13br2_bits {
        constexpr uint32_t BRSAO = (16 << 0);  ///< Block repeated source address offset 	For a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (GPDMA_CxSAR) at the end of a block transfer. 	Note: A block repeated source address offset must be aligned with the programmed data width of a source burst (BRSAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
        constexpr uint32_t BRDAO = (16 << 16);  ///< Block repeated destination address offset 	For a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (GPDMA_CxDAR) at the end of a block transfer. 	Note: A block repeated destination address offset must be aligned with the programmed data width of a destination burst (BRDAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C13LLR Register bits
    namespace gpdma_c13llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UB2 = (1U << 25);  ///< Update GPDMA_CxBR2 from memory 	This bit controls the update of GPDMA_CxBR2 from the memory during the link transfer.
        constexpr uint32_t UT3 = (1U << 26);  ///< Update GPDMA_CxTR3 from memory 	This bit controls the update of GPDMA_CxTR3 from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C14LBAR Register bits
    namespace gpdma_c14lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C14FCR Register bits
    namespace gpdma_c14fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C14SR Register bits
    namespace gpdma_c14sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C14CR Register bits
    namespace gpdma_c14cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C14TR1 Register bits
    namespace gpdma_c14tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C14TR2 Register bits
    namespace gpdma_c14tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C14BR1 Register bits
    namespace gpdma_c14br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
        constexpr uint32_t BRC = (11 << 16);  ///< Block repeat counter 	This field contains the number of repetitions of the current block (0 to 2047). 	When the channel is enabled, this field becomes read-only. After decrements, this field indicates the remaining number of blocks, excluding the current one. This counter is hardware decremented for each completed block transfer. 	Once the last block transfer is completed (BRC[10:0]=BNDT[15:0]=0): 	If GPDMA_CxLLR.UB1=1, all GPDMA_CxBR1 fields are updated by the next LLI in the memory. 	If GPDMA_CxLLR.UB1=0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value. 	if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	if GPDMA_CxLLR=0, this field is kept as zero following the last LLI and data transfer.
        constexpr uint32_t SDEC = (1U << 28);  ///< source address decrement
        constexpr uint32_t DDEC = (1U << 29);  ///< destination address decrement
        constexpr uint32_t BRSDEC = (1U << 30);  ///< Block repeat source address decrement 	Note: On top of this increment/decrement (depending on BRSDEC), GPDMA_CxSAR is in the same time also updated by the increment/decrement (depending on SDEC) of the GPDMA_CxTR3.SAO value, as it is done after any programmed burst transfer.
        constexpr uint32_t BRDDEC = (1U << 31);  ///< Block repeat destination address decrement 	Note: On top of this increment/decrement (depending on BRDDEC), GPDMA_CxDAR is in the same time also updated by the increment/decrement (depending on DDEC) of the GPDMA_CxTR3.DAO value, as it is usually done at the end of each programmed burst transfer.
    }

    /// GPDMA_C14SAR Register bits
    namespace gpdma_c14sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C14DAR Register bits
    namespace gpdma_c14dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C14TR3 Register bits
    namespace gpdma_c14tr3_bits {
        constexpr uint32_t SAO = (13 << 0);  ///< source address offset increment 	The source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.SINC=1). 	Note: A source address offset must be aligned with the programmed data width of a source burst (SAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued. 	When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
        constexpr uint32_t DAO = (13 << 16);  ///< destination address offset increment 	The destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.DINC=1). 	Note: A destination address offset must be aligned with the programmed data width of a destination burst (DAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C14BR2 Register bits
    namespace gpdma_c14br2_bits {
        constexpr uint32_t BRSAO = (16 << 0);  ///< Block repeated source address offset 	For a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (GPDMA_CxSAR) at the end of a block transfer. 	Note: A block repeated source address offset must be aligned with the programmed data width of a source burst (BRSAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
        constexpr uint32_t BRDAO = (16 << 16);  ///< Block repeated destination address offset 	For a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (GPDMA_CxDAR) at the end of a block transfer. 	Note: A block repeated destination address offset must be aligned with the programmed data width of a destination burst (BRDAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C14LLR Register bits
    namespace gpdma_c14llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UB2 = (1U << 25);  ///< Update GPDMA_CxBR2 from memory 	This bit controls the update of GPDMA_CxBR2 from the memory during the link transfer.
        constexpr uint32_t UT3 = (1U << 26);  ///< Update GPDMA_CxTR3 from memory 	This bit controls the update of GPDMA_CxTR3 from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

    /// GPDMA_C15LBAR Register bits
    namespace gpdma_c15lbar_bits {
        constexpr uint32_t LBA = (16 << 16);  ///< linked-list base address of GPDMA channel x
    }

    /// GPDMA_C15FCR Register bits
    namespace gpdma_c15fcr_bits {
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag clear
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag clear
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag clear
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag clear
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag clear
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag clear
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag clear
    }

    /// GPDMA_C15SR Register bits
    namespace gpdma_c15sr_bits {
        constexpr uint32_t IDLEF = (1U << 0);  ///< idle flag 	This idle flag is de-asserted by hardware when the channel is enabled (GPDMA_CxCR.EN=1) with a valid channel configuration (no USEF to be immediately reported). 	This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).
        constexpr uint32_t TCF = (1U << 8);  ///< transfer complete flag 	A transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).
        constexpr uint32_t HTF = (1U << 9);  ///< half transfer flag 	An half transfer event is either an half block transfer or an half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]). 	An half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination. 	An half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination.
        constexpr uint32_t DTEF = (1U << 10);  ///< data transfer error flag
        constexpr uint32_t ULEF = (1U << 11);  ///< update link transfer error flag
        constexpr uint32_t USEF = (1U << 12);  ///< user setting error flag
        constexpr uint32_t SUSPF = (1U << 13);  ///< completed suspension flag
        constexpr uint32_t TOF = (1U << 14);  ///< trigger overrun flag
        constexpr uint32_t FIFOL = (8 << 16);  ///< monitored FIFO level 	Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words). 	Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF=1).
    }

    /// GPDMA_C15CR Register bits
    namespace gpdma_c15cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< enable 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 	this bit is de-asserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, e.g. if LSM=1 at the end of a single execution of the LLI). 	Else, this bit can be asserted by software. 	Writing 0 into this EN bit is ignored.
        constexpr uint32_t RESET = (1U << 1);  ///< reset 	This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0). 	The reset is effective when the channel is in steady state, meaning one of the following: 	- active channel in suspended state (GPDMA_CxSR.SUSPF=1 and GPDMA_CxSR.IDLEF=GPDMA_CxCR.EN=1) 	- channel in disabled state (GPDMA_CxSR.IDLEF=1 and GPDMA_CxCR.EN=0). 	After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in ).
        constexpr uint32_t SUSP = (1U << 2);  ///< suspend 	Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else: 	Software must write 1 in order to suspend an active channel i.e. a channel with an on-going GPDMA transfer over its master ports. 	The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in .
        constexpr uint32_t TCIE = (1U << 8);  ///< transfer complete interrupt enable
        constexpr uint32_t HTIE = (1U << 9);  ///< half transfer complete interrupt enable
        constexpr uint32_t DTEIE = (1U << 10);  ///< data transfer error interrupt enable
        constexpr uint32_t ULEIE = (1U << 11);  ///< update link transfer error interrupt enable
        constexpr uint32_t USEIE = (1U << 12);  ///< user setting error interrupt enable
        constexpr uint32_t SUSPIE = (1U << 13);  ///< completed suspension interrupt enable
        constexpr uint32_t TOIE = (1U << 14);  ///< trigger overrun interrupt enable
        constexpr uint32_t LSM = (1U << 16);  ///< Link step mode 	First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0]=0 and GPDMA_CxBR1.BRC[10:0]=0 if present. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t LAP = (1U << 17);  ///< linked-list allocated port 	This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory. 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t PRIO = (2 << 22);  ///< priority level of the channel x GPDMA transfer versus others 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
    }

    /// GPDMA_C15TR1 Register bits
    namespace gpdma_c15tr1_bits {
        constexpr uint32_t SDW_LOG2 = (2 << 0);  ///< binary logarithm of the source data width of a burst in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued. 	A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued. 	A source single transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.
        constexpr uint32_t SINC = (1U << 3);  ///< source incrementing burst 	The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t SBL_1 = (6 << 4);  ///< source burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If SBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t PAM = (2 << 11);  ///< padding/alignment mode 	If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored. 	Else: 	- Case 1: If destination data width > source data width 	1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer 	- Case 2: If destination data width < source data width 	1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination 	Note:
        constexpr uint32_t SBX = (1U << 13);  ///< source byte exchange within the unaligned half-word of each source word 	If the source data width is shorter than a word, this bit is ignored. 	If the source data width is a word:
        constexpr uint32_t SAP = (1U << 14);  ///< source allocated port 	This bit is used to allocate the master port for the source transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t SSEC = (1U << 15);  ///< security attribute of the GPDMA transfer from the source 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this SSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.
        constexpr uint32_t DDW_LOG2 = (2 << 16);  ///< binary logarithm of the destination data width of a burst, in bytes 	Note: Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued. 	A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.
        constexpr uint32_t DINC = (1U << 19);  ///< destination incrementing burst 	The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.
        constexpr uint32_t DBL_1 = (6 << 20);  ///< destination burst length minus 1, between 0 and 63 	The burst length unit is one data named beat within a burst. If DBL_1[5:0]=0, the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0]. 	Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol. 	If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower bursts/singles, but the data integrity is guaranteed.
        constexpr uint32_t DBX = (1U << 26);  ///< destination byte exchange 	If the destination data size is a byte, this bit is ignored. 	If the destination data size is not a byte:
        constexpr uint32_t DHX = (1U << 27);  ///< destination half-word exchange 	If the destination data size is shorter than a word, this bit is ignored. 	If the destination data size is a word:
        constexpr uint32_t DAP = (1U << 30);  ///< destination allocated port 	This bit is used to allocate the master port for the destination transfer 	Note: This bit must be written when EN=0. This bit is read-only when EN=1.
        constexpr uint32_t DSEC = (1U << 31);  ///< security attribute of the GPDMA transfer to the destination 	If GPDMA_SECCFGR.SECx=1 and the access is secure: 	This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx=1. A secure write is ignored when GPDMA_SECCFGR.SECx=0. 	When GPDMA_SECCFGR.SECx is de-asserted, this DSEC bit is also de-asserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.
    }

    /// GPDMA_C15TR2 Register bits
    namespace gpdma_c15tr2_bits {
        constexpr uint32_t REQSEL = (7 << 0);  ///< GPDMA hardware request selection 	These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per . 	The user must not assign a same input hardware request (same REQSEL[6:0] value) to different active GPDMA channels (GPDMA_CxCR.EN=1 and GPDMA_CxTR2.SWREQ=0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.
        constexpr uint32_t SWREQ = (1U << 9);  ///< software request 	This bit is internally taken into account when GPDMA_CxCR.EN is asserted.
        constexpr uint32_t DREQ = (1U << 10);  ///< destination hardware request 	This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer). Else: 	Note:
        constexpr uint32_t BREQ = (1U << 11);  ///< Block hardware request 	If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ=1 (software request for a memory-to-memory transfer), this bit is ignored. Else:
        constexpr uint32_t TRIGM = (2 << 14);  ///< trigger mode 	These bits define the transfer granularity for its conditioning by the trigger. 	If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0]=00 or 11, these TRIGM[1:0] bits are ignored. 	Else, a GPDMA transfer is conditioned by at least one trigger hit: 	first burst read of a 2D/repeated block transfer is conditioned by one hit trigger. 	 If the peripheral is programmed as a source (DREQ=0) of the LLI data transfer, each programmed burst read is conditioned. 	 If the peripheral is programmed as a destination (DREQ=1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a (possibly 2D/repeated) block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit. 	The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0]=01 or respectively TRIGPOL[1:0]=10). 	The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[5:0] is not modified, and the channel is enabled. 	Transferring a next LLIn+1 that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[5:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLIn trigger. 	After a first new trigger hitn+1 is memorized, if another second trigger hitn+2 is detected and if the hitn triggered transfer is still not completed, hitn+2 is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF=1), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE=1). The channel is not automatically disabled by hardware due to a trigger overrun. 	Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0]=11 and (SWREQ=1 or (SWREQ=0 and DREQ=0)), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger. 	When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0]=11 and SWREQ=0 and DREQ=1), this shortened destination burst transfer is conditioned once by the trigger.
        constexpr uint32_t TRIGSEL = (6 << 16);  ///< trigger event input selection 	These bits select the trigger event input of the GPDMA transfer (as per ), with an active trigger event if TRIGPOL[1:0]00.
        constexpr uint32_t TRIGPOL = (2 << 24);  ///< trigger event polarity 	These bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0].
        constexpr uint32_t TCEM = (2 << 30);  ///< transfer complete event mode 	These bits define the transfer granularity for the transfer complete and half transfer complete events generation. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then neither the complete transfer event nor the half transfer event is generated. 	Note: If the initial LLI0 data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0]=0), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI1.
    }

    /// GPDMA_C15BR1 Register bits
    namespace gpdma_c15br1_bits {
        constexpr uint32_t BNDT = (16 << 0);  ///< block number of data bytes to transfer from the source 	Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64Kbytes -1. 	Once the last data transfer is completed (BNDT[15:0]=0): 	- if GPDMA_CxLLR.UB1=1, this field is updated by the LLI in the memory. 	- if GPDMA_CxLLR.UB1=0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value. 	- if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	- if GPDMA_CxLLR=0, this field is kept as zero following the last LLI data transfer. 	Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued. 	When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
        constexpr uint32_t BRC = (11 << 16);  ///< Block repeat counter 	This field contains the number of repetitions of the current block (0 to 2047). 	When the channel is enabled, this field becomes read-only. After decrements, this field indicates the remaining number of blocks, excluding the current one. This counter is hardware decremented for each completed block transfer. 	Once the last block transfer is completed (BRC[10:0]=BNDT[15:0]=0): 	If GPDMA_CxLLR.UB1=1, all GPDMA_CxBR1 fields are updated by the next LLI in the memory. 	If GPDMA_CxLLR.UB1=0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value. 	if all GPDMA_CxLLR.Uxx=0 and if GPDMA_CxLLR.LA[15:0]0, this field is internally restored to the programmed value (infinite/continuous last LLI). 	if GPDMA_CxLLR=0, this field is kept as zero following the last LLI and data transfer.
        constexpr uint32_t SDEC = (1U << 28);  ///< source address decrement
        constexpr uint32_t DDEC = (1U << 29);  ///< destination address decrement
        constexpr uint32_t BRSDEC = (1U << 30);  ///< Block repeat source address decrement 	Note: On top of this increment/decrement (depending on BRSDEC), GPDMA_CxSAR is in the same time also updated by the increment/decrement (depending on SDEC) of the GPDMA_CxTR3.SAO value, as it is done after any programmed burst transfer.
        constexpr uint32_t BRDDEC = (1U << 31);  ///< Block repeat destination address decrement 	Note: On top of this increment/decrement (depending on BRDDEC), GPDMA_CxDAR is in the same time also updated by the increment/decrement (depending on DDEC) of the GPDMA_CxTR3.DAO value, as it is usually done at the end of each programmed burst transfer.
    }

    /// GPDMA_C15SAR Register bits
    namespace gpdma_c15sar_bits {
        constexpr uint32_t SA = (32 << 0);  ///< source address 	This field is the pointer to the address from which the next data is read. 	During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each single source data, reflecting the next address from which data is read. 	During the channel activity, this address is updated after each completed source burst, consequently to: 	the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0] 	the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0] 	once/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA=1. 	Note: A source address must be aligned with the programmed data width of a source single (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued. 	When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
    }

    /// GPDMA_C15DAR Register bits
    namespace gpdma_c15dar_bits {
        constexpr uint32_t DA = (32 << 0);  ///< destination address 	This field is the pointer to the address from which the next data is written. 	During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each single destination data, reflecting the next address from which data is written. 	During the channel activity, this address is updated after each completed destination burst, consequently to: 	the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0] 	the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0] 	once/if completed destination block transfer, for a channel x with 2D addressing capability (x=12to15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0] 	In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA=1. 	Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C15TR3 Register bits
    namespace gpdma_c15tr3_bits {
        constexpr uint32_t SAO = (13 << 0);  ///< source address offset increment 	The source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.SINC=1). 	Note: A source address offset must be aligned with the programmed data width of a source burst (SAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued. 	When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied.
        constexpr uint32_t DAO = (13 << 16);  ///< destination address offset increment 	The destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.DINC=1). 	Note: A destination address offset must be aligned with the programmed data width of a destination burst (DAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C15BR2 Register bits
    namespace gpdma_c15br2_bits {
        constexpr uint32_t BRSAO = (16 << 0);  ///< Block repeated source address offset 	For a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (GPDMA_CxSAR) at the end of a block transfer. 	Note: A block repeated source address offset must be aligned with the programmed data width of a source burst (BRSAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
        constexpr uint32_t BRDAO = (16 << 16);  ///< Block repeated destination address offset 	For a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (GPDMA_CxDAR) at the end of a block transfer. 	Note: A block repeated destination address offset must be aligned with the programmed data width of a destination burst (BRDAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
    }

    /// GPDMA_C15LLR Register bits
    namespace gpdma_c15llr_bits {
        constexpr uint32_t LA = (14 << 2);  ///< pointer (16-bit low-significant address) to the next linked-list data structure 	If UT1=UT2=UB1=USA=UDA=ULL=0 and if LA[15:20]=0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file. 	Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR). 	Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.
        constexpr uint32_t ULL = (1U << 16);  ///< Update GPDMA_CxLLR register from memory 	This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.
        constexpr uint32_t UB2 = (1U << 25);  ///< Update GPDMA_CxBR2 from memory 	This bit controls the update of GPDMA_CxBR2 from the memory during the link transfer.
        constexpr uint32_t UT3 = (1U << 26);  ///< Update GPDMA_CxTR3 from memory 	This bit controls the update of GPDMA_CxTR3 from the memory during the link transfer.
        constexpr uint32_t UDA = (1U << 27);  ///< Update GPDMA_CxDAR register from memory 	This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.
        constexpr uint32_t USA = (1U << 28);  ///< update GPDMA_CxSAR from memory 	This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.
        constexpr uint32_t UB1 = (1U << 29);  ///< Update GPDMA_CxBR1 from memory 	This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1=0 and if GPDMA_CxLLR0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.
        constexpr uint32_t UT2 = (1U << 30);  ///< Update GPDMA_CxTR2 from memory 	This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.
        constexpr uint32_t UT1 = (1U << 31);  ///< Update GPDMA_CxTR1 from memory 	This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SEC_SPI1_BASE = 0x50013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;
    constexpr uint32_t SEC_SPI2_BASE = 0x50003800;
    constexpr uint32_t SPI3_BASE = 0x46002000;
    constexpr uint32_t SEC_SPI3_BASE = 0x56002000;
    constexpr uint32_t OCTOSPI1_BASE = 0x420D1400;
    constexpr uint32_t SEC_OCTOSPI1_BASE = 0x520D1400;
    constexpr uint32_t OCTOSPI2_BASE = 0x420D2400;
    constexpr uint32_t SEC_OCTOSPI2_BASE = 0x520D2400;
    constexpr uint32_t OCTOSPIM_BASE = 0x420C4000;
    constexpr uint32_t SEC_OCTOSPIM_BASE = 0x520C4000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SPI_CR1;  ///< Offset: 0x00 - serial peripheral enable This bit is set by and cleared...
        volatile uint32_t SPI_CR2;  ///< Offset: 0x04 - number of data at current transfer When these bits are...
        volatile uint32_t SPI_CFG1;  ///< Offset: 0x08 - SPI configuration register 1
        volatile uint32_t SPI_CFG2;  ///< Offset: 0x0C - SPI configuration register 2
        volatile uint32_t SPI_IER;  ///< Offset: 0x10 - RXP interrupt enable
        volatile uint32_t SPI_SR;  ///< Offset: 0x14 - Rx-Packet available RXP flag is changed by hardware. It...
        volatile uint32_t SPI_IFCR;  ///< Offset: 0x18 - end of transfer flag clear Writing a 1 into this bit...
        volatile uint32_t SPI_AUTOCR;  ///< Offset: 0x1C - trigger selection (refer ). ... Note: these bits can be...
        volatile uint32_t SPI_TXDR;  ///< Offset: 0x20 - transmit data register The register serves as an...
        volatile uint32_t SPI_RXDR;  ///< Offset: 0x30 - receive data register The register serves as an...
        volatile uint32_t SPI_CRCPOLY;  ///< Offset: 0x40 - SPI polynomial register
        volatile uint32_t SPI_TXCRC;  ///< Offset: 0x44 - CRC register for transmitter When CRC calculation is...
        volatile uint32_t SPI_RXCRC;  ///< Offset: 0x48 - CRC register for receiver When CRC calculation is...
        volatile uint32_t SPI_UDRDR;  ///< Offset: 0x4C - SPI underrun data register
    };

    /// Peripheral instances
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SEC_SPI1 = reinterpret_cast<Registers*>(SEC_SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SEC_SPI2 = reinterpret_cast<Registers*>(SEC_SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* SEC_SPI3 = reinterpret_cast<Registers*>(SEC_SPI3_BASE);
    inline Registers* OCTOSPI1 = reinterpret_cast<Registers*>(OCTOSPI1_BASE);
    inline Registers* SEC_OCTOSPI1 = reinterpret_cast<Registers*>(SEC_OCTOSPI1_BASE);
    inline Registers* OCTOSPI2 = reinterpret_cast<Registers*>(OCTOSPI2_BASE);
    inline Registers* SEC_OCTOSPI2 = reinterpret_cast<Registers*>(SEC_OCTOSPI2_BASE);
    inline Registers* OCTOSPIM = reinterpret_cast<Registers*>(OCTOSPIM_BASE);
    inline Registers* SEC_OCTOSPIM = reinterpret_cast<Registers*>(SEC_OCTOSPIM_BASE);

    // Bit definitions
    /// SPI_CR1 Register bits
    namespace spi_cr1_bits {
        constexpr uint32_t SPE = (1U << 0);  ///< serial peripheral enable This bit is set by and cleared by software. When SPE=1, SPI data transfer is enabled, SPI_CFG1 and SPI_CFG2 configuration registers, CRCPOLY, UDRDR, part of SPI_AUTOCR register and IOLOCK bit in the SPI_CR1 register are write protected. They can be changed only when SPE=0. When SPE=0 any SPI operation is stopped and disabled, all the pending requests of the events with enabled interrupt are blocked except the MODF interrupt request (but their pending still propagates the request of the spi_plck clock), the SS output is deactivated at master, the RDY signal keeps not ready status at slave, the internal state machine is reseted, all the FIFOs content is flushed, CRC calculation initialized, receive data register is read zero. SPE is cleared and cannot be set when MODF error flag is active.
        constexpr uint32_t MASRX = (1U << 8);  ///< master automatic suspension in Receive mode This bit is set and cleared by software to control continuous SPI transfer in master receiver mode and automatic management in order to avoid overrun condition. When SPI communication is suspended by hardware automatically, it could happen that few bits of next frame are already clocked out due to internal synchronization delay. This is why, the automatic suspension is not quite reliable when size of data drops below 8 bits. In this case, a safe suspension can be achieved by combination with delay inserted between data frames applied when MIDI parameter keeps a non zero value; sum of data size and the interleaved SPI cycles should always produce interval at length of 8 SPI clock periods at minimum. After software clearing of the SUSP bit, the communication resumes and continues by subsequent bits transaction without any next constraint. Prior the SUSP bit is cleared, the user must release the RxFIFO space as much as possible by reading out all the data packets available at RxFIFO based on the RXP flag indication to prevent any subsequent suspension.
        constexpr uint32_t CSTART = (1U << 9);  ///< master transfer start This bit can be set by software if SPI is enabled only to start an SPI communication. it is cleared by hardware when end of transfer (EOT) flag is set or when a transaction suspend request is accepted. In SPI mode, the bit is taken into account at master mode only. If transmission is enabled, communication starts or continues only if any data is available in the transmission FIFO.
        constexpr uint32_t CSUSP = (1U << 10);  ///< master SUSPend request This bit reads as zero. In Master mode, when this bit is set by software, the CSTART bit is reset at the end of the current frame and SPI communication is suspended. The user has to check SUSP flag to check end of the frame transaction. The Master mode communication must be suspended (using this bit or keeping TXDR empty) before disabling the SPI or going to Low-power mode. After software suspension, SUSP flag has to be cleared and SPI disabled and re-enabled before the next transaction starts.
        constexpr uint32_t HDDIR = (1U << 11);  ///< Rx/Tx direction at Half-duplex mode In Half-Duplex configuration the HDDIR bit establishes the Rx/Tx direction of the data transfer. This bit is ignored in Full-Duplex or any Simplex configuration.
        constexpr uint32_t SSI = (1U << 12);  ///< internal SS signal input level This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the peripheral SS input internally and the I/O value of the SS pin is ignored.
        constexpr uint32_t CRC33_17 = (1U << 13);  ///< 32-bit CRC polynomial configuration
        constexpr uint32_t RCRCINI = (1U << 14);  ///< CRC calculation initialization pattern control for receiver
        constexpr uint32_t TCRCINI = (1U << 15);  ///< CRC calculation initialization pattern control for transmitter
        constexpr uint32_t IOLOCK = (1U << 16);  ///< locking the AF configuration of associated IOs This bit is set by software and cleared by hardware whenever the SPE bit is changed from 1 to 0. When this bit is set, SPI_CFG2 register content cannot be modified. This bit can be set when SPI is disabled only else it is write protected. It is cleared and cannot be set when MODF bit is set.
    }

    /// SPI_CR2 Register bits
    namespace spi_cr2_bits {
        constexpr uint32_t TSIZE = (16 << 0);  ///< number of data at current transfer When these bits are changed by software, the SPI has to be disabled. Endless transaction is initialized when CSTART is set while zero value is stored at TSIZE. TSIZE cannot be set to 0xFFFF respective 0x3FFF value when CRC is enabled. Note: TSIZE[15:10] bits are reserved at limited feature set instances and must be kept at reset value.
    }

    /// SPI_CFG1 Register bits
    namespace spi_cfg1_bits {
        constexpr uint32_t DSIZE = (5 << 0);  ///< number of bits in at single SPI data frame ..... Note: Maximum data size can be limited up to 16-bits at some instances. At instances with limited set of features, DSIZE2:0] bits are reserved and must be kept at reset state. DSIZE[4:3] bits then control next settings of data size: 00xxx: 8-bits 01xxx: 16-bits 10xxx: 24-bits 11xxx: 32-bits.
        constexpr uint32_t FTHLV = (4 << 5);  ///< FIFO threshold level Defines number of data frames at single data packet. Size of the packet should not exceed 1/2 of FIFO space. SPI interface is more efficient if configured packet sizes are aligned with data register access parallelism: If SPI data register is accessed as a 16-bit register and DSIZE  8 bit, better to select FTHLV=2, 4, 6. If SPI data register is accessed as a 32-bit register and DSIZE> 8 bit, better to select FTHLV=2, 4, 6, while if DSIZE 8bit, better to select FTHLV=4, 8, 12. Note: FTHLV[3:2] bits are reserved at instances with limited set of features
        constexpr uint32_t UDRCFG = (1U << 9);  ///< behavior of slave transmitter at underrun condition For more details see underrun condition.
        constexpr uint32_t RXDMAEN = (1U << 14);  ///< Rx DMA stream enable
        constexpr uint32_t TXDMAEN = (1U << 15);  ///< Tx DMA stream enable
        constexpr uint32_t CRCSIZE = (5 << 16);  ///< length of CRC frame to be transacted and compared Most significant bits are taken into account from polynomial calculation when CRC result is transacted or compared. The length of the polynomial is not affected by this setting. ..... The value must be set equal or multiply of data size (DSIZE[4:0]). Its maximum size corresponds to DSIZE maximum at the instance. Note: The most significant bit at CRCSIZE bit field is reserved at the peripheral instances where data size is limited to 16-bit.
        constexpr uint32_t CRCEN = (1U << 22);  ///< hardware CRC computation enable
        constexpr uint32_t MBR = (3 << 28);  ///< master baud rate prescaler setting Note: MBR setting is considered at slave working at TI mode, too (see mode).
        constexpr uint32_t BPASS = (1U << 31);  ///< bypass of the prescaler at master baud rate clock generator
    }

    /// SPI_CFG2 Register bits
    namespace spi_cfg2_bits {
        constexpr uint32_t MSSI = (4 << 0);  ///< Master SS Idleness Specifies an extra delay, expressed in number of SPI clock cycle periods, inserted additionally between active edge of SS opening a session and the beginning of the first data frame of the session in Master mode when SSOE is enabled. ... Note: This feature is not supported in TI mode. To include the delay, the SPI must be disabled and re-enabled between sessions.
        constexpr uint32_t MIDI = (4 << 4);  ///< master Inter-Data Idleness Specifies minimum time delay (expressed in SPI clock cycles periods) inserted between two consecutive data frames in Master mode. ... Note: This feature is not supported in TI mode.
        constexpr uint32_t RDIOM = (1U << 13);  ///< RDY signal input/output management Note: When DSIZE at the SPI_CFG1 register is configured shorter than 8-bit, the RDIOM bit has to be kept at zero.
        constexpr uint32_t RDIOP = (1U << 14);  ///< RDY signal input/output polarity
        constexpr uint32_t IOSWP = (1U << 15);  ///< swap functionality of MISO and MOSI pins When this bit is set, the function of MISO and MOSI pins alternate functions are inverted. Original MISO pin becomes MOSI and original MOSI pin becomes MISO.
        constexpr uint32_t COMM = (2 << 17);  ///< SPI Communication Mode
        constexpr uint32_t SP = (3 << 19);  ///< serial protocol others: reserved, must not be used
        constexpr uint32_t MASTER = (1U << 22);  ///< SPI Master
        constexpr uint32_t LSBFRST = (1U << 23);  ///< data frame format
        constexpr uint32_t CPHA = (1U << 24);  ///< clock phase
        constexpr uint32_t CPOL = (1U << 25);  ///< clock polarity
        constexpr uint32_t SSM = (1U << 26);  ///< software management of SS signal input When master uses hardware SS output (SSM=0 and SSOE=1) the SS signal input is forced to not active state internally to prevent master mode fault error.
        constexpr uint32_t SSIOP = (1U << 28);  ///< SS input/output polarity
        constexpr uint32_t SSOE = (1U << 29);  ///< SS output enable This bit is taken into account in Master mode only
        constexpr uint32_t SSOM = (1U << 30);  ///< SS output management in Master mode This bit is taken into account in Master mode when SSOE is enabled. It allows the SS output to be configured between two consecutive data transfers.
        constexpr uint32_t AFCNTR = (1U << 31);  ///< alternate function GPIOs control This bit is taken into account when SPE=0 only When SPI has to be disabled temporary for a specific configuration reason (e.g. CRC reset, CPHA or HDDIR change) setting this bit prevents any glitches on the associated outputs configured at alternate function mode by keeping them forced at state corresponding the current SPI configuration.
    }

    /// SPI_IER Register bits
    namespace spi_ier_bits {
        constexpr uint32_t RXPIE = (1U << 0);  ///< RXP interrupt enable
        constexpr uint32_t TXPIE = (1U << 1);  ///< TXP interrupt enable TXPIE is set by software and cleared by TXTF flag set event.
        constexpr uint32_t DXPIE = (1U << 2);  ///< DXP interrupt enabled DXPIE is set by software and cleared by TXTF flag set event.
        constexpr uint32_t EOTIE = (1U << 3);  ///< EOT, SUSP and TXC interrupt enable
        constexpr uint32_t TXTFIE = (1U << 4);  ///< TXTFIE interrupt enable
        constexpr uint32_t UDRIE = (1U << 5);  ///< UDR interrupt enable
        constexpr uint32_t OVRIE = (1U << 6);  ///< OVR interrupt enable
        constexpr uint32_t CRCEIE = (1U << 7);  ///< CRC error interrupt enable
        constexpr uint32_t TIFREIE = (1U << 8);  ///< TIFRE interrupt enable
        constexpr uint32_t MODFIE = (1U << 9);  ///< mode Fault interrupt enable
    }

    /// SPI_SR Register bits
    namespace spi_sr_bits {
        constexpr uint32_t RXP = (1U << 0);  ///< Rx-Packet available RXP flag is changed by hardware. It monitors number of overall data currently available at RxFIFO if SPI is enabled. It has to be checked once a data packet is completely read out from RxFIFO.
        constexpr uint32_t TXP = (1U << 1);  ///< Tx-Packet space available TXP flag is changed by hardware. It monitors overall space currently available at TxFIFO no matter if SPI is enabled or not. It has to be checked once a complete data packet is stored at TxFIFO.
        constexpr uint32_t DXP = (1U << 2);  ///< duplex packet DXP flag is set whenever both TXP and RXP flags are set regardless SPI mode.
        constexpr uint32_t EOT = (1U << 3);  ///< end of transfer EOT is set by hardware as soon as a full transfer is complete, that is when TSIZE number of data have been transmitted and/or received on the SPI. EOT is cleared by software write 1 to EOTC bit at SPI_IFCR. EOT flag triggers an interrupt if EOTIE bit is set. If DXP flag is used until TXTF flag is set and DXPIE is cleared, EOT can be used to download the last packets contained into RxFIFO in one-shot. In master, EOT event terminates the data transaction and handles SS output optionally. When CRC is applied, the EOT event is extended over the CRC frame transaction. To restart the internal state machine properly, SPI is strongly suggested to be disabled and re-enabled before next transaction starts despite its setting is not changed.
        constexpr uint32_t TXTF = (1U << 4);  ///< transmission transfer filled TXTF is set by hardware as soon as all of the data packets in a transfer have been submitted for transmission by application software or DMA, that is when TSIZE number of data have been pushed into the TxFIFO. This bit is cleared by software write 1 to TXTFC bit at SPI_IFCR TXTF flag triggers an interrupt if TXTFIE bit is set. TXTF setting clears the TXPIE and DXPIE masks so to off-load application software from calculating when to disable TXP and DXP interrupts.
        constexpr uint32_t UDR = (1U << 5);  ///< underrun at slave transmission mode This bit is cleared by writing 1 to UDRC bit at SPI_IFCR Note: UDR flag applies to Slave mode only
        constexpr uint32_t OVR = (1U << 6);  ///< overrun This bit is cleared by writing 1 to OVRC bit at SPI_IFCR
        constexpr uint32_t CRCE = (1U << 7);  ///< CRC error This bit is cleared by writing 1 to CRCEC bit at SPI_IFCR
        constexpr uint32_t TIFRE = (1U << 8);  ///< TI frame format error This bit is cleared by writing 1 to TIFREC bit at SPI_IFCR
        constexpr uint32_t MODF = (1U << 9);  ///< mode fault This bit is cleared by writing 1 to MODFC bit at SPI_IFCR
        constexpr uint32_t SUSP = (1U << 11);  ///< suspension status In Master mode, SUSP is set by hardware either as soon as the current frame is completed after CSUSP request is done or at master automatic suspend receive mode (MASRX bit is set at SPI_CR1 register) on RxFIFO full condition. SUSP generates an interrupt when EOTIE is set. This bit has to be cleared prior SPI is disabled by writing 1 to SUSPC bit at SPI_IFCR.
        constexpr uint32_t TXC = (1U << 12);  ///< TxFIFO transmission complete The flag behavior depends on TSIZE setting. When TSIZE=0 the TXC is changed by hardware exclusively and it raises each time the TxFIFO becomes empty and there is no activity on the bus. If TSIZE <>0 there is no specific reason to monitor TXC as it just copies the EOT flag value including its software clearing. The TXC generates an interrupt when EOTIE is set.
        constexpr uint32_t RXPLVL = (2 << 13);  ///< RxFIFO packing level When RXWNE=0 and data size is set up to 16-bit, the value gives number of remaining data frames persisting at RxFIFO. Note: (*): Optional value when data size is set up to 8-bit only. When data size is greater than 16-bit, these bits are always read as 00. In that consequence, the single data frame received at the FIFO cannot be detected neither by RWNE nor by RXPLVL bits if data size is set from 17 to 24 bits. The user then must apply other methods like TSIZE>0 or FTHLV=0.
        constexpr uint32_t RXWNE = (1U << 15);  ///< RxFIFO word not empty Note: This bit value does not depend on DSIZE setting and keeps together with RXPLVL[1:0] information about RxFIFO occupancy by residual data.
        constexpr uint32_t CTSIZE = (16 << 16);  ///< number of data frames remaining in current TSIZE session The value is not quite reliable when traffic is ongoing on bus or during autonomous operation at low-power mode. Note: CTSIZE[15:0] bits are not available at instances with limited set of features
    }

    /// SPI_IFCR Register bits
    namespace spi_ifcr_bits {
        constexpr uint32_t EOTC = (1U << 3);  ///< end of transfer flag clear Writing a 1 into this bit clears EOT flag in the SPI_SR register
        constexpr uint32_t TXTFC = (1U << 4);  ///< transmission transfer filled flag clear Writing a 1 into this bit clears TXTF flag in the SPI_SR register
        constexpr uint32_t UDRC = (1U << 5);  ///< underrun flag clear Writing a 1 into this bit clears UDR flag in the SPI_SR register
        constexpr uint32_t OVRC = (1U << 6);  ///< overrun flag clear Writing a 1 into this bit clears OVR flag in the SPI_SR register
        constexpr uint32_t CRCEC = (1U << 7);  ///< CRC error flag clear Writing a 1 into this bit clears CRCE flag in the SPI_SR register
        constexpr uint32_t TIFREC = (1U << 8);  ///< TI frame format error flag clear Writing a 1 into this bit clears TIFRE flag in the SPI_SR register
        constexpr uint32_t MODFC = (1U << 9);  ///< mode fault flag clear Writing a 1 into this bit clears MODF flag in the SPI_SR register
        constexpr uint32_t SUSPC = (1U << 11);  ///< SUSPend flag clear Writing a 1 into this bit clears SUSP flag in the SPI_SR register
    }

    /// SPI_AUTOCR Register bits
    namespace spi_autocr_bits {
        constexpr uint32_t TRIGSEL = (4 << 16);  ///< trigger selection (refer ). ... Note: these bits can be written only when SPE=0.
        constexpr uint32_t TRIGPOL = (1U << 20);  ///< trigger polarity Note: This bit can be written only when SPE=0.
        constexpr uint32_t TRIGEN = (1U << 21);  ///< trigger of CSTART control enable Note: if user can't prevent trigger event during write, the TRIGEN has to be changed when SPI is disabled
    }

    /// SPI_TXDR Register bits
    namespace spi_txdr_bits {
        constexpr uint32_t TXDR = (32 << 0);  ///< transmit data register The register serves as an interface with TxFIFO. A write to it accesses TxFIFO. Note: data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. Note: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is written by single access. halfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be written by single access. word-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be written by single access. Write access of this register less than the configured data size is forbidden.
    }

    /// SPI_RXDR Register bits
    namespace spi_rxdr_bits {
        constexpr uint32_t RXDR = (32 << 0);  ///< receive data register The register serves as an interface with RxFIFO. When it is read, RxFIFO is accessed. Note: data is always right-aligned. Unused bits are read as zero when the register is read. Writing to the register is ignored. Note: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is read by single access halfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be read by single access word-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be read by single access. Read access of this register less than the configured data size is forbidden.
    }

    /// SPI_CRCPOLY Register bits
    namespace spi_crcpoly_bits {
        constexpr uint32_t CRCPOLY = (32 << 0);  ///< CRC polynomial register This register contains the polynomial for the CRC calculation. The default 9-bit polynomial setting 0x107 corresponds to default 8-bit setting of DSIZE. It is compatible with setting 0x07 used at some other ST products with fixed length of the polynomial string where the most significant bit of the string is always kept hidden. Length of the polynomial is given by the most significant bit of the value stored at this register. It has to be set greater than DSIZE. CRC33_17 bit has to be set additionally with CRCPOLY register when DSIZE is configured to maximum 32-bit or 16-bit size and CRC is enabled (to keep polynomial length grater than data size). Note: CRCPOLY[31:16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.
    }

    /// SPI_TXCRC Register bits
    namespace spi_txcrc_bits {
        constexpr uint32_t TXCRC = (32 << 0);  ///< CRC register for transmitter When CRC calculation is enabled, the TXCRC[31:0] bits contain the computed CRC value of the subsequently transmitted bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register. The number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register. Note: a read to this register when the communication is ongoing could return an incorrect value. Note: TXCRC[31-16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored. Note: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits at this case.
    }

    /// SPI_RXCRC Register bits
    namespace spi_rxcrc_bits {
        constexpr uint32_t RXCRC = (32 << 0);  ///< CRC register for receiver When CRC calculation is enabled, the RXCRC[31:0] bits contain the computed CRC value of the subsequently received bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register. The number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register. Note: a read to this register when the communication is ongoing could return an incorrect value. RXCRC[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored. Note: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits at this case.
    }

    /// SPI_UDRDR Register bits
    namespace spi_udrdr_bits {
        constexpr uint32_t UDRDR = (32 << 0);  ///< data at slave underrun condition The register is taken into account in Slave mode and at underrun condition only. The number of bits considered depends on DSIZE bit settings of the SPI_CFG1 register. Underrun condition handling depends on setting UDRCFG bit at SPI_CFG1 register. Note: UDRDR[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constraint when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x46000400;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t SECCFGR;  ///< Offset: 0x00 - SYSCFG secure configuration register
        volatile uint32_t CFGR1;  ///< Offset: 0x04 - configuration register 1
        volatile uint32_t FPUIMR;  ///< Offset: 0x08 - FPU interrupt mask register
        volatile uint32_t CNSLCKR;  ///< Offset: 0x0C - SYSCFG CPU non-secure lock register
        volatile uint32_t CSLOCKR;  ///< Offset: 0x10 - SYSCFG CPU secure lock register
        volatile uint32_t CFGR2;  ///< Offset: 0x14 - configuration register 2
        volatile uint32_t MESR;  ///< Offset: 0x18 - memory erase status register
        volatile uint32_t CCCSR;  ///< Offset: 0x1C - compensation cell control/status register
        volatile uint32_t CCVR;  ///< Offset: 0x20 - compensation cell value register
        volatile uint32_t CCCR;  ///< Offset: 0x24 - compensation cell code register
        volatile uint32_t RSSCMDR;  ///< Offset: 0x2C - RSS command register
        volatile uint32_t UCPDR;  ///< Offset: 0x70 - USB Type C and Power Delivery register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t SYSCFGSEC = (1U << 0);  ///< SYSCFG clock control security
        constexpr uint32_t CLASSBSEC = (1U << 1);  ///< CLASSBSEC
        constexpr uint32_t FPUSEC = (1U << 3);  ///< FPUSEC
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t PB9_FMP = (1U << 19);  ///< PB9_FMP
        constexpr uint32_t PB8_FMP = (1U << 18);  ///< PB8_FMP
        constexpr uint32_t PB7_FMP = (1U << 17);  ///< PB7_FMP
        constexpr uint32_t PB6_FMP = (1U << 16);  ///< PB6_FMP
        constexpr uint32_t ANASWVDD = (1U << 9);  ///< GPIO analog switch control voltage selection
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable
    }

    /// FPUIMR Register bits
    namespace fpuimr_bits {
        constexpr uint32_t FPU_IE = (6 << 0);  ///< Floating point unit interrupts enable bits
    }

    /// CNSLCKR Register bits
    namespace cnslckr_bits {
        constexpr uint32_t LOCKNSVTOR = (1U << 0);  ///< VTOR_NS register lock
        constexpr uint32_t LOCKNSMPU = (1U << 1);  ///< Non-secure MPU registers lock
    }

    /// CSLOCKR Register bits
    namespace cslockr_bits {
        constexpr uint32_t LOCKSVTAIRCR = (1U << 0);  ///< LOCKSVTAIRCR
        constexpr uint32_t LOCKSMPU = (1U << 1);  ///< LOCKSMPU
        constexpr uint32_t LOCKSAU = (1U << 2);  ///< LOCKSAU
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t ECCL = (1U << 3);  ///< ECC Lock
        constexpr uint32_t PVDL = (1U << 2);  ///< PVD lock enable bit
        constexpr uint32_t SPL = (1U << 1);  ///< SRAM ECC lock bit
        constexpr uint32_t CLL = (1U << 0);  ///< LOCKUP (hardfault) output enable bit
    }

    /// MESR Register bits
    namespace mesr_bits {
        constexpr uint32_t IPMEE = (1U << 16);  ///< IPMEE
        constexpr uint32_t MCLR = (1U << 0);  ///< MCLR
    }

    /// CCCSR Register bits
    namespace cccsr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< EN1
        constexpr uint32_t CS1 = (1U << 1);  ///< CS1
        constexpr uint32_t EN2 = (1U << 2);  ///< EN2
        constexpr uint32_t CS2 = (1U << 3);  ///< CS2
        constexpr uint32_t RDY1 = (1U << 8);  ///< RDY1
        constexpr uint32_t RDY2 = (1U << 9);  ///< RDY2
    }

    /// CCVR Register bits
    namespace ccvr_bits {
        constexpr uint32_t NCV1 = (4 << 0);  ///< NCV1
        constexpr uint32_t PCV1 = (4 << 4);  ///< PCV1
        constexpr uint32_t NCV2 = (4 << 8);  ///< NCV2
        constexpr uint32_t PCV2 = (4 << 12);  ///< PCV2
    }

    /// CCCR Register bits
    namespace cccr_bits {
        constexpr uint32_t NCC1 = (4 << 0);  ///< NCC1
        constexpr uint32_t PCC1 = (4 << 4);  ///< PCC1
        constexpr uint32_t NCC2 = (4 << 8);  ///< NCC2
        constexpr uint32_t PCC2 = (4 << 12);  ///< PCC2
    }

    /// RSSCMDR Register bits
    namespace rsscmdr_bits {
        constexpr uint32_t RSSCMD = (16 << 0);  ///< RSS commands
    }

    /// UCPDR Register bits
    namespace ucpdr_bits {
        constexpr uint32_t CC1ENRXFILTER = (1U << 0);  ///< CC1ENRXFILTER
        constexpr uint32_t CC2ENRXFILTER = (1U << 1);  ///< CC2ENRXFILTER
    }

}

// ============================================================================
// PKA Peripheral
// ============================================================================

namespace pka {
    /// Base addresses
    constexpr uint32_t PKA_BASE = 0x420C2000;

    /// PKA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control register
        volatile uint32_t SR;  ///< Offset: 0x04 - PKA status register
        volatile uint32_t CLRFR;  ///< Offset: 0x08 - PKA clear flag register
    };

    /// Peripheral instances
    inline Registers* PKA = reinterpret_cast<Registers*>(PKA_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t OPERRIE = (1U << 21);  ///< Operation error interrupt enable
        constexpr uint32_t ADDRERRIE = (1U << 20);  ///< Address error interrupt enable
        constexpr uint32_t RAMERRIE = (1U << 19);  ///< RAM error interrupt enable
        constexpr uint32_t PROCENDIE = (1U << 17);  ///< End of operation interrupt enable
        constexpr uint32_t MODE = (6 << 8);  ///< PKA Operation Mode
        constexpr uint32_t START = (1U << 1);  ///< Start the operation
        constexpr uint32_t EN = (1U << 0);  ///< Peripheral Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t INITOK = (1U << 0);  ///< INITOK
        constexpr uint32_t BUSY = (1U << 16);  ///< PKA operation is in progress
        constexpr uint32_t PROCENDF = (1U << 17);  ///< PKA End of Operation flag
        constexpr uint32_t RAMERRF = (1U << 19);  ///< RAMERRF
        constexpr uint32_t ADDRERRF = (1U << 20);  ///< ADDRERRF
        constexpr uint32_t OPERRF = (1U << 21);  ///< OPERRF
    }

    /// CLRFR Register bits
    namespace clrfr_bits {
        constexpr uint32_t PROCENDFC = (1U << 17);  ///< Clear PKA End of Operation flag
        constexpr uint32_t RAMERRFC = (1U << 19);  ///< RAMERRFC
        constexpr uint32_t ADDRERRFC = (1U << 20);  ///< ADDRERRFC
        constexpr uint32_t OPERRFC = (1U << 21);  ///< OPERRFC
    }

}

// ============================================================================
// DBGMCU Peripheral
// ============================================================================

namespace dbgmcu {
    /// Base addresses
    constexpr uint32_t DBGMCU_BASE = 0xE0044000;

    /// DBGMCU Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - DBGMCU_IDCODE
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU configuration register
        volatile uint32_t APB1LFZR;  ///< Offset: 0x08 - Debug MCU APB1L peripheral freeze register
        volatile uint32_t APB1HFZR;  ///< Offset: 0x0C - Debug MCU APB1H peripheral freeze register
        volatile uint32_t APB2FZR;  ///< Offset: 0x10 - Debug MCU APB2 peripheral freeze register
        volatile uint32_t APB3FZR;  ///< Offset: 0x14 - Debug MCU APB3 peripheral freeze register
        volatile uint32_t AHB1FZR;  ///< Offset: 0x20 - Debug MCU AHB1 peripheral freeze register
        volatile uint32_t AHB3FZR;  ///< Offset: 0x28 - Debug MCU AHB3 peripheral freeze register
        volatile uint32_t DBGMCU_SR;  ///< Offset: 0xFC - DBGMCU status register
        volatile uint32_t DBGMCU_DBG_AUTH_HOST;  ///< Offset: 0x100 - DBGMCU debug host authentication register
        volatile uint32_t DBGMCU_DBG_AUTH_DEVICE;  ///< Offset: 0x104 - DBGMCU debug device authentication register
        volatile uint32_t PIDR4;  ///< Offset: 0xFD0 - Debug MCU CoreSight peripheral identity register 4
        volatile uint32_t PIDR0;  ///< Offset: 0xFE0 - Debug MCU CoreSight peripheral identity register 0
        volatile uint32_t PIDR1;  ///< Offset: 0xFE4 - Debug MCU CoreSight peripheral identity register 1
        volatile uint32_t PIDR2;  ///< Offset: 0xFE8 - Debug MCU CoreSight peripheral identity register 2
        volatile uint32_t PIDR3;  ///< Offset: 0xFEC - Debug MCU CoreSight peripheral identity register 3
        volatile uint32_t CIDR0;  ///< Offset: 0xFF0 - Debug MCU CoreSight component identity register 0
        volatile uint32_t CIDR1;  ///< Offset: 0xFF4 - Debug MCU CoreSight component identity register 1
        volatile uint32_t CIDR2;  ///< Offset: 0xFF8 - Debug MCU CoreSight component identity register 2
        volatile uint32_t CIDR3;  ///< Offset: 0xFFC - Debug MCU CoreSight component identity register 3
    };

    /// Peripheral instances
    inline Registers* DBGMCU = reinterpret_cast<Registers*>(DBGMCU_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device dentification
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby mode
        constexpr uint32_t TRACE_IOEN = (1U << 4);  ///< Trace pin assignment control
        constexpr uint32_t TRACE_EN = (1U << 5);  ///< trace port and clock enable
        constexpr uint32_t TRACE_MODE = (2 << 6);  ///< Trace pin assignment control
    }

    /// APB1LFZR Register bits
    namespace apb1lfzr_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< TIM2 stop in debug
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 stop in debug
        constexpr uint32_t DBG_TIM4_STOP = (1U << 2);  ///< TIM4 stop in debug
        constexpr uint32_t DBG_TIM5_STOP = (1U << 3);  ///< TIM5 stop in debug
        constexpr uint32_t DBG_TIM6_STOP = (1U << 4);  ///< TIM6 stop in debug
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< TIM7 stop in debug
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Window watchdog counter stop in debug
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Independent watchdog counter stop in debug
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout stop in debug
        constexpr uint32_t DBG_I2C2_STOP = (1U << 22);  ///< I2C2 SMBUS timeout stop in debug
    }

    /// APB1HFZR Register bits
    namespace apb1hfzr_bits {
        constexpr uint32_t DBG_I2C4_STOP = (1U << 1);  ///< I2C4 stop in debug
        constexpr uint32_t DBG_LPTIM2_STOP = (1U << 5);  ///< LPTIM2 stop in debug
    }

    /// APB2FZR Register bits
    namespace apb2fzr_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM8_STOP = (1U << 13);  ///< TIM8 stop in debug
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< TIM15 counter stopped when core is halted
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< TIM16 counter stopped when core is halted
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< DBG_TIM17_STOP
    }

    /// APB3FZR Register bits
    namespace apb3fzr_bits {
        constexpr uint32_t DBG_I2C3_STOP = (1U << 10);  ///< I2C3 stop in debug
        constexpr uint32_t DBG_LPTIM1_STOP = (1U << 17);  ///< LPTIM1 stop in debug
        constexpr uint32_t DBG_LPTIM3_STOP = (1U << 18);  ///< LPTIM3 stop in debug
        constexpr uint32_t DBG_LPTIM4_STOP = (1U << 19);  ///< LPTIM4 stop in debug
        constexpr uint32_t DBG_RTC_STOP = (1U << 30);  ///< RTC stop in debug
    }

    /// AHB1FZR Register bits
    namespace ahb1fzr_bits {
        constexpr uint32_t DBG_GPDMA0_STOP = (1U << 0);  ///< GPDMA channel 0 stop in debug
        constexpr uint32_t DBG_GPDMA1_STOP = (1U << 1);  ///< GPDMA channel 1 stop in debug
        constexpr uint32_t DBG_GPDMA2_STOP = (1U << 2);  ///< GPDMA channel 2 stop in debug
        constexpr uint32_t DBG_GPDMA3_STOP = (1U << 3);  ///< GPDMA channel 3 stop in debug
        constexpr uint32_t DBG_GPDMA4_STOP = (1U << 4);  ///< GPDMA channel 4 stop in debug
        constexpr uint32_t DBG_GPDMA5_STOP = (1U << 5);  ///< GPDMA channel 5 stop in debug
        constexpr uint32_t DBG_GPDMA6_STOP = (1U << 6);  ///< GPDMA channel 6 stop in debug
        constexpr uint32_t DBG_GPDMA7_STOP = (1U << 7);  ///< GPDMA channel 7 stop in debug
        constexpr uint32_t DBG_GPDMA8_STOP = (1U << 8);  ///< GPDMA channel 8 stop in debug
        constexpr uint32_t DBG_GPDMA9_STOP = (1U << 9);  ///< GPDMA channel 9 stop in debug
        constexpr uint32_t DBG_GPDMA10_STOP = (1U << 10);  ///< GPDMA channel 10 stop in debug
        constexpr uint32_t DBG_GPDMA11_STOP = (1U << 11);  ///< GPDMA channel 11 stop in debug
        constexpr uint32_t DBG_GPDMA12_STOP = (1U << 12);  ///< GPDMA channel 12 stop in debug
        constexpr uint32_t DBG_GPDMA13_STOP = (1U << 13);  ///< GPDMA channel 13 stop in debug
        constexpr uint32_t DBG_GPDMA14_STOP = (1U << 14);  ///< GPDMA channel 14 stop in debug
        constexpr uint32_t DBG_GPDMA15_STOP = (1U << 15);  ///< GPDMA channel 15 stop in debug
    }

    /// AHB3FZR Register bits
    namespace ahb3fzr_bits {
        constexpr uint32_t DBG_LPDMA0_STOP = (1U << 0);  ///< LPDMA channel 0 stop in debug
        constexpr uint32_t DBG_LPDMA1_STOP = (1U << 1);  ///< LPDMA channel 1 stop in debug
        constexpr uint32_t DBG_LPDMA2_STOP = (1U << 2);  ///< LPDMA channel 2 stop in debug
        constexpr uint32_t DBG_LPDMA3_STOP = (1U << 3);  ///< LPDMA channel 3 stop in debug
    }

    /// DBGMCU_SR Register bits
    namespace dbgmcu_sr_bits {
        constexpr uint32_t AP_PRESENT = (8 << 0);  ///< Bit n identifies whether access port AP n is present in device 	Bit n=0: APn absent 	Bit n=1: APn present
        constexpr uint32_t AP_LOCKED = (8 << 8);  ///< DECLARATION TO BE CONFIRMED by PRODUCT OWNER! Bit n identifies whether access port AP n is open (can be accessed via the debug port) or locked (debug access to the AP is blocked) 	Bit n=0: APn locked 	Bit n=1: APn enabled
    }

    /// DBGMCU_DBG_AUTH_HOST Register bits
    namespace dbgmcu_dbg_auth_host_bits {
        constexpr uint32_t AUTH_KEY = (32 << 0);  ///< Device authentication key 	The device specific 64-bit authentication key (OEM key) must be written to this register (in two successive 32-bit writes, least significant word first) to permit RDP regression. Writing a wrong key locks access to the device and prevent code execution from the Flash memory.
    }

    /// DBGMCU_DBG_AUTH_DEVICE Register bits
    namespace dbgmcu_dbg_auth_device_bits {
        constexpr uint32_t AUTH_ID = (32 << 0);  ///< Device specific ID 	Device specific ID used for RDP regression.
    }

    /// PIDR4 Register bits
    namespace pidr4_bits {
        constexpr uint32_t JEP106CON = (4 << 0);  ///< JEP106 continuation code
        constexpr uint32_t KCOUNT_4 = (4 << 4);  ///< register file size
    }

    /// PIDR0 Register bits
    namespace pidr0_bits {
        constexpr uint32_t PARTNUM = (8 << 0);  ///< part number bits [7:0]
    }

    /// PIDR1 Register bits
    namespace pidr1_bits {
        constexpr uint32_t PARTNUM = (4 << 0);  ///< part number bits [11:8]
        constexpr uint32_t JEP106ID = (4 << 4);  ///< JEP106 identity code bits [3:0]
    }

    /// PIDR2 Register bits
    namespace pidr2_bits {
        constexpr uint32_t JEP106ID = (3 << 0);  ///< JEP106 identity code bits [6:4]
        constexpr uint32_t JEDEC = (1U << 3);  ///< JEDEC assigned value
        constexpr uint32_t REVISION = (4 << 4);  ///< component revision number
    }

    /// PIDR3 Register bits
    namespace pidr3_bits {
        constexpr uint32_t CMOD = (4 << 0);  ///< customer modified
        constexpr uint32_t REVAND = (4 << 4);  ///< metal fix version
    }

    /// CIDR0 Register bits
    namespace cidr0_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [7:0]
    }

    /// CIDR1 Register bits
    namespace cidr1_bits {
        constexpr uint32_t PREAMBLE = (4 << 0);  ///< component identification bits [11:8]
        constexpr uint32_t CLASS_ = (4 << 4);  ///< component identification bits [15:12] - component class (renamed from CLASS_)
    }

    /// CIDR2 Register bits
    namespace cidr2_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [23:16]
    }

    /// CIDR3 Register bits
    namespace cidr3_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [31:24]
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x46002400;
    constexpr uint32_t SEC_LPUART1_BASE = 0x56002400;
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t SEC_USART1_BASE = 0x50013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t SEC_USART2_BASE = 0x50004400;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t SEC_USART3_BASE = 0x50004800;
    constexpr uint32_t UART4_BASE = 0x40004C00;
    constexpr uint32_t SEC_UART4_BASE = 0x50004C00;
    constexpr uint32_t UART5_BASE = 0x40005000;
    constexpr uint32_t SEC_UART5_BASE = 0x50005000;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR;  ///< Offset: 0x1C - Interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - prescaler register
        volatile uint32_t AUTOCR;  ///< Offset: 0x30 - Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* SEC_LPUART1 = reinterpret_cast<Registers*>(SEC_LPUART1_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* SEC_USART1 = reinterpret_cast<Registers*>(SEC_USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* SEC_USART2 = reinterpret_cast<Registers*>(SEC_USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* SEC_USART3 = reinterpret_cast<Registers*>(SEC_USART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* SEC_UART4 = reinterpret_cast<Registers*>(SEC_UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);
    inline Registers* SEC_UART5 = reinterpret_cast<Registers*>(SEC_UART5_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFFIE
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFEIE
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFOEN
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXFNFIE = (1U << 7);  ///< TXFIFO not full interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXFNEIE = (1U << 5);  ///< RXFNEIE
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD = (8 << 24);  ///< Address of the LPUART node
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t DATAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFTCFG
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFTIE
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< RXFTCFG
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFTIE
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (20 << 0);  ///< BRR
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< TXFRQ
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFT
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFT
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFF
        constexpr uint32_t TXFE = (1U << 23);  ///< TXFE
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t TXFNF = (1U << 7);  ///< TXFNF
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXFNE = (1U << 5);  ///< RXFNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NE = (1U << 2);  ///< NE
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NECF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< PRESCALER
    }

    /// AUTOCR Register bits
    namespace autocr_bits {
        constexpr uint32_t TDN = (16 << 0);  ///< TDN
        constexpr uint32_t TRIGPOL = (1U << 16);  ///< TRIGPOL
        constexpr uint32_t TRIGEN = (1U << 17);  ///< TRIGEN
        constexpr uint32_t IDLEDIS = (1U << 18);  ///< IDLEDIS
        constexpr uint32_t TRIGSEL = (4 << 19);  ///< TRIGSEL
        constexpr uint32_t TECLREN = (1U << 31);  ///< TECLREN
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x46005400;
    constexpr uint32_t SEC_COMP_BASE = 0x56005400;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t COMP1_CSR;  ///< Offset: 0x00 - Comparator 1 control and status register
        volatile uint32_t COMP2_CSR;  ///< Offset: 0x04 - Comparator 2 control and status register
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);
    inline Registers* SEC_COMP = reinterpret_cast<Registers*>(SEC_COMP_BASE);

    // Bit definitions
    /// COMP1_CSR Register bits
    namespace comp1_csr_bits {
        constexpr uint32_t COMP1_EN = (1U << 0);  ///< Comparator 1 enable bit
        constexpr uint32_t COMP1_INMSEL = (4 << 4);  ///< Comparator 1 Input Minus connection configuration bit
        constexpr uint32_t COMP1_INPSEL = (2 << 8);  ///< Comparator1 input plus selection bit
        constexpr uint32_t COMP1_WINMODE = (1U << 11);  ///< COMP1_WINMODE
        constexpr uint32_t COMP1_WINOUT = (1U << 14);  ///< COMP1_WINOUT
        constexpr uint32_t COMP1_POLARITY = (1U << 15);  ///< Comparator 1 polarity selection bit
        constexpr uint32_t COMP1_HYST = (2 << 16);  ///< Comparator 1 hysteresis selection bits
        constexpr uint32_t COMP1_PWRMODE = (2 << 18);  ///< COMP1_PWRMODE
        constexpr uint32_t COMP1_BLANKSEL = (5 << 20);  ///< COMP1_BLANKSEL
        constexpr uint32_t COMP1_VALUE = (1U << 30);  ///< Comparator 1 output status bit
        constexpr uint32_t COMP1_LOCK = (1U << 31);  ///< COMP1_CSR register lock bit
    }

    /// COMP2_CSR Register bits
    namespace comp2_csr_bits {
        constexpr uint32_t COM2_EN = (1U << 0);  ///< Comparator 2 enable bit
        constexpr uint32_t COM2_INMSEL = (4 << 4);  ///< Comparator 2 Input Minus connection configuration bit
        constexpr uint32_t COM2_INPSEL = (2 << 8);  ///< Comparator 2 input plus selection bit
        constexpr uint32_t COM2_WINMODE = (1U << 11);  ///< COM2_WINMODE
        constexpr uint32_t COM2_WINOUT = (1U << 14);  ///< COM2_WINOUT
        constexpr uint32_t COM2_POLARITY = (1U << 15);  ///< Comparator 2 polarity selection bit
        constexpr uint32_t COM2_HYST = (2 << 16);  ///< Comparator 2 hysteresis selection bits
        constexpr uint32_t COM2_PWRMODE = (2 << 18);  ///< COM2_PWRMODE
        constexpr uint32_t COM2_BLANKSEL = (5 << 20);  ///< COM2_BLANKSEL
        constexpr uint32_t COM2_VALUE = (1U << 30);  ///< Comparator 2 output status bit
        constexpr uint32_t COM2_LOCK = (1U << 31);  ///< COMP2_CSR register lock bit
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x46007400;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t VREFBUF_CSR;  ///< Offset: 0x00 - VREFBUF control and status register
        volatile uint32_t VREFBUF_CCR;  ///< Offset: 0x04 - VREFBUF calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// VREFBUF_CSR Register bits
    namespace vrefbuf_csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< ENVR
        constexpr uint32_t HIZ = (1U << 1);  ///< HIZ
        constexpr uint32_t VRR = (1U << 3);  ///< VRR
        constexpr uint32_t VRS = (3 << 4);  ///< VRS
    }

    /// VREFBUF_CCR Register bits
    namespace vrefbuf_ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< TRIM
    }

}

// ============================================================================
// TSC Peripheral
// ============================================================================

namespace tsc {
    /// Base addresses
    constexpr uint32_t TSC_BASE = 0x40024000;

    /// TSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t IER;  ///< Offset: 0x04 - interrupt enable register
        volatile uint32_t ICR;  ///< Offset: 0x08 - interrupt clear register
        volatile uint32_t ISR;  ///< Offset: 0x0C - interrupt status register
        volatile uint32_t IOHCR;  ///< Offset: 0x10 - I/O hysteresis control register
        volatile uint32_t IOASCR;  ///< Offset: 0x18 - I/O analog switch control register
        volatile uint32_t IOSCR;  ///< Offset: 0x20 - I/O sampling control register
        volatile uint32_t IOCCR;  ///< Offset: 0x28 - I/O channel control register
        volatile uint32_t IOGCSR;  ///< Offset: 0x30 - I/O group control status register
        volatile uint32_t IOG1CR;  ///< Offset: 0x34 - I/O group x counter register
        volatile uint32_t IOG2CR;  ///< Offset: 0x38 - I/O group x counter register
        volatile uint32_t IOG3CR;  ///< Offset: 0x3C - I/O group x counter register
        volatile uint32_t IOG4CR;  ///< Offset: 0x40 - I/O group x counter register
        volatile uint32_t IOG5CR;  ///< Offset: 0x44 - I/O group x counter register
        volatile uint32_t IOG6CR;  ///< Offset: 0x48 - I/O group x counter register
        volatile uint32_t IOG7CR;  ///< Offset: 0x4C - I/O group x counter register
        volatile uint32_t IOG8CR;  ///< Offset: 0x50 - I/O group x counter register
    };

    /// Peripheral instances
    inline Registers* TSC = reinterpret_cast<Registers*>(TSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CTPH = (4 << 28);  ///< Charge transfer pulse high
        constexpr uint32_t CTPL = (4 << 24);  ///< Charge transfer pulse low
        constexpr uint32_t SSD = (7 << 17);  ///< Spread spectrum deviation
        constexpr uint32_t SSE = (1U << 16);  ///< Spread spectrum enable
        constexpr uint32_t SSPSC = (1U << 15);  ///< Spread spectrum prescaler
        constexpr uint32_t PGPSC = (3 << 12);  ///< pulse generator prescaler
        constexpr uint32_t MCV = (3 << 5);  ///< Max count value
        constexpr uint32_t IODEF = (1U << 4);  ///< I/O Default mode
        constexpr uint32_t SYNCPOL = (1U << 3);  ///< Synchronization pin polarity
        constexpr uint32_t AM = (1U << 2);  ///< Acquisition mode
        constexpr uint32_t START = (1U << 1);  ///< Start a new acquisition
        constexpr uint32_t TSCE = (1U << 0);  ///< Touch sensing controller enable
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t MCEIE = (1U << 1);  ///< Max count error interrupt enable
        constexpr uint32_t EOAIE = (1U << 0);  ///< End of acquisition interrupt enable
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t MCEIC = (1U << 1);  ///< Max count error interrupt clear
        constexpr uint32_t EOAIC = (1U << 0);  ///< End of acquisition interrupt clear
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t MCEF = (1U << 1);  ///< Max count error flag
        constexpr uint32_t EOAF = (1U << 0);  ///< End of acquisition flag
    }

    /// IOHCR Register bits
    namespace iohcr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOASCR Register bits
    namespace ioascr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOSCR Register bits
    namespace ioscr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOCCR Register bits
    namespace ioccr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOGCSR Register bits
    namespace iogcsr_bits {
        constexpr uint32_t G8S = (1U << 23);  ///< Analog I/O group x status
        constexpr uint32_t G7S = (1U << 22);  ///< Analog I/O group x status
        constexpr uint32_t G6S = (1U << 21);  ///< Analog I/O group x status
        constexpr uint32_t G5S = (1U << 20);  ///< Analog I/O group x status
        constexpr uint32_t G4S = (1U << 19);  ///< Analog I/O group x status
        constexpr uint32_t G3S = (1U << 18);  ///< Analog I/O group x status
        constexpr uint32_t G2S = (1U << 17);  ///< Analog I/O group x status
        constexpr uint32_t G1S = (1U << 16);  ///< Analog I/O group x status
        constexpr uint32_t G8E = (1U << 7);  ///< Analog I/O group x enable
        constexpr uint32_t G7E = (1U << 6);  ///< Analog I/O group x enable
        constexpr uint32_t G6E = (1U << 5);  ///< Analog I/O group x enable
        constexpr uint32_t G5E = (1U << 4);  ///< Analog I/O group x enable
        constexpr uint32_t G4E = (1U << 3);  ///< Analog I/O group x enable
        constexpr uint32_t G3E = (1U << 2);  ///< Analog I/O group x enable
        constexpr uint32_t G2E = (1U << 1);  ///< Analog I/O group x enable
        constexpr uint32_t G1E = (1U << 0);  ///< Analog I/O group x enable
    }

    /// IOG1CR Register bits
    namespace iog1cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG2CR Register bits
    namespace iog2cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG3CR Register bits
    namespace iog3cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG4CR Register bits
    namespace iog4cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG5CR Register bits
    namespace iog5cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG6CR Register bits
    namespace iog6cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG7CR Register bits
    namespace iog7cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG8CR Register bits
    namespace iog8cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

}

// ============================================================================
// UCPD1 Peripheral
// ============================================================================

namespace ucpd1 {
    /// Base addresses
    constexpr uint32_t UCPD1_BASE = 0x4000DC00;

    /// UCPD1 Register structure
    struct Registers {
        volatile uint32_t UCPD_CFGR1;  ///< Offset: 0x00 - UCPD configuration register 1
        volatile uint32_t UCPD_CFGR2;  ///< Offset: 0x04 - UCPD configuration register 2
        volatile uint32_t UCPD_CFGR3;  ///< Offset: 0x08 - UCPD configuration register 3
        volatile uint32_t UCPD_CR;  ///< Offset: 0x0C - UCPD control register
        volatile uint32_t UCPD_IMR;  ///< Offset: 0x10 - UCPD interrupt mask register
        volatile uint32_t UCPD_SR;  ///< Offset: 0x14 - UCPD status register
        volatile uint32_t UCPD_ICR;  ///< Offset: 0x18 - UCPD interrupt clear register
        volatile uint32_t UCPD_TX_ORDSETR;  ///< Offset: 0x1C - UCPD Tx ordered set type register
        volatile uint32_t UCPD_TX_PAYSZR;  ///< Offset: 0x20 - UCPD Tx payload size register
        volatile uint32_t UCPD_TXDR;  ///< Offset: 0x24 - UCPD Tx data register
        volatile uint32_t UCPD_RX_ORDSETR;  ///< Offset: 0x28 - Rx ordered set code detected
        volatile uint32_t UCPD_RX_PAYSZR;  ///< Offset: 0x2C - Rx payload size received This bitfield contains the...
        volatile uint32_t UCPD_RXDR;  ///< Offset: 0x30 - Data byte received
        volatile uint32_t UCPD_RX_ORDEXTR1;  ///< Offset: 0x34 - UCPD Rx ordered set extension register 1
        volatile uint32_t UCPD_RX_ORDEXTR2;  ///< Offset: 0x38 - UCPD Rx ordered set extension register 2
    };

    /// Peripheral instances
    inline Registers* UCPD1 = reinterpret_cast<Registers*>(UCPD1_BASE);

    // Bit definitions
    /// UCPD_CFGR1 Register bits
    namespace ucpd_cfgr1_bits {
        constexpr uint32_t HBITCLKDIV = (6 << 0);  ///< Division ratio for producing half-bit clock The bitfield determines the division ratio (the bitfield value plus one) of a ucpd_clk divider producing half-bit clock (hbit_clk).
        constexpr uint32_t IFRGAP = (5 << 6);  ///< Division ratio for producing inter-frame gap timer clock The bitfield determines the division ratio (the bitfield value minus one) of a ucpd_clk divider producing inter-frame gap timer clock (tInterFrameGap). The division ratio 15 is to apply for Tx clock at the USB PD 2.0 specification nominal value. The division ratios below 15 are to apply for Tx clock below nominal, and the division ratios above 15 for Tx clock above nominal.
        constexpr uint32_t TRANSWIN = (5 << 11);  ///< Transition window duration The bitfield determines the division ratio (the bitfield value minus one) of a hbit_clk divider producing tTransitionWindow interval. Set a value that produces an interval of 12 to 20 us, taking into account the ucpd_clk frequency and the HBITCLKDIV[5:0] bitfield setting.
        constexpr uint32_t PSC_USBPDCLK = (3 << 17);  ///< Pre-scaler division ratio for generating ucpd_clk The bitfield determines the division ratio of a kernel clock pre-scaler producing UCPD peripheral clock (ucpd_clk). It is recommended to use the pre-scaler so as to set the ucpd_clk frequency in the range from 6 to 9 MHz.
        constexpr uint32_t RXORDSETEN = (9 << 20);  ///< Receiver ordered set enable The bitfield determines the types of ordered sets that the receiver must detect. When set/cleared, each bit enables/disables a specific function: 0bxxxxxxxx1: SOP detect enabled 0bxxxxxxx1x: SOP' detect enabled 0bxxxxxx1xx: SOP'' detect enabled 0bxxxxx1xxx: Hard Reset detect enabled 0bxxxx1xxxx: Cable Detect reset enabled 0bxxx1xxxxx: SOP'_Debug enabled 0bxx1xxxxxx: SOP''_Debug enabled 0bx1xxxxxxx: SOP extension#1 enabled 0b1xxxxxxxx: SOP extension#2 enabled
        constexpr uint32_t TXDMAEN = (1U << 29);  ///< Transmission DMA mode enable When set, the bit enables DMA mode for transmission.
        constexpr uint32_t RXDMAEN = (1U << 30);  ///< Reception DMA mode enable When set, the bit enables DMA mode for reception.
        constexpr uint32_t UCPDEN = (1U << 31);  ///< UCPD peripheral enable General enable of the UCPD peripheral. Upon disabling, the peripheral instantly quits any ongoing activity and all control bits and bitfields default to their reset values. They must be set to their desired values each time the peripheral transits from disabled to enabled state.
    }

    /// UCPD_CFGR2 Register bits
    namespace ucpd_cfgr2_bits {
        constexpr uint32_t RXFILTDIS = (1U << 0);  ///< BMC decoder Rx pre-filter enable The sampling clock is that of the receiver (that is, after pre-scaler).
        constexpr uint32_t RXFILT2N3 = (1U << 1);  ///< BMC decoder Rx pre-filter sampling method Number of consistent consecutive samples before confirming a new value.
        constexpr uint32_t FORCECLK = (1U << 2);  ///< Force ClkReq clock request
        constexpr uint32_t WUPEN = (1U << 3);  ///< Wakeup from Stop mode enable Setting the bit enables the UCPD_ASYNC_INT signal.
    }

    /// UCPD_CFGR3 Register bits
    namespace ucpd_cfgr3_bits {
        constexpr uint32_t TRIM1_NG_CCRPD = (4 << 0);  ///< SW trim value for RPD resistors on the CC1 line
        constexpr uint32_t TRIM1_NG_CC3A0 = (4 << 9);  ///< SW trim value for Iref on the CC1 line
        constexpr uint32_t TRIM2_NG_CCRPD = (4 << 16);  ///< SW trim value for RPD resistors on the CC2 line
        constexpr uint32_t TRIM2_NG_CC3A0 = (4 << 25);  ///< SW trim value for Iref on the CC2 line
    }

    /// UCPD_CR Register bits
    namespace ucpd_cr_bits {
        constexpr uint32_t TXMODE = (2 << 0);  ///< Type of Tx packet Writing the bitfield triggers the action as follows, depending on the value: Others: invalid From V1.1 of the USB PD specification, there is a counter defined for the duration of the BIST Carrier Mode 2. To quit this mode correctly (after the "tBISTContMode" delay), disable the peripheral (UCPDEN = 0).
        constexpr uint32_t TXSEND = (1U << 2);  ///< Command to send a Tx packet The bit is cleared by hardware as soon as the packet transmission begins or is discarded.
        constexpr uint32_t TXHRST = (1U << 3);  ///< Command to send a Tx Hard Reset The bit is cleared by hardware as soon as the message transmission begins or is discarded.
        constexpr uint32_t RXMODE = (1U << 4);  ///< Receiver mode Determines the mode of the receiver. When the bit is set, RXORDSET behaves normally, RXDR no longer receives bytes yet the CRC checking still proceeds as for a normal message.
        constexpr uint32_t PHYRXEN = (1U << 5);  ///< USB Power Delivery receiver enable Both CC1 and CC2 receivers are disabled when the bit is cleared. Only the CC receiver selected via the PHYCCSEL bit is enabled when the bit is set.
        constexpr uint32_t PHYCCSEL = (1U << 6);  ///< CC1/CC2 line selector for USB Power Delivery signaling The selection depends on the cable orientation as discovered at attach.
        constexpr uint32_t ANASUBMODE = (2 << 7);  ///< Analog PHY sub-mode Refer to TYPEC_VSTATE_CCx for the effect of this bitfield.
        constexpr uint32_t ANAMODE = (1U << 9);  ///< Analog PHY operating mode The use of CC1 and CC2 depends on CCENABLE. Refer to ANAMODE, ANASUBMODE and link with TYPEC_VSTATE_CCx for the effect of this bitfield in conjunction with ANASUBMODE[1:0].
        constexpr uint32_t CCENABLE = (2 << 10);  ///< CC line enable This bitfield enables CC1 and CC2 line analog PHYs (pull-ups and pull-downs) according to ANAMODE and ANASUBMODE[1:0] setting. A single line PHY can be enabled when, for example, the other line is driven by VCONN via an external VCONN switch. Enabling both PHYs is the normal usage for sink/source.
        constexpr uint32_t CC1VCONNEN = (1U << 13);  ///< VCONN switch enable for CC1
        constexpr uint32_t CC2VCONNEN = (1U << 14);  ///< VCONN switch enable for CC2
        constexpr uint32_t FRSRXEN = (1U << 16);  ///< FRS event detection enable Setting the bit enables FRS Rx event (FRSEVT) detection on the CC line selected through the PHYCCSEL bit. 0: Disable Clear the bit when the device is attached to an FRS-incapable source/sink.
        constexpr uint32_t FRSTX = (1U << 17);  ///< FRS Tx signaling enable. Setting the bit enables FRS Tx signaling. The bit is cleared by hardware after a delay respecting the USB Power Delivery specification Revision 3.0.
        constexpr uint32_t RDCH = (1U << 18);  ///< Rdch condition drive The bit drives Rdch condition on the CC line selected through the PHYCCSEL bit (thus associated with VCONN), by remaining set during the source-only UnattachedWait.SRC state, to respect the Type-C state. Refer to "USB Type-C ECN for Source VCONN Discharge". The CCENABLE[1:0] bitfield must be set accordingly, too.
        constexpr uint32_t CC1TCDIS = (1U << 20);  ///< CC1 Type-C detector disable The bit disables the Type-C detector on the CC1 line. When enabled, the Type-C detector for CC1 is configured through ANAMODE and ANASUBMODE[1:0].
        constexpr uint32_t CC2TCDIS = (1U << 21);  ///< CC2 Type-C detector disable The bit disables the Type-C detector on the CC2 line. When enabled, the Type-C detector for CC2 is configured through ANAMODE and ANASUBMODE[1:0].
    }

    /// UCPD_IMR Register bits
    namespace ucpd_imr_bits {
        constexpr uint32_t TXISIE = (1U << 0);  ///< TXIS interrupt enable
        constexpr uint32_t TXMSGDISCIE = (1U << 1);  ///< TXMSGDISC interrupt enable
        constexpr uint32_t TXMSGSENTIE = (1U << 2);  ///< TXMSGSENT interrupt enable
        constexpr uint32_t TXMSGABTIE = (1U << 3);  ///< TXMSGABT interrupt enable
        constexpr uint32_t HRSTDISCIE = (1U << 4);  ///< HRSTDISC interrupt enable
        constexpr uint32_t HRSTSENTIE = (1U << 5);  ///< HRSTSENT interrupt enable
        constexpr uint32_t TXUNDIE = (1U << 6);  ///< TXUND interrupt enable
        constexpr uint32_t RXNEIE = (1U << 8);  ///< RXNE interrupt enable
        constexpr uint32_t RXORDDETIE = (1U << 9);  ///< RXORDDET interrupt enable
        constexpr uint32_t RXHRSTDETIE = (1U << 10);  ///< RXHRSTDET interrupt enable
        constexpr uint32_t RXOVRIE = (1U << 11);  ///< RXOVR interrupt enable
        constexpr uint32_t RXMSGENDIE = (1U << 12);  ///< RXMSGEND interrupt enable
        constexpr uint32_t TYPECEVT1IE = (1U << 14);  ///< TYPECEVT1 interrupt enable
        constexpr uint32_t TYPECEVT2IE = (1U << 15);  ///< TYPECEVT2 interrupt enable
        constexpr uint32_t FRSEVTIE = (1U << 20);  ///< FRSEVT interrupt enable
    }

    /// UCPD_SR Register bits
    namespace ucpd_sr_bits {
        constexpr uint32_t TXIS = (1U << 0);  ///< Transmit interrupt status The flag indicates that the UCPD_TXDR register is empty and new data write is required (as the amount of data sent has not reached the payload size defined in the TXPAYSZ bitfield). The flag is cleared with the data write into the UCPD_TXDR register.
        constexpr uint32_t TXMSGDISC = (1U << 1);  ///< Message transmission discarded The flag indicates that a message transmission was dropped. The flag is cleared by setting the TXMSGDISCCF bit. Transmission of a message can be dropped if there is a concurrent receive in progress or at excessive noise on the line. After a Tx message is discarded, the flag is only raised when the CC line becomes idle.
        constexpr uint32_t TXMSGSENT = (1U << 2);  ///< Message transmission completed The flag indicates the completion of packet transmission. It is cleared by setting the TXMSGSENTCF bit. In the event of a message transmission interrupted by a Hard Reset, the flag is not raised.
        constexpr uint32_t TXMSGABT = (1U << 3);  ///< Transmit message abort The flag indicates that a Tx message is aborted due to a subsequent Hard Reset message send request taking priority during transmit. It is cleared by setting the TXMSGABTCF bit.
        constexpr uint32_t HRSTDISC = (1U << 4);  ///< Hard Reset discarded The flag indicates that the Hard Reset message is discarded. The flag is cleared by setting the HRSTDISCCF bit.
        constexpr uint32_t HRSTSENT = (1U << 5);  ///< Hard Reset message sent The flag indicates that the Hard Reset message is sent. The flag is cleared by setting the HRSTSENTCF bit.
        constexpr uint32_t TXUND = (1U << 6);  ///< Tx data underrun detection The flag indicates that the Tx data register (UCPD_TXDR) was not written in time for a transmit message to execute normally. It is cleared by setting the TXUNDCF bit.
        constexpr uint32_t RXNE = (1U << 8);  ///< Receive data register not empty detection The flag indicates that the UCPD_RXDR register is not empty. It is automatically cleared upon reading UCPD_RXDR.
        constexpr uint32_t RXORDDET = (1U << 9);  ///< Rx ordered set (4 K-codes) detection The flag indicates the detection of an ordered set. The relevant information is stored in the RXORDSET[2:0] bitfield of the UCPD_RX_ORDSET register. It is cleared by setting the RXORDDETCF bit.
        constexpr uint32_t RXHRSTDET = (1U << 10);  ///< Rx Hard Reset receipt detection The flag indicates the receipt of valid Hard Reset message. It is cleared by setting the RXHRSTDETCF bit.
        constexpr uint32_t RXOVR = (1U << 11);  ///< Rx data overflow detection The flag indicates Rx data buffer overflow. It is cleared by setting the RXOVRCF bit. The buffer overflow can occur if the received data are not read fast enough.
        constexpr uint32_t RXMSGEND = (1U << 12);  ///< Rx message received The flag indicates whether a message (except Hard Reset message) has been received, regardless the CRC value. The flag is cleared by setting the RXMSGENDCF bit. The RXERR flag set when the RXMSGEND flag goes high indicates errors in the last-received message.
        constexpr uint32_t RXERR = (1U << 13);  ///< Receive message error The flag indicates errors of the last Rx message declared (via RXMSGEND), such as incorrect CRC or truncated message (a line becoming static before EOP is met). It is asserted whenever the RXMSGEND flag is set.
        constexpr uint32_t TYPECEVT1 = (1U << 14);  ///< Type-C voltage level event on CC1 line The flag indicates a change of the TYPEC_VSTATE_CC1[1:0] bitfield value, which corresponds to a new Type-C event. It is cleared by setting the TYPECEVT2CF bit.
        constexpr uint32_t TYPECEVT2 = (1U << 15);  ///< Type-C voltage level event on CC2 line The flag indicates a change of the TYPEC_VSTATE_CC2[1:0] bitfield value, which corresponds to a new Type-C event. It is cleared by setting the TYPECEVT2CF bit.
        constexpr uint32_t TYPEC_VSTATE_CC1 = (2 << 16);  ///< The status bitfield indicates the voltage level on the CC1 line in its steady state. The voltage variation on the CC1 line during USB PD messages due to the BMC PHY modulation does not impact the bitfield value.
        constexpr uint32_t TYPEC_VSTATE_CC2 = (2 << 18);  ///< CC2 line voltage level The status bitfield indicates the voltage level on the CC2 line in its steady state. The voltage variation on the CC2 line during USB PD messages due to the BMC PHY modulation does not impact the bitfield value.
        constexpr uint32_t FRSEVT = (1U << 20);  ///< FRS detection event The flag is cleared by setting the FRSEVTCF bit.
    }

    /// UCPD_ICR Register bits
    namespace ucpd_icr_bits {
        constexpr uint32_t TXMSGDISCCF = (1U << 1);  ///< Tx message discard flag (TXMSGDISC) clear Setting the bit clears the TXMSGDISC flag in the UCPD_SR register.
        constexpr uint32_t TXMSGSENTCF = (1U << 2);  ///< Tx message send flag (TXMSGSENT) clear Setting the bit clears the TXMSGSENT flag in the UCPD_SR register.
        constexpr uint32_t TXMSGABTCF = (1U << 3);  ///< Tx message abort flag (TXMSGABT) clear Setting the bit clears the TXMSGABT flag in the UCPD_SR register.
        constexpr uint32_t HRSTDISCCF = (1U << 4);  ///< Hard reset discard flag (HRSTDISC) clear Setting the bit clears the HRSTDISC flag in the UCPD_SR register.
        constexpr uint32_t HRSTSENTCF = (1U << 5);  ///< Hard reset send flag (HRSTSENT) clear Setting the bit clears the HRSTSENT flag in the UCPD_SR register.
        constexpr uint32_t TXUNDCF = (1U << 6);  ///< Tx underflow flag (TXUND) clear Setting the bit clears the TXUND flag in the UCPD_SR register.
        constexpr uint32_t RXORDDETCF = (1U << 9);  ///< Rx ordered set detect flag (RXORDDET) clear Setting the bit clears the RXORDDET flag in the UCPD_SR register.
        constexpr uint32_t RXHRSTDETCF = (1U << 10);  ///< Rx Hard Reset detect flag (RXHRSTDET) clear Setting the bit clears the RXHRSTDET flag in the UCPD_SR register.
        constexpr uint32_t RXOVRCF = (1U << 11);  ///< Rx overflow flag (RXOVR) clear Setting the bit clears the RXOVR flag in the UCPD_SR register.
        constexpr uint32_t RXMSGENDCF = (1U << 12);  ///< Rx message received flag (RXMSGEND) clear Setting the bit clears the RXMSGEND flag in the UCPD_SR register.
        constexpr uint32_t TYPECEVT1CF = (1U << 14);  ///< Type-C CC1 event flag (TYPECEVT1) clear Setting the bit clears the TYPECEVT1 flag in the UCPD_SR register
        constexpr uint32_t TYPECEVT2CF = (1U << 15);  ///< Type-C CC2 line event flag (TYPECEVT2) clear Setting the bit clears the TYPECEVT2 flag in the UCPD_SR register
        constexpr uint32_t FRSEVTCF = (1U << 20);  ///< FRS event flag (FRSEVT) clear Setting the bit clears the FRSEVT flag in the UCPD_SR register.
    }

    /// UCPD_TX_ORDSETR Register bits
    namespace ucpd_tx_ordsetr_bits {
        constexpr uint32_t TXORDSET = (20 << 0);  ///< Ordered set to transmit The bitfield determines a full 20-bit sequence to transmit, consisting of four K-codes, each of five bits, defining the packet to transmit. The bit 0 (bit 0 of K-code1) is the first, the bit 19 (bit 4 of Kcode4) the last.
    }

    /// UCPD_TX_PAYSZR Register bits
    namespace ucpd_tx_payszr_bits {
        constexpr uint32_t TXPAYSZ = (10 << 0);  ///< Payload size yet to transmit The bitfield is modified by software and by hardware. It contains the number of bytes of a payload (including header but excluding CRC) yet to transmit: each time a data byte is written into the UCPD_TXDR register, the bitfield value decrements and the TXIS bit is set, except when the bitfield value reaches zero. The enumerated values are standard payload sizes before the start of transmission.
    }

    /// UCPD_TXDR Register bits
    namespace ucpd_txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< Data byte to transmit
    }

    /// UCPD_RX_ORDSETR Register bits
    namespace ucpd_rx_ordsetr_bits {
        constexpr uint32_t RXORDSET = (3 << 0);  ///< Rx ordered set code detected
        constexpr uint32_t RXSOP3OF4 = (1U << 3);  ///< The bit indicates the number of correct Kcodes. For debug purposes only.
        constexpr uint32_t RXSOPKINVALID = (3 << 4);  ///< The bitfield is for debug purposes only. Others: Invalid
    }

    /// UCPD_RX_PAYSZR Register bits
    namespace ucpd_rx_payszr_bits {
        constexpr uint32_t RXPAYSZ = (10 << 0);  ///< Rx payload size received This bitfield contains the number of bytes of a payload (including header but excluding CRC) received: each time a new data byte is received in the UCPD_RXDR register, the bitfield value increments and the RXMSGEND flag is set (and an interrupt generated if enabled). The bitfield may return a spurious value when a byte reception is ongoing (the RXMSGEND flag is low).
    }

    /// UCPD_RXDR Register bits
    namespace ucpd_rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< Data byte received
    }

    /// UCPD_RX_ORDEXTR1 Register bits
    namespace ucpd_rx_ordextr1_bits {
        constexpr uint32_t RXSOPX1 = (20 << 0);  ///< Ordered set 1 received The bitfield contains a full 20-bit sequence received, consisting of four Kcodes, each of five bits. The bit 0 (bit 0 of Kcode1) is receive first, the bit 19 (bit 4 of Kcode4) last.
    }

    /// UCPD_RX_ORDEXTR2 Register bits
    namespace ucpd_rx_ordextr2_bits {
        constexpr uint32_t RXSOPX2 = (20 << 0);  ///< Ordered set 2 received The bitfield contains a full 20-bit sequence received, consisting of four Kcodes, each of five bits. The bit 0 (bit 0 of Kcode1) is receive first, the bit 19 (bit 4 of Kcode4) last.
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t FDCAN1_RAM_BASE = 0x4000AC00;
    constexpr uint32_t SEC_FDCAN1_RAM_BASE = 0x5000AC00;
    constexpr uint32_t FDCAN1_BASE = 0x4000A400;
    constexpr uint32_t SEC_FDCAN1_BASE = 0x5000A400;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t FDCAN_CREL;  ///< Offset: 0x00 - FDCAN Core Release Register
        volatile uint32_t FDCAN_ENDN;  ///< Offset: 0x04 - FDCAN endian register
        volatile uint32_t FDCAN_DBTP;  ///< Offset: 0x0C - FDCAN Data Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TEST;  ///< Offset: 0x10 - FDCAN Test Register
        volatile uint32_t FDCAN_RWD;  ///< Offset: 0x14 - FDCAN RAM Watchdog Register
        volatile uint32_t FDCAN_CCCR;  ///< Offset: 0x18 - FDCAN CC Control Register
        volatile uint32_t FDCAN_NBTP;  ///< Offset: 0x1C - FDCAN Nominal Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TSCC;  ///< Offset: 0x20 - FDCAN Timestamp Counter Configuration Register
        volatile uint32_t FDCAN_TSCV;  ///< Offset: 0x24 - FDCAN Timestamp Counter Value Register
        volatile uint32_t FDCAN_TOCC;  ///< Offset: 0x28 - FDCAN Timeout Counter Configuration Register
        volatile uint32_t FDCAN_TOCV;  ///< Offset: 0x2C - FDCAN Timeout Counter Value Register
        volatile uint32_t FDCAN_ECR;  ///< Offset: 0x40 - FDCAN Error Counter Register
        volatile uint32_t FDCAN_PSR;  ///< Offset: 0x44 - FDCAN Protocol Status Register
        volatile uint32_t FDCAN_TDCR;  ///< Offset: 0x48 - FDCAN Transmitter Delay Compensation Register
        volatile uint32_t FDCAN_IR;  ///< Offset: 0x50 - FDCAN Interrupt Register
        volatile uint32_t FDCAN_IE;  ///< Offset: 0x54 - FDCAN Interrupt Enable Register
        volatile uint32_t FDCAN_ILS;  ///< Offset: 0x58 - FDCAN Interrupt Line Select Register
        volatile uint32_t FDCAN_ILE;  ///< Offset: 0x5C - FDCAN Interrupt Line Enable Register
        volatile uint32_t FDCAN_RXGFC;  ///< Offset: 0x80 - FDCAN Global Filter Configuration Register
        volatile uint32_t FDCAN_XIDAM;  ///< Offset: 0x84 - FDCAN Extended ID and Mask Register
        volatile uint32_t FDCAN_HPMS;  ///< Offset: 0x88 - FDCAN High Priority Message Status Register
        volatile uint32_t FDCAN_RXF0S;  ///< Offset: 0x90 - FDCAN Rx FIFO 0 Status Register
        volatile uint32_t FDCAN_RXF0A;  ///< Offset: 0x94 - CAN Rx FIFO 0 Acknowledge Register
        volatile uint32_t FDCAN_RXF1S;  ///< Offset: 0x98 - FDCAN Rx FIFO 1 Status Register
        volatile uint32_t FDCAN_RXF1A;  ///< Offset: 0x9C - FDCAN Rx FIFO 1 Acknowledge Register
        volatile uint32_t FDCAN_TXBC;  ///< Offset: 0xC0 - FDCAN Tx buffer configuration register
        volatile uint32_t FDCAN_TXFQS;  ///< Offset: 0xC4 - FDCAN Tx FIFO/Queue Status Register
        volatile uint32_t FDCAN_TXBRP;  ///< Offset: 0xC8 - FDCAN Tx Buffer Request Pending Register
        volatile uint32_t FDCAN_TXBAR;  ///< Offset: 0xCC - FDCAN Tx Buffer Add Request Register
        volatile uint32_t FDCAN_TXBCR;  ///< Offset: 0xD0 - FDCAN Tx Buffer Cancellation Request Register
        volatile uint32_t FDCAN_TXBTO;  ///< Offset: 0xD4 - FDCAN Tx Buffer Transmission Occurred Register
        volatile uint32_t FDCAN_TXBCF;  ///< Offset: 0xD8 - FDCAN Tx Buffer Cancellation Finished Register
        volatile uint32_t FDCAN_TXBTIE;  ///< Offset: 0xDC - FDCAN Tx Buffer Transmission Interrupt Enable Register
        volatile uint32_t FDCAN_TXBCIE;  ///< Offset: 0xE0 - FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        volatile uint32_t FDCAN_TXEFS;  ///< Offset: 0xE4 - FDCAN Tx Event FIFO Status Register
        volatile uint32_t FDCAN_TXEFA;  ///< Offset: 0xE8 - FDCAN Tx Event FIFO Acknowledge Register
        volatile uint32_t FDCAN_CKDIV;  ///< Offset: 0x100 - FDCAN CFG clock divider register
    };

    /// Peripheral instances
    inline Registers* FDCAN1_RAM = reinterpret_cast<Registers*>(FDCAN1_RAM_BASE);
    inline Registers* SEC_FDCAN1_RAM = reinterpret_cast<Registers*>(SEC_FDCAN1_RAM_BASE);
    inline Registers* FDCAN1 = reinterpret_cast<Registers*>(FDCAN1_BASE);
    inline Registers* SEC_FDCAN1 = reinterpret_cast<Registers*>(SEC_FDCAN1_BASE);

    // Bit definitions
    /// FDCAN_CREL Register bits
    namespace fdcan_crel_bits {
        constexpr uint32_t REL = (4 << 28);  ///< Core release
        constexpr uint32_t STEP = (4 << 24);  ///< Step of Core release
        constexpr uint32_t SUBSTEP = (4 << 20);  ///< Sub-step of Core release
        constexpr uint32_t YEAR = (4 << 16);  ///< Timestamp Year
        constexpr uint32_t MON = (8 << 8);  ///< Timestamp Month
        constexpr uint32_t DAY = (8 << 0);  ///< Timestamp Day
    }

    /// FDCAN_ENDN Register bits
    namespace fdcan_endn_bits {
        constexpr uint32_t ETV = (32 << 0);  ///< Endiannes Test Value
    }

    /// FDCAN_DBTP Register bits
    namespace fdcan_dbtp_bits {
        constexpr uint32_t DSJW = (4 << 0);  ///< Synchronization Jump Width
        constexpr uint32_t DTSEG2 = (4 << 4);  ///< Data time segment after sample point
        constexpr uint32_t DTSEG1 = (5 << 8);  ///< Data time segment after sample point
        constexpr uint32_t DBRP = (5 << 16);  ///< Data BIt Rate Prescaler
        constexpr uint32_t TDC = (1U << 23);  ///< Transceiver Delay Compensation
    }

    /// FDCAN_TEST Register bits
    namespace fdcan_test_bits {
        constexpr uint32_t LBCK = (1U << 4);  ///< Loop Back mode
        constexpr uint32_t TX = (2 << 5);  ///< Loop Back mode
        constexpr uint32_t RX = (1U << 7);  ///< Control of Transmit Pin
    }

    /// FDCAN_RWD Register bits
    namespace fdcan_rwd_bits {
        constexpr uint32_t WDV = (8 << 8);  ///< Watchdog value
        constexpr uint32_t WDC = (8 << 0);  ///< Watchdog configuration
    }

    /// FDCAN_CCCR Register bits
    namespace fdcan_cccr_bits {
        constexpr uint32_t INIT = (1U << 0);  ///< Initialization
        constexpr uint32_t CCE = (1U << 1);  ///< Configuration Change Enable
        constexpr uint32_t ASM_ = (1U << 2);  ///< ASM Restricted Operation Mode (renamed from ASM_)
        constexpr uint32_t CSA = (1U << 3);  ///< Clock Stop Acknowledge
        constexpr uint32_t CSR = (1U << 4);  ///< Clock Stop Request
        constexpr uint32_t MON = (1U << 5);  ///< Bus Monitoring Mode
        constexpr uint32_t DAR = (1U << 6);  ///< Disable Automatic Retransmission
        constexpr uint32_t TEST = (1U << 7);  ///< Test Mode Enable
        constexpr uint32_t FDOE = (1U << 8);  ///< FD Operation Enable
        constexpr uint32_t BRSE = (1U << 9);  ///< FDCAN Bit Rate Switching
        constexpr uint32_t PXHD = (1U << 12);  ///< Protocol Exception Handling Disable
        constexpr uint32_t EFBI = (1U << 13);  ///< Edge Filtering during Bus Integration
        constexpr uint32_t TXP = (1U << 14);  ///< TXP
        constexpr uint32_t NISO = (1U << 15);  ///< Non ISO Operation
    }

    /// FDCAN_NBTP Register bits
    namespace fdcan_nbtp_bits {
        constexpr uint32_t NSJW = (7 << 25);  ///< Nominal (Re)Synchronization Jump Width
        constexpr uint32_t NBRP = (9 << 16);  ///< Bit Rate Prescaler
        constexpr uint32_t NTSEG1 = (8 << 8);  ///< Nominal Time segment before sample point
        constexpr uint32_t NTSEG2 = (7 << 0);  ///< Nominal Time segment after sample point
    }

    /// FDCAN_TSCC Register bits
    namespace fdcan_tscc_bits {
        constexpr uint32_t TCP = (4 << 16);  ///< Timestamp Counter Prescaler
        constexpr uint32_t TSS = (2 << 0);  ///< Timestamp Select
    }

    /// FDCAN_TSCV Register bits
    namespace fdcan_tscv_bits {
        constexpr uint32_t TSC = (16 << 0);  ///< Timestamp Counter
    }

    /// FDCAN_TOCC Register bits
    namespace fdcan_tocc_bits {
        constexpr uint32_t ETOC = (1U << 0);  ///< Enable Timeout Counter
        constexpr uint32_t TOS = (2 << 1);  ///< Timeout Select
        constexpr uint32_t TOP = (16 << 16);  ///< Timeout Period
    }

    /// FDCAN_TOCV Register bits
    namespace fdcan_tocv_bits {
        constexpr uint32_t TOC = (16 << 0);  ///< Timeout Counter
    }

    /// FDCAN_ECR Register bits
    namespace fdcan_ecr_bits {
        constexpr uint32_t CEL = (8 << 16);  ///< AN Error Logging
        constexpr uint32_t RP = (1U << 15);  ///< Receive Error Passive
        constexpr uint32_t REC = (7 << 8);  ///< Receive Error Counter
        constexpr uint32_t TEC = (8 << 0);  ///< Transmit Error Counter
    }

    /// FDCAN_PSR Register bits
    namespace fdcan_psr_bits {
        constexpr uint32_t LEC = (3 << 0);  ///< Last Error Code
        constexpr uint32_t ACT = (2 << 3);  ///< Activity
        constexpr uint32_t EP = (1U << 5);  ///< Error Passive
        constexpr uint32_t EW = (1U << 6);  ///< Warning Status
        constexpr uint32_t BO = (1U << 7);  ///< Bus_Off Status
        constexpr uint32_t DLEC = (3 << 8);  ///< Data Last Error Code
        constexpr uint32_t RESI = (1U << 11);  ///< ESI flag of last received FDCAN Message
        constexpr uint32_t RBRS = (1U << 12);  ///< BRS flag of last received FDCAN Message
        constexpr uint32_t REDL = (1U << 13);  ///< Received FDCAN Message
        constexpr uint32_t PXE = (1U << 14);  ///< Protocol Exception Event
        constexpr uint32_t TDCV = (7 << 16);  ///< Transmitter Delay Compensation Value
    }

    /// FDCAN_TDCR Register bits
    namespace fdcan_tdcr_bits {
        constexpr uint32_t TDCF = (7 << 0);  ///< Transmitter Delay Compensation Filter Window Length
        constexpr uint32_t TDCO = (7 << 8);  ///< Transmitter Delay Compensation Offset
    }

    /// FDCAN_IR Register bits
    namespace fdcan_ir_bits {
        constexpr uint32_t RF0N = (1U << 0);  ///< RF0N
        constexpr uint32_t RF0F = (1U << 1);  ///< RF0F
        constexpr uint32_t RF0L = (1U << 2);  ///< RF0L
        constexpr uint32_t RF1N = (1U << 3);  ///< RF1N
        constexpr uint32_t RF1F = (1U << 4);  ///< RF1F
        constexpr uint32_t RF1L = (1U << 5);  ///< RF1L
        constexpr uint32_t HPM = (1U << 6);  ///< HPM
        constexpr uint32_t TC = (1U << 7);  ///< TC
        constexpr uint32_t TCF = (1U << 8);  ///< TCF
        constexpr uint32_t TFE = (1U << 9);  ///< TFE
        constexpr uint32_t TEFN = (1U << 10);  ///< TEFN
        constexpr uint32_t TEFF = (1U << 11);  ///< TEFF
        constexpr uint32_t TEFL = (1U << 12);  ///< TEFL
        constexpr uint32_t TSW = (1U << 13);  ///< TSW
        constexpr uint32_t MRAF = (1U << 14);  ///< MRAF
        constexpr uint32_t TOO = (1U << 15);  ///< TOO
        constexpr uint32_t ELO = (1U << 16);  ///< ELO
        constexpr uint32_t EP = (1U << 17);  ///< EP
        constexpr uint32_t EW = (1U << 18);  ///< EW
        constexpr uint32_t BO = (1U << 19);  ///< BO
        constexpr uint32_t WDI = (1U << 20);  ///< WDI
        constexpr uint32_t PEA = (1U << 21);  ///< PEA
        constexpr uint32_t PED = (1U << 22);  ///< PED
        constexpr uint32_t ARA = (1U << 23);  ///< ARA
    }

    /// FDCAN_IE Register bits
    namespace fdcan_ie_bits {
        constexpr uint32_t RF0NE = (1U << 0);  ///< Rx FIFO 0 New Message Enable
        constexpr uint32_t RF0FE = (1U << 1);  ///< Rx FIFO 0 Full Enable
        constexpr uint32_t RF0LE = (1U << 2);  ///< Rx FIFO 0 Message Lost Enable
        constexpr uint32_t RF1NE = (1U << 3);  ///< Rx FIFO 1 New Message Enable
        constexpr uint32_t RF1FE = (1U << 4);  ///< Rx FIFO 1 Watermark Reached Enable
        constexpr uint32_t RF1LE = (1U << 5);  ///< Rx FIFO 1 Message Lost Enable
        constexpr uint32_t HPME = (1U << 6);  ///< High Priority Message Enable
        constexpr uint32_t TCE = (1U << 7);  ///< Transmission Completed Enable
        constexpr uint32_t TCFE = (1U << 8);  ///< Transmission Cancellation Finished Enable
        constexpr uint32_t TEFE = (1U << 9);  ///< Tx FIFO Empty Enable
        constexpr uint32_t TEFNE = (1U << 10);  ///< Tx Event FIFO New Entry Enable
        constexpr uint32_t TEFFE = (1U << 11);  ///< Tx Event FIFO Full Enable
        constexpr uint32_t TEFLE = (1U << 12);  ///< Tx Event FIFO Element Lost Enable
        constexpr uint32_t TSWE = (1U << 13);  ///< TSWE
        constexpr uint32_t MRAFE = (1U << 14);  ///< Message RAM Access Failure Enable
        constexpr uint32_t TOOE = (1U << 15);  ///< Timeout Occurred Enable
        constexpr uint32_t ELOE = (1U << 16);  ///< Error Logging Overflow Enable
        constexpr uint32_t EPE = (1U << 17);  ///< Error Passive Enable
        constexpr uint32_t EWE = (1U << 18);  ///< Warning Status Enable
        constexpr uint32_t BOE = (1U << 19);  ///< Bus_Off Status Enable
        constexpr uint32_t WDIE = (1U << 20);  ///< Watchdog Interrupt Enable
        constexpr uint32_t PEAE = (1U << 21);  ///< Protocol Error in Arbitration Phase Enable
        constexpr uint32_t PEDE = (1U << 22);  ///< Protocol Error in Data Phase Enable
        constexpr uint32_t ARAE = (1U << 23);  ///< Access to Reserved Address Enable
    }

    /// FDCAN_ILS Register bits
    namespace fdcan_ils_bits {
        constexpr uint32_t RxFIFO0 = (1U << 0);  ///< RxFIFO0
        constexpr uint32_t RxFIFO1 = (1U << 1);  ///< RxFIFO1
        constexpr uint32_t SMSG = (1U << 2);  ///< SMSG
        constexpr uint32_t TFERR = (1U << 3);  ///< TFERR
        constexpr uint32_t MISC = (1U << 4);  ///< MISC
        constexpr uint32_t BERR = (1U << 5);  ///< BERR
        constexpr uint32_t PERR = (1U << 6);  ///< PERR
    }

    /// FDCAN_ILE Register bits
    namespace fdcan_ile_bits {
        constexpr uint32_t EINT0 = (1U << 0);  ///< Enable Interrupt Line 0
        constexpr uint32_t EINT1 = (1U << 1);  ///< Enable Interrupt Line 1
    }

    /// FDCAN_RXGFC Register bits
    namespace fdcan_rxgfc_bits {
        constexpr uint32_t RRFE = (1U << 0);  ///< Reject Remote Frames Extended
        constexpr uint32_t RRFS = (1U << 1);  ///< Reject Remote Frames Standard
        constexpr uint32_t ANFE = (2 << 2);  ///< Accept Non-matching Frames Extended
        constexpr uint32_t ANFS = (2 << 4);  ///< Accept Non-matching Frames Standard
        constexpr uint32_t F1OM = (1U << 8);  ///< F1OM
        constexpr uint32_t F0OM = (1U << 9);  ///< F0OM
        constexpr uint32_t LSS = (5 << 16);  ///< LSS
        constexpr uint32_t LSE = (4 << 24);  ///< LSE
    }

    /// FDCAN_XIDAM Register bits
    namespace fdcan_xidam_bits {
        constexpr uint32_t EIDM = (29 << 0);  ///< Extended ID Mask
    }

    /// FDCAN_HPMS Register bits
    namespace fdcan_hpms_bits {
        constexpr uint32_t BIDX = (3 << 0);  ///< Buffer Index
        constexpr uint32_t MSI = (2 << 6);  ///< Message Storage Indicator
        constexpr uint32_t FIDX = (5 << 8);  ///< Filter Index
        constexpr uint32_t FLST = (1U << 15);  ///< Filter List
    }

    /// FDCAN_RXF0S Register bits
    namespace fdcan_rxf0s_bits {
        constexpr uint32_t F0FL = (4 << 0);  ///< Rx FIFO 0 Fill Level
        constexpr uint32_t F0GI = (2 << 8);  ///< Rx FIFO 0 Get Index
        constexpr uint32_t F0PI = (2 << 16);  ///< Rx FIFO 0 Put Index
        constexpr uint32_t F0F = (1U << 24);  ///< Rx FIFO 0 Full
        constexpr uint32_t RF0L = (1U << 25);  ///< Rx FIFO 0 Message Lost
    }

    /// FDCAN_RXF0A Register bits
    namespace fdcan_rxf0a_bits {
        constexpr uint32_t F0AI = (3 << 0);  ///< Rx FIFO 0 Acknowledge Index
    }

    /// FDCAN_RXF1S Register bits
    namespace fdcan_rxf1s_bits {
        constexpr uint32_t F1FL = (4 << 0);  ///< Rx FIFO 1 Fill Level
        constexpr uint32_t F1GI = (2 << 8);  ///< Rx FIFO 1 Get Index
        constexpr uint32_t F1PI = (2 << 16);  ///< Rx FIFO 1 Put Index
        constexpr uint32_t F1F = (1U << 24);  ///< Rx FIFO 1 Full
        constexpr uint32_t RF1L = (1U << 25);  ///< Rx FIFO 1 Message Lost
    }

    /// FDCAN_RXF1A Register bits
    namespace fdcan_rxf1a_bits {
        constexpr uint32_t F1AI = (3 << 0);  ///< Rx FIFO 1 Acknowledge Index
    }

    /// FDCAN_TXBC Register bits
    namespace fdcan_txbc_bits {
        constexpr uint32_t TFQM = (1U << 24);  ///< Tx FIFO/Queue Mode
    }

    /// FDCAN_TXFQS Register bits
    namespace fdcan_txfqs_bits {
        constexpr uint32_t TFFL = (3 << 0);  ///< Tx FIFO Free Level
        constexpr uint32_t TFGI = (2 << 8);  ///< TFGI
        constexpr uint32_t TFQPI = (2 << 16);  ///< Tx FIFO/Queue Put Index
        constexpr uint32_t TFQF = (1U << 21);  ///< Tx FIFO/Queue Full
    }

    /// FDCAN_TXBRP Register bits
    namespace fdcan_txbrp_bits {
        constexpr uint32_t TRP = (3 << 0);  ///< Transmission Request Pending
    }

    /// FDCAN_TXBAR Register bits
    namespace fdcan_txbar_bits {
        constexpr uint32_t AR = (3 << 0);  ///< Add Request
    }

    /// FDCAN_TXBCR Register bits
    namespace fdcan_txbcr_bits {
        constexpr uint32_t CR = (3 << 0);  ///< Cancellation Request
    }

    /// FDCAN_TXBTO Register bits
    namespace fdcan_txbto_bits {
        constexpr uint32_t TO = (3 << 0);  ///< Transmission Occurred.
    }

    /// FDCAN_TXBCF Register bits
    namespace fdcan_txbcf_bits {
        constexpr uint32_t CF = (3 << 0);  ///< Cancellation Finished
    }

    /// FDCAN_TXBTIE Register bits
    namespace fdcan_txbtie_bits {
        constexpr uint32_t TIE = (3 << 0);  ///< Transmission Interrupt Enable
    }

    /// FDCAN_TXBCIE Register bits
    namespace fdcan_txbcie_bits {
        constexpr uint32_t CFIE = (3 << 0);  ///< Cancellation Finished Interrupt Enable
    }

    /// FDCAN_TXEFS Register bits
    namespace fdcan_txefs_bits {
        constexpr uint32_t EFFL = (3 << 0);  ///< Event FIFO Fill Level
        constexpr uint32_t EFGI = (2 << 8);  ///< Event FIFO Get Index.
        constexpr uint32_t EFPI = (2 << 16);  ///< Event FIFO Put Index
        constexpr uint32_t EFF = (1U << 24);  ///< Event FIFO Full.
        constexpr uint32_t TEFL = (1U << 25);  ///< Tx Event FIFO Element Lost.
    }

    /// FDCAN_TXEFA Register bits
    namespace fdcan_txefa_bits {
        constexpr uint32_t EFAI = (2 << 0);  ///< Event FIFO Acknowledge Index
    }

    /// FDCAN_CKDIV Register bits
    namespace fdcan_ckdiv_bits {
        constexpr uint32_t PDIV = (4 << 0);  ///< PDIV
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 8-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// CRS Peripheral
// ============================================================================

namespace crs {
    /// Base addresses
    constexpr uint32_t CRS_BASE = 0x40006000;

    /// CRS Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - configuration register
        volatile uint32_t ISR;  ///< Offset: 0x08 - interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x0C - interrupt flag clear register
    };

    /// Peripheral instances
    inline Registers* CRS = reinterpret_cast<Registers*>(CRS_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TRIM = (7 << 8);  ///< HSI48 oscillator smooth trimming
        constexpr uint32_t SWSYNC = (1U << 7);  ///< Generate software SYNC event
        constexpr uint32_t AUTOTRIMEN = (1U << 6);  ///< Automatic trimming enable
        constexpr uint32_t CEN = (1U << 5);  ///< Frequency error counter enable
        constexpr uint32_t ESYNCIE = (1U << 3);  ///< Expected SYNC interrupt enable
        constexpr uint32_t ERRIE = (1U << 2);  ///< Synchronization or trimming error interrupt enable
        constexpr uint32_t SYNCWARNIE = (1U << 1);  ///< SYNC warning interrupt enable
        constexpr uint32_t SYNCOKIE = (1U << 0);  ///< SYNC event OK interrupt enable
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t SYNCPOL = (1U << 31);  ///< SYNC polarity selection
        constexpr uint32_t SYNCSRC = (2 << 28);  ///< SYNC signal source selection
        constexpr uint32_t SYNCDIV = (3 << 24);  ///< SYNC divider
        constexpr uint32_t FELIM = (8 << 16);  ///< Frequency error limit
        constexpr uint32_t RELOAD = (16 << 0);  ///< Counter reload value
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t FECAP = (16 << 16);  ///< Frequency error capture
        constexpr uint32_t FEDIR = (1U << 15);  ///< Frequency error direction
        constexpr uint32_t TRIMOVF = (1U << 10);  ///< Trimming overflow or underflow
        constexpr uint32_t SYNCMISS = (1U << 9);  ///< SYNC missed
        constexpr uint32_t SYNCERR = (1U << 8);  ///< SYNC error
        constexpr uint32_t ESYNCF = (1U << 3);  ///< Expected SYNC flag
        constexpr uint32_t ERRF = (1U << 2);  ///< Error flag
        constexpr uint32_t SYNCWARNF = (1U << 1);  ///< SYNC warning flag
        constexpr uint32_t SYNCOKF = (1U << 0);  ///< SYNC event OK flag
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ESYNCC = (1U << 3);  ///< Expected SYNC clear flag
        constexpr uint32_t ERRC = (1U << 2);  ///< Error clear flag
        constexpr uint32_t SYNCWARNC = (1U << 1);  ///< SYNC warning clear flag
        constexpr uint32_t SYNCOKC = (1U << 0);  ///< SYNC event OK clear flag
    }

}

// ============================================================================
// HASH Peripheral
// ============================================================================

namespace hash {
    /// Base addresses
    constexpr uint32_t HASH_BASE = 0x420C0400;

    /// HASH Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t DIN;  ///< Offset: 0x04 - data input register
        volatile uint32_t STR;  ///< Offset: 0x08 - start register
        volatile uint32_t HRA0;  ///< Offset: 0x0C - HASH aliased digest register 0
        volatile uint32_t HRA1;  ///< Offset: 0x10 - HASH aliased digest register 1
        volatile uint32_t HRA2;  ///< Offset: 0x14 - HASH aliased digest register 2
        volatile uint32_t HRA3;  ///< Offset: 0x18 - HASH aliased digest register 3
        volatile uint32_t HRA4;  ///< Offset: 0x1C - HASH aliased digest register 4
        volatile uint32_t HR0;  ///< Offset: 0x310 - digest register 0
        volatile uint32_t HR1;  ///< Offset: 0x314 - digest register 1
        volatile uint32_t HR2;  ///< Offset: 0x318 - digest register 4
        volatile uint32_t HR3;  ///< Offset: 0x31C - digest register 3
        volatile uint32_t HR4;  ///< Offset: 0x320 - digest register 4
        volatile uint32_t HR5;  ///< Offset: 0x324 - supplementary digest register 5
        volatile uint32_t HR6;  ///< Offset: 0x328 - supplementary digest register 6
        volatile uint32_t HR7;  ///< Offset: 0x32C - supplementary digest register 7
        volatile uint32_t IMR;  ///< Offset: 0x20 - interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x24 - status register
        volatile uint32_t CSR0;  ///< Offset: 0xF8 - context swap registers
        volatile uint32_t CSR1;  ///< Offset: 0xFC - context swap registers
        volatile uint32_t CSR2;  ///< Offset: 0x100 - context swap registers
        volatile uint32_t CSR3;  ///< Offset: 0x104 - context swap registers
        volatile uint32_t CSR4;  ///< Offset: 0x108 - context swap registers
        volatile uint32_t CSR5;  ///< Offset: 0x10C - context swap registers
        volatile uint32_t CSR6;  ///< Offset: 0x110 - context swap registers
        volatile uint32_t CSR7;  ///< Offset: 0x114 - context swap registers
        volatile uint32_t CSR8;  ///< Offset: 0x118 - context swap registers
        volatile uint32_t CSR9;  ///< Offset: 0x11C - context swap registers
        volatile uint32_t CSR10;  ///< Offset: 0x120 - context swap registers
        volatile uint32_t CSR11;  ///< Offset: 0x124 - context swap registers
        volatile uint32_t CSR12;  ///< Offset: 0x128 - context swap registers
        volatile uint32_t CSR13;  ///< Offset: 0x12C - context swap registers
        volatile uint32_t CSR14;  ///< Offset: 0x130 - context swap registers
        volatile uint32_t CSR15;  ///< Offset: 0x134 - context swap registers
        volatile uint32_t CSR16;  ///< Offset: 0x138 - context swap registers
        volatile uint32_t CSR17;  ///< Offset: 0x13C - context swap registers
        volatile uint32_t CSR18;  ///< Offset: 0x140 - context swap registers
        volatile uint32_t CSR19;  ///< Offset: 0x144 - context swap registers
        volatile uint32_t CSR20;  ///< Offset: 0x148 - context swap registers
        volatile uint32_t CSR21;  ///< Offset: 0x14C - context swap registers
        volatile uint32_t CSR22;  ///< Offset: 0x150 - context swap registers
        volatile uint32_t CSR23;  ///< Offset: 0x154 - context swap registers
        volatile uint32_t CSR24;  ///< Offset: 0x158 - context swap registers
        volatile uint32_t CSR25;  ///< Offset: 0x15C - context swap registers
        volatile uint32_t CSR26;  ///< Offset: 0x160 - context swap registers
        volatile uint32_t CSR27;  ///< Offset: 0x164 - context swap registers
        volatile uint32_t CSR28;  ///< Offset: 0x168 - context swap registers
        volatile uint32_t CSR29;  ///< Offset: 0x16C - context swap registers
        volatile uint32_t CSR30;  ///< Offset: 0x170 - context swap registers
        volatile uint32_t CSR31;  ///< Offset: 0x174 - context swap registers
        volatile uint32_t CSR32;  ///< Offset: 0x178 - context swap registers
        volatile uint32_t CSR33;  ///< Offset: 0x17C - context swap registers
        volatile uint32_t CSR34;  ///< Offset: 0x180 - context swap registers
        volatile uint32_t CSR35;  ///< Offset: 0x184 - context swap registers
        volatile uint32_t CSR36;  ///< Offset: 0x188 - context swap registers
        volatile uint32_t CSR37;  ///< Offset: 0x18C - context swap registers
        volatile uint32_t CSR38;  ///< Offset: 0x190 - context swap registers
        volatile uint32_t CSR39;  ///< Offset: 0x194 - context swap registers
        volatile uint32_t CSR40;  ///< Offset: 0x198 - context swap registers
        volatile uint32_t CSR41;  ///< Offset: 0x19C - context swap registers
        volatile uint32_t CSR42;  ///< Offset: 0x1A0 - context swap registers
        volatile uint32_t CSR43;  ///< Offset: 0x1A4 - context swap registers
        volatile uint32_t CSR44;  ///< Offset: 0x1A8 - context swap registers
        volatile uint32_t CSR45;  ///< Offset: 0x1AC - context swap registers
        volatile uint32_t CSR46;  ///< Offset: 0x1B0 - context swap registers
        volatile uint32_t CSR47;  ///< Offset: 0x1B4 - context swap registers
        volatile uint32_t CSR48;  ///< Offset: 0x1B8 - context swap registers
        volatile uint32_t CSR49;  ///< Offset: 0x1BC - context swap registers
        volatile uint32_t CSR50;  ///< Offset: 0x1C0 - context swap registers
        volatile uint32_t CSR51;  ///< Offset: 0x1C4 - context swap registers
        volatile uint32_t CSR52;  ///< Offset: 0x1C8 - context swap registers
        volatile uint32_t CSR53;  ///< Offset: 0x1CC - context swap registers
    };

    /// Peripheral instances
    inline Registers* HASH = reinterpret_cast<Registers*>(HASH_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t INIT = (1U << 2);  ///< Initialize message digest calculation
        constexpr uint32_t DMAE = (1U << 3);  ///< DMA enable
        constexpr uint32_t DATATYPE = (2 << 4);  ///< Data type selection
        constexpr uint32_t MODE = (1U << 6);  ///< Mode selection
        constexpr uint32_t ALGO = (2 << 17);  ///< Algorithm selection
        constexpr uint32_t NBW = (4 << 8);  ///< Number of words already pushed
        constexpr uint32_t DINNE = (1U << 12);  ///< DIN not empty
        constexpr uint32_t MDMAT = (1U << 13);  ///< Multiple DMA Transfers
        constexpr uint32_t LKEY = (1U << 16);  ///< Long key selection
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Data input
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t DCAL = (1U << 8);  ///< Digest calculation
        constexpr uint32_t NBLW = (5 << 0);  ///< Number of valid bits in the last word of the message
    }

    /// HRA0 Register bits
    namespace hra0_bits {
        constexpr uint32_t H0 = (32 << 0);  ///< H0
    }

    /// HRA1 Register bits
    namespace hra1_bits {
        constexpr uint32_t H1 = (32 << 0);  ///< H1
    }

    /// HRA2 Register bits
    namespace hra2_bits {
        constexpr uint32_t H2 = (32 << 0);  ///< H2
    }

    /// HRA3 Register bits
    namespace hra3_bits {
        constexpr uint32_t H3 = (32 << 0);  ///< H3
    }

    /// HRA4 Register bits
    namespace hra4_bits {
        constexpr uint32_t H4 = (32 << 0);  ///< H4
    }

    /// HR0 Register bits
    namespace hr0_bits {
        constexpr uint32_t H0 = (32 << 0);  ///< H0
    }

    /// HR1 Register bits
    namespace hr1_bits {
        constexpr uint32_t H1 = (32 << 0);  ///< H1
    }

    /// HR2 Register bits
    namespace hr2_bits {
        constexpr uint32_t H2 = (32 << 0);  ///< H2
    }

    /// HR3 Register bits
    namespace hr3_bits {
        constexpr uint32_t H3 = (32 << 0);  ///< H3
    }

    /// HR4 Register bits
    namespace hr4_bits {
        constexpr uint32_t H4 = (32 << 0);  ///< H4
    }

    /// HR5 Register bits
    namespace hr5_bits {
        constexpr uint32_t H5 = (32 << 0);  ///< H5
    }

    /// HR6 Register bits
    namespace hr6_bits {
        constexpr uint32_t H6 = (32 << 0);  ///< H6
    }

    /// HR7 Register bits
    namespace hr7_bits {
        constexpr uint32_t H7 = (32 << 0);  ///< H7
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t DCIE = (1U << 1);  ///< Digest calculation completion interrupt enable
        constexpr uint32_t DINIE = (1U << 0);  ///< Data input interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BUSY = (1U << 3);  ///< Busy bit
        constexpr uint32_t DMAS = (1U << 2);  ///< DMA Status
        constexpr uint32_t DCIS = (1U << 1);  ///< Digest calculation completion interrupt status
        constexpr uint32_t DINIS = (1U << 0);  ///< Data input interrupt status
        constexpr uint32_t NBWE = (5 << 16);  ///< Number of words expected
        constexpr uint32_t DINNE = (1U << 15);  ///< DIN not empty
        constexpr uint32_t NBWP = (5 << 9);  ///< Number of words already pushed
    }

    /// CSR0 Register bits
    namespace csr0_bits {
        constexpr uint32_t CSR0 = (32 << 0);  ///< CSR0
    }

    /// CSR1 Register bits
    namespace csr1_bits {
        constexpr uint32_t CSR1 = (32 << 0);  ///< CSR1
    }

    /// CSR2 Register bits
    namespace csr2_bits {
        constexpr uint32_t CSR2 = (32 << 0);  ///< CSR2
    }

    /// CSR3 Register bits
    namespace csr3_bits {
        constexpr uint32_t CSR3 = (32 << 0);  ///< CSR3
    }

    /// CSR4 Register bits
    namespace csr4_bits {
        constexpr uint32_t CSR4 = (32 << 0);  ///< CSR4
    }

    /// CSR5 Register bits
    namespace csr5_bits {
        constexpr uint32_t CSR5 = (32 << 0);  ///< CSR5
    }

    /// CSR6 Register bits
    namespace csr6_bits {
        constexpr uint32_t CSR6 = (32 << 0);  ///< CSR6
    }

    /// CSR7 Register bits
    namespace csr7_bits {
        constexpr uint32_t CSR7 = (32 << 0);  ///< CSR7
    }

    /// CSR8 Register bits
    namespace csr8_bits {
        constexpr uint32_t CSR8 = (32 << 0);  ///< CSR8
    }

    /// CSR9 Register bits
    namespace csr9_bits {
        constexpr uint32_t CSR9 = (32 << 0);  ///< CSR9
    }

    /// CSR10 Register bits
    namespace csr10_bits {
        constexpr uint32_t CSR10 = (32 << 0);  ///< CSR10
    }

    /// CSR11 Register bits
    namespace csr11_bits {
        constexpr uint32_t CSR11 = (32 << 0);  ///< CSR11
    }

    /// CSR12 Register bits
    namespace csr12_bits {
        constexpr uint32_t CSR12 = (32 << 0);  ///< CSR12
    }

    /// CSR13 Register bits
    namespace csr13_bits {
        constexpr uint32_t CSR13 = (32 << 0);  ///< CSR13
    }

    /// CSR14 Register bits
    namespace csr14_bits {
        constexpr uint32_t CSR14 = (32 << 0);  ///< CSR14
    }

    /// CSR15 Register bits
    namespace csr15_bits {
        constexpr uint32_t CSR15 = (32 << 0);  ///< CSR15
    }

    /// CSR16 Register bits
    namespace csr16_bits {
        constexpr uint32_t CSR16 = (32 << 0);  ///< CSR16
    }

    /// CSR17 Register bits
    namespace csr17_bits {
        constexpr uint32_t CSR17 = (32 << 0);  ///< CSR17
    }

    /// CSR18 Register bits
    namespace csr18_bits {
        constexpr uint32_t CSR18 = (32 << 0);  ///< CSR18
    }

    /// CSR19 Register bits
    namespace csr19_bits {
        constexpr uint32_t CSR19 = (32 << 0);  ///< CSR19
    }

    /// CSR20 Register bits
    namespace csr20_bits {
        constexpr uint32_t CSR20 = (32 << 0);  ///< CSR20
    }

    /// CSR21 Register bits
    namespace csr21_bits {
        constexpr uint32_t CSR21 = (32 << 0);  ///< CSR21
    }

    /// CSR22 Register bits
    namespace csr22_bits {
        constexpr uint32_t CSR22 = (32 << 0);  ///< CSR22
    }

    /// CSR23 Register bits
    namespace csr23_bits {
        constexpr uint32_t CSR23 = (32 << 0);  ///< CSR23
    }

    /// CSR24 Register bits
    namespace csr24_bits {
        constexpr uint32_t CSR24 = (32 << 0);  ///< CSR24
    }

    /// CSR25 Register bits
    namespace csr25_bits {
        constexpr uint32_t CSR25 = (32 << 0);  ///< CSR25
    }

    /// CSR26 Register bits
    namespace csr26_bits {
        constexpr uint32_t CSR26 = (32 << 0);  ///< CSR26
    }

    /// CSR27 Register bits
    namespace csr27_bits {
        constexpr uint32_t CSR27 = (32 << 0);  ///< CSR27
    }

    /// CSR28 Register bits
    namespace csr28_bits {
        constexpr uint32_t CSR28 = (32 << 0);  ///< CSR28
    }

    /// CSR29 Register bits
    namespace csr29_bits {
        constexpr uint32_t CSR29 = (32 << 0);  ///< CSR29
    }

    /// CSR30 Register bits
    namespace csr30_bits {
        constexpr uint32_t CSR30 = (32 << 0);  ///< CSR30
    }

    /// CSR31 Register bits
    namespace csr31_bits {
        constexpr uint32_t CSR31 = (32 << 0);  ///< CSR31
    }

    /// CSR32 Register bits
    namespace csr32_bits {
        constexpr uint32_t CSR32 = (32 << 0);  ///< CSR32
    }

    /// CSR33 Register bits
    namespace csr33_bits {
        constexpr uint32_t CSR33 = (32 << 0);  ///< CSR33
    }

    /// CSR34 Register bits
    namespace csr34_bits {
        constexpr uint32_t CSR34 = (32 << 0);  ///< CSR34
    }

    /// CSR35 Register bits
    namespace csr35_bits {
        constexpr uint32_t CSR35 = (32 << 0);  ///< CSR35
    }

    /// CSR36 Register bits
    namespace csr36_bits {
        constexpr uint32_t CSR36 = (32 << 0);  ///< CSR36
    }

    /// CSR37 Register bits
    namespace csr37_bits {
        constexpr uint32_t CSR37 = (32 << 0);  ///< CSR37
    }

    /// CSR38 Register bits
    namespace csr38_bits {
        constexpr uint32_t CSR38 = (32 << 0);  ///< CSR38
    }

    /// CSR39 Register bits
    namespace csr39_bits {
        constexpr uint32_t CSR39 = (32 << 0);  ///< CSR39
    }

    /// CSR40 Register bits
    namespace csr40_bits {
        constexpr uint32_t CSR40 = (32 << 0);  ///< CSR40
    }

    /// CSR41 Register bits
    namespace csr41_bits {
        constexpr uint32_t CSR41 = (32 << 0);  ///< CSR41
    }

    /// CSR42 Register bits
    namespace csr42_bits {
        constexpr uint32_t CSR42 = (32 << 0);  ///< CSR42
    }

    /// CSR43 Register bits
    namespace csr43_bits {
        constexpr uint32_t CSR43 = (32 << 0);  ///< CSR43
    }

    /// CSR44 Register bits
    namespace csr44_bits {
        constexpr uint32_t CSR44 = (32 << 0);  ///< CSR44
    }

    /// CSR45 Register bits
    namespace csr45_bits {
        constexpr uint32_t CSR45 = (32 << 0);  ///< CSR45
    }

    /// CSR46 Register bits
    namespace csr46_bits {
        constexpr uint32_t CSR46 = (32 << 0);  ///< CSR46
    }

    /// CSR47 Register bits
    namespace csr47_bits {
        constexpr uint32_t CSR47 = (32 << 0);  ///< CSR47
    }

    /// CSR48 Register bits
    namespace csr48_bits {
        constexpr uint32_t CSR48 = (32 << 0);  ///< CSR48
    }

    /// CSR49 Register bits
    namespace csr49_bits {
        constexpr uint32_t CSR49 = (32 << 0);  ///< CSR49
    }

    /// CSR50 Register bits
    namespace csr50_bits {
        constexpr uint32_t CSR50 = (32 << 0);  ///< CSR50
    }

    /// CSR51 Register bits
    namespace csr51_bits {
        constexpr uint32_t CSR51 = (32 << 0);  ///< CSR51
    }

    /// CSR52 Register bits
    namespace csr52_bits {
        constexpr uint32_t CSR52 = (32 << 0);  ///< CSR52
    }

    /// CSR53 Register bits
    namespace csr53_bits {
        constexpr uint32_t CSR53 = (32 << 0);  ///< CSR53
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x46007C00;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t TAMP_CR1;  ///< Offset: 0x00 - TAMP control register 1
        volatile uint32_t TAMP_CR2;  ///< Offset: 0x04 - TAMP control register 2
        volatile uint32_t TAMP_CR3;  ///< Offset: 0x08 - TAMP control register 3
        volatile uint32_t TAMP_FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t TAMP_ATCR1;  ///< Offset: 0x10 - TAMP active tamper control register 1
        volatile uint32_t TAMP_ATSEEDR;  ///< Offset: 0x14 - TAMP active tamper seed register
        volatile uint32_t TAMP_ATOR;  ///< Offset: 0x18 - TAMP active tamper output register
        volatile uint32_t TAMP_ATCR2;  ///< Offset: 0x1C - TAMP active tamper control register 2
        volatile uint32_t TAMP_SECCFGR;  ///< Offset: 0x20 - TAMP secure mode register
        volatile uint32_t TAMP_PRIVCR;  ///< Offset: 0x24 - TAMP privilege mode control register
        volatile uint32_t TAMP_IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t TAMP_SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t TAMP_MISR;  ///< Offset: 0x34 - TAMP non-secure masked interrupt status register
        volatile uint32_t TAMP_SMISR;  ///< Offset: 0x38 - TAMP secure masked interrupt status register
        volatile uint32_t TAMP_SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t TAMP_COUNT1R;  ///< Offset: 0x40 - TAMP monotonic counter 1 register
        volatile uint32_t TAMP_ERCFGR;  ///< Offset: 0x54 - TAMP erase configuration register
        volatile uint32_t TAMP_BKP0R;  ///< Offset: 0x100 - TAMP backup 0 register
        volatile uint32_t TAMP_BKP1R;  ///< Offset: 0x104 - TAMP backup 1 register
        volatile uint32_t TAMP_BKP2R;  ///< Offset: 0x108 - TAMP backup 2 register
        volatile uint32_t TAMP_BKP3R;  ///< Offset: 0x10C - TAMP backup 3 register
        volatile uint32_t TAMP_BKP4R;  ///< Offset: 0x110 - TAMP backup 4 register
        volatile uint32_t TAMP_BKP5R;  ///< Offset: 0x114 - TAMP backup 5 register
        volatile uint32_t TAMP_BKP6R;  ///< Offset: 0x118 - TAMP backup 6 register
        volatile uint32_t TAMP_BKP7R;  ///< Offset: 0x11C - TAMP backup 7 register
        volatile uint32_t TAMP_BKP8R;  ///< Offset: 0x120 - TAMP backup 8 register
        volatile uint32_t TAMP_BKP9R;  ///< Offset: 0x124 - TAMP backup 9 register
        volatile uint32_t TAMP_BKP10R;  ///< Offset: 0x128 - TAMP backup 10 register
        volatile uint32_t TAMP_BKP11R;  ///< Offset: 0x12C - TAMP backup 11 register
        volatile uint32_t TAMP_BKP12R;  ///< Offset: 0x130 - TAMP backup 12 register
        volatile uint32_t TAMP_BKP13R;  ///< Offset: 0x134 - TAMP backup 13 register
        volatile uint32_t TAMP_BKP14R;  ///< Offset: 0x138 - TAMP backup 14 register
        volatile uint32_t TAMP_BKP15R;  ///< Offset: 0x13C - TAMP backup 15 register
        volatile uint32_t TAMP_BKP16R;  ///< Offset: 0x140 - TAMP backup 16 register
        volatile uint32_t TAMP_BKP17R;  ///< Offset: 0x144 - TAMP backup 17 register
        volatile uint32_t TAMP_BKP18R;  ///< Offset: 0x148 - TAMP backup 18 register
        volatile uint32_t TAMP_BKP19R;  ///< Offset: 0x14C - TAMP backup 19 register
        volatile uint32_t TAMP_BKP20R;  ///< Offset: 0x150 - TAMP backup 20 register
        volatile uint32_t TAMP_BKP21R;  ///< Offset: 0x154 - TAMP backup 21 register
        volatile uint32_t TAMP_BKP22R;  ///< Offset: 0x158 - TAMP backup 22 register
        volatile uint32_t TAMP_BKP23R;  ///< Offset: 0x15C - TAMP backup 23 register
        volatile uint32_t TAMP_BKP24R;  ///< Offset: 0x160 - TAMP backup 24 register
        volatile uint32_t TAMP_BKP25R;  ///< Offset: 0x164 - TAMP backup 25 register
        volatile uint32_t TAMP_BKP26R;  ///< Offset: 0x168 - TAMP backup 26 register
        volatile uint32_t TAMP_BKP27R;  ///< Offset: 0x16C - TAMP backup 27 register
        volatile uint32_t TAMP_BKP28R;  ///< Offset: 0x170 - TAMP backup 28 register
        volatile uint32_t TAMP_BKP29R;  ///< Offset: 0x174 - TAMP backup 29 register
        volatile uint32_t TAMP_BKP30R;  ///< Offset: 0x178 - TAMP backup 30 register
        volatile uint32_t TAMP_BKP31R;  ///< Offset: 0x17C - TAMP backup 31 register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// TAMP_CR1 Register bits
    namespace tamp_cr1_bits {
        constexpr uint32_t TAMP1E = (1U << 0);  ///< Tamper detection on TAMP_IN1 enable
        constexpr uint32_t TAMP2E = (1U << 1);  ///< Tamper detection on TAMP_IN2 enable
        constexpr uint32_t TAMP3E = (1U << 2);  ///< Tamper detection on TAMP_IN3 enable
        constexpr uint32_t TAMP4E = (1U << 3);  ///< Tamper detection on TAMP_IN4 enable
        constexpr uint32_t TAMP5E = (1U << 4);  ///< Tamper detection on TAMP_IN5 enable
        constexpr uint32_t TAMP6E = (1U << 5);  ///< Tamper detection on TAMP_IN6 enable
        constexpr uint32_t TAMP7E = (1U << 6);  ///< Tamper detection on TAMP_IN7 enable
        constexpr uint32_t TAMP8E = (1U << 7);  ///< Tamper detection on TAMP_IN8 enable
        constexpr uint32_t ITAMP1E = (1U << 16);  ///< Internal tamper 1 enable
        constexpr uint32_t ITAMP2E = (1U << 17);  ///< Internal tamper 2 enable
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< Internal tamper 3 enable
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< Internal tamper 5 enable
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< Internal tamper 6 enable
        constexpr uint32_t ITAMP7E = (1U << 22);  ///< Internal tamper 7 enable
        constexpr uint32_t ITAMP8E = (1U << 23);  ///< Internal tamper 8 enable
        constexpr uint32_t ITAMP9E = (1U << 24);  ///< Internal tamper 9 enable
        constexpr uint32_t ITAMP11E = (1U << 26);  ///< Internal tamper 11 enable
        constexpr uint32_t ITAMP12E = (1U << 27);  ///< Internal tamper 12 enable
        constexpr uint32_t ITAMP13E = (1U << 28);  ///< Internal tamper 13 enable
    }

    /// TAMP_CR2 Register bits
    namespace tamp_cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< Tamper 1 no erase
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< Tamper 2 no erase
        constexpr uint32_t TAMP3NOER = (1U << 2);  ///< Tamper 3 no erase
        constexpr uint32_t TAMP4NOER = (1U << 3);  ///< Tamper 4 no erase
        constexpr uint32_t TAMP5NOER = (1U << 4);  ///< Tamper 5 no erase
        constexpr uint32_t TAMP6NOER = (1U << 5);  ///< Tamper 6 no erase
        constexpr uint32_t TAMP7NOER = (1U << 6);  ///< Tamper 7 no erase
        constexpr uint32_t TAMP8NOER = (1U << 7);  ///< Tamper 8 no erase
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< Tamper 1 mask The tamper 1 interrupt must not be enabled when TAMP1MSK is set.
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< Tamper 2 mask The tamper 2 interrupt must not be enabled when TAMP2MSK is set.
        constexpr uint32_t TAMP3MSK = (1U << 18);  ///< Tamper 3 mask The tamper 3 interrupt must not be enabled when TAMP3MSK is set.
        constexpr uint32_t BKBLOCK = (1U << 22);  ///< Backup registers and device secrets access blocked
        constexpr uint32_t BKERASE = (1U << 23);  ///< Backup registers and device secrets erase Writing '1 to this bit reset the backup registers and device secrets(1). Writing 0 has no effect. This bit is always read as 0.
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< Active level for tamper 1 input If TAMPFLT=00 Tamper 1 input rising edge and high level triggers a tamper detection event. If TAMPFLT=00 Tamper 1 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< Active level for tamper 2 input If TAMPFLT = 00 Tamper 2 input rising edge and high level triggers a tamper detection event. If TAMPFLT=00 Tamper 2 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP3TRG = (1U << 26);  ///< Active level for tamper 3 input If TAMPFLT=00 Tamper 3 input rising edge and high level triggers a tamper detection event. If TAMPFLT=00 Tamper 3 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP4TRG = (1U << 27);  ///< Active level for tamper 4 input (active mode disabled) If TAMPFLT=00 Tamper 4 input rising edge and high level triggers a tamper detection event. If TAMPFLT=00 Tamper 4 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP5TRG = (1U << 28);  ///< Active level for tamper 5 input (active mode disabled) If TAMPFLT=00 Tamper 5 input rising edge and high level triggers a tamper detection event. If TAMPFLT=00 Tamper 5 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP6TRG = (1U << 29);  ///< Active level for tamper 6 input (active mode disabled) If TAMPFLT=00 Tamper 6 input rising edge and high level triggers a tamper detection event. If TAMPFLT=00 Tamper 6 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP7TRG = (1U << 30);  ///< Active level for tamper 7 input (active mode disabled) If TAMPFLT=00 Tamper 7 input rising edge and high level triggers a tamper detection event. If TAMPFLT=00 Tamper 7 input falling edge and low level triggers a tamper detection event.
        constexpr uint32_t TAMP8TRG = (1U << 31);  ///< Active level for tamper 8 input (active mode disabled) If TAMPFLT=00 Tamper 8 input rising edge and high level triggers a tamper detection event. If TAMPFLT =00 Tamper 8 input falling edge and low level triggers a tamper detection event.
    }

    /// TAMP_CR3 Register bits
    namespace tamp_cr3_bits {
        constexpr uint32_t ITAMP1NOER = (1U << 0);  ///< Internal Tamper 1 no erase
        constexpr uint32_t ITAMP2NOER = (1U << 1);  ///< Internal Tamper 2 no erase
        constexpr uint32_t ITAMP3NOER = (1U << 2);  ///< Internal Tamper 3 no erase
        constexpr uint32_t ITAMP5NOER = (1U << 4);  ///< Internal Tamper 5 no erase
        constexpr uint32_t ITAMP6NOER = (1U << 5);  ///< Internal Tamper 6 no erase
        constexpr uint32_t ITAMP7NOER = (1U << 6);  ///< Internal Tamper 7 no erase
        constexpr uint32_t ITAMP8NOER = (1U << 7);  ///< Internal Tamper 8 no erase
        constexpr uint32_t ITAMP9NOER = (1U << 8);  ///< Internal Tamper 9 no erase
        constexpr uint32_t ITAMP11NOER = (1U << 10);  ///< Internal Tamper 11 no erase
        constexpr uint32_t ITAMP12NOER = (1U << 11);  ///< Internal Tamper 12 no erase
        constexpr uint32_t ITAMP13NOER = (1U << 12);  ///< Internal Tamper 13 no erase
    }

    /// TAMP_FLTCR Register bits
    namespace tamp_fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< Tamper sampling frequency Determines the frequency at which each of the TAMP_INx inputs are sampled.
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMP_INx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMP_INx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMP_INx pull-up disable This bit determines if each of the TAMPx pins are precharged before each sample.
    }

    /// TAMP_ATCR1 Register bits
    namespace tamp_atcr1_bits {
        constexpr uint32_t TAMP1AM = (1U << 0);  ///< Tamper 1 active mode
        constexpr uint32_t TAMP2AM = (1U << 1);  ///< Tamper 2 active mode
        constexpr uint32_t TAMP3AM = (1U << 2);  ///< Tamper 3 active mode
        constexpr uint32_t TAMP4AM = (1U << 3);  ///< Tamper 4 active mode
        constexpr uint32_t TAMP5AM = (1U << 4);  ///< Tamper 5 active mode
        constexpr uint32_t TAMP6AM = (1U << 5);  ///< Tamper 6 active mode
        constexpr uint32_t TAMP7AM = (1U << 6);  ///< Tamper 7 active mode
        constexpr uint32_t TAMP8AM = (1U << 7);  ///< Tamper 8 active mode
        constexpr uint32_t ATOSEL1 = (2 << 8);  ///< Active tamper shared output 1 selection The selected output must be available in the package pinout
        constexpr uint32_t ATOSEL2 = (2 << 10);  ///< Active tamper shared output 2 selection The selected output must be available in the package pinout
        constexpr uint32_t ATOSEL3 = (2 << 12);  ///< Active tamper shared output 3 selection The selected output must be available in the package pinout
        constexpr uint32_t ATOSEL4 = (2 << 14);  ///< Active tamper shared output 4 selection The selected output must be available in the package pinout.
        constexpr uint32_t ATCKSEL = (3 << 16);  ///< Active tamper RTC asynchronous prescaler clock selection These bits selects the RTC asynchronous prescaler stage output.The selected clock is CK_ATPRE. fCK_ATPRE = fRTCCLK / 2ATCKSEL when (PREDIV_A+1) = 128. ... These bits can be written only when all active tampers are disabled. The write protection remains for up to 1.5 ck_atpre cycles after all the active tampers are disable.
        constexpr uint32_t ATPER = (3 << 24);  ///< Active tamper output change period The tamper output is changed every CK_ATPER = (2ATPER x CK_ATPRE) cycles. Refer to .
        constexpr uint32_t ATOSHARE = (1U << 30);  ///< Active tamper output sharing TAMP_IN1 is compared with TAMPOUTSEL1 TAMP_IN2 is compared with TAMPOUTSEL2 TAMP_IN3 is compared with TAMPOUTSEL3 TAMP_IN4 is compared with TAMPOUTSEL4 TAMP_IN5 is compared with TAMPOUTSEL5 TAMP_IN6 is compared with TAMPOUTSEL6 TAMP_IN7 is compared with TAMPOUTSEL7 TAMP_IN8 is compared with TAMPOUTSEL8
        constexpr uint32_t FLTEN = (1U << 31);  ///< Active tamper filter enable
    }

    /// TAMP_ATSEEDR Register bits
    namespace tamp_atseedr_bits {
        constexpr uint32_t SEED = (32 << 0);  ///< Pseudo-random generator seed value This register must be written four times with 32-bit values to provide the 128-bit seed to the PRNG. Writing to this register automatically sends the seed value to the PRNG.
    }

    /// TAMP_ATOR Register bits
    namespace tamp_ator_bits {
        constexpr uint32_t PRNG = (8 << 0);  ///< Pseudo-random generator value This field provides the values of the PRNG output. Because of potential inconsistencies due to synchronization delays, PRNG must be read at least twice. The read value is correct if it is equal to previous read value. This field can only be read when the APB is in secure mode.
        constexpr uint32_t SEEDF = (1U << 14);  ///< Seed running flag This flag is set by hardware when a new seed is written in the TAMP_ATSEEDR. It is cleared by hardware when the PRNG has absorbed this new seed, and by system reset. The TAMP APB cock must not be switched off as long as SEEDF is set.
        constexpr uint32_t INITS = (1U << 15);  ///< Active tamper initialization status This flag is set by hardware when the PRNG has absorbed the first 128-bit seed, meaning that the enabled active tampers are functional. This flag is cleared when the active tampers are disabled.
    }

    /// TAMP_ATCR2 Register bits
    namespace tamp_atcr2_bits {
        constexpr uint32_t ATOSEL1 = (3 << 8);  ///< Active tamper shared output 1 selection The selected output must be available in the package pinout. Bits 9:8 are the mirror of ATOSEL1[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1.
        constexpr uint32_t ATOSEL2 = (3 << 11);  ///< Active tamper shared output 2 selection The selected output must be available in the package pinout. Bits 12:11 are the mirror of ATOSEL2[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1.
        constexpr uint32_t ATOSEL3 = (3 << 14);  ///< Active tamper shared output 3 selection The selected output must be available in the package pinout. Bits 15:14 are the mirror of ATOSEL3[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1.
        constexpr uint32_t ATOSEL4 = (3 << 17);  ///< Active tamper shared output 4 selection The selected output must be available in the package pinout. Bits 18:17 are the mirror of ATOSEL2[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1.
        constexpr uint32_t ATOSEL5 = (3 << 20);  ///< Active tamper shared output 5 selection The selected output must be available in the package pinout.
        constexpr uint32_t ATOSEL6 = (3 << 23);  ///< Active tamper shared output 6 selection The selected output must be available in the package pinout.
        constexpr uint32_t ATOSEL7 = (3 << 26);  ///< Active tamper shared output 7 selection The selected output must be available in the package pinout.
        constexpr uint32_t ATOSEL8 = (3 << 29);  ///< Active tamper shared output 8 selection The selected output must be available in the package pinout.
    }

    /// TAMP_SECCFGR Register bits
    namespace tamp_seccfgr_bits {
        constexpr uint32_t BKPRWSEC = (8 << 0);  ///< Backup registers read/write protection offset Protection zone 1 is defined for backup registers from TAMP_BKP0R to TAMP_BKPxR (x = BKPRWSEC-1, from 0 to 128). if TZEN=1, these backup registers can be read and written only with secure access. If TZEN=0:	the protection zone 1 can be read and written with non-secure access. If BKPRWSEC = 0: there is no protection zone 1. If BKPRWPRIV is set, BKPRWSEC[7:0] can be written only in privileged mode.
        constexpr uint32_t CNT1SEC = (1U << 15);  ///< Monotonic counter 1 secure protection
        constexpr uint32_t BKPWSEC = (8 << 16);  ///< Backup registers write protection offset Protection zone 2 is defined for backup registers from TAMP_BKPyR (y = BKPRWSEC, from 0 to 128) to TAMP_BKPzR (z = BKPWSEC-1, from 0 to 128, BKPWSECBKPRWSEC): if TZEN=1, these backup registers can be written only with secure access. They can be read with secure or non-secure access. Protection zone 3 defined for backup registers from TAMP_BKPtR (t = BKPWSEC, from 0 to 127). They can be read or written with secure or non-secure access. If TZEN=0:	the protection zone 2 can be read and written with non-secure access. If BKPWSEC = 0 or if BKPWSECBKPRWSEC: there is no protection zone 2. If BKPWPRIV is set, BKPRWSEC[7:0] can be written only in privileged mode.
        constexpr uint32_t BHKLOCK = (1U << 30);  ///< Boot hardware key lock This bit can be read and can only be written to 1 by software. It is cleared by hardware together with the backup registers following a tamper detection event or when the readout protection (RDP) is disabled.
        constexpr uint32_t TAMPSEC = (1U << 31);  ///< Tamper protection (excluding monotonic counters and backup registers) Note: Refer to for details on the read protection.
    }

    /// TAMP_PRIVCR Register bits
    namespace tamp_privcr_bits {
        constexpr uint32_t CNT1PRIV = (1U << 15);  ///< Monotonic counter 1 privilege protection
        constexpr uint32_t BKPRWPRIV = (1U << 29);  ///< Backup registers zone 1 privilege protection
        constexpr uint32_t BKPWPRIV = (1U << 30);  ///< Backup registers zone 2 privilege protection
        constexpr uint32_t TAMPPRIV = (1U << 31);  ///< Tamper privilege protection (excluding backup registers) Note: Refer to for details on the read protection.
    }

    /// TAMP_IER Register bits
    namespace tamp_ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< Tamper 1 interrupt enable
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< Tamper 2 interrupt enable
        constexpr uint32_t TAMP3IE = (1U << 2);  ///< Tamper 3 interrupt enable
        constexpr uint32_t TAMP4IE = (1U << 3);  ///< Tamper 4 interrupt enable
        constexpr uint32_t TAMP5IE = (1U << 4);  ///< Tamper 5 interrupt enable
        constexpr uint32_t TAMP6IE = (1U << 5);  ///< Tamper 6 interrupt enable
        constexpr uint32_t TAMP7IE = (1U << 6);  ///< Tamper 7interrupt enable
        constexpr uint32_t TAMP8IE = (1U << 7);  ///< Tamper 8 interrupt enable
        constexpr uint32_t ITAMP1IE = (1U << 16);  ///< Internal tamper 1 interrupt enable
        constexpr uint32_t ITAMP2IE = (1U << 17);  ///< Internal tamper 2 interrupt enable
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< Internal tamper 3 interrupt enable
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< Internal tamper 5 interrupt enable
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< Internal tamper 6 interrupt enable
        constexpr uint32_t ITAMP7IE = (1U << 22);  ///< Internal tamper 7 interrupt enable
        constexpr uint32_t ITAMP8IE = (1U << 23);  ///< Internal tamper 8 interrupt enable
        constexpr uint32_t ITAMP9IE = (1U << 24);  ///< Internal tamper 9 interrupt enable
        constexpr uint32_t ITAMP11IE = (1U << 26);  ///< Internal tamper 11 interrupt enable
        constexpr uint32_t ITAMP12IE = (1U << 27);  ///< Internal tamper 12 interrupt enable
        constexpr uint32_t ITAMP13IE = (1U << 28);  ///< Internal tamper 13 interrupt enable
    }

    /// TAMP_SR Register bits
    namespace tamp_sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP1 input.
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP2 input.
        constexpr uint32_t TAMP3F = (1U << 2);  ///< TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP3 input.
        constexpr uint32_t TAMP4F = (1U << 3);  ///< TAMP4 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP4 input.
        constexpr uint32_t TAMP5F = (1U << 4);  ///< TAMP5 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP5 input.
        constexpr uint32_t TAMP6F = (1U << 5);  ///< TAMP6 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP6 input.
        constexpr uint32_t TAMP7F = (1U << 6);  ///< TAMP7 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP7 input.
        constexpr uint32_t TAMP8F = (1U << 7);  ///< TAMP8 detection flag This flag is set by hardware when a tamper detection event is detected on the TAMP8 input
        constexpr uint32_t ITAMP1F = (1U << 16);  ///< Internal tamper 1 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 1.
        constexpr uint32_t ITAMP2F = (1U << 17);  ///< Internal tamper 2 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 2.
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< Internal tamper 3 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 3.
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< Internal tamper 5 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 5.
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< Internal tamper 6 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 6.
        constexpr uint32_t ITAMP7F = (1U << 22);  ///< Internal tamper 7 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 7.
        constexpr uint32_t ITAMP8F = (1U << 23);  ///< Internal tamper 8 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 8.
        constexpr uint32_t ITAMP9F = (1U << 24);  ///< Internal tamper 9 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 9.
        constexpr uint32_t ITAMP11F = (1U << 26);  ///< Internal tamper 11 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 11.
        constexpr uint32_t ITAMP12F = (1U << 27);  ///< Internal tamper 12 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 12.
        constexpr uint32_t ITAMP13F = (1U << 28);  ///< Internal tamper 13 flag This flag is set by hardware when a tamper detection event is detected on the internal tamper 13.
    }

    /// TAMP_MISR Register bits
    namespace tamp_misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1 non-secure interrupt masked flag This flag is set by hardware when the tamper 1 non-secure interrupt is raised.
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2 non-secure interrupt masked flag This flag is set by hardware when the tamper 2 non-secure interrupt is raised.
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3 non-secure interrupt masked flag This flag is set by hardware when the tamper 3 non-secure interrupt is raised.
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4 non-secure interrupt masked flag This flag is set by hardware when the tamper 4 non-secure interrupt is raised.
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5 non-secure interrupt masked flag This flag is set by hardware when the tamper 5 non-secure interrupt is raised.
        constexpr uint32_t TAMP6MF = (1U << 5);  ///< TAMP6 non-secure interrupt masked flag This flag is set by hardware when the tamper 6 non-secure interrupt is raised.
        constexpr uint32_t TAMP7MF = (1U << 6);  ///< TAMP7 non-secure interrupt masked flag This flag is set by hardware when the tamper 7 non-secure interrupt is raised.
        constexpr uint32_t TAMP8MF = (1U << 7);  ///< TAMP8 non-secure interrupt masked flag This flag is set by hardware when the tamper 8 non-secure interrupt is raised.
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< Internal tamper 1 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 1 non-secure interrupt is raised.
        constexpr uint32_t ITAMP2MF = (1U << 17);  ///< Internal tamper 2 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 2 non-secure interrupt is raised.
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< Internal tamper 3 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 3 non-secure interrupt is raised.
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< Internal tamper 5 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 5 non-secure interrupt is raised.
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< Internal tamper 6 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 6 non-secure interrupt is raised.
        constexpr uint32_t ITAMP7MF = (1U << 22);  ///< VCORE monitoring tamper non-secure interrupt masked flag This flag is set by hardware when the internal tamper 7 non-secure interrupt is raised.
        constexpr uint32_t ITAMP8MF = (1U << 23);  ///< Internal tamper 8 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 8 non-secure interrupt is raised.
        constexpr uint32_t ITAMP9MF = (1U << 24);  ///< internal tamper 9 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 9 non-secure interrupt is raised.
        constexpr uint32_t ITAMP11MF = (1U << 26);  ///< internal tamper 11 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 11 non-secure interrupt is raised.
        constexpr uint32_t ITAMP12MF = (1U << 27);  ///< internal tamper 12 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 12 non-secure interrupt is raised.
        constexpr uint32_t ITAMP13MF = (1U << 28);  ///< internal tamper 13 non-secure interrupt masked flag This flag is set by hardware when the internal tamper 13 non-secure interrupt is raised.
    }

    /// TAMP_SMISR Register bits
    namespace tamp_smisr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1 secure interrupt masked flag This flag is set by hardware when the tamper 1 secure interrupt is raised.
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2 secure interrupt masked flag This flag is set by hardware when the tamper 2 secure interrupt is raised.
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3 secure interrupt masked flag This flag is set by hardware when the tamper 3 secure interrupt is raised.
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4 secure interrupt masked flag This flag is set by hardware when the tamper 4 secure interrupt is raised.
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5 secure interrupt masked flag This flag is set by hardware when the tamper 5 secure interrupt is raised.
        constexpr uint32_t TAMP6MF = (1U << 5);  ///< TAMP6 secure interrupt masked flag This flag is set by hardware when the tamper 6 secure interrupt is raised.
        constexpr uint32_t TAMP7MF = (1U << 6);  ///< TAMP7 secure interrupt masked flag This flag is set by hardware when the tamper 7 secure interrupt is raised.
        constexpr uint32_t TAMP8MF = (1U << 7);  ///< TAMP8 secure interrupt masked flag This flag is set by hardware when the tamper 8 secure interrupt is raised.
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< Internal tamper 1 secure interrupt masked flag This flag is set by hardware when the internal tamper 1 secure interrupt is raised.
        constexpr uint32_t ITAMP2MF = (1U << 17);  ///< Internal tamper 2 secure interrupt masked flag This flag is set by hardware when the internal tamper 2 secure interrupt is raised.
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< Internal tamper 3 secure interrupt masked flag This flag is set by hardware when the internal tamper 3 secure interrupt is raised.
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< Internal tamper 5 secure interrupt masked flag This flag is set by hardware when the internal tamper 5 secure interrupt is raised.
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< Internal tamper 6 secure interrupt masked flag This flag is set by hardware when the internal tamper 6 secure interrupt is raised.
        constexpr uint32_t ITAMP7MF = (1U << 22);  ///< VCORE monitoring tamper secure interrupt masked flag This flag is set by hardware when the internal tamper 7 secure interrupt is raised.
        constexpr uint32_t ITAMP8MF = (1U << 23);  ///< Internal tamper 8 secure interrupt masked flag This flag is set by hardware when the internal tamper 8 secure interrupt is raised.
        constexpr uint32_t ITAMP9MF = (1U << 24);  ///< internal tamper 9 secure interrupt masked flag This flag is set by hardware when the internal tamper 9 secure interrupt is raised.
        constexpr uint32_t ITAMP11MF = (1U << 26);  ///< internal tamper 11 secure interrupt masked flag This flag is set by hardware when the internal tamper 11 secure interrupt is raised.
        constexpr uint32_t ITAMP12MF = (1U << 27);  ///< internal tamper 12 secure interrupt masked flag This flag is set by hardware when the internal tamper 12 secure interrupt is raised.
        constexpr uint32_t ITAMP13MF = (1U << 28);  ///< internal tamper 13 secure interrupt masked flag This flag is set by hardware when the internal tamper 13 secure interrupt is raised.
    }

    /// TAMP_SCR Register bits
    namespace tamp_scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< Clear TAMP1 detection flag Writing 1 in this bit clears the TAMP1F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< Clear TAMP2 detection flag Writing 1 in this bit clears the TAMP2F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP3F = (1U << 2);  ///< Clear TAMP3 detection flag Writing 1 in this bit clears the TAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP4F = (1U << 3);  ///< Clear TAMP4 detection flag Writing 1 in this bit clears the TAMP4F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP5F = (1U << 4);  ///< Clear TAMP5 detection flag Writing 1 in this bit clears the TAMP5F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP6F = (1U << 5);  ///< Clear TAMP6 detection flag Writing 1 in this bit clears the TAMP6F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP7F = (1U << 6);  ///< Clear TAMP7 detection flag Writing 1 in this bit clears the TAMP7F bit in the TAMP_SR register.
        constexpr uint32_t CTAMP8F = (1U << 7);  ///< Clear TAMP8 detection flag Writing 1 in this bit clears the TAMP8F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP1F = (1U << 16);  ///< Clear ITAMP1 detection flag Writing 1 in this bit clears the ITAMP1F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP2F = (1U << 17);  ///< Clear ITAMP2 detection flag Writing 1 in this bit clears the ITAMP2F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< Clear ITAMP3 detection flag Writing 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< Clear ITAMP5 detection flag Writing 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP6F = (1U << 21);  ///< Clear ITAMP6 detection flag Writing 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP7F = (1U << 22);  ///< Clear ITAMP7 detection flag Writing 1 in this bit clears the ITAMP7F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP8F = (1U << 23);  ///< Clear ITAMP8 detection flag Writing 1 in this bit clears the ITAMP8F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP9F = (1U << 24);  ///< Clear ITAMP9 detection flag Writing 1 in this bit clears the ITAMP9F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP11F = (1U << 26);  ///< Clear ITAMP11 detection flag Writing 1 in this bit clears the ITAMP11F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP12F = (1U << 27);  ///< Clear ITAMP12 detection flag Writing 1 in this bit clears the ITAMP12F bit in the TAMP_SR register.
        constexpr uint32_t CITAMP13F = (1U << 28);  ///< Clear ITAMP13 detection flag Writing 1 in this bit clears the ITAMP13F bit in the TAMP_SR register.
    }

    /// TAMP_COUNT1R Register bits
    namespace tamp_count1r_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< This register is read-only only and is incremented by one when a write access is done to this register. This register cannot roll-over and is frozen when reaching the maximum value.
    }

    /// TAMP_ERCFGR Register bits
    namespace tamp_ercfgr_bits {
        constexpr uint32_t ERCFG0 = (1U << 0);  ///< Configurable device secrets configuration
    }

    /// TAMP_BKP0R Register bits
    namespace tamp_bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP1R Register bits
    namespace tamp_bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP2R Register bits
    namespace tamp_bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP3R Register bits
    namespace tamp_bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP4R Register bits
    namespace tamp_bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP5R Register bits
    namespace tamp_bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP6R Register bits
    namespace tamp_bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP7R Register bits
    namespace tamp_bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP8R Register bits
    namespace tamp_bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP9R Register bits
    namespace tamp_bkp9r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP10R Register bits
    namespace tamp_bkp10r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP11R Register bits
    namespace tamp_bkp11r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP12R Register bits
    namespace tamp_bkp12r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP13R Register bits
    namespace tamp_bkp13r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP14R Register bits
    namespace tamp_bkp14r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP15R Register bits
    namespace tamp_bkp15r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP16R Register bits
    namespace tamp_bkp16r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP17R Register bits
    namespace tamp_bkp17r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP18R Register bits
    namespace tamp_bkp18r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP19R Register bits
    namespace tamp_bkp19r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP20R Register bits
    namespace tamp_bkp20r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP21R Register bits
    namespace tamp_bkp21r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP22R Register bits
    namespace tamp_bkp22r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP23R Register bits
    namespace tamp_bkp23r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP24R Register bits
    namespace tamp_bkp24r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP25R Register bits
    namespace tamp_bkp25r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP26R Register bits
    namespace tamp_bkp26r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP27R Register bits
    namespace tamp_bkp27r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP28R Register bits
    namespace tamp_bkp28r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP29R Register bits
    namespace tamp_bkp29r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP30R Register bits
    namespace tamp_bkp30r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

    /// TAMP_BKP31R Register bits
    namespace tamp_bkp31r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< The application can write or read data to and from these registers. In the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.
    }

}

// ============================================================================
// MDF1 Peripheral
// ============================================================================

namespace mdf1 {
    /// Base addresses
    constexpr uint32_t MDF1_BASE = 0x40025000;

    /// MDF1 Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - MDF global control register
        volatile uint32_t CKGCR;  ///< Offset: 0x04 - MDF clock generator control register
        volatile uint32_t MDF_SITF0CR;  ///< Offset: 0x80 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF1CR;  ///< Offset: 0x100 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF2CR;  ///< Offset: 0x180 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF3CR;  ///< Offset: 0x200 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF4CR;  ///< Offset: 0x280 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF5CR;  ///< Offset: 0x300 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_BSMX0CR;  ///< Offset: 0x84 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX1CR;  ///< Offset: 0x104 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX2CR;  ///< Offset: 0x184 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX3CR;  ///< Offset: 0x204 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX4CR;  ///< Offset: 0x284 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX5CR;  ///< Offset: 0x304 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_DFLT0CR;  ///< Offset: 0x88 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT1CR;  ///< Offset: 0x108 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT2CR;  ///< Offset: 0x188 - This register is used to control the digital filter 2.
        volatile uint32_t MDF_DFLT3CR;  ///< Offset: 0x208 - This register is used to control the digital filter 3.
        volatile uint32_t MDF_DFLT4CR;  ///< Offset: 0x288 - This register is used to control the digital filter 4.
        volatile uint32_t MDF_DFLT5CR;  ///< Offset: 0x308 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT0CICR;  ///< Offset: 0x8C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT1CICR;  ///< Offset: 0x10C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT2CICR;  ///< Offset: 0x18C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT3CICR;  ///< Offset: 0x20C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT4CICR;  ///< Offset: 0x28C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT5CICR;  ///< Offset: 0x30C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT0RSFR;  ///< Offset: 0x90 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT1RSFR;  ///< Offset: 0x110 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT2RSFR;  ///< Offset: 0x190 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT3RSFR;  ///< Offset: 0x210 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT4RSFR;  ///< Offset: 0x290 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT5RSFR;  ///< Offset: 0x310 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT0INTR;  ///< Offset: 0x94 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT1INTR;  ///< Offset: 0x114 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT2INTR;  ///< Offset: 0x194 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT3INTR;  ///< Offset: 0x214 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT4INTR;  ///< Offset: 0x294 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT5INTR;  ///< Offset: 0x314 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_OLD0CR;  ///< Offset: 0x98 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD1CR;  ///< Offset: 0x118 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD2CR;  ///< Offset: 0x198 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD3CR;  ///< Offset: 0x218 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD4CR;  ///< Offset: 0x298 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD5CR;  ///< Offset: 0x318 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD0THLR;  ///< Offset: 0x9C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD1THLR;  ///< Offset: 0x11C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD2THLR;  ///< Offset: 0x19C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD3THLR;  ///< Offset: 0x21C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD4THLR;  ///< Offset: 0x29C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD5THLR;  ///< Offset: 0x31C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD0THHR;  ///< Offset: 0xA0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD1THHR;  ///< Offset: 0x120 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD2THHR;  ///< Offset: 0x1A0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD3THHR;  ///< Offset: 0x220 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD4THHR;  ///< Offset: 0x2A0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD5THHR;  ///< Offset: 0x320 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_DLY0CR;  ///< Offset: 0xA4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY1CR;  ///< Offset: 0x124 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY2CR;  ///< Offset: 0x1A4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY3CR;  ///< Offset: 0x224 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY4CR;  ///< Offset: 0x2A4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY5CR;  ///< Offset: 0x324 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD0CR;  ///< Offset: 0xA8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD1CR;  ///< Offset: 0x128 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD2CR;  ///< Offset: 0x1A8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD3CR;  ///< Offset: 0x228 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD4CR;  ///< Offset: 0x2A8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD5CR;  ///< Offset: 0x328 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DFLT0IER;  ///< Offset: 0xAC - This register is used for allowing or not the events to...
        volatile uint32_t MDF_DFLT0ISR;  ///< Offset: 0xB0 - MDF DFLT0 interrupt status register 0
        volatile uint32_t MDF_DFLT1IER;  ///< Offset: 0x12C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT2IER;  ///< Offset: 0x1AC - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT3IER;  ///< Offset: 0x22C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT4IER;  ///< Offset: 0x2AC - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT5IER;  ///< Offset: 0x32C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT1ISR;  ///< Offset: 0x130 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT2ISR;  ///< Offset: 0x1B0 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT3ISR;  ///< Offset: 0x230 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT4ISR;  ///< Offset: 0x2B0 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT5ISR;  ///< Offset: 0x330 - This register contains the status flags for each digital...
        volatile uint32_t MDF_OEC0CR;  ///< Offset: 0xB4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC1CR;  ///< Offset: 0x134 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC2CR;  ///< Offset: 0x1B4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC3CR;  ///< Offset: 0x234 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC4CR;  ///< Offset: 0x2B4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC5CR;  ///< Offset: 0x334 - This register contains the offset compensation value.
        volatile uint32_t MDF_SNPS0DR;  ///< Offset: 0xEC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS1DR;  ///< Offset: 0x16C - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS2DR;  ///< Offset: 0x1EC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS3DR;  ///< Offset: 0x26C - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS4DR;  ///< Offset: 0x2EC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS5DR;  ///< Offset: 0x36C - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT0DR;  ///< Offset: 0xF0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT1DR;  ///< Offset: 0x170 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT2DR;  ///< Offset: 0x1F0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT3DR;  ///< Offset: 0x270 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT4DR;  ///< Offset: 0x2F0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT5DR;  ///< Offset: 0x370 - This register is used to read the data processed by each...
    };

    /// Peripheral instances
    inline Registers* MDF1 = reinterpret_cast<Registers*>(MDF1_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t TRGO = (1U << 0);  ///< TRGO
        constexpr uint32_t ILVNB = (4 << 4);  ///< ILVNB
    }

    /// CKGCR Register bits
    namespace ckgcr_bits {
        constexpr uint32_t CKGDEN = (1U << 0);  ///< CKGDEN
        constexpr uint32_t CCK0EN = (1U << 1);  ///< CCK0EN
        constexpr uint32_t CCK1EN = (1U << 2);  ///< CCK1EN
        constexpr uint32_t CKGMOD = (1U << 4);  ///< CKGMOD
        constexpr uint32_t CCK0DIR = (1U << 5);  ///< CCK0DIR
        constexpr uint32_t CCK1DIR = (1U << 6);  ///< CCK1DIR
        constexpr uint32_t TRGSENS = (1U << 8);  ///< TRGSENS
        constexpr uint32_t TRGSRC = (4 << 12);  ///< TRGSRC
        constexpr uint32_t CCKDIV = (4 << 16);  ///< CCKDIV
        constexpr uint32_t PROCDIV = (7 << 24);  ///< PROCDIV
        constexpr uint32_t CKGACTIVE = (1U << 31);  ///< CKGACTIVE
    }

    /// MDF_SITF0CR Register bits
    namespace mdf_sitf0cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF1CR Register bits
    namespace mdf_sitf1cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag
    }

    /// MDF_SITF2CR Register bits
    namespace mdf_sitf2cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag
    }

    /// MDF_SITF3CR Register bits
    namespace mdf_sitf3cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF4CR Register bits
    namespace mdf_sitf4cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF5CR Register bits
    namespace mdf_sitf5cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX0CR Register bits
    namespace mdf_bsmx0cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX1CR Register bits
    namespace mdf_bsmx1cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX2CR Register bits
    namespace mdf_bsmx2cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to a . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX3CR Register bits
    namespace mdf_bsmx3cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to a . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to a in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX4CR Register bits
    namespace mdf_bsmx4cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX5CR Register bits
    namespace mdf_bsmx5cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_DFLT0CR Register bits
    namespace mdf_dflt0cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT1CR Register bits
    namespace mdf_dflt1cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT2CR Register bits
    namespace mdf_dflt2cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT3CR Register bits
    namespace mdf_dflt3cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT4CR Register bits
    namespace mdf_dflt4cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT5CR Register bits
    namespace mdf_dflt5cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT0CICR Register bits
    namespace mdf_dflt0cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT1CICR Register bits
    namespace mdf_dflt1cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT2CICR Register bits
    namespace mdf_dflt2cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT3CICR Register bits
    namespace mdf_dflt3cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT4CICR Register bits
    namespace mdf_dflt4cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT5CICR Register bits
    namespace mdf_dflt5cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT0RSFR Register bits
    namespace mdf_dflt0rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT1RSFR Register bits
    namespace mdf_dflt1rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT2RSFR Register bits
    namespace mdf_dflt2rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT3RSFR Register bits
    namespace mdf_dflt3rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT4RSFR Register bits
    namespace mdf_dflt4rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT5RSFR Register bits
    namespace mdf_dflt5rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT0INTR Register bits
    namespace mdf_dflt0intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT1INTR Register bits
    namespace mdf_dflt1intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT2INTR Register bits
    namespace mdf_dflt2intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT3INTR Register bits
    namespace mdf_dflt3intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT4INTR Register bits
    namespace mdf_dflt4intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT5INTR Register bits
    namespace mdf_dflt5intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD0CR Register bits
    namespace mdf_old0cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD1CR Register bits
    namespace mdf_old1cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD2CR Register bits
    namespace mdf_old2cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD3CR Register bits
    namespace mdf_old3cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD4CR Register bits
    namespace mdf_old4cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD5CR Register bits
    namespace mdf_old5cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD0THLR Register bits
    namespace mdf_old0thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD1THLR Register bits
    namespace mdf_old1thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD2THLR Register bits
    namespace mdf_old2thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD3THLR Register bits
    namespace mdf_old3thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD4THLR Register bits
    namespace mdf_old4thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD5THLR Register bits
    namespace mdf_old5thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD0THHR Register bits
    namespace mdf_old0thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD1THHR Register bits
    namespace mdf_old1thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD2THHR Register bits
    namespace mdf_old2thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD3THHR Register bits
    namespace mdf_old3thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD4THHR Register bits
    namespace mdf_old4thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD5THHR Register bits
    namespace mdf_old5thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_DLY0CR Register bits
    namespace mdf_dly0cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY1CR Register bits
    namespace mdf_dly1cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY2CR Register bits
    namespace mdf_dly2cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY3CR Register bits
    namespace mdf_dly3cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY4CR Register bits
    namespace mdf_dly4cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY5CR Register bits
    namespace mdf_dly5cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_SCD0CR Register bits
    namespace mdf_scd0cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD1CR Register bits
    namespace mdf_scd1cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD2CR Register bits
    namespace mdf_scd2cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD3CR Register bits
    namespace mdf_scd3cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD4CR Register bits
    namespace mdf_scd4cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD5CR Register bits
    namespace mdf_scd5cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_DFLT0IER Register bits
    namespace mdf_dflt0ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT0ISR Register bits
    namespace mdf_dflt0isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< FTHF
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on , writing 0 has no effect. - 1: Reading 1 means that a new data is available on , writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing this bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was higher than OLDTHL when the last OLD event occurred. - 1: The signal was lower than OLDTHL when the last OLD event occurred.
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing this bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH when the last OLD event occurred. - 1: The signal was higher than OLDTHH when the last OLD event occurred.
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT1IER Register bits
    namespace mdf_dflt1ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT2IER Register bits
    namespace mdf_dflt2ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT3IER Register bits
    namespace mdf_dflt3ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT4IER Register bits
    namespace mdf_dflt4ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT5IER Register bits
    namespace mdf_dflt5ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT1ISR Register bits
    namespace mdf_dflt1isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT2ISR Register bits
    namespace mdf_dflt2isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT3ISR Register bits
    namespace mdf_dflt3isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT4ISR Register bits
    namespace mdf_dflt4isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT5ISR Register bits
    namespace mdf_dflt5isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_OEC0CR Register bits
    namespace mdf_oec0cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC1CR Register bits
    namespace mdf_oec1cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC2CR Register bits
    namespace mdf_oec2cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC3CR Register bits
    namespace mdf_oec3cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC4CR Register bits
    namespace mdf_oec4cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC5CR Register bits
    namespace mdf_oec5cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_SNPS0DR Register bits
    namespace mdf_snps0dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS1DR Register bits
    namespace mdf_snps1dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS2DR Register bits
    namespace mdf_snps2dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS3DR Register bits
    namespace mdf_snps3dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS4DR Register bits
    namespace mdf_snps4dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS5DR Register bits
    namespace mdf_snps5dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_DFLT0DR Register bits
    namespace mdf_dflt0dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT1DR Register bits
    namespace mdf_dflt1dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT2DR Register bits
    namespace mdf_dflt2dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT3DR Register bits
    namespace mdf_dflt3dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT4DR Register bits
    namespace mdf_dflt4dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT5DR Register bits
    namespace mdf_dflt5dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

}

// ============================================================================
// ADF1 Peripheral
// ============================================================================

namespace adf1 {
    /// Base addresses
    constexpr uint32_t ADF1_BASE = 0x46024000;

    /// ADF1 Register structure
    struct Registers {
        volatile uint32_t ADF_GCR;  ///< Offset: 0x00 - ADF Global Control Register
        volatile uint32_t ADF_CKGCR;  ///< Offset: 0x04 - ADF clock generator control register
        volatile uint32_t ADF_SITF0CR;  ///< Offset: 0x80 - ADF serial interface control register 0
        volatile uint32_t ADF_BSMX0CR;  ///< Offset: 0x84 - ADF bitstream matrix control register 0
        volatile uint32_t ADF_DFLT0CR;  ///< Offset: 0x88 - ADF digital filter control register 0
        volatile uint32_t ADF_DFLT0CICR;  ///< Offset: 0x8C - ADF digital filer configuration register 0
        volatile uint32_t ADF_DFLT0RSFR;  ///< Offset: 0x90 - ADF reshape filter configuration register 0
        volatile uint32_t ADF_DLY0CR;  ///< Offset: 0xA4 - ADF delay control register 0
        volatile uint32_t ADF_DFLT0IER;  ///< Offset: 0xAC - ADF DFLT0 interrupt enable register
        volatile uint32_t ADF_DFLT0ISR;  ///< Offset: 0xB0 - ADF DFLT0 interrupt status register 0
        volatile uint32_t ADF_SADCR;  ///< Offset: 0xB8 - ADF SAD control register
        volatile uint32_t ADF_SADCFGR;  ///< Offset: 0xBC - ADF SAD configuration register
        volatile uint32_t ADF_SADSDLVR;  ///< Offset: 0xC0 - ADF SAD sound level register
        volatile uint32_t ADF_SADANLVR;  ///< Offset: 0xC4 - ADF SAD ambient noise level register
        volatile uint32_t ADF_DFLT0DR;  ///< Offset: 0xF0 - ADF digital filter data register 0
    };

    /// Peripheral instances
    inline Registers* ADF1 = reinterpret_cast<Registers*>(ADF1_BASE);

    // Bit definitions
    /// ADF_GCR Register bits
    namespace adf_gcr_bits {
        constexpr uint32_t TRGO = (1U << 0);  ///< Trigger output control Set by software and reset by
    }

    /// ADF_CKGCR Register bits
    namespace adf_ckgcr_bits {
        constexpr uint32_t CKGACTIVE = (1U << 31);  ///< Clock generator active flag
        constexpr uint32_t PROCDIV = (7 << 24);  ///< Divider to control the serial interface clock
        constexpr uint32_t CCKDIV = (4 << 16);  ///< Divider to control the ADF_CCK clock
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter trigger signal selection
        constexpr uint32_t TRGSENS = (1U << 8);  ///< CKGEN trigger sensitivity selection
        constexpr uint32_t CCK1DIR = (1U << 6);  ///< ADF_CCK1 direction
        constexpr uint32_t CCK0DIR = (1U << 5);  ///< ADF_CCK0 direction
        constexpr uint32_t CKGMOD = (1U << 4);  ///< Clock generator mode
        constexpr uint32_t CCK1EN = (1U << 2);  ///< ADF_CCK1 clock enable
        constexpr uint32_t CCK0EN = (1U << 1);  ///< ADF_CCK0 clock enable
        constexpr uint32_t CKGDEN = (1U << 0);  ///< CKGEN dividers enable
    }

    /// ADF_SITF0CR Register bits
    namespace adf_sitf0cr_bits {
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< SITFACTIVE
        constexpr uint32_t STH = (5 << 8);  ///< STH
        constexpr uint32_t SITFMOD = (2 << 4);  ///< SITFMOD
        constexpr uint32_t SCKSRC = (2 << 1);  ///< SCKSRC
        constexpr uint32_t SITFEN = (1U << 0);  ///< SITFEN
    }

    /// ADF_BSMX0CR Register bits
    namespace adf_bsmx0cr_bits {
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX active flag
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream selection
    }

    /// ADF_DFLT0CR Register bits
    namespace adf_dflt0cr_bits {
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< DFLT0 active flag
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< DFLT0 run status flag
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded
        constexpr uint32_t TRGSRC = (4 << 12);  ///< DFLT0 trigger signal selection
        constexpr uint32_t ACQMOD = (3 << 4);  ///< DFLT0 trigger mode
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO threshold selection
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA requests enable
        constexpr uint32_t DFLTEN = (1U << 0);  ///< DFLT0 enable
    }

    /// ADF_DFLT0CICR Register bits
    namespace adf_dflt0cicr_bits {
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC order
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter
    }

    /// ADF_DFLT0RSFR Register bits
    namespace adf_dflt0rsfr_bits {
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-pass filter bypass
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass
    }

    /// ADF_DLY0CR Register bits
    namespace adf_dly0cr_bits {
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip busy flag
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream
    }

    /// ADF_DFLT0IER Register bits
    namespace adf_dflt0ier_bits {
        constexpr uint32_t SDLVLIE = (1U << 13);  ///< SAD sound-level value ready enable
        constexpr uint32_t SDDETIE = (1U << 12);  ///< Sound activity detection interrupt enable
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape filter overrun interrupt enable
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable
    }

    /// ADF_DFLT0ISR Register bits
    namespace adf_dflt0isr_bits {
        constexpr uint32_t SDLVLF = (1U << 13);  ///< Sound level value ready flag
        constexpr uint32_t SDDETF = (1U << 12);  ///< Sound activity detection flag
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape filter overrun detection flag
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO not empty flag
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag
    }

    /// ADF_SADCR Register bits
    namespace adf_sadcr_bits {
        constexpr uint32_t SADACTIVE = (1U << 31);  ///< SAD Active flag
        constexpr uint32_t SADMOD = (2 << 12);  ///< SAD working mode
        constexpr uint32_t FRSIZE = (3 << 8);  ///< Frame size
        constexpr uint32_t HYSTEN = (1U << 7);  ///< Hysteresis enable
        constexpr uint32_t SADST = (2 << 4);  ///< SAD state
        constexpr uint32_t DETCFG = (1U << 3);  ///< Sound trigger event configuration
        constexpr uint32_t DATCAP = (2 << 1);  ///< Data capture mode
        constexpr uint32_t SADEN = (1U << 0);  ///< Sound activity detector enable
    }

    /// ADF_SADCFGR Register bits
    namespace adf_sadcfgr_bits {
        constexpr uint32_t ANMIN = (13 << 16);  ///< ANMIN
        constexpr uint32_t HGOVR = (3 << 12);  ///< Hangover time window
        constexpr uint32_t LFRNB = (3 << 8);  ///< LFRNB
        constexpr uint32_t ANSLP = (3 << 4);  ///< ANSLP
        constexpr uint32_t SNTHR = (4 << 0);  ///< SNTHR
    }

    /// ADF_SADSDLVR Register bits
    namespace adf_sadsdlvr_bits {
        constexpr uint32_t SDLVL = (15 << 0);  ///< SDLVL
    }

    /// ADF_SADANLVR Register bits
    namespace adf_sadanlvr_bits {
        constexpr uint32_t ANLVL = (15 << 0);  ///< ANLVL
    }

    /// ADF_DFLT0DR Register bits
    namespace adf_dflt0dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< DR
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x42028000;
    constexpr uint32_t SEC_ADC1_BASE = 0x52028000;
    constexpr uint32_t ADC4_BASE = 0x46021000;
    constexpr uint32_t SEC_ADC4_BASE = 0x56021000;
    constexpr uint32_t ADC12_BASE = 0x42028300;
    constexpr uint32_t SEC_ADC12_BASE = 0x52028300;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t ADC_IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t ADC_CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t ADC_CFGR1;  ///< Offset: 0x0C - ADC configuration register
        volatile uint32_t ADC_CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t ADC_SMPR1;  ///< Offset: 0x14 - ADC sample time register 1
        volatile uint32_t ADC_SMPR2;  ///< Offset: 0x18 - ADC sample time register 2
        volatile uint32_t ADC_PCSEL;  ///< Offset: 0x1C - ADC channel preselection register
        volatile uint32_t ADC_SQR1;  ///< Offset: 0x30 - ADC regular sequence register 1
        volatile uint32_t ADC_SQR2;  ///< Offset: 0x34 - ADC regular sequence register 2
        volatile uint32_t ADC_SQR3;  ///< Offset: 0x38 - ADC regular sequence register 3
        volatile uint32_t ADC_SQR4;  ///< Offset: 0x3C - ADC regular sequence register 4
        volatile uint32_t ADC_DR;  ///< Offset: 0x40 - ADC regular Data Register
        volatile uint32_t ADC_JSQR;  ///< Offset: 0x4C - ADC injected sequence register
        volatile uint32_t ADC_OFR1;  ///< Offset: 0x60 - ADC offset register
        volatile uint32_t ADC_OFR2;  ///< Offset: 0x64 - ADC offset register
        volatile uint32_t ADC_OFR3;  ///< Offset: 0x68 - ADC offset register
        volatile uint32_t ADC_OFR4;  ///< Offset: 0x6C - ADC offset register
        volatile uint32_t ADC_GCOMP;  ///< Offset: 0x70 - ADC gain compensation register
        volatile uint32_t ADC_JDR1;  ///< Offset: 0x80 - ADC injected data register
        volatile uint32_t ADC_JDR2;  ///< Offset: 0x84 - ADC injected data register
        volatile uint32_t ADC_JDR3;  ///< Offset: 0x88 - ADC injected data register
        volatile uint32_t ADC_JDR4;  ///< Offset: 0x8C - ADC injected data register
        volatile uint32_t ADC_AWD2CR;  ///< Offset: 0xA0 - ADC analog watchdog 2 configuration register
        volatile uint32_t ADC_AWD3CR;  ///< Offset: 0xA4 - ADC analog watchdog 3 configuration register
        volatile uint32_t ADC_LTR1;  ///< Offset: 0xA8 - ADC watchdog threshold register 1
        volatile uint32_t ADC_HTR1;  ///< Offset: 0xAC - ADC watchdog threshold register 1
        volatile uint32_t ADC_LTR2;  ///< Offset: 0xB0 - ADC watchdog lower threshold register 2
        volatile uint32_t ADC_HTR2;  ///< Offset: 0xB4 - ADC watchdog higher threshold register 2
        volatile uint32_t ADC_LTR3;  ///< Offset: 0xB8 - ADC watchdog lower threshold register 3
        volatile uint32_t ADC_HTR3;  ///< Offset: 0xBC - ADC watchdog higher threshold register 3
        volatile uint32_t ADC_DIFSEL;  ///< Offset: 0xC0 - ADC differential mode selection register
        volatile uint32_t ADC_CALFACT;  ///< Offset: 0xC4 - ADC user control register
        volatile uint32_t ADC_CALFACT2;  ///< Offset: 0xC8 - ADC calibration factor register
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* SEC_ADC1 = reinterpret_cast<Registers*>(SEC_ADC1_BASE);
    inline Registers* ADC4 = reinterpret_cast<Registers*>(ADC4_BASE);
    inline Registers* SEC_ADC4 = reinterpret_cast<Registers*>(SEC_ADC4_BASE);
    inline Registers* ADC12 = reinterpret_cast<Registers*>(ADC12_BASE);
    inline Registers* SEC_ADC12 = reinterpret_cast<Registers*>(SEC_ADC12_BASE);

    // Bit definitions
    /// ADC_ISR Register bits
    namespace adc_isr_bits {
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADC ready This bit is set by hardware after the ADC has been enabled (bit ADEN=1) and when the ADC reaches a state where it is ready to accept conversion requests. It is cleared by software writing 1 to it.
        constexpr uint32_t EOSMP = (1U << 1);  ///< End of sampling flag This bit is set by hardware during the conversion of any channel (only for regular channels), at the end of the sampling phase.
        constexpr uint32_t EOC = (1U << 2);  ///< End of conversion flag This bit is set by hardware at the end of each regular conversion of a channel when a new data is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register
        constexpr uint32_t EOS = (1U << 3);  ///< End of regular sequence flag This bit is set by hardware at the end of the conversions of a regular sequence of channels. It is cleared by software writing 1 to it.
        constexpr uint32_t OVR = (1U << 4);  ///< ADC overrun This bit is set by hardware when an overrun occurs on a regular channel, meaning that a new conversion has completed while the EOC flag was already set. It is cleared by software writing 1 to it.
        constexpr uint32_t JEOC = (1U << 5);  ///< Injected channel end of conversion flag This bit is set by hardware at the end of each injected conversion of a channel when a new data is available in the corresponding ADC_JDRy register. It is cleared by software writing 1 to it or by reading the corresponding ADC_JDRy register
        constexpr uint32_t JEOS = (1U << 6);  ///< Injected channel end of sequence flag This bit is set by hardware at the end of the conversions of all injected channels in the group. It is cleared by software writing 1 to it.
        constexpr uint32_t AWD1 = (1U << 7);  ///< Analog watchdog 1 flag This bit is set by hardware when the converted voltage crosses the values programmed in the fields LT1[11:0] and HT1[11:0] of ADC_LTR1, & ADC_HTR1 register. It is cleared by software. writing 1 to it.
        constexpr uint32_t AWD2 = (1U << 8);  ///< Analog watchdog 2 flag This bit is set by hardware when the converted voltage crosses the values programmed in the fields LT2[7:0] and HT2[7:0] of ADC_LTR2 & ADC_HTR2 register. It is cleared by software writing 1 to it.
        constexpr uint32_t AWD3 = (1U << 9);  ///< Analog watchdog 3 flag This bit is set by hardware when the converted voltage crosses the values programmed in the fields LT3[7:0] and HT3[7:0] of ADC_LTR3 & ADC_HTR3 register. It is cleared by software writing 1 to it.
        constexpr uint32_t LDORDY = (1U << 12);  ///< ADC voltage regulator ready This bit is set by hardware. It indicates that the ADC internal supply is ready. The ADC is available after tADCVREG_SETUP time.
    }

    /// ADC_IER Register bits
    namespace adc_ier_bits {
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADC ready interrupt enable This bit is set and cleared by software to enable/disable the ADC Ready interrupt. Note: Software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< End of sampling flag interrupt enable for regular conversions This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt for regular conversions. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t EOCIE = (1U << 2);  ///< End of regular conversion interrupt enable This bit is set and cleared by software to enable/disable the end of a regular conversion interrupt. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t EOSIE = (1U << 3);  ///< End of regular sequence of conversions interrupt enable This bit is set and cleared by software to enable/disable the end of regular sequence of conversions interrupt. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t OVRIE = (1U << 4);  ///< Overrun interrupt enable This bit is set and cleared by software to enable/disable the Overrun interrupt of a regular conversion. Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t JEOCIE = (1U << 5);  ///< End of injected conversion interrupt enable This bit is set and cleared by software to enable/disable the end of an injected conversion interrupt. Note: Software is allowed to write this bit only when JADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t JEOSIE = (1U << 6);  ///< End of injected sequence of conversions interrupt enable This bit is set and cleared by software to enable/disable the end of injected sequence of conversions interrupt. Note: Software is allowed to write this bit only when JADSTART=0 (which ensures that no injected conversion is ongoing).
        constexpr uint32_t AWD1IE = (1U << 7);  ///< Analog watchdog 1 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog 1 interrupt. Note: Software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD2IE = (1U << 8);  ///< Analog watchdog 2 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt. Note: Software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD3IE = (1U << 9);  ///< Analog watchdog 3 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt. Note: Software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_CR Register bits
    namespace adc_cr_bits {
        constexpr uint32_t ADEN = (1U << 0);  ///< ADC enable control This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the flag ADRDY has been set. It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command. Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL=0, JADSTART=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0) except for bit ADVREGEN which must be 1 (and the software must have wait for the startup time of the voltage regulator)
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADC disable command This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state). It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time). Note: The software is allowed to set ADDIS only when ADEN=1 and both ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing)
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADC start of regular conversion This bit is set by software to start ADC conversion of regular channels. Depending on the configuration bits EXTEN[1:0], a conversion starts immediately (software trigger configuration) or once a regular hardware trigger event occurs (hardware trigger configuration). It is cleared by hardware: in Single conversion mode (CONT=0, DISCEN=0) when software trigger is selected (EXTEN[1:0]=0x0): at the assertion of the end of regular conversion sequence (EOS) flag. In Discontinuous conversion mode (CONT=0, DISCEN=1), when the software trigger is selected (EXTEN[1:0]=0x0): at the end of conversion (EOC) flag. in all other cases: after the execution of the ADSTP command, at the same time that ADSTP is cleared by hardware. Note: The software is allowed to set ADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled and there is no pending request to disable the ADC) In Auto-injection mode (JAUTO=1), regular and auto-injected conversions are started by setting bit ADSTART (JADSTART must be kept cleared)
        constexpr uint32_t JADSTART = (1U << 3);  ///< ADC start of injected conversion This bit is set by software to start ADC conversion of injected channels. Depending on the configuration bits JEXTEN[1:0], a conversion starts immediately (software trigger configuration) or once an injected hardware trigger event occurs (hardware trigger configuration). It is cleared by hardware: in Single conversion mode when software trigger is selected (JEXTSEL=0x0): at the assertion of the end of injected conversion sequence (JEOS) flag. in all cases: after the execution of the JADSTP command, at the same time as JADSTP is cleared by hardware. Note: The software is allowed to set JADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled and there is no pending request to disable the ADC). In Auto-injection mode (JAUTO=1), regular and auto-injected conversions are started by setting bit ADSTART (JADSTART must be kept cleared)
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADC stop of regular conversion command This bit is set by software to stop and discard an ongoing regular conversion (ADSTP Command). It is cleared by hardware when the conversion is effectively discarded and the ADC regular sequence and triggers can be re-configured. The ADC is then ready to accept a new start of regular conversions (ADSTART command). Note: The software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 (ADC is enabled and eventually converting a regular conversion and there is no pending request to disable the ADC). In Auto-injection mode (JAUTO=1), setting ADSTP bit aborts both regular and injected conversions (do not use JADSTP).
        constexpr uint32_t JADSTP = (1U << 5);  ///< ADC stop of injected conversion command This bit is set by software to stop and discard an ongoing injected conversion (JADSTP Command). It is cleared by hardware when the conversion is effectively discarded and the ADC injected sequence and triggers can be re-configured. The ADC is then ready to accept a new start of injected conversions (JADSTART command). Note: The software is allowed to set JADSTP only when JADSTART=1 and ADDIS=0 (ADC is enabled and eventually converting an injected conversion and there is no pending request to disable the ADC). In Auto-injection mode (JAUTO=1), setting ADSTP bit aborts both regular and injected conversions (do not use JADSTP)
        constexpr uint32_t ADCALLIN = (1U << 16);  ///< Linearity calibration This bit is set and cleared by software to enable the linearity calibration. Note: The software is allowed to write this bit only when the ADC is disabled and is not calibrating (ADCAL=0, JADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
        constexpr uint32_t CALINDEX = (4 << 24);  ///< Calibration factor This bitfield controls the calibration factor to be read or written. Calibration index 0 is dedicated to single-ended and differential offsets, calibration index 1 to 7 to the linearity calibration factors, and index 8 to the internal offset: Others: Reserved, must not be used Note: ADC_CALFACT2[31:0] correspond to the location of CALINDEX[3:0] calibration factor data (see for details).
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADC voltage regulator enable This bits is set by software to enable the ADC voltage regulator. Before performing any operation such as launching a calibration or enabling the ADC, the ADC voltage regulator must first be enabled and the software must wait for the regulator start-up time. For more details about the ADC voltage regulator enable and disable sequences, refer to (ADVREGEN). The software can program this bit field only when the ADC is disabled (ADCAL=0, JADSTART=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
        constexpr uint32_t DEEPPWD = (1U << 29);  ///< Deep-power-down enable This bit is set and cleared by software to put the ADC in Deep-power-down mode. Note: The software is allowed to write this bit only when the ADC is disabled (ADCAL=0, JADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADC calibration This bit is set by software to start the ADC calibration. It is cleared by hardware after calibration is complete. Note: The software is allowed to launch a calibration by setting ADCAL only when ADEN=0.
    }

    /// ADC_CFGR1 Register bits
    namespace adc_cfgr1_bits {
        constexpr uint32_t DMNGT = (2 << 0);  ///< Data management configuration This bit is set and cleared by software to select how the ADC interface output data are managed. Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t RES = (2 << 2);  ///< Data resolution These bits are written by software to select the resolution of the conversion. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t EXTSEL = (5 << 5);  ///< External trigger selection for regular group These bits select the external event used to trigger the start of conversion of a regular group: ... Refer to the ADC external trigger for regular channels in signals for details on trigger mapping. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t EXTEN = (2 << 10);  ///< External trigger enable and polarity selection for regular channels These bits are set and cleared by software to select the external trigger polarity and enable the trigger of a regular group. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t OVRMOD = (1U << 12);  ///< Overrun Mode This bit is set and cleared by software and configure the way data overrun is managed. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t CONT = (1U << 13);  ///< Single / continuous conversion mode for regular conversions This bit is set and cleared by software. If it is set, regular conversion takes place continuously until it is cleared. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both DISCEN=1 and CONT=1. The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t AUTDLY = (1U << 14);  ///< Delayed conversion mode This bit is set and cleared by software to enable/disable the Auto Delayed Conversion mode.. Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t DISCEN = (1U << 16);  ///< Discontinuous mode for regular channels This bit is set and cleared by software to enable/disable Discontinuous mode for regular channels. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both DISCEN=1 and CONT=1. It is not possible to use both auto-injected mode and discontinuous mode simultaneously: the bits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set. The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t DISCNUM = (3 << 17);  ///< Discontinuous mode channel count These bits are written by software to define the number of regular channels to be converted in discontinuous mode, after receiving an external trigger. ... Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t JDISCEN = (1U << 20);  ///< Discontinuous mode on injected channels This bit is set and cleared by software to enable/disable discontinuous mode on the injected channels of a group. Note: The software is allowed to write this bit only when JADSTART=0 (which ensures that no injected conversion is ongoing). It is not possible to use both auto-injected mode and discontinuous mode simultaneously: the bits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set.
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< Enable the watchdog 1 on a single channel or on all channels This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWD1CH[4:0] bits or on all the channels Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t AWD1EN = (1U << 23);  ///< Analog watchdog 1 enable on regular channels This bit is set and cleared by software Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t JAWD1EN = (1U << 24);  ///< Analog watchdog 1 enable on injected channels This bit is set and cleared by software Note: The software is allowed to write this bit only when JADSTART=0 (which ensures that no injected conversion is ongoing).
        constexpr uint32_t JAUTO = (1U << 25);  ///< Automatic injected group conversion This bit is set and cleared by software to enable/disable automatic injected group conversion after regular group conversion. Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no regular nor injected conversion is ongoing).
        constexpr uint32_t AWD1CH = (5 << 26);  ///< Analog watchdog 1 channel selection These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog. ..... Others: Reserved, must not be used Note: The channel selected by AWD1CH must be also selected into the SQRi or JSQRi registers. Software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_CFGR2 Register bits
    namespace adc_cfgr2_bits {
        constexpr uint32_t ROVSE = (1U << 0);  ///< Regular Oversampling Enable This bit is set and cleared by software to enable regular oversampling. Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)
        constexpr uint32_t JOVSE = (1U << 1);  ///< Injected Oversampling Enable This bit is set and cleared by software to enable injected oversampling. Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)
        constexpr uint32_t OVSS = (4 << 5);  ///< Oversampling right shift This bit field is set and cleared by software to define the right shifting applied to the raw oversampling result. Others: Reserved, must not be used. Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t TROVS = (1U << 9);  ///< Triggered Regular Oversampling This bit is set and cleared by software to enable triggered oversampling Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t ROVSM = (1U << 10);  ///< Regular Oversampling mode This bit is set and cleared by software to select the regular oversampling mode. Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t BULB = (1U << 13);  ///< Bulb sampling mode This bit is set and cleared by software to select the bulb sampling mode. SMPTRIG bit must not be set when the BULB bit is set. The very first ADC conversion is performed with the sampling time specified in SMPx bits. Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SWTRIG = (1U << 14);  ///< Software trigger bit for sampling time control trigger mode This bit is set and cleared by software to enable the bulb sampling mode. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMPTRIG = (1U << 15);  ///< Sampling time control trigger mode This bit is set and cleared by software to enable the sampling time control trigger mode. The sampling time starts on the trigger rising edge, and the conversion on the trigger falling edge. EXTEN[1:0] bits must be set to 01. BULB bit must not be set when the SMPTRIG bit is set. When EXTEN[1:0] bits is set to 00, set SWTRIG to start the sampling and clear SWTRIG bit to start the conversion. Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OSR = (10 << 16);  ///< Oversampling ratio This bitfield is set and cleared by software to define the oversampling ratio. 2: 3x ... 1023: 1024x Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        constexpr uint32_t LFTRIG = (1U << 27);  ///< Low-frequency trigger This bit is set and cleared by software Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t LSHIFT = (4 << 28);  ///< Left shift factor This bitfield is set and cleared by software to define the left shifting applied to the final result with or without oversampling. Note: The software is allowed to write this bit only when ADSTART= 0 (which ensures that no conversion is ongoing).
    }

    /// ADC_SMPR1 Register bits
    namespace adc_smpr1_bits {
        constexpr uint32_t SMP0 = (3 << 0);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP1 = (3 << 3);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP2 = (3 << 6);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP3 = (3 << 9);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP4 = (3 << 12);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP5 = (3 << 15);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP6 = (3 << 18);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP7 = (3 << 21);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP8 = (3 << 24);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP9 = (3 << 27);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_SMPR2 Register bits
    namespace adc_smpr2_bits {
        constexpr uint32_t SMP10 = (3 << 0);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP11 = (3 << 3);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP12 = (3 << 6);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP13 = (3 << 9);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP14 = (3 << 12);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP15 = (3 << 15);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP16 = (3 << 18);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP17 = (3 << 21);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP18 = (3 << 24);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SMP19 = (3 << 27);  ///< Channel x sampling time selection (x = 0 to 9) These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_PCSEL Register bits
    namespace adc_pcsel_bits {
        constexpr uint32_t PCSEL0 = (1U << 0);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL1 = (1U << 1);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL2 = (1U << 2);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL3 = (1U << 3);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL4 = (1U << 4);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL5 = (1U << 5);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL6 = (1U << 6);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL7 = (1U << 7);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL8 = (1U << 8);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL9 = (1U << 9);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL10 = (1U << 10);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL11 = (1U << 11);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL12 = (1U << 12);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL13 = (1U << 13);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL14 = (1U << 14);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL15 = (1U << 15);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL16 = (1U << 16);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL17 = (1U << 17);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL18 = (1U << 18);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t PCSEL19 = (1U << 19);  ///< Channel i (VINP[i]) preselection These bits are written by software to preselect the input channel I/O instance to be converted. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_SQR1 Register bits
    namespace adc_sqr1_bits {
        constexpr uint32_t L = (4 << 0);  ///< Regular channel sequence length These bits are written by software to define the total number of conversions in the regular channel conversion sequence. ... Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ1 = (5 << 6);  ///< 1st conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 1st in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ2 = (5 << 12);  ///< 2nd conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 2nd in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ3 = (5 << 18);  ///< 3rd conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 3rd in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ4 = (5 << 24);  ///< 4th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 4th in the regular conversion sequence.
    }

    /// ADC_SQR2 Register bits
    namespace adc_sqr2_bits {
        constexpr uint32_t SQ5 = (5 << 0);  ///< 5th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 5th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ6 = (5 << 6);  ///< 6th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 6th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ7 = (5 << 12);  ///< 7th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 7th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ8 = (5 << 18);  ///< 8th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 8th in the regular conversion sequence Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ9 = (5 << 24);  ///< 9th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 9th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
    }

    /// ADC_SQR3 Register bits
    namespace adc_sqr3_bits {
        constexpr uint32_t SQ10 = (5 << 0);  ///< 10th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 10th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ11 = (5 << 6);  ///< 11th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 11th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ12 = (5 << 12);  ///< 12th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 12th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ13 = (5 << 18);  ///< 13th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 13th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ14 = (5 << 24);  ///< 14th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 14th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
    }

    /// ADC_SQR4 Register bits
    namespace adc_sqr4_bits {
        constexpr uint32_t SQ15 = (5 << 0);  ///< 15th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 15th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
        constexpr uint32_t SQ16 = (5 << 6);  ///< 16th conversion in regular sequence These bits are written by software with the channel number (0..19) assigned as the 16th in the regular conversion sequence. Note: The software is allowed to write these bits only when ADSTART=0 (which ensures that no regular conversion is ongoing).
    }

    /// ADC_DR Register bits
    namespace adc_dr_bits {
        constexpr uint32_t RDATA = (32 << 0);  ///< Regular data converted These bits are read-only. They contain the conversion result from the last converted regular channel. The data are left- or right-aligned as described in .
    }

    /// ADC_JSQR Register bits
    namespace adc_jsqr_bits {
        constexpr uint32_t JL = (2 << 0);  ///< Injected channel sequence length These bits are written by software to define the total number of conversions in the injected channel conversion sequence. Note: The software is allowed to write these bits only when JADSTART=0 (which ensures that no injected conversion is ongoing.
        constexpr uint32_t JEXTSEL = (5 << 2);  ///< External trigger selection for injected group These bits select the external event used to trigger the start of conversion of an injected group: ... Refer to the ADC external trigger for injected channels in internal signals for details on trigger mapping. Note: The software is allowed to write these bits only when JADSTART=0 (which ensures that no injected conversion is ongoing.
        constexpr uint32_t JEXTEN = (2 << 7);  ///< External trigger enable and polarity selection for injected channels These bits are set and cleared by software to select the external trigger polarity and enable the trigger of an injected group. Note: The software is allowed to write these bits only when JADSTART=0 (which ensures that no injected conversion is ongoing.
        constexpr uint32_t JSQ1 = (5 << 9);  ///< 1st conversion in the injected sequence These bits are written by software with the channel number (0..19) assigned as the 1st in the injected conversion sequence. Note: The software is allowed to write these bits only when JADSTART=0 (which ensures that no injected conversion is ongoing.
        constexpr uint32_t JSQ2 = (5 << 15);  ///< 2nd conversion in the injected sequence These bits are written by software with the channel number (0..19) assigned as the 2nd in the injected conversion sequence. Note: The software is allowed to write these bits only when JADSTART=0 (which ensures that no injected conversion is ongoing.
        constexpr uint32_t JSQ3 = (5 << 21);  ///< 3rd conversion in the injected sequence These bits are written by software with the channel number (0..19) assigned as the 3rd in the injected conversion sequence. Note: The software is allowed to write these bits only when JADSTART=0 (which ensures that no injected conversion is ongoing.
        constexpr uint32_t JSQ4 = (5 << 27);  ///< 4th conversion in the injected sequence These bits are written by software with the channel number (0..19) assigned as the 4th in the injected conversion sequence. Note: The software is allowed to write these bits only when JADSTART=0 (which ensures that no injected conversion is ongoing.
    }

    /// ADC_OFR1 Register bits
    namespace adc_ofr1_bits {
        constexpr uint32_t OFFSET = (24 << 0);  ///< Data offset y for the channel programmed into OFFSETy_CH[4:0] bits These bits are written by software to define the offset y to be subtracted from the raw converted data when converting a channel (regular or injected). The channel to which the data offset y applies must be programmed to the OFFSETy_CH[4:0] bits. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion). When OFFSETy[21:0] bitfield is reset, the offset compensation is disabled. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing). If several offsets (OFFSETy) point to the same channel, only the offset with the lowest y value is considered for the subtraction. For example, if OFFSET1_CH[4:0]=4 and OFFSET2_CH[4:0]=4, this is OFFSET1[25:0] that is subtracted when converting channel 4.
        constexpr uint32_t POSOFF = (1U << 24);  ///< offset sign This bit is set and cleared by software to enable the positive offset. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t USAT = (1U << 25);  ///< Unsigned saturation enable This bit is written by software to enable or disable the unsigned saturation feature. Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SSAT = (1U << 26);  ///< Signed saturation enable This bit is written by software to enable or disable the Signed saturation feature. (see OFFSETy_CH, OVSS, LSHIFT, USAT, SSAT) for details). Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< Channel selection for the data offset y These bits are written by software to define the channel to which the offset programmed into OFFSETy[25:0] bits applies. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing). If OFFSETy_EN bit is set, it is not allowed to select the same channel in different ADC_OFRy registers.
    }

    /// ADC_OFR2 Register bits
    namespace adc_ofr2_bits {
        constexpr uint32_t OFFSET = (24 << 0);  ///< Data offset y for the channel programmed into OFFSETy_CH[4:0] bits These bits are written by software to define the offset y to be subtracted from the raw converted data when converting a channel (regular or injected). The channel to which the data offset y applies must be programmed to the OFFSETy_CH[4:0] bits. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion). When OFFSETy[21:0] bitfield is reset, the offset compensation is disabled. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing). If several offsets (OFFSETy) point to the same channel, only the offset with the lowest y value is considered for the subtraction. For example, if OFFSET1_CH[4:0]=4 and OFFSET2_CH[4:0]=4, this is OFFSET1[25:0] that is subtracted when converting channel 4.
        constexpr uint32_t POSOFF = (1U << 24);  ///< offset sign This bit is set and cleared by software to enable the positive offset. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t USAT = (1U << 25);  ///< Unsigned saturation enable This bit is written by software to enable or disable the unsigned saturation feature. Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SSAT = (1U << 26);  ///< Signed saturation enable This bit is written by software to enable or disable the Signed saturation feature. (see OFFSETy_CH, OVSS, LSHIFT, USAT, SSAT) for details). Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< Channel selection for the data offset y These bits are written by software to define the channel to which the offset programmed into OFFSETy[25:0] bits applies. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing). If OFFSETy_EN bit is set, it is not allowed to select the same channel in different ADC_OFRy registers.
    }

    /// ADC_OFR3 Register bits
    namespace adc_ofr3_bits {
        constexpr uint32_t OFFSET = (24 << 0);  ///< Data offset y for the channel programmed into OFFSETy_CH[4:0] bits These bits are written by software to define the offset y to be subtracted from the raw converted data when converting a channel (regular or injected). The channel to which the data offset y applies must be programmed to the OFFSETy_CH[4:0] bits. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion). When OFFSETy[21:0] bitfield is reset, the offset compensation is disabled. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing). If several offsets (OFFSETy) point to the same channel, only the offset with the lowest y value is considered for the subtraction. For example, if OFFSET1_CH[4:0]=4 and OFFSET2_CH[4:0]=4, this is OFFSET1[25:0] that is subtracted when converting channel 4.
        constexpr uint32_t POSOFF = (1U << 24);  ///< offset sign This bit is set and cleared by software to enable the positive offset. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t USAT = (1U << 25);  ///< Unsigned saturation enable This bit is written by software to enable or disable the unsigned saturation feature. Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SSAT = (1U << 26);  ///< Signed saturation enable This bit is written by software to enable or disable the Signed saturation feature. (see OFFSETy_CH, OVSS, LSHIFT, USAT, SSAT) for details). Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< Channel selection for the data offset y These bits are written by software to define the channel to which the offset programmed into OFFSETy[25:0] bits applies. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing). If OFFSETy_EN bit is set, it is not allowed to select the same channel in different ADC_OFRy registers.
    }

    /// ADC_OFR4 Register bits
    namespace adc_ofr4_bits {
        constexpr uint32_t OFFSET = (24 << 0);  ///< Data offset y for the channel programmed into OFFSETy_CH[4:0] bits These bits are written by software to define the offset y to be subtracted from the raw converted data when converting a channel (regular or injected). The channel to which the data offset y applies must be programmed to the OFFSETy_CH[4:0] bits. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion). When OFFSETy[21:0] bitfield is reset, the offset compensation is disabled. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing). If several offsets (OFFSETy) point to the same channel, only the offset with the lowest y value is considered for the subtraction. For example, if OFFSET1_CH[4:0]=4 and OFFSET2_CH[4:0]=4, this is OFFSET1[25:0] that is subtracted when converting channel 4.
        constexpr uint32_t POSOFF = (1U << 24);  ///< offset sign This bit is set and cleared by software to enable the positive offset. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t USAT = (1U << 25);  ///< Unsigned saturation enable This bit is written by software to enable or disable the unsigned saturation feature. Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t SSAT = (1U << 26);  ///< Signed saturation enable This bit is written by software to enable or disable the Signed saturation feature. (see OFFSETy_CH, OVSS, LSHIFT, USAT, SSAT) for details). Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< Channel selection for the data offset y These bits are written by software to define the channel to which the offset programmed into OFFSETy[25:0] bits applies. Note: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing). If OFFSETy_EN bit is set, it is not allowed to select the same channel in different ADC_OFRy registers.
    }

    /// ADC_GCOMP Register bits
    namespace adc_gcomp_bits {
        constexpr uint32_t GCOMPCOEFF = (14 << 0);  ///< Gain compensation coefficient These bits are set and cleared by software to program the gain compensation coefficient. ... ... The coefficient is divided by 4096 to get the gain factor ranging from 0 to 3.999756. Note: This gain compensation is only applied when GCOMP bit of ADCx_CFGR2 register is 1.
        constexpr uint32_t GCOMP = (1U << 31);  ///< Gain compensation mode This bit is set and cleared by software to enable the gain compensation mode. Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_JDR1 Register bits
    namespace adc_jdr1_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< Injected data These bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in .
    }

    /// ADC_JDR2 Register bits
    namespace adc_jdr2_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< Injected data These bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in .
    }

    /// ADC_JDR3 Register bits
    namespace adc_jdr3_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< Injected data These bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in .
    }

    /// ADC_JDR4 Register bits
    namespace adc_jdr4_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< Injected data These bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in .
    }

    /// ADC_AWD2CR Register bits
    namespace adc_awd2cr_bits {
        constexpr uint32_t AWD2CH = (20 << 0);  ///< Analog watchdog 2 channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by the analog watchdog 2. AWD2CH[i] = 0: ADC analog input channel-i is not monitored by AWD2 AWD2CH[i] = 1: ADC analog input channel-i is monitored by AWD2 When AWD2CH[19:0] = 000..0, the analog Watchdog 2 is disabled Note: The channels selected by AWD2CH must be also selected into the SQRi or JSQRi registers. Software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_AWD3CR Register bits
    namespace adc_awd3cr_bits {
        constexpr uint32_t AWD3CH = (20 << 0);  ///< Analog watchdog 3 channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by the analog watchdog 3. AWD3CH[i] = 0: ADC analog input channel-i is not monitored by AWD3 AWD3CH[i] = 1: ADC analog input channel-i is monitored by AWD3 When AWD3CH[19:0] = 000..0, the analog Watchdog 3 is disabled Note: The channels selected by AWD3CH must be also selected into the SQRi or JSQRi registers. The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_LTR1 Register bits
    namespace adc_ltr1_bits {
        constexpr uint32_t LTR1 = (25 << 0);  ///< Analog watchdog 1 lower threshold These bits are written by software to define the lower threshold for the analog watchdog 1. Refer to AWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).
    }

    /// ADC_HTR1 Register bits
    namespace adc_htr1_bits {
        constexpr uint32_t HTR1 = (25 << 0);  ///< Analog watchdog 1 higher threshold These bits are written by software to define the higher threshold for the analog watchdog 1. Refer to AWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).
        constexpr uint32_t AWDFILT1 = (3 << 29);  ///< Analog watchdog filtering parameter This bit is set and cleared by software. ... Note: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which ensures that no conversion is ongoing).
    }

    /// ADC_LTR2 Register bits
    namespace adc_ltr2_bits {
        constexpr uint32_t LTR2 = (25 << 0);  ///< Analog watchdog 2 lower threshold These bits are written by software to define the lower threshold for the analog watchdog 2. Refer to AWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).
    }

    /// ADC_HTR2 Register bits
    namespace adc_htr2_bits {
        constexpr uint32_t HTR2 = (25 << 0);  ///< Analog watchdog 2 higher threshold These bits are written by software to define the higher threshold for the analog watchdog 2. Refer to AWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).
    }

    /// ADC_LTR3 Register bits
    namespace adc_ltr3_bits {
        constexpr uint32_t LTR3 = (25 << 0);  ///< Analog watchdog 3 lower threshold These bits are written by software to define the lower threshold for the analog watchdog 3. Refer to AWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).
    }

    /// ADC_HTR3 Register bits
    namespace adc_htr3_bits {
        constexpr uint32_t HTR3 = (25 << 0);  ///< Analog watchdog 3 higher threshold These bits are written by software to define the higher threshold for the analog watchdog 3. Refer to AWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).
    }

    /// ADC_DIFSEL Register bits
    namespace adc_difsel_bits {
        constexpr uint32_t DIFSEL = (20 << 0);  ///< Differential mode for channels 19 to 0 These bits are set and cleared by software. They allow selecting if a channel is configured as single ended or differential mode. DIFSEL[i] = 0: ADC analog input channel-i is configured in single ended mode DIFSEL[i] = 1: ADC analog input channel-i is configured in differential mode Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL=0, JADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
    }

    /// ADC_CALFACT Register bits
    namespace adc_calfact_bits {
        constexpr uint32_t I_APB_ADDR = (8 << 0);  ///< Delayed write access address This bitfield contains the address that is being written during delayed write accesses.
        constexpr uint32_t I_APB_DATA = (8 << 8);  ///< Delayed write access data This bitfield contains the data that are being written during delayed write accesses.
        constexpr uint32_t VALIDITY = (1U << 16);  ///< Delayed write access status bit This bit indicates the communication status between the ADC digital and analog blocks.
        constexpr uint32_t LATCH_COEF = (1U << 24);  ///< Calibration factor latch enable bit This bit latches the calibration factor in the CALFACT[31:0] bits.
        constexpr uint32_t CAPTURE_COEF = (1U << 25);  ///< Calibration factor capture enable bit This bit enables the internal calibration factor capture.
    }

    /// ADC_CALFACT2 Register bits
    namespace adc_calfact2_bits {
        constexpr uint32_t CALFACT = (32 << 0);  ///< Linearity or offset calibration factor These bits can be written either by hardware or by software. They contain the 32-bit offset or linearity calibration factor. When CAPTURE_COEF is set to 1, the calibration factor of the analog block is read back and stored in CALFACT[31:0], indexed by CALINDEX[3:0] bits. When LATCH_COEF is set to 1, the calibration factor of the analog block is updated with the value programmed in CALFACT[31:0], indexed by CALINDEX[3:0] bits. To read all calibration factors, perform nine accesses to the ADC_CALFACT2 register. To write all calibration factors, perform eight accesses to the ADC_CALFACT2 register. Note: The software is allowed to write these bits only when ADEN=1, ADSTART=0 and JADSTART=0 (ADC is enabled and no calibration is ongoing and no conversion is ongoing).
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x420D0400;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t BCR1;  ///< Offset: 0x00 - SRAM/NOR-Flash chip-select control register for bank 1
        volatile uint32_t BCR2;  ///< Offset: 0x08 - SRAM/NOR-Flash chip-select control register for bank 2
        volatile uint32_t BCR3;  ///< Offset: 0x10 - SRAM/NOR-Flash chip-select control register for bank 3
        volatile uint32_t BCR4;  ///< Offset: 0x18 - SRAM/NOR-Flash chip-select control register for bank 4
        volatile uint32_t BTR1;  ///< Offset: 0x04 - SRAM/NOR-Flash chip-select timing register for bank 1
        volatile uint32_t BTR2;  ///< Offset: 0x0C - SRAM/NOR-Flash chip-select timing register for bank 2
        volatile uint32_t BTR3;  ///< Offset: 0x14 - SRAM/NOR-Flash chip-select timing register for bank 3
        volatile uint32_t BTR4;  ///< Offset: 0x1C - SRAM/NOR-Flash chip-select timing register for bank 4
        volatile uint32_t BWTR1;  ///< Offset: 0x104 - SRAM/NOR-Flash write timing registers 1
        volatile uint32_t BWTR2;  ///< Offset: 0x10C - SRAM/NOR-Flash write timing registers 2
        volatile uint32_t BWTR3;  ///< Offset: 0x114 - SRAM/NOR-Flash write timing registers 3
        volatile uint32_t BWTR4;  ///< Offset: 0x11C - SRAM/NOR-Flash write timing registers 4
        volatile uint32_t PCSCNTR;  ///< Offset: 0x20 - PSRAM chip select counter register
        volatile uint32_t PCR;  ///< Offset: 0x80 - NAND Flash control registers
        volatile uint32_t SR;  ///< Offset: 0x84 - status and interrupt register
        volatile uint32_t PMEM;  ///< Offset: 0x88 - Common memory space timing register
        volatile uint32_t PATT;  ///< Offset: 0x8C - The FMC_PATT read/write register contains the timing...
        volatile uint32_t ECCR;  ///< Offset: 0x94 - This register contain the current error correction code...
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous clock enable
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO disable
        constexpr uint32_t NBLSET = (2 << 22);  ///< Byte lane (NBL) setup
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller enable
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous clock enable
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO disable
        constexpr uint32_t NBLSET = (2 << 22);  ///< Byte lane (NBL) setup
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller enable
    }

    /// BCR3 Register bits
    namespace bcr3_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous clock enable
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO disable
        constexpr uint32_t NBLSET = (2 << 22);  ///< Byte lane (NBL) setup
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller enable
    }

    /// BCR4 Register bits
    namespace bcr4_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous clock enable
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO disable
        constexpr uint32_t NBLSET = (2 << 22);  ///< Byte lane (NBL) setup
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller enable
    }

    /// BTR1 Register bits
    namespace btr1_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BTR2 Register bits
    namespace btr2_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BTR3 Register bits
    namespace btr3_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BTR4 Register bits
    namespace btr4_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BWTR1 Register bits
    namespace bwtr1_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BWTR2 Register bits
    namespace bwtr2_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BWTR3 Register bits
    namespace bwtr3_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BWTR4 Register bits
    namespace bwtr4_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// PCSCNTR Register bits
    namespace pcscntr_bits {
        constexpr uint32_t CSCOUNT = (16 << 0);  ///< Chip select counter
        constexpr uint32_t CNTB1EN = (1U << 16);  ///< Counter Bank 1 enable
        constexpr uint32_t CNTB2EN = (1U << 17);  ///< Counter Bank 2 enable
        constexpr uint32_t CNTB3EN = (1U << 18);  ///< Counter Bank 3 enable
        constexpr uint32_t CNTB4EN = (1U << 19);  ///< Counter Bank 4 enable
    }

    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t PWAITEN = (1U << 1);  ///< Wait feature enable bit
        constexpr uint32_t PBKEN = (1U << 2);  ///< NAND Flash memory bank enable bit
        constexpr uint32_t PTYP = (1U << 3);  ///< Memory type
        constexpr uint32_t PWID = (2 << 4);  ///< Data bus width
        constexpr uint32_t ECCEN = (1U << 6);  ///< ECC computation logic enable bit
        constexpr uint32_t TCLR = (4 << 9);  ///< CLE to RE delay
        constexpr uint32_t TAR = (3 << 13);  ///< ALE to RE delay
        constexpr uint32_t ECCPS = (3 << 17);  ///< ECC page size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t IRS = (1U << 0);  ///< Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
        constexpr uint32_t ILS = (1U << 1);  ///< Interrupt high-level status The flag is set by hardware and reset by software.
        constexpr uint32_t IFS = (1U << 2);  ///< Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
        constexpr uint32_t IREN = (1U << 3);  ///< Interrupt rising edge detection enable bit
        constexpr uint32_t ILEN = (1U << 4);  ///< Interrupt high-level detection enable bit
        constexpr uint32_t IFEN = (1U << 5);  ///< Interrupt falling edge detection enable bit
        constexpr uint32_t FEMPT = (1U << 6);  ///< FIFO empty. Read-only bit that provides the status of the FIFO
    }

    /// PMEM Register bits
    namespace pmem_bits {
        constexpr uint32_t MEMSET = (8 << 0);  ///< Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space:
        constexpr uint32_t MEMWAIT = (8 << 8);  ///< Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
        constexpr uint32_t MEMHOLD = (8 << 16);  ///< Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space:
        constexpr uint32_t MEMHIZ = (8 << 24);  ///< Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions:
    }

    /// PATT Register bits
    namespace patt_bits {
        constexpr uint32_t ATTSET = (8 << 0);  ///< Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
        constexpr uint32_t ATTWAIT = (8 << 8);  ///< Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
        constexpr uint32_t ATTHOLD = (8 << 16);  ///< Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
        constexpr uint32_t ATTHIZ = (8 << 24);  ///< Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction:
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ECC = (32 << 0);  ///< ECC result This field contains the value computed by the ECC computation logic. Table167 describes the contents of these bit fields.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x420C0800;
    constexpr uint32_t SEC_RNG_BASE = 0x520C0800;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DR;  ///< Offset: 0x08 - data register
        volatile uint32_t HTCR;  ///< Offset: 0x10 - health test control register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);
    inline Registers* SEC_RNG = reinterpret_cast<Registers*>(SEC_RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CONFIGLOCK = (1U << 31);  ///< RNG Config Lock
        constexpr uint32_t CONDRST = (1U << 30);  ///< Conditioning soft reset
        constexpr uint32_t RNG_CONFIG1 = (6 << 20);  ///< RNG configuration 1
        constexpr uint32_t CLKDIV = (4 << 16);  ///< Clock divider factor
        constexpr uint32_t RNG_CONFIG2 = (3 << 13);  ///< RNG configuration 2
        constexpr uint32_t NISTC = (1U << 12);  ///< Non NIST compliant
        constexpr uint32_t RNG_CONFIG3 = (4 << 8);  ///< RNG configuration 3
        constexpr uint32_t ARDIS = (1U << 7);  ///< Auto reset disable
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt Enable
        constexpr uint32_t RNGEN = (1U << 2);  ///< True random number generator enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data
    }

    /// HTCR Register bits
    namespace htcr_bits {
        constexpr uint32_t HTCFG = (32 << 0);  ///< health test configuration
    }

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x420C0000;
    constexpr uint32_t SEC_AES_BASE = 0x520C0000;
    constexpr uint32_t SAES_BASE = 0x420C0C00;
    constexpr uint32_t SEC_SAES_BASE = 0x520C0C00;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DINR;  ///< Offset: 0x08 - data input register
        volatile uint32_t DOUTR;  ///< Offset: 0x0C - data output register
        volatile uint32_t KEYR0;  ///< Offset: 0x10 - key register 0
        volatile uint32_t KEYR1;  ///< Offset: 0x14 - key register 1
        volatile uint32_t KEYR2;  ///< Offset: 0x18 - key register 2
        volatile uint32_t KEYR3;  ///< Offset: 0x1C - key register 3
        volatile uint32_t IVR0;  ///< Offset: 0x20 - initialization vector register 0
        volatile uint32_t IVR1;  ///< Offset: 0x24 - initialization vector register 1
        volatile uint32_t IVR2;  ///< Offset: 0x28 - initialization vector register 2
        volatile uint32_t IVR3;  ///< Offset: 0x2C - initialization vector register 3
        volatile uint32_t KEYR4;  ///< Offset: 0x30 - key register 4
        volatile uint32_t KEYR5;  ///< Offset: 0x34 - key register 5
        volatile uint32_t KEYR6;  ///< Offset: 0x38 - key register 6
        volatile uint32_t KEYR7;  ///< Offset: 0x3C - key register 7
        volatile uint32_t SUSP0R;  ///< Offset: 0x40 - suspend registers
        volatile uint32_t SUSP1R;  ///< Offset: 0x44 - suspend registers
        volatile uint32_t SUSP2R;  ///< Offset: 0x48 - suspend registers
        volatile uint32_t SUSP3R;  ///< Offset: 0x4C - suspend registers
        volatile uint32_t SUSP4R;  ///< Offset: 0x50 - suspend registers
        volatile uint32_t SUSP5R;  ///< Offset: 0x54 - suspend registers
        volatile uint32_t SUSP6R;  ///< Offset: 0x58 - suspend registers
        volatile uint32_t SUSP7R;  ///< Offset: 0x5C - suspend registers
        volatile uint32_t IER;  ///< Offset: 0x300 - interrupt enable register
        volatile uint32_t ISR;  ///< Offset: 0x304 - interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x308 - interrupt clear register
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* SEC_AES = reinterpret_cast<Registers*>(SEC_AES_BASE);
    inline Registers* SAES = reinterpret_cast<Registers*>(SAES_BASE);
    inline Registers* SEC_SAES = reinterpret_cast<Registers*>(SEC_SAES_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t IPRST = (1U << 31);  ///< IPRST
        constexpr uint32_t KMOD = (2 << 24);  ///< KMOD
        constexpr uint32_t NPBLB = (4 << 20);  ///< NPBLB
        constexpr uint32_t KEYSIZE = (1U << 18);  ///< KEYSIZE
        constexpr uint32_t CHMOD_2 = (1U << 16);  ///< CHMOD_2
        constexpr uint32_t GCMPH = (2 << 13);  ///< GCMPH
        constexpr uint32_t DMAOUTEN = (1U << 12);  ///< Enable DMA management of data output phase
        constexpr uint32_t DMAINEN = (1U << 11);  ///< Enable DMA management of data input phase
        constexpr uint32_t CHMOD = (2 << 5);  ///< AES chaining mode
        constexpr uint32_t MODE = (2 << 3);  ///< AES operating mode
        constexpr uint32_t DATATYPE = (2 << 1);  ///< Data type selection (for data in and data out to/from the cryptographic block)
        constexpr uint32_t EN = (1U << 0);  ///< AES enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t KEYVALID = (1U << 7);  ///< Key Valid flag
        constexpr uint32_t BUSY = (1U << 3);  ///< BUSY
        constexpr uint32_t WRERR = (1U << 2);  ///< Write error flag
        constexpr uint32_t RDERR = (1U << 1);  ///< Read error flag
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag
    }

    /// DINR Register bits
    namespace dinr_bits {
        constexpr uint32_t DIN = (32 << 0);  ///< Input data word
    }

    /// DOUTR Register bits
    namespace doutr_bits {
        constexpr uint32_t DOUT = (32 << 0);  ///< Output data word
    }

    /// KEYR0 Register bits
    namespace keyr0_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [31:0]
    }

    /// KEYR1 Register bits
    namespace keyr1_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [63:32]
    }

    /// KEYR2 Register bits
    namespace keyr2_bits {
        constexpr uint32_t KEYR = (32 << 0);  ///< Cryptographic key, bits [95:64]
    }

    /// KEYR3 Register bits
    namespace keyr3_bits {
        constexpr uint32_t AES_KEYR3 = (32 << 0);  ///< Cryptographic key, bits [127:96]
    }

    /// IVR0 Register bits
    namespace ivr0_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [31:0]
    }

    /// IVR1 Register bits
    namespace ivr1_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [63:32]
    }

    /// IVR2 Register bits
    namespace ivr2_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [95:64]
    }

    /// IVR3 Register bits
    namespace ivr3_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [127:96]
    }

    /// KEYR4 Register bits
    namespace keyr4_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [159:128]
    }

    /// KEYR5 Register bits
    namespace keyr5_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [191:160]
    }

    /// KEYR6 Register bits
    namespace keyr6_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [223:192]
    }

    /// KEYR7 Register bits
    namespace keyr7_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [255:224]
    }

    /// SUSP0R Register bits
    namespace susp0r_bits {
        constexpr uint32_t SUSP0 = (32 << 0);  ///< AES suspend
    }

    /// SUSP1R Register bits
    namespace susp1r_bits {
        constexpr uint32_t SUSP1 = (32 << 0);  ///< AES suspend
    }

    /// SUSP2R Register bits
    namespace susp2r_bits {
        constexpr uint32_t SUSP2 = (32 << 0);  ///< AES suspend
    }

    /// SUSP3R Register bits
    namespace susp3r_bits {
        constexpr uint32_t SUSP3 = (32 << 0);  ///< AES suspend
    }

    /// SUSP4R Register bits
    namespace susp4r_bits {
        constexpr uint32_t SUSP4 = (32 << 0);  ///< AES suspend
    }

    /// SUSP5R Register bits
    namespace susp5r_bits {
        constexpr uint32_t SUSP5 = (32 << 0);  ///< AES suspend
    }

    /// SUSP6R Register bits
    namespace susp6r_bits {
        constexpr uint32_t SUSP6 = (32 << 0);  ///< AES suspend
    }

    /// SUSP7R Register bits
    namespace susp7r_bits {
        constexpr uint32_t SUSP7 = (32 << 0);  ///< AES suspend
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t RNGEIE = (1U << 3);  ///< Key error interrupt flag
        constexpr uint32_t KEIE = (1U << 2);  ///< Key error interrupt flag
        constexpr uint32_t RWEIE = (1U << 1);  ///< Read or write error interrupt flag
        constexpr uint32_t CCFIE = (1U << 0);  ///< Computation complete flag
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t RNGEIF = (1U << 3);  ///< Key error interrupt flag
        constexpr uint32_t KEIF = (1U << 2);  ///< Key error interrupt flag
        constexpr uint32_t RWEIF = (1U << 1);  ///< Read or write error interrupt flag
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t KEIF = (1U << 2);  ///< Key error interrupt flag clear
        constexpr uint32_t RWEIF = (1U << 1);  ///< Read or write error interrupt flag clear
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag clear
    }

}

// ============================================================================
// FMAC Peripheral
// ============================================================================

namespace fmac {
    /// Base addresses
    constexpr uint32_t FMAC_BASE = 0x40021400;

    /// FMAC Register structure
    struct Registers {
        volatile uint32_t X1BUFCFG;  ///< Offset: 0x00 - FMAC X1 Buffer Configuration register
        volatile uint32_t X2BUFCFG;  ///< Offset: 0x04 - FMAC X2 Buffer Configuration register
        volatile uint32_t YBUFCFG;  ///< Offset: 0x08 - FMAC Y Buffer Configuration register
        volatile uint32_t PARAM;  ///< Offset: 0x0C - FMAC Parameter register
        volatile uint32_t CR;  ///< Offset: 0x10 - FMAC Control register
        volatile uint32_t SR;  ///< Offset: 0x14 - FMAC Status register
        volatile uint32_t WDATA;  ///< Offset: 0x18 - FMAC Write Data register
        volatile uint32_t RDATA;  ///< Offset: 0x1C - FMAC Read Data register
    };

    /// Peripheral instances
    inline Registers* FMAC = reinterpret_cast<Registers*>(FMAC_BASE);

    // Bit definitions
    /// X1BUFCFG Register bits
    namespace x1bufcfg_bits {
        constexpr uint32_t X1_BASE = (8 << 0);  ///< Base address of X1 buffer
        constexpr uint32_t X1_BUF_SIZE = (8 << 8);  ///< Allocated size of X1 buffer in 16-bit words
        constexpr uint32_t FULL_WM = (2 << 24);  ///< Watermark for buffer full flag
    }

    /// X2BUFCFG Register bits
    namespace x2bufcfg_bits {
        constexpr uint32_t X2_BASE = (8 << 0);  ///< Base address of X2 buffer
        constexpr uint32_t X2_BUF_SIZE = (8 << 8);  ///< Size of X2 buffer in 16-bit words
    }

    /// YBUFCFG Register bits
    namespace ybufcfg_bits {
        constexpr uint32_t Y_BASE = (8 << 0);  ///< Base address of Y buffer
        constexpr uint32_t Y_BUF_SIZE = (8 << 8);  ///< Size of Y buffer in 16-bit words
        constexpr uint32_t EMPTY_WM = (2 << 24);  ///< Watermark for buffer empty flag
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t START = (1U << 31);  ///< Enable execution
        constexpr uint32_t FUNC = (7 << 24);  ///< Function
        constexpr uint32_t R = (8 << 16);  ///< Input parameter R
        constexpr uint32_t Q = (8 << 8);  ///< Input parameter Q
        constexpr uint32_t P = (8 << 0);  ///< Input parameter P
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESET = (1U << 16);  ///< Reset FMAC unit
        constexpr uint32_t CLIPEN = (1U << 15);  ///< Enable clipping
        constexpr uint32_t DMAWEN = (1U << 9);  ///< Enable DMA write channel requests
        constexpr uint32_t DMAREN = (1U << 8);  ///< Enable DMA read channel requests
        constexpr uint32_t SATIEN = (1U << 4);  ///< Enable saturation error interrupts
        constexpr uint32_t UNFLIEN = (1U << 3);  ///< Enable underflow error interrupts
        constexpr uint32_t OVFLIEN = (1U << 2);  ///< Enable overflow error interrupts
        constexpr uint32_t WIEN = (1U << 1);  ///< Enable write interrupt
        constexpr uint32_t RIEN = (1U << 0);  ///< Enable read interrupt
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t YEMPTY = (1U << 0);  ///< Y buffer empty flag
        constexpr uint32_t X1FULL = (1U << 1);  ///< X1 buffer full flag
        constexpr uint32_t OVFL = (1U << 8);  ///< Overflow error flag
        constexpr uint32_t UNFL = (1U << 9);  ///< Underflow error flag
        constexpr uint32_t SAT = (1U << 10);  ///< Saturation error flag
    }

    /// WDATA Register bits
    namespace wdata_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Write data
    }

    /// RDATA Register bits
    namespace rdata_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Read data
    }

}

// ============================================================================
// CORDIC Peripheral
// ============================================================================

namespace cordic {
    /// Base addresses
    constexpr uint32_t CORDIC_BASE = 0x40021000;

    /// CORDIC Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - CORDIC Control Status register
        volatile uint32_t WDATA;  ///< Offset: 0x04 - FMAC Write Data register
        volatile uint32_t RDATA;  ///< Offset: 0x08 - FMAC Read Data register
    };

    /// Peripheral instances
    inline Registers* CORDIC = reinterpret_cast<Registers*>(CORDIC_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t FUNC = (4 << 0);  ///< Function
        constexpr uint32_t PRECISION = (4 << 4);  ///< Precision required (number of iterations)
        constexpr uint32_t SCALE = (3 << 8);  ///< Scaling factor
        constexpr uint32_t IEN = (1U << 16);  ///< Enable interrupt
        constexpr uint32_t DMAREN = (1U << 17);  ///< Enable DMA read channel
        constexpr uint32_t DMAWEN = (1U << 18);  ///< Enable DMA write channel
        constexpr uint32_t NRES = (1U << 19);  ///< Number of results in the CORDIC_RDATA register
        constexpr uint32_t NARGS = (1U << 20);  ///< Number of arguments expected by the CORDIC_WDATA register
        constexpr uint32_t RESSIZE = (1U << 21);  ///< Width of output data
        constexpr uint32_t ARGSIZE = (1U << 22);  ///< Width of input data
        constexpr uint32_t RRDY = (1U << 31);  ///< Result ready flag
    }

    /// WDATA Register bits
    namespace wdata_bits {
        constexpr uint32_t ARG = (32 << 0);  ///< Function input arguments
    }

    /// RDATA Register bits
    namespace rdata_bits {
        constexpr uint32_t RES = (32 << 0);  ///< Function result
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC1_BASE = 0x46021800;
    constexpr uint32_t SEC_DAC1_BASE = 0x56021800;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t DAC_SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DAC_DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DAC_DHR12R2;  ///< Offset: 0x14 - DAC channel2 12-bit right aligned data holding register
        volatile uint32_t DAC_DHR12L2;  ///< Offset: 0x18 - DAC channel2 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R2;  ///< Offset: 0x1C - DAC channel2 8-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DAC_DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DAC_DOR2;  ///< Offset: 0x30 - DAC channel2 data output register
        volatile uint32_t DAC_SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t DAC_CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t DAC_MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t DAC_SHSR1;  ///< Offset: 0x40 - DAC Sample and Hold sample time register 1
        volatile uint32_t DAC_SHSR2;  ///< Offset: 0x44 - DAC channel2 sample and hold sample time register
        volatile uint32_t DAC_SHHR;  ///< Offset: 0x48 - DAC Sample and Hold hold time register
        volatile uint32_t DAC_SHRR;  ///< Offset: 0x4C - DAC Sample and Hold refresh time register
        volatile uint32_t DAC_AUTOCR;  ///< Offset: 0x54 - Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);
    inline Registers* SEC_DAC1 = reinterpret_cast<Registers*>(SEC_DAC1_BASE);

    // Bit definitions
    /// DAC_CR Register bits
    namespace dac_cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable
        constexpr uint32_t TSEL1 = (4 << 2);  ///< DAC channel1 trigger selection
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC channel1 calibration enable
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable
        constexpr uint32_t TEN2 = (1U << 17);  ///< DAC channel2 trigger enable
        constexpr uint32_t TSEL2 = (4 << 18);  ///< DAC channel2 trigger selection
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable
        constexpr uint32_t CEN2 = (1U << 30);  ///< DAC channel2 calibration enable
    }

    /// DAC_SWTRGR Register bits
    namespace dac_swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger
    }

    /// DAC_DHR12R1 Register bits
    namespace dac_dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
        constexpr uint32_t DACC1DHRB = (12 << 16);  ///< DAC channel1 12-bit right-aligned data B
    }

    /// DAC_DHR12L1 Register bits
    namespace dac_dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
        constexpr uint32_t DACC1DHRB = (12 << 20);  ///< DAC channel1 12-bit left-aligned data B
    }

    /// DAC_DHR8R1 Register bits
    namespace dac_dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
        constexpr uint32_t DACC1DHRB = (8 << 8);  ///< DAC channel1 8-bit right-aligned Sdata
    }

    /// DAC_DHR12R2 Register bits
    namespace dac_dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data
        constexpr uint32_t DACC2DHRB = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DAC_DHR12L2 Register bits
    namespace dac_dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data
        constexpr uint32_t DACC2DHRB = (12 << 20);  ///< DAC channel2 12-bit left-aligned data B
    }

    /// DAC_DHR8R2 Register bits
    namespace dac_dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data
        constexpr uint32_t DACC2DHRB = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DAC_DHR12RD Register bits
    namespace dac_dhr12rd_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DAC_DHR12LD Register bits
    namespace dac_dhr12ld_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data
    }

    /// DAC_DHR8RD Register bits
    namespace dac_dhr8rd_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DAC_DOR1 Register bits
    namespace dac_dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output
        constexpr uint32_t DACC1DORB = (12 << 16);  ///< DAC channel1 data output
    }

    /// DAC_DOR2 Register bits
    namespace dac_dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output
        constexpr uint32_t DACC2DORB = (12 << 16);  ///< DAC channel2 data output
    }

    /// DAC_SR Register bits
    namespace dac_sr_bits {
        constexpr uint32_t DAC1RDY = (1U << 11);  ///< DAC channel1 ready status bit
        constexpr uint32_t DORSTAT1 = (1U << 12);  ///< DAC channel1 output register status bit
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC Channel 1 calibration offset status
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC Channel 1 busy writing sample time flag
        constexpr uint32_t DAC2RDY = (1U << 27);  ///< DAC channel 2 ready status bit
        constexpr uint32_t DORSTAT2 = (1U << 28);  ///< DAC channel 2 output register status bit
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag
        constexpr uint32_t CAL_FLAG2 = (1U << 30);  ///< DAC Channel 2 calibration offset status
        constexpr uint32_t BWST2 = (1U << 31);  ///< DAC Channel 2 busy writing sample time flag
    }

    /// DAC_CCR Register bits
    namespace dac_ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC Channel 1 offset trimming value
        constexpr uint32_t OTRIM2 = (5 << 16);  ///< DAC Channel 2 offset trimming value
    }

    /// DAC_MCR Register bits
    namespace dac_mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC Channel 1 mode
        constexpr uint32_t DMADOUBLE1 = (1U << 8);  ///< DAC Channel1 DMA double data mode
        constexpr uint32_t SINFORMAT1 = (1U << 9);  ///< Enable signed format for DAC channel1
        constexpr uint32_t HFSEL = (2 << 14);  ///< High frequency interface mode selection
        constexpr uint32_t MODE2 = (3 << 16);  ///< DAC Channel 2 mode
        constexpr uint32_t DMADOUBLE2 = (1U << 24);  ///< DAC Channel2 DMA double data mode
        constexpr uint32_t SINFORMAT2 = (1U << 25);  ///< Enable signed format for DAC channel2
    }

    /// DAC_SHSR1 Register bits
    namespace dac_shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC Channel 1 sample Time (only valid in sample &amp; hold mode)
    }

    /// DAC_SHSR2 Register bits
    namespace dac_shsr2_bits {
        constexpr uint32_t TSAMPLE2 = (10 << 0);  ///< DAC Channel 2 sample Time (only valid in sample and hold mode)
    }

    /// DAC_SHHR Register bits
    namespace dac_shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC Channel 1 hold Time (only valid in sample and hold mode)
        constexpr uint32_t THOLD2 = (10 << 16);  ///< DAC Channel 2 hold time (only valid in sample and hold mode)
    }

    /// DAC_SHRR Register bits
    namespace dac_shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC Channel 1 refresh Time (only valid in sample and hold mode)
        constexpr uint32_t TREFRESH2 = (8 << 16);  ///< DAC Channel 2 refresh Time (only valid in sample and hold mode)
    }

    /// DAC_AUTOCR Register bits
    namespace dac_autocr_bits {
        constexpr uint32_t AUTOMODE = (1U << 22);  ///< DAC Autonomous mode
    }

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC1_BASE = 0x420C8000;
    constexpr uint32_t SEC_SDMMC1_BASE = 0x520C8000;
    constexpr uint32_t SDMMC2_BASE = 0x420C8C00;
    constexpr uint32_t SEC_SDMMC2_BASE = 0x520C8C00;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t POWER;  ///< Offset: 0x00 - power control register
        volatile uint32_t CLKCR;  ///< Offset: 0x04 - clock control register
        volatile uint32_t ARGR;  ///< Offset: 0x08 - argument register
        volatile uint32_t CMDR;  ///< Offset: 0x0C - command register
        volatile uint32_t RESPCMDR;  ///< Offset: 0x10 - command response register
        volatile uint32_t RESP1;  ///< Offset: 0x14 - response 1 register
        volatile uint32_t RESP2;  ///< Offset: 0x18 - response 2 register
        volatile uint32_t RESP3;  ///< Offset: 0x1C - response 3 register
        volatile uint32_t RESP4;  ///< Offset: 0x20 - response 4 register
        volatile uint32_t DTIMER;  ///< Offset: 0x24 - data timer register
        volatile uint32_t DLENR;  ///< Offset: 0x28 - data length register
        volatile uint32_t DCTRL;  ///< Offset: 0x2C - data control register
        volatile uint32_t DCNTR;  ///< Offset: 0x30 - data counter register
        volatile uint32_t STAR;  ///< Offset: 0x34 - status register
        volatile uint32_t ICR;  ///< Offset: 0x38 - interrupt clear register
        volatile uint32_t MASKR;  ///< Offset: 0x3C - mask register
        volatile uint32_t ACKTIMER;  ///< Offset: 0x40 - acknowledgment timer register
        volatile uint32_t FIFOR0;  ///< Offset: 0x80 - data FIFO register 0
        volatile uint32_t FIFOR1;  ///< Offset: 0x84 - data FIFO register 1
        volatile uint32_t FIFOR2;  ///< Offset: 0x88 - data FIFO register 2
        volatile uint32_t FIFOR3;  ///< Offset: 0x8C - data FIFO register 3
        volatile uint32_t FIFOR4;  ///< Offset: 0x90 - data FIFO register 4
        volatile uint32_t FIFOR5;  ///< Offset: 0x94 - data FIFO register 5
        volatile uint32_t FIFOR6;  ///< Offset: 0x98 - data FIFO register 6
        volatile uint32_t FIFOR7;  ///< Offset: 0x9C - data FIFO register 7
        volatile uint32_t FIFOR8;  ///< Offset: 0xA0 - data FIFO register 8
        volatile uint32_t FIFOR9;  ///< Offset: 0xA4 - data FIFO register 9
        volatile uint32_t FIFOR10;  ///< Offset: 0xA8 - data FIFO register 10
        volatile uint32_t FIFOR11;  ///< Offset: 0xAC - data FIFO register 11
        volatile uint32_t FIFOR12;  ///< Offset: 0xB0 - data FIFO register 12
        volatile uint32_t FIFOR13;  ///< Offset: 0xB4 - data FIFO register 13
        volatile uint32_t FIFOR14;  ///< Offset: 0xB8 - data FIFO register 14
        volatile uint32_t FIFOR15;  ///< Offset: 0xBC - data FIFO register 15
        volatile uint32_t SDMMC_IDMACTRLR;  ///< Offset: 0x50 - DMA control register
        volatile uint32_t SDMMC_IDMABSIZER;  ///< Offset: 0x54 - buffer size register
        volatile uint32_t SDMMC_IDMABASER;  ///< Offset: 0x58 - buffer base address register
        volatile uint32_t SDMMC_IDMALAR;  ///< Offset: 0x64 - linked list address register
        volatile uint32_t SDMMC_IDMABAR;  ///< Offset: 0x68 - linked list memory base register
    };

    /// Peripheral instances
    inline Registers* SDMMC1 = reinterpret_cast<Registers*>(SDMMC1_BASE);
    inline Registers* SEC_SDMMC1 = reinterpret_cast<Registers*>(SEC_SDMMC1_BASE);
    inline Registers* SDMMC2 = reinterpret_cast<Registers*>(SDMMC2_BASE);
    inline Registers* SEC_SDMMC2 = reinterpret_cast<Registers*>(SEC_SDMMC2_BASE);

    // Bit definitions
    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t PWRCTRL = (2 << 0);  ///< SDMMC state control bits
        constexpr uint32_t VSWITCH = (1U << 2);  ///< Voltage switch sequence start
        constexpr uint32_t VSWITCHEN = (1U << 3);  ///< Voltage switch procedure enable
        constexpr uint32_t DIRPOL = (1U << 4);  ///< Data and command direction signals polarity selection
    }

    /// CLKCR Register bits
    namespace clkcr_bits {
        constexpr uint32_t SELCLKRX = (2 << 20);  ///< Receive clock selection
        constexpr uint32_t BUSSPEED = (1U << 19);  ///< Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50,DDR50, SDR104
        constexpr uint32_t DDR = (1U << 18);  ///< Data rate signaling selection
        constexpr uint32_t HWFC_EN = (1U << 17);  ///< HW Flow Control enable
        constexpr uint32_t NEGEDGE = (1U << 16);  ///< SDIO_CK dephasing selection bit
        constexpr uint32_t WIDBUS = (2 << 14);  ///< Wide bus mode enable bit
        constexpr uint32_t PWRSAV = (1U << 12);  ///< Power saving configuration bit
        constexpr uint32_t CLKDIV = (10 << 0);  ///< Clock divide factor
    }

    /// ARGR Register bits
    namespace argr_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command argument
    }

    /// CMDR Register bits
    namespace cmdr_bits {
        constexpr uint32_t CMDSUSPEND = (1U << 16);  ///< The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end
        constexpr uint32_t BOOTEN = (1U << 15);  ///< Enable boot mode procedure
        constexpr uint32_t BOOTMODE = (1U << 14);  ///< Select the boot mode procedure to be used
        constexpr uint32_t DTHOLD = (1U << 13);  ///< Hold new data block transmission and reception in the DPSM
        constexpr uint32_t CPSMEN = (1U << 12);  ///< Command path state machine (CPSM) Enable bit
        constexpr uint32_t WAITPEND = (1U << 11);  ///< CPSM Waits for ends of data transfer (CmdPend internal signal) from DPSM
        constexpr uint32_t WAITINT = (1U << 10);  ///< CPSM waits for interrupt request
        constexpr uint32_t WAITRESP = (2 << 8);  ///< Wait for response bits
        constexpr uint32_t CMDSTOP = (1U << 7);  ///< The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM
        constexpr uint32_t CMDTRANS = (1U << 6);  ///< The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM
        constexpr uint32_t CMDINDEX = (6 << 0);  ///< Command index
    }

    /// RESPCMDR Register bits
    namespace respcmdr_bits {
        constexpr uint32_t RESPCMD = (6 << 0);  ///< Response command index
    }

    /// RESP1 Register bits
    namespace resp1_bits {
        constexpr uint32_t CARDSTATUS1 = (32 << 0);  ///< CARDSTATUS1
    }

    /// RESP2 Register bits
    namespace resp2_bits {
        constexpr uint32_t CARDSTATUS2 = (32 << 0);  ///< CARDSTATUS2
    }

    /// RESP3 Register bits
    namespace resp3_bits {
        constexpr uint32_t CARDSTATUS3 = (32 << 0);  ///< CARDSTATUS3
    }

    /// RESP4 Register bits
    namespace resp4_bits {
        constexpr uint32_t CARDSTATUS4 = (32 << 0);  ///< CARDSTATUS4
    }

    /// DTIMER Register bits
    namespace dtimer_bits {
        constexpr uint32_t DATATIME = (32 << 0);  ///< Data and R1b busy timeout period
    }

    /// DLENR Register bits
    namespace dlenr_bits {
        constexpr uint32_t DATALENGTH = (25 << 0);  ///< Data length value
    }

    /// DCTRL Register bits
    namespace dctrl_bits {
        constexpr uint32_t FIFORST = (1U << 13);  ///< FIFO reset, will flush any remaining data
        constexpr uint32_t BOOTACKEN = (1U << 12);  ///< Enable the reception of the boot acknowledgment
        constexpr uint32_t SDIOEN = (1U << 11);  ///< SD I/O enable functions
        constexpr uint32_t RWMOD = (1U << 10);  ///< Read wait mode
        constexpr uint32_t RWSTOP = (1U << 9);  ///< Read wait stop
        constexpr uint32_t RWSTART = (1U << 8);  ///< Read wait start
        constexpr uint32_t DBLOCKSIZE = (4 << 4);  ///< Data block size
        constexpr uint32_t DTMODE = (2 << 2);  ///< Data transfer mode selection
        constexpr uint32_t DTDIR = (1U << 1);  ///< Data transfer direction selection
        constexpr uint32_t DTEN = (1U << 0);  ///< DTEN
    }

    /// DCNTR Register bits
    namespace dcntr_bits {
        constexpr uint32_t DATACOUNT = (25 << 0);  ///< Data count value
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t IDMABTC = (1U << 28);  ///< IDMA buffer transfer complete
        constexpr uint32_t IDMATE = (1U << 27);  ///< IDMA transfer error
        constexpr uint32_t CKSTOP = (1U << 26);  ///< SDMMC_CK stopped in Voltage switch procedure
        constexpr uint32_t VSWEND = (1U << 25);  ///< Voltage switch critical timing section completion
        constexpr uint32_t ACKTIMEOUT = (1U << 24);  ///< Boot acknowledgment timeout
        constexpr uint32_t ACKFAIL = (1U << 23);  ///< Boot acknowledgment received (boot acknowledgment check fail)
        constexpr uint32_t SDIOIT = (1U << 22);  ///< SDIO interrupt received
        constexpr uint32_t BUSYD0END = (1U << 21);  ///< end of SDMMC_D0 Busy following a CMD response detected
        constexpr uint32_t BUSYD0 = (1U << 20);  ///< Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response
        constexpr uint32_t RXFIFOE = (1U << 19);  ///< Receive FIFO empty
        constexpr uint32_t TXFIFOE = (1U << 18);  ///< Transmit FIFO empty
        constexpr uint32_t RXFIFOF = (1U << 17);  ///< Receive FIFO full
        constexpr uint32_t TXFIFOF = (1U << 16);  ///< Transmit FIFO full
        constexpr uint32_t RXFIFOHF = (1U << 15);  ///< Receive FIFO half full
        constexpr uint32_t TXFIFOHE = (1U << 14);  ///< Transmit FIFO half empty
        constexpr uint32_t CPSMACT = (1U << 13);  ///< Command path state machine active, i.e. not in Idle state
        constexpr uint32_t DPSMACT = (1U << 12);  ///< Data path state machine active, i.e. not in Idle state
        constexpr uint32_t DABORT = (1U << 11);  ///< Data transfer aborted by CMD12
        constexpr uint32_t DBCKEND = (1U << 10);  ///< Data block sent/received
        constexpr uint32_t DHOLD = (1U << 9);  ///< Data transfer Hold
        constexpr uint32_t DATAEND = (1U << 8);  ///< Data transfer ended correctly
        constexpr uint32_t CMDSENT = (1U << 7);  ///< Command sent (no response required)
        constexpr uint32_t CMDREND = (1U << 6);  ///< Command response received (CRC check passed, or no CRC)
        constexpr uint32_t RXOVERR = (1U << 5);  ///< Received FIFO overrun error (masked by hardware when IDMA is enabled)
        constexpr uint32_t TXUNDERR = (1U << 4);  ///< Transmit FIFO underrun error (masked by hardware when IDMA is enabled)
        constexpr uint32_t DTIMEOUT = (1U << 3);  ///< Data timeout
        constexpr uint32_t CTIMEOUT = (1U << 2);  ///< Command response timeout
        constexpr uint32_t DCRCFAIL = (1U << 1);  ///< Data block sent/received (CRC check failed)
        constexpr uint32_t CCRCFAIL = (1U << 0);  ///< Command response received (CRC check failed)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t IDMABTCC = (1U << 28);  ///< IDMA buffer transfer complete clear bit
        constexpr uint32_t IDMATEC = (1U << 27);  ///< IDMA transfer error clear bit
        constexpr uint32_t CKSTOPC = (1U << 26);  ///< CKSTOP flag clear bit
        constexpr uint32_t VSWENDC = (1U << 25);  ///< VSWEND flag clear bit
        constexpr uint32_t ACKTIMEOUTC = (1U << 24);  ///< ACKTIMEOUT flag clear bit
        constexpr uint32_t ACKFAILC = (1U << 23);  ///< ACKFAIL flag clear bit
        constexpr uint32_t SDIOITC = (1U << 22);  ///< SDIOIT flag clear bit
        constexpr uint32_t BUSYD0ENDC = (1U << 21);  ///< BUSYD0END flag clear bit
        constexpr uint32_t DABORTC = (1U << 11);  ///< DABORT flag clear bit
        constexpr uint32_t DBCKENDC = (1U << 10);  ///< DBCKEND flag clear bit
        constexpr uint32_t DHOLDC = (1U << 9);  ///< DHOLD flag clear bit
        constexpr uint32_t DATAENDC = (1U << 8);  ///< DATAEND flag clear bit
        constexpr uint32_t CMDSENTC = (1U << 7);  ///< CMDSENT flag clear bit
        constexpr uint32_t CMDRENDC = (1U << 6);  ///< CMDREND flag clear bit
        constexpr uint32_t RXOVERRC = (1U << 5);  ///< RXOVERR flag clear bit
        constexpr uint32_t TXUNDERRC = (1U << 4);  ///< TXUNDERR flag clear bit
        constexpr uint32_t DTIMEOUTC = (1U << 3);  ///< DTIMEOUT flag clear bit
        constexpr uint32_t CTIMEOUTC = (1U << 2);  ///< CTIMEOUT flag clear bit
        constexpr uint32_t DCRCFAILC = (1U << 1);  ///< DCRCFAIL flag clear bit
        constexpr uint32_t CCRCFAILC = (1U << 0);  ///< CCRCFAIL flag clear bit
    }

    /// MASKR Register bits
    namespace maskr_bits {
        constexpr uint32_t IDMABTCIE = (1U << 28);  ///< IDMA buffer transfer complete interrupt enable
        constexpr uint32_t CKSTOPIE = (1U << 26);  ///< Voltage Switch clock stopped interrupt enable
        constexpr uint32_t VSWENDIE = (1U << 25);  ///< Voltage switch critical timing section completion interrupt enable
        constexpr uint32_t ACKTIMEOUTIE = (1U << 24);  ///< Acknowledgment timeout interrupt enable
        constexpr uint32_t ACKFAILIE = (1U << 23);  ///< Acknowledgment Fail interrupt enable
        constexpr uint32_t SDIOITIE = (1U << 22);  ///< SDIO mode interrupt received interrupt enable
        constexpr uint32_t BUSYD0ENDIE = (1U << 21);  ///< BUSYD0END interrupt enable
        constexpr uint32_t TXFIFOEIE = (1U << 18);  ///< Tx FIFO empty interrupt enable
        constexpr uint32_t RXFIFOFIE = (1U << 17);  ///< Rx FIFO full interrupt enable
        constexpr uint32_t RXFIFOHFIE = (1U << 15);  ///< Rx FIFO half full interrupt enable
        constexpr uint32_t TXFIFOHEIE = (1U << 14);  ///< Tx FIFO half empty interrupt enable
        constexpr uint32_t DABORTIE = (1U << 11);  ///< Data transfer aborted interrupt enable
        constexpr uint32_t DBCKENDIE = (1U << 10);  ///< Data block end interrupt enable
        constexpr uint32_t DHOLDIE = (1U << 9);  ///< Data hold interrupt enable
        constexpr uint32_t DATAENDIE = (1U << 8);  ///< Data end interrupt enable
        constexpr uint32_t CMDSENTIE = (1U << 7);  ///< Command sent interrupt enable
        constexpr uint32_t CMDRENDIE = (1U << 6);  ///< Command response received interrupt enable
        constexpr uint32_t RXOVERRIE = (1U << 5);  ///< Rx FIFO overrun error interrupt enable
        constexpr uint32_t TXUNDERRIE = (1U << 4);  ///< Tx FIFO underrun error interrupt enable
        constexpr uint32_t DTIMEOUTIE = (1U << 3);  ///< Data timeout interrupt enable
        constexpr uint32_t CTIMEOUTIE = (1U << 2);  ///< Command timeout interrupt enable
        constexpr uint32_t DCRCFAILIE = (1U << 1);  ///< Data CRC fail interrupt enable
        constexpr uint32_t CCRCFAILIE = (1U << 0);  ///< Command CRC fail interrupt enable
    }

    /// ACKTIMER Register bits
    namespace acktimer_bits {
        constexpr uint32_t ACKTIME = (25 << 0);  ///< Boot acknowledgment timeout period
    }

    /// FIFOR0 Register bits
    namespace fifor0_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR1 Register bits
    namespace fifor1_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR2 Register bits
    namespace fifor2_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR3 Register bits
    namespace fifor3_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR4 Register bits
    namespace fifor4_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR5 Register bits
    namespace fifor5_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR6 Register bits
    namespace fifor6_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR7 Register bits
    namespace fifor7_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR8 Register bits
    namespace fifor8_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR9 Register bits
    namespace fifor9_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR10 Register bits
    namespace fifor10_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR11 Register bits
    namespace fifor11_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR12 Register bits
    namespace fifor12_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR13 Register bits
    namespace fifor13_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR14 Register bits
    namespace fifor14_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR15 Register bits
    namespace fifor15_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// SDMMC_IDMACTRLR Register bits
    namespace sdmmc_idmactrlr_bits {
        constexpr uint32_t IDMAEN = (1U << 0);  ///< IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABMODE = (1U << 1);  ///< Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    }

    /// SDMMC_IDMABSIZER Register bits
    namespace sdmmc_idmabsizer_bits {
        constexpr uint32_t IDMABNDT = (12 << 5);  ///< Number of bytes per buffer
    }

    /// SDMMC_IDMABASER Register bits
    namespace sdmmc_idmabaser_bits {
        constexpr uint32_t IDMABASE = (32 << 0);  ///< Buffer memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only)
    }

    /// SDMMC_IDMALAR Register bits
    namespace sdmmc_idmalar_bits {
        constexpr uint32_t ULA = (1U << 31);  ///< Update SDMMC_IDMALAR from linked list when in linked list mode (SDMMC_IDMACTRLR.IDMABMODE select linked list mode)
        constexpr uint32_t ULS = (1U << 30);  ///< Update SDMMC_IDMABSIZE from the next linked list when in linked list mode (SDMMC_IDMACTRLR.IDMABMODE select linked list mode and ULA = 1)
        constexpr uint32_t ABR = (1U << 29);  ///< Acknowledge linked list buffer ready
        constexpr uint32_t IDMALA = (14 << 2);  ///< Acknowledge linked list buffer ready
    }

    /// SDMMC_IDMABAR Register bits
    namespace sdmmc_idmabar_bits {
        constexpr uint32_t IDMABA = (30 << 2);  ///< Word aligned Linked list memory base address
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x46005000;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t OPAMP1_CSR;  ///< Offset: 0x00 - OPAMP1 control/status register
        volatile uint32_t OPAMP1_OTR;  ///< Offset: 0x04 - OPAMP1 offset trimming register in normal mode
        volatile uint32_t OPAMP1_LPOTR;  ///< Offset: 0x08 - OPAMP1 offset trimming register in low-power mode
        volatile uint32_t OPAMP2_CRS;  ///< Offset: 0x10 - OPAMP2 control/status register
        volatile uint32_t OPAMP2_OTR;  ///< Offset: 0x14 - OPAMP2 offset trimming register in normal mode
        volatile uint32_t OPAMP2_LPOTR;  ///< Offset: 0x18 - OPAMP2 offset trimming register in low-power mode
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// OPAMP1_CSR Register bits
    namespace opamp1_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< OPAMP enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< OPAMP low-power mode The OPAMP must be disabled to change this configuration.
        constexpr uint32_t OPAMODE = (2 << 2);  ///< OPAMP PGA mode 00 and 01: internal PGA disabled
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< OPAMP programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< Inverting input selection These bits are used only when OPAMODE = 00, 01 or 10. 1x: inverting input not externally connected
        constexpr uint32_t VP_SEL = (1U << 10);  ///< Non-inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< Calibration mode enable
        constexpr uint32_t CALSEL = (1U << 13);  ///< Calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< factory or user offset trimmed values selection This bit is active for normal and low-power modes.
        constexpr uint32_t CALOUT = (1U << 15);  ///< OPAMP calibration output During the calibration mode, the offset is trimmed when this signal toggles.
        constexpr uint32_t OPAHSM = (1U << 30);  ///< OPAMP high-speed mode This bit is effective for both normal and low-power modes.
        constexpr uint32_t OPA_RANGE = (1U << 31);  ///< OPAMP range setting This bit must be set before enabling the OPAMP and this bit affects all OPAMP instances.
    }

    /// OPAMP1_OTR Register bits
    namespace opamp1_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP1_LPOTR Register bits
    namespace opamp1_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Low-power mode trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Low-power mode trim for PMOS differential pairs
    }

    /// OPAMP2_CRS Register bits
    namespace opamp2_crs_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< OPAMP enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< OPAMP low-power mode The OPAMP must be disabled to change this configuration.
        constexpr uint32_t OPAMODE = (2 << 2);  ///< OPAMP PGA mode 00 and 01: internal PGA disabled
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< OPAMP programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< Inverting input selection These bits are used only when OPAMODE = 00, 01 or 10. in PGA mode for filtering) 1x: inverting input not externally connected
        constexpr uint32_t VP_SEL = (1U << 10);  ///< Non inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< Calibration mode enable
        constexpr uint32_t CALSEL = (1U << 13);  ///< Calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< factory or user offset trimmed values selection This bit is active for normal and low-power modes.
        constexpr uint32_t CALOUT = (1U << 15);  ///< OPAMP calibration output During calibration mode, the offset is trimmed when this signal toggles.
        constexpr uint32_t OPAHSM = (1U << 30);  ///< OPAMP high-speed mode This bit is effective for both normal and high-speed modes.
    }

    /// OPAMP2_OTR Register bits
    namespace opamp2_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP2_LPOTR Register bits
    namespace opamp2_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Low-power mode trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Low-power mode trim for PMOS differential pairs
    }

}

// ============================================================================
// DLYBOS1 Peripheral
// ============================================================================

namespace dlybos1 {
    /// Base addresses
    constexpr uint32_t DLYBOS1_BASE = 0x420CF000;

    /// DLYBOS1 Register structure
    struct Registers {
        volatile uint32_t DLYB_CR;  ///< Offset: 0x00 - control register
        volatile uint32_t DLYB_CFGR;  ///< Offset: 0x04 - configuration register
    };

    /// Peripheral instances
    inline Registers* DLYBOS1 = reinterpret_cast<Registers*>(DLYBOS1_BASE);

    // Bit definitions
    /// DLYB_CR Register bits
    namespace dlyb_cr_bits {
        constexpr uint32_t DEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t SEN = (1U << 1);  ///< OPALPM
    }

    /// DLYB_CFGR Register bits
    namespace dlyb_cfgr_bits {
        constexpr uint32_t SEL = (4 << 0);  ///< SEL
        constexpr uint32_t UNIT = (7 << 8);  ///< UNIT
        constexpr uint32_t LNG = (12 << 16);  ///< LNG
        constexpr uint32_t LNGF = (1U << 31);  ///< LNGF
    }

}

// ============================================================================
// DLYBOS2 Peripheral
// ============================================================================

namespace dlybos2 {
    /// Base addresses
    constexpr uint32_t DLYBOS2_BASE = 0x420CF400;

    /// DLYBOS2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DLYBOS2 = reinterpret_cast<Registers*>(DLYBOS2_BASE);

}

// ============================================================================
// DLYBSD1 Peripheral
// ============================================================================

namespace dlybsd1 {
    /// Base addresses
    constexpr uint32_t DLYBSD1_BASE = 0x420C8400;

    /// DLYBSD1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DLYBSD1 = reinterpret_cast<Registers*>(DLYBSD1_BASE);

}

// ============================================================================
// DLYBSD2 Peripheral
// ============================================================================

namespace dlybsd2 {
    /// Base addresses
    constexpr uint32_t DLYBSD2_BASE = 0x420C8800;

    /// DLYBSD2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DLYBSD2 = reinterpret_cast<Registers*>(DLYBSD2_BASE);

}

// ============================================================================
// OTG Peripheral
// ============================================================================

namespace otg {
    /// Base addresses
    constexpr uint32_t OTG_FS_BASE = 0x42040000;

    /// OTG Register structure
    struct Registers {
        volatile uint32_t GOTGCTL;  ///< Offset: 0x00 - The GOTGCTL register controls the behavior and reflects...
        volatile uint32_t GOTGINT;  ///< Offset: 0x04 - The application reads this register whenever there is an...
        volatile uint32_t GAHBCFG;  ///< Offset: 0x08 - This register can be used to configure the core after...
        volatile uint32_t GUSBCFG;  ///< Offset: 0x0C - This register can be used to configure the core after...
        volatile uint32_t GRSTCTL;  ///< Offset: 0x10 - The application uses this register to reset various...
        volatile uint32_t GINTSTS;  ///< Offset: 0x14 - This register interrupts the application for...
        volatile uint32_t GINTMSK;  ///< Offset: 0x18 - This register works with the core interrupt register to...
        volatile uint32_t GRXSTSR_DEVICE;  ///< Offset: 0x1C - This description is for register GRXSTSR in Device mode....
        volatile uint32_t GRXSTSR_HOST;  ///< Offset: 0x1C - This description is for register GRXSTSR in Host mode
        volatile uint32_t GRXSTSP_DEVICE;  ///< Offset: 0x20 - This description is for register GRXSTSP in Device mode....
        volatile uint32_t GRXSTSP_HOST;  ///< Offset: 0x20 - This description is for register GRXSTSP in HOST mode
        volatile uint32_t GRXFSIZ;  ///< Offset: 0x24 - The application can program the RAM size that must be...
        volatile uint32_t HNPTXFSIZ;  ///< Offset: 0x28 - Host mode
        volatile uint32_t HNPTXSTS;  ///< Offset: 0x2C - In device mode, this register is not valid. This...
        volatile uint32_t GCCFG;  ///< Offset: 0x38 - OTG general core configuration register
        volatile uint32_t CID;  ///< Offset: 0x3C - This is a register containing the Product ID as reset value.
        volatile uint32_t GLPMCFG;  ///< Offset: 0x54 - OTG core LPM configuration register
        volatile uint32_t HPTXFSIZ;  ///< Offset: 0x100 - OTG host periodic transmit FIFO size register
        volatile uint32_t DIEPTXF1;  ///< Offset: 0x104 - OTG device IN endpoint transmit FIFO 1 size register
        volatile uint32_t DIEPTXF2;  ///< Offset: 0x108 - OTG device IN endpoint transmit FIFO 2 size register
        volatile uint32_t DIEPTXF3;  ///< Offset: 0x10C - OTG device IN endpoint transmit FIFO 3 size register
        volatile uint32_t DIEPTXF4;  ///< Offset: 0x110 - OTG device IN endpoint transmit FIFO 4 size register
        volatile uint32_t DIEPTXF5;  ///< Offset: 0x114 - OTG device IN endpoint transmit FIFO 5 size register
        volatile uint32_t HCFG;  ///< Offset: 0x400 - This register configures the core after power-on. Do not...
        volatile uint32_t HFIR;  ///< Offset: 0x404 - This register stores the frame interval information for...
        volatile uint32_t HFNUM;  ///< Offset: 0x408 - This register indicates the current frame number. It...
        volatile uint32_t HPTXSTS;  ///< Offset: 0x410 - This read-only register contains the free space...
        volatile uint32_t HAINT;  ///< Offset: 0x414 - When a significant event occurs on a channel, the host...
        volatile uint32_t HAINTMSK;  ///< Offset: 0x418 - The host all channel interrupt mask register works with...
        volatile uint32_t HPRT;  ///< Offset: 0x440 - This register is available only in host mode. Currently,...
        volatile uint32_t HCCHAR0;  ///< Offset: 0x500 - OTG host channel 0 characteristics register
        volatile uint32_t HCINT0;  ///< Offset: 0x508 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK0;  ///< Offset: 0x50C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ0;  ///< Offset: 0x510 - OTG host channel 0 transfer size register
        volatile uint32_t HCCHAR1;  ///< Offset: 0x520 - OTG host channel 1 characteristics register
        volatile uint32_t HCINT1;  ///< Offset: 0x528 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK1;  ///< Offset: 0x52C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ1;  ///< Offset: 0x530 - OTG host channel 1 transfer size register
        volatile uint32_t HCCHAR2;  ///< Offset: 0x540 - OTG host channel 2 characteristics register
        volatile uint32_t HCINT2;  ///< Offset: 0x548 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK2;  ///< Offset: 0x54C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ2;  ///< Offset: 0x550 - OTG host channel 2 transfer size register
        volatile uint32_t HCCHAR3;  ///< Offset: 0x560 - OTG host channel 3 characteristics register
        volatile uint32_t HCINT3;  ///< Offset: 0x568 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK3;  ///< Offset: 0x56C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ3;  ///< Offset: 0x570 - OTG host channel 3 transfer size register
        volatile uint32_t HCCHAR4;  ///< Offset: 0x580 - OTG host channel 4 characteristics register
        volatile uint32_t HCINT4;  ///< Offset: 0x588 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK4;  ///< Offset: 0x58C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ4;  ///< Offset: 0x590 - OTG host channel 4 transfer size register
        volatile uint32_t HCCHAR5;  ///< Offset: 0x5A0 - OTG host channel 5 characteristics register
        volatile uint32_t HCINT5;  ///< Offset: 0x5A8 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK5;  ///< Offset: 0x5AC - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ5;  ///< Offset: 0x5B0 - OTG host channel 5 transfer size register
        volatile uint32_t HCCHAR6;  ///< Offset: 0x5C0 - OTG host channel 6 characteristics register
        volatile uint32_t HCINT6;  ///< Offset: 0x5C8 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK6;  ///< Offset: 0x5CC - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ6;  ///< Offset: 0x5D0 - OTG host channel 6 transfer size register
        volatile uint32_t HCCHAR7;  ///< Offset: 0x5E0 - OTG host channel 7 characteristics register
        volatile uint32_t HCINT7;  ///< Offset: 0x5E8 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK7;  ///< Offset: 0x5EC - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ7;  ///< Offset: 0x5F0 - OTG host channel 7 transfer size register
        volatile uint32_t HCCHAR8;  ///< Offset: 0x600 - OTG host channel 8 characteristics register
        volatile uint32_t HCINT8;  ///< Offset: 0x608 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK8;  ///< Offset: 0x60C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ8;  ///< Offset: 0x610 - OTG host channel 8 transfer size register
        volatile uint32_t HCCHAR9;  ///< Offset: 0x620 - OTG host channel 9 characteristics register
        volatile uint32_t HCINT9;  ///< Offset: 0x628 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK9;  ///< Offset: 0x62C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ9;  ///< Offset: 0x630 - OTG host channel 9 transfer size register
        volatile uint32_t HCCHAR10;  ///< Offset: 0x640 - OTG host channel 10 characteristics register
        volatile uint32_t HCINT10;  ///< Offset: 0x648 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK10;  ///< Offset: 0x64C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ10;  ///< Offset: 0x650 - OTG host channel 10 transfer size register
        volatile uint32_t HCCHAR11;  ///< Offset: 0x660 - OTG host channel 11 characteristics register
        volatile uint32_t HCINT11;  ///< Offset: 0x668 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK11;  ///< Offset: 0x66C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ11;  ///< Offset: 0x670 - OTG host channel 11 transfer size register
        volatile uint32_t DCFG;  ///< Offset: 0x800 - This register configures the core in device mode after...
        volatile uint32_t DCTL;  ///< Offset: 0x804 - OTG device control register
        volatile uint32_t DSTS;  ///< Offset: 0x808 - This register indicates the status of the core with...
        volatile uint32_t DIEPMSK;  ///< Offset: 0x810 - This register works with each of the DIEPINTx registers...
        volatile uint32_t DOEPMSK;  ///< Offset: 0x814 - This register works with each of the DOEPINTx registers...
        volatile uint32_t DAINT;  ///< Offset: 0x818 - When a significant event occurs on an endpoint, a DAINT...
        volatile uint32_t DAINTMSK;  ///< Offset: 0x81C - The DAINTMSK register works with the device endpoint...
        volatile uint32_t DVBUSDIS;  ///< Offset: 0x828 - This register specifies the VBUS discharge time after...
        volatile uint32_t DVBUSPULSE;  ///< Offset: 0x82C - This register specifies the VBUS pulsing time during SRP.
        volatile uint32_t DIEPEMPMSK;  ///< Offset: 0x834 - This register is used to control the IN endpoint FIFO...
        volatile uint32_t DIEPCTL0;  ///< Offset: 0x900 - The application uses this register to control the...
        volatile uint32_t DIEPINT0;  ///< Offset: 0x908 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ0;  ///< Offset: 0x910 - The application must modify this register before...
        volatile uint32_t DTXFSTS0;  ///< Offset: 0x918 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL1;  ///< Offset: 0x920 - The application uses this register to control the...
        volatile uint32_t DIEPINT1;  ///< Offset: 0x928 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ1;  ///< Offset: 0x930 - The application must modify this register before...
        volatile uint32_t DTXFSTS1;  ///< Offset: 0x938 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL2;  ///< Offset: 0x940 - The application uses this register to control the...
        volatile uint32_t DIEPINT2;  ///< Offset: 0x948 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ2;  ///< Offset: 0x950 - The application must modify this register before...
        volatile uint32_t DTXFSTS2;  ///< Offset: 0x958 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL3;  ///< Offset: 0x960 - The application uses this register to control the...
        volatile uint32_t DIEPINT3;  ///< Offset: 0x968 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ3;  ///< Offset: 0x970 - The application must modify this register before...
        volatile uint32_t DTXFSTS3;  ///< Offset: 0x978 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL4;  ///< Offset: 0x980 - The application uses this register to control the...
        volatile uint32_t DIEPINT4;  ///< Offset: 0x988 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ4;  ///< Offset: 0x990 - The application must modify this register before...
        volatile uint32_t DTXFSTS4;  ///< Offset: 0x998 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL5;  ///< Offset: 0x9A0 - The application uses this register to control the...
        volatile uint32_t DIEPINT5;  ///< Offset: 0x9A8 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ5;  ///< Offset: 0x9B0 - The application must modify this register before...
        volatile uint32_t DTXFSTS5;  ///< Offset: 0x9B8 - This read-only register contains the free space...
        volatile uint32_t DOEPCTL0;  ///< Offset: 0xB00 - This section describes the DOEPCTL0 register.
        volatile uint32_t DOEPINT0;  ///< Offset: 0xB08 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ0;  ///< Offset: 0xB10 - The application must modify this register before...
        volatile uint32_t DOEPCTL1;  ///< Offset: 0xB20 - The application uses this register to control the...
        volatile uint32_t DOEPINT1;  ///< Offset: 0xB28 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ1;  ///< Offset: 0xB30 - The application must modify this register before...
        volatile uint32_t DOEPCTL2;  ///< Offset: 0xB40 - The application uses this register to control the...
        volatile uint32_t DOEPINT2;  ///< Offset: 0xB48 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ2;  ///< Offset: 0xB50 - The application must modify this register before...
        volatile uint32_t DOEPCTL3;  ///< Offset: 0xB60 - The application uses this register to control the...
        volatile uint32_t DOEPINT3;  ///< Offset: 0xB68 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ3;  ///< Offset: 0xB70 - The application must modify this register before...
        volatile uint32_t DOEPCTL4;  ///< Offset: 0xB80 - The application uses this register to control the...
        volatile uint32_t DOEPINT4;  ///< Offset: 0xB88 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ4;  ///< Offset: 0xB90 - The application must modify this register before...
        volatile uint32_t DOEPCTL5;  ///< Offset: 0xBA0 - The application uses this register to control the...
        volatile uint32_t DOEPINT5;  ///< Offset: 0xBA8 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ5;  ///< Offset: 0xBB0 - The application must modify this register before...
        volatile uint32_t PCGCCTL;  ///< Offset: 0xE00 - This register is available in host and device modes.
    };

    /// Peripheral instances
    inline Registers* OTG_FS = reinterpret_cast<Registers*>(OTG_FS_BASE);

    // Bit definitions
    /// GOTGCTL Register bits
    namespace gotgctl_bits {
        constexpr uint32_t SRQSCS = (1U << 0);  ///< SRQSCS
        constexpr uint32_t SRQ = (1U << 1);  ///< SRQ
        constexpr uint32_t VBVALOEN = (1U << 2);  ///< VBVALOEN
        constexpr uint32_t VBVALOVAL = (1U << 3);  ///< VBVALOVAL
        constexpr uint32_t AVALOEN = (1U << 4);  ///< AVALOEN
        constexpr uint32_t AVALOVAL = (1U << 5);  ///< AVALOVAL
        constexpr uint32_t BVALOEN = (1U << 6);  ///< BVALOEN
        constexpr uint32_t BVALOVAL = (1U << 7);  ///< BVALOVAL
        constexpr uint32_t HNGSCS = (1U << 8);  ///< HNGSCS
        constexpr uint32_t HNPRQ = (1U << 9);  ///< HNPRQ
        constexpr uint32_t HSHNPEN = (1U << 10);  ///< HSHNPEN
        constexpr uint32_t DHNPEN = (1U << 11);  ///< DHNPEN
        constexpr uint32_t EHEN = (1U << 12);  ///< EHEN
        constexpr uint32_t CIDSTS = (1U << 16);  ///< CIDSTS
        constexpr uint32_t DBCT = (1U << 17);  ///< DBCT
        constexpr uint32_t ASVLD = (1U << 18);  ///< ASVLD
        constexpr uint32_t BSVLD = (1U << 19);  ///< BSVLD
        constexpr uint32_t OTGVER = (1U << 20);  ///< OTGVER
        constexpr uint32_t CURMOD = (1U << 21);  ///< CURMOD
    }

    /// GOTGINT Register bits
    namespace gotgint_bits {
        constexpr uint32_t SEDET = (1U << 2);  ///< SEDET
        constexpr uint32_t SRSSCHG = (1U << 8);  ///< SRSSCHG
        constexpr uint32_t HNSSCHG = (1U << 9);  ///< HNSSCHG
        constexpr uint32_t HNGDET = (1U << 17);  ///< HNGDET
        constexpr uint32_t ADTOCHG = (1U << 18);  ///< ADTOCHG
        constexpr uint32_t DBCDNE = (1U << 19);  ///< DBCDNE
    }

    /// GAHBCFG Register bits
    namespace gahbcfg_bits {
        constexpr uint32_t GINTMSK = (1U << 0);  ///< GINTMSK
        constexpr uint32_t TXFELVL = (1U << 7);  ///< TXFELVL
        constexpr uint32_t PTXFELVL = (1U << 8);  ///< PTXFELVL
    }

    /// GUSBCFG Register bits
    namespace gusbcfg_bits {
        constexpr uint32_t TOCAL = (3 << 0);  ///< TOCAL
        constexpr uint32_t PHYSEL = (1U << 6);  ///< PHYSEL
        constexpr uint32_t SRPCAP = (1U << 8);  ///< SRPCAP
        constexpr uint32_t HNPCAP = (1U << 9);  ///< HNPCAP
        constexpr uint32_t TRDT = (4 << 10);  ///< TRDT
        constexpr uint32_t FHMOD = (1U << 29);  ///< FHMOD
        constexpr uint32_t FDMOD = (1U << 30);  ///< FDMOD
    }

    /// GRSTCTL Register bits
    namespace grstctl_bits {
        constexpr uint32_t CSRST = (1U << 0);  ///< CSRST
        constexpr uint32_t PSRST = (1U << 1);  ///< PSRST
        constexpr uint32_t FSRST = (1U << 2);  ///< FSRST
        constexpr uint32_t RXFFLSH = (1U << 4);  ///< RXFFLSH
        constexpr uint32_t TXFFLSH = (1U << 5);  ///< TXFFLSH
        constexpr uint32_t TXFNUM = (5 << 6);  ///< TXFNUM
        constexpr uint32_t AHBIDL = (1U << 31);  ///< AHBIDL
    }

    /// GINTSTS Register bits
    namespace gintsts_bits {
        constexpr uint32_t CMOD = (1U << 0);  ///< CMOD
        constexpr uint32_t MMIS = (1U << 1);  ///< MMIS
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTGINT
        constexpr uint32_t SOF = (1U << 3);  ///< SOF
        constexpr uint32_t RXFLVL = (1U << 4);  ///< RXFLVL
        constexpr uint32_t NPTXFE = (1U << 5);  ///< NPTXFE
        constexpr uint32_t GINAKEFF = (1U << 6);  ///< GINAKEFF
        constexpr uint32_t GONAKEFF = (1U << 7);  ///< GONAKEFF
        constexpr uint32_t ESUSP = (1U << 10);  ///< ESUSP
        constexpr uint32_t USBSUSP = (1U << 11);  ///< USBSUSP
        constexpr uint32_t USBRST = (1U << 12);  ///< USBRST
        constexpr uint32_t ENUMDNE = (1U << 13);  ///< ENUMDNE
        constexpr uint32_t ISOODRP = (1U << 14);  ///< ISOODRP
        constexpr uint32_t EOPF = (1U << 15);  ///< EOPF
        constexpr uint32_t IEPINT = (1U << 18);  ///< IEPINT
        constexpr uint32_t OEPINT = (1U << 19);  ///< OEPINT
        constexpr uint32_t IISOIXFR = (1U << 20);  ///< IISOIXFR
        constexpr uint32_t IPXFR = (1U << 21);  ///< IPXFR
        constexpr uint32_t RSTDET = (1U << 23);  ///< RSTDET
        constexpr uint32_t HPRTINT = (1U << 24);  ///< HPRTINT
        constexpr uint32_t HCINT = (1U << 25);  ///< HCINT
        constexpr uint32_t PTXFE = (1U << 26);  ///< PTXFE
        constexpr uint32_t LPMINT = (1U << 27);  ///< LPMINT
        constexpr uint32_t CIDSCHG = (1U << 28);  ///< CIDSCHG
        constexpr uint32_t DISCINT = (1U << 29);  ///< DISCINT
        constexpr uint32_t SRQINT = (1U << 30);  ///< SRQINT
        constexpr uint32_t WKUPINT = (1U << 31);  ///< WKUPINT
    }

    /// GINTMSK Register bits
    namespace gintmsk_bits {
        constexpr uint32_t MMISM = (1U << 1);  ///< MMISM
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTGINT
        constexpr uint32_t SOFM = (1U << 3);  ///< SOFM
        constexpr uint32_t RXFLVLM = (1U << 4);  ///< RXFLVLM
        constexpr uint32_t NPTXFEM = (1U << 5);  ///< NPTXFEM
        constexpr uint32_t GINAKEFFM = (1U << 6);  ///< GINAKEFFM
        constexpr uint32_t GONAKEFFM = (1U << 7);  ///< GONAKEFFM
        constexpr uint32_t ESUSPM = (1U << 10);  ///< ESUSPM
        constexpr uint32_t USBSUSPM = (1U << 11);  ///< USBSUSPM
        constexpr uint32_t USBRST = (1U << 12);  ///< USBRST
        constexpr uint32_t ENUMDNEM = (1U << 13);  ///< ENUMDNEM
        constexpr uint32_t ISOODRPM = (1U << 14);  ///< ISOODRPM
        constexpr uint32_t EOPFM = (1U << 15);  ///< EOPFM
        constexpr uint32_t IEPINT = (1U << 18);  ///< IEPINT
        constexpr uint32_t OEPINT = (1U << 19);  ///< OEPINT
        constexpr uint32_t IISOIXFRM = (1U << 20);  ///< IISOIXFRM
        constexpr uint32_t IPXFRM = (1U << 21);  ///< IPXFRM
        constexpr uint32_t RSTDETM = (1U << 23);  ///< RSTDETM
        constexpr uint32_t PRTIM = (1U << 24);  ///< PRTIM
        constexpr uint32_t HCIM = (1U << 25);  ///< HCIM
        constexpr uint32_t PTXFEM = (1U << 26);  ///< PTXFEM
        constexpr uint32_t LPMINTM = (1U << 27);  ///< LPMINTM
        constexpr uint32_t CIDSCHGM = (1U << 28);  ///< CIDSCHGM
        constexpr uint32_t DISCINT = (1U << 29);  ///< DISCINT
        constexpr uint32_t SRQIM = (1U << 30);  ///< SRQIM
        constexpr uint32_t WUIM = (1U << 31);  ///< WUIM
    }

    /// GRXSTSR_DEVICE Register bits
    namespace grxstsr_device_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< EPNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
        constexpr uint32_t FRMNUM = (4 << 21);  ///< FRMNUM
        constexpr uint32_t STSPHST = (1U << 27);  ///< STSPHST
    }

    /// GRXSTSR_HOST Register bits
    namespace grxstsr_host_bits {
        constexpr uint32_t CHNUM = (4 << 0);  ///< CHNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
    }

    /// GRXSTSP_DEVICE Register bits
    namespace grxstsp_device_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< EPNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
        constexpr uint32_t FRMNUM = (4 << 21);  ///< FRMNUM
        constexpr uint32_t STSPHST = (1U << 27);  ///< STSPHST
    }

    /// GRXSTSP_HOST Register bits
    namespace grxstsp_host_bits {
        constexpr uint32_t CHNUM = (4 << 0);  ///< CHNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
    }

    /// GRXFSIZ Register bits
    namespace grxfsiz_bits {
        constexpr uint32_t RXFD = (16 << 0);  ///< RXFD
    }

    /// HNPTXFSIZ Register bits
    namespace hnptxfsiz_bits {
        constexpr uint32_t NPTXFSA = (16 << 0);  ///< NPTXFSA
        constexpr uint32_t NPTXFD = (16 << 16);  ///< NPTXFD
    }

    /// HNPTXSTS Register bits
    namespace hnptxsts_bits {
        constexpr uint32_t NPTXFSAV = (16 << 0);  ///< NPTXFSAV
        constexpr uint32_t NPTQXSAV = (8 << 16);  ///< NPTQXSAV
        constexpr uint32_t NPTXQTOP = (7 << 24);  ///< NPTXQTOP
    }

    /// GCCFG Register bits
    namespace gccfg_bits {
        constexpr uint32_t DCDET = (1U << 0);  ///< DCDET
        constexpr uint32_t PDET = (1U << 1);  ///< PDET
        constexpr uint32_t SDET = (1U << 2);  ///< SDET
        constexpr uint32_t PS2DET = (1U << 3);  ///< PS2DET
        constexpr uint32_t PWRDWN = (1U << 16);  ///< PWRDWN
        constexpr uint32_t BCDEN = (1U << 17);  ///< BCDEN
        constexpr uint32_t DCDEN = (1U << 18);  ///< DCDEN
        constexpr uint32_t PDEN = (1U << 19);  ///< PDEN
        constexpr uint32_t SDEN = (1U << 20);  ///< SDEN
        constexpr uint32_t VBDEN = (1U << 21);  ///< VBDEN
    }

    /// CID Register bits
    namespace cid_bits {
        constexpr uint32_t PRODUCT_ID = (32 << 0);  ///< PRODUCT_ID
    }

    /// GLPMCFG Register bits
    namespace glpmcfg_bits {
        constexpr uint32_t LPMEN = (1U << 0);  ///< LPMEN
        constexpr uint32_t LPMACK = (1U << 1);  ///< LPMACK
        constexpr uint32_t BESL = (4 << 2);  ///< BESL
        constexpr uint32_t REMWAKE = (1U << 6);  ///< REMWAKE
        constexpr uint32_t L1SSEN = (1U << 7);  ///< L1SSEN
        constexpr uint32_t BESLTHRS = (4 << 8);  ///< BESLTHRS
        constexpr uint32_t L1DSEN = (1U << 12);  ///< L1DSEN
        constexpr uint32_t LPMRSP = (2 << 13);  ///< LPMRSP
        constexpr uint32_t SLPSTS = (1U << 15);  ///< SLPSTS
        constexpr uint32_t L1RSMOK = (1U << 16);  ///< L1RSMOK
        constexpr uint32_t LPMCHIDX = (4 << 17);  ///< LPMCHIDX
        constexpr uint32_t LPMRCNT = (3 << 21);  ///< LPMRCNT
        constexpr uint32_t SNDLPM = (1U << 24);  ///< SNDLPM
        constexpr uint32_t LPMRCNTSTS = (3 << 25);  ///< LPMRCNTSTS
        constexpr uint32_t ENBESL = (1U << 28);  ///< ENBESL
    }

    /// HPTXFSIZ Register bits
    namespace hptxfsiz_bits {
        constexpr uint32_t PTXSA = (16 << 0);  ///< PTXSA
        constexpr uint32_t PTXFSIZ = (16 << 16);  ///< PTXFSIZ
    }

    /// DIEPTXF1 Register bits
    namespace dieptxf1_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF2 Register bits
    namespace dieptxf2_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF3 Register bits
    namespace dieptxf3_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF4 Register bits
    namespace dieptxf4_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF5 Register bits
    namespace dieptxf5_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// HCFG Register bits
    namespace hcfg_bits {
        constexpr uint32_t FSLSPCS = (2 << 0);  ///< FSLSPCS
        constexpr uint32_t FSLSS = (1U << 2);  ///< FSLSS
    }

    /// HFIR Register bits
    namespace hfir_bits {
        constexpr uint32_t FRIVL = (16 << 0);  ///< FRIVL
        constexpr uint32_t RLDCTRL = (1U << 16);  ///< RLDCTRL
    }

    /// HFNUM Register bits
    namespace hfnum_bits {
        constexpr uint32_t FRNUM = (16 << 0);  ///< FRNUM
        constexpr uint32_t FTREM = (16 << 16);  ///< FTREM
    }

    /// HPTXSTS Register bits
    namespace hptxsts_bits {
        constexpr uint32_t PTXFSAVL = (16 << 0);  ///< PTXFSAVL
        constexpr uint32_t PTXQSAV = (8 << 16);  ///< PTXQSAV
        constexpr uint32_t PTXQTOP = (8 << 24);  ///< PTXQTOP
    }

    /// HAINT Register bits
    namespace haint_bits {
        constexpr uint32_t HAINT = (16 << 0);  ///< HAINT
    }

    /// HAINTMSK Register bits
    namespace haintmsk_bits {
        constexpr uint32_t HAINTM = (16 << 0);  ///< HAINTM
    }

    /// HPRT Register bits
    namespace hprt_bits {
        constexpr uint32_t PCSTS = (1U << 0);  ///< PCSTS
        constexpr uint32_t PCDET = (1U << 1);  ///< PCDET
        constexpr uint32_t PENA = (1U << 2);  ///< PENA
        constexpr uint32_t PENCHNG = (1U << 3);  ///< PENCHNG
        constexpr uint32_t POCA = (1U << 4);  ///< POCA
        constexpr uint32_t POCCHNG = (1U << 5);  ///< POCCHNG
        constexpr uint32_t PRES = (1U << 6);  ///< PRES
        constexpr uint32_t PSUSP = (1U << 7);  ///< PSUSP
        constexpr uint32_t PRST = (1U << 8);  ///< PRST
        constexpr uint32_t PLSTS = (2 << 10);  ///< PLSTS
        constexpr uint32_t PPWR = (1U << 12);  ///< PPWR
        constexpr uint32_t PTCTL = (4 << 13);  ///< PTCTL
        constexpr uint32_t PSPD = (2 << 17);  ///< PSPD
    }

    /// HCCHAR0 Register bits
    namespace hcchar0_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT0 Register bits
    namespace hcint0_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK0 Register bits
    namespace hcintmsk0_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ0 Register bits
    namespace hctsiz0_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR1 Register bits
    namespace hcchar1_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT1 Register bits
    namespace hcint1_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK1 Register bits
    namespace hcintmsk1_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ1 Register bits
    namespace hctsiz1_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR2 Register bits
    namespace hcchar2_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT2 Register bits
    namespace hcint2_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK2 Register bits
    namespace hcintmsk2_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ2 Register bits
    namespace hctsiz2_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR3 Register bits
    namespace hcchar3_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT3 Register bits
    namespace hcint3_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK3 Register bits
    namespace hcintmsk3_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ3 Register bits
    namespace hctsiz3_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR4 Register bits
    namespace hcchar4_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT4 Register bits
    namespace hcint4_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK4 Register bits
    namespace hcintmsk4_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ4 Register bits
    namespace hctsiz4_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR5 Register bits
    namespace hcchar5_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT5 Register bits
    namespace hcint5_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK5 Register bits
    namespace hcintmsk5_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ5 Register bits
    namespace hctsiz5_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR6 Register bits
    namespace hcchar6_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT6 Register bits
    namespace hcint6_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK6 Register bits
    namespace hcintmsk6_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ6 Register bits
    namespace hctsiz6_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR7 Register bits
    namespace hcchar7_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT7 Register bits
    namespace hcint7_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK7 Register bits
    namespace hcintmsk7_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ7 Register bits
    namespace hctsiz7_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR8 Register bits
    namespace hcchar8_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT8 Register bits
    namespace hcint8_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK8 Register bits
    namespace hcintmsk8_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ8 Register bits
    namespace hctsiz8_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR9 Register bits
    namespace hcchar9_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT9 Register bits
    namespace hcint9_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK9 Register bits
    namespace hcintmsk9_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ9 Register bits
    namespace hctsiz9_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR10 Register bits
    namespace hcchar10_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT10 Register bits
    namespace hcint10_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK10 Register bits
    namespace hcintmsk10_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ10 Register bits
    namespace hctsiz10_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR11 Register bits
    namespace hcchar11_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT11 Register bits
    namespace hcint11_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK11 Register bits
    namespace hcintmsk11_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ11 Register bits
    namespace hctsiz11_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// DCFG Register bits
    namespace dcfg_bits {
        constexpr uint32_t DSPD = (2 << 0);  ///< DSPD
        constexpr uint32_t NZLSOHSK = (1U << 2);  ///< NZLSOHSK
        constexpr uint32_t DAD = (7 << 4);  ///< DAD
        constexpr uint32_t PFIVL = (2 << 11);  ///< PFIVL
        constexpr uint32_t ERRATIM = (1U << 15);  ///< ERRATIM
    }

    /// DCTL Register bits
    namespace dctl_bits {
        constexpr uint32_t RWUSIG = (1U << 0);  ///< RWUSIG
        constexpr uint32_t SDIS = (1U << 1);  ///< SDIS
        constexpr uint32_t GINSTS = (1U << 2);  ///< GINSTS
        constexpr uint32_t GONSTS = (1U << 3);  ///< GONSTS
        constexpr uint32_t TCTL = (3 << 4);  ///< TCTL
        constexpr uint32_t SGINAK = (1U << 7);  ///< SGINAK
        constexpr uint32_t CGINAK = (1U << 8);  ///< CGINAK
        constexpr uint32_t SGONAK = (1U << 9);  ///< SGONAK
        constexpr uint32_t CGONAK = (1U << 10);  ///< CGONAK
        constexpr uint32_t POPRGDNE = (1U << 11);  ///< POPRGDNE
        constexpr uint32_t DSBESLRJCT = (1U << 18);  ///< DSBESLRJCT
    }

    /// DSTS Register bits
    namespace dsts_bits {
        constexpr uint32_t SUSPSTS = (1U << 0);  ///< SUSPSTS
        constexpr uint32_t ENUMSPD = (2 << 1);  ///< ENUMSPD
        constexpr uint32_t EERR = (1U << 3);  ///< EERR
        constexpr uint32_t FNSOF = (14 << 8);  ///< FNSOF
        constexpr uint32_t DEVLNSTS = (2 << 22);  ///< DEVLNSTS
    }

    /// DIEPMSK Register bits
    namespace diepmsk_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t EPDM = (1U << 1);  ///< EPDM
        constexpr uint32_t TOM = (1U << 3);  ///< TOM
        constexpr uint32_t ITTXFEMSK = (1U << 4);  ///< ITTXFEMSK
        constexpr uint32_t INEPNMM = (1U << 5);  ///< INEPNMM
        constexpr uint32_t INEPNEM = (1U << 6);  ///< INEPNEM
        constexpr uint32_t NAKM = (1U << 13);  ///< NAKM
    }

    /// DOEPMSK Register bits
    namespace doepmsk_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t EPDM = (1U << 1);  ///< EPDM
        constexpr uint32_t STUPM = (1U << 3);  ///< STUPM
        constexpr uint32_t OTEPDM = (1U << 4);  ///< OTEPDM
        constexpr uint32_t STSPHSRXM = (1U << 5);  ///< STSPHSRXM
        constexpr uint32_t OUTPKTERRM = (1U << 8);  ///< OUTPKTERRM
        constexpr uint32_t BERRM = (1U << 12);  ///< BERRM
        constexpr uint32_t NAKMSK = (1U << 13);  ///< NAKMSK
    }

    /// DAINT Register bits
    namespace daint_bits {
        constexpr uint32_t IEPINT = (16 << 0);  ///< IEPINT
        constexpr uint32_t OEPINT = (16 << 16);  ///< OEPINT
    }

    /// DAINTMSK Register bits
    namespace daintmsk_bits {
        constexpr uint32_t IEPM = (16 << 0);  ///< IEPM
        constexpr uint32_t OEPM = (16 << 16);  ///< OEPM
    }

    /// DVBUSDIS Register bits
    namespace dvbusdis_bits {
        constexpr uint32_t VBUSDT = (16 << 0);  ///< VBUSDT
    }

    /// DVBUSPULSE Register bits
    namespace dvbuspulse_bits {
        constexpr uint32_t DVBUSP = (16 << 0);  ///< DVBUSP
    }

    /// DIEPEMPMSK Register bits
    namespace diepempmsk_bits {
        constexpr uint32_t INEPTXFEM = (16 << 0);  ///< INEPTXFEM
    }

    /// DIEPCTL0 Register bits
    namespace diepctl0_bits {
        constexpr uint32_t MPSIZ = (2 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT0 Register bits
    namespace diepint0_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ0 Register bits
    namespace dieptsiz0_bits {
        constexpr uint32_t XFRSIZ = (7 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (2 << 19);  ///< PKTCNT
    }

    /// DTXFSTS0 Register bits
    namespace dtxfsts0_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL1 Register bits
    namespace diepctl1_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT1 Register bits
    namespace diepint1_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ1 Register bits
    namespace dieptsiz1_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DTXFSTS1 Register bits
    namespace dtxfsts1_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL2 Register bits
    namespace diepctl2_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT2 Register bits
    namespace diepint2_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ2 Register bits
    namespace dieptsiz2_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DTXFSTS2 Register bits
    namespace dtxfsts2_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL3 Register bits
    namespace diepctl3_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT3 Register bits
    namespace diepint3_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ3 Register bits
    namespace dieptsiz3_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DTXFSTS3 Register bits
    namespace dtxfsts3_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL4 Register bits
    namespace diepctl4_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT4 Register bits
    namespace diepint4_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ4 Register bits
    namespace dieptsiz4_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DTXFSTS4 Register bits
    namespace dtxfsts4_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL5 Register bits
    namespace diepctl5_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT5 Register bits
    namespace diepint5_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ5 Register bits
    namespace dieptsiz5_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DTXFSTS5 Register bits
    namespace dtxfsts5_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DOEPCTL0 Register bits
    namespace doepctl0_bits {
        constexpr uint32_t MPSIZ = (2 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT0 Register bits
    namespace doepint0_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ0 Register bits
    namespace doeptsiz0_bits {
        constexpr uint32_t XFRSIZ = (7 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (1U << 19);  ///< PKTCNT
        constexpr uint32_t STUPCNT = (2 << 29);  ///< STUPCNT
    }

    /// DOEPCTL1 Register bits
    namespace doepctl1_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT1 Register bits
    namespace doepint1_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ1 Register bits
    namespace doeptsiz1_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPCTL2 Register bits
    namespace doepctl2_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT2 Register bits
    namespace doepint2_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ2 Register bits
    namespace doeptsiz2_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPCTL3 Register bits
    namespace doepctl3_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT3 Register bits
    namespace doepint3_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ3 Register bits
    namespace doeptsiz3_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPCTL4 Register bits
    namespace doepctl4_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT4 Register bits
    namespace doepint4_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ4 Register bits
    namespace doeptsiz4_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPCTL5 Register bits
    namespace doepctl5_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT5 Register bits
    namespace doepint5_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ5 Register bits
    namespace doeptsiz5_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// PCGCCTL Register bits
    namespace pcgcctl_bits {
        constexpr uint32_t STPPCLK = (1U << 0);  ///< STPPCLK
        constexpr uint32_t GATEHCLK = (1U << 1);  ///< GATEHCLK
        constexpr uint32_t PHYSUSP = (1U << 4);  ///< PHYSUSP
        constexpr uint32_t ENL1GTG = (1U << 5);  ///< ENL1GTG
        constexpr uint32_t PHYSLEEP = (1U << 6);  ///< PHYSLEEP
        constexpr uint32_t SUSP = (1U << 7);  ///< SUSP
    }

}

// ============================================================================
// PSSI Peripheral
// ============================================================================

namespace pssi {
    /// Base addresses
    constexpr uint32_t PSSI_BASE = 0x4202C400;

    /// PSSI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - PSSI control register
        volatile uint32_t SR;  ///< Offset: 0x04 - PSSI status register
        volatile uint32_t RIS;  ///< Offset: 0x08 - PSSI raw interrupt status register
        volatile uint32_t IER;  ///< Offset: 0x0C - PSSI interrupt enable register
        volatile uint32_t MIS;  ///< Offset: 0x10 - PSSI masked interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x14 - PSSI interrupt clear register
        volatile uint32_t DR;  ///< Offset: 0x28 - PSSI data register
    };

    /// Peripheral instances
    inline Registers* PSSI = reinterpret_cast<Registers*>(PSSI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CKPOL = (1U << 5);  ///< Parallel data clock polarity 		This bit configures the capture edge of the parallel clock or the edge used for driving outputs, depending on OUTEN.
        constexpr uint32_t DEPOL = (1U << 6);  ///< Data enable (PSSI_DE) polarity 		This bit indicates the level on the PSSI_DE pin when the data are not valid on the parallel interface.
        constexpr uint32_t RDYPOL = (1U << 8);  ///< Ready (PSSI_RDY) polarity 		This bit indicates the level on the PSSI_RDY pin when the data are not valid on the parallel interface.
        constexpr uint32_t EDM = (2 << 10);  ///< Extended data mode
        constexpr uint32_t ENABLE = (1U << 14);  ///< PSSI enable 		The contents of the FIFO are flushed when ENABLE is cleared to 0. 		Note: When ENABLE=1, the content of PSSI_CR must not be changed, except for the ENABLE bit itself. All configuration bits can change as soon as ENABLE changes from 0 to 1. 		The DMA controller and all PSSI configuration registers must be programmed correctly before setting the ENABLE bit to 1. 		The ENABLE bit and the DCMI ENABLE bit (bit 15 of DCMI_CR) must not be set to 1 at the same time.
        constexpr uint32_t DERDYCFG = (3 << 18);  ///< Data enable and ready configuration 		When the PSSI_RDY function is mapped to the PSSI_DE pin (settings 101 or 111), it is still the RDYPOL bit which determines its polarity. Similarly, when the PSSI_DE function is mapped to the PSSI_RDY pin (settings 110 or 111), it is still the DEPOL bit which determines its polarity.
        constexpr uint32_t DMAEN = (1U << 30);  ///< DMA enable bit
        constexpr uint32_t OUTEN = (1U << 31);  ///< Data direction selection bit
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RTT4B = (1U << 2);  ///< RTT4B
        constexpr uint32_t RTT1B = (1U << 3);  ///< RTT1B
    }

    /// RIS Register bits
    namespace ris_bits {
        constexpr uint32_t OVR_RIS = (1U << 1);  ///< OVR_RIS
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t OVR_IE = (1U << 1);  ///< OVR_IE
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t OVR_MIS = (1U << 1);  ///< OVR_MIS
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t OVR_ISC = (1U << 1);  ///< OVR_ISC
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t BYTE0 = (8 << 0);  ///< Data byte 0
        constexpr uint32_t BYTE1 = (8 << 8);  ///< Data byte 1
        constexpr uint32_t BYTE2 = (8 << 16);  ///< Data byte 2
        constexpr uint32_t BYTE3 = (8 << 24);  ///< Data byte 3
    }

}

// ============================================================================
// OTFDEC1 Peripheral
// ============================================================================

namespace otfdec1 {
    /// Base addresses
    constexpr uint32_t OTFDEC1_BASE = 0x420C5000;

    /// OTFDEC1 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OTFDEC control register
        volatile uint32_t PRIVCFGR;  ///< Offset: 0x10 - OTFDEC privileged access control configuration register
        volatile uint32_t R1CFGR;  ///< Offset: 0x20 - OTFDEC region x configuration register
        volatile uint32_t R2CFGR;  ///< Offset: 0x50 - OTFDEC region x configuration register
        volatile uint32_t R3CFGR;  ///< Offset: 0x80 - OTFDEC region x configuration register
        volatile uint32_t R4CFGR;  ///< Offset: 0xB0 - OTFDEC region x configuration register
        volatile uint32_t R1STARTADDR;  ///< Offset: 0x24 - OTFDEC region x start address register
        volatile uint32_t R2STARTADDR;  ///< Offset: 0x54 - OTFDEC region x start address register
        volatile uint32_t R3STARTADDR;  ///< Offset: 0x84 - OTFDEC region x start address register
        volatile uint32_t R4STARTADDR;  ///< Offset: 0xB4 - OTFDEC region x start address register
        volatile uint32_t R1ENDADDR;  ///< Offset: 0x28 - OTFDEC region x end address register
        volatile uint32_t R2ENDADDR;  ///< Offset: 0x58 - OTFDEC region x end address register
        volatile uint32_t R3ENDADDR;  ///< Offset: 0x88 - OTFDEC region x end address register
        volatile uint32_t R4ENDADDR;  ///< Offset: 0x8C - OTFDEC region x end address register
        volatile uint32_t R1NONCER0;  ///< Offset: 0x2C - OTFDEC region x nonce register 0
        volatile uint32_t R2NONCER0;  ///< Offset: 0x5C - OTFDEC region x nonce register 0
        volatile uint32_t R3NONCER0;  ///< Offset: 0x8C - OTFDEC region x nonce register 0
        volatile uint32_t R4NONCER0;  ///< Offset: 0xBC - OTFDEC region x nonce register 0
        volatile uint32_t R1NONCER1;  ///< Offset: 0x30 - OTFDEC region x nonce register 1
        volatile uint32_t R2NONCER1;  ///< Offset: 0x60 - OTFDEC region x nonce register 1
        volatile uint32_t R3NONCER1;  ///< Offset: 0x90 - OTFDEC region x nonce register 1
        volatile uint32_t R4NONCER1;  ///< Offset: 0xC0 - OTFDEC region x nonce register 1
        volatile uint32_t R1KEYR0;  ///< Offset: 0x34 - OTFDEC region x key register 0
        volatile uint32_t R2KEYR0;  ///< Offset: 0x64 - OTFDEC region x key register 0
        volatile uint32_t R3KEYR0;  ///< Offset: 0x94 - OTFDEC region x key register 0
        volatile uint32_t R4KEYR0;  ///< Offset: 0xC4 - OTFDEC region x key register 0
        volatile uint32_t R1KEYR1;  ///< Offset: 0x38 - OTFDEC region x key register 1
        volatile uint32_t R2KEYR1;  ///< Offset: 0x68 - OTFDEC region x key register 1
        volatile uint32_t R3KEYR1;  ///< Offset: 0x98 - OTFDEC region x key register 1
        volatile uint32_t R4KEYR1;  ///< Offset: 0xC8 - OTFDEC region x key register 1
        volatile uint32_t R1KEYR2;  ///< Offset: 0x3C - OTFDEC region x key register 2
        volatile uint32_t R2KEYR2;  ///< Offset: 0x6C - OTFDEC region x key register 2
        volatile uint32_t R3KEYR2;  ///< Offset: 0x9C - OTFDEC region x key register 2
        volatile uint32_t R4KEYR2;  ///< Offset: 0xCC - OTFDEC region x key register 2
        volatile uint32_t R1KEYR3;  ///< Offset: 0x40 - OTFDEC region x key register 3
        volatile uint32_t R2KEYR3;  ///< Offset: 0x70 - OTFDEC region x key register 3
        volatile uint32_t R3KEYR3;  ///< Offset: 0xA0 - OTFDEC region x key register 3
        volatile uint32_t R4KEYR3;  ///< Offset: 0xD0 - OTFDEC region x key register 3
        volatile uint32_t ISR;  ///< Offset: 0x300 - OTFDEC interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x304 - OTFDEC interrupt clear register
        volatile uint32_t IER;  ///< Offset: 0x308 - OTFDEC interrupt enable register
    };

    /// Peripheral instances
    inline Registers* OTFDEC1 = reinterpret_cast<Registers*>(OTFDEC1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ENC = (1U << 0);  ///< Encryption mode bit
    }

    /// PRIVCFGR Register bits
    namespace privcfgr_bits {
        constexpr uint32_t PRIV = (1U << 0);  ///< Encryption mode bit
    }

    /// R1CFGR Register bits
    namespace r1cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REGx_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R2CFGR Register bits
    namespace r2cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REGx_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R3CFGR Register bits
    namespace r3cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REGx_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R4CFGR Register bits
    namespace r4cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REGx_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R1STARTADDR Register bits
    namespace r1startaddr_bits {
        constexpr uint32_t REGx_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R2STARTADDR Register bits
    namespace r2startaddr_bits {
        constexpr uint32_t REGx_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R3STARTADDR Register bits
    namespace r3startaddr_bits {
        constexpr uint32_t REGx_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R4STARTADDR Register bits
    namespace r4startaddr_bits {
        constexpr uint32_t REGx_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R1ENDADDR Register bits
    namespace r1endaddr_bits {
        constexpr uint32_t REGx_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R2ENDADDR Register bits
    namespace r2endaddr_bits {
        constexpr uint32_t REGx_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R3ENDADDR Register bits
    namespace r3endaddr_bits {
        constexpr uint32_t REGx_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R4ENDADDR Register bits
    namespace r4endaddr_bits {
        constexpr uint32_t REGx_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R1NONCER0 Register bits
    namespace r1noncer0_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R2NONCER0 Register bits
    namespace r2noncer0_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R3NONCER0 Register bits
    namespace r3noncer0_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R4NONCER0 Register bits
    namespace r4noncer0_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R1NONCER1 Register bits
    namespace r1noncer1_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< Region nonce
    }

    /// R2NONCER1 Register bits
    namespace r2noncer1_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< Region nonce, bits [63:32]REGx_NONCE[63:32]
    }

    /// R3NONCER1 Register bits
    namespace r3noncer1_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R4NONCER1 Register bits
    namespace r4noncer1_bits {
        constexpr uint32_t REGx_NONCE = (32 << 0);  ///< REGx_NONCE
    }

    /// R1KEYR0 Register bits
    namespace r1keyr0_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R2KEYR0 Register bits
    namespace r2keyr0_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R3KEYR0 Register bits
    namespace r3keyr0_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R4KEYR0 Register bits
    namespace r4keyr0_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R1KEYR1 Register bits
    namespace r1keyr1_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R2KEYR1 Register bits
    namespace r2keyr1_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R3KEYR1 Register bits
    namespace r3keyr1_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R4KEYR1 Register bits
    namespace r4keyr1_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R1KEYR2 Register bits
    namespace r1keyr2_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R2KEYR2 Register bits
    namespace r2keyr2_bits {
        constexpr uint32_t REGx_KEY_ = (32 << 0);  ///< REGx_KEY
    }

    /// R3KEYR2 Register bits
    namespace r3keyr2_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R4KEYR2 Register bits
    namespace r4keyr2_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R1KEYR3 Register bits
    namespace r1keyr3_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R2KEYR3 Register bits
    namespace r2keyr3_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R3KEYR3 Register bits
    namespace r3keyr3_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// R4KEYR3 Register bits
    namespace r4keyr3_bits {
        constexpr uint32_t REGx_KEY = (32 << 0);  ///< REGx_KEY
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t SEIF = (1U << 0);  ///< Security Error Interrupt Flag status
        constexpr uint32_t XONEIF = (1U << 1);  ///< Execute-only execute-Never Error Interrupt Flag status
        constexpr uint32_t KEIF = (1U << 2);  ///< Key Error Interrupt Flag status
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t SEIF = (1U << 0);  ///< SEIF
        constexpr uint32_t XONEIF = (1U << 1);  ///< Execute-only execute-Never Error Interrupt Flag clear
        constexpr uint32_t KEIF = (1U << 2);  ///< KEIF
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< Security Error Interrupt Enable
        constexpr uint32_t XONEIE = (1U << 1);  ///< XONEIE
        constexpr uint32_t KEIE = (1U << 2);  ///< KEIE
    }

}

// ============================================================================
// OTFDEC2 Peripheral
// ============================================================================

namespace otfdec2 {
    /// Base addresses
    constexpr uint32_t OTFDEC2_BASE = 0x420C5400;

    /// OTFDEC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* OTFDEC2 = reinterpret_cast<Registers*>(OTFDEC2_BASE);

}

// ============================================================================
// RAMCFG Peripheral
// ============================================================================

namespace ramcfg {
    /// Base addresses
    constexpr uint32_t RAMCFG_BASE = 0x40026000;

    /// RAMCFG Register structure
    struct Registers {
        volatile uint32_t RAM1CR;  ///< Offset: 0x00 - RAMCFG SRAM x control register
        volatile uint32_t RAM1ISR;  ///< Offset: 0x08 - RAMCFG RAMx interrupt status register
        volatile uint32_t RAM1ERKEYR;  ///< Offset: 0x28 - RAMCFG SRAM x erase key register
        volatile uint32_t RAM2CR;  ///< Offset: 0x40 - RAMCFG SRAM x control register
        volatile uint32_t RAM2IER;  ///< Offset: 0x44 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t RAM2ISR;  ///< Offset: 0x48 - RAMCFG RAMx interrupt status register
        volatile uint32_t RAM2SEAR;  ///< Offset: 0x4C - RAMCFG RAM x ECC single error address register
        volatile uint32_t RAM2DEAR;  ///< Offset: 0x50 - RAMCFG RAM x ECC double error address register
        volatile uint32_t RAM2ICR;  ///< Offset: 0x54 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t RAM2WPR1;  ///< Offset: 0x58 - RAMCFG SRAM2 write protection register 1
        volatile uint32_t RAM2WPR2;  ///< Offset: 0x5C - RAMCFG SRAM2 write protection register 2
        volatile uint32_t RAM2ECCKEYR;  ///< Offset: 0x64 - RAMCFG SRAM x ECC key register
        volatile uint32_t RAM2ERKEYR;  ///< Offset: 0x68 - RAMCFG SRAM x erase key register
        volatile uint32_t RAM3CR;  ///< Offset: 0x80 - RAMCFG SRAM x control register
        volatile uint32_t RAM3IER;  ///< Offset: 0x84 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t RAM3ISR;  ///< Offset: 0x88 - RAMCFG RAMx interrupt status register
        volatile uint32_t RAM3SEAR;  ///< Offset: 0x8C - RAMCFG RAM x ECC single error address register
        volatile uint32_t RAM3DEAR;  ///< Offset: 0x90 - RAMCFG RAM x ECC double error address register
        volatile uint32_t RAM3ICR;  ///< Offset: 0x94 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t RAM3ECCKEYR;  ///< Offset: 0xA4 - RAMCFG SRAM x ECC key register
        volatile uint32_t RAM3ERKEYR;  ///< Offset: 0xA8 - RAMCFG SRAM x erase key register
        volatile uint32_t RAM4CR;  ///< Offset: 0xC0 - RAMCFG SRAM x control register
        volatile uint32_t RAM4ISR;  ///< Offset: 0xC8 - RAMCFG RAMx interrupt status register
        volatile uint32_t RAM4ERKEYR;  ///< Offset: 0xE8 - RAMCFG SRAM x erase key register
        volatile uint32_t RAM5CR;  ///< Offset: 0x100 - RAMCFG SRAM x control register
        volatile uint32_t RAM5IER;  ///< Offset: 0x104 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t RAM5ISR;  ///< Offset: 0x108 - RAMCFG RAMx interrupt status register
        volatile uint32_t RAM5SEAR;  ///< Offset: 0x10C - RAMCFG RAM x ECC single error address register
        volatile uint32_t RAM5DEAR;  ///< Offset: 0x110 - RAMCFG RAM x ECC double error address register
        volatile uint32_t RAM5ICR;  ///< Offset: 0x114 - RAMCFG RAM x interrupt clear register x
    };

    /// Peripheral instances
    inline Registers* RAMCFG = reinterpret_cast<Registers*>(RAMCFG_BASE);

    // Bit definitions
    /// RAM1CR Register bits
    namespace ram1cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// RAM1ISR Register bits
    namespace ram1isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// RAM1ERKEYR Register bits
    namespace ram1erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// RAM2CR Register bits
    namespace ram2cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// RAM2IER Register bits
    namespace ram2ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// RAM2ISR Register bits
    namespace ram2isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// RAM2SEAR Register bits
    namespace ram2sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// RAM2DEAR Register bits
    namespace ram2dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// RAM2ICR Register bits
    namespace ram2icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

    /// RAM2WPR1 Register bits
    namespace ram2wpr1_bits {
        constexpr uint32_t P0WP = (1U << 0);  ///< P0WP
        constexpr uint32_t P1WP = (1U << 1);  ///< P1WP
        constexpr uint32_t P2WP = (1U << 2);  ///< P2WP
        constexpr uint32_t P3WP = (1U << 3);  ///< P3WP
        constexpr uint32_t P4WP = (1U << 4);  ///< P4WP
        constexpr uint32_t P5WP = (1U << 5);  ///< P5WP
        constexpr uint32_t P6WP = (1U << 6);  ///< P6WP
        constexpr uint32_t P7WP = (1U << 7);  ///< P7WP
        constexpr uint32_t P8WP = (1U << 8);  ///< P8WP
        constexpr uint32_t P9WP = (1U << 9);  ///< P9WP
        constexpr uint32_t P10WP = (1U << 10);  ///< P10WP
        constexpr uint32_t P11WP = (1U << 11);  ///< P11WP
        constexpr uint32_t P12WP = (1U << 12);  ///< P12WP
        constexpr uint32_t P13WP = (1U << 13);  ///< P13WP
        constexpr uint32_t P14WP = (1U << 14);  ///< P14WP
        constexpr uint32_t P15WP = (1U << 15);  ///< P15WP
        constexpr uint32_t P16WP = (1U << 16);  ///< P16WP
        constexpr uint32_t P17WP = (1U << 17);  ///< P17WP
        constexpr uint32_t P18WP = (1U << 18);  ///< P18WP
        constexpr uint32_t P19WP = (1U << 19);  ///< P19WP
        constexpr uint32_t P20WP = (1U << 20);  ///< P20WP
        constexpr uint32_t P21WP = (1U << 21);  ///< P21WP
        constexpr uint32_t P22WP = (1U << 22);  ///< P22WP
        constexpr uint32_t P23WP = (1U << 23);  ///< P23WP
        constexpr uint32_t P24WP = (1U << 24);  ///< P24WP
        constexpr uint32_t P25WP = (1U << 25);  ///< P25WP
        constexpr uint32_t P26WP = (1U << 26);  ///< P26WP
        constexpr uint32_t P27WP = (1U << 27);  ///< P27WP
        constexpr uint32_t P28WP = (1U << 28);  ///< P28WP
        constexpr uint32_t P29WP = (1U << 29);  ///< P29WP
        constexpr uint32_t P30WP = (1U << 30);  ///< P30WP
        constexpr uint32_t P31WP = (1U << 31);  ///< P31WP
    }

    /// RAM2WPR2 Register bits
    namespace ram2wpr2_bits {
        constexpr uint32_t P32WP = (1U << 0);  ///< P32WP
        constexpr uint32_t P33WP = (1U << 1);  ///< P33WP
        constexpr uint32_t P34WP = (1U << 2);  ///< P34WP
        constexpr uint32_t P35WP = (1U << 3);  ///< P35WP
        constexpr uint32_t P36WP = (1U << 4);  ///< P36WP
        constexpr uint32_t P37WP = (1U << 5);  ///< P37WP
        constexpr uint32_t P38WP = (1U << 6);  ///< P38WP
        constexpr uint32_t P39WP = (1U << 7);  ///< P39WP
        constexpr uint32_t P40WP = (1U << 8);  ///< P40WP
        constexpr uint32_t P41WP = (1U << 9);  ///< P41WP
        constexpr uint32_t P42WP = (1U << 10);  ///< P42WP
        constexpr uint32_t P43WP = (1U << 11);  ///< P43WP
        constexpr uint32_t P44WP = (1U << 12);  ///< P44WP
        constexpr uint32_t P45WP = (1U << 13);  ///< P45WP
        constexpr uint32_t P46WP = (1U << 14);  ///< P46WP
        constexpr uint32_t P47WP = (1U << 15);  ///< P47WP
        constexpr uint32_t P48WP = (1U << 16);  ///< P48WP
        constexpr uint32_t P49WP = (1U << 17);  ///< P49WP
        constexpr uint32_t P50WP = (1U << 18);  ///< P50WP
        constexpr uint32_t P51WP = (1U << 19);  ///< P51WP
        constexpr uint32_t P52WP = (1U << 20);  ///< P52WP
        constexpr uint32_t P53WP = (1U << 21);  ///< P53WP
        constexpr uint32_t P54WP = (1U << 22);  ///< P54WP
        constexpr uint32_t P55WP = (1U << 23);  ///< P55WP
        constexpr uint32_t P56WP = (1U << 24);  ///< P56WP
        constexpr uint32_t P57WP = (1U << 25);  ///< P57WP
        constexpr uint32_t P58WP = (1U << 26);  ///< P58WP
        constexpr uint32_t P59WP = (1U << 27);  ///< P59WP
        constexpr uint32_t P60WP = (1U << 28);  ///< P60WP
        constexpr uint32_t P61WP = (1U << 29);  ///< P61WP
        constexpr uint32_t P62WP = (1U << 30);  ///< P62WP
        constexpr uint32_t P63WP = (1U << 31);  ///< P63WP
    }

    /// RAM2ECCKEYR Register bits
    namespace ram2ecckeyr_bits {
        constexpr uint32_t ECCKEY = (8 << 0);  ///< ECCKEY
    }

    /// RAM2ERKEYR Register bits
    namespace ram2erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// RAM3CR Register bits
    namespace ram3cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// RAM3IER Register bits
    namespace ram3ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// RAM3ISR Register bits
    namespace ram3isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// RAM3SEAR Register bits
    namespace ram3sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// RAM3DEAR Register bits
    namespace ram3dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// RAM3ICR Register bits
    namespace ram3icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

    /// RAM3ECCKEYR Register bits
    namespace ram3ecckeyr_bits {
        constexpr uint32_t ECCKEY = (8 << 0);  ///< ECCKEY
    }

    /// RAM3ERKEYR Register bits
    namespace ram3erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// RAM4CR Register bits
    namespace ram4cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// RAM4ISR Register bits
    namespace ram4isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// RAM4ERKEYR Register bits
    namespace ram4erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// RAM5CR Register bits
    namespace ram5cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// RAM5IER Register bits
    namespace ram5ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// RAM5ISR Register bits
    namespace ram5isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// RAM5SEAR Register bits
    namespace ram5sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// RAM5DEAR Register bits
    namespace ram5dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// RAM5ICR Register bits
    namespace ram5icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

}

// ============================================================================
// DCMI Peripheral
// ============================================================================

namespace dcmi {
    /// Base addresses
    constexpr uint32_t DCMI_BASE = 0x4202C000;

    /// DCMI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t RIS;  ///< Offset: 0x08 - raw interrupt status register
        volatile uint32_t IER;  ///< Offset: 0x0C - interrupt enable register
        volatile uint32_t MIS;  ///< Offset: 0x10 - masked interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x14 - interrupt clear register
        volatile uint32_t ESCR;  ///< Offset: 0x18 - background offset register
        volatile uint32_t ESUR;  ///< Offset: 0x1C - embedded synchronization unmask register
        volatile uint32_t CWSTRT;  ///< Offset: 0x20 - crop window start
        volatile uint32_t CWSIZE;  ///< Offset: 0x24 - crop window size
        volatile uint32_t DR;  ///< Offset: 0x28 - data register
    };

    /// Peripheral instances
    inline Registers* DCMI = reinterpret_cast<Registers*>(DCMI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t OELS = (1U << 20);  ///< Odd/Even Line Select (Line Select Start)
        constexpr uint32_t LSM = (1U << 19);  ///< Line Select mode
        constexpr uint32_t OEBS = (1U << 18);  ///< Odd/Even Byte Select (Byte Select Start)
        constexpr uint32_t BSM = (2 << 16);  ///< Byte Select mode
        constexpr uint32_t ENABLE = (1U << 14);  ///< DCMI enable
        constexpr uint32_t EDM = (2 << 10);  ///< Extended data mode
        constexpr uint32_t FCRC = (2 << 8);  ///< Frame capture rate control
        constexpr uint32_t VSPOL = (1U << 7);  ///< Vertical synchronization polarity
        constexpr uint32_t HSPOL = (1U << 6);  ///< Horizontal synchronization polarity
        constexpr uint32_t PCKPOL = (1U << 5);  ///< Pixel clock polarity
        constexpr uint32_t ESS = (1U << 4);  ///< Embedded synchronization select
        constexpr uint32_t JPEG = (1U << 3);  ///< JPEG format
        constexpr uint32_t CROP = (1U << 2);  ///< Crop feature
        constexpr uint32_t CM = (1U << 1);  ///< Capture mode
        constexpr uint32_t CAPTURE = (1U << 0);  ///< Capture enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t FNE = (1U << 2);  ///< FIFO not empty
        constexpr uint32_t VSYNC = (1U << 1);  ///< Vertical synchronization
        constexpr uint32_t HSYNC = (1U << 0);  ///< Horizontal synchronization
    }

    /// RIS Register bits
    namespace ris_bits {
        constexpr uint32_t LINE_RIS = (1U << 4);  ///< Line raw interrupt status
        constexpr uint32_t VSYNC_RIS = (1U << 3);  ///< DCMI_VSYNC raw interrupt status
        constexpr uint32_t ERR_RIS = (1U << 2);  ///< Synchronization error raw interrupt status
        constexpr uint32_t OVR_RIS = (1U << 1);  ///< Overrun raw interrupt status
        constexpr uint32_t FRAME_RIS = (1U << 0);  ///< Capture complete raw interrupt status
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t LINE_IE = (1U << 4);  ///< Line interrupt enable
        constexpr uint32_t VSYNC_IE = (1U << 3);  ///< DCMI_VSYNC interrupt enable
        constexpr uint32_t ERR_IE = (1U << 2);  ///< Synchronization error interrupt enable
        constexpr uint32_t OVR_IE = (1U << 1);  ///< Overrun interrupt enable
        constexpr uint32_t FRAME_IE = (1U << 0);  ///< Capture complete interrupt enable
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t LINE_MIS = (1U << 4);  ///< Line masked interrupt status
        constexpr uint32_t VSYNC_MIS = (1U << 3);  ///< VSYNC masked interrupt status
        constexpr uint32_t ERR_MIS = (1U << 2);  ///< Synchronization error masked interrupt status
        constexpr uint32_t OVR_MIS = (1U << 1);  ///< Overrun masked interrupt status
        constexpr uint32_t FRAME_MIS = (1U << 0);  ///< Capture complete masked interrupt status
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t LINE_ISC = (1U << 4);  ///< line interrupt status clear
        constexpr uint32_t VSYNC_ISC = (1U << 3);  ///< Vertical Synchronization interrupt status clear
        constexpr uint32_t ERR_ISC = (1U << 2);  ///< Synchronization error interrupt status clear
        constexpr uint32_t OVR_ISC = (1U << 1);  ///< Overrun interrupt status clear
        constexpr uint32_t FRAME_ISC = (1U << 0);  ///< Capture complete interrupt status clear
    }

    /// ESCR Register bits
    namespace escr_bits {
        constexpr uint32_t FEC = (8 << 24);  ///< Frame end delimiter code
        constexpr uint32_t LEC = (8 << 16);  ///< Line end delimiter code
        constexpr uint32_t LSC = (8 << 8);  ///< Line start delimiter code
        constexpr uint32_t FSC = (8 << 0);  ///< Frame start delimiter code
    }

    /// ESUR Register bits
    namespace esur_bits {
        constexpr uint32_t FEU = (8 << 24);  ///< Frame end delimiter unmask
        constexpr uint32_t LEU = (8 << 16);  ///< Line end delimiter unmask
        constexpr uint32_t LSU = (8 << 8);  ///< Line start delimiter unmask
        constexpr uint32_t FSU = (8 << 0);  ///< Frame start delimiter unmask
    }

    /// CWSTRT Register bits
    namespace cwstrt_bits {
        constexpr uint32_t VST = (13 << 16);  ///< Vertical start line count
        constexpr uint32_t HOFFCNT = (14 << 0);  ///< Horizontal offset count
    }

    /// CWSIZE Register bits
    namespace cwsize_bits {
        constexpr uint32_t VLINE = (14 << 16);  ///< Vertical line count
        constexpr uint32_t CAPCNT = (14 << 0);  ///< Capture count
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t BYTE3 = (8 << 24);  ///< Data byte 3
        constexpr uint32_t BYTE2 = (8 << 16);  ///< Data byte 2
        constexpr uint32_t BYTE1 = (8 << 8);  ///< Data byte 1
        constexpr uint32_t BYTE0 = (8 << 0);  ///< Data byte 0
    }

}

// ============================================================================
// DCB Peripheral
// ============================================================================

namespace dcb {
    /// Base addresses
    constexpr uint32_t DCB_BASE = 0xE000EE08;

    /// DCB Register structure
    struct Registers {
        volatile uint32_t DSCSR;  ///< Offset: 0x00 - Debug Security Control and Status Register
    };

    /// Peripheral instances
    inline Registers* DCB = reinterpret_cast<Registers*>(DCB_BASE);

    // Bit definitions
    /// DSCSR Register bits
    namespace dscsr_bits {
        constexpr uint32_t CDS = (1U << 16);  ///< Current domain Secure
    }

}


} // namespace alloy::generated::stm32u585

#endif // ALLOY_GENERATED_STM32U585_PERIPHERALS_HPP