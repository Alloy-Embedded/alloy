/// Auto-generated code for STM32U5Gx
/// Generated by Alloy Code Generator
/// Source: st_stm32u5.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:44:31
#ifndef ALLOY_GENERATED_STM32U5GX_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32U5GX_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32u5gx {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 8;
    constexpr bool has_adf1 = true;
    constexpr uint32_t num_adf1_instances = 1;
    constexpr bool has_sec = true;
    constexpr uint32_t num_sec_instances = 45;
    constexpr bool has_crypto = true;
    constexpr uint32_t num_crypto_instances = 4;
    constexpr bool has_comp = true;
    constexpr uint32_t num_comp_instances = 2;
    constexpr bool has_cordic = true;
    constexpr uint32_t num_cordic_instances = 1;
    constexpr bool has_crc = true;
    constexpr uint32_t num_crc_instances = 1;
    constexpr bool has_crs = true;
    constexpr uint32_t num_crs_instances = 1;
    constexpr bool has_dac = true;
    constexpr uint32_t num_dac_instances = 2;
    constexpr bool has_dbgmcu = true;
    constexpr uint32_t num_dbgmcu_instances = 1;
    constexpr bool has_dcache1 = true;
    constexpr uint32_t num_dcache1_instances = 1;
    constexpr bool has_dcache2 = true;
    constexpr uint32_t num_dcache2_instances = 1;
    constexpr bool has_dcmi = true;
    constexpr uint32_t num_dcmi_instances = 1;
    constexpr bool has_dlybos1 = true;
    constexpr uint32_t num_dlybos1_instances = 1;
    constexpr bool has_dlybos2 = true;
    constexpr uint32_t num_dlybos2_instances = 1;
    constexpr bool has_dlybsd1 = true;
    constexpr uint32_t num_dlybsd1_instances = 1;
    constexpr bool has_dlybsd2 = true;
    constexpr uint32_t num_dlybsd2_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 6;
    constexpr bool has_dsi = true;
    constexpr uint32_t num_dsi_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_can = true;
    constexpr uint32_t num_can_instances = 4;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 2;
    constexpr bool has_fmac = true;
    constexpr uint32_t num_fmac_instances = 1;
    constexpr bool has_fmc = true;
    constexpr uint32_t num_fmc_instances = 1;
    constexpr bool has_gfxmmu = true;
    constexpr uint32_t num_gfxmmu_instances = 1;
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 32;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 22;
    constexpr bool has_gtzc1 = true;
    constexpr uint32_t num_gtzc1_instances = 7;
    constexpr bool has_gtzc2 = true;
    constexpr uint32_t num_gtzc2_instances = 3;
    constexpr bool has_hash = true;
    constexpr uint32_t num_hash_instances = 1;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 14;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 12;
    constexpr bool has_icache = true;
    constexpr uint32_t num_icache_instances = 1;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 4;
    constexpr bool has_jpeg = true;
    constexpr uint32_t num_jpeg_instances = 1;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 14;
    constexpr bool has_ltdc = true;
    constexpr uint32_t num_ltdc_instances = 1;
    constexpr bool has_mdf1 = true;
    constexpr uint32_t num_mdf1_instances = 1;
    constexpr bool has_opamp = true;
    constexpr uint32_t num_opamp_instances = 1;
    constexpr bool has_otfdec1 = true;
    constexpr uint32_t num_otfdec1_instances = 1;
    constexpr bool has_otfdec2 = true;
    constexpr uint32_t num_otfdec2_instances = 1;
    constexpr bool has_otg = true;
    constexpr uint32_t num_otg_instances = 1;
    constexpr bool has_pka = true;
    constexpr uint32_t num_pka_instances = 1;
    constexpr bool has_pssi = true;
    constexpr uint32_t num_pssi_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 2;
    constexpr bool has_ramcfg = true;
    constexpr uint32_t num_ramcfg_instances = 1;
    constexpr bool has_rcc = true;
    constexpr uint32_t num_rcc_instances = 2;
    constexpr bool has_rng = true;
    constexpr uint32_t num_rng_instances = 2;
    constexpr bool has_rtc = true;
    constexpr uint32_t num_rtc_instances = 2;
    constexpr bool has_sai1 = true;
    constexpr uint32_t num_sai1_instances = 1;
    constexpr bool has_sai2 = true;
    constexpr uint32_t num_sai2_instances = 1;
    constexpr bool has_sdio = true;
    constexpr uint32_t num_sdio_instances = 4;
    constexpr bool has_syscfg = true;
    constexpr uint32_t num_syscfg_instances = 1;
    constexpr bool has_tamp = true;
    constexpr uint32_t num_tamp_instances = 1;
    constexpr bool has_tsc = true;
    constexpr uint32_t num_tsc_instances = 1;
    constexpr bool has_ucpd1 = true;
    constexpr uint32_t num_ucpd1_instances = 1;
    constexpr bool has_vrefbuf = true;
    constexpr uint32_t num_vrefbuf_instances = 1;
    constexpr bool has_dcb = true;
    constexpr uint32_t num_dcb_instances = 1;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 8;
    };
    template<>
    struct peripheral_count<struct adf1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sec_tag> {
        static constexpr uint32_t value = 45;
    };
    template<>
    struct peripheral_count<struct crypto_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct comp_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct cordic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct crs_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dac_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct dbgmcu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcache1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcache2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcmi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlybos1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlybos2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlybsd1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dlybsd2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 6;
    };
    template<>
    struct peripheral_count<struct dsi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct can_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct fmac_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct fmc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gfxmmu_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 32;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 22;
    };
    template<>
    struct peripheral_count<struct gtzc1_tag> {
        static constexpr uint32_t value = 7;
    };
    template<>
    struct peripheral_count<struct gtzc2_tag> {
        static constexpr uint32_t value = 3;
    };
    template<>
    struct peripheral_count<struct hash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 14;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 12;
    };
    template<>
    struct peripheral_count<struct icache_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct jpeg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 14;
    };
    template<>
    struct peripheral_count<struct ltdc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mdf1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct opamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otfdec1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otfdec2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct otg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pka_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pssi_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct ramcfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rcc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rng_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct rtc_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct sai1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sai2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sdio_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct syscfg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tamp_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct tsc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct ucpd1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct vrefbuf_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dcb_tag> {
        static constexpr uint32_t value = 1;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 22;
    constexpr uint32_t max_gpio_pins = 352;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_lpuart1 = true;
    constexpr bool has_sec_lpuart1 = true;
    constexpr bool has_usart1 = true;
    constexpr bool has_sec_usart1 = true;
    constexpr bool has_usart2 = true;
    constexpr bool has_sec_usart2 = true;
    constexpr bool has_usart3 = true;
    constexpr bool has_sec_usart3 = true;
    constexpr bool has_uart4 = true;
    constexpr bool has_sec_uart4 = true;
    constexpr bool has_uart5 = true;
    constexpr bool has_sec_uart5 = true;
    constexpr bool has_usart6 = true;
    constexpr bool has_sec_usart6 = true;
}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC1_BASE = 0x42028000;
    constexpr uint32_t SEC_ADC1_BASE = 0x52028000;
    constexpr uint32_t ADC2_BASE = 0x42028100;
    constexpr uint32_t SEC_ADC2_BASE = 0x52028100;
    constexpr uint32_t ADC12_Common_BASE = 0x42028300;
    constexpr uint32_t SEC_ADC12_Common_BASE = 0x52028300;
    constexpr uint32_t ADC4_BASE = 0x46021000;
    constexpr uint32_t SEC_ADC4_BASE = 0x56021000;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_ISR;  ///< Offset: 0x00 - ADC interrupt and status register
        volatile uint32_t ADC_IER;  ///< Offset: 0x04 - ADC interrupt enable register
        volatile uint32_t ADC_CR;  ///< Offset: 0x08 - ADC control register
        volatile uint32_t ADC_CFGR1;  ///< Offset: 0x0C - ADC configuration register
        volatile uint32_t ADC_CFGR2;  ///< Offset: 0x10 - ADC configuration register 2
        volatile uint32_t ADC_SMPR1;  ///< Offset: 0x14 - ADC sample time register 1
        volatile uint32_t ADC_SMPR2;  ///< Offset: 0x18 - ADC sample time register 2
        volatile uint32_t ADC_PCSEL;  ///< Offset: 0x1C - ADC channel preselection register
        volatile uint32_t ADC_SQR1;  ///< Offset: 0x30 - ADC regular sequence register 1
        volatile uint32_t ADC_SQR2;  ///< Offset: 0x34 - ADC regular sequence register 2
        volatile uint32_t ADC_SQR3;  ///< Offset: 0x38 - ADC regular sequence register 3
        volatile uint32_t ADC_SQR4;  ///< Offset: 0x3C - ADC regular sequence register 4
        volatile uint32_t ADC_DR;  ///< Offset: 0x40 - ADC regular Data Register
        volatile uint32_t ADC_JSQR;  ///< Offset: 0x4C - ADC injected sequence register
        volatile uint32_t ADC_OFR1;  ///< Offset: 0x60 - ADC offset register
        volatile uint32_t ADC_OFR2;  ///< Offset: 0x64 - ADC offset register
        volatile uint32_t ADC_OFR3;  ///< Offset: 0x68 - ADC offset register
        volatile uint32_t ADC_OFR4;  ///< Offset: 0x6C - ADC offset register
        volatile uint32_t ADC_GCOMP;  ///< Offset: 0x70 - ADC gain compensation register
        volatile uint32_t ADC_JDR1;  ///< Offset: 0x80 - ADC injected data register
        volatile uint32_t ADC_JDR2;  ///< Offset: 0x84 - ADC injected data register
        volatile uint32_t ADC_JDR3;  ///< Offset: 0x88 - ADC injected data register
        volatile uint32_t ADC_JDR4;  ///< Offset: 0x8C - ADC injected data register
        volatile uint32_t ADC_AWD2CR;  ///< Offset: 0xA0 - ADC analog watchdog 2 configuration register
        volatile uint32_t ADC_AWD3CR;  ///< Offset: 0xA4 - ADC analog watchdog 3 configuration register
        volatile uint32_t ADC_LTR1;  ///< Offset: 0xA8 - ADC watchdog threshold register 1
        volatile uint32_t ADC_HTR1;  ///< Offset: 0xAC - ADC watchdog threshold register 1
        volatile uint32_t ADC_LTR2;  ///< Offset: 0xB0 - ADC watchdog lower threshold register 2
        volatile uint32_t ADC_HTR2;  ///< Offset: 0xB4 - ADC watchdog higher threshold register 2
        volatile uint32_t ADC_LTR3;  ///< Offset: 0xB8 - ADC watchdog lower threshold register 3
        volatile uint32_t ADC_HTR3;  ///< Offset: 0xBC - ADC watchdog higher threshold register 3
        volatile uint32_t ADC_DIFSEL;  ///< Offset: 0xC0 - ADC differential mode selection register
        volatile uint32_t ADC_CALFACT;  ///< Offset: 0xC4 - ADC user control register
        volatile uint32_t ADC_CALFACT2;  ///< Offset: 0xC8 - ADC calibration factor register
    };

    /// Peripheral instances
    inline Registers* ADC1 = reinterpret_cast<Registers*>(ADC1_BASE);
    inline Registers* SEC_ADC1 = reinterpret_cast<Registers*>(SEC_ADC1_BASE);
    inline Registers* ADC2 = reinterpret_cast<Registers*>(ADC2_BASE);
    inline Registers* SEC_ADC2 = reinterpret_cast<Registers*>(SEC_ADC2_BASE);
    inline Registers* ADC12_Common = reinterpret_cast<Registers*>(ADC12_Common_BASE);
    inline Registers* SEC_ADC12_Common = reinterpret_cast<Registers*>(SEC_ADC12_Common_BASE);
    inline Registers* ADC4 = reinterpret_cast<Registers*>(ADC4_BASE);
    inline Registers* SEC_ADC4 = reinterpret_cast<Registers*>(SEC_ADC4_BASE);

    // Bit definitions
    /// ADC_ISR Register bits
    namespace adc_isr_bits {
        constexpr uint32_t LDORDY = (1U << 12);  ///< LDORDY
        constexpr uint32_t AWD3 = (1U << 9);  ///< AWD3
        constexpr uint32_t AWD2 = (1U << 8);  ///< AWD2
        constexpr uint32_t AWD1 = (1U << 7);  ///< AWD1
        constexpr uint32_t JEOS = (1U << 6);  ///< JEOS
        constexpr uint32_t JEOC = (1U << 5);  ///< JEOC
        constexpr uint32_t OVR = (1U << 4);  ///< OVR
        constexpr uint32_t EOS = (1U << 3);  ///< EOS
        constexpr uint32_t EOC = (1U << 2);  ///< EOC
        constexpr uint32_t EOSMP = (1U << 1);  ///< EOSMP
        constexpr uint32_t ADRDY = (1U << 0);  ///< ADRDY
    }

    /// ADC_IER Register bits
    namespace adc_ier_bits {
        constexpr uint32_t AWD3IE = (1U << 9);  ///< AWD3IE
        constexpr uint32_t AWD2IE = (1U << 8);  ///< AWD2IE
        constexpr uint32_t AWD1IE = (1U << 7);  ///< AWD1IE
        constexpr uint32_t JEOSIE = (1U << 6);  ///< JEOSIE
        constexpr uint32_t JEOCIE = (1U << 5);  ///< JEOCIE
        constexpr uint32_t OVRIE = (1U << 4);  ///< OVRIE
        constexpr uint32_t EOSIE = (1U << 3);  ///< EOSIE
        constexpr uint32_t EOCIE = (1U << 2);  ///< EOCIE
        constexpr uint32_t EOSMPIE = (1U << 1);  ///< EOSMPIE
        constexpr uint32_t ADRDYIE = (1U << 0);  ///< ADRDYIE
    }

    /// ADC_CR Register bits
    namespace adc_cr_bits {
        constexpr uint32_t ADCAL = (1U << 31);  ///< ADCAL
        constexpr uint32_t DEEPPWD = (1U << 29);  ///< DEEPPWD
        constexpr uint32_t ADVREGEN = (1U << 28);  ///< ADVREGEN
        constexpr uint32_t CALINDEX = (4 << 24);  ///< CALINDEX
        constexpr uint32_t ADCALLIN = (1U << 16);  ///< ADCALLIN
        constexpr uint32_t JADSTP = (1U << 5);  ///< JADSTP
        constexpr uint32_t ADSTP = (1U << 4);  ///< ADSTP
        constexpr uint32_t JADSTART = (1U << 3);  ///< JADSTART
        constexpr uint32_t ADSTART = (1U << 2);  ///< ADSTART
        constexpr uint32_t ADDIS = (1U << 1);  ///< ADDIS
        constexpr uint32_t ADEN = (1U << 0);  ///< ADEN
    }

    /// ADC_CFGR1 Register bits
    namespace adc_cfgr1_bits {
        constexpr uint32_t AWD1CH = (5 << 26);  ///< AWD1CH
        constexpr uint32_t JAUTO = (1U << 25);  ///< JAUTO
        constexpr uint32_t JAWD1EN = (1U << 24);  ///< JAWD1EN
        constexpr uint32_t AWD1EN = (1U << 23);  ///< AWD1EN
        constexpr uint32_t AWD1SGL = (1U << 22);  ///< AWD1SGL
        constexpr uint32_t JDISCEN = (1U << 20);  ///< JDISCEN
        constexpr uint32_t DISCNUM = (3 << 17);  ///< DISCNUM
        constexpr uint32_t DISCEN = (1U << 16);  ///< DISCEN
        constexpr uint32_t AUTDLY = (1U << 14);  ///< AUTDLY
        constexpr uint32_t CONT = (1U << 13);  ///< CONT
        constexpr uint32_t OVRMOD = (1U << 12);  ///< OVRMOD
        constexpr uint32_t EXTEN = (2 << 10);  ///< EXTEN
        constexpr uint32_t EXTSEL = (5 << 5);  ///< EXTSEL
        constexpr uint32_t RES = (2 << 2);  ///< RES
        constexpr uint32_t DMNGT = (2 << 0);  ///< DMNGT
    }

    /// ADC_CFGR2 Register bits
    namespace adc_cfgr2_bits {
        constexpr uint32_t LSHIFT = (4 << 28);  ///< LSHIFT
        constexpr uint32_t LFTRIG = (1U << 27);  ///< LFTRIG
        constexpr uint32_t OSR = (10 << 16);  ///< OSR
        constexpr uint32_t SMPTRIG = (1U << 15);  ///< SMPTRIG
        constexpr uint32_t SWTRIG = (1U << 14);  ///< SWTRIG
        constexpr uint32_t BULB = (1U << 13);  ///< BULB
        constexpr uint32_t ROVSM = (1U << 10);  ///< ROVSM
        constexpr uint32_t TROVS = (1U << 9);  ///< TROVS
        constexpr uint32_t OVSS = (4 << 5);  ///< OVSS
        constexpr uint32_t JOVSE = (1U << 1);  ///< JOVSE
        constexpr uint32_t ROVSE = (1U << 0);  ///< ROVSE
    }

    /// ADC_SMPR1 Register bits
    namespace adc_smpr1_bits {
        constexpr uint32_t SMP9 = (3 << 27);  ///< SMP9
        constexpr uint32_t SMP8 = (3 << 24);  ///< SMP8
        constexpr uint32_t SMP7 = (3 << 21);  ///< SMP7
        constexpr uint32_t SMP6 = (3 << 18);  ///< SMP6
        constexpr uint32_t SMP5 = (3 << 15);  ///< SMP5
        constexpr uint32_t SMP4 = (3 << 12);  ///< SMP4
        constexpr uint32_t SMP3 = (3 << 9);  ///< SMP3
        constexpr uint32_t SMP2 = (3 << 6);  ///< SMP2
        constexpr uint32_t SMP1 = (3 << 3);  ///< SMP1
        constexpr uint32_t SMP0 = (3 << 0);  ///< SMP0
    }

    /// ADC_SMPR2 Register bits
    namespace adc_smpr2_bits {
        constexpr uint32_t SMP19 = (3 << 27);  ///< SMP19
        constexpr uint32_t SMP18 = (3 << 24);  ///< SMP18
        constexpr uint32_t SMP17 = (3 << 21);  ///< SMP17
        constexpr uint32_t SMP16 = (3 << 18);  ///< SMP16
        constexpr uint32_t SMP15 = (3 << 15);  ///< SMP15
        constexpr uint32_t SMP14 = (3 << 12);  ///< SMP14
        constexpr uint32_t SMP13 = (3 << 9);  ///< SMP13
        constexpr uint32_t SMP12 = (3 << 6);  ///< SMP12
        constexpr uint32_t SMP11 = (3 << 3);  ///< SMP11
        constexpr uint32_t SMP10 = (3 << 0);  ///< SMP10
    }

    /// ADC_PCSEL Register bits
    namespace adc_pcsel_bits {
        constexpr uint32_t PCSEL19 = (1U << 19);  ///< PCSEL19
        constexpr uint32_t PCSEL18 = (1U << 18);  ///< PCSEL18
        constexpr uint32_t PCSEL17 = (1U << 17);  ///< PCSEL17
        constexpr uint32_t PCSEL16 = (1U << 16);  ///< PCSEL16
        constexpr uint32_t PCSEL15 = (1U << 15);  ///< PCSEL15
        constexpr uint32_t PCSEL14 = (1U << 14);  ///< PCSEL14
        constexpr uint32_t PCSEL13 = (1U << 13);  ///< PCSEL13
        constexpr uint32_t PCSEL12 = (1U << 12);  ///< PCSEL12
        constexpr uint32_t PCSEL11 = (1U << 11);  ///< PCSEL11
        constexpr uint32_t PCSEL10 = (1U << 10);  ///< PCSEL10
        constexpr uint32_t PCSEL9 = (1U << 9);  ///< PCSEL9
        constexpr uint32_t PCSEL8 = (1U << 8);  ///< PCSEL8
        constexpr uint32_t PCSEL7 = (1U << 7);  ///< PCSEL7
        constexpr uint32_t PCSEL6 = (1U << 6);  ///< PCSEL6
        constexpr uint32_t PCSEL5 = (1U << 5);  ///< PCSEL5
        constexpr uint32_t PCSEL4 = (1U << 4);  ///< PCSEL4
        constexpr uint32_t PCSEL3 = (1U << 3);  ///< PCSEL3
        constexpr uint32_t PCSEL2 = (1U << 2);  ///< PCSEL2
        constexpr uint32_t PCSEL1 = (1U << 1);  ///< PCSEL1
        constexpr uint32_t PCSEL0 = (1U << 0);  ///< PCSEL0
    }

    /// ADC_SQR1 Register bits
    namespace adc_sqr1_bits {
        constexpr uint32_t SQ4 = (5 << 24);  ///< SQ4
        constexpr uint32_t SQ3 = (5 << 18);  ///< SQ3
        constexpr uint32_t SQ2 = (5 << 12);  ///< SQ2
        constexpr uint32_t SQ1 = (5 << 6);  ///< SQ1
        constexpr uint32_t L = (4 << 0);  ///< L
    }

    /// ADC_SQR2 Register bits
    namespace adc_sqr2_bits {
        constexpr uint32_t SQ9 = (5 << 24);  ///< SQ9
        constexpr uint32_t SQ8 = (5 << 18);  ///< SQ8
        constexpr uint32_t SQ7 = (5 << 12);  ///< SQ7
        constexpr uint32_t SQ6 = (5 << 6);  ///< SQ6
        constexpr uint32_t SQ5 = (5 << 0);  ///< SQ5
    }

    /// ADC_SQR3 Register bits
    namespace adc_sqr3_bits {
        constexpr uint32_t SQ14 = (5 << 24);  ///< SQ14
        constexpr uint32_t SQ13 = (5 << 18);  ///< SQ13
        constexpr uint32_t SQ12 = (5 << 12);  ///< SQ12
        constexpr uint32_t SQ11 = (5 << 6);  ///< SQ11
        constexpr uint32_t SQ10 = (5 << 0);  ///< SQ10
    }

    /// ADC_SQR4 Register bits
    namespace adc_sqr4_bits {
        constexpr uint32_t SQ16 = (5 << 6);  ///< SQ16
        constexpr uint32_t SQ15 = (5 << 0);  ///< SQ15
    }

    /// ADC_DR Register bits
    namespace adc_dr_bits {
        constexpr uint32_t RDATA = (32 << 0);  ///< RDATA
    }

    /// ADC_JSQR Register bits
    namespace adc_jsqr_bits {
        constexpr uint32_t JSQ4 = (5 << 27);  ///< JSQ4
        constexpr uint32_t JSQ3 = (5 << 21);  ///< JSQ3
        constexpr uint32_t JSQ2 = (5 << 15);  ///< JSQ2
        constexpr uint32_t JSQ1 = (5 << 9);  ///< JSQ1
        constexpr uint32_t JEXTEN = (2 << 7);  ///< JEXTEN
        constexpr uint32_t JEXTSEL = (5 << 2);  ///< JEXTSEL
        constexpr uint32_t JL = (2 << 0);  ///< JL
    }

    /// ADC_OFR1 Register bits
    namespace adc_ofr1_bits {
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< OFFSET_CH
        constexpr uint32_t SSAT = (1U << 26);  ///< SSAT
        constexpr uint32_t USAT = (1U << 25);  ///< USAT
        constexpr uint32_t POSOFF = (1U << 24);  ///< POSOFF
        constexpr uint32_t OFFSET = (24 << 0);  ///< OFFSET
    }

    /// ADC_OFR2 Register bits
    namespace adc_ofr2_bits {
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< OFFSET_CH
        constexpr uint32_t SSAT = (1U << 26);  ///< SSAT
        constexpr uint32_t USAT = (1U << 25);  ///< USAT
        constexpr uint32_t POSOFF = (1U << 24);  ///< POSOFF
        constexpr uint32_t OFFSET = (24 << 0);  ///< OFFSET
    }

    /// ADC_OFR3 Register bits
    namespace adc_ofr3_bits {
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< OFFSET_CH
        constexpr uint32_t SSAT = (1U << 26);  ///< SSAT
        constexpr uint32_t USAT = (1U << 25);  ///< USAT
        constexpr uint32_t POSOFF = (1U << 24);  ///< POSOFF
        constexpr uint32_t OFFSET = (24 << 0);  ///< OFFSET
    }

    /// ADC_OFR4 Register bits
    namespace adc_ofr4_bits {
        constexpr uint32_t OFFSET_CH = (5 << 27);  ///< OFFSET_CH
        constexpr uint32_t SSAT = (1U << 26);  ///< SSAT
        constexpr uint32_t USAT = (1U << 25);  ///< USAT
        constexpr uint32_t POSOFF = (1U << 24);  ///< POSOFF
        constexpr uint32_t OFFSET = (24 << 0);  ///< OFFSET
    }

    /// ADC_GCOMP Register bits
    namespace adc_gcomp_bits {
        constexpr uint32_t GCOMP = (1U << 31);  ///< GCOMP
        constexpr uint32_t GCOMPCOEFF = (14 << 0);  ///< GCOMPCOEFF
    }

    /// ADC_JDR1 Register bits
    namespace adc_jdr1_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< JDATA
    }

    /// ADC_JDR2 Register bits
    namespace adc_jdr2_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< JDATA
    }

    /// ADC_JDR3 Register bits
    namespace adc_jdr3_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< JDATA
    }

    /// ADC_JDR4 Register bits
    namespace adc_jdr4_bits {
        constexpr uint32_t JDATA = (32 << 0);  ///< JDATA
    }

    /// ADC_AWD2CR Register bits
    namespace adc_awd2cr_bits {
        constexpr uint32_t AWD2CH = (20 << 0);  ///< AWD2CH
    }

    /// ADC_AWD3CR Register bits
    namespace adc_awd3cr_bits {
        constexpr uint32_t AWD3CH = (20 << 0);  ///< AWD3CH
    }

    /// ADC_LTR1 Register bits
    namespace adc_ltr1_bits {
        constexpr uint32_t LTR1 = (25 << 0);  ///< LTR1
    }

    /// ADC_HTR1 Register bits
    namespace adc_htr1_bits {
        constexpr uint32_t AWDFILT1 = (3 << 29);  ///< AWDFILT1
        constexpr uint32_t HTR1 = (25 << 0);  ///< HTR1
    }

    /// ADC_LTR2 Register bits
    namespace adc_ltr2_bits {
        constexpr uint32_t LTR2 = (25 << 0);  ///< LTR2
    }

    /// ADC_HTR2 Register bits
    namespace adc_htr2_bits {
        constexpr uint32_t HTR2 = (25 << 0);  ///< HTR2
    }

    /// ADC_LTR3 Register bits
    namespace adc_ltr3_bits {
        constexpr uint32_t LTR3 = (25 << 0);  ///< LTR3
    }

    /// ADC_HTR3 Register bits
    namespace adc_htr3_bits {
        constexpr uint32_t HTR3 = (25 << 0);  ///< HTR3
    }

    /// ADC_DIFSEL Register bits
    namespace adc_difsel_bits {
        constexpr uint32_t DIFSEL = (20 << 0);  ///< DIFSEL
    }

    /// ADC_CALFACT Register bits
    namespace adc_calfact_bits {
        constexpr uint32_t CAPTURE_COEF = (1U << 25);  ///< CAPTURE_COEF
        constexpr uint32_t LATCH_COEF = (1U << 24);  ///< LATCH_COEF
        constexpr uint32_t VALIDITY = (1U << 16);  ///< VALIDITY
        constexpr uint32_t I_APB_DATA = (8 << 8);  ///< I_APB_DATA
        constexpr uint32_t I_APB_ADDR = (8 << 0);  ///< I_APB_ADDR
    }

    /// ADC_CALFACT2 Register bits
    namespace adc_calfact2_bits {
        constexpr uint32_t CALFACT = (32 << 0);  ///< CALFACT
    }

}

// ============================================================================
// ADF1 Peripheral
// ============================================================================

namespace adf1 {
    /// Base addresses
    constexpr uint32_t ADF1_BASE = 0x46024000;

    /// ADF1 Register structure
    struct Registers {
        volatile uint32_t ADF_GCR;  ///< Offset: 0x00 - ADF Global Control Register
        volatile uint32_t ADF_CKGCR;  ///< Offset: 0x04 - ADF clock generator control register
        volatile uint32_t ADF_SITF0CR;  ///< Offset: 0x80 - ADF serial interface control register 0
        volatile uint32_t ADF_BSMX0CR;  ///< Offset: 0x84 - ADF bitstream matrix control register 0
        volatile uint32_t ADF_DFLT0CR;  ///< Offset: 0x88 - ADF digital filter control register 0
        volatile uint32_t ADF_DFLT0CICR;  ///< Offset: 0x8C - ADF digital filer configuration register 0
        volatile uint32_t ADF_DFLT0RSFR;  ///< Offset: 0x90 - ADF reshape filter configuration register 0
        volatile uint32_t ADF_DLY0CR;  ///< Offset: 0xA4 - ADF delay control register 0
        volatile uint32_t ADF_DFLT0IER;  ///< Offset: 0xAC - ADF DFLT0 interrupt enable register
        volatile uint32_t ADF_DFLT0ISR;  ///< Offset: 0xB0 - ADF DFLT0 interrupt status register 0
        volatile uint32_t ADF_SADCR;  ///< Offset: 0xB8 - ADF SAD control register
        volatile uint32_t ADF_SADCFGR;  ///< Offset: 0xBC - ADF SAD configuration register
        volatile uint32_t ADF_SADSDLVR;  ///< Offset: 0xC0 - ADF SAD sound level register
        volatile uint32_t ADF_SADANLVR;  ///< Offset: 0xC4 - ADF SAD ambient noise level register
        volatile uint32_t ADF_DFLT0DR;  ///< Offset: 0xF0 - ADF digital filter data register 0
    };

    /// Peripheral instances
    inline Registers* ADF1 = reinterpret_cast<Registers*>(ADF1_BASE);

    // Bit definitions
    /// ADF_GCR Register bits
    namespace adf_gcr_bits {
        constexpr uint32_t TRGO = (1U << 0);  ///< Trigger output control Set by software and reset by
    }

    /// ADF_CKGCR Register bits
    namespace adf_ckgcr_bits {
        constexpr uint32_t CKGACTIVE = (1U << 31);  ///< Clock generator active flag
        constexpr uint32_t PROCDIV = (7 << 24);  ///< Divider to control the serial interface clock
        constexpr uint32_t CCKDIV = (4 << 16);  ///< Divider to control the ADF_CCK clock
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter trigger signal selection
        constexpr uint32_t TRGSENS = (1U << 8);  ///< CKGEN trigger sensitivity selection
        constexpr uint32_t CCK1DIR = (1U << 6);  ///< ADF_CCK1 direction
        constexpr uint32_t CCK0DIR = (1U << 5);  ///< ADF_CCK0 direction
        constexpr uint32_t CKGMOD = (1U << 4);  ///< Clock generator mode
        constexpr uint32_t CCK1EN = (1U << 2);  ///< ADF_CCK1 clock enable
        constexpr uint32_t CCK0EN = (1U << 1);  ///< ADF_CCK0 clock enable
        constexpr uint32_t CKGDEN = (1U << 0);  ///< CKGEN dividers enable
    }

    /// ADF_SITF0CR Register bits
    namespace adf_sitf0cr_bits {
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< SITFACTIVE
        constexpr uint32_t STH = (5 << 8);  ///< STH
        constexpr uint32_t SITFMOD = (2 << 4);  ///< SITFMOD
        constexpr uint32_t SCKSRC = (2 << 1);  ///< SCKSRC
        constexpr uint32_t SITFEN = (1U << 0);  ///< SITFEN
    }

    /// ADF_BSMX0CR Register bits
    namespace adf_bsmx0cr_bits {
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX active flag
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream selection
    }

    /// ADF_DFLT0CR Register bits
    namespace adf_dflt0cr_bits {
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< DFLT0 active flag
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< DFLT0 run status flag
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded
        constexpr uint32_t TRGSRC = (4 << 12);  ///< DFLT0 trigger signal selection
        constexpr uint32_t ACQMOD = (3 << 4);  ///< DFLT0 trigger mode
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO threshold selection
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA requests enable
        constexpr uint32_t DFLTEN = (1U << 0);  ///< DFLT0 enable
    }

    /// ADF_DFLT0CICR Register bits
    namespace adf_dflt0cicr_bits {
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC order
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter
    }

    /// ADF_DFLT0RSFR Register bits
    namespace adf_dflt0rsfr_bits {
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-pass filter bypass
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass
    }

    /// ADF_DLY0CR Register bits
    namespace adf_dly0cr_bits {
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip busy flag
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream
    }

    /// ADF_DFLT0IER Register bits
    namespace adf_dflt0ier_bits {
        constexpr uint32_t SDLVLIE = (1U << 13);  ///< SAD sound-level value ready enable
        constexpr uint32_t SDDETIE = (1U << 12);  ///< Sound activity detection interrupt enable
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape filter overrun interrupt enable
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable
    }

    /// ADF_DFLT0ISR Register bits
    namespace adf_dflt0isr_bits {
        constexpr uint32_t SDLVLF = (1U << 13);  ///< Sound level value ready flag
        constexpr uint32_t SDDETF = (1U << 12);  ///< Sound activity detection flag
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape filter overrun detection flag
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO not empty flag
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag
    }

    /// ADF_SADCR Register bits
    namespace adf_sadcr_bits {
        constexpr uint32_t SADACTIVE = (1U << 31);  ///< SAD Active flag
        constexpr uint32_t SADMOD = (2 << 12);  ///< SAD working mode
        constexpr uint32_t FRSIZE = (3 << 8);  ///< Frame size
        constexpr uint32_t HYSTEN = (1U << 7);  ///< Hysteresis enable
        constexpr uint32_t SADST = (2 << 4);  ///< SAD state
        constexpr uint32_t DETCFG = (1U << 3);  ///< Sound trigger event configuration
        constexpr uint32_t DATCAP = (2 << 1);  ///< Data capture mode
        constexpr uint32_t SADEN = (1U << 0);  ///< Sound activity detector enable
    }

    /// ADF_SADCFGR Register bits
    namespace adf_sadcfgr_bits {
        constexpr uint32_t ANMIN = (13 << 16);  ///< ANMIN
        constexpr uint32_t HGOVR = (3 << 12);  ///< Hangover time window
        constexpr uint32_t LFRNB = (3 << 8);  ///< LFRNB
        constexpr uint32_t ANSLP = (3 << 4);  ///< ANSLP
        constexpr uint32_t SNTHR = (4 << 0);  ///< SNTHR
    }

    /// ADF_SADSDLVR Register bits
    namespace adf_sadsdlvr_bits {
        constexpr uint32_t SDLVL = (15 << 0);  ///< SDLVL
    }

    /// ADF_SADANLVR Register bits
    namespace adf_sadanlvr_bits {
        constexpr uint32_t ANLVL = (15 << 0);  ///< ANLVL
    }

    /// ADF_DFLT0DR Register bits
    namespace adf_dflt0dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< DR
    }

}

// ============================================================================
// SEC Peripheral
// ============================================================================

namespace sec {
    /// Base addresses
    constexpr uint32_t SEC_ADF1_BASE = 0x56024000;
    constexpr uint32_t SEC_CORDIC_BASE = 0x50021000;
    constexpr uint32_t SEC_CRC_BASE = 0x50023000;
    constexpr uint32_t SEC_CRS_BASE = 0x50006000;
    constexpr uint32_t SEC_DCACHE1_BASE = 0x50031400;
    constexpr uint32_t SEC_DCACHE2_BASE = 0x50031800;
    constexpr uint32_t SEC_DCMI_BASE = 0x5202C000;
    constexpr uint32_t SEC_DLYBOS1_BASE = 0x520CF000;
    constexpr uint32_t SEC_DLYBOS2_BASE = 0x520CF400;
    constexpr uint32_t SEC_DLYBSD1_BASE = 0x520C8400;
    constexpr uint32_t SEC_DLYBSD2_BASE = 0x520C8800;
    constexpr uint32_t SEC_DSI_BASE = 0x50016C00;
    constexpr uint32_t SEC_EXTI_BASE = 0x56022000;
    constexpr uint32_t SEC_FMAC_BASE = 0x50021400;
    constexpr uint32_t SEC_FMC_BASE = 0x520D0400;
    constexpr uint32_t SEC_GFXMMU_BASE = 0x5002C000;
    constexpr uint32_t SEC_GTZC1_MPCBB1_BASE = 0x50032C00;
    constexpr uint32_t SEC_GTZC1_MPCBB2_BASE = 0x50033000;
    constexpr uint32_t SEC_GTZC1_MPCBB3_BASE = 0x50033400;
    constexpr uint32_t SEC_GTZC1_MPCBB5_BASE = 0x50033800;
    constexpr uint32_t SEC_GTZC1_MPCBB6_BASE = 0x50033C00;
    constexpr uint32_t SEC_GTZC1_TZIC_BASE = 0x50032800;
    constexpr uint32_t SEC_GTZC1_TZSC_BASE = 0x50032400;
    constexpr uint32_t SEC_GTZC2_MPCBB4_BASE = 0x56023800;
    constexpr uint32_t SEC_GTZC2_TZIC_BASE = 0x56023400;
    constexpr uint32_t SEC_GTZC2_TZSC_BASE = 0x56023000;
    constexpr uint32_t SEC_HASH_BASE = 0x520C0400;
    constexpr uint32_t SEC_ICache_BASE = 0x50030400;
    constexpr uint32_t SEC_JPEG_BASE = 0x5002A000;
    constexpr uint32_t SEC_LTDC_BASE = 0x50016800;
    constexpr uint32_t SEC_MDF1_BASE = 0x50025000;
    constexpr uint32_t SEC_OPAMP_BASE = 0x56005000;
    constexpr uint32_t SEC_OTFDEC1_BASE = 0x520C5000;
    constexpr uint32_t SEC_OTFDEC2_BASE = 0x520C5400;
    constexpr uint32_t SEC_OTG_HS_BASE = 0x52040000;
    constexpr uint32_t SEC_PKA_BASE = 0x520C2000;
    constexpr uint32_t SEC_PSSI_BASE = 0x5202C400;
    constexpr uint32_t SEC_RAMCFG_BASE = 0x50026000;
    constexpr uint32_t SEC_SAI1_BASE = 0x50015400;
    constexpr uint32_t SEC_SAI2_BASE = 0x50015800;
    constexpr uint32_t SEC_SYSCFG_BASE = 0x56000400;
    constexpr uint32_t SEC_TAMP_BASE = 0x56007C00;
    constexpr uint32_t SEC_TSC_BASE = 0x50024000;
    constexpr uint32_t SEC_UCPD1_BASE = 0x5000DC00;
    constexpr uint32_t SEC_VREFBUF_BASE = 0x56007400;

    /// SEC Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SEC_ADF1 = reinterpret_cast<Registers*>(SEC_ADF1_BASE);
    inline Registers* SEC_CORDIC = reinterpret_cast<Registers*>(SEC_CORDIC_BASE);
    inline Registers* SEC_CRC = reinterpret_cast<Registers*>(SEC_CRC_BASE);
    inline Registers* SEC_CRS = reinterpret_cast<Registers*>(SEC_CRS_BASE);
    inline Registers* SEC_DCACHE1 = reinterpret_cast<Registers*>(SEC_DCACHE1_BASE);
    inline Registers* SEC_DCACHE2 = reinterpret_cast<Registers*>(SEC_DCACHE2_BASE);
    inline Registers* SEC_DCMI = reinterpret_cast<Registers*>(SEC_DCMI_BASE);
    inline Registers* SEC_DLYBOS1 = reinterpret_cast<Registers*>(SEC_DLYBOS1_BASE);
    inline Registers* SEC_DLYBOS2 = reinterpret_cast<Registers*>(SEC_DLYBOS2_BASE);
    inline Registers* SEC_DLYBSD1 = reinterpret_cast<Registers*>(SEC_DLYBSD1_BASE);
    inline Registers* SEC_DLYBSD2 = reinterpret_cast<Registers*>(SEC_DLYBSD2_BASE);
    inline Registers* SEC_DSI = reinterpret_cast<Registers*>(SEC_DSI_BASE);
    inline Registers* SEC_EXTI = reinterpret_cast<Registers*>(SEC_EXTI_BASE);
    inline Registers* SEC_FMAC = reinterpret_cast<Registers*>(SEC_FMAC_BASE);
    inline Registers* SEC_FMC = reinterpret_cast<Registers*>(SEC_FMC_BASE);
    inline Registers* SEC_GFXMMU = reinterpret_cast<Registers*>(SEC_GFXMMU_BASE);
    inline Registers* SEC_GTZC1_MPCBB1 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB1_BASE);
    inline Registers* SEC_GTZC1_MPCBB2 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB2_BASE);
    inline Registers* SEC_GTZC1_MPCBB3 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB3_BASE);
    inline Registers* SEC_GTZC1_MPCBB5 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB5_BASE);
    inline Registers* SEC_GTZC1_MPCBB6 = reinterpret_cast<Registers*>(SEC_GTZC1_MPCBB6_BASE);
    inline Registers* SEC_GTZC1_TZIC = reinterpret_cast<Registers*>(SEC_GTZC1_TZIC_BASE);
    inline Registers* SEC_GTZC1_TZSC = reinterpret_cast<Registers*>(SEC_GTZC1_TZSC_BASE);
    inline Registers* SEC_GTZC2_MPCBB4 = reinterpret_cast<Registers*>(SEC_GTZC2_MPCBB4_BASE);
    inline Registers* SEC_GTZC2_TZIC = reinterpret_cast<Registers*>(SEC_GTZC2_TZIC_BASE);
    inline Registers* SEC_GTZC2_TZSC = reinterpret_cast<Registers*>(SEC_GTZC2_TZSC_BASE);
    inline Registers* SEC_HASH = reinterpret_cast<Registers*>(SEC_HASH_BASE);
    inline Registers* SEC_ICache = reinterpret_cast<Registers*>(SEC_ICache_BASE);
    inline Registers* SEC_JPEG = reinterpret_cast<Registers*>(SEC_JPEG_BASE);
    inline Registers* SEC_LTDC = reinterpret_cast<Registers*>(SEC_LTDC_BASE);
    inline Registers* SEC_MDF1 = reinterpret_cast<Registers*>(SEC_MDF1_BASE);
    inline Registers* SEC_OPAMP = reinterpret_cast<Registers*>(SEC_OPAMP_BASE);
    inline Registers* SEC_OTFDEC1 = reinterpret_cast<Registers*>(SEC_OTFDEC1_BASE);
    inline Registers* SEC_OTFDEC2 = reinterpret_cast<Registers*>(SEC_OTFDEC2_BASE);
    inline Registers* SEC_OTG_HS = reinterpret_cast<Registers*>(SEC_OTG_HS_BASE);
    inline Registers* SEC_PKA = reinterpret_cast<Registers*>(SEC_PKA_BASE);
    inline Registers* SEC_PSSI = reinterpret_cast<Registers*>(SEC_PSSI_BASE);
    inline Registers* SEC_RAMCFG = reinterpret_cast<Registers*>(SEC_RAMCFG_BASE);
    inline Registers* SEC_SAI1 = reinterpret_cast<Registers*>(SEC_SAI1_BASE);
    inline Registers* SEC_SAI2 = reinterpret_cast<Registers*>(SEC_SAI2_BASE);
    inline Registers* SEC_SYSCFG = reinterpret_cast<Registers*>(SEC_SYSCFG_BASE);
    inline Registers* SEC_TAMP = reinterpret_cast<Registers*>(SEC_TAMP_BASE);
    inline Registers* SEC_TSC = reinterpret_cast<Registers*>(SEC_TSC_BASE);
    inline Registers* SEC_UCPD1 = reinterpret_cast<Registers*>(SEC_UCPD1_BASE);
    inline Registers* SEC_VREFBUF = reinterpret_cast<Registers*>(SEC_VREFBUF_BASE);

}

// ============================================================================
// CRYPTO Peripheral
// ============================================================================

namespace crypto {
    /// Base addresses
    constexpr uint32_t AES_BASE = 0x420C0000;
    constexpr uint32_t SEC_AES_BASE = 0x520C0000;
    constexpr uint32_t SAES_BASE = 0x420C0C00;
    constexpr uint32_t SEC_SAES_BASE = 0x520C0C00;

    /// CRYPTO Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DINR;  ///< Offset: 0x08 - data input register
        volatile uint32_t DOUTR;  ///< Offset: 0x0C - data output register
        volatile uint32_t KEYR0;  ///< Offset: 0x10 - key register 0
        volatile uint32_t KEYR1;  ///< Offset: 0x14 - key register 1
        volatile uint32_t KEYR2;  ///< Offset: 0x18 - key register 2
        volatile uint32_t KEYR3;  ///< Offset: 0x1C - key register 3
        volatile uint32_t IVR0;  ///< Offset: 0x20 - initialization vector register 0
        volatile uint32_t IVR1;  ///< Offset: 0x24 - initialization vector register 1
        volatile uint32_t IVR2;  ///< Offset: 0x28 - initialization vector register 2
        volatile uint32_t IVR3;  ///< Offset: 0x2C - initialization vector register 3
        volatile uint32_t KEYR4;  ///< Offset: 0x30 - key register 4
        volatile uint32_t KEYR5;  ///< Offset: 0x34 - key register 5
        volatile uint32_t KEYR6;  ///< Offset: 0x38 - key register 6
        volatile uint32_t KEYR7;  ///< Offset: 0x3C - key register 7
        volatile uint32_t SUSP0R;  ///< Offset: 0x40 - suspend registers
        volatile uint32_t SUSP1R;  ///< Offset: 0x44 - suspend registers
        volatile uint32_t SUSP2R;  ///< Offset: 0x48 - suspend registers
        volatile uint32_t SUSP3R;  ///< Offset: 0x4C - suspend registers
        volatile uint32_t SUSP4R;  ///< Offset: 0x50 - suspend registers
        volatile uint32_t SUSP5R;  ///< Offset: 0x54 - suspend registers
        volatile uint32_t SUSP6R;  ///< Offset: 0x58 - suspend registers
        volatile uint32_t SUSP7R;  ///< Offset: 0x5C - suspend registers
        volatile uint32_t IER;  ///< Offset: 0x300 - interrupt enable register
        volatile uint32_t ISR;  ///< Offset: 0x304 - interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x308 - interrupt clear register
    };

    /// Peripheral instances
    inline Registers* AES = reinterpret_cast<Registers*>(AES_BASE);
    inline Registers* SEC_AES = reinterpret_cast<Registers*>(SEC_AES_BASE);
    inline Registers* SAES = reinterpret_cast<Registers*>(SAES_BASE);
    inline Registers* SEC_SAES = reinterpret_cast<Registers*>(SEC_SAES_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t IPRST = (1U << 31);  ///< IPRST
        constexpr uint32_t KMOD = (2 << 24);  ///< KMOD
        constexpr uint32_t NPBLB = (4 << 20);  ///< NPBLB
        constexpr uint32_t KEYSIZE = (1U << 18);  ///< KEYSIZE
        constexpr uint32_t CHMOD_2 = (1U << 16);  ///< CHMOD_2
        constexpr uint32_t GCMPH = (2 << 13);  ///< GCMPH
        constexpr uint32_t DMAOUTEN = (1U << 12);  ///< Enable DMA management of data output phase
        constexpr uint32_t DMAINEN = (1U << 11);  ///< Enable DMA management of data input phase
        constexpr uint32_t CHMOD = (2 << 5);  ///< AES chaining mode
        constexpr uint32_t MODE = (2 << 3);  ///< AES operating mode
        constexpr uint32_t DATATYPE = (2 << 1);  ///< Data type selection (for data in and data out to/from the cryptographic block)
        constexpr uint32_t EN = (1U << 0);  ///< AES enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t KEYVALID = (1U << 7);  ///< Key Valid flag
        constexpr uint32_t BUSY = (1U << 3);  ///< BUSY
        constexpr uint32_t WRERR = (1U << 2);  ///< Write error flag
        constexpr uint32_t RDERR = (1U << 1);  ///< Read error flag
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag
    }

    /// DINR Register bits
    namespace dinr_bits {
        constexpr uint32_t DIN = (32 << 0);  ///< Input data word
    }

    /// DOUTR Register bits
    namespace doutr_bits {
        constexpr uint32_t DOUT = (32 << 0);  ///< Output data word
    }

    /// KEYR0 Register bits
    namespace keyr0_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [31:0]
    }

    /// KEYR1 Register bits
    namespace keyr1_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [63:32]
    }

    /// KEYR2 Register bits
    namespace keyr2_bits {
        constexpr uint32_t KEYR = (32 << 0);  ///< Cryptographic key, bits [95:64]
    }

    /// KEYR3 Register bits
    namespace keyr3_bits {
        constexpr uint32_t AES_KEYR3 = (32 << 0);  ///< Cryptographic key, bits [127:96]
    }

    /// IVR0 Register bits
    namespace ivr0_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [31:0]
    }

    /// IVR1 Register bits
    namespace ivr1_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [63:32]
    }

    /// IVR2 Register bits
    namespace ivr2_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [95:64]
    }

    /// IVR3 Register bits
    namespace ivr3_bits {
        constexpr uint32_t IVI = (32 << 0);  ///< Initialization vector input, bits [127:96]
    }

    /// KEYR4 Register bits
    namespace keyr4_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [159:128]
    }

    /// KEYR5 Register bits
    namespace keyr5_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [191:160]
    }

    /// KEYR6 Register bits
    namespace keyr6_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [223:192]
    }

    /// KEYR7 Register bits
    namespace keyr7_bits {
        constexpr uint32_t KEY = (32 << 0);  ///< Cryptographic key, bits [255:224]
    }

    /// SUSP0R Register bits
    namespace susp0r_bits {
        constexpr uint32_t SUSP0 = (32 << 0);  ///< AES suspend
    }

    /// SUSP1R Register bits
    namespace susp1r_bits {
        constexpr uint32_t SUSP1 = (32 << 0);  ///< AES suspend
    }

    /// SUSP2R Register bits
    namespace susp2r_bits {
        constexpr uint32_t SUSP2 = (32 << 0);  ///< AES suspend
    }

    /// SUSP3R Register bits
    namespace susp3r_bits {
        constexpr uint32_t SUSP3 = (32 << 0);  ///< AES suspend
    }

    /// SUSP4R Register bits
    namespace susp4r_bits {
        constexpr uint32_t SUSP4 = (32 << 0);  ///< AES suspend
    }

    /// SUSP5R Register bits
    namespace susp5r_bits {
        constexpr uint32_t SUSP5 = (32 << 0);  ///< AES suspend
    }

    /// SUSP6R Register bits
    namespace susp6r_bits {
        constexpr uint32_t SUSP6 = (32 << 0);  ///< AES suspend
    }

    /// SUSP7R Register bits
    namespace susp7r_bits {
        constexpr uint32_t SUSP7 = (32 << 0);  ///< AES suspend
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t KEIE = (1U << 2);  ///< Key error interrupt flag
        constexpr uint32_t RWEIE = (1U << 1);  ///< Read or write error interrupt flag
        constexpr uint32_t CCFIE = (1U << 0);  ///< Computation complete flag
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t KEIF = (1U << 2);  ///< Key error interrupt flag
        constexpr uint32_t RWEIF = (1U << 1);  ///< Read or write error interrupt flag
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t KEIF = (1U << 2);  ///< Key error interrupt flag clear
        constexpr uint32_t RWEIF = (1U << 1);  ///< Read or write error interrupt flag clear
        constexpr uint32_t CCF = (1U << 0);  ///< Computation complete flag clear
    }

}

// ============================================================================
// COMP Peripheral
// ============================================================================

namespace comp {
    /// Base addresses
    constexpr uint32_t COMP_BASE = 0x46005400;
    constexpr uint32_t SEC_COMP_BASE = 0x56005400;

    /// COMP Register structure
    struct Registers {
        volatile uint32_t COMP1_CSR;  ///< Offset: 0x00 - Comparator 1 control and status register
        volatile uint32_t COMP2_CSR;  ///< Offset: 0x04 - Comparator 2 control and status register
    };

    /// Peripheral instances
    inline Registers* COMP = reinterpret_cast<Registers*>(COMP_BASE);
    inline Registers* SEC_COMP = reinterpret_cast<Registers*>(SEC_COMP_BASE);

    // Bit definitions
    /// COMP1_CSR Register bits
    namespace comp1_csr_bits {
        constexpr uint32_t COMP1_EN = (1U << 0);  ///< Comparator 1 enable bit
        constexpr uint32_t COMP1_INMSEL = (4 << 4);  ///< Comparator 1 Input Minus connection configuration bit
        constexpr uint32_t COMP1_INPSEL = (2 << 8);  ///< Comparator1 input plus selection bit
        constexpr uint32_t COMP1_WINMODE = (1U << 11);  ///< COMP1_WINMODE
        constexpr uint32_t COMP1_WINOUT = (1U << 14);  ///< COMP1_WINOUT
        constexpr uint32_t COMP1_POLARITY = (1U << 15);  ///< Comparator 1 polarity selection bit
        constexpr uint32_t COMP1_HYST = (2 << 16);  ///< Comparator 1 hysteresis selection bits
        constexpr uint32_t COMP1_PWRMODE = (2 << 18);  ///< COMP1_PWRMODE
        constexpr uint32_t COMP1_BLANKSEL = (5 << 20);  ///< COMP1_BLANKSEL
        constexpr uint32_t COMP1_VALUE = (1U << 30);  ///< Comparator 1 output status bit
        constexpr uint32_t COMP1_LOCK = (1U << 31);  ///< COMP1_CSR register lock bit
    }

    /// COMP2_CSR Register bits
    namespace comp2_csr_bits {
        constexpr uint32_t COM2_EN = (1U << 0);  ///< Comparator 2 enable bit
        constexpr uint32_t COM2_INMSEL = (4 << 4);  ///< Comparator 2 Input Minus connection configuration bit
        constexpr uint32_t COM2_INPSEL = (2 << 8);  ///< Comparator 2 input plus selection bit
        constexpr uint32_t COM2_WINMODE = (1U << 11);  ///< COM2_WINMODE
        constexpr uint32_t COM2_WINOUT = (1U << 14);  ///< COM2_WINOUT
        constexpr uint32_t COM2_POLARITY = (1U << 15);  ///< Comparator 2 polarity selection bit
        constexpr uint32_t COM2_HYST = (2 << 16);  ///< Comparator 2 hysteresis selection bits
        constexpr uint32_t COM2_PWRMODE = (2 << 18);  ///< COM2_PWRMODE
        constexpr uint32_t COM2_BLANKSEL = (5 << 20);  ///< COM2_BLANKSEL
        constexpr uint32_t COM2_VALUE = (1U << 30);  ///< Comparator 2 output status bit
        constexpr uint32_t COM2_LOCK = (1U << 31);  ///< COMP2_CSR register lock bit
    }

}

// ============================================================================
// CORDIC Peripheral
// ============================================================================

namespace cordic {
    /// Base addresses
    constexpr uint32_t CORDIC_BASE = 0x40021000;

    /// CORDIC Register structure
    struct Registers {
        volatile uint32_t CSR;  ///< Offset: 0x00 - CORDIC Control Status register
        volatile uint32_t WDATA;  ///< Offset: 0x04 - FMAC Write Data register
        volatile uint32_t RDATA;  ///< Offset: 0x08 - FMAC Read Data register
    };

    /// Peripheral instances
    inline Registers* CORDIC = reinterpret_cast<Registers*>(CORDIC_BASE);

    // Bit definitions
    /// CSR Register bits
    namespace csr_bits {
        constexpr uint32_t FUNC = (4 << 0);  ///< Function
        constexpr uint32_t PRECISION = (4 << 4);  ///< Precision required (number of iterations)
        constexpr uint32_t SCALE = (3 << 8);  ///< Scaling factor
        constexpr uint32_t IEN = (1U << 16);  ///< Enable interrupt
        constexpr uint32_t DMAREN = (1U << 17);  ///< Enable DMA read channel
        constexpr uint32_t DMAWEN = (1U << 18);  ///< Enable DMA write channel
        constexpr uint32_t NRES = (1U << 19);  ///< Number of results in the CORDIC_RDATA register
        constexpr uint32_t NARGS = (1U << 20);  ///< Number of arguments expected by the CORDIC_WDATA register
        constexpr uint32_t RESSIZE = (1U << 21);  ///< Width of output data
        constexpr uint32_t ARGSIZE = (1U << 22);  ///< Width of input data
        constexpr uint32_t RRDY = (1U << 31);  ///< Result ready flag
    }

    /// WDATA Register bits
    namespace wdata_bits {
        constexpr uint32_t ARG = (32 << 0);  ///< Function input arguments
    }

    /// RDATA Register bits
    namespace rdata_bits {
        constexpr uint32_t RES = (32 << 0);  ///< Function result
    }

}

// ============================================================================
// CRC Peripheral
// ============================================================================

namespace crc {
    /// Base addresses
    constexpr uint32_t CRC_BASE = 0x40023000;

    /// CRC Register structure
    struct Registers {
        volatile uint32_t DR;  ///< Offset: 0x00 - Data register
        volatile uint32_t IDR;  ///< Offset: 0x04 - Independent data register
        volatile uint32_t CR;  ///< Offset: 0x08 - Control register
        volatile uint32_t INIT;  ///< Offset: 0x10 - Initial CRC value
        volatile uint32_t POL;  ///< Offset: 0x14 - polynomial
    };

    /// Peripheral instances
    inline Registers* CRC = reinterpret_cast<Registers*>(CRC_BASE);

    // Bit definitions
    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t DR = (32 << 0);  ///< Data register bits
    }

    /// IDR Register bits
    namespace idr_bits {
        constexpr uint32_t IDR = (32 << 0);  ///< General-purpose 8-bit data register bits
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t REV_OUT = (1U << 7);  ///< Reverse output data
        constexpr uint32_t REV_IN = (2 << 5);  ///< Reverse input data
        constexpr uint32_t POLYSIZE = (2 << 3);  ///< Polynomial size
        constexpr uint32_t RESET = (1U << 0);  ///< RESET bit
    }

    /// INIT Register bits
    namespace init_bits {
        constexpr uint32_t CRC_INIT = (32 << 0);  ///< Programmable initial CRC value
    }

    /// POL Register bits
    namespace pol_bits {
        constexpr uint32_t POL = (32 << 0);  ///< Programmable polynomial
    }

}

// ============================================================================
// CRS Peripheral
// ============================================================================

namespace crs {
    /// Base addresses
    constexpr uint32_t CRS_BASE = 0x40006000;

    /// CRS Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t CFGR;  ///< Offset: 0x04 - configuration register
        volatile uint32_t ISR;  ///< Offset: 0x08 - interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x0C - interrupt flag clear register
    };

    /// Peripheral instances
    inline Registers* CRS = reinterpret_cast<Registers*>(CRS_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TRIM = (7 << 8);  ///< HSI48 oscillator smooth trimming
        constexpr uint32_t SWSYNC = (1U << 7);  ///< Generate software SYNC event
        constexpr uint32_t AUTOTRIMEN = (1U << 6);  ///< Automatic trimming enable
        constexpr uint32_t CEN = (1U << 5);  ///< Frequency error counter enable
        constexpr uint32_t ESYNCIE = (1U << 3);  ///< Expected SYNC interrupt enable
        constexpr uint32_t ERRIE = (1U << 2);  ///< Synchronization or trimming error interrupt enable
        constexpr uint32_t SYNCWARNIE = (1U << 1);  ///< SYNC warning interrupt enable
        constexpr uint32_t SYNCOKIE = (1U << 0);  ///< SYNC event OK interrupt enable
    }

    /// CFGR Register bits
    namespace cfgr_bits {
        constexpr uint32_t SYNCPOL = (1U << 31);  ///< SYNC polarity selection
        constexpr uint32_t SYNCSRC = (2 << 28);  ///< SYNC signal source selection
        constexpr uint32_t SYNCDIV = (3 << 24);  ///< SYNC divider
        constexpr uint32_t FELIM = (8 << 16);  ///< Frequency error limit
        constexpr uint32_t RELOAD = (16 << 0);  ///< Counter reload value
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t FECAP = (16 << 16);  ///< Frequency error capture
        constexpr uint32_t FEDIR = (1U << 15);  ///< Frequency error direction
        constexpr uint32_t TRIMOVF = (1U << 10);  ///< Trimming overflow or underflow
        constexpr uint32_t SYNCMISS = (1U << 9);  ///< SYNC missed
        constexpr uint32_t SYNCERR = (1U << 8);  ///< SYNC error
        constexpr uint32_t ESYNCF = (1U << 3);  ///< Expected SYNC flag
        constexpr uint32_t ERRF = (1U << 2);  ///< Error flag
        constexpr uint32_t SYNCWARNF = (1U << 1);  ///< SYNC warning flag
        constexpr uint32_t SYNCOKF = (1U << 0);  ///< SYNC event OK flag
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ESYNCC = (1U << 3);  ///< Expected SYNC clear flag
        constexpr uint32_t ERRC = (1U << 2);  ///< Error clear flag
        constexpr uint32_t SYNCWARNC = (1U << 1);  ///< SYNC warning clear flag
        constexpr uint32_t SYNCOKC = (1U << 0);  ///< SYNC event OK clear flag
    }

}

// ============================================================================
// DAC Peripheral
// ============================================================================

namespace dac {
    /// Base addresses
    constexpr uint32_t DAC1_BASE = 0x46021800;
    constexpr uint32_t SEC_DAC1_BASE = 0x56021800;

    /// DAC Register structure
    struct Registers {
        volatile uint32_t DAC_CR;  ///< Offset: 0x00 - DAC control register
        volatile uint32_t DAC_SWTRGR;  ///< Offset: 0x04 - DAC software trigger register
        volatile uint32_t DAC_DHR12R1;  ///< Offset: 0x08 - DAC channel1 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12L1;  ///< Offset: 0x0C - DAC channel1 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R1;  ///< Offset: 0x10 - DAC channel1 8-bit right aligned data holding register
        volatile uint32_t DAC_DHR12R2;  ///< Offset: 0x14 - DAC channel2 12-bit right aligned data holding register
        volatile uint32_t DAC_DHR12L2;  ///< Offset: 0x18 - DAC channel2 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8R2;  ///< Offset: 0x1C - DAC channel2 8-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12RD;  ///< Offset: 0x20 - Dual DAC 12-bit right-aligned data holding register
        volatile uint32_t DAC_DHR12LD;  ///< Offset: 0x24 - DUAL DAC 12-bit left aligned data holding register
        volatile uint32_t DAC_DHR8RD;  ///< Offset: 0x28 - DUAL DAC 8-bit right aligned data holding register
        volatile uint32_t DAC_DOR1;  ///< Offset: 0x2C - DAC channel1 data output register
        volatile uint32_t DAC_DOR2;  ///< Offset: 0x30 - DAC channel2 data output register
        volatile uint32_t DAC_SR;  ///< Offset: 0x34 - DAC status register
        volatile uint32_t DAC_CCR;  ///< Offset: 0x38 - DAC calibration control register
        volatile uint32_t DAC_MCR;  ///< Offset: 0x3C - DAC mode control register
        volatile uint32_t DAC_SHSR1;  ///< Offset: 0x40 - DAC Sample and Hold sample time register 1
        volatile uint32_t DAC_SHSR2;  ///< Offset: 0x44 - DAC channel2 sample and hold sample time register
        volatile uint32_t DAC_SHHR;  ///< Offset: 0x48 - DAC Sample and Hold hold time register
        volatile uint32_t DAC_SHRR;  ///< Offset: 0x4C - DAC Sample and Hold refresh time register
        volatile uint32_t DAC_AUTOCR;  ///< Offset: 0x54 - Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* DAC1 = reinterpret_cast<Registers*>(DAC1_BASE);
    inline Registers* SEC_DAC1 = reinterpret_cast<Registers*>(SEC_DAC1_BASE);

    // Bit definitions
    /// DAC_CR Register bits
    namespace dac_cr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< DAC channel1 enable
        constexpr uint32_t TEN1 = (1U << 1);  ///< DAC channel1 trigger enable
        constexpr uint32_t TSEL1 = (4 << 2);  ///< DAC channel1 trigger selection
        constexpr uint32_t WAVE1 = (2 << 6);  ///< DAC channel1 noise/triangle wave generation enable
        constexpr uint32_t MAMP1 = (4 << 8);  ///< DAC channel1 mask/amplitude selector
        constexpr uint32_t DMAEN1 = (1U << 12);  ///< DAC channel1 DMA enable
        constexpr uint32_t DMAUDRIE1 = (1U << 13);  ///< DAC channel1 DMA Underrun Interrupt enable
        constexpr uint32_t CEN1 = (1U << 14);  ///< DAC channel1 calibration enable
        constexpr uint32_t EN2 = (1U << 16);  ///< DAC channel2 enable
        constexpr uint32_t TEN2 = (1U << 17);  ///< DAC channel2 trigger enable
        constexpr uint32_t TSEL2 = (4 << 18);  ///< DAC channel2 trigger selection
        constexpr uint32_t WAVE2 = (2 << 22);  ///< DAC channel2 noise/triangle wave generation enable
        constexpr uint32_t MAMP2 = (4 << 24);  ///< DAC channel2 mask/amplitude selector
        constexpr uint32_t DMAEN2 = (1U << 28);  ///< DAC channel2 DMA enable
        constexpr uint32_t DMAUDRIE2 = (1U << 29);  ///< DAC channel2 DMA underrun interrupt enable
        constexpr uint32_t CEN2 = (1U << 30);  ///< DAC channel2 calibration enable
    }

    /// DAC_SWTRGR Register bits
    namespace dac_swtrgr_bits {
        constexpr uint32_t SWTRIG1 = (1U << 0);  ///< DAC channel1 software trigger
        constexpr uint32_t SWTRIG2 = (1U << 1);  ///< DAC channel2 software trigger
    }

    /// DAC_DHR12R1 Register bits
    namespace dac_dhr12r1_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
        constexpr uint32_t DACC1DHRB = (12 << 16);  ///< DAC channel1 12-bit right-aligned data B
    }

    /// DAC_DHR12L1 Register bits
    namespace dac_dhr12l1_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
        constexpr uint32_t DACC1DHRB = (12 << 20);  ///< DAC channel1 12-bit left-aligned data B
    }

    /// DAC_DHR8R1 Register bits
    namespace dac_dhr8r1_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
        constexpr uint32_t DACC1DHRB = (8 << 8);  ///< DAC channel1 8-bit right-aligned Sdata
    }

    /// DAC_DHR12R2 Register bits
    namespace dac_dhr12r2_bits {
        constexpr uint32_t DACC2DHR = (12 << 0);  ///< DAC channel2 12-bit right-aligned data
        constexpr uint32_t DACC2DHRB = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DAC_DHR12L2 Register bits
    namespace dac_dhr12l2_bits {
        constexpr uint32_t DACC2DHR = (12 << 4);  ///< DAC channel2 12-bit left-aligned data
        constexpr uint32_t DACC2DHRB = (12 << 20);  ///< DAC channel2 12-bit left-aligned data B
    }

    /// DAC_DHR8R2 Register bits
    namespace dac_dhr8r2_bits {
        constexpr uint32_t DACC2DHR = (8 << 0);  ///< DAC channel2 8-bit right-aligned data
        constexpr uint32_t DACC2DHRB = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DAC_DHR12RD Register bits
    namespace dac_dhr12rd_bits {
        constexpr uint32_t DACC1DHR = (12 << 0);  ///< DAC channel1 12-bit right-aligned data
        constexpr uint32_t DACC2DHR = (12 << 16);  ///< DAC channel2 12-bit right-aligned data
    }

    /// DAC_DHR12LD Register bits
    namespace dac_dhr12ld_bits {
        constexpr uint32_t DACC1DHR = (12 << 4);  ///< DAC channel1 12-bit left-aligned data
        constexpr uint32_t DACC2DHR = (12 << 20);  ///< DAC channel2 12-bit left-aligned data
    }

    /// DAC_DHR8RD Register bits
    namespace dac_dhr8rd_bits {
        constexpr uint32_t DACC1DHR = (8 << 0);  ///< DAC channel1 8-bit right-aligned data
        constexpr uint32_t DACC2DHR = (8 << 8);  ///< DAC channel2 8-bit right-aligned data
    }

    /// DAC_DOR1 Register bits
    namespace dac_dor1_bits {
        constexpr uint32_t DACC1DOR = (12 << 0);  ///< DAC channel1 data output
        constexpr uint32_t DACC1DORB = (12 << 16);  ///< DAC channel1 data output
    }

    /// DAC_DOR2 Register bits
    namespace dac_dor2_bits {
        constexpr uint32_t DACC2DOR = (12 << 0);  ///< DAC channel2 data output
        constexpr uint32_t DACC2DORB = (12 << 16);  ///< DAC channel2 data output
    }

    /// DAC_SR Register bits
    namespace dac_sr_bits {
        constexpr uint32_t DAC1RDY = (1U << 11);  ///< DAC channel1 ready status bit
        constexpr uint32_t DORSTAT1 = (1U << 12);  ///< DAC channel1 output register status bit
        constexpr uint32_t DMAUDR1 = (1U << 13);  ///< DAC channel1 DMA underrun flag
        constexpr uint32_t CAL_FLAG1 = (1U << 14);  ///< DAC Channel 1 calibration offset status
        constexpr uint32_t BWST1 = (1U << 15);  ///< DAC Channel 1 busy writing sample time flag
        constexpr uint32_t DAC2RDY = (1U << 27);  ///< DAC channel 2 ready status bit
        constexpr uint32_t DORSTAT2 = (1U << 28);  ///< DAC channel 2 output register status bit
        constexpr uint32_t DMAUDR2 = (1U << 29);  ///< DAC channel2 DMA underrun flag
        constexpr uint32_t CAL_FLAG2 = (1U << 30);  ///< DAC Channel 2 calibration offset status
        constexpr uint32_t BWST2 = (1U << 31);  ///< DAC Channel 2 busy writing sample time flag
    }

    /// DAC_CCR Register bits
    namespace dac_ccr_bits {
        constexpr uint32_t OTRIM1 = (5 << 0);  ///< DAC Channel 1 offset trimming value
        constexpr uint32_t OTRIM2 = (5 << 16);  ///< DAC Channel 2 offset trimming value
    }

    /// DAC_MCR Register bits
    namespace dac_mcr_bits {
        constexpr uint32_t MODE1 = (3 << 0);  ///< DAC Channel 1 mode
        constexpr uint32_t DMADOUBLE1 = (1U << 8);  ///< DAC Channel1 DMA double data mode
        constexpr uint32_t SINFORMAT1 = (1U << 9);  ///< Enable signed format for DAC channel1
        constexpr uint32_t HFSEL = (2 << 14);  ///< High frequency interface mode selection
        constexpr uint32_t MODE2 = (3 << 16);  ///< DAC Channel 2 mode
        constexpr uint32_t DMADOUBLE2 = (1U << 24);  ///< DAC Channel2 DMA double data mode
        constexpr uint32_t SINFORMAT2 = (1U << 25);  ///< Enable signed format for DAC channel2
    }

    /// DAC_SHSR1 Register bits
    namespace dac_shsr1_bits {
        constexpr uint32_t TSAMPLE1 = (10 << 0);  ///< DAC Channel 1 sample Time (only valid in sample &amp; hold mode)
    }

    /// DAC_SHSR2 Register bits
    namespace dac_shsr2_bits {
        constexpr uint32_t TSAMPLE2 = (10 << 0);  ///< DAC Channel 2 sample Time (only valid in sample and hold mode)
    }

    /// DAC_SHHR Register bits
    namespace dac_shhr_bits {
        constexpr uint32_t THOLD1 = (10 << 0);  ///< DAC Channel 1 hold Time (only valid in sample and hold mode)
        constexpr uint32_t THOLD2 = (10 << 16);  ///< DAC Channel 2 hold time (only valid in sample and hold mode)
    }

    /// DAC_SHRR Register bits
    namespace dac_shrr_bits {
        constexpr uint32_t TREFRESH1 = (8 << 0);  ///< DAC Channel 1 refresh Time (only valid in sample and hold mode)
        constexpr uint32_t TREFRESH2 = (8 << 16);  ///< DAC Channel 2 refresh Time (only valid in sample and hold mode)
    }

    /// DAC_AUTOCR Register bits
    namespace dac_autocr_bits {
        constexpr uint32_t AUTOMODE = (1U << 22);  ///< DAC Autonomous mode
    }

}

// ============================================================================
// DBGMCU Peripheral
// ============================================================================

namespace dbgmcu {
    /// Base addresses
    constexpr uint32_t DBGMCU_BASE = 0xE0044000;

    /// DBGMCU Register structure
    struct Registers {
        volatile uint32_t IDCODE;  ///< Offset: 0x00 - DBGMCU_IDCODE
        volatile uint32_t CR;  ///< Offset: 0x04 - Debug MCU configuration register
        volatile uint32_t APB1LFZR;  ///< Offset: 0x08 - Debug MCU APB1L peripheral freeze register
        volatile uint32_t APB1HFZR;  ///< Offset: 0x0C - Debug MCU APB1H peripheral freeze register
        volatile uint32_t APB2FZR;  ///< Offset: 0x10 - Debug MCU APB2 peripheral freeze register
        volatile uint32_t APB3FZR;  ///< Offset: 0x14 - Debug MCU APB3 peripheral freeze register
        volatile uint32_t AHB1FZR;  ///< Offset: 0x20 - Debug MCU AHB1 peripheral freeze register
        volatile uint32_t AHB3FZR;  ///< Offset: 0x28 - Debug MCU AHB3 peripheral freeze register
        volatile uint32_t SR;  ///< Offset: 0xFC - DBGMCU status register
        volatile uint32_t DBGMCU_DBG_AUTH_HOST;  ///< Offset: 0x100 - DBGMCU debug host authentication register
        volatile uint32_t DBG_AUTH_DEVICE;  ///< Offset: 0x104 - DBGMCU debug device authentication register
        volatile uint32_t PIDR4;  ///< Offset: 0xFD0 - Debug MCU CoreSight peripheral identity register 4
        volatile uint32_t PIDR0;  ///< Offset: 0xFE0 - Debug MCU CoreSight peripheral identity register 0
        volatile uint32_t PIDR1;  ///< Offset: 0xFE4 - Debug MCU CoreSight peripheral identity register 1
        volatile uint32_t PIDR2;  ///< Offset: 0xFE8 - Debug MCU CoreSight peripheral identity register 2
        volatile uint32_t PIDR3;  ///< Offset: 0xFEC - Debug MCU CoreSight peripheral identity register 3
        volatile uint32_t CIDR0;  ///< Offset: 0xFF0 - Debug MCU CoreSight component identity register 0
        volatile uint32_t CIDR1;  ///< Offset: 0xFF4 - Debug MCU CoreSight component identity register 1
        volatile uint32_t CIDR2;  ///< Offset: 0xFF8 - Debug MCU CoreSight component identity register 2
        volatile uint32_t CIDR3;  ///< Offset: 0xFFC - Debug MCU CoreSight component identity register 3
    };

    /// Peripheral instances
    inline Registers* DBGMCU = reinterpret_cast<Registers*>(DBGMCU_BASE);

    // Bit definitions
    /// IDCODE Register bits
    namespace idcode_bits {
        constexpr uint32_t DEV_ID = (12 << 0);  ///< Device dentification
        constexpr uint32_t REV_ID = (16 << 16);  ///< Revision
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t DBG_STOP = (1U << 1);  ///< Debug Stop mode
        constexpr uint32_t DBG_STANDBY = (1U << 2);  ///< Debug Standby mode
        constexpr uint32_t TRACE_IOEN = (1U << 4);  ///< Trace pin assignment control
        constexpr uint32_t TRACE_EN = (1U << 5);  ///< trace port and clock enable
        constexpr uint32_t TRACE_MODE = (2 << 6);  ///< Trace pin assignment control
    }

    /// APB1LFZR Register bits
    namespace apb1lfzr_bits {
        constexpr uint32_t DBG_TIM2_STOP = (1U << 0);  ///< TIM2 stop in debug
        constexpr uint32_t DBG_TIM3_STOP = (1U << 1);  ///< TIM3 stop in debug
        constexpr uint32_t DBG_TIM4_STOP = (1U << 2);  ///< TIM4 stop in debug
        constexpr uint32_t DBG_TIM5_STOP = (1U << 3);  ///< TIM5 stop in debug
        constexpr uint32_t DBG_TIM6_STOP = (1U << 4);  ///< TIM6 stop in debug
        constexpr uint32_t DBG_TIM7_STOP = (1U << 5);  ///< TIM7 stop in debug
        constexpr uint32_t DBG_WWDG_STOP = (1U << 11);  ///< Window watchdog counter stop in debug
        constexpr uint32_t DBG_IWDG_STOP = (1U << 12);  ///< Independent watchdog counter stop in debug
        constexpr uint32_t DBG_I2C1_STOP = (1U << 21);  ///< I2C1 SMBUS timeout stop in debug
        constexpr uint32_t DBG_I2C2_STOP = (1U << 22);  ///< I2C2 SMBUS timeout stop in debug
    }

    /// APB1HFZR Register bits
    namespace apb1hfzr_bits {
        constexpr uint32_t DBG_I2C4_STOP = (1U << 1);  ///< I2C4 stop in debug
        constexpr uint32_t DBG_LPTIM2_STOP = (1U << 5);  ///< LPTIM2 stop in debug
    }

    /// APB2FZR Register bits
    namespace apb2fzr_bits {
        constexpr uint32_t DBG_TIM1_STOP = (1U << 11);  ///< TIM1 counter stopped when core is halted
        constexpr uint32_t DBG_TIM8_STOP = (1U << 13);  ///< TIM8 stop in debug
        constexpr uint32_t DBG_TIM15_STOP = (1U << 16);  ///< TIM15 counter stopped when core is halted
        constexpr uint32_t DBG_TIM16_STOP = (1U << 17);  ///< TIM16 counter stopped when core is halted
        constexpr uint32_t DBG_TIM17_STOP = (1U << 18);  ///< DBG_TIM17_STOP
    }

    /// APB3FZR Register bits
    namespace apb3fzr_bits {
        constexpr uint32_t DBG_I2C3_STOP = (1U << 10);  ///< I2C3 stop in debug
        constexpr uint32_t DBG_LPTIM1_STOP = (1U << 17);  ///< LPTIM1 stop in debug
        constexpr uint32_t DBG_LPTIM3_STOP = (1U << 18);  ///< LPTIM3 stop in debug
        constexpr uint32_t DBG_LPTIM4_STOP = (1U << 19);  ///< LPTIM4 stop in debug
        constexpr uint32_t DBG_RTC_STOP = (1U << 30);  ///< RTC stop in debug
    }

    /// AHB1FZR Register bits
    namespace ahb1fzr_bits {
        constexpr uint32_t DBG_GPDMA0_STOP = (1U << 0);  ///< GPDMA channel 0 stop in debug
        constexpr uint32_t DBG_GPDMA1_STOP = (1U << 1);  ///< GPDMA channel 1 stop in debug
        constexpr uint32_t DBG_GPDMA2_STOP = (1U << 2);  ///< GPDMA channel 2 stop in debug
        constexpr uint32_t DBG_GPDMA3_STOP = (1U << 3);  ///< GPDMA channel 3 stop in debug
        constexpr uint32_t DBG_GPDMA4_STOP = (1U << 4);  ///< GPDMA channel 4 stop in debug
        constexpr uint32_t DBG_GPDMA5_STOP = (1U << 5);  ///< GPDMA channel 5 stop in debug
        constexpr uint32_t DBG_GPDMA6_STOP = (1U << 6);  ///< GPDMA channel 6 stop in debug
        constexpr uint32_t DBG_GPDMA7_STOP = (1U << 7);  ///< GPDMA channel 7 stop in debug
        constexpr uint32_t DBG_GPDMA8_STOP = (1U << 8);  ///< GPDMA channel 8 stop in debug
        constexpr uint32_t DBG_GPDMA9_STOP = (1U << 9);  ///< GPDMA channel 9 stop in debug
        constexpr uint32_t DBG_GPDMA10_STOP = (1U << 10);  ///< GPDMA channel 10 stop in debug
        constexpr uint32_t DBG_GPDMA11_STOP = (1U << 11);  ///< GPDMA channel 11 stop in debug
        constexpr uint32_t DBG_GPDMA12_STOP = (1U << 12);  ///< GPDMA channel 12 stop in debug
        constexpr uint32_t DBG_GPDMA13_STOP = (1U << 13);  ///< GPDMA channel 13 stop in debug
        constexpr uint32_t DBG_GPDMA14_STOP = (1U << 14);  ///< GPDMA channel 14 stop in debug
        constexpr uint32_t DBG_GPDMA15_STOP = (1U << 15);  ///< GPDMA channel 15 stop in debug
    }

    /// AHB3FZR Register bits
    namespace ahb3fzr_bits {
        constexpr uint32_t DBG_LPDMA0_STOP = (1U << 0);  ///< LPDMA channel 0 stop in debug
        constexpr uint32_t DBG_LPDMA1_STOP = (1U << 1);  ///< LPDMA channel 1 stop in debug
        constexpr uint32_t DBG_LPDMA2_STOP = (1U << 2);  ///< LPDMA channel 2 stop in debug
        constexpr uint32_t DBG_LPDMA3_STOP = (1U << 3);  ///< LPDMA channel 3 stop in debug
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t AP_PRESENT = (8 << 0);  ///< AP_PRESENT
        constexpr uint32_t AP_LOCKED = (8 << 8);  ///< AP_LOCKED
    }

    /// DBGMCU_DBG_AUTH_HOST Register bits
    namespace dbgmcu_dbg_auth_host_bits {
        constexpr uint32_t AUTH_KEY = (32 << 0);  ///< AUTH_KEY
    }

    /// DBG_AUTH_DEVICE Register bits
    namespace dbg_auth_device_bits {
        constexpr uint32_t AUTH_ID = (16 << 0);  ///< AUTH_ID
    }

    /// PIDR4 Register bits
    namespace pidr4_bits {
        constexpr uint32_t JEP106CON = (4 << 0);  ///< JEP106 continuation code
        constexpr uint32_t KCOUNT_4 = (4 << 4);  ///< register file size
    }

    /// PIDR0 Register bits
    namespace pidr0_bits {
        constexpr uint32_t PARTNUM = (8 << 0);  ///< part number bits [7:0]
    }

    /// PIDR1 Register bits
    namespace pidr1_bits {
        constexpr uint32_t PARTNUM = (4 << 0);  ///< part number bits [11:8]
        constexpr uint32_t JEP106ID = (4 << 4);  ///< JEP106 identity code bits [3:0]
    }

    /// PIDR2 Register bits
    namespace pidr2_bits {
        constexpr uint32_t JEP106ID = (3 << 0);  ///< JEP106 identity code bits [6:4]
        constexpr uint32_t JEDEC = (1U << 3);  ///< JEDEC assigned value
        constexpr uint32_t REVISION = (4 << 4);  ///< component revision number
    }

    /// PIDR3 Register bits
    namespace pidr3_bits {
        constexpr uint32_t CMOD = (4 << 0);  ///< customer modified
        constexpr uint32_t REVAND = (4 << 4);  ///< metal fix version
    }

    /// CIDR0 Register bits
    namespace cidr0_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [7:0]
    }

    /// CIDR1 Register bits
    namespace cidr1_bits {
        constexpr uint32_t PREAMBLE = (4 << 0);  ///< component identification bits [11:8]
        constexpr uint32_t CLASS_ = (4 << 4);  ///< component identification bits [15:12] - component class (renamed from CLASS_)
    }

    /// CIDR2 Register bits
    namespace cidr2_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [23:16]
    }

    /// CIDR3 Register bits
    namespace cidr3_bits {
        constexpr uint32_t PREAMBLE = (8 << 0);  ///< component identification bits [31:24]
    }

}

// ============================================================================
// DCACHE1 Peripheral
// ============================================================================

namespace dcache1 {
    /// Base addresses
    constexpr uint32_t DCACHE1_BASE = 0x40031400;

    /// DCACHE1 Register structure
    struct Registers {
        volatile uint32_t DCACHE_CR;  ///< Offset: 0x00 - DCACHE control register
        volatile uint32_t DCACHE_SR;  ///< Offset: 0x04 - DCACHE status register
        volatile uint32_t DCACHE_IER;  ///< Offset: 0x08 - DCACHE interrupt enable register
        volatile uint32_t DCACHE_FCR;  ///< Offset: 0x0C - DCACHE flag clear register
        volatile uint32_t DCACHE_RHMONR;  ///< Offset: 0x10 - DCACHE read-hit monitor register
        volatile uint32_t DCACHE_RMMONR;  ///< Offset: 0x14 - DCACHE read-miss monitor register
        volatile uint32_t DCACHE_WHMONR;  ///< Offset: 0x20 - write-hit monitor register
        volatile uint32_t DCACHE_WMMONR;  ///< Offset: 0x24 - write-miss monitor register
        volatile uint32_t DCACHE_CMDRSADDRR;  ///< Offset: 0x28 - command range start address register
        volatile uint32_t DCACHE_CMDREADDRR;  ///< Offset: 0x2C - command range start address register
    };

    /// Peripheral instances
    inline Registers* DCACHE1 = reinterpret_cast<Registers*>(DCACHE1_BASE);

    // Bit definitions
    /// DCACHE_CR Register bits
    namespace dcache_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t CACHEINV = (1U << 1);  ///< CACHEINV
        constexpr uint32_t CACHECMD = (3 << 8);  ///< CACHECMD
        constexpr uint32_t STARTCMD = (1U << 11);  ///< STARTCMD
        constexpr uint32_t RHITMEN = (1U << 16);  ///< RHITMEN
        constexpr uint32_t RMISSMEN = (1U << 17);  ///< RMISSMEN
        constexpr uint32_t RHITMRST = (1U << 18);  ///< RHITMRST
        constexpr uint32_t RMISSMRST = (1U << 19);  ///< RMISSMRST
        constexpr uint32_t WHITMEN = (1U << 20);  ///< WHITMEN
        constexpr uint32_t WMISSMEN = (1U << 21);  ///< WMISSMEN
        constexpr uint32_t WHITMRST = (1U << 22);  ///< WHITMRST
        constexpr uint32_t WMISSMRST = (1U << 23);  ///< WMISSMRST
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// DCACHE_SR Register bits
    namespace dcache_sr_bits {
        constexpr uint32_t BUSYF = (1U << 0);  ///< BUSYF
        constexpr uint32_t BSYENDF = (1U << 1);  ///< BSYENDF
        constexpr uint32_t ERRF = (1U << 2);  ///< ERRF
        constexpr uint32_t BUSYCMDF = (1U << 3);  ///< BUSYCMDF
        constexpr uint32_t CMDENDF = (1U << 4);  ///< CMDENDF
    }

    /// DCACHE_IER Register bits
    namespace dcache_ier_bits {
        constexpr uint32_t BSYENDIE = (1U << 1);  ///< BSYENDIE
        constexpr uint32_t ERRIE = (1U << 2);  ///< ERRIE
        constexpr uint32_t CMDENDIE = (1U << 4);  ///< CMDENDIE
    }

    /// DCACHE_FCR Register bits
    namespace dcache_fcr_bits {
        constexpr uint32_t CBSYENDF = (1U << 1);  ///< CBSYENDF
        constexpr uint32_t CERRF = (1U << 2);  ///< CERRF
        constexpr uint32_t CCMDENDF = (1U << 4);  ///< CCMDENDF
    }

    /// DCACHE_RHMONR Register bits
    namespace dcache_rhmonr_bits {
        constexpr uint32_t RHITMON = (32 << 0);  ///< RHITMON
    }

    /// DCACHE_RMMONR Register bits
    namespace dcache_rmmonr_bits {
        constexpr uint32_t MRISSMON = (16 << 0);  ///< RMISSMON
    }

    /// DCACHE_WHMONR Register bits
    namespace dcache_whmonr_bits {
        constexpr uint32_t WHITMON = (32 << 0);  ///< WHITMON
    }

    /// DCACHE_WMMONR Register bits
    namespace dcache_wmmonr_bits {
        constexpr uint32_t WMISSMON = (16 << 0);  ///< WMISSMON
    }

    /// DCACHE_CMDRSADDRR Register bits
    namespace dcache_cmdrsaddrr_bits {
        constexpr uint32_t CMDSTARTADDR = (28 << 4);  ///< CMDSTARTADDR
    }

    /// DCACHE_CMDREADDRR Register bits
    namespace dcache_cmdreaddrr_bits {
        constexpr uint32_t CMDENDADDR = (28 << 4);  ///< CMDENDADDR
    }

}

// ============================================================================
// DCACHE2 Peripheral
// ============================================================================

namespace dcache2 {
    /// Base addresses
    constexpr uint32_t DCACHE2_BASE = 0x40031800;

    /// DCACHE2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DCACHE2 = reinterpret_cast<Registers*>(DCACHE2_BASE);

}

// ============================================================================
// DCMI Peripheral
// ============================================================================

namespace dcmi {
    /// Base addresses
    constexpr uint32_t DCMI_BASE = 0x4202C000;

    /// DCMI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t RIS;  ///< Offset: 0x08 - raw interrupt status register
        volatile uint32_t IER;  ///< Offset: 0x0C - interrupt enable register
        volatile uint32_t MIS;  ///< Offset: 0x10 - masked interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x14 - interrupt clear register
        volatile uint32_t ESCR;  ///< Offset: 0x18 - background offset register
        volatile uint32_t ESUR;  ///< Offset: 0x1C - embedded synchronization unmask register
        volatile uint32_t CWSTRT;  ///< Offset: 0x20 - crop window start
        volatile uint32_t CWSIZE;  ///< Offset: 0x24 - crop window size
        volatile uint32_t DR;  ///< Offset: 0x28 - data register
    };

    /// Peripheral instances
    inline Registers* DCMI = reinterpret_cast<Registers*>(DCMI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t OELS = (1U << 20);  ///< Odd/Even Line Select (Line Select Start)
        constexpr uint32_t LSM = (1U << 19);  ///< Line Select mode
        constexpr uint32_t OEBS = (1U << 18);  ///< Odd/Even Byte Select (Byte Select Start)
        constexpr uint32_t BSM = (2 << 16);  ///< Byte Select mode
        constexpr uint32_t ENABLE = (1U << 14);  ///< DCMI enable
        constexpr uint32_t EDM = (2 << 10);  ///< Extended data mode
        constexpr uint32_t FCRC = (2 << 8);  ///< Frame capture rate control
        constexpr uint32_t VSPOL = (1U << 7);  ///< Vertical synchronization polarity
        constexpr uint32_t HSPOL = (1U << 6);  ///< Horizontal synchronization polarity
        constexpr uint32_t PCKPOL = (1U << 5);  ///< Pixel clock polarity
        constexpr uint32_t ESS = (1U << 4);  ///< Embedded synchronization select
        constexpr uint32_t JPEG = (1U << 3);  ///< JPEG format
        constexpr uint32_t CROP = (1U << 2);  ///< Crop feature
        constexpr uint32_t CM = (1U << 1);  ///< Capture mode
        constexpr uint32_t CAPTURE = (1U << 0);  ///< Capture enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t FNE = (1U << 2);  ///< FIFO not empty
        constexpr uint32_t VSYNC = (1U << 1);  ///< Vertical synchronization
        constexpr uint32_t HSYNC = (1U << 0);  ///< Horizontal synchronization
    }

    /// RIS Register bits
    namespace ris_bits {
        constexpr uint32_t LINE_RIS = (1U << 4);  ///< Line raw interrupt status
        constexpr uint32_t VSYNC_RIS = (1U << 3);  ///< DCMI_VSYNC raw interrupt status
        constexpr uint32_t ERR_RIS = (1U << 2);  ///< Synchronization error raw interrupt status
        constexpr uint32_t OVR_RIS = (1U << 1);  ///< Overrun raw interrupt status
        constexpr uint32_t FRAME_RIS = (1U << 0);  ///< Capture complete raw interrupt status
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t LINE_IE = (1U << 4);  ///< Line interrupt enable
        constexpr uint32_t VSYNC_IE = (1U << 3);  ///< DCMI_VSYNC interrupt enable
        constexpr uint32_t ERR_IE = (1U << 2);  ///< Synchronization error interrupt enable
        constexpr uint32_t OVR_IE = (1U << 1);  ///< Overrun interrupt enable
        constexpr uint32_t FRAME_IE = (1U << 0);  ///< Capture complete interrupt enable
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t LINE_MIS = (1U << 4);  ///< Line masked interrupt status
        constexpr uint32_t VSYNC_MIS = (1U << 3);  ///< VSYNC masked interrupt status
        constexpr uint32_t ERR_MIS = (1U << 2);  ///< Synchronization error masked interrupt status
        constexpr uint32_t OVR_MIS = (1U << 1);  ///< Overrun masked interrupt status
        constexpr uint32_t FRAME_MIS = (1U << 0);  ///< Capture complete masked interrupt status
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t LINE_ISC = (1U << 4);  ///< line interrupt status clear
        constexpr uint32_t VSYNC_ISC = (1U << 3);  ///< Vertical Synchronization interrupt status clear
        constexpr uint32_t ERR_ISC = (1U << 2);  ///< Synchronization error interrupt status clear
        constexpr uint32_t OVR_ISC = (1U << 1);  ///< Overrun interrupt status clear
        constexpr uint32_t FRAME_ISC = (1U << 0);  ///< Capture complete interrupt status clear
    }

    /// ESCR Register bits
    namespace escr_bits {
        constexpr uint32_t FEC = (8 << 24);  ///< Frame end delimiter code
        constexpr uint32_t LEC = (8 << 16);  ///< Line end delimiter code
        constexpr uint32_t LSC = (8 << 8);  ///< Line start delimiter code
        constexpr uint32_t FSC = (8 << 0);  ///< Frame start delimiter code
    }

    /// ESUR Register bits
    namespace esur_bits {
        constexpr uint32_t FEU = (8 << 24);  ///< Frame end delimiter unmask
        constexpr uint32_t LEU = (8 << 16);  ///< Line end delimiter unmask
        constexpr uint32_t LSU = (8 << 8);  ///< Line start delimiter unmask
        constexpr uint32_t FSU = (8 << 0);  ///< Frame start delimiter unmask
    }

    /// CWSTRT Register bits
    namespace cwstrt_bits {
        constexpr uint32_t VST = (13 << 16);  ///< Vertical start line count
        constexpr uint32_t HOFFCNT = (14 << 0);  ///< Horizontal offset count
    }

    /// CWSIZE Register bits
    namespace cwsize_bits {
        constexpr uint32_t VLINE = (14 << 16);  ///< Vertical line count
        constexpr uint32_t CAPCNT = (14 << 0);  ///< Capture count
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t BYTE3 = (8 << 24);  ///< Data byte 3
        constexpr uint32_t BYTE2 = (8 << 16);  ///< Data byte 2
        constexpr uint32_t BYTE1 = (8 << 8);  ///< Data byte 1
        constexpr uint32_t BYTE0 = (8 << 0);  ///< Data byte 0
    }

}

// ============================================================================
// DLYBOS1 Peripheral
// ============================================================================

namespace dlybos1 {
    /// Base addresses
    constexpr uint32_t DLYBOS1_BASE = 0x420CF000;

    /// DLYBOS1 Register structure
    struct Registers {
        volatile uint32_t DLYB_CR;  ///< Offset: 0x00 - control register
        volatile uint32_t DLYB_CFGR;  ///< Offset: 0x04 - configuration register
    };

    /// Peripheral instances
    inline Registers* DLYBOS1 = reinterpret_cast<Registers*>(DLYBOS1_BASE);

    // Bit definitions
    /// DLYB_CR Register bits
    namespace dlyb_cr_bits {
        constexpr uint32_t DEN = (1U << 0);  ///< Operational amplifier Enable
        constexpr uint32_t SEN = (1U << 1);  ///< OPALPM
    }

    /// DLYB_CFGR Register bits
    namespace dlyb_cfgr_bits {
        constexpr uint32_t SEL = (4 << 0);  ///< SEL
        constexpr uint32_t UNIT = (7 << 8);  ///< UNIT
        constexpr uint32_t LNG = (12 << 16);  ///< LNG
        constexpr uint32_t LNGF = (1U << 31);  ///< LNGF
    }

}

// ============================================================================
// DLYBOS2 Peripheral
// ============================================================================

namespace dlybos2 {
    /// Base addresses
    constexpr uint32_t DLYBOS2_BASE = 0x420CF400;

    /// DLYBOS2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DLYBOS2 = reinterpret_cast<Registers*>(DLYBOS2_BASE);

}

// ============================================================================
// DLYBSD1 Peripheral
// ============================================================================

namespace dlybsd1 {
    /// Base addresses
    constexpr uint32_t DLYBSD1_BASE = 0x420C8400;

    /// DLYBSD1 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DLYBSD1 = reinterpret_cast<Registers*>(DLYBSD1_BASE);

}

// ============================================================================
// DLYBSD2 Peripheral
// ============================================================================

namespace dlybsd2 {
    /// Base addresses
    constexpr uint32_t DLYBSD2_BASE = 0x420C8800;

    /// DLYBSD2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* DLYBSD2 = reinterpret_cast<Registers*>(DLYBSD2_BASE);

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t DMA2D_BASE = 0x4002B000;
    constexpr uint32_t SEC_DMA2D_BASE = 0x5002B000;
    constexpr uint32_t GPDMA1_BASE = 0x40020000;
    constexpr uint32_t SEC_GPDMA1_BASE = 0x50020000;
    constexpr uint32_t LPDMA1_BASE = 0x46025000;
    constexpr uint32_t SEC_LPDMA1_BASE = 0x56025000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t ISR;  ///< Offset: 0x04 - Interrupt Status Register
        volatile uint32_t IFCR;  ///< Offset: 0x08 - interrupt flag clear register
        volatile uint32_t FGMAR;  ///< Offset: 0x0C - foreground memory address register
        volatile uint32_t FGOR;  ///< Offset: 0x10 - foreground offset register
        volatile uint32_t BGMAR;  ///< Offset: 0x14 - background memory address register
        volatile uint32_t BGOR;  ///< Offset: 0x18 - background offset register
        volatile uint32_t FGPFCCR;  ///< Offset: 0x1C - foreground PFC control register
        volatile uint32_t FGCOLR;  ///< Offset: 0x20 - foreground color register
        volatile uint32_t BGPFCCR;  ///< Offset: 0x24 - background PFC control register
        volatile uint32_t BGCOLR;  ///< Offset: 0x28 - background color register
        volatile uint32_t FGCMAR;  ///< Offset: 0x2C - foreground CLUT memory address register
        volatile uint32_t BGCMAR;  ///< Offset: 0x30 - background CLUT memory address register
        volatile uint32_t OPFCCR;  ///< Offset: 0x34 - output PFC control register
        volatile uint32_t OCOLR_RGB888;  ///< Offset: 0x38 - output color register
        volatile uint32_t OCOLR_RGB565;  ///< Offset: 0x38 - output color register
        volatile uint32_t OCOLR_ARGB1555;  ///< Offset: 0x38 - output color register
        volatile uint32_t OCOLR_ARGB4444;  ///< Offset: 0x38 - output color register
        volatile uint32_t OMAR;  ///< Offset: 0x3C - output memory address register
        volatile uint32_t OOR;  ///< Offset: 0x40 - output offset register
        volatile uint32_t NLR;  ///< Offset: 0x44 - number of line register
        volatile uint32_t LWR;  ///< Offset: 0x48 - line watermark register
        volatile uint32_t AMTCR;  ///< Offset: 0x4C - AHB master timer configuration register
        volatile uint32_t FGCLUT;  ///< Offset: 0x400 - FGCLUT
        volatile uint32_t BGCLUT;  ///< Offset: 0x800 - BGCLUT
    };

    /// Peripheral instances
    inline Registers* DMA2D = reinterpret_cast<Registers*>(DMA2D_BASE);
    inline Registers* SEC_DMA2D = reinterpret_cast<Registers*>(SEC_DMA2D_BASE);
    inline Registers* GPDMA1 = reinterpret_cast<Registers*>(GPDMA1_BASE);
    inline Registers* SEC_GPDMA1 = reinterpret_cast<Registers*>(SEC_GPDMA1_BASE);
    inline Registers* LPDMA1 = reinterpret_cast<Registers*>(LPDMA1_BASE);
    inline Registers* SEC_LPDMA1 = reinterpret_cast<Registers*>(SEC_LPDMA1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t MODE = (3 << 16);  ///< DMA2D mode
        constexpr uint32_t CEIE = (1U << 13);  ///< Configuration Error Interrupt Enable
        constexpr uint32_t CTCIE = (1U << 12);  ///< CLUT transfer complete interrupt enable
        constexpr uint32_t CAEIE = (1U << 11);  ///< CLUT access error interrupt enable
        constexpr uint32_t TWIE = (1U << 10);  ///< Transfer watermark interrupt enable
        constexpr uint32_t TCIE = (1U << 9);  ///< Transfer complete interrupt enable
        constexpr uint32_t TEIE = (1U << 8);  ///< Transfer error interrupt enable
        constexpr uint32_t LOM = (1U << 6);  ///< Line Offset Mode
        constexpr uint32_t ABORT = (1U << 2);  ///< Abort
        constexpr uint32_t SUSP = (1U << 1);  ///< Suspend
        constexpr uint32_t START = (1U << 0);  ///< Start
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t CEIF = (1U << 5);  ///< Configuration error interrupt flag
        constexpr uint32_t CTCIF = (1U << 4);  ///< CLUT transfer complete interrupt flag
        constexpr uint32_t CAEIF = (1U << 3);  ///< CLUT access error interrupt flag
        constexpr uint32_t TWIF = (1U << 2);  ///< Transfer watermark interrupt flag
        constexpr uint32_t TCIF = (1U << 1);  ///< Transfer complete interrupt flag
        constexpr uint32_t TEIF = (1U << 0);  ///< Transfer error interrupt flag
    }

    /// IFCR Register bits
    namespace ifcr_bits {
        constexpr uint32_t CCEIF = (1U << 5);  ///< Clear configuration error interrupt flag
        constexpr uint32_t CCTCIF = (1U << 4);  ///< Clear CLUT transfer complete interrupt flag
        constexpr uint32_t CAECIF = (1U << 3);  ///< Clear CLUT access error interrupt flag
        constexpr uint32_t CTWIF = (1U << 2);  ///< Clear transfer watermark interrupt flag
        constexpr uint32_t CTCIF = (1U << 1);  ///< Clear transfer complete interrupt flag
        constexpr uint32_t CTEIF = (1U << 0);  ///< Clear Transfer error interrupt flag
    }

    /// FGMAR Register bits
    namespace fgmar_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// FGOR Register bits
    namespace fgor_bits {
        constexpr uint32_t LO = (16 << 0);  ///< Line offset
    }

    /// BGMAR Register bits
    namespace bgmar_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// BGOR Register bits
    namespace bgor_bits {
        constexpr uint32_t LO = (16 << 0);  ///< Line offset
    }

    /// FGPFCCR Register bits
    namespace fgpfccr_bits {
        constexpr uint32_t ALPHA = (8 << 24);  ///< Alpha value
        constexpr uint32_t RBS = (1U << 21);  ///< Red Blue Swap
        constexpr uint32_t AI = (1U << 20);  ///< Alpha Inverted
        constexpr uint32_t AM = (2 << 16);  ///< Alpha mode
        constexpr uint32_t CS = (8 << 8);  ///< CLUT size
        constexpr uint32_t START = (1U << 5);  ///< Start
        constexpr uint32_t CCM = (1U << 4);  ///< CLUT color mode
        constexpr uint32_t CM = (4 << 0);  ///< Color mode
    }

    /// FGCOLR Register bits
    namespace fgcolr_bits {
        constexpr uint32_t RED = (8 << 16);  ///< Red Value
        constexpr uint32_t GREEN = (8 << 8);  ///< Green Value
        constexpr uint32_t BLUE = (8 << 0);  ///< Blue Value
    }

    /// BGPFCCR Register bits
    namespace bgpfccr_bits {
        constexpr uint32_t ALPHA = (8 << 24);  ///< Alpha value
        constexpr uint32_t RBS = (1U << 21);  ///< Red Blue Swap
        constexpr uint32_t AI = (1U << 20);  ///< Alpha Inverted
        constexpr uint32_t AM = (2 << 16);  ///< Alpha mode
        constexpr uint32_t CS = (8 << 8);  ///< CLUT size
        constexpr uint32_t START = (1U << 5);  ///< Start
        constexpr uint32_t CCM = (1U << 4);  ///< CLUT Color mode
        constexpr uint32_t CM = (4 << 0);  ///< Color mode
    }

    /// BGCOLR Register bits
    namespace bgcolr_bits {
        constexpr uint32_t RED = (8 << 16);  ///< Red Value
        constexpr uint32_t GREEN = (8 << 8);  ///< Green Value
        constexpr uint32_t BLUE = (8 << 0);  ///< Blue Value
    }

    /// FGCMAR Register bits
    namespace fgcmar_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory Address
    }

    /// BGCMAR Register bits
    namespace bgcmar_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory address
    }

    /// OPFCCR Register bits
    namespace opfccr_bits {
        constexpr uint32_t RBS = (1U << 21);  ///< Red Blue Swap
        constexpr uint32_t AI = (1U << 20);  ///< Alpha Inverted
        constexpr uint32_t SB = (1U << 9);  ///< Swap Bytes
        constexpr uint32_t CM = (3 << 0);  ///< Color mode
    }

    /// OCOLR_RGB888 Register bits
    namespace ocolr_rgb888_bits {
        constexpr uint32_t APLHA = (8 << 24);  ///< Alpha Channel Value
        constexpr uint32_t RED = (8 << 16);  ///< Red Value
        constexpr uint32_t GREEN = (8 << 8);  ///< Green Value
        constexpr uint32_t BLUE = (8 << 0);  ///< Blue Value
    }

    /// OCOLR_RGB565 Register bits
    namespace ocolr_rgb565_bits {
        constexpr uint32_t RED = (5 << 11);  ///< Red value in RGB565 mode
        constexpr uint32_t GREEN = (6 << 5);  ///< Green value in RGB565 mode
        constexpr uint32_t BLUE = (5 << 0);  ///< Blue value in RGB565 mode
    }

    /// OCOLR_ARGB1555 Register bits
    namespace ocolr_argb1555_bits {
        constexpr uint32_t A = (1U << 15);  ///< Alpha channel value in ARGB1555 mode
        constexpr uint32_t RED = (5 << 10);  ///< Red value in ARGB1555 mode
        constexpr uint32_t GREEN = (5 << 5);  ///< Green value in ARGB1555 mode
        constexpr uint32_t BLUE = (5 << 0);  ///< Blue value in ARGB1555 mode
    }

    /// OCOLR_ARGB4444 Register bits
    namespace ocolr_argb4444_bits {
        constexpr uint32_t ALPHA = (4 << 12);  ///< Alpha channel value in ARGB4444
        constexpr uint32_t RED = (4 << 8);  ///< Red value in ARGB4444 mode
        constexpr uint32_t GREEN = (4 << 4);  ///< Green value in ARGB4444 mode
        constexpr uint32_t BLUE = (4 << 0);  ///< Blue value in ARGB4444 mode
    }

    /// OMAR Register bits
    namespace omar_bits {
        constexpr uint32_t MA = (32 << 0);  ///< Memory Address
    }

    /// OOR Register bits
    namespace oor_bits {
        constexpr uint32_t LO = (16 << 0);  ///< Line Offset
    }

    /// NLR Register bits
    namespace nlr_bits {
        constexpr uint32_t PL = (14 << 16);  ///< Pixel per lines
        constexpr uint32_t NL = (16 << 0);  ///< Number of lines
    }

    /// LWR Register bits
    namespace lwr_bits {
        constexpr uint32_t LW = (16 << 0);  ///< Line watermark
    }

    /// AMTCR Register bits
    namespace amtcr_bits {
        constexpr uint32_t DT = (8 << 8);  ///< Dead Time
        constexpr uint32_t EN = (1U << 0);  ///< Enable
    }

    /// FGCLUT Register bits
    namespace fgclut_bits {
        constexpr uint32_t APLHA = (8 << 24);  ///< APLHA
        constexpr uint32_t RED = (8 << 16);  ///< RED
        constexpr uint32_t GREEN = (8 << 8);  ///< GREEN
        constexpr uint32_t BLUE = (8 << 0);  ///< BLUE
    }

    /// BGCLUT Register bits
    namespace bgclut_bits {
        constexpr uint32_t APLHA = (8 << 24);  ///< APLHA
        constexpr uint32_t RED = (8 << 16);  ///< RED
        constexpr uint32_t GREEN = (8 << 8);  ///< GREEN
        constexpr uint32_t BLUE = (8 << 0);  ///< BLUE
    }

}

// ============================================================================
// DSI Peripheral
// ============================================================================

namespace dsi {
    /// Base addresses
    constexpr uint32_t DSI_BASE = 0x40016C00;

    /// DSI Register structure
    struct Registers {
        volatile uint32_t DSI_VR;  ///< Offset: 0x00 - DSI Host version register
        volatile uint32_t DSI_CR;  ///< Offset: 0x04 - DSI Host control register
        volatile uint32_t DSI_CCR;  ///< Offset: 0x08 - DSI Host clock control register
        volatile uint32_t DSI_LVCIDR;  ///< Offset: 0x0C - DSI Host LTDC VCID register
        volatile uint32_t DSI_LCOLCR;  ///< Offset: 0x10 - DSI Host LTDC color coding register
        volatile uint32_t DSI_LPCR;  ///< Offset: 0x14 - DSI Host LTDC polarity configuration register
        volatile uint32_t DSI_LPMCR;  ///< Offset: 0x18 - DSI Host low-power mode configuration register
        volatile uint32_t DSI_PCR;  ///< Offset: 0x2C - DSI Host protocol configuration register
        volatile uint32_t DSI_GVCIDR;  ///< Offset: 0x30 - DSI Host generic VCID register
        volatile uint32_t DSI_MCR;  ///< Offset: 0x34 - DSI Host mode configuration register
        volatile uint32_t DSI_VMCR;  ///< Offset: 0x38 - DSI Host video mode configuration register
        volatile uint32_t DSI_VPCR;  ///< Offset: 0x3C - DSI Host video packet configuration register
        volatile uint32_t DSI_VCCR;  ///< Offset: 0x40 - DSI Host video chunks configuration register
        volatile uint32_t DSI_VNPCR;  ///< Offset: 0x44 - DSI Host video null packet configuration register
        volatile uint32_t DSI_VHSACR;  ///< Offset: 0x48 - DSI Host video HSA configuration register
        volatile uint32_t DSI_VHBPCR;  ///< Offset: 0x4C - DSI Host video HBP configuration register
        volatile uint32_t DSI_VLCR;  ///< Offset: 0x50 - DSI Host video line configuration register
        volatile uint32_t DSI_VVSACR;  ///< Offset: 0x54 - DSI Host video VSA configuration register
        volatile uint32_t DSI_VVBPCR;  ///< Offset: 0x58 - DSI Host video VBP configuration register
        volatile uint32_t DSI_VVFPCR;  ///< Offset: 0x5C - DSI Host video VFP configuration register
        volatile uint32_t DSI_VVACR;  ///< Offset: 0x60 - DSI Host video VA configuration register
        volatile uint32_t DSI_LCCR;  ///< Offset: 0x64 - DSI Host LTDC command configuration register
        volatile uint32_t DSI_CMCR;  ///< Offset: 0x68 - DSI Host command mode configuration register
        volatile uint32_t DSI_GHCR;  ///< Offset: 0x6C - DSI Host generic header configuration register
        volatile uint32_t DSI_GPDR;  ///< Offset: 0x70 - DSI Host generic payload data register
        volatile uint32_t DSI_GPSR;  ///< Offset: 0x74 - DSI Host generic packet status register
        volatile uint32_t DSI_TCCR0;  ///< Offset: 0x78 - DSI Host timeout counter configuration register 0
        volatile uint32_t DSI_TCCR1;  ///< Offset: 0x7C - DSI Host timeout counter configuration register 1
        volatile uint32_t DSI_TCCR2;  ///< Offset: 0x80 - DSI Host timeout counter configuration register 2
        volatile uint32_t DSI_TCCR3;  ///< Offset: 0x84 - DSI Host timeout counter configuration register 3
        volatile uint32_t DSI_TCCR4;  ///< Offset: 0x88 - DSI Host timeout counter configuration register 4
        volatile uint32_t DSI_TCCR5;  ///< Offset: 0x8C - DSI Host timeout counter configuration register 5
        volatile uint32_t DSI_CLCR;  ///< Offset: 0x94 - DSI Host clock lane configuration register
        volatile uint32_t DSI_CLTCR;  ///< Offset: 0x98 - DSI Host clock lane timer configuration register
        volatile uint32_t DSI_DLTCR;  ///< Offset: 0x9C - DSI Host data lane timer configuration register
        volatile uint32_t DSI_PCTLR;  ///< Offset: 0xA0 - DSI Host PHY control register
        volatile uint32_t DSI_PCONFR;  ///< Offset: 0xA4 - DSI Host PHY configuration register
        volatile uint32_t DSI_PUCR;  ///< Offset: 0xA8 - DSI Host PHY ULPS control register
        volatile uint32_t DSI_PTTCR;  ///< Offset: 0xAC - DSI Host PHY TX triggers configuration register
        volatile uint32_t DSI_PSR;  ///< Offset: 0xB0 - DSI Host PHY status register
        volatile uint32_t DSI_ISR0;  ///< Offset: 0xBC - DSI Host interrupt and status register 0
        volatile uint32_t DSI_ISR1;  ///< Offset: 0xC0 - DSI Host interrupt and status register 1
        volatile uint32_t DSI_IER0;  ///< Offset: 0xC4 - DSI Host interrupt enable register 0
        volatile uint32_t DSI_IER1;  ///< Offset: 0xC8 - DSI Host interrupt enable register 1
        volatile uint32_t DSI_FIR0;  ///< Offset: 0xD8 - DSI Host force interrupt register 0
        volatile uint32_t DSI_FIR1;  ///< Offset: 0xDC - DSI Host force interrupt register 1
        volatile uint32_t DSI_DLTRCR;  ///< Offset: 0xF4 - DSI Host data lane timer read configuration register
        volatile uint32_t DSI_VSCR;  ///< Offset: 0x100 - DSI Host video shadow control register
        volatile uint32_t DSI_LCVCIDR;  ///< Offset: 0x10C - DSI Host LTDC current VCID register
        volatile uint32_t DSI_LCCCR;  ///< Offset: 0x110 - DSI Host LTDC current color coding register
        volatile uint32_t DSI_LPMCCR;  ///< Offset: 0x118 - DSI Host low-power mode current configuration register
        volatile uint32_t DSI_VMCCR;  ///< Offset: 0x138 - DSI Host video mode current configuration register
        volatile uint32_t DSI_VPCCR;  ///< Offset: 0x13C - DSI Host video packet current configuration register
        volatile uint32_t DSI_VCCCR;  ///< Offset: 0x140 - DSI Host video chunks current configuration register
        volatile uint32_t DSI_VNPCCR;  ///< Offset: 0x144 - DSI Host video null packet current configuration register
        volatile uint32_t DSI_VHSACCR;  ///< Offset: 0x148 - DSI Host video HSA current configuration register
        volatile uint32_t DSI_VHBPCCR;  ///< Offset: 0x14C - DSI Host video HBP current configuration register
        volatile uint32_t DSI_VLCCR;  ///< Offset: 0x150 - DSI Host video line current configuration register
        volatile uint32_t DSI_VVSACCR;  ///< Offset: 0x154 - DSI Host video VSA current configuration register
        volatile uint32_t DSI_VVBPCCR;  ///< Offset: 0x158 - DSI Host video VBP current configuration register
        volatile uint32_t DSI_VVFPCCR;  ///< Offset: 0x15C - DSI Host video VFP current configuration register
        volatile uint32_t DSI_VVACCR;  ///< Offset: 0x160 - DSI Host video VA current configuration register
        volatile uint32_t DSI_FBSR;  ///< Offset: 0x168 - DSI Host FIFO and buffer status register
        volatile uint32_t DSI_WCFGR;  ///< Offset: 0x400 - DSI Wrapper configuration register
        volatile uint32_t DSI_WCR;  ///< Offset: 0x404 - DSI Wrapper control register
        volatile uint32_t DSI_WIER;  ///< Offset: 0x408 - DSI Wrapper interrupt enable register
        volatile uint32_t DSI_WISR;  ///< Offset: 0x40C - DSI Wrapper interrupt and status register
        volatile uint32_t DSI_WIFCR;  ///< Offset: 0x410 - DSI Wrapper interrupt flag clear register
        volatile uint32_t DSI_WPCR0;  ///< Offset: 0x418 - DSI Wrapper PHY configuration register 0
        volatile uint32_t DSI_WRPCR;  ///< Offset: 0x430 - DSI Wrapper regulator and PLL control register
        volatile uint32_t DSI_BCFGR;  ///< Offset: 0x808 - DSI bias configuration register
        volatile uint32_t DSI_DPCBCR;  ///< Offset: 0xC04 - DSI D-PHY clock band control register
        volatile uint32_t DSI_DPCSRCR;  ///< Offset: 0xC34 - DSI D-PHY clock skew rate control register
        volatile uint32_t DSI_DPDL0BCR;  ///< Offset: 0xC70 - DSI D-PHY data lane 0 band control register
        volatile uint32_t DSI_DPDL0SRCR;  ///< Offset: 0xCA0 - DSI D-PHY data lane 0 skew rate control register
        volatile uint32_t DSI_DPDL1BCR;  ///< Offset: 0xD08 - DSI D-PHY data lane 1 band control register
        volatile uint32_t DSI_DPDL1SRCR;  ///< Offset: 0xD38 - DSI D-PHY data lane 1 skew rate control register
    };

    /// Peripheral instances
    inline Registers* DSI = reinterpret_cast<Registers*>(DSI_BASE);

    // Bit definitions
    /// DSI_VR Register bits
    namespace dsi_vr_bits {
        constexpr uint32_t VERSION = (32 << 0);  ///< Version of the DSI Host This read-only register contains the version of the DSI Host
    }

    /// DSI_CR Register bits
    namespace dsi_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable This bit configures the DSI Host in either power-up mode or to reset.
    }

    /// DSI_CCR Register bits
    namespace dsi_ccr_bits {
        constexpr uint32_t TXECKDIV = (8 << 0);  ///< TX escape clock division This field indicates the division factor for the TX escape clock source (lanebyteclk). The values 0 and 1 stop the TX_ESC clock generation.
        constexpr uint32_t TOCKDIV = (8 << 8);  ///< Timeout clock division This field indicates the division factor for the timeout clock used as the timing unit in the configuration of HS to LP and LP to HS transition error.
    }

    /// DSI_LVCIDR Register bits
    namespace dsi_lvcidr_bits {
        constexpr uint32_t VCID = (2 << 0);  ///< Virtual channel ID These bits configure the virtual channel ID for the LTDC interface traffic.
    }

    /// DSI_LCOLCR Register bits
    namespace dsi_lcolcr_bits {
        constexpr uint32_t COLC = (4 << 0);  ///< Color coding This field configures the DPI color coding. Others: Reserved
        constexpr uint32_t LPE = (1U << 8);  ///< Loosely packet enable This bit enables the loosely packed variant to 18-bit configuration
    }

    /// DSI_LPCR Register bits
    namespace dsi_lpcr_bits {
        constexpr uint32_t DEP = (1U << 0);  ///< Data enable polarity This bit configures the polarity of data enable pin.
        constexpr uint32_t VSP = (1U << 1);  ///< VSYNC polarity This bit configures the polarity of VSYNC pin.
        constexpr uint32_t HSP = (1U << 2);  ///< HSYNC polarity This bit configures the polarity of HSYNC pin.
    }

    /// DSI_LPMCR Register bits
    namespace dsi_lpmcr_bits {
        constexpr uint32_t VLPSIZE = (8 << 0);  ///< VACT largest packet size This field is used for the transmission of commands in low-power mode. It defines the size, in bytes, of the largest packet that can fit in a line during VACT regions.
        constexpr uint32_t LPSIZE = (8 << 16);  ///< Largest packet size This field is used for the transmission of commands in low-power mode. It defines the size, in bytes, of the largest packet that can fit in a line during VSA, VBP and VFP regions.
    }

    /// DSI_PCR Register bits
    namespace dsi_pcr_bits {
        constexpr uint32_t ETTXE = (1U << 0);  ///< EoTp transmission enable This bit enables the EoTP transmission.
        constexpr uint32_t ETRXE = (1U << 1);  ///< EoTp reception enable This bit enables the EoTp reception.
        constexpr uint32_t BTAE = (1U << 2);  ///< Bus-turn-around enable This bit enables the bus-turn-around (BTA) request.
        constexpr uint32_t ECCRXE = (1U << 3);  ///< ECC reception enable This bit enables the ECC reception, error correction and reporting.
        constexpr uint32_t CRCRXE = (1U << 4);  ///< CRC reception enable This bit enables the CRC reception and error reporting.
        constexpr uint32_t ETTXLPE = (1U << 5);  ///< EoTp transmission in low-power enable This bit enables the EoTP transmission in low-power.
    }

    /// DSI_GVCIDR Register bits
    namespace dsi_gvcidr_bits {
        constexpr uint32_t VCIDRX = (2 << 0);  ///< Virtual channel ID for reception This field indicates the generic interface read-back virtual channel identification.
        constexpr uint32_t VCIDTX = (2 << 16);  ///< Virtual channel ID for transmission This field indicates the generic interface virtual channel identification where the generic packet is automatically generated and transmitted.
    }

    /// DSI_MCR Register bits
    namespace dsi_mcr_bits {
        constexpr uint32_t CMDM = (1U << 0);  ///< Command mode This bit configures the DSI Host in either video or command mode.
    }

    /// DSI_VMCR Register bits
    namespace dsi_vmcr_bits {
        constexpr uint32_t VMT = (2 << 0);  ///< Video mode type This field configures the video mode transmission type : 1x: Burst mode
        constexpr uint32_t LPVSAE = (1U << 8);  ///< Low-power vertical sync active enable This bit enables to return to low-power inside the vertical sync time (VSA) period when timing allows.
        constexpr uint32_t LPVBPE = (1U << 9);  ///< Low-power vertical back-porch enable This bit enables to return to low-power inside the vertical back-porch (VBP) period when timing allows.
        constexpr uint32_t LPVFPE = (1U << 10);  ///< Low-power vertical front-porch enable This bit enables to return to low-power inside the vertical front-porch (VFP) period when timing allows.
        constexpr uint32_t LPVAE = (1U << 11);  ///< Low-power vertical active enable This bit enables to return to low-power inside the vertical active (VACT) period when timing allows.
        constexpr uint32_t LPHBPE = (1U << 12);  ///< Low-power horizontal back-porch enable This bit enables the return to low-power inside the horizontal back-porch (HBP) period when timing allows.
        constexpr uint32_t LPHFPE = (1U << 13);  ///< Low-power horizontal front-porch enable This bit enables the return to low-power inside the horizontal front-porch (HFP) period when timing allows.
        constexpr uint32_t FBTAAE = (1U << 14);  ///< Frame bus-turn-around acknowledge enable This bit enables the request for an acknowledge response at the end of a frame.
        constexpr uint32_t LPCE = (1U << 15);  ///< Low-power command enable This bit enables the command transmission only in low-power mode.
        constexpr uint32_t PGE = (1U << 16);  ///< Pattern generator enable This bit enables the video mode pattern generator.
        constexpr uint32_t PGM = (1U << 20);  ///< Pattern generator mode This bit configures the pattern generator mode.
        constexpr uint32_t PGO = (1U << 24);  ///< Pattern generator orientation This bit configures the color bar orientation.
    }

    /// DSI_VPCR Register bits
    namespace dsi_vpcr_bits {
        constexpr uint32_t VPSIZE = (14 << 0);  ///< Video packet size This field configures the number of pixels in a single video packet. For 18-bit not loosely packed data types, this number must be a multiple of 4. For YCbCr data types, it must be a multiple of 2 as described in the DSI specification.
    }

    /// DSI_VCCR Register bits
    namespace dsi_vccr_bits {
        constexpr uint32_t NUMC = (13 << 0);  ///< Number of chunks This register configures the number of chunks to be transmitted during a line period (a chunk consists of a video packet and a null packet). If set to 0 or 1, the video line is transmitted in a single packet. If set to 1, the packet is part of a chunk, so a null packet follows it if NPSIZE > 0. Otherwise, multiple chunks are used to transmit each video line.
    }

    /// DSI_VNPCR Register bits
    namespace dsi_vnpcr_bits {
        constexpr uint32_t NPSIZE = (13 << 0);  ///< Null packet size This field configures the number of bytes inside a null packet. Setting to 0 disables the null packets.
    }

    /// DSI_VHSACR Register bits
    namespace dsi_vhsacr_bits {
        constexpr uint32_t HSA = (12 << 0);  ///< Horizontal synchronism active duration This fields configures the horizontal synchronism active period in lane byte clock cycles.
    }

    /// DSI_VHBPCR Register bits
    namespace dsi_vhbpcr_bits {
        constexpr uint32_t HBP = (12 << 0);  ///< Horizontal back-porch duration This fields configures the horizontal back-porch period in lane byte clock cycles.
    }

    /// DSI_VLCR Register bits
    namespace dsi_vlcr_bits {
        constexpr uint32_t HLINE = (15 << 0);  ///< Horizontal line duration This fields configures the total of the horizontal line period (HSA+HBP+HACT+HFP) counted in lane byte clock cycles.
    }

    /// DSI_VVSACR Register bits
    namespace dsi_vvsacr_bits {
        constexpr uint32_t VSA = (10 << 0);  ///< Vertical synchronism active duration This fields configures the vertical synchronism active period measured in number of horizontal lines.
    }

    /// DSI_VVBPCR Register bits
    namespace dsi_vvbpcr_bits {
        constexpr uint32_t VBP = (10 << 0);  ///< Vertical back-porch duration This fields configures the vertical back-porch period measured in number of horizontal lines.
    }

    /// DSI_VVFPCR Register bits
    namespace dsi_vvfpcr_bits {
        constexpr uint32_t VFP = (10 << 0);  ///< Vertical front-porch duration This fields configures the vertical front-porch period measured in number of horizontal lines.
    }

    /// DSI_VVACR Register bits
    namespace dsi_vvacr_bits {
        constexpr uint32_t VA = (14 << 0);  ///< Vertical active duration This fields configures the vertical active period measured in number of horizontal lines.
    }

    /// DSI_LCCR Register bits
    namespace dsi_lccr_bits {
        constexpr uint32_t CMDSIZE = (16 << 0);  ///< Command size This field configures the maximum allowed size for an LTDC write memory command, measured in pixels. Automatic partitioning of data obtained from LTDC is permanently enabled.
    }

    /// DSI_CMCR Register bits
    namespace dsi_cmcr_bits {
        constexpr uint32_t TEARE = (1U << 0);  ///< Tearing effect acknowledge request enable This bit enables the tearing effect acknowledge request:
        constexpr uint32_t ARE = (1U << 1);  ///< Acknowledge request enable This bit enables the acknowledge request after each packet transmission:
        constexpr uint32_t GSW0TX = (1U << 8);  ///< Generic short write zero parameters transmission This bit configures the generic short write packet with zero parameters command transmission type:
        constexpr uint32_t GSW1TX = (1U << 9);  ///< Generic short write one parameters transmission This bit configures the generic short write packet with one parameters command transmission type:
        constexpr uint32_t GSW2TX = (1U << 10);  ///< Generic short write two parameters transmission This bit configures the generic short write packet with two parameters command transmission type:
        constexpr uint32_t GSR0TX = (1U << 11);  ///< Generic short read zero parameters transmission This bit configures the generic short read packet with zero parameters command transmission type:
        constexpr uint32_t GSR1TX = (1U << 12);  ///< Generic short read one parameters transmission This bit configures the generic short read packet with one parameters command transmission type:
        constexpr uint32_t GSR2TX = (1U << 13);  ///< Generic short read two parameters transmission This bit configures the generic short read packet with two parameters command transmission type:
        constexpr uint32_t GLWTX = (1U << 14);  ///< Generic long write transmission This bit configures the generic long write packet command transmission type :
        constexpr uint32_t DSW0TX = (1U << 16);  ///< DCS short write zero parameter transmission This bit configures the DCS short write packet with zero parameter command transmission type:
        constexpr uint32_t DSW1TX = (1U << 17);  ///< DCS short read one parameter transmission This bit configures the DCS short read packet with one parameter command transmission type:
        constexpr uint32_t DSR0TX = (1U << 18);  ///< DCS short read zero parameter transmission This bit configures the DCS short read packet with zero parameter command transmission type:
        constexpr uint32_t DLWTX = (1U << 19);  ///< DCS long write transmission This bit configures the DCS long write packet command transmission type:
        constexpr uint32_t MRDPS = (1U << 24);  ///< Maximum read packet size This bit configures the maximum read packet size command transmission type:
    }

    /// DSI_GHCR Register bits
    namespace dsi_ghcr_bits {
        constexpr uint32_t DT = (6 << 0);  ///< Type This field configures the packet data type of the header packet.
        constexpr uint32_t VCID = (2 << 6);  ///< Channel This field configures the virtual channel ID of the header packet.
        constexpr uint32_t WCLSB = (8 << 8);  ///< WordCount LSB This field configures the less significant byte of the header packet word count for long packets, or data 0 for short packets.
        constexpr uint32_t WCMSB = (8 << 16);  ///< WordCount MSB This field configures the most significant byte of the header packet's word count for long packets, or data 1 for short packets.
    }

    /// DSI_GPDR Register bits
    namespace dsi_gpdr_bits {
        constexpr uint32_t DATA1 = (8 << 0);  ///< Payload byte 1 This field indicates the byte 1 of the packet payload.
        constexpr uint32_t DATA2 = (8 << 8);  ///< Payload byte 2 This field indicates the byte 2 of the packet payload.
        constexpr uint32_t DATA3 = (8 << 16);  ///< Payload byte 3 This field indicates the byte 3 of the packet payload.
        constexpr uint32_t DATA4 = (8 << 24);  ///< Payload byte 4 This field indicates the byte 4 of the packet payload.
    }

    /// DSI_GPSR Register bits
    namespace dsi_gpsr_bits {
        constexpr uint32_t CMDFE = (1U << 0);  ///< Command FIFO empty This bit indicates the empty status of the generic command FIFO:
        constexpr uint32_t CMDFF = (1U << 1);  ///< Command FIFO full This bit indicates the full status of the generic command FIFO:
        constexpr uint32_t PWRFE = (1U << 2);  ///< Payload write FIFO empty This bit indicates the empty status of the generic write payload FIFO:
        constexpr uint32_t PWRFF = (1U << 3);  ///< Payload write FIFO full This bit indicates the full status of the generic write payload FIFO:
        constexpr uint32_t PRDFE = (1U << 4);  ///< Payload read FIFO empty This bit indicates the empty status of the generic read payload FIFO:
        constexpr uint32_t PRDFF = (1U << 5);  ///< Payload read FIFO full This bit indicates the full status of the generic read payload FIFO:
        constexpr uint32_t RCB = (1U << 6);  ///< Read command busy This bit is set when a read command is issued and cleared when the entire response is stored in the FIFO:
        constexpr uint32_t CMDBE = (1U << 16);  ///< Command buffer empty This bit indicates the empty status of the generic payload internal buffer:
        constexpr uint32_t CMDBF = (1U << 17);  ///< Command buffer full This bit indicates the full status of the generic command internal buffer:
        constexpr uint32_t PBE = (1U << 18);  ///< Payload buffer empty This bit indicates the empty status of the generic payload internal buffer:
        constexpr uint32_t PBF = (1U << 19);  ///< Payload buffer full This bit indicates the full status of the generic payload internal buffer:
    }

    /// DSI_TCCR0 Register bits
    namespace dsi_tccr0_bits {
        constexpr uint32_t LPRX_TOCNT = (16 << 0);  ///< Low-power reception timeout counter This field configures the timeout counter that triggers a low-power reception timeout contention detection (measured in TOCKDIV cycles).
        constexpr uint32_t HSTX_TOCNT = (16 << 16);  ///< High-speed transmission timeout counter This field configures the timeout counter that triggers a high-speed transmission timeout contention detection (measured in TOCKDIV cycles). If using the non-burst mode and there is no enough time to switch from high-speed to low-power and back in the period from one line data finishing to the next line sync start, the DSI link returns the low-power state once per frame, then configure the TOCKDIV and HSTX_TOCNT to be in accordance with: HSTX_TOCNT * lanebyteclkperiod * TOCKDIV â¥ the time of one FRAME data transmission *Â (1 + 10%) In burst mode, RGB pixel packets are time-compressed, leaving more time during a scan line. Therefore, if in burst mode and there is enough time to switch from high-speed to low-power and back in the period from one line data finishing to the next line sync start, the DSI link can return low-power mode and back in this time interval to save power. For this, configure the TOCKDIV and HSTX_TOCNT to be in accordance with: HSTX_TOCNT * lanebyteclkperiod * TOCKDIV â¥ the time of one LINE data transmission *Â (1Â +Â 10%)
    }

    /// DSI_TCCR1 Register bits
    namespace dsi_tccr1_bits {
        constexpr uint32_t HSRD_TOCNT = (16 << 0);  ///< High-speed read timeout counter This field sets a period for which the DSI Host keeps the link still, after sending a high-speed read operation. This period is measured in cycles of lanebyteclk. The counting starts when the D-PHY enters the Stop state and causes no interrupts.
    }

    /// DSI_TCCR2 Register bits
    namespace dsi_tccr2_bits {
        constexpr uint32_t LPRD_TOCNT = (16 << 0);  ///< Low-power read timeout counter This field sets a period for which the DSI Host keeps the link still, after sending a low-power read operation. This period is measured in cycles of lanebyteclk. The counting starts when the D-PHY enters the Stop state and causes no interrupts.
    }

    /// DSI_TCCR3 Register bits
    namespace dsi_tccr3_bits {
        constexpr uint32_t HSWR_TOCNT = (16 << 0);  ///< High-speed write timeout counter This field sets a period for which the DSI Host keeps the link inactive after sending a high-speed write operation. This period is measured in cycles of lanebyteclk. The counting starts when the D-PHY enters the Stop state and causes no interrupts.
        constexpr uint32_t PM = (1U << 24);  ///< Presp mode When set to 1, this bit ensures that the peripheral response timeout caused by HSWR_TOCNT is used only once per LTDC frame in command mode, when both the following conditions are met: dpivsync_edpiwms has risen and fallen. Packets originated from LTDC in command mode have been transmitted and its FIFO is empty again. In this scenario no non-LTDC command requests are sent to the D-PHY, even if there is traffic from generic interface ready to be sent, making it return to stop state. When it does so, PRESP_TO counter is activated and only when it finishes does the controller send any other traffic that is ready.
    }

    /// DSI_TCCR4 Register bits
    namespace dsi_tccr4_bits {
        constexpr uint32_t LPWR_TOCNT = (16 << 0);  ///< Low-power write timeout counter This field sets a period for which the DSI Host keeps the link still, after sending a low-power write operation. This period is measured in cycles of lanebyteclk. The counting starts when the D-PHY enters the Stop state and causes no interrupts.
    }

    /// DSI_TCCR5 Register bits
    namespace dsi_tccr5_bits {
        constexpr uint32_t BTA_TOCNT = (16 << 0);  ///< Bus-turn-around timeout counter This field sets a period for which the DSI Host keeps the link still, after completing a bus-turn-around. This period is measured in cycles of lanebyteclk. The counting starts when the DâPHY enters the Stop state and causes no interrupts.
    }

    /// DSI_CLCR Register bits
    namespace dsi_clcr_bits {
        constexpr uint32_t DPCC = (1U << 0);  ///< D-PHY clock control This bit controls the D-PHY clock state:
        constexpr uint32_t ACR = (1U << 1);  ///< Automatic clock lane control This bit enables the automatic mechanism to stop providing clock in the clock lane when time allows.
    }

    /// DSI_CLTCR Register bits
    namespace dsi_cltcr_bits {
        constexpr uint32_t LP2HS_TIME = (10 << 0);  ///< Low-power to high-speed time This field configures the maximum time that the D-PHY clock lane takes to go from lowâpower to high-speed transmission measured in lane byte clock cycles.
        constexpr uint32_t HS2LP_TIME = (10 << 16);  ///< High-speed to low-power time This field configures the maximum time that the D-PHY clock lane takes to go from highâspeed to low-power transmission measured in lane byte clock cycles.
    }

    /// DSI_DLTCR Register bits
    namespace dsi_dltcr_bits {
        constexpr uint32_t LP2HS_TIME = (10 << 0);  ///< Low-power to high-speed time This field configures the maximum time that the D-PHY data lanes take to go from low-power to high-speed transmission measured in lane byte clock cycles.
        constexpr uint32_t HS2LP_TIME = (10 << 16);  ///< High-speed to low-power time This field configures the maximum time that the D-PHY data lanes take to go from high-speed to low-power transmission measured in lane byte clock cycles.
    }

    /// DSI_PCTLR Register bits
    namespace dsi_pctlr_bits {
        constexpr uint32_t DEN = (1U << 1);  ///< Digital enable When set to 0, this bit places the digital section of the D-PHY in the reset state
        constexpr uint32_t CKE = (1U << 2);  ///< Clock enable This bit enables the D-PHY clock lane module:
    }

    /// DSI_PCONFR Register bits
    namespace dsi_pconfr_bits {
        constexpr uint32_t NL = (2 << 0);  ///< Number of lanes This field configures the number of active data lanes: Others: Reserved
        constexpr uint32_t SW_TIME = (8 << 8);  ///< Stop wait time This field configures the minimum wait period to request a high-speed transmission after the Stop state.
    }

    /// DSI_PUCR Register bits
    namespace dsi_pucr_bits {
        constexpr uint32_t URCL = (1U << 0);  ///< ULPS request on clock lane ULPS mode request on clock lane.
        constexpr uint32_t UECL = (1U << 1);  ///< ULPS exit on clock lane ULPS mode exit on clock lane.
        constexpr uint32_t URDL = (1U << 2);  ///< ULPS request on data lane ULPS mode request on all active data lanes.
        constexpr uint32_t UEDL = (1U << 3);  ///< ULPS exit on data lane ULPS mode exit on all active data lanes.
    }

    /// DSI_PTTCR Register bits
    namespace dsi_pttcr_bits {
        constexpr uint32_t TX_TRIG = (4 << 0);  ///< Transmission trigger Escape mode transmit trigger 0-3. Only one bit of TX_TRIG is asserted at any given time.
    }

    /// DSI_PSR Register bits
    namespace dsi_psr_bits {
        constexpr uint32_t PD = (1U << 1);  ///< PHY direction This bit indicates the status of phydirection D-PHY signal.
        constexpr uint32_t PSSC = (1U << 2);  ///< PHY stop state clock lane This bit indicates the status of phystopstateclklane D-PHY signal.
        constexpr uint32_t UANC = (1U << 3);  ///< ULPS active not clock lane This bit indicates the status of ulpsactivenotclklane D-PHY signal.
        constexpr uint32_t PSS0 = (1U << 4);  ///< PHY stop state lane 0 This bit indicates the status of phystopstate0lane D-PHY signal.
        constexpr uint32_t UAN0 = (1U << 5);  ///< ULPS active not lane 1 This bit indicates the status of ulpsactivenot0lane D-PHY signal.
        constexpr uint32_t RUE0 = (1U << 6);  ///< RX ULPS escape lane 0 This bit indicates the status of rxulpsesc0lane D-PHY signal.
        constexpr uint32_t PSS1 = (1U << 7);  ///< PHY stop state lane 1 This bit indicates the status of phystopstate1lane D-PHY signal.
        constexpr uint32_t UAN1 = (1U << 8);  ///< ULPS active not lane 1 This bit indicates the status of ulpsactivenot1lane D-PHY signal.
    }

    /// DSI_ISR0 Register bits
    namespace dsi_isr0_bits {
        constexpr uint32_t AE0 = (1U << 0);  ///< Acknowledge error 0 This bit retrieves the SoT error from the acknowledge error report.
        constexpr uint32_t AE1 = (1U << 1);  ///< Acknowledge error 1 This bit retrieves the SoT sync error from the acknowledge error report.
        constexpr uint32_t AE2 = (1U << 2);  ///< Acknowledge error 2 This bit retrieves the EoT sync error from the acknowledge error report.
        constexpr uint32_t AE3 = (1U << 3);  ///< Acknowledge error 3 This bit retrieves the escape mode entry command error from the acknowledge error report.
        constexpr uint32_t AE4 = (1U << 4);  ///< Acknowledge error 4 This bit retrieves the LP transmit sync error from the acknowledge error report.
        constexpr uint32_t AE5 = (1U << 5);  ///< Acknowledge error 5 This bit retrieves the peripheral timeout error from the acknowledge error report.
        constexpr uint32_t AE6 = (1U << 6);  ///< Acknowledge error 6 This bit retrieves the false control error from the acknowledge error report.
        constexpr uint32_t AE7 = (1U << 7);  ///< Acknowledge error 7 This bit retrieves the reserved (specific to the device) from the acknowledge error report.
        constexpr uint32_t AE8 = (1U << 8);  ///< Acknowledge error 8 This bit retrieves the ECC error, single-bit (detected and corrected) from the acknowledge error report.
        constexpr uint32_t AE9 = (1U << 9);  ///< Acknowledge error 9 This bit retrieves the ECC error, multi-bit (detected, not corrected) from the acknowledge error report.
        constexpr uint32_t AE10 = (1U << 10);  ///< Acknowledge error 10 This bit retrieves the checksum error (long packet only) from the acknowledge error report.
        constexpr uint32_t AE11 = (1U << 11);  ///< Acknowledge error 11 This bit retrieves the not recognized DSI data type from the acknowledge error report.
        constexpr uint32_t AE12 = (1U << 12);  ///< Acknowledge error 12 This bit retrieves the DSI VC ID Invalid from the acknowledge error report.
        constexpr uint32_t AE13 = (1U << 13);  ///< Acknowledge error 13 This bit retrieves the invalid transmission length from the acknowledge error report.
        constexpr uint32_t AE14 = (1U << 14);  ///< Acknowledge error 14 This bit retrieves the reserved (specific to the device) from the acknowledge error report.
        constexpr uint32_t AE15 = (1U << 15);  ///< Acknowledge error 15 This bit retrieves the DSI protocol violation from the acknowledge error report.
        constexpr uint32_t PE0 = (1U << 16);  ///< PHY error 0 This bit indicates the ErrEsc escape entry error from lane 0.
        constexpr uint32_t PE1 = (1U << 17);  ///< PHY error 1 This bit indicates the ErrSyncEsc low-power transmission synchronization error from lane 0.
        constexpr uint32_t PE2 = (1U << 18);  ///< PHY error 2 This bit indicates the ErrControl error from lane 0.
        constexpr uint32_t PE3 = (1U << 19);  ///< PHY error 3 This bit indicates the LP0 contention error ErrContentionLP0 from lane 0.
        constexpr uint32_t PE4 = (1U << 20);  ///< PHY error 4 This bit indicates the LP1 contention error ErrContentionLP1 from lane 0.
    }

    /// DSI_ISR1 Register bits
    namespace dsi_isr1_bits {
        constexpr uint32_t TOHSTX = (1U << 0);  ///< Timeout high-speed transmission This bit indicates that the high-speed transmission timeout counter reached the end and contention is detected.
        constexpr uint32_t TOLPRX = (1U << 1);  ///< Timeout low-power reception This bit indicates that the low-power reception timeout counter reached the end and contention is detected.
        constexpr uint32_t ECCSE = (1U << 2);  ///< ECC single-bit error This bit indicates that the ECC single error is detected and corrected in a received packet.
        constexpr uint32_t ECCME = (1U << 3);  ///< ECC multi-bit error This bit indicates that the ECC multiple error is detected in a received packet.
        constexpr uint32_t CRCE = (1U << 4);  ///< CRC error This bit indicates that the CRC error is detected in the received packet payload.
        constexpr uint32_t PSE = (1U << 5);  ///< Packet size error This bit indicates that the packet size error is detected during the packet reception.
        constexpr uint32_t EOTPE = (1U << 6);  ///< EoTp error This bit indicates that the EoTp packet is not received at the end of the incoming peripheral transmission.
        constexpr uint32_t LPWRE = (1U << 7);  ///< LTDC payload write error This bit indicates that during a DPI pixel line storage, the payload FIFO becomes full and the data stored is corrupted.
        constexpr uint32_t GCWRE = (1U << 8);  ///< Generic command write error This bit indicates that the system tried to write a command through the generic interface and the FIFO is full. Therefore, the command is not written.
        constexpr uint32_t GPWRE = (1U << 9);  ///< Generic payload write error This bit indicates that the system tried to write a payload data through the generic interface and the FIFO is full. Therefore, the payload is not written.
        constexpr uint32_t GPTXE = (1U << 10);  ///< Generic payload transmit error This bit indicates that during a generic interface packet build, the payload FIFO becomes empty and corrupt data is sent.
        constexpr uint32_t GPRDE = (1U << 11);  ///< Generic payload read error This bit indicates that during a DCS read data, the payload FIFO becomes empty and the data sent to the interface is corrupted.
        constexpr uint32_t GPRXE = (1U << 12);  ///< Generic payload receive error This bit indicates that during a generic interface packet read back, the payload FIFO becomes full and the received data is corrupted.
        constexpr uint32_t PBUE = (1U << 19);  ///< Payload buffer underflow error This bit indicates that underflow has occurred when reading payload to build DSI packet for video mode.
    }

    /// DSI_IER0 Register bits
    namespace dsi_ier0_bits {
        constexpr uint32_t AE0IE = (1U << 0);  ///< Acknowledge error 0 interrupt enable This bit enables the interrupt generation on acknowledge error 0.
        constexpr uint32_t AE1IE = (1U << 1);  ///< Acknowledge error 1 interrupt enable This bit enables the interrupt generation on acknowledge error 1.
        constexpr uint32_t AE2IE = (1U << 2);  ///< Acknowledge error 2 interrupt enable This bit enables the interrupt generation on acknowledge error 2.
        constexpr uint32_t AE3IE = (1U << 3);  ///< Acknowledge error 3 interrupt enable This bit enables the interrupt generation on acknowledge error 3.
        constexpr uint32_t AE4IE = (1U << 4);  ///< Acknowledge error 4 interrupt enable This bit enables the interrupt generation on acknowledge error 4.
        constexpr uint32_t AE5IE = (1U << 5);  ///< Acknowledge error 5 interrupt enable This bit enables the interrupt generation on acknowledge error 5.
        constexpr uint32_t AE6IE = (1U << 6);  ///< Acknowledge error 6 interrupt enable This bit enables the interrupt generation on acknowledge error 6.
        constexpr uint32_t AE7IE = (1U << 7);  ///< Acknowledge error 7 interrupt enable This bit enables the interrupt generation on acknowledge error 7.
        constexpr uint32_t AE8IE = (1U << 8);  ///< Acknowledge error 8 interrupt enable This bit enables the interrupt generation on acknowledge error 8.
        constexpr uint32_t AE9IE = (1U << 9);  ///< Acknowledge error 9 interrupt enable This bit enables the interrupt generation on acknowledge error 9.
        constexpr uint32_t AE10IE = (1U << 10);  ///< Acknowledge error 10 interrupt enable This bit enables the interrupt generation on acknowledge error 10.
        constexpr uint32_t AE11IE = (1U << 11);  ///< Acknowledge error 11 interrupt enable This bit enables the interrupt generation on acknowledge error 11.
        constexpr uint32_t AE12IE = (1U << 12);  ///< Acknowledge error 12 interrupt enable This bit enables the interrupt generation on acknowledge error 12.
        constexpr uint32_t AE13IE = (1U << 13);  ///< Acknowledge error 13 interrupt enable This bit enables the interrupt generation on acknowledge error 13.
        constexpr uint32_t AE14IE = (1U << 14);  ///< Acknowledge error 14 interrupt enable This bit enables the interrupt generation on acknowledge error 14.
        constexpr uint32_t AE15IE = (1U << 15);  ///< Acknowledge error 15 interrupt enable This bit enables the interrupt generation on acknowledge error 15.
        constexpr uint32_t PE0IE = (1U << 16);  ///< PHY error 0 interrupt enable This bit enables the interrupt generation on PHY error 0.
        constexpr uint32_t PE1IE = (1U << 17);  ///< PHY error 1 interrupt enable This bit enables the interrupt generation on PHY error 1.
        constexpr uint32_t PE2IE = (1U << 18);  ///< PHY error 2 interrupt enable This bit enables the interrupt generation on PHY error 2.
        constexpr uint32_t PE3IE = (1U << 19);  ///< PHY error 3 interrupt enable This bit enables the interrupt generation on PHY error 4.
        constexpr uint32_t PE4IE = (1U << 20);  ///< PHY error 4 interrupt enable This bit enables the interrupt generation on PHY error 4.
    }

    /// DSI_IER1 Register bits
    namespace dsi_ier1_bits {
        constexpr uint32_t TOHSTXIE = (1U << 0);  ///< Timeout high-speed transmission interrupt enable This bit enables the interrupt generation on timeout high-speed transmission .
        constexpr uint32_t TOLPRXIE = (1U << 1);  ///< Timeout low-power reception interrupt enable This bit enables the interrupt generation on timeout low-power reception.
        constexpr uint32_t ECCSEIE = (1U << 2);  ///< ECC single-bit error interrupt enable This bit enables the interrupt generation on ECC single-bit error.
        constexpr uint32_t ECCMEIE = (1U << 3);  ///< ECC multi-bit error interrupt enable This bit enables the interrupt generation on ECC multi-bit error.
        constexpr uint32_t CRCEIE = (1U << 4);  ///< CRC error interrupt enable This bit enables the interrupt generation on CRC error.
        constexpr uint32_t PSEIE = (1U << 5);  ///< Packet size error interrupt enable This bit enables the interrupt generation on packet size error.
        constexpr uint32_t EOTPEIE = (1U << 6);  ///< EoTp error interrupt enable This bit enables the interrupt generation on EoTp error.
        constexpr uint32_t LPWREIE = (1U << 7);  ///< LTDC payload write error interrupt enable This bit enables the interrupt generation on LTDC payload write error.
        constexpr uint32_t GCWREIE = (1U << 8);  ///< Generic command write error interrupt enable This bit enables the interrupt generation on generic command write error.
        constexpr uint32_t GPWREIE = (1U << 9);  ///< Generic payload write error interrupt enable This bit enables the interrupt generation on generic payload write error.
        constexpr uint32_t GPTXEIE = (1U << 10);  ///< Generic payload transmit error interrupt enable This bit enables the interrupt generation on generic payload transmit error.
        constexpr uint32_t GPRDEIE = (1U << 11);  ///< Generic payload read error interrupt enable This bit enables the interrupt generation on generic payload read error.
        constexpr uint32_t GPRXEIE = (1U << 12);  ///< Generic payload receive error interrupt enable This bit enables the interrupt generation on generic payload receive error.
        constexpr uint32_t PBUEIE = (1U << 19);  ///< Payload buffer underflow error interrupt enable This bit enables the interrupt generation on payload buffer underflow error.
    }

    /// DSI_FIR0 Register bits
    namespace dsi_fir0_bits {
        constexpr uint32_t FAE0 = (1U << 0);  ///< Force acknowledge error 0 Writing one to this bit forces an acknowledge error 0.
        constexpr uint32_t FAE1 = (1U << 1);  ///< Force acknowledge error 1 Writing one to this bit forces an acknowledge error 1.
        constexpr uint32_t FAE2 = (1U << 2);  ///< Force acknowledge error 2 Writing one to this bit forces an acknowledge error 2.
        constexpr uint32_t FAE3 = (1U << 3);  ///< Force acknowledge error 3 Writing one to this bit forces an acknowledge error 3.
        constexpr uint32_t FAE4 = (1U << 4);  ///< Force acknowledge error 4 Writing one to this bit forces an acknowledge error 4.
        constexpr uint32_t FAE5 = (1U << 5);  ///< Force acknowledge error 5 Writing one to this bit forces an acknowledge error 5.
        constexpr uint32_t FAE6 = (1U << 6);  ///< Force acknowledge error 6 Writing one to this bit forces an acknowledge error 6.
        constexpr uint32_t FAE7 = (1U << 7);  ///< Force acknowledge error 7 Writing one to this bit forces an acknowledge error 7.
        constexpr uint32_t FAE8 = (1U << 8);  ///< Force acknowledge error 8 Writing one to this bit forces an acknowledge error 8.
        constexpr uint32_t FAE9 = (1U << 9);  ///< Force acknowledge error 9 Writing one to this bit forces an acknowledge error 9.
        constexpr uint32_t FAE10 = (1U << 10);  ///< Force acknowledge error 10 Writing one to this bit forces an acknowledge error 10.
        constexpr uint32_t FAE11 = (1U << 11);  ///< Force acknowledge error 11 Writing one to this bit forces an acknowledge error 11.
        constexpr uint32_t FAE12 = (1U << 12);  ///< Force acknowledge error 12 Writing one to this bit forces an acknowledge error 12.
        constexpr uint32_t FAE13 = (1U << 13);  ///< Force acknowledge error 13 Writing one to this bit forces an acknowledge error 13.
        constexpr uint32_t FAE14 = (1U << 14);  ///< Force acknowledge error 14 Writing one to this bit forces an acknowledge error 14.
        constexpr uint32_t FAE15 = (1U << 15);  ///< Force acknowledge error 15 Writing one to this bit forces an acknowledge error 15.
        constexpr uint32_t FPE0 = (1U << 16);  ///< Force PHY error 0 Writing one to this bit forces a PHY error 0.
        constexpr uint32_t FPE1 = (1U << 17);  ///< Force PHY error 1 Writing one to this bit forces a PHY error 1.
        constexpr uint32_t FPE2 = (1U << 18);  ///< Force PHY error 2 Writing one to this bit forces a PHY error 2.
        constexpr uint32_t FPE3 = (1U << 19);  ///< Force PHY error 3 Writing one to this bit forces a PHY error 3.
        constexpr uint32_t FPE4 = (1U << 20);  ///< Force PHY error 4 Writing one to this bit forces a PHY error 4.
    }

    /// DSI_FIR1 Register bits
    namespace dsi_fir1_bits {
        constexpr uint32_t FTOHSTX = (1U << 0);  ///< Force timeout high-speed transmission Writing one to this bit forces a timeout high-speed transmission.
        constexpr uint32_t FTOLPRX = (1U << 1);  ///< Force timeout low-power reception Writing one to this bit forces a timeout low-power reception.
        constexpr uint32_t FECCSE = (1U << 2);  ///< Force ECC single-bit error Writing one to this bit forces a ECC single-bit error.
        constexpr uint32_t FECCME = (1U << 3);  ///< Force ECC multi-bit error Writing one to this bit forces a ECC multi-bit error.
        constexpr uint32_t FCRCE = (1U << 4);  ///< Force CRC error Writing one to this bit forces a CRC error.
        constexpr uint32_t FPSE = (1U << 5);  ///< Force packet size error Writing one to this bit forces a packet size error.
        constexpr uint32_t FEOTPE = (1U << 6);  ///< Force EoTp error Writing one to this bit forces a EoTp error.
        constexpr uint32_t FLPWRE = (1U << 7);  ///< Force LTDC payload write error Writing one to this bit forces a LTDC payload write error.
        constexpr uint32_t FGCWRE = (1U << 8);  ///< Force generic command write error Writing one to this bit forces a generic command write error.
        constexpr uint32_t FGPWRE = (1U << 9);  ///< Force generic payload write error Writing one to this bit forces a generic payload write error.
        constexpr uint32_t FGPTXE = (1U << 10);  ///< Force generic payload transmit error Writing one to this bit forces a generic payload transmit error.
        constexpr uint32_t FGPRDE = (1U << 11);  ///< Force generic payload read error Writing one to this bit forces a generic payload read error.
        constexpr uint32_t FGPRXE = (1U << 12);  ///< Force generic payload receive error Writing one to this bit forces a generic payload receive error.
        constexpr uint32_t FPBUE = (1U << 19);  ///< Force payload buffer underflow error Writing one to this bit forces a payload undrflow error.
    }

    /// DSI_DLTRCR Register bits
    namespace dsi_dltrcr_bits {
        constexpr uint32_t MRD_TIME = (15 << 0);  ///< Maximum read time This field configures the maximum time required to perform a read command in lane byte clock cycles. This register can only be modified when no read command is in progress.
    }

    /// DSI_VSCR Register bits
    namespace dsi_vscr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable When set to 1, DSI Host LTDC interface receives the active configuration from the auxiliary registers. When this bit is set along with the UR bit, the auxiliary registers are automatically updated.
        constexpr uint32_t UR = (1U << 8);  ///< Update register When set to 1, the LTDC registers are copied to the auxiliary registers. After copying, this bit is auto cleared.
    }

    /// DSI_LCVCIDR Register bits
    namespace dsi_lcvcidr_bits {
        constexpr uint32_t VCID = (2 << 0);  ///< Virtual channel ID This field returns the virtual channel ID for the LTDC interface.
    }

    /// DSI_LCCCR Register bits
    namespace dsi_lcccr_bits {
        constexpr uint32_t COLC = (4 << 0);  ///< Color coding This field returns the current LTDC interface color coding. 0110-1111: reserved If LTDC interface in command mode is chosen and currently works in the command mode (CMDM=1), then 0110-1111: 24-bit
        constexpr uint32_t LPE = (1U << 8);  ///< Loosely packed enable This bit returns the current state of the loosely packed variant to 18-bit configurations.
    }

    /// DSI_LPMCCR Register bits
    namespace dsi_lpmccr_bits {
        constexpr uint32_t VLPSIZE = (8 << 0);  ///< VACT largest packet size This field returns the current size, in bytes, of the largest packet that can fit in a line during VACT regions, for the transmission of commands in low-power mode.
        constexpr uint32_t LPSIZE = (8 << 16);  ///< Largest packet size This field is returns the current size, in bytes, of the largest packet that can fit in a line during VSA, VBP and VFP regions, for the transmission of commands in low-power mode.
    }

    /// DSI_VMCCR Register bits
    namespace dsi_vmccr_bits {
        constexpr uint32_t VMT = (2 << 0);  ///< Video mode type This field returns the current video mode transmission type: 1x: Burst mode
        constexpr uint32_t LPVSAE = (1U << 2);  ///< Low-power vertical sync time enable This bit returns the current state of return to low-power inside the vertical sync time (VSA) period when timing allows.
        constexpr uint32_t LPVBPE = (1U << 3);  ///< Low-power vertical back-porch enable This bit returns the current state of return to low-power inside the vertical back-porch (VBP) period when timing allows.
        constexpr uint32_t LPVFPE = (1U << 4);  ///< Low-power vertical front-porch enable This bit returns the current state of return to low-power inside the vertical front-porch (VFP) period when timing allows.
        constexpr uint32_t LPVAE = (1U << 5);  ///< Low-power vertical active enable This bit returns the current state of return to low-power inside the vertical active (VACT) period when timing allows.
        constexpr uint32_t LPHBPE = (1U << 6);  ///< Low-power horizontal back-porch enable This bit returns the current state of return to low-power inside the horizontal back-porch (HBP) period when timing allows.
        constexpr uint32_t LPHFE = (1U << 7);  ///< Low-power horizontal front-porch enable This bit returns the current state of return to low-power inside the horizontal front-porch (HFP) period when timing allows.
        constexpr uint32_t FBTAAE = (1U << 8);  ///< Frame BTA acknowledge enable This bit returns the current state of request for an acknowledge response at the end of a frame.
        constexpr uint32_t LPCE = (1U << 9);  ///< Low-power command enable This bit returns the current command transmission state in low-power mode.
    }

    /// DSI_VPCCR Register bits
    namespace dsi_vpccr_bits {
        constexpr uint32_t VPSIZE = (14 << 0);  ///< Video packet size This field returns the number of pixels in a single video packet.
    }

    /// DSI_VCCCR Register bits
    namespace dsi_vcccr_bits {
        constexpr uint32_t NUMC = (13 << 0);  ///< Number of chunks This field returns the number of chunks being transmitted during a line period.
    }

    /// DSI_VNPCCR Register bits
    namespace dsi_vnpccr_bits {
        constexpr uint32_t NPSIZE = (13 << 0);  ///< Null packet size This field returns the number of bytes inside a null packet.
    }

    /// DSI_VHSACCR Register bits
    namespace dsi_vhsaccr_bits {
        constexpr uint32_t HSA = (12 << 0);  ///< Horizontal synchronism active duration This fields returns the horizontal synchronism active period in lane byte clock cycles.
    }

    /// DSI_VHBPCCR Register bits
    namespace dsi_vhbpccr_bits {
        constexpr uint32_t HBP = (12 << 0);  ///< Horizontal back-porch duration This field returns the horizontal back-porch period in lane byte clock cycles.
    }

    /// DSI_VLCCR Register bits
    namespace dsi_vlccr_bits {
        constexpr uint32_t HLINE = (15 << 0);  ///< Horizontal line duration This field returns the current total of the horizontal line period (HSA+HBP+HACT+HFP) counted in lane byte clock cycles.
    }

    /// DSI_VVSACCR Register bits
    namespace dsi_vvsaccr_bits {
        constexpr uint32_t VSA = (10 << 0);  ///< Vertical synchronism active duration This field returns the current vertical synchronism active period measured in number of horizontal lines.
    }

    /// DSI_VVBPCCR Register bits
    namespace dsi_vvbpccr_bits {
        constexpr uint32_t VBP = (10 << 0);  ///< Vertical back-porch duration This field returns the current vertical back-porch period measured in number of horizontal lines.
    }

    /// DSI_VVFPCCR Register bits
    namespace dsi_vvfpccr_bits {
        constexpr uint32_t VFP = (10 << 0);  ///< Vertical front-porch duration This field returns the current vertical front-porch period measured in number of horizontal lines.
    }

    /// DSI_VVACCR Register bits
    namespace dsi_vvaccr_bits {
        constexpr uint32_t VA = (14 << 0);  ///< Vertical active duration This field returns the current vertical active period measured in number of horizontal lines.
    }

    /// DSI_FBSR Register bits
    namespace dsi_fbsr_bits {
        constexpr uint32_t VCWFE = (1U << 0);  ///< Video mode command write FIFO empty This bit indicates the empty status of the video mode write command FIFO:
        constexpr uint32_t VCWFF = (1U << 1);  ///< Video mode command write FIFO full This bit indicates the full status of the video mode write command FIFO:
        constexpr uint32_t VPWFE = (1U << 2);  ///< Video mode payload write FIFO empty This bit indicates the empty status of the video mode write payload FIFO:
        constexpr uint32_t VPWFF = (1U << 3);  ///< Video mode payload write FIFO full This bit indicates the full status of the video mode write payload FIFO:
        constexpr uint32_t ACWFE = (1U << 4);  ///< Adapted command mode command write FIFO empty This bit indicates the empty status of the adapted command mode write command FIFO:
        constexpr uint32_t ACWFF = (1U << 5);  ///< Adapted command mode command write FIFO full This bit indicates the full status of the adapted command mode write command FIFO:
        constexpr uint32_t APWFE = (1U << 6);  ///< Adapted command mode payload write FIFO empty This bit indicates the empty status of the adapted command mode write payload FIFO:
        constexpr uint32_t APWFF = (1U << 7);  ///< Adapted command mode payload write FIFO full This bit indicates the full status of the adapted command mode write payload FIFO:
        constexpr uint32_t VPBE = (1U << 16);  ///< Video mode payload buffer empty This bit indicates the empty status of the video mode payload internal buffer:
        constexpr uint32_t VPBF = (1U << 17);  ///< Video mode payload buffer full This bit indicates the full status of the video mode payload internal buffer:
        constexpr uint32_t ACBE = (1U << 20);  ///< Adapted command mode command buffer empty This bit indicates the empty status of the adapted command mode command internal buffer:
        constexpr uint32_t ACBF = (1U << 21);  ///< Adapted command mode command buffer full This bit indicates the full status of the adapted command mode command internal buffer:
        constexpr uint32_t APBE = (1U << 22);  ///< Adapted command mode payload buffer empty This bit indicates the empty status of the adapted command mode payload internal buffer:
        constexpr uint32_t APBF = (1U << 23);  ///< Adapted command mode payload buffer full This bit indicates the full status of the adapted command mode payload internal buffer:
    }

    /// DSI_WCFGR Register bits
    namespace dsi_wcfgr_bits {
        constexpr uint32_t DSIM = (1U << 0);  ///< DSI mode This bit selects the mode for the video transmission. This bit must only be changed when DSI Host is stopped (DSI_CR.EN = 0).
        constexpr uint32_t COLMUX = (3 << 1);  ///< Color multiplexing This bit selects the color multiplexing used by DSI Host. This field must only be changed when DSI is stopped (DSI_WCR.DSIEN = 0 and DSI_CR.ENÂ =Â 0).
        constexpr uint32_t TESRC = (1U << 4);  ///< TE source This bit selects the tearing effect (TE) source. This bit must only be changed when DSI Host is stopped (DSI_CR.EN = 0).
        constexpr uint32_t TEPOL = (1U << 5);  ///< TE polarity This bit selects the polarity of the external pin tearing effect (TE) source. This bit must only be changed when DSI Host is stopped (DSI_CR.EN = 0).
        constexpr uint32_t AR = (1U << 6);  ///< Automatic refresh This bit selects the refresh mode in DBI mode. This bit must only be changed when DSI Host is stopped (DSI_CR.EN = 0).
        constexpr uint32_t VSPOL = (1U << 7);  ///< VSync polarity This bit selects the VSync edge on which the LTDC is halted. This bit must only be changed when DSI is stopped (DSI_WCR.DSIEN = 0 and DSI_CR.ENÂ =Â 0).
    }

    /// DSI_WCR Register bits
    namespace dsi_wcr_bits {
        constexpr uint32_t COLM = (1U << 0);  ///< Color mode This bit controls the display color mode in video mode.
        constexpr uint32_t SHTDN = (1U << 1);  ///< Shutdown This bit controls the display shutdown in video mode.
        constexpr uint32_t LTDCEN = (1U << 2);  ///< LTDC enable This bit enables the LTDC for a frame transfer in adapted command mode.
        constexpr uint32_t DSIEN = (1U << 3);  ///< DSI enable This bit enables the DSI Wrapper.
    }

    /// DSI_WIER Register bits
    namespace dsi_wier_bits {
        constexpr uint32_t TEIE = (1U << 0);  ///< Tearing effect interrupt enable This bit enables the tearing effect interrupt.
        constexpr uint32_t ERIE = (1U << 1);  ///< End of refresh interrupt enable This bit enables the end of refresh interrupt.
        constexpr uint32_t PLLLIE = (1U << 9);  ///< PLL lock interrupt enable This bit enables the PLL lock interrupt.
        constexpr uint32_t PLLUIE = (1U << 10);  ///< PLL unlock interrupt enable This bit enables the PLL unlock interrupt.
    }

    /// DSI_WISR Register bits
    namespace dsi_wisr_bits {
        constexpr uint32_t TEIF = (1U << 0);  ///< Tearing effect interrupt flag This bit is set when a tearing effect event occurs.
        constexpr uint32_t ERIF = (1U << 1);  ///< End of refresh interrupt flag This bit is set when the transfer of a frame in adapted command mode is finished.
        constexpr uint32_t BUSY = (1U << 2);  ///< Busy flag This bit is set when the transfer of a frame in adapted command mode is ongoing.
        constexpr uint32_t PLLLS = (1U << 8);  ///< PLL lock status This bit is set when the PLL is locked and cleared when it is unlocked.
        constexpr uint32_t PLLLIF = (1U << 9);  ///< PLL lock interrupt flag This bit is set when the PLL becomes locked.
        constexpr uint32_t PLLUIF = (1U << 10);  ///< PLL unlock interrupt flag This bit is set when the PLL becomes unlocked.
    }

    /// DSI_WIFCR Register bits
    namespace dsi_wifcr_bits {
        constexpr uint32_t CTEIF = (1U << 0);  ///< Clear tearing effect interrupt flag Write 1 clears the TEIF flag in the DSI_WSR register.
        constexpr uint32_t CERIF = (1U << 1);  ///< Clear end of refresh interrupt flag Write 1 clears the ERIF flag in the DSI_WSR register.
        constexpr uint32_t CPLLLIF = (1U << 9);  ///< Clear PLL lock interrupt flag Write 1 clears the PLLLIF flag in the DSI_WSR register.
        constexpr uint32_t CPLLUIF = (1U << 10);  ///< Clear PLL unlock interrupt flag Write 1 clears the PLLUIF flag in the DSI_WSR register.
    }

    /// DSI_WPCR0 Register bits
    namespace dsi_wpcr0_bits {
        constexpr uint32_t SWCL = (1U << 6);  ///< Swap clock lane pins This bit swaps the pins on clock lane.
        constexpr uint32_t SWDL0 = (1U << 7);  ///< Swap data lane 0 pins This bit swaps the pins on data lane 0.
        constexpr uint32_t SWDL1 = (1U << 8);  ///< Swap data lane 1 pins This bit swaps the pins on clock lane.
        constexpr uint32_t FTXSMCL = (1U << 12);  ///< Force in TX Stop mode the clock lane This bit forces the clock lane in TX stop mode. It is used to initialize a lane module in transmit mode. It causes the lane module to immediately jump to transmit control mode and to begin transmitting a stop state (LP-11). It can be used to go back in TX mode after a wrong BTA sequence.
        constexpr uint32_t FTXSMDL = (1U << 13);  ///< Force in TX Stop mode the data lanes This bit forces the data lanes in TX stop mode. It is used to initialize a lane module in transmit mode. It causes the lane module to immediately jump to transmit control mode and to begin transmitting a stop state (LP-11). It can be used to go back in TX mode after a wrong BTA sequence.
    }

    /// DSI_WRPCR Register bits
    namespace dsi_wrpcr_bits {
        constexpr uint32_t PLLEN = (1U << 0);  ///< PLL enable This bit enables the D-PHY PLL.
        constexpr uint32_t NDIV = (9 << 2);  ///< PLL loop division factor This field configures the PLL loop division factor. 2: PLL loop divided by 2x2 ... 511: PLL loop divided by 511x2
        constexpr uint32_t IDF = (9 << 11);  ///< PLL input division factor This field configures the PLL input division factor. 2: PLL input divided by 2 ... 511: PLL input divided by 511
        constexpr uint32_t ODF = (9 << 20);  ///< PLL output division factor This field configures the PLL output division factor. 2: PLL output divided by 2 ... 511: PLL output divided by 511
    }

    /// DSI_BCFGR Register bits
    namespace dsi_bcfgr_bits {
        constexpr uint32_t PWRUP = (1U << 6);  ///< Power-up This bit powers-up the reference bias for the MIPI D-PHY
    }

    /// DSI_DPCBCR Register bits
    namespace dsi_dpcbcr_bits {
        constexpr uint32_t BC = (5 << 3);  ///< Band control This field selects the frequency band used by the D-PHY. Others: Reserved
    }

    /// DSI_DPCSRCR Register bits
    namespace dsi_dpcsrcr_bits {
        constexpr uint32_t SRC = (8 << 0);  ///< Slew rate control This field selects the slew rate for HS-TX speed. Others: Reserved
    }

    /// DSI_DPDL0BCR Register bits
    namespace dsi_dpdl0bcr_bits {
        constexpr uint32_t BC = (5 << 0);  ///< Band control This field selects the frequency band used by the D-PHY. Others: Reserved
    }

    /// DSI_DPDL0SRCR Register bits
    namespace dsi_dpdl0srcr_bits {
        constexpr uint32_t SRC = (8 << 0);  ///< Slew rate control This field selects the slew rate for HS-TX speed. Others: Reserved
    }

    /// DSI_DPDL1BCR Register bits
    namespace dsi_dpdl1bcr_bits {
        constexpr uint32_t BC = (5 << 0);  ///< Band control This field selects the frequency band used by the D-PHY. Others: Reserved
    }

    /// DSI_DPDL1SRCR Register bits
    namespace dsi_dpdl1srcr_bits {
        constexpr uint32_t SRC = (8 << 0);  ///< Slew rate control This field selects the slew rate for HS-TX speed. Others: Reserved
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x46022000;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t EXTI_RTSR1;  ///< Offset: 0x00 - EXTI rising trigger selection register
        volatile uint32_t EXTI_FTSR1;  ///< Offset: 0x04 - EXTI falling trigger selection register
        volatile uint32_t EXTI_SWIER1;  ///< Offset: 0x08 - EXTI software interrupt event register
        volatile uint32_t EXTI_RPR1;  ///< Offset: 0x0C - EXTI rising edge pending register
        volatile uint32_t EXTI_FPR1;  ///< Offset: 0x10 - EXTI falling edge pending register
        volatile uint32_t EXTI_SECCFGR1;  ///< Offset: 0x14 - EXTI security configuration register
        volatile uint32_t EXTI_PRIVCFGR1;  ///< Offset: 0x18 - EXTI privilege configuration register
        volatile uint32_t EXTI_EXTICR1;  ///< Offset: 0x60 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR2;  ///< Offset: 0x64 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR3;  ///< Offset: 0x68 - EXTI external interrupt selection register
        volatile uint32_t EXTI_EXTICR4;  ///< Offset: 0x6C - EXTI external interrupt selection register
        volatile uint32_t EXTI_LOCKR;  ///< Offset: 0x70 - EXTI lock register
        volatile uint32_t EXTI_IMR1;  ///< Offset: 0x80 - EXTI CPU wake-up with interrupt mask register
        volatile uint32_t EXTI_EMR1;  ///< Offset: 0x84 - EXTI CPU wake-up with event mask register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// EXTI_RTSR1 Register bits
    namespace exti_rtsr1_bits {
        constexpr uint32_t RT0 = (1U << 0);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT1 = (1U << 1);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT2 = (1U << 2);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT3 = (1U << 3);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT4 = (1U << 4);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT5 = (1U << 5);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT6 = (1U << 6);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT7 = (1U << 7);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT8 = (1U << 8);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT9 = (1U << 9);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT10 = (1U << 10);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT11 = (1U << 11);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT12 = (1U << 12);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT13 = (1U << 13);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT14 = (1U << 14);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT15 = (1U << 15);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT16 = (1U << 16);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT17 = (1U << 17);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT18 = (1U << 18);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT19 = (1U << 19);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT20 = (1U << 20);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT21 = (1U << 21);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT22 = (1U << 22);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT23 = (1U << 23);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT24 = (1U << 24);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RT25 = (1U << 25);  ///< Rising trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0. Note: RT25, RT24, and RT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_FTSR1 Register bits
    namespace exti_ftsr1_bits {
        constexpr uint32_t FT0 = (1U << 0);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT1 = (1U << 1);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT2 = (1U << 2);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT3 = (1U << 3);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT4 = (1U << 4);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT5 = (1U << 5);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT6 = (1U << 6);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT7 = (1U << 7);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT8 = (1U << 8);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT9 = (1U << 9);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT10 = (1U << 10);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT11 = (1U << 11);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT12 = (1U << 12);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT13 = (1U << 13);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT14 = (1U << 14);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT15 = (1U << 15);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT16 = (1U << 16);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT17 = (1U << 17);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT18 = (1U << 18);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT19 = (1U << 19);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT20 = (1U << 20);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT21 = (1U << 21);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT22 = (1U << 22);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT23 = (1U << 23);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT24 = (1U << 24);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FT25 = (1U << 25);  ///< Falling trigger event configuration bit of configurable event input x When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0. Note: FT25, FT24, and FT23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_SWIER1 Register bits
    namespace exti_swier1_bits {
        constexpr uint32_t SWI0 = (1U << 0);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI1 = (1U << 1);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI2 = (1U << 2);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI3 = (1U << 3);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI4 = (1U << 4);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI5 = (1U << 5);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI6 = (1U << 6);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI7 = (1U << 7);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI8 = (1U << 8);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI9 = (1U << 9);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI10 = (1U << 10);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI11 = (1U << 11);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI12 = (1U << 12);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI13 = (1U << 13);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI14 = (1U << 14);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI15 = (1U << 15);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI16 = (1U << 16);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI17 = (1U << 17);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI18 = (1U << 18);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI19 = (1U << 19);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI20 = (1U << 20);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI21 = (1U << 21);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI22 = (1U << 22);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI23 = (1U << 23);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI24 = (1U << 24);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SWI25 = (1U << 25);  ///< Software interrupt on event x When EXTI_SECCFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0. A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read. Note: SW25, SW24, and SW23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_RPR1 Register bits
    namespace exti_rpr1_bits {
        constexpr uint32_t RPIF0 = (1U << 0);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF1 = (1U << 1);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF2 = (1U << 2);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF3 = (1U << 3);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF4 = (1U << 4);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF5 = (1U << 5);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF6 = (1U << 6);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF7 = (1U << 7);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF8 = (1U << 8);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF9 = (1U << 9);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF10 = (1U << 10);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF11 = (1U << 11);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF12 = (1U << 12);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF13 = (1U << 13);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF14 = (1U << 14);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF15 = (1U << 15);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF16 = (1U << 16);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF17 = (1U << 17);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF18 = (1U << 18);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF19 = (1U << 19);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF20 = (1U << 20);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF21 = (1U << 21);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF22 = (1U << 22);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF23 = (1U << 23);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF24 = (1U << 24);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t RPIF25 = (1U << 25);  ///< configurable event inputs x rising edge pending bit When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0. This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it. RPIF25, RPIF24, and RPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. Note: If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_FPR1 Register bits
    namespace exti_fpr1_bits {
        constexpr uint32_t FPIF0 = (1U << 0);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF1 = (1U << 1);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF2 = (1U << 2);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF3 = (1U << 3);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF4 = (1U << 4);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF5 = (1U << 5);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF6 = (1U << 6);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF7 = (1U << 7);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF8 = (1U << 8);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF9 = (1U << 9);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF10 = (1U << 10);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF11 = (1U << 11);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF12 = (1U << 12);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF13 = (1U << 13);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF14 = (1U << 14);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF15 = (1U << 15);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF16 = (1U << 16);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF17 = (1U << 17);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF18 = (1U << 18);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF19 = (1U << 19);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF20 = (1U << 20);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF21 = (1U << 21);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF22 = (1U << 22);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF23 = (1U << 23);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF24 = (1U << 24);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t FPIF25 = (1U << 25);  ///< configurable event inputs x falling edge pending bit When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access. When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0. This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it. Note: FPIF25, FPIF24, and FPIF23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_SECCFGR1 Register bits
    namespace exti_seccfgr1_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC1 = (1U << 1);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC2 = (1U << 2);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC3 = (1U << 3);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC4 = (1U << 4);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC5 = (1U << 5);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC6 = (1U << 6);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC7 = (1U << 7);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC8 = (1U << 8);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC9 = (1U << 9);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC10 = (1U << 10);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC11 = (1U << 11);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC12 = (1U << 12);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC13 = (1U << 13);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC14 = (1U << 14);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC15 = (1U << 15);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC16 = (1U << 16);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC17 = (1U << 17);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC18 = (1U << 18);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC19 = (1U << 19);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC20 = (1U << 20);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC21 = (1U << 21);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC22 = (1U << 22);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC23 = (1U << 23);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC24 = (1U << 24);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t SEC25 = (1U << 25);  ///< Security enable on event input x When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded. Note: SEC25, SEC24, and SEC23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_PRIVCFGR1 Register bits
    namespace exti_privcfgr1_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV1 = (1U << 1);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV2 = (1U << 2);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV3 = (1U << 3);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV4 = (1U << 4);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV5 = (1U << 5);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV6 = (1U << 6);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV7 = (1U << 7);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV8 = (1U << 8);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV9 = (1U << 9);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV10 = (1U << 10);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV11 = (1U << 11);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV12 = (1U << 12);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV13 = (1U << 13);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV14 = (1U << 14);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV15 = (1U << 15);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV16 = (1U << 16);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV17 = (1U << 17);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV18 = (1U << 18);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV19 = (1U << 19);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV20 = (1U << 20);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV21 = (1U << 21);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV22 = (1U << 22);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV23 = (1U << 23);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV24 = (1U << 24);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t PRIV25 = (1U << 25);  ///< Security enable on event input x When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access. When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded. Note: PRIV25, PRIV24, and PRIV23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_EXTICR1 Register bits
    namespace exti_exticr1_bits {
        constexpr uint32_t EXTI0 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI1 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI2 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI3 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR2 Register bits
    namespace exti_exticr2_bits {
        constexpr uint32_t EXTI4 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI5 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI6 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI7 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR3 Register bits
    namespace exti_exticr3_bits {
        constexpr uint32_t EXTI8 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI9 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI10 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI11 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_EXTICR4 Register bits
    namespace exti_exticr4_bits {
        constexpr uint32_t EXTI12 = (8 << 0);  ///< EXTIm GPIO port selection
        constexpr uint32_t EXTI13 = (8 << 8);  ///< EXTIm+1 GPIO port selection
        constexpr uint32_t EXTI14 = (8 << 16);  ///< EXTIm+2 GPIO port selection
        constexpr uint32_t EXTI15 = (8 << 24);  ///< EXTIm+3 GPIO port selection
    }

    /// EXTI_LOCKR Register bits
    namespace exti_lockr_bits {
        constexpr uint32_t LOCK = (1U << 0);  ///< Global security and privilege configuration registers (EXTI_SECCFGR and EXTI_PRIVCFGR) lock This bit is written once after reset.
    }

    /// EXTI_IMR1 Register bits
    namespace exti_imr1_bits {
        constexpr uint32_t IM0 = (1U << 0);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM1 = (1U << 1);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM2 = (1U << 2);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM3 = (1U << 3);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM4 = (1U << 4);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM5 = (1U << 5);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM6 = (1U << 6);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM7 = (1U << 7);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM8 = (1U << 8);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM9 = (1U << 9);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM10 = (1U << 10);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM11 = (1U << 11);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM12 = (1U << 12);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM13 = (1U << 13);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM14 = (1U << 14);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM15 = (1U << 15);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM16 = (1U << 16);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM17 = (1U << 17);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM18 = (1U << 18);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM19 = (1U << 19);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM20 = (1U << 20);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM21 = (1U << 21);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM22 = (1U << 22);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM23 = (1U << 23);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM24 = (1U << 24);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t IM25 = (1U << 25);  ///< CPU wake-up with interrupt mask on event input x When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: IM25, IM24, and IM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

    /// EXTI_EMR1 Register bits
    namespace exti_emr1_bits {
        constexpr uint32_t EM0 = (1U << 0);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM1 = (1U << 1);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM2 = (1U << 2);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM3 = (1U << 3);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM4 = (1U << 4);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM5 = (1U << 5);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM6 = (1U << 6);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM7 = (1U << 7);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM8 = (1U << 8);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM9 = (1U << 9);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM10 = (1U << 10);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM11 = (1U << 11);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM12 = (1U << 12);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM13 = (1U << 13);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM14 = (1U << 14);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM15 = (1U << 15);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM16 = (1U << 16);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM17 = (1U << 17);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM18 = (1U << 18);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM19 = (1U << 19);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM20 = (1U << 20);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM21 = (1U << 21);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM22 = (1U << 22);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM23 = (1U << 23);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM24 = (1U << 24);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
        constexpr uint32_t EM25 = (1U << 25);  ///< CPU wake-up with event generation mask on event input x When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access. When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0. When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access. When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded. Note: EM25, EM24, and EM23 bits are only available on some devices in the STM32U5 Series. Refer to the EXTI line connections table for its availability. If not present, consider this bit as reserved and keep at reset value.
    }

}

// ============================================================================
// CAN Peripheral
// ============================================================================

namespace can {
    /// Base addresses
    constexpr uint32_t FDCAN1_RAM_BASE = 0x4000AC00;
    constexpr uint32_t SEC_FDCAN1_RAM_BASE = 0x5000AC00;
    constexpr uint32_t FDCAN1_BASE = 0x4000A400;
    constexpr uint32_t SEC_FDCAN1_BASE = 0x5000A400;

    /// CAN Register structure
    struct Registers {
        volatile uint32_t FDCAN_CREL;  ///< Offset: 0x00 - FDCAN Core Release Register
        volatile uint32_t FDCAN_ENDN;  ///< Offset: 0x04 - FDCAN endian register
        volatile uint32_t FDCAN_DBTP;  ///< Offset: 0x0C - FDCAN Data Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TEST;  ///< Offset: 0x10 - FDCAN Test Register
        volatile uint32_t FDCAN_RWD;  ///< Offset: 0x14 - FDCAN RAM Watchdog Register
        volatile uint32_t FDCAN_CCCR;  ///< Offset: 0x18 - FDCAN CC Control Register
        volatile uint32_t FDCAN_NBTP;  ///< Offset: 0x1C - FDCAN Nominal Bit Timing and Prescaler Register
        volatile uint32_t FDCAN_TSCC;  ///< Offset: 0x20 - FDCAN Timestamp Counter Configuration Register
        volatile uint32_t FDCAN_TSCV;  ///< Offset: 0x24 - FDCAN Timestamp Counter Value Register
        volatile uint32_t FDCAN_TOCC;  ///< Offset: 0x28 - FDCAN Timeout Counter Configuration Register
        volatile uint32_t FDCAN_TOCV;  ///< Offset: 0x2C - FDCAN Timeout Counter Value Register
        volatile uint32_t FDCAN_ECR;  ///< Offset: 0x40 - FDCAN Error Counter Register
        volatile uint32_t FDCAN_PSR;  ///< Offset: 0x44 - FDCAN Protocol Status Register
        volatile uint32_t FDCAN_TDCR;  ///< Offset: 0x48 - FDCAN Transmitter Delay Compensation Register
        volatile uint32_t FDCAN_IR;  ///< Offset: 0x50 - FDCAN Interrupt Register
        volatile uint32_t FDCAN_IE;  ///< Offset: 0x54 - FDCAN Interrupt Enable Register
        volatile uint32_t FDCAN_ILS;  ///< Offset: 0x58 - FDCAN Interrupt Line Select Register
        volatile uint32_t FDCAN_ILE;  ///< Offset: 0x5C - FDCAN Interrupt Line Enable Register
        volatile uint32_t FDCAN_RXGFC;  ///< Offset: 0x80 - FDCAN Global Filter Configuration Register
        volatile uint32_t FDCAN_XIDAM;  ///< Offset: 0x84 - FDCAN Extended ID and Mask Register
        volatile uint32_t FDCAN_HPMS;  ///< Offset: 0x88 - FDCAN High Priority Message Status Register
        volatile uint32_t FDCAN_RXF0S;  ///< Offset: 0x90 - FDCAN Rx FIFO 0 Status Register
        volatile uint32_t FDCAN_RXF0A;  ///< Offset: 0x94 - CAN Rx FIFO 0 Acknowledge Register
        volatile uint32_t FDCAN_RXF1S;  ///< Offset: 0x98 - FDCAN Rx FIFO 1 Status Register
        volatile uint32_t FDCAN_RXF1A;  ///< Offset: 0x9C - FDCAN Rx FIFO 1 Acknowledge Register
        volatile uint32_t FDCAN_TXBC;  ///< Offset: 0xC0 - FDCAN Tx buffer configuration register
        volatile uint32_t FDCAN_TXFQS;  ///< Offset: 0xC4 - FDCAN Tx FIFO/Queue Status Register
        volatile uint32_t FDCAN_TXBRP;  ///< Offset: 0xC8 - FDCAN Tx Buffer Request Pending Register
        volatile uint32_t FDCAN_TXBAR;  ///< Offset: 0xCC - FDCAN Tx Buffer Add Request Register
        volatile uint32_t FDCAN_TXBCR;  ///< Offset: 0xD0 - FDCAN Tx Buffer Cancellation Request Register
        volatile uint32_t FDCAN_TXBTO;  ///< Offset: 0xD4 - FDCAN Tx Buffer Transmission Occurred Register
        volatile uint32_t FDCAN_TXBCF;  ///< Offset: 0xD8 - FDCAN Tx Buffer Cancellation Finished Register
        volatile uint32_t FDCAN_TXBTIE;  ///< Offset: 0xDC - FDCAN Tx Buffer Transmission Interrupt Enable Register
        volatile uint32_t FDCAN_TXBCIE;  ///< Offset: 0xE0 - FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
        volatile uint32_t FDCAN_TXEFS;  ///< Offset: 0xE4 - FDCAN Tx Event FIFO Status Register
        volatile uint32_t FDCAN_TXEFA;  ///< Offset: 0xE8 - FDCAN Tx Event FIFO Acknowledge Register
        volatile uint32_t FDCAN_CKDIV;  ///< Offset: 0x100 - FDCAN CFG clock divider register
    };

    /// Peripheral instances
    inline Registers* FDCAN1_RAM = reinterpret_cast<Registers*>(FDCAN1_RAM_BASE);
    inline Registers* SEC_FDCAN1_RAM = reinterpret_cast<Registers*>(SEC_FDCAN1_RAM_BASE);
    inline Registers* FDCAN1 = reinterpret_cast<Registers*>(FDCAN1_BASE);
    inline Registers* SEC_FDCAN1 = reinterpret_cast<Registers*>(SEC_FDCAN1_BASE);

    // Bit definitions
    /// FDCAN_CREL Register bits
    namespace fdcan_crel_bits {
        constexpr uint32_t REL = (4 << 28);  ///< Core release
        constexpr uint32_t STEP = (4 << 24);  ///< Step of Core release
        constexpr uint32_t SUBSTEP = (4 << 20);  ///< Sub-step of Core release
        constexpr uint32_t YEAR = (4 << 16);  ///< Timestamp Year
        constexpr uint32_t MON = (8 << 8);  ///< Timestamp Month
        constexpr uint32_t DAY = (8 << 0);  ///< Timestamp Day
    }

    /// FDCAN_ENDN Register bits
    namespace fdcan_endn_bits {
        constexpr uint32_t ETV = (32 << 0);  ///< Endiannes Test Value
    }

    /// FDCAN_DBTP Register bits
    namespace fdcan_dbtp_bits {
        constexpr uint32_t DSJW = (4 << 0);  ///< Synchronization Jump Width
        constexpr uint32_t DTSEG2 = (4 << 4);  ///< Data time segment after sample point
        constexpr uint32_t DTSEG1 = (5 << 8);  ///< Data time segment after sample point
        constexpr uint32_t DBRP = (5 << 16);  ///< Data BIt Rate Prescaler
        constexpr uint32_t TDC = (1U << 23);  ///< Transceiver Delay Compensation
    }

    /// FDCAN_TEST Register bits
    namespace fdcan_test_bits {
        constexpr uint32_t LBCK = (1U << 4);  ///< Loop Back mode
        constexpr uint32_t TX = (2 << 5);  ///< Loop Back mode
        constexpr uint32_t RX = (1U << 7);  ///< Control of Transmit Pin
    }

    /// FDCAN_RWD Register bits
    namespace fdcan_rwd_bits {
        constexpr uint32_t WDV = (8 << 8);  ///< Watchdog value
        constexpr uint32_t WDC = (8 << 0);  ///< Watchdog configuration
    }

    /// FDCAN_CCCR Register bits
    namespace fdcan_cccr_bits {
        constexpr uint32_t INIT = (1U << 0);  ///< Initialization
        constexpr uint32_t CCE = (1U << 1);  ///< Configuration Change Enable
        constexpr uint32_t ASM_ = (1U << 2);  ///< ASM Restricted Operation Mode (renamed from ASM_)
        constexpr uint32_t CSA = (1U << 3);  ///< Clock Stop Acknowledge
        constexpr uint32_t CSR = (1U << 4);  ///< Clock Stop Request
        constexpr uint32_t MON = (1U << 5);  ///< Bus Monitoring Mode
        constexpr uint32_t DAR = (1U << 6);  ///< Disable Automatic Retransmission
        constexpr uint32_t TEST = (1U << 7);  ///< Test Mode Enable
        constexpr uint32_t FDOE = (1U << 8);  ///< FD Operation Enable
        constexpr uint32_t BRSE = (1U << 9);  ///< FDCAN Bit Rate Switching
        constexpr uint32_t PXHD = (1U << 12);  ///< Protocol Exception Handling Disable
        constexpr uint32_t EFBI = (1U << 13);  ///< Edge Filtering during Bus Integration
        constexpr uint32_t TXP = (1U << 14);  ///< TXP
        constexpr uint32_t NISO = (1U << 15);  ///< Non ISO Operation
    }

    /// FDCAN_NBTP Register bits
    namespace fdcan_nbtp_bits {
        constexpr uint32_t NSJW = (7 << 25);  ///< Nominal (Re)Synchronization Jump Width
        constexpr uint32_t NBRP = (9 << 16);  ///< Bit Rate Prescaler
        constexpr uint32_t NTSEG1 = (8 << 8);  ///< Nominal Time segment before sample point
        constexpr uint32_t NTSEG2 = (7 << 0);  ///< Nominal Time segment after sample point
    }

    /// FDCAN_TSCC Register bits
    namespace fdcan_tscc_bits {
        constexpr uint32_t TCP = (4 << 16);  ///< Timestamp Counter Prescaler
        constexpr uint32_t TSS = (2 << 0);  ///< Timestamp Select
    }

    /// FDCAN_TSCV Register bits
    namespace fdcan_tscv_bits {
        constexpr uint32_t TSC = (16 << 0);  ///< Timestamp Counter
    }

    /// FDCAN_TOCC Register bits
    namespace fdcan_tocc_bits {
        constexpr uint32_t ETOC = (1U << 0);  ///< Enable Timeout Counter
        constexpr uint32_t TOS = (2 << 1);  ///< Timeout Select
        constexpr uint32_t TOP = (16 << 16);  ///< Timeout Period
    }

    /// FDCAN_TOCV Register bits
    namespace fdcan_tocv_bits {
        constexpr uint32_t TOC = (16 << 0);  ///< Timeout Counter
    }

    /// FDCAN_ECR Register bits
    namespace fdcan_ecr_bits {
        constexpr uint32_t CEL = (8 << 16);  ///< AN Error Logging
        constexpr uint32_t RP = (1U << 15);  ///< Receive Error Passive
        constexpr uint32_t REC = (7 << 8);  ///< Receive Error Counter
        constexpr uint32_t TEC = (8 << 0);  ///< Transmit Error Counter
    }

    /// FDCAN_PSR Register bits
    namespace fdcan_psr_bits {
        constexpr uint32_t LEC = (3 << 0);  ///< Last Error Code
        constexpr uint32_t ACT = (2 << 3);  ///< Activity
        constexpr uint32_t EP = (1U << 5);  ///< Error Passive
        constexpr uint32_t EW = (1U << 6);  ///< Warning Status
        constexpr uint32_t BO = (1U << 7);  ///< Bus_Off Status
        constexpr uint32_t DLEC = (3 << 8);  ///< Data Last Error Code
        constexpr uint32_t RESI = (1U << 11);  ///< ESI flag of last received FDCAN Message
        constexpr uint32_t RBRS = (1U << 12);  ///< BRS flag of last received FDCAN Message
        constexpr uint32_t REDL = (1U << 13);  ///< Received FDCAN Message
        constexpr uint32_t PXE = (1U << 14);  ///< Protocol Exception Event
        constexpr uint32_t TDCV = (7 << 16);  ///< Transmitter Delay Compensation Value
    }

    /// FDCAN_TDCR Register bits
    namespace fdcan_tdcr_bits {
        constexpr uint32_t TDCF = (7 << 0);  ///< Transmitter Delay Compensation Filter Window Length
        constexpr uint32_t TDCO = (7 << 8);  ///< Transmitter Delay Compensation Offset
    }

    /// FDCAN_IR Register bits
    namespace fdcan_ir_bits {
        constexpr uint32_t RF0N = (1U << 0);  ///< RF0N
        constexpr uint32_t RF0F = (1U << 1);  ///< RF0F
        constexpr uint32_t RF0L = (1U << 2);  ///< RF0L
        constexpr uint32_t RF1N = (1U << 3);  ///< RF1N
        constexpr uint32_t RF1F = (1U << 4);  ///< RF1F
        constexpr uint32_t RF1L = (1U << 5);  ///< RF1L
        constexpr uint32_t HPM = (1U << 6);  ///< HPM
        constexpr uint32_t TC = (1U << 7);  ///< TC
        constexpr uint32_t TCF = (1U << 8);  ///< TCF
        constexpr uint32_t TFE = (1U << 9);  ///< TFE
        constexpr uint32_t TEFN = (1U << 10);  ///< TEFN
        constexpr uint32_t TEFF = (1U << 11);  ///< TEFF
        constexpr uint32_t TEFL = (1U << 12);  ///< TEFL
        constexpr uint32_t TSW = (1U << 13);  ///< TSW
        constexpr uint32_t MRAF = (1U << 14);  ///< MRAF
        constexpr uint32_t TOO = (1U << 15);  ///< TOO
        constexpr uint32_t ELO = (1U << 16);  ///< ELO
        constexpr uint32_t EP = (1U << 17);  ///< EP
        constexpr uint32_t EW = (1U << 18);  ///< EW
        constexpr uint32_t BO = (1U << 19);  ///< BO
        constexpr uint32_t WDI = (1U << 20);  ///< WDI
        constexpr uint32_t PEA = (1U << 21);  ///< PEA
        constexpr uint32_t PED = (1U << 22);  ///< PED
        constexpr uint32_t ARA = (1U << 23);  ///< ARA
    }

    /// FDCAN_IE Register bits
    namespace fdcan_ie_bits {
        constexpr uint32_t RF0NE = (1U << 0);  ///< Rx FIFO 0 New Message Enable
        constexpr uint32_t RF0FE = (1U << 1);  ///< Rx FIFO 0 Full Enable
        constexpr uint32_t RF0LE = (1U << 2);  ///< Rx FIFO 0 Message Lost Enable
        constexpr uint32_t RF1NE = (1U << 3);  ///< Rx FIFO 1 New Message Enable
        constexpr uint32_t RF1FE = (1U << 4);  ///< Rx FIFO 1 Watermark Reached Enable
        constexpr uint32_t RF1LE = (1U << 5);  ///< Rx FIFO 1 Message Lost Enable
        constexpr uint32_t HPME = (1U << 6);  ///< High Priority Message Enable
        constexpr uint32_t TCE = (1U << 7);  ///< Transmission Completed Enable
        constexpr uint32_t TCFE = (1U << 8);  ///< Transmission Cancellation Finished Enable
        constexpr uint32_t TEFE = (1U << 9);  ///< Tx FIFO Empty Enable
        constexpr uint32_t TEFNE = (1U << 10);  ///< Tx Event FIFO New Entry Enable
        constexpr uint32_t TEFFE = (1U << 11);  ///< Tx Event FIFO Full Enable
        constexpr uint32_t TEFLE = (1U << 12);  ///< Tx Event FIFO Element Lost Enable
        constexpr uint32_t TSWE = (1U << 13);  ///< TSWE
        constexpr uint32_t MRAFE = (1U << 14);  ///< Message RAM Access Failure Enable
        constexpr uint32_t TOOE = (1U << 15);  ///< Timeout Occurred Enable
        constexpr uint32_t ELOE = (1U << 16);  ///< Error Logging Overflow Enable
        constexpr uint32_t EPE = (1U << 17);  ///< Error Passive Enable
        constexpr uint32_t EWE = (1U << 18);  ///< Warning Status Enable
        constexpr uint32_t BOE = (1U << 19);  ///< Bus_Off Status Enable
        constexpr uint32_t WDIE = (1U << 20);  ///< Watchdog Interrupt Enable
        constexpr uint32_t PEAE = (1U << 21);  ///< Protocol Error in Arbitration Phase Enable
        constexpr uint32_t PEDE = (1U << 22);  ///< Protocol Error in Data Phase Enable
        constexpr uint32_t ARAE = (1U << 23);  ///< Access to Reserved Address Enable
    }

    /// FDCAN_ILS Register bits
    namespace fdcan_ils_bits {
        constexpr uint32_t RxFIFO0 = (1U << 0);  ///< RxFIFO0
        constexpr uint32_t RxFIFO1 = (1U << 1);  ///< RxFIFO1
        constexpr uint32_t SMSG = (1U << 2);  ///< SMSG
        constexpr uint32_t TFERR = (1U << 3);  ///< TFERR
        constexpr uint32_t MISC = (1U << 4);  ///< MISC
        constexpr uint32_t BERR = (1U << 5);  ///< BERR
        constexpr uint32_t PERR = (1U << 6);  ///< PERR
    }

    /// FDCAN_ILE Register bits
    namespace fdcan_ile_bits {
        constexpr uint32_t EINT0 = (1U << 0);  ///< Enable Interrupt Line 0
        constexpr uint32_t EINT1 = (1U << 1);  ///< Enable Interrupt Line 1
    }

    /// FDCAN_RXGFC Register bits
    namespace fdcan_rxgfc_bits {
        constexpr uint32_t RRFE = (1U << 0);  ///< Reject Remote Frames Extended
        constexpr uint32_t RRFS = (1U << 1);  ///< Reject Remote Frames Standard
        constexpr uint32_t ANFE = (2 << 2);  ///< Accept Non-matching Frames Extended
        constexpr uint32_t ANFS = (2 << 4);  ///< Accept Non-matching Frames Standard
        constexpr uint32_t F1OM = (1U << 8);  ///< F1OM
        constexpr uint32_t F0OM = (1U << 9);  ///< F0OM
        constexpr uint32_t LSS = (5 << 16);  ///< LSS
        constexpr uint32_t LSE = (4 << 24);  ///< LSE
    }

    /// FDCAN_XIDAM Register bits
    namespace fdcan_xidam_bits {
        constexpr uint32_t EIDM = (29 << 0);  ///< Extended ID Mask
    }

    /// FDCAN_HPMS Register bits
    namespace fdcan_hpms_bits {
        constexpr uint32_t BIDX = (3 << 0);  ///< Buffer Index
        constexpr uint32_t MSI = (2 << 6);  ///< Message Storage Indicator
        constexpr uint32_t FIDX = (5 << 8);  ///< Filter Index
        constexpr uint32_t FLST = (1U << 15);  ///< Filter List
    }

    /// FDCAN_RXF0S Register bits
    namespace fdcan_rxf0s_bits {
        constexpr uint32_t F0FL = (4 << 0);  ///< Rx FIFO 0 Fill Level
        constexpr uint32_t F0GI = (2 << 8);  ///< Rx FIFO 0 Get Index
        constexpr uint32_t F0PI = (2 << 16);  ///< Rx FIFO 0 Put Index
        constexpr uint32_t F0F = (1U << 24);  ///< Rx FIFO 0 Full
        constexpr uint32_t RF0L = (1U << 25);  ///< Rx FIFO 0 Message Lost
    }

    /// FDCAN_RXF0A Register bits
    namespace fdcan_rxf0a_bits {
        constexpr uint32_t F0AI = (3 << 0);  ///< Rx FIFO 0 Acknowledge Index
    }

    /// FDCAN_RXF1S Register bits
    namespace fdcan_rxf1s_bits {
        constexpr uint32_t F1FL = (4 << 0);  ///< Rx FIFO 1 Fill Level
        constexpr uint32_t F1GI = (2 << 8);  ///< Rx FIFO 1 Get Index
        constexpr uint32_t F1PI = (2 << 16);  ///< Rx FIFO 1 Put Index
        constexpr uint32_t F1F = (1U << 24);  ///< Rx FIFO 1 Full
        constexpr uint32_t RF1L = (1U << 25);  ///< Rx FIFO 1 Message Lost
    }

    /// FDCAN_RXF1A Register bits
    namespace fdcan_rxf1a_bits {
        constexpr uint32_t F1AI = (3 << 0);  ///< Rx FIFO 1 Acknowledge Index
    }

    /// FDCAN_TXBC Register bits
    namespace fdcan_txbc_bits {
        constexpr uint32_t TFQM = (1U << 24);  ///< Tx FIFO/Queue Mode
    }

    /// FDCAN_TXFQS Register bits
    namespace fdcan_txfqs_bits {
        constexpr uint32_t TFFL = (3 << 0);  ///< Tx FIFO Free Level
        constexpr uint32_t TFGI = (2 << 8);  ///< TFGI
        constexpr uint32_t TFQPI = (2 << 16);  ///< Tx FIFO/Queue Put Index
        constexpr uint32_t TFQF = (1U << 21);  ///< Tx FIFO/Queue Full
    }

    /// FDCAN_TXBRP Register bits
    namespace fdcan_txbrp_bits {
        constexpr uint32_t TRP = (3 << 0);  ///< Transmission Request Pending
    }

    /// FDCAN_TXBAR Register bits
    namespace fdcan_txbar_bits {
        constexpr uint32_t AR = (3 << 0);  ///< Add Request
    }

    /// FDCAN_TXBCR Register bits
    namespace fdcan_txbcr_bits {
        constexpr uint32_t CR = (3 << 0);  ///< Cancellation Request
    }

    /// FDCAN_TXBTO Register bits
    namespace fdcan_txbto_bits {
        constexpr uint32_t TO = (3 << 0);  ///< Transmission Occurred.
    }

    /// FDCAN_TXBCF Register bits
    namespace fdcan_txbcf_bits {
        constexpr uint32_t CF = (3 << 0);  ///< Cancellation Finished
    }

    /// FDCAN_TXBTIE Register bits
    namespace fdcan_txbtie_bits {
        constexpr uint32_t TIE = (3 << 0);  ///< Transmission Interrupt Enable
    }

    /// FDCAN_TXBCIE Register bits
    namespace fdcan_txbcie_bits {
        constexpr uint32_t CFIE = (3 << 0);  ///< Cancellation Finished Interrupt Enable
    }

    /// FDCAN_TXEFS Register bits
    namespace fdcan_txefs_bits {
        constexpr uint32_t EFFL = (3 << 0);  ///< Event FIFO Fill Level
        constexpr uint32_t EFGI = (2 << 8);  ///< Event FIFO Get Index.
        constexpr uint32_t EFPI = (2 << 16);  ///< Event FIFO Put Index
        constexpr uint32_t EFF = (1U << 24);  ///< Event FIFO Full.
        constexpr uint32_t TEFL = (1U << 25);  ///< Tx Event FIFO Element Lost.
    }

    /// FDCAN_TXEFA Register bits
    namespace fdcan_txefa_bits {
        constexpr uint32_t EFAI = (2 << 0);  ///< Event FIFO Acknowledge Index
    }

    /// FDCAN_CKDIV Register bits
    namespace fdcan_ckdiv_bits {
        constexpr uint32_t PDIV = (4 << 0);  ///< PDIV
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x40022000;
    constexpr uint32_t SEC_FLASH_BASE = 0x50022000;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FLASH_ACR;  ///< Offset: 0x00 - FLASH access control register
        volatile uint32_t FLASH_NSKEYR;  ///< Offset: 0x08 - FLASH non-secure key register
        volatile uint32_t FLASH_SECKEYR;  ///< Offset: 0x0C - FLASH secure key register
        volatile uint32_t FLASH_OPTKEYR;  ///< Offset: 0x10 - FLASH option key register
        volatile uint32_t FLASH_PDKEY1R;  ///< Offset: 0x18 - FLASH bank 1 power-down key register
        volatile uint32_t FLASH_PDKEY2R;  ///< Offset: 0x1C - FLASH bank 2 power-down key register
        volatile uint32_t FLASH_NSSR;  ///< Offset: 0x20 - FLASH non-secure status register
        volatile uint32_t FLASH_SECSR;  ///< Offset: 0x24 - FLASH secure status register
        volatile uint32_t FLASH_NSCR;  ///< Offset: 0x28 - FLASH non-secure control register
        volatile uint32_t FLASH_SECCR;  ///< Offset: 0x2C - FLASH secure control register
        volatile uint32_t FLASH_ECCR;  ///< Offset: 0x30 - FLASH ECC register
        volatile uint32_t FLASH_OPSR;  ///< Offset: 0x34 - FLASH operation status register
        volatile uint32_t FLASH_OPTR;  ///< Offset: 0x40 - FLASH option register
        volatile uint32_t FLASH_NSBOOTADD0R;  ///< Offset: 0x44 - FLASH non-secure boot address 0 register
        volatile uint32_t FLASH_NSBOOTADD1R;  ///< Offset: 0x48 - FLASH non-secure boot address 1 register
        volatile uint32_t FLASH_SECBOOTADD0R;  ///< Offset: 0x4C - FLASH secure boot address 0 register
        volatile uint32_t FLASH_SECWM1R1;  ///< Offset: 0x50 - FLASH secure watermark1 register 1
        volatile uint32_t FLASH_SECWM1R2;  ///< Offset: 0x54 - FLASH secure watermark1 register 2
        volatile uint32_t FLASH_WRP1AR;  ///< Offset: 0x58 - FLASH WRP1 area A address register
        volatile uint32_t FLASH_WRP1BR;  ///< Offset: 0x5C - FLASH WRP1 area B address register
        volatile uint32_t FLASH_SECWM2R1;  ///< Offset: 0x60 - FLASH secure watermark2 register 1
        volatile uint32_t FLASH_SECWM2R2;  ///< Offset: 0x64 - FLASH secure watermark2 register 2
        volatile uint32_t FLASH_WRP2AR;  ///< Offset: 0x68 - FLASH WPR2 area A address register
        volatile uint32_t FLASH_WRP2BR;  ///< Offset: 0x6C - FLASH WPR2 area B address register
        volatile uint32_t FLASH_OEM1KEYR1;  ///< Offset: 0x70 - FLASH OEM1 key register 1
        volatile uint32_t FLASH_OEM1KEYR2;  ///< Offset: 0x74 - FLASH OEM1 key register 2
        volatile uint32_t FLASH_OEM2KEYR1;  ///< Offset: 0x78 - FLASH OEM2 key register 1
        volatile uint32_t FLASH_OEM2KEYR2;  ///< Offset: 0x7C - FLASH OEM2 key register 2
        volatile uint32_t FLASH_SEC1BBR1;  ///< Offset: 0x80 - FLASH secure block based bank 1 register 1
        volatile uint32_t FLASH_SEC1BBR2;  ///< Offset: 0x84 - FLASH secure block based bank 1 register 2
        volatile uint32_t FLASH_SEC1BBR3;  ///< Offset: 0x88 - FLASH secure block based bank 1 register 3
        volatile uint32_t FLASH_SEC1BBR4;  ///< Offset: 0x8C - FLASH secure block based bank 1 register 4
        volatile uint32_t FLASH_SEC1BBR5;  ///< Offset: 0x90 - FLASH secure block based bank 1 register 5
        volatile uint32_t FLASH_SEC1BBR6;  ///< Offset: 0x94 - FLASH secure block based bank 1 register 6
        volatile uint32_t FLASH_SEC1BBR7;  ///< Offset: 0x98 - FLASH secure block based bank 1 register 7
        volatile uint32_t FLASH_SEC1BBR8;  ///< Offset: 0x9C - FLASH secure block based bank 1 register 8
        volatile uint32_t FLASH_SEC2BBR1;  ///< Offset: 0xA0 - FLASH secure block based bank 2 register 1
        volatile uint32_t FLASH_SEC2BBR2;  ///< Offset: 0xA4 - FLASH secure block based bank 2 register 2
        volatile uint32_t FLASH_SEC2BBR3;  ///< Offset: 0xA8 - FLASH secure block based bank 2 register 3
        volatile uint32_t FLASH_SEC2BBR4;  ///< Offset: 0xAC - FLASH secure block based bank 2 register 4
        volatile uint32_t FLASH_SEC2BBR5;  ///< Offset: 0xB0 - FLASH secure block based bank 2 register 5
        volatile uint32_t FLASH_SEC2BBR6;  ///< Offset: 0xB4 - FLASH secure block based bank 2 register 6
        volatile uint32_t FLASH_SEC2BBR7;  ///< Offset: 0xB8 - FLASH secure block based bank 2 register 7
        volatile uint32_t FLASH_SEC2BBR8;  ///< Offset: 0xBC - FLASH secure block based bank 2 register 8
        volatile uint32_t FLASH_SECHDPCR;  ///< Offset: 0xC0 - FLASH secure HDP control register
        volatile uint32_t FLASH_PRIVCFGR;  ///< Offset: 0xC4 - FLASH privilege configuration register
        volatile uint32_t FLASH_PRIV1BBR1;  ///< Offset: 0xD0 - FLASH privilege block based bank 1 register 1
        volatile uint32_t FLASH_PRIV1BBR2;  ///< Offset: 0xD4 - FLASH privilege block based bank 1 register 2
        volatile uint32_t FLASH_PRIV1BBR3;  ///< Offset: 0xD8 - FLASH privilege block based bank 1 register 3
        volatile uint32_t FLASH_PRIV1BBR4;  ///< Offset: 0xDC - FLASH privilege block based bank 1 register 4
        volatile uint32_t FLASH_PRIV1BBR5;  ///< Offset: 0xE0 - FLASH privilege block based bank 1 register 5
        volatile uint32_t FLASH_PRIV1BBR6;  ///< Offset: 0xE4 - FLASH privilege block based bank 1 register 6
        volatile uint32_t FLASH_PRIV1BBR7;  ///< Offset: 0xE8 - FLASH privilege block based bank 1 register 7
        volatile uint32_t FLASH_PRIV1BBR8;  ///< Offset: 0xEC - FLASH privilege block based bank 1 register 8
        volatile uint32_t FLASH_PRIV2BBR1;  ///< Offset: 0xF0 - FLASH privilege block based bank 2 register 1
        volatile uint32_t FLASH_PRIV2BBR2;  ///< Offset: 0xF4 - FLASH privilege block based bank 2 register 2
        volatile uint32_t FLASH_PRIV2BBR3;  ///< Offset: 0xF8 - FLASH privilege block based bank 2 register 3
        volatile uint32_t FLASH_PRIV2BBR4;  ///< Offset: 0xFC - FLASH privilege block based bank 2 register 4
        volatile uint32_t FLASH_PRIV2BBR5;  ///< Offset: 0x100 - FLASH privilege block based bank 2 register 5
        volatile uint32_t FLASH_PRIV2BBR6;  ///< Offset: 0x104 - FLASH privilege block based bank 2 register 6
        volatile uint32_t FLASH_PRIV2BBR7;  ///< Offset: 0x108 - FLASH privilege block based bank 2 register 7
        volatile uint32_t FLASH_PRIV2BBR8;  ///< Offset: 0x10C - FLASH privilege block based bank 2 register 8
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);
    inline Registers* SEC_FLASH = reinterpret_cast<Registers*>(SEC_FLASH_BASE);

    // Bit definitions
    /// FLASH_ACR Register bits
    namespace flash_acr_bits {
        constexpr uint32_t LATENCY = (4 << 0);  ///< Latency These bits represent the ratio between the HCLK (AHB clock) period and the Flash memory access time. ...
        constexpr uint32_t PRFTEN = (1U << 8);  ///< Prefetch enable This bit enables the prefetch buffer in the embedded Flash memory.
        constexpr uint32_t LPM = (1U << 11);  ///< Low-power read mode This bit puts the Flash memory in low-power read mode.
        constexpr uint32_t PDREQ1 = (1U << 12);  ///< Bank 1 power-down mode request This bit is write-protected with FLASH_PDKEY1R. This bit requests bank 1 to enter power-down mode. When bank 1 enters power-down mode, this bit is cleared by hardware and the PDKEY1R is locked.
        constexpr uint32_t PDREQ2 = (1U << 13);  ///< Bank 2 power-down mode request This bit is write-protected with FLASH_PDKEY2R. This bit requests bank 2 to enter power-down mode. When bank 2 enters power-down mode, this bit is cleared by hardware and the PDKEY2R is locked.
        constexpr uint32_t SLEEP_PD = (1U << 14);  ///< Flash memory power-down mode during Sleep mode This bit determines whether the Flash memory is in power-down mode or Idle mode when the device is in Sleep mode. The Flash must not be put in power-down while a program or an erase operation is on-going.
    }

    /// FLASH_NSKEYR Register bits
    namespace flash_nskeyr_bits {
        constexpr uint32_t NSKEY = (32 << 0);  ///< Flash memory non-secure key The following values must be written consecutively to unlock the FLASH_NSCR register, allowing the Flash memory non-secure programming/erasing operations: KEY1: 0x4567 0123 KEY2: 0xCDEF 89AB
    }

    /// FLASH_SECKEYR Register bits
    namespace flash_seckeyr_bits {
        constexpr uint32_t SECKEY = (32 << 0);  ///< Flash memory secure key The following values must be written consecutively to unlock the FLASH_SECCR register, allowing the Flash memory secure programming/erasing operations: KEY1: 0x4567 0123 KEY2: 0xCDEF 89AB
    }

    /// FLASH_OPTKEYR Register bits
    namespace flash_optkeyr_bits {
        constexpr uint32_t OPTKEY = (32 << 0);  ///< Option byte key The following values must be written consecutively to unlock the FLASH_OPTR register allowing option byte programming/erasing operations: KEY1: 0x0819 2A3B KEY2: 0x4C5D 6E7F
    }

    /// FLASH_PDKEY1R Register bits
    namespace flash_pdkey1r_bits {
        constexpr uint32_t PDKEY1 = (32 << 0);  ///< Bank 1 power-down key The following values must be written consecutively to unlock the PDREQ1 bit in FLASH_ACR: PDKEY1_1: 0x0415 2637 PDKEY1_2: 0xFAFB FCFD
    }

    /// FLASH_PDKEY2R Register bits
    namespace flash_pdkey2r_bits {
        constexpr uint32_t PDKEY2 = (32 << 0);  ///< Bank 2 power-down key The following values must be written consecutively to unlock the PDREQ2 bit in FLASH_ACR: PDKEY2_1: 0x4051 6273 PDKEY2_2: 0xAFBF CFDF
    }

    /// FLASH_NSSR Register bits
    namespace flash_nssr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< Non-secure end of operation This bit is set by hardware when one or more Flash memory non-secure operation (program/erase) has been completed successfully. This bit is set only if the non-secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_NSCR). This bit is cleared by writing 1.
        constexpr uint32_t OPERR = (1U << 1);  ///< Non-secure operation error This bit is set by hardware when a Flash memory non-secure operation (program/erase) completes unsuccessfully. This bit is set only if non-secure error interrupts are enabled (NSERRIE = 1). This bit is cleared by writing 1.
        constexpr uint32_t PROGERR = (1U << 3);  ///< Non-secure programming error This bit is set by hardware when a non-secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1.
        constexpr uint32_t WRPERR = (1U << 4);  ///< Non-secure write protection error This bit is set by hardware when an non-secure address to be erased/programmed belongs to a write-protected part (by WRP, PCROP, HDP or RDP level 1) of the Flash memory. This bit is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t PGAERR = (1U << 5);  ///< Non-secure programming alignment error This bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address. This bit is cleared by writing 1.
        constexpr uint32_t SIZERR = (1U << 6);  ///< Non-secure size error This bit is set by hardware when the size of the access is a byte or half-word during a non-secure program sequence. Only quad-word programming is allowed by means of successive word accesses. This bit is cleared by writing 1.
        constexpr uint32_t PGSERR = (1U << 7);  ///< Non-secure programming sequence error This bit is set by hardware when programming sequence is not correct. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t OPTWERR = (1U << 13);  ///< Option write error This bit is set by hardware when the options bytes are written with an invalid configuration. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t BSY = (1U << 16);  ///< Non-secure busy This indicates that a Flash memory secure or non-secure operation is in progress. This bit is set at the beginning of a Flash operation and reset when the operation finishes or when an error occurs.
        constexpr uint32_t WDW = (1U << 17);  ///< Non-secure wait data to write This bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory.
        constexpr uint32_t OEM1LOCK = (1U << 18);  ///< OEM1 lock This bit indicates that the OEM1 RDP key read during the OBL is not virgin. When set, the OEM1 RDP lock mechanism is active.
        constexpr uint32_t OEM2LOCK = (1U << 19);  ///< OEM2 lock This bit indicates that the OEM2 RDP key read during the OBL is not virgin. When set, the OEM2 RDP lock mechanism is active.
        constexpr uint32_t PD1 = (1U << 20);  ///< Bank 1 in power-down mode This bit indicates that the Flash memory bank 1 is in power-down state. It is reset when bank 1 is in normal mode or being awaken.
        constexpr uint32_t PD2 = (1U << 21);  ///< Bank 2 in power-down mode This bit indicates that the Flash memory bank 2 is in power-down state. It is reset when bank 2 is in normal mode or being awaken.
    }

    /// FLASH_SECSR Register bits
    namespace flash_secsr_bits {
        constexpr uint32_t EOP = (1U << 0);  ///< Secure end of operation This bit is set by hardware when one or more Flash memory secure operation (program/erase) has been completed successfully. This bit is set only if the secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_SECCR). This bit is cleared by writing 1.
        constexpr uint32_t OPERR = (1U << 1);  ///< Secure operation error This bit is set by hardware when a Flash memory secure operation (program/erase) completes unsuccessfully. This bit is set only if secure error interrupts are enabled (SECERRIE = 1). This bit is cleared by writing 1.
        constexpr uint32_t PROGERR = (1U << 3);  ///< Secure programming error This bit is set by hardware when a secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1.
        constexpr uint32_t WRPERR = (1U << 4);  ///< Secure write protection error This bit is set by hardware when an secure address to be erased/programmed belongs to a write-protected part (by WRP, PCROP, HDP or RDP level 1) of the Flash memory.This bit is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t PGAERR = (1U << 5);  ///< Secure programming alignment error This bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address.This bit is cleared by writing 1.
        constexpr uint32_t SIZERR = (1U << 6);  ///< Secure size error This bit is set by hardware when the size of the access is a byte or half-word during a secure program sequence. Only quad-word programming is allowed by means of successive word accesses.This bit is cleared by writing 1.
        constexpr uint32_t PGSERR = (1U << 7);  ///< Secure programming sequence error This bit is set by hardware when programming sequence is not correct. It is cleared by writing 1. Refer to for full conditions of error flag setting.
        constexpr uint32_t RDERR = (1U << 14);  ///< Secure readout protection error This bit is set by hardware when a read access is performed to a secure PCROP area and when a cacheable fetch access is performed to a secure PCROP area. An interrupt is generated if RDERRIE is set in FLASH_SECCR register. This bit is cleared by writing 1.
        constexpr uint32_t BSY = (1U << 16);  ///< Secure busy This bit indicates that a Flash memory secure or non-secure operation is in progress. This is set on the beginning of a Flash operation and reset when the operation finishes or when an error occurs.
        constexpr uint32_t WDW = (1U << 17);  ///< Secure wait data to write This bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory.
    }

    /// FLASH_NSCR Register bits
    namespace flash_nscr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Non-secure programming
        constexpr uint32_t PER = (1U << 1);  ///< Non-secure page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Non-secure bank 1 mass erase This bit triggers the bank 1 non-secure mass erase (all bank 1 user pages) when set.
        constexpr uint32_t PNB = (8 << 3);  ///< Non-secure page number selection These bits select the page to erase. ... ...
        constexpr uint32_t BKER = (1U << 11);  ///< Non-secure bank selection for page erase
        constexpr uint32_t BWR = (1U << 14);  ///< Non-secure burst write programming mode When set, this bit selects the burst write programming mode.
        constexpr uint32_t MER2 = (1U << 15);  ///< Non-secure bank 2 mass erase This bit triggers the bank 2 non-secure mass erase (all bank 2 user pages) when set.
        constexpr uint32_t STRT = (1U << 16);  ///< Non-secure start This bit triggers a non-secure erase operation when set. If MER1, MER2 and PER bits are reset and the STRT bit is set, the PGSERR bit in FLASH_NSSR is set (this condition is forbidden). This bit is set only by software and is cleared when the BSY bit is cleared in FLASH_NSSR.
        constexpr uint32_t OPTSTRT = (1U << 17);  ///< Options modification start This bit triggers an options operation when set. It can not be written if OPTLOCK bit is set. This bit is set only by software, and is cleared when the BSY bit is cleared in FLASH_NSSR.
        constexpr uint32_t EOPIE = (1U << 24);  ///< Non-secure end of operation interrupt enable This bit enables the interrupt generation when the EOP bit in the FLASH_NSSR is set to 1.
        constexpr uint32_t ERRIE = (1U << 25);  ///< Non-secure error interrupt enable This bit enables the interrupt generation when the OPERR bit in the FLASH_NSSR is set to 1.
        constexpr uint32_t OBL_LAUNCH = (1U << 27);  ///< Force the option byte loading When set to 1, this bit forces the option byte reloading. This bit is cleared only when the option byte loading is complete. It cannot be written if OPTLOCK is set.
        constexpr uint32_t OPTLOCK = (1U << 30);  ///< Option lock This bit is set only. When set, all bits concerning user options in FLASH_NSCR register are locked. This bit is cleared by hardware after detecting the unlock sequence. The LOCK bit in the FLASH_NSCR must be cleared before doing the unlock sequence for OPTLOCK bit. In case of an unsuccessful unlock operation, this bit remains set until the next reset.
        constexpr uint32_t LOCK = (1U << 31);  ///< Non-secure lock This bit is set only. When set, the FLASH_NSCR register is locked. It is cleared by hardware after detecting the unlock sequence in FLASH_NSKEYR register. In case of an unsuccessful unlock operation, this bit remains set until the next system reset.
    }

    /// FLASH_SECCR Register bits
    namespace flash_seccr_bits {
        constexpr uint32_t PG = (1U << 0);  ///< Secure programming
        constexpr uint32_t PER = (1U << 1);  ///< Secure page erase
        constexpr uint32_t MER1 = (1U << 2);  ///< Secure bank 1 mass erase This bit triggers the bank 1 secure mass erase (all bank 1 user pages) when set.
        constexpr uint32_t PNB = (8 << 3);  ///< Secure page number selection These bits select the page to erase. ... ...
        constexpr uint32_t BKER = (1U << 11);  ///< Secure bank selection for page erase
        constexpr uint32_t BWR = (1U << 14);  ///< Secure burst write programming mode When set, this bit selects the burst write programming mode.
        constexpr uint32_t MER2 = (1U << 15);  ///< Secure bank 2 mass erase This bit triggers the bank 2 secure mass erase (all bank 2 user pages) when set.
        constexpr uint32_t STRT = (1U << 16);  ///< Secure start This bit triggers a secure erase operation when set. If MER1, MER2 and PER bits are reset and the STRT bit is set, the PGSERR in the FLASH_SECSR is set (this condition is forbidden). This bit is set only by software and is cleared when the BSY bit is cleared in FLASH_SECSR.
        constexpr uint32_t EOPIE = (1U << 24);  ///< Secure End of operation interrupt enable This bit enables the interrupt generation when the EOP bit in the FLASH_SECSR is set to 1.
        constexpr uint32_t ERRIE = (1U << 25);  ///< Secure error interrupt enable This bit enables the interrupt generation when the OPERR bit in the FLASH_SECSR is set to 1.
        constexpr uint32_t RDERRIE = (1U << 26);  ///< Secure PCROP read error interrupt enable This bit enables the interrupt generation when the RDERR bit in the FLASH_SECSR is set to 1.
        constexpr uint32_t INV = (1U << 29);  ///< Flash memory security state invert This bit inverts the Flash memory security state.
        constexpr uint32_t LOCK = (1U << 31);  ///< Secure lock This bit is set only. When set, the FLASH_SECCR register is locked. It is cleared by hardware after detecting the unlock sequence in FLASH_SECKEYR register. In case of an unsuccessful unlock operation, this bit remains set until the next system reset.
    }

    /// FLASH_ECCR Register bits
    namespace flash_eccr_bits {
        constexpr uint32_t ADDR_ECC = (21 << 0);  ///< ECC fail address This field indicates which address is concerned by the ECC error correction or by the double ECC error detection. The address is given by bank from address 0x0 0000 to 0x1F FFF0.
        constexpr uint32_t BK_ECC = (1U << 21);  ///< ECC fail bank This bit indicates which bank is concerned by the ECC error correction or by the double ECC error detection.
        constexpr uint32_t SYSF_ECC = (1U << 22);  ///< System Flash memory ECC fail This bit indicates that the ECC error correction or double ECC error detection is located in the system Flash memory.
        constexpr uint32_t ECCIE = (1U << 24);  ///< ECC correction interrupt enable This bit enables the interrupt generation when the ECCC bit in the FLASH_ECCR register is set.
        constexpr uint32_t ECCC = (1U << 30);  ///< ECC correction This bit is set by hardware when one ECC error has been detected and corrected (only if ECCC and ECCD were previously cleared). An interrupt is generated if ECCIE is set. This bit is cleared by writing 1.
        constexpr uint32_t ECCD = (1U << 31);  ///< ECC detection This bit is set by hardware when two ECC errors have been detected (only if ECCC and ECCD were previously cleared). When this bit is set, a NMI is generated. This bit is cleared by writing 1.
    }

    /// FLASH_OPSR Register bits
    namespace flash_opsr_bits {
        constexpr uint32_t ADDR_OP = (21 << 0);  ///< Interrupted operation address This field indicates which address in the Flash memory was accessed when reset occurred. The address is given by bank from address 0x0 0000 to 0x1F FFF0.
        constexpr uint32_t BK_OP = (1U << 21);  ///< Interrupted operation bank This bit indicates which Flash memory bank was accessed when reset occurred
        constexpr uint32_t SYSF_OP = (1U << 22);  ///< Operation in system Flash memory interrupted This bit indicates that the reset occurred during an operation in the system Flash memory.
        constexpr uint32_t CODE_OP = (3 << 29);  ///< Flash memory operation code This field indicates which Flash memory operation has been interrupted by a system reset:
    }

    /// FLASH_OPTR Register bits
    namespace flash_optr_bits {
        constexpr uint32_t RDP = (8 << 0);  ///< Readout protection level Others: Level 1 (memories readout protection active) Note: Refer to for more details.
        constexpr uint32_t BOR_LEV = (3 << 8);  ///< BOR reset level These bits contain the VDD supply level threshold that activates/releases the reset.
        constexpr uint32_t nRST_STOP = (1U << 12);  ///< Reset generation in Stop mode
        constexpr uint32_t nRST_STDBY = (1U << 13);  ///< Reset generation in Standby mode
        constexpr uint32_t nRST_SHDW = (1U << 14);  ///< Reset generation in Shutdown mode
        constexpr uint32_t SRAM1345_RST = (1U << 15);  ///< SRAM1, SRAM3, SRAM4 and SRAM5 erase upon system reset
        constexpr uint32_t IWDG_SW = (1U << 16);  ///< Independent watchdog selection
        constexpr uint32_t IWDG_STOP = (1U << 17);  ///< Independent watchdog counter freeze in Stop mode
        constexpr uint32_t IWDG_STDBY = (1U << 18);  ///< Independent watchdog counter freeze in Standby mode
        constexpr uint32_t WWDG_SW = (1U << 19);  ///< Window watchdog selection
        constexpr uint32_t SWAP_BANK = (1U << 20);  ///< Swap banks
        constexpr uint32_t DUALBANK = (1U << 21);  ///< Dual-bank on 1-Mbyte and 512-Kbyte Flash memory devices
        constexpr uint32_t BKPRAM_ECC = (1U << 22);  ///< Backup RAM ECC detection and correction enable
        constexpr uint32_t SRAM3_ECC = (1U << 23);  ///< SRAM3 ECC detection and correction enable
        constexpr uint32_t SRAM2_ECC = (1U << 24);  ///< SRAM2 ECC detection and correction enable
        constexpr uint32_t SRAM2_RST = (1U << 25);  ///< SRAM2 erase when system reset
        constexpr uint32_t nSWBOOT0 = (1U << 26);  ///< Software BOOT0
        constexpr uint32_t nBOOT0 = (1U << 27);  ///< nBOOT0 option bit
        constexpr uint32_t PA15_PUPEN = (1U << 28);  ///< PA15 pull-up enable
        constexpr uint32_t IO_VDD_HSLV = (1U << 29);  ///< High-speed IO at low VDD voltage configuration bit This bit can be set only with VDD below 2.5V
        constexpr uint32_t IO_VDDIO2_HSLV = (1U << 30);  ///< High-speed IO at low VDDIO2 voltage configuration bit This bit can be set only with VDDIO2 below 2.5 V.
        constexpr uint32_t TZEN = (1U << 31);  ///< Global TrustZone security enable
    }

    /// FLASH_NSBOOTADD0R Register bits
    namespace flash_nsbootadd0r_bits {
        constexpr uint32_t NSBOOTADD0 = (25 << 7);  ///< Non-secure boot base address 0 The non-secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: NSBOOTADD0[24:0] = 0x0100000: Boot from non-secure Flash memory (0x0800 0000) NSBOOTADD0[24:0] = 0x017F200: Boot from system memory bootloader (0x0BF9 0000) NSBOOTADD0[24:0] = 0x0400000: Boot from non-secure SRAM1 on S-Bus (0x2000 0000)
    }

    /// FLASH_NSBOOTADD1R Register bits
    namespace flash_nsbootadd1r_bits {
        constexpr uint32_t NSBOOTADD1 = (25 << 7);  ///< Non-secure boot address 1 The non-secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: NSBOOTADD1[24:0] = 0x0100000: Boot from non-secure Flash memory (0x0800 0000) NSBOOTADD1[24:0] = 0x017F200: Boot from system memory bootloader (0x0BF9 0000) NSBOOTADD1[24:0] = 0x0400000: Boot from non-secure SRAM1 on S-Bus (0x2000 0000)
    }

    /// FLASH_SECBOOTADD0R Register bits
    namespace flash_secbootadd0r_bits {
        constexpr uint32_t BOOT_LOCK = (1U << 0);  ///< Boot lock When set, the boot is always forced to base address value programmed in SECBOOTADD0[24:0] option bytes whatever the boot selection option. When set, this bit can only be cleared by an RDP at level 0.
        constexpr uint32_t SECBOOTADD0 = (25 << 7);  ///< Secure boot base address 0 The secure boot memory address can be programmed to any address in the valid address range with a granularity of 128 bytes. This bits correspond to address [31:7] The SECBOOTADD0 option bytes are selected following the BOOT0 pin or nSWBOOT0 state. Examples: SECBOOTADD0[24:0] = 0x018 0000: Boot from secure Flash memory (0x0C00 0000) SECBOOTADD0[24:0] = 0x01F F000: Boot from RSS (0x0FF8 0000) SECBOOTADD0[24:0] = 0x060 0000: Boot from secure SRAM1 on S-Bus (0x3000 0000)
    }

    /// FLASH_SECWM1R1 Register bits
    namespace flash_secwm1r1_bits {
        constexpr uint32_t SECWM1_PSTRT = (8 << 0);  ///< Start page of first secure area This field contains the first page of the secure area in bank 1.
        constexpr uint32_t SECWM1_PEND = (8 << 16);  ///< End page of first secure area This field contains the last page of the secure area in bank 1.
    }

    /// FLASH_SECWM1R2 Register bits
    namespace flash_secwm1r2_bits {
        constexpr uint32_t PCROP1_PSTRT = (8 << 0);  ///< Start page of first PCROP area This field contains the first page of the PCROP area in bank 1.
        constexpr uint32_t PCROP1EN = (1U << 15);  ///< PCROP1 area enable
        constexpr uint32_t HDP1_PEND = (8 << 16);  ///< End page of first hide protection area This field contains the last page of the HDP area in bank 1.
        constexpr uint32_t HDP1EN = (1U << 31);  ///< Hide protection first area enable
    }

    /// FLASH_WRP1AR Register bits
    namespace flash_wrp1ar_bits {
        constexpr uint32_t WRP1A_PSTRT = (8 << 0);  ///< bank 1 WPR first area A start page This field contains the first page of the first WPR area for bank 1.
        constexpr uint32_t WRP1A_PEND = (8 << 16);  ///< Bank 1 WPR first area A end page This field contains the last page of the first WPR area in bank 1.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 1 WPR first area A unlock
    }

    /// FLASH_WRP1BR Register bits
    namespace flash_wrp1br_bits {
        constexpr uint32_t WRP1B_PSTRT = (8 << 0);  ///< Bank 1 WRP second area B start page This field contains the first page of the second WRP area for bank 1.
        constexpr uint32_t WRP1B_PEND = (8 << 16);  ///< Bank 1 WRP second area B end page This field contains the last page of the second WRP area in bank 1.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 1 WPR second area B unlock
    }

    /// FLASH_SECWM2R1 Register bits
    namespace flash_secwm2r1_bits {
        constexpr uint32_t SECWM2_PSTRT = (8 << 0);  ///< Start page of second secure area This field contains the first page of the secure area in bank 2.
        constexpr uint32_t SECWM2_PEND = (8 << 16);  ///< End page of second secure area This field contains the last page of the secure area in bank 2.
    }

    /// FLASH_SECWM2R2 Register bits
    namespace flash_secwm2r2_bits {
        constexpr uint32_t PCROP2_PSTRT = (8 << 0);  ///< Start page of PCROP2 area PRCROP2_PSTRT contains the first page of the PCROP area in bank 2.
        constexpr uint32_t PCROP2EN = (1U << 15);  ///< PCROP2 area enable
        constexpr uint32_t HDP2_PEND = (8 << 16);  ///< End page of hide protection second area HDP2_PEND contains the last page of the HDP area in bank 2.
        constexpr uint32_t HDP2EN = (1U << 31);  ///< Hide protection second area enable
    }

    /// FLASH_WRP2AR Register bits
    namespace flash_wrp2ar_bits {
        constexpr uint32_t WRP2A_PSTRT = (8 << 0);  ///< Bank 2 WPR first area A start page This field contains the first page of the first WRP area for bank 2.
        constexpr uint32_t WRP2A_PEND = (8 << 16);  ///< Bank 2 WPR first area A end page This field contains the last page of the first WRP area in bank 2.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 2 WPR first area A unlock
    }

    /// FLASH_WRP2BR Register bits
    namespace flash_wrp2br_bits {
        constexpr uint32_t WRP2B_PSTRT = (8 << 0);  ///< Bank 2 WPR second area B start page This field contains the first page of the second WRP area for bank 2.
        constexpr uint32_t WRP2B_PEND = (8 << 16);  ///< Bank 2 WPR second area B end page This field contains the last page of the second WRP area in bank 2.
        constexpr uint32_t UNLOCK = (1U << 31);  ///< Bank 2 WPR second area B unlock
    }

    /// FLASH_OEM1KEYR1 Register bits
    namespace flash_oem1keyr1_bits {
        constexpr uint32_t OEM1KEY = (32 << 0);  ///< OEM1 least significant bytes key
    }

    /// FLASH_OEM1KEYR2 Register bits
    namespace flash_oem1keyr2_bits {
        constexpr uint32_t OEM1KEY = (32 << 0);  ///< OEM1 most significant bytes key
    }

    /// FLASH_OEM2KEYR1 Register bits
    namespace flash_oem2keyr1_bits {
        constexpr uint32_t OEM2KEY = (32 << 0);  ///< OEM2 least significant bytes key
    }

    /// FLASH_OEM2KEYR2 Register bits
    namespace flash_oem2keyr2_bits {
        constexpr uint32_t OEM2KEY = (32 << 0);  ///< OEM2 most significant bytes key
    }

    /// FLASH_SEC1BBR1 Register bits
    namespace flash_sec1bbr1_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR2 Register bits
    namespace flash_sec1bbr2_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR3 Register bits
    namespace flash_sec1bbr3_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR4 Register bits
    namespace flash_sec1bbr4_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR5 Register bits
    namespace flash_sec1bbr5_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR6 Register bits
    namespace flash_sec1bbr6_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR7 Register bits
    namespace flash_sec1bbr7_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC1BBR8 Register bits
    namespace flash_sec1bbr8_bits {
        constexpr uint32_t SEC1BB0 = (1U << 0);  ///< SEC1BB0
        constexpr uint32_t SEC1BB1 = (1U << 1);  ///< SEC1BB1
        constexpr uint32_t SEC1BB2 = (1U << 2);  ///< SEC1BB2
        constexpr uint32_t SEC1BB3 = (1U << 3);  ///< SEC1BB3
        constexpr uint32_t SEC1BB4 = (1U << 4);  ///< SEC1BB4
        constexpr uint32_t SEC1BB5 = (1U << 5);  ///< SEC1BB5
        constexpr uint32_t SEC1BB6 = (1U << 6);  ///< SEC1BB6
        constexpr uint32_t SEC1BB7 = (1U << 7);  ///< SEC1BB7
        constexpr uint32_t SEC1BB8 = (1U << 8);  ///< SEC1BB8
        constexpr uint32_t SEC1BB9 = (1U << 9);  ///< SEC1BB9
        constexpr uint32_t SEC1BB10 = (1U << 10);  ///< SEC1BB10
        constexpr uint32_t SEC1BB11 = (1U << 11);  ///< SEC1BB11
        constexpr uint32_t SEC1BB12 = (1U << 12);  ///< SEC1BB12
        constexpr uint32_t SEC1BB13 = (1U << 13);  ///< SEC1BB13
        constexpr uint32_t SEC1BB14 = (1U << 14);  ///< SEC1BB14
        constexpr uint32_t SEC1BB15 = (1U << 15);  ///< SEC1BB15
        constexpr uint32_t SEC1BB16 = (1U << 16);  ///< SEC1BB16
        constexpr uint32_t SEC1BB17 = (1U << 17);  ///< SEC1BB17
        constexpr uint32_t SEC1BB18 = (1U << 18);  ///< SEC1BB18
        constexpr uint32_t SEC1BB19 = (1U << 19);  ///< SEC1BB19
        constexpr uint32_t SEC1BB20 = (1U << 20);  ///< SEC1BB20
        constexpr uint32_t SEC1BB21 = (1U << 21);  ///< SEC1BB21
        constexpr uint32_t SEC1BB22 = (1U << 22);  ///< SEC1BB22
        constexpr uint32_t SEC1BB23 = (1U << 23);  ///< SEC1BB23
        constexpr uint32_t SEC1BB24 = (1U << 24);  ///< SEC1BB24
        constexpr uint32_t SEC1BB25 = (1U << 25);  ///< SEC1BB25
        constexpr uint32_t SEC1BB26 = (1U << 26);  ///< SEC1BB26
        constexpr uint32_t SEC1BB27 = (1U << 27);  ///< SEC1BB27
        constexpr uint32_t SEC1BB28 = (1U << 28);  ///< SEC1BB28
        constexpr uint32_t SEC1BB29 = (1U << 29);  ///< SEC1BB29
        constexpr uint32_t SEC1BB30 = (1U << 30);  ///< SEC1BB30
        constexpr uint32_t SEC1BB31 = (1U << 31);  ///< SEC1BB31
    }

    /// FLASH_SEC2BBR1 Register bits
    namespace flash_sec2bbr1_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR2 Register bits
    namespace flash_sec2bbr2_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR3 Register bits
    namespace flash_sec2bbr3_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR4 Register bits
    namespace flash_sec2bbr4_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR5 Register bits
    namespace flash_sec2bbr5_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR6 Register bits
    namespace flash_sec2bbr6_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR7 Register bits
    namespace flash_sec2bbr7_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SEC2BBR8 Register bits
    namespace flash_sec2bbr8_bits {
        constexpr uint32_t SEC2BB0 = (1U << 0);  ///< SEC2BB0
        constexpr uint32_t SEC2BB1 = (1U << 1);  ///< SEC2BB1
        constexpr uint32_t SEC2BB2 = (1U << 2);  ///< SEC2BB2
        constexpr uint32_t SEC2BB3 = (1U << 3);  ///< SEC2BB3
        constexpr uint32_t SEC2BB4 = (1U << 4);  ///< SEC2BB4
        constexpr uint32_t SEC2BB5 = (1U << 5);  ///< SEC2BB5
        constexpr uint32_t SEC2BB6 = (1U << 6);  ///< SEC2BB6
        constexpr uint32_t SEC2BB7 = (1U << 7);  ///< SEC2BB7
        constexpr uint32_t SEC2BB8 = (1U << 8);  ///< SEC2BB8
        constexpr uint32_t SEC2BB9 = (1U << 9);  ///< SEC2BB9
        constexpr uint32_t SEC2BB10 = (1U << 10);  ///< SEC2BB10
        constexpr uint32_t SEC2BB11 = (1U << 11);  ///< SEC2BB11
        constexpr uint32_t SEC2BB12 = (1U << 12);  ///< SEC2BB12
        constexpr uint32_t SEC2BB13 = (1U << 13);  ///< SEC2BB13
        constexpr uint32_t SEC2BB14 = (1U << 14);  ///< SEC2BB14
        constexpr uint32_t SEC2BB15 = (1U << 15);  ///< SEC2BB15
        constexpr uint32_t SEC2BB16 = (1U << 16);  ///< SEC2BB16
        constexpr uint32_t SEC2BB17 = (1U << 17);  ///< SEC2BB17
        constexpr uint32_t SEC2BB18 = (1U << 18);  ///< SEC2BB18
        constexpr uint32_t SEC2BB19 = (1U << 19);  ///< SEC2BB19
        constexpr uint32_t SEC2BB20 = (1U << 20);  ///< SEC2BB20
        constexpr uint32_t SEC2BB21 = (1U << 21);  ///< SEC2BB21
        constexpr uint32_t SEC2BB22 = (1U << 22);  ///< SEC2BB22
        constexpr uint32_t SEC2BB23 = (1U << 23);  ///< SEC2BB23
        constexpr uint32_t SEC2BB24 = (1U << 24);  ///< SEC2BB24
        constexpr uint32_t SEC2BB25 = (1U << 25);  ///< SEC2BB25
        constexpr uint32_t SEC2BB26 = (1U << 26);  ///< SEC2BB26
        constexpr uint32_t SEC2BB27 = (1U << 27);  ///< SEC2BB27
        constexpr uint32_t SEC2BB28 = (1U << 28);  ///< SEC2BB28
        constexpr uint32_t SEC2BB29 = (1U << 29);  ///< SEC2BB29
        constexpr uint32_t SEC2BB30 = (1U << 30);  ///< SEC2BB30
        constexpr uint32_t SEC2BB31 = (1U << 31);  ///< SEC2BB31
    }

    /// FLASH_SECHDPCR Register bits
    namespace flash_sechdpcr_bits {
        constexpr uint32_t HDP1_ACCDIS = (1U << 0);  ///< HDP1 area access disable When set, this bit is only cleared by a system reset.
        constexpr uint32_t HDP2_ACCDIS = (1U << 1);  ///< HDP2 area access disable When set, this bit is only cleared by a system reset.
    }

    /// FLASH_PRIVCFGR Register bits
    namespace flash_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< Privileged protection for secure registers
        constexpr uint32_t NSPRIV = (1U << 1);  ///< Privileged protection for non-secure registers
    }

    /// FLASH_PRIV1BBR1 Register bits
    namespace flash_priv1bbr1_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR2 Register bits
    namespace flash_priv1bbr2_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR3 Register bits
    namespace flash_priv1bbr3_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR4 Register bits
    namespace flash_priv1bbr4_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR5 Register bits
    namespace flash_priv1bbr5_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR6 Register bits
    namespace flash_priv1bbr6_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR7 Register bits
    namespace flash_priv1bbr7_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV1BBR8 Register bits
    namespace flash_priv1bbr8_bits {
        constexpr uint32_t PRIV1BB0 = (1U << 0);  ///< PRIV1BB0
        constexpr uint32_t PRIV1BB1 = (1U << 1);  ///< PRIV1BB1
        constexpr uint32_t PRIV1BB2 = (1U << 2);  ///< PRIV1BB2
        constexpr uint32_t PRIV1BB3 = (1U << 3);  ///< PRIV1BB3
        constexpr uint32_t PRIV1BB4 = (1U << 4);  ///< PRIV1BB4
        constexpr uint32_t PRIV1BB5 = (1U << 5);  ///< PRIV1BB5
        constexpr uint32_t PRIV1BB6 = (1U << 6);  ///< PRIV1BB6
        constexpr uint32_t PRIV1BB7 = (1U << 7);  ///< PRIV1BB7
        constexpr uint32_t PRIV1BB8 = (1U << 8);  ///< PRIV1BB8
        constexpr uint32_t PRIV1BB9 = (1U << 9);  ///< PRIV1BB9
        constexpr uint32_t PRIV1BB10 = (1U << 10);  ///< PRIV1BB10
        constexpr uint32_t PRIV1BB11 = (1U << 11);  ///< PRIV1BB11
        constexpr uint32_t PRIV1BB12 = (1U << 12);  ///< PRIV1BB12
        constexpr uint32_t PRIV1BB13 = (1U << 13);  ///< PRIV1BB13
        constexpr uint32_t PRIV1BB14 = (1U << 14);  ///< PRIV1BB14
        constexpr uint32_t PRIV1BB15 = (1U << 15);  ///< PRIV1BB15
        constexpr uint32_t PRIV1BB16 = (1U << 16);  ///< PRIV1BB16
        constexpr uint32_t PRIV1BB17 = (1U << 17);  ///< PRIV1BB17
        constexpr uint32_t PRIV1BB18 = (1U << 18);  ///< PRIV1BB18
        constexpr uint32_t PRIV1BB19 = (1U << 19);  ///< PRIV1BB19
        constexpr uint32_t PRIV1BB20 = (1U << 20);  ///< PRIV1BB20
        constexpr uint32_t PRIV1BB21 = (1U << 21);  ///< PRIV1BB21
        constexpr uint32_t PRIV1BB22 = (1U << 22);  ///< PRIV1BB22
        constexpr uint32_t PRIV1BB23 = (1U << 23);  ///< PRIV1BB23
        constexpr uint32_t PRIV1BB24 = (1U << 24);  ///< PRIV1BB24
        constexpr uint32_t PRIV1BB25 = (1U << 25);  ///< PRIV1BB25
        constexpr uint32_t PRIV1BB26 = (1U << 26);  ///< PRIV1BB26
        constexpr uint32_t PRIV1BB27 = (1U << 27);  ///< PRIV1BB27
        constexpr uint32_t PRIV1BB28 = (1U << 28);  ///< PRIV1BB28
        constexpr uint32_t PRIV1BB29 = (1U << 29);  ///< PRIV1BB29
        constexpr uint32_t PRIV1BB30 = (1U << 30);  ///< PRIV1BB30
        constexpr uint32_t PRIV1BB31 = (1U << 31);  ///< PRIV1BB31
    }

    /// FLASH_PRIV2BBR1 Register bits
    namespace flash_priv2bbr1_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR2 Register bits
    namespace flash_priv2bbr2_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR3 Register bits
    namespace flash_priv2bbr3_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR4 Register bits
    namespace flash_priv2bbr4_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR5 Register bits
    namespace flash_priv2bbr5_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR6 Register bits
    namespace flash_priv2bbr6_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR7 Register bits
    namespace flash_priv2bbr7_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

    /// FLASH_PRIV2BBR8 Register bits
    namespace flash_priv2bbr8_bits {
        constexpr uint32_t PRIV2BB0 = (1U << 0);  ///< PRIV2BB0
        constexpr uint32_t PRIV2BB1 = (1U << 1);  ///< PRIV2BB1
        constexpr uint32_t PRIV2BB2 = (1U << 2);  ///< PRIV2BB2
        constexpr uint32_t PRIV2BB3 = (1U << 3);  ///< PRIV2BB3
        constexpr uint32_t PRIV2BB4 = (1U << 4);  ///< PRIV2BB4
        constexpr uint32_t PRIV2BB5 = (1U << 5);  ///< PRIV2BB5
        constexpr uint32_t PRIV2BB6 = (1U << 6);  ///< PRIV2BB6
        constexpr uint32_t PRIV2BB7 = (1U << 7);  ///< PRIV2BB7
        constexpr uint32_t PRIV2BB8 = (1U << 8);  ///< PRIV2BB8
        constexpr uint32_t PRIV2BB9 = (1U << 9);  ///< PRIV2BB9
        constexpr uint32_t PRIV2BB10 = (1U << 10);  ///< PRIV2BB10
        constexpr uint32_t PRIV2BB11 = (1U << 11);  ///< PRIV2BB11
        constexpr uint32_t PRIV2BB12 = (1U << 12);  ///< PRIV2BB12
        constexpr uint32_t PRIV2BB13 = (1U << 13);  ///< PRIV2BB13
        constexpr uint32_t PRIV2BB14 = (1U << 14);  ///< PRIV2BB14
        constexpr uint32_t PRIV2BB15 = (1U << 15);  ///< PRIV2BB15
        constexpr uint32_t PRIV2BB16 = (1U << 16);  ///< PRIV2BB16
        constexpr uint32_t PRIV2BB17 = (1U << 17);  ///< PRIV2BB17
        constexpr uint32_t PRIV2BB18 = (1U << 18);  ///< PRIV2BB18
        constexpr uint32_t PRIV2BB19 = (1U << 19);  ///< PRIV2BB19
        constexpr uint32_t PRIV2BB20 = (1U << 20);  ///< PRIV2BB20
        constexpr uint32_t PRIV2BB21 = (1U << 21);  ///< PRIV2BB21
        constexpr uint32_t PRIV2BB22 = (1U << 22);  ///< PRIV2BB22
        constexpr uint32_t PRIV2BB23 = (1U << 23);  ///< PRIV2BB23
        constexpr uint32_t PRIV2BB24 = (1U << 24);  ///< PRIV2BB24
        constexpr uint32_t PRIV2BB25 = (1U << 25);  ///< PRIV2BB25
        constexpr uint32_t PRIV2BB26 = (1U << 26);  ///< PRIV2BB26
        constexpr uint32_t PRIV2BB27 = (1U << 27);  ///< PRIV2BB27
        constexpr uint32_t PRIV2BB28 = (1U << 28);  ///< PRIV2BB28
        constexpr uint32_t PRIV2BB29 = (1U << 29);  ///< PRIV2BB29
        constexpr uint32_t PRIV2BB30 = (1U << 30);  ///< PRIV2BB30
        constexpr uint32_t PRIV2BB31 = (1U << 31);  ///< PRIV2BB31
    }

}

// ============================================================================
// FMAC Peripheral
// ============================================================================

namespace fmac {
    /// Base addresses
    constexpr uint32_t FMAC_BASE = 0x40021400;

    /// FMAC Register structure
    struct Registers {
        volatile uint32_t X1BUFCFG;  ///< Offset: 0x00 - FMAC X1 Buffer Configuration register
        volatile uint32_t X2BUFCFG;  ///< Offset: 0x04 - FMAC X2 Buffer Configuration register
        volatile uint32_t YBUFCFG;  ///< Offset: 0x08 - FMAC Y Buffer Configuration register
        volatile uint32_t PARAM;  ///< Offset: 0x0C - FMAC Parameter register
        volatile uint32_t CR;  ///< Offset: 0x10 - FMAC Control register
        volatile uint32_t SR;  ///< Offset: 0x14 - FMAC Status register
        volatile uint32_t WDATA;  ///< Offset: 0x18 - FMAC Write Data register
        volatile uint32_t RDATA;  ///< Offset: 0x1C - FMAC Read Data register
    };

    /// Peripheral instances
    inline Registers* FMAC = reinterpret_cast<Registers*>(FMAC_BASE);

    // Bit definitions
    /// X1BUFCFG Register bits
    namespace x1bufcfg_bits {
        constexpr uint32_t X1_BASE = (8 << 0);  ///< Base address of X1 buffer
        constexpr uint32_t X1_BUF_SIZE = (8 << 8);  ///< Allocated size of X1 buffer in 16-bit words
        constexpr uint32_t FULL_WM = (2 << 24);  ///< Watermark for buffer full flag
    }

    /// X2BUFCFG Register bits
    namespace x2bufcfg_bits {
        constexpr uint32_t X2_BASE = (8 << 0);  ///< Base address of X2 buffer
        constexpr uint32_t X2_BUF_SIZE = (8 << 8);  ///< Size of X2 buffer in 16-bit words
    }

    /// YBUFCFG Register bits
    namespace ybufcfg_bits {
        constexpr uint32_t Y_BASE = (8 << 0);  ///< Base address of Y buffer
        constexpr uint32_t Y_BUF_SIZE = (8 << 8);  ///< Size of Y buffer in 16-bit words
        constexpr uint32_t EMPTY_WM = (2 << 24);  ///< Watermark for buffer empty flag
    }

    /// PARAM Register bits
    namespace param_bits {
        constexpr uint32_t START = (1U << 31);  ///< Enable execution
        constexpr uint32_t FUNC = (7 << 24);  ///< Function
        constexpr uint32_t R = (8 << 16);  ///< Input parameter R
        constexpr uint32_t Q = (8 << 8);  ///< Input parameter Q
        constexpr uint32_t P = (8 << 0);  ///< Input parameter P
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t RESET = (1U << 16);  ///< Reset FMAC unit
        constexpr uint32_t CLIPEN = (1U << 15);  ///< Enable clipping
        constexpr uint32_t DMAWEN = (1U << 9);  ///< Enable DMA write channel requests
        constexpr uint32_t DMAREN = (1U << 8);  ///< Enable DMA read channel requests
        constexpr uint32_t SATIEN = (1U << 4);  ///< Enable saturation error interrupts
        constexpr uint32_t UNFLIEN = (1U << 3);  ///< Enable underflow error interrupts
        constexpr uint32_t OVFLIEN = (1U << 2);  ///< Enable overflow error interrupts
        constexpr uint32_t WIEN = (1U << 1);  ///< Enable write interrupt
        constexpr uint32_t RIEN = (1U << 0);  ///< Enable read interrupt
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t YEMPTY = (1U << 0);  ///< Y buffer empty flag
        constexpr uint32_t X1FULL = (1U << 1);  ///< X1 buffer full flag
        constexpr uint32_t OVFL = (1U << 8);  ///< Overflow error flag
        constexpr uint32_t UNFL = (1U << 9);  ///< Underflow error flag
        constexpr uint32_t SAT = (1U << 10);  ///< Saturation error flag
    }

    /// WDATA Register bits
    namespace wdata_bits {
        constexpr uint32_t WDATA = (16 << 0);  ///< Write data
    }

    /// RDATA Register bits
    namespace rdata_bits {
        constexpr uint32_t RDATA = (16 << 0);  ///< Read data
    }

}

// ============================================================================
// FMC Peripheral
// ============================================================================

namespace fmc {
    /// Base addresses
    constexpr uint32_t FMC_BASE = 0x420D0400;

    /// FMC Register structure
    struct Registers {
        volatile uint32_t BCR1;  ///< Offset: 0x00 - SRAM/NOR-Flash chip-select control register for bank 1
        volatile uint32_t BCR2;  ///< Offset: 0x08 - SRAM/NOR-Flash chip-select control register for bank 2
        volatile uint32_t BCR3;  ///< Offset: 0x10 - SRAM/NOR-Flash chip-select control register for bank 3
        volatile uint32_t BCR4;  ///< Offset: 0x18 - SRAM/NOR-Flash chip-select control register for bank 4
        volatile uint32_t BTR1;  ///< Offset: 0x04 - SRAM/NOR-Flash chip-select timing register for bank 1
        volatile uint32_t BTR2;  ///< Offset: 0x0C - SRAM/NOR-Flash chip-select timing register for bank 2
        volatile uint32_t BTR3;  ///< Offset: 0x14 - SRAM/NOR-Flash chip-select timing register for bank 3
        volatile uint32_t BTR4;  ///< Offset: 0x1C - SRAM/NOR-Flash chip-select timing register for bank 4
        volatile uint32_t BWTR1;  ///< Offset: 0x104 - SRAM/NOR-Flash write timing registers 1
        volatile uint32_t BWTR2;  ///< Offset: 0x10C - SRAM/NOR-Flash write timing registers 2
        volatile uint32_t BWTR3;  ///< Offset: 0x114 - SRAM/NOR-Flash write timing registers 3
        volatile uint32_t BWTR4;  ///< Offset: 0x11C - SRAM/NOR-Flash write timing registers 4
        volatile uint32_t PCSCNTR;  ///< Offset: 0x20 - PSRAM chip select counter register
        volatile uint32_t PCR;  ///< Offset: 0x80 - NAND Flash control registers
        volatile uint32_t SR;  ///< Offset: 0x84 - status and interrupt register
        volatile uint32_t PMEM;  ///< Offset: 0x88 - Common memory space timing register
        volatile uint32_t PATT;  ///< Offset: 0x8C - The FMC_PATT read/write register contains the timing...
        volatile uint32_t ECCR;  ///< Offset: 0x94 - This register contain the current error correction code...
    };

    /// Peripheral instances
    inline Registers* FMC = reinterpret_cast<Registers*>(FMC_BASE);

    // Bit definitions
    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous clock enable
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO disable
        constexpr uint32_t NBLSET = (2 << 22);  ///< Byte lane (NBL) setup
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller enable
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous clock enable
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO disable
        constexpr uint32_t NBLSET = (2 << 22);  ///< Byte lane (NBL) setup
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller enable
    }

    /// BCR3 Register bits
    namespace bcr3_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous clock enable
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO disable
        constexpr uint32_t NBLSET = (2 << 22);  ///< Byte lane (NBL) setup
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller enable
    }

    /// BCR4 Register bits
    namespace bcr4_bits {
        constexpr uint32_t MBKEN = (1U << 0);  ///< Memory bank enable bit
        constexpr uint32_t MUXEN = (1U << 1);  ///< Address/data multiplexing enable bit
        constexpr uint32_t MTYP = (2 << 2);  ///< Memory type
        constexpr uint32_t MWID = (2 << 4);  ///< Memory data bus width
        constexpr uint32_t FACCEN = (1U << 6);  ///< Flash access enable
        constexpr uint32_t BURSTEN = (1U << 8);  ///< Burst enable bit
        constexpr uint32_t WAITPOL = (1U << 9);  ///< Wait signal polarity bit
        constexpr uint32_t WAITCFG = (1U << 11);  ///< Wait timing configuration
        constexpr uint32_t WREN = (1U << 12);  ///< Write enable bit
        constexpr uint32_t WAITEN = (1U << 13);  ///< Wait enable bit
        constexpr uint32_t EXTMOD = (1U << 14);  ///< Extended mode enable
        constexpr uint32_t ASYNCWAIT = (1U << 15);  ///< Wait signal during asynchronous transfers
        constexpr uint32_t CPSIZE = (3 << 16);  ///< CRAM Page Size
        constexpr uint32_t CBURSTRW = (1U << 19);  ///< Write burst enable
        constexpr uint32_t CCLKEN = (1U << 20);  ///< Continuous clock enable
        constexpr uint32_t WFDIS = (1U << 21);  ///< Write FIFO disable
        constexpr uint32_t NBLSET = (2 << 22);  ///< Byte lane (NBL) setup
        constexpr uint32_t FMCEN = (1U << 31);  ///< FMC controller enable
    }

    /// BTR1 Register bits
    namespace btr1_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BTR2 Register bits
    namespace btr2_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BTR3 Register bits
    namespace btr3_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BTR4 Register bits
    namespace btr4_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t CLKDIV = (4 << 20);  ///< Clock divide ratio (for FMC_CLK signal)
        constexpr uint32_t DATLAT = (4 << 24);  ///< Data latency for synchronous memory
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BWTR1 Register bits
    namespace bwtr1_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BWTR2 Register bits
    namespace bwtr2_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BWTR3 Register bits
    namespace bwtr3_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// BWTR4 Register bits
    namespace bwtr4_bits {
        constexpr uint32_t ADDSET = (4 << 0);  ///< Address setup phase duration
        constexpr uint32_t ADDHLD = (4 << 4);  ///< Address-hold phase duration
        constexpr uint32_t DATAST = (8 << 8);  ///< Data-phase duration
        constexpr uint32_t BUSTURN = (4 << 16);  ///< Bus turnaround phase duration
        constexpr uint32_t ACCMOD = (2 << 28);  ///< Access mode
        constexpr uint32_t DATAHLD = (2 << 30);  ///< Data hold phase duration
    }

    /// PCSCNTR Register bits
    namespace pcscntr_bits {
        constexpr uint32_t CSCOUNT = (16 << 0);  ///< Chip select counter
        constexpr uint32_t CNTB1EN = (1U << 16);  ///< Counter Bank 1 enable
        constexpr uint32_t CNTB2EN = (1U << 17);  ///< Counter Bank 2 enable
        constexpr uint32_t CNTB3EN = (1U << 18);  ///< Counter Bank 3 enable
        constexpr uint32_t CNTB4EN = (1U << 19);  ///< Counter Bank 4 enable
    }

    /// PCR Register bits
    namespace pcr_bits {
        constexpr uint32_t PWAITEN = (1U << 1);  ///< Wait feature enable bit
        constexpr uint32_t PBKEN = (1U << 2);  ///< NAND Flash memory bank enable bit
        constexpr uint32_t PTYP = (1U << 3);  ///< Memory type
        constexpr uint32_t PWID = (2 << 4);  ///< Data bus width
        constexpr uint32_t ECCEN = (1U << 6);  ///< ECC computation logic enable bit
        constexpr uint32_t TCLR = (4 << 9);  ///< CLE to RE delay
        constexpr uint32_t TAR = (3 << 13);  ///< ALE to RE delay
        constexpr uint32_t ECCPS = (3 << 17);  ///< ECC page size
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t IRS = (1U << 0);  ///< Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
        constexpr uint32_t ILS = (1U << 1);  ///< Interrupt high-level status The flag is set by hardware and reset by software.
        constexpr uint32_t IFS = (1U << 2);  ///< Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
        constexpr uint32_t IREN = (1U << 3);  ///< Interrupt rising edge detection enable bit
        constexpr uint32_t ILEN = (1U << 4);  ///< Interrupt high-level detection enable bit
        constexpr uint32_t IFEN = (1U << 5);  ///< Interrupt falling edge detection enable bit
        constexpr uint32_t FEMPT = (1U << 6);  ///< FIFO empty. Read-only bit that provides the status of the FIFO
    }

    /// PMEM Register bits
    namespace pmem_bits {
        constexpr uint32_t MEMSET = (8 << 0);  ///< Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space:
        constexpr uint32_t MEMWAIT = (8 << 8);  ///< Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
        constexpr uint32_t MEMHOLD = (8 << 16);  ///< Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space:
        constexpr uint32_t MEMHIZ = (8 << 24);  ///< Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions:
    }

    /// PATT Register bits
    namespace patt_bits {
        constexpr uint32_t ATTSET = (8 << 0);  ///< Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
        constexpr uint32_t ATTWAIT = (8 << 8);  ///< Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
        constexpr uint32_t ATTHOLD = (8 << 16);  ///< Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
        constexpr uint32_t ATTHIZ = (8 << 24);  ///< Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction:
    }

    /// ECCR Register bits
    namespace eccr_bits {
        constexpr uint32_t ECC = (32 << 0);  ///< ECC result This field contains the value computed by the ECC computation logic. Table167 describes the contents of these bit fields.
    }

}

// ============================================================================
// GFXMMU Peripheral
// ============================================================================

namespace gfxmmu {
    /// Base addresses
    constexpr uint32_t GFXMMU_BASE = 0x4002C000;

    /// GFXMMU Register structure
    struct Registers {
        volatile uint32_t GFXMMU_CR;  ///< Offset: 0x00 - GFXMMU configuration register
        volatile uint32_t GFXMMU_SR;  ///< Offset: 0x04 - GFXMMU status register
        volatile uint32_t GFXMMU_FCR;  ///< Offset: 0x08 - GFXMMU flag clear register
        volatile uint32_t GFXMMU_CCR;  ///< Offset: 0x0C - GFXMMU cache control register
        volatile uint32_t GFXMMU_DVR;  ///< Offset: 0x10 - GFXMMU default value register
        volatile uint32_t GFXMMU_B0CR;  ///< Offset: 0x20 - GFXMMU buffer 0 configuration register
        volatile uint32_t GFXMMU_B1CR;  ///< Offset: 0x24 - GFXMMU buffer 1 configuration register
        volatile uint32_t GFXMMU_B2CR;  ///< Offset: 0x28 - GFXMMU buffer 2 configuration register
        volatile uint32_t GFXMMU_B3CR;  ///< Offset: 0x2C - GFXMMU buffer 3 configuration register
        volatile uint32_t GFXMMU_LUT0L;  ///< Offset: 0x1000 - GFXMMU LUT entry 0 low
        volatile uint32_t GFXMMU_LUT0H;  ///< Offset: 0x1004 - GFXMMU LUT entry 0 high
        volatile uint32_t GFXMMU_LUT1L;  ///< Offset: 0x1008 - GFXMMU LUT entry 1 low
        volatile uint32_t GFXMMU_LUT1H;  ///< Offset: 0x100C - GFXMMU LUT entry 1 high
        volatile uint32_t GFXMMU_LUT2L;  ///< Offset: 0x1010 - GFXMMU LUT entry 2 low
        volatile uint32_t GFXMMU_LUT2H;  ///< Offset: 0x1014 - GFXMMU LUT entry 2 high
        volatile uint32_t GFXMMU_LUT3L;  ///< Offset: 0x1018 - GFXMMU LUT entry 3 low
        volatile uint32_t GFXMMU_LUT3H;  ///< Offset: 0x101C - GFXMMU LUT entry 3 high
        volatile uint32_t GFXMMU_LUT4L;  ///< Offset: 0x1020 - GFXMMU LUT entry 4 low
        volatile uint32_t GFXMMU_LUT4H;  ///< Offset: 0x1024 - GFXMMU LUT entry 4 high
        volatile uint32_t GFXMMU_LUT5L;  ///< Offset: 0x1028 - GFXMMU LUT entry 5 low
        volatile uint32_t GFXMMU_LUT5H;  ///< Offset: 0x102C - GFXMMU LUT entry 5 high
        volatile uint32_t GFXMMU_LUT6L;  ///< Offset: 0x1030 - GFXMMU LUT entry 6 low
        volatile uint32_t GFXMMU_LUT6H;  ///< Offset: 0x1034 - GFXMMU LUT entry 6 high
        volatile uint32_t GFXMMU_LUT7L;  ///< Offset: 0x1038 - GFXMMU LUT entry 7 low
        volatile uint32_t GFXMMU_LUT7H;  ///< Offset: 0x103C - GFXMMU LUT entry 7 high
        volatile uint32_t GFXMMU_LUT8L;  ///< Offset: 0x1040 - GFXMMU LUT entry 8 low
        volatile uint32_t GFXMMU_LUT8H;  ///< Offset: 0x1044 - GFXMMU LUT entry 8 high
        volatile uint32_t GFXMMU_LUT9L;  ///< Offset: 0x1048 - GFXMMU LUT entry 9 low
        volatile uint32_t GFXMMU_LUT9H;  ///< Offset: 0x104C - GFXMMU LUT entry 9 high
        volatile uint32_t GFXMMU_LUT10L;  ///< Offset: 0x1050 - GFXMMU LUT entry 10 low
        volatile uint32_t GFXMMU_LUT10H;  ///< Offset: 0x1054 - GFXMMU LUT entry 10 high
        volatile uint32_t GFXMMU_LUT11L;  ///< Offset: 0x1058 - GFXMMU LUT entry 11 low
        volatile uint32_t GFXMMU_LUT11H;  ///< Offset: 0x105C - GFXMMU LUT entry 11 high
        volatile uint32_t GFXMMU_LUT12L;  ///< Offset: 0x1060 - GFXMMU LUT entry 12 low
        volatile uint32_t GFXMMU_LUT12H;  ///< Offset: 0x1064 - GFXMMU LUT entry 12 high
        volatile uint32_t GFXMMU_LUT13L;  ///< Offset: 0x1068 - GFXMMU LUT entry 13 low
        volatile uint32_t GFXMMU_LUT13H;  ///< Offset: 0x106C - GFXMMU LUT entry 13 high
        volatile uint32_t GFXMMU_LUT14L;  ///< Offset: 0x1070 - GFXMMU LUT entry 14 low
        volatile uint32_t GFXMMU_LUT14H;  ///< Offset: 0x1074 - GFXMMU LUT entry 14 high
        volatile uint32_t GFXMMU_LUT15L;  ///< Offset: 0x1078 - GFXMMU LUT entry 15 low
        volatile uint32_t GFXMMU_LUT15H;  ///< Offset: 0x107C - GFXMMU LUT entry 15 high
        volatile uint32_t GFXMMU_LUT16L;  ///< Offset: 0x1080 - GFXMMU LUT entry 16 low
        volatile uint32_t GFXMMU_LUT16H;  ///< Offset: 0x1084 - GFXMMU LUT entry 16 high
        volatile uint32_t GFXMMU_LUT17L;  ///< Offset: 0x1088 - GFXMMU LUT entry 17 low
        volatile uint32_t GFXMMU_LUT17H;  ///< Offset: 0x108C - GFXMMU LUT entry 17 high
        volatile uint32_t GFXMMU_LUT18L;  ///< Offset: 0x1090 - GFXMMU LUT entry 18 low
        volatile uint32_t GFXMMU_LUT18H;  ///< Offset: 0x1094 - GFXMMU LUT entry 18 high
        volatile uint32_t GFXMMU_LUT19L;  ///< Offset: 0x1098 - GFXMMU LUT entry 19 low
        volatile uint32_t GFXMMU_LUT19H;  ///< Offset: 0x109C - GFXMMU LUT entry 19 high
        volatile uint32_t GFXMMU_LUT20L;  ///< Offset: 0x10A0 - GFXMMU LUT entry 20 low
        volatile uint32_t GFXMMU_LUT20H;  ///< Offset: 0x10A4 - GFXMMU LUT entry 20 high
        volatile uint32_t GFXMMU_LUT21L;  ///< Offset: 0x10A8 - GFXMMU LUT entry 21 low
        volatile uint32_t GFXMMU_LUT21H;  ///< Offset: 0x10AC - GFXMMU LUT entry 21 high
        volatile uint32_t GFXMMU_LUT22L;  ///< Offset: 0x10B0 - GFXMMU LUT entry 22 low
        volatile uint32_t GFXMMU_LUT22H;  ///< Offset: 0x10B4 - GFXMMU LUT entry 22 high
        volatile uint32_t GFXMMU_LUT23L;  ///< Offset: 0x10B8 - GFXMMU LUT entry 23 low
        volatile uint32_t GFXMMU_LUT23H;  ///< Offset: 0x10BC - GFXMMU LUT entry 23 high
        volatile uint32_t GFXMMU_LUT24L;  ///< Offset: 0x10C0 - GFXMMU LUT entry 24 low
        volatile uint32_t GFXMMU_LUT24H;  ///< Offset: 0x10C4 - GFXMMU LUT entry 24 high
        volatile uint32_t GFXMMU_LUT25L;  ///< Offset: 0x10C8 - GFXMMU LUT entry 25 low
        volatile uint32_t GFXMMU_LUT25H;  ///< Offset: 0x10CC - GFXMMU LUT entry 25 high
        volatile uint32_t GFXMMU_LUT26L;  ///< Offset: 0x10D0 - GFXMMU LUT entry 26 low
        volatile uint32_t GFXMMU_LUT26H;  ///< Offset: 0x10D4 - GFXMMU LUT entry 26 high
        volatile uint32_t GFXMMU_LUT27L;  ///< Offset: 0x10D8 - GFXMMU LUT entry 27 low
        volatile uint32_t GFXMMU_LUT27H;  ///< Offset: 0x10DC - GFXMMU LUT entry 27 high
        volatile uint32_t GFXMMU_LUT28L;  ///< Offset: 0x10E0 - GFXMMU LUT entry 28 low
        volatile uint32_t GFXMMU_LUT28H;  ///< Offset: 0x10E4 - GFXMMU LUT entry 28 high
        volatile uint32_t GFXMMU_LUT29L;  ///< Offset: 0x10E8 - GFXMMU LUT entry 29 low
        volatile uint32_t GFXMMU_LUT29H;  ///< Offset: 0x10EC - GFXMMU LUT entry 29 high
        volatile uint32_t GFXMMU_LUT30L;  ///< Offset: 0x10F0 - GFXMMU LUT entry 30 low
        volatile uint32_t GFXMMU_LUT30H;  ///< Offset: 0x10F4 - GFXMMU LUT entry 30 high
        volatile uint32_t GFXMMU_LUT31L;  ///< Offset: 0x10F8 - GFXMMU LUT entry 31 low
        volatile uint32_t GFXMMU_LUT31H;  ///< Offset: 0x10FC - GFXMMU LUT entry 31 high
        volatile uint32_t GFXMMU_LUT32L;  ///< Offset: 0x1100 - GFXMMU LUT entry 32 low
        volatile uint32_t GFXMMU_LUT32H;  ///< Offset: 0x1104 - GFXMMU LUT entry 32 high
        volatile uint32_t GFXMMU_LUT33L;  ///< Offset: 0x1108 - GFXMMU LUT entry 33 low
        volatile uint32_t GFXMMU_LUT33H;  ///< Offset: 0x110C - GFXMMU LUT entry 33 high
        volatile uint32_t GFXMMU_LUT34L;  ///< Offset: 0x1110 - GFXMMU LUT entry 34 low
        volatile uint32_t GFXMMU_LUT34H;  ///< Offset: 0x1114 - GFXMMU LUT entry 34 high
        volatile uint32_t GFXMMU_LUT35L;  ///< Offset: 0x1118 - GFXMMU LUT entry 35 low
        volatile uint32_t GFXMMU_LUT35H;  ///< Offset: 0x111C - GFXMMU LUT entry 35 high
        volatile uint32_t GFXMMU_LUT36L;  ///< Offset: 0x1120 - GFXMMU LUT entry 36 low
        volatile uint32_t GFXMMU_LUT36H;  ///< Offset: 0x1124 - GFXMMU LUT entry 36 high
        volatile uint32_t GFXMMU_LUT37L;  ///< Offset: 0x1128 - GFXMMU LUT entry 37 low
        volatile uint32_t GFXMMU_LUT37H;  ///< Offset: 0x112C - GFXMMU LUT entry 37 high
        volatile uint32_t GFXMMU_LUT38L;  ///< Offset: 0x1130 - GFXMMU LUT entry 38 low
        volatile uint32_t GFXMMU_LUT38H;  ///< Offset: 0x1134 - GFXMMU LUT entry 38 high
        volatile uint32_t GFXMMU_LUT39L;  ///< Offset: 0x1138 - GFXMMU LUT entry 39 low
        volatile uint32_t GFXMMU_LUT39H;  ///< Offset: 0x113C - GFXMMU LUT entry 39 high
        volatile uint32_t GFXMMU_LUT40L;  ///< Offset: 0x1140 - GFXMMU LUT entry 40 low
        volatile uint32_t GFXMMU_LUT40H;  ///< Offset: 0x1144 - GFXMMU LUT entry 40 high
        volatile uint32_t GFXMMU_LUT41L;  ///< Offset: 0x1148 - GFXMMU LUT entry 41 low
        volatile uint32_t GFXMMU_LUT41H;  ///< Offset: 0x114C - GFXMMU LUT entry 41 high
        volatile uint32_t GFXMMU_LUT42L;  ///< Offset: 0x1150 - GFXMMU LUT entry 42 low
        volatile uint32_t GFXMMU_LUT42H;  ///< Offset: 0x1154 - GFXMMU LUT entry 42 high
        volatile uint32_t GFXMMU_LUT43L;  ///< Offset: 0x1158 - GFXMMU LUT entry 43 low
        volatile uint32_t GFXMMU_LUT43H;  ///< Offset: 0x115C - GFXMMU LUT entry 43 high
        volatile uint32_t GFXMMU_LUT44L;  ///< Offset: 0x1160 - GFXMMU LUT entry 44 low
        volatile uint32_t GFXMMU_LUT44H;  ///< Offset: 0x1164 - GFXMMU LUT entry 44 high
        volatile uint32_t GFXMMU_LUT45L;  ///< Offset: 0x1168 - GFXMMU LUT entry 45 low
        volatile uint32_t GFXMMU_LUT45H;  ///< Offset: 0x116C - GFXMMU LUT entry 45 high
        volatile uint32_t GFXMMU_LUT46L;  ///< Offset: 0x1170 - GFXMMU LUT entry 46 low
        volatile uint32_t GFXMMU_LUT46H;  ///< Offset: 0x1174 - GFXMMU LUT entry 46 high
        volatile uint32_t GFXMMU_LUT47L;  ///< Offset: 0x1178 - GFXMMU LUT entry 47 low
        volatile uint32_t GFXMMU_LUT47H;  ///< Offset: 0x117C - GFXMMU LUT entry 47 high
        volatile uint32_t GFXMMU_LUT48L;  ///< Offset: 0x1180 - GFXMMU LUT entry 48 low
        volatile uint32_t GFXMMU_LUT48H;  ///< Offset: 0x1184 - GFXMMU LUT entry 48 high
        volatile uint32_t GFXMMU_LUT49L;  ///< Offset: 0x1188 - GFXMMU LUT entry 49 low
        volatile uint32_t GFXMMU_LUT49H;  ///< Offset: 0x118C - GFXMMU LUT entry 49 high
        volatile uint32_t GFXMMU_LUT50L;  ///< Offset: 0x1190 - GFXMMU LUT entry 50 low
        volatile uint32_t GFXMMU_LUT50H;  ///< Offset: 0x1194 - GFXMMU LUT entry 50 high
        volatile uint32_t GFXMMU_LUT51L;  ///< Offset: 0x1198 - GFXMMU LUT entry 51 low
        volatile uint32_t GFXMMU_LUT51H;  ///< Offset: 0x119C - GFXMMU LUT entry 51 high
        volatile uint32_t GFXMMU_LUT52L;  ///< Offset: 0x11A0 - GFXMMU LUT entry 52 low
        volatile uint32_t GFXMMU_LUT52H;  ///< Offset: 0x11A4 - GFXMMU LUT entry 52 high
        volatile uint32_t GFXMMU_LUT53L;  ///< Offset: 0x11A8 - GFXMMU LUT entry 53 low
        volatile uint32_t GFXMMU_LUT53H;  ///< Offset: 0x11AC - GFXMMU LUT entry 53 high
        volatile uint32_t GFXMMU_LUT54L;  ///< Offset: 0x11B0 - GFXMMU LUT entry 54 low
        volatile uint32_t GFXMMU_LUT54H;  ///< Offset: 0x11B4 - GFXMMU LUT entry 54 high
        volatile uint32_t GFXMMU_LUT55L;  ///< Offset: 0x11B8 - GFXMMU LUT entry 55 low
        volatile uint32_t GFXMMU_LUT55H;  ///< Offset: 0x11BC - GFXMMU LUT entry 55 high
        volatile uint32_t GFXMMU_LUT56L;  ///< Offset: 0x11C0 - GFXMMU LUT entry 56 low
        volatile uint32_t GFXMMU_LUT56H;  ///< Offset: 0x11C4 - GFXMMU LUT entry 56 high
        volatile uint32_t GFXMMU_LUT57L;  ///< Offset: 0x11C8 - GFXMMU LUT entry 57 low
        volatile uint32_t GFXMMU_LUT57H;  ///< Offset: 0x11CC - GFXMMU LUT entry 57 high
        volatile uint32_t GFXMMU_LUT58L;  ///< Offset: 0x11D0 - GFXMMU LUT entry 58 low
        volatile uint32_t GFXMMU_LUT58H;  ///< Offset: 0x11D4 - GFXMMU LUT entry 58 high
        volatile uint32_t GFXMMU_LUT59L;  ///< Offset: 0x11D8 - GFXMMU LUT entry 59 low
        volatile uint32_t GFXMMU_LUT59H;  ///< Offset: 0x11DC - GFXMMU LUT entry 59 high
        volatile uint32_t GFXMMU_LUT60L;  ///< Offset: 0x11E0 - GFXMMU LUT entry 60 low
        volatile uint32_t GFXMMU_LUT60H;  ///< Offset: 0x11E4 - GFXMMU LUT entry 60 high
        volatile uint32_t GFXMMU_LUT61L;  ///< Offset: 0x11E8 - GFXMMU LUT entry 61 low
        volatile uint32_t GFXMMU_LUT61H;  ///< Offset: 0x11EC - GFXMMU LUT entry 61 high
        volatile uint32_t GFXMMU_LUT62L;  ///< Offset: 0x11F0 - GFXMMU LUT entry 62 low
        volatile uint32_t GFXMMU_LUT62H;  ///< Offset: 0x11F4 - GFXMMU LUT entry 62 high
        volatile uint32_t GFXMMU_LUT63L;  ///< Offset: 0x11F8 - GFXMMU LUT entry 63 low
        volatile uint32_t GFXMMU_LUT63H;  ///< Offset: 0x11FC - GFXMMU LUT entry 63 high
        volatile uint32_t GFXMMU_LUT64L;  ///< Offset: 0x1200 - GFXMMU LUT entry 64 low
        volatile uint32_t GFXMMU_LUT64H;  ///< Offset: 0x1204 - GFXMMU LUT entry 64 high
        volatile uint32_t GFXMMU_LUT65L;  ///< Offset: 0x1208 - GFXMMU LUT entry 65 low
        volatile uint32_t GFXMMU_LUT65H;  ///< Offset: 0x120C - GFXMMU LUT entry 65 high
        volatile uint32_t GFXMMU_LUT66L;  ///< Offset: 0x1210 - GFXMMU LUT entry 66 low
        volatile uint32_t GFXMMU_LUT66H;  ///< Offset: 0x1214 - GFXMMU LUT entry 66 high
        volatile uint32_t GFXMMU_LUT67L;  ///< Offset: 0x1218 - GFXMMU LUT entry 67 low
        volatile uint32_t GFXMMU_LUT67H;  ///< Offset: 0x121C - GFXMMU LUT entry 67 high
        volatile uint32_t GFXMMU_LUT68L;  ///< Offset: 0x1220 - GFXMMU LUT entry 68 low
        volatile uint32_t GFXMMU_LUT68H;  ///< Offset: 0x1224 - GFXMMU LUT entry 68 high
        volatile uint32_t GFXMMU_LUT69L;  ///< Offset: 0x1228 - GFXMMU LUT entry 69 low
        volatile uint32_t GFXMMU_LUT69H;  ///< Offset: 0x122C - GFXMMU LUT entry 69 high
        volatile uint32_t GFXMMU_LUT70L;  ///< Offset: 0x1230 - GFXMMU LUT entry 70 low
        volatile uint32_t GFXMMU_LUT70H;  ///< Offset: 0x1234 - GFXMMU LUT entry 70 high
        volatile uint32_t GFXMMU_LUT71L;  ///< Offset: 0x1238 - GFXMMU LUT entry 71 low
        volatile uint32_t GFXMMU_LUT71H;  ///< Offset: 0x123C - GFXMMU LUT entry 71 high
        volatile uint32_t GFXMMU_LUT72L;  ///< Offset: 0x1240 - GFXMMU LUT entry 72 low
        volatile uint32_t GFXMMU_LUT72H;  ///< Offset: 0x1244 - GFXMMU LUT entry 72 high
        volatile uint32_t GFXMMU_LUT73L;  ///< Offset: 0x1248 - GFXMMU LUT entry 73 low
        volatile uint32_t GFXMMU_LUT73H;  ///< Offset: 0x124C - GFXMMU LUT entry 73 high
        volatile uint32_t GFXMMU_LUT74L;  ///< Offset: 0x1250 - GFXMMU LUT entry 74 low
        volatile uint32_t GFXMMU_LUT74H;  ///< Offset: 0x1254 - GFXMMU LUT entry 74 high
        volatile uint32_t GFXMMU_LUT75L;  ///< Offset: 0x1258 - GFXMMU LUT entry 75 low
        volatile uint32_t GFXMMU_LUT75H;  ///< Offset: 0x125C - GFXMMU LUT entry 75 high
        volatile uint32_t GFXMMU_LUT76L;  ///< Offset: 0x1260 - GFXMMU LUT entry 76 low
        volatile uint32_t GFXMMU_LUT76H;  ///< Offset: 0x1264 - GFXMMU LUT entry 76 high
        volatile uint32_t GFXMMU_LUT77L;  ///< Offset: 0x1268 - GFXMMU LUT entry 77 low
        volatile uint32_t GFXMMU_LUT77H;  ///< Offset: 0x126C - GFXMMU LUT entry 77 high
        volatile uint32_t GFXMMU_LUT78L;  ///< Offset: 0x1270 - GFXMMU LUT entry 78 low
        volatile uint32_t GFXMMU_LUT78H;  ///< Offset: 0x1274 - GFXMMU LUT entry 78 high
        volatile uint32_t GFXMMU_LUT79L;  ///< Offset: 0x1278 - GFXMMU LUT entry 79 low
        volatile uint32_t GFXMMU_LUT79H;  ///< Offset: 0x127C - GFXMMU LUT entry 79 high
        volatile uint32_t GFXMMU_LUT80L;  ///< Offset: 0x1280 - GFXMMU LUT entry 80 low
        volatile uint32_t GFXMMU_LUT80H;  ///< Offset: 0x1284 - GFXMMU LUT entry 80 high
        volatile uint32_t GFXMMU_LUT81L;  ///< Offset: 0x1288 - GFXMMU LUT entry 81 low
        volatile uint32_t GFXMMU_LUT81H;  ///< Offset: 0x128C - GFXMMU LUT entry 81 high
        volatile uint32_t GFXMMU_LUT82L;  ///< Offset: 0x1290 - GFXMMU LUT entry 82 low
        volatile uint32_t GFXMMU_LUT82H;  ///< Offset: 0x1294 - GFXMMU LUT entry 82 high
        volatile uint32_t GFXMMU_LUT83L;  ///< Offset: 0x1298 - GFXMMU LUT entry 83 low
        volatile uint32_t GFXMMU_LUT83H;  ///< Offset: 0x129C - GFXMMU LUT entry 83 high
        volatile uint32_t GFXMMU_LUT84L;  ///< Offset: 0x12A0 - GFXMMU LUT entry 84 low
        volatile uint32_t GFXMMU_LUT84H;  ///< Offset: 0x12A4 - GFXMMU LUT entry 84 high
        volatile uint32_t GFXMMU_LUT85L;  ///< Offset: 0x12A8 - GFXMMU LUT entry 85 low
        volatile uint32_t GFXMMU_LUT85H;  ///< Offset: 0x12AC - GFXMMU LUT entry 85 high
        volatile uint32_t GFXMMU_LUT86L;  ///< Offset: 0x12B0 - GFXMMU LUT entry 86 low
        volatile uint32_t GFXMMU_LUT86H;  ///< Offset: 0x12B4 - GFXMMU LUT entry 86 high
        volatile uint32_t GFXMMU_LUT87L;  ///< Offset: 0x12B8 - GFXMMU LUT entry 87 low
        volatile uint32_t GFXMMU_LUT87H;  ///< Offset: 0x12BC - GFXMMU LUT entry 87 high
        volatile uint32_t GFXMMU_LUT88L;  ///< Offset: 0x12C0 - GFXMMU LUT entry 88 low
        volatile uint32_t GFXMMU_LUT88H;  ///< Offset: 0x12C4 - GFXMMU LUT entry 88 high
        volatile uint32_t GFXMMU_LUT89L;  ///< Offset: 0x12C8 - GFXMMU LUT entry 89 low
        volatile uint32_t GFXMMU_LUT89H;  ///< Offset: 0x12CC - GFXMMU LUT entry 89 high
        volatile uint32_t GFXMMU_LUT90L;  ///< Offset: 0x12D0 - GFXMMU LUT entry 90 low
        volatile uint32_t GFXMMU_LUT90H;  ///< Offset: 0x12D4 - GFXMMU LUT entry 90 high
        volatile uint32_t GFXMMU_LUT91L;  ///< Offset: 0x12D8 - GFXMMU LUT entry 91 low
        volatile uint32_t GFXMMU_LUT91H;  ///< Offset: 0x12DC - GFXMMU LUT entry 91 high
        volatile uint32_t GFXMMU_LUT92L;  ///< Offset: 0x12E0 - GFXMMU LUT entry 92 low
        volatile uint32_t GFXMMU_LUT92H;  ///< Offset: 0x12E4 - GFXMMU LUT entry 92 high
        volatile uint32_t GFXMMU_LUT93L;  ///< Offset: 0x12E8 - GFXMMU LUT entry 93 low
        volatile uint32_t GFXMMU_LUT93H;  ///< Offset: 0x12EC - GFXMMU LUT entry 93 high
        volatile uint32_t GFXMMU_LUT94L;  ///< Offset: 0x12F0 - GFXMMU LUT entry 94 low
        volatile uint32_t GFXMMU_LUT94H;  ///< Offset: 0x12F4 - GFXMMU LUT entry 94 high
        volatile uint32_t GFXMMU_LUT95L;  ///< Offset: 0x12F8 - GFXMMU LUT entry 95 low
        volatile uint32_t GFXMMU_LUT95H;  ///< Offset: 0x12FC - GFXMMU LUT entry 95 high
        volatile uint32_t GFXMMU_LUT96L;  ///< Offset: 0x1300 - GFXMMU LUT entry 96 low
        volatile uint32_t GFXMMU_LUT96H;  ///< Offset: 0x1304 - GFXMMU LUT entry 96 high
        volatile uint32_t GFXMMU_LUT97L;  ///< Offset: 0x1308 - GFXMMU LUT entry 97 low
        volatile uint32_t GFXMMU_LUT97H;  ///< Offset: 0x130C - GFXMMU LUT entry 97 high
        volatile uint32_t GFXMMU_LUT98L;  ///< Offset: 0x1310 - GFXMMU LUT entry 98 low
        volatile uint32_t GFXMMU_LUT98H;  ///< Offset: 0x1314 - GFXMMU LUT entry 98 high
        volatile uint32_t GFXMMU_LUT99L;  ///< Offset: 0x1318 - GFXMMU LUT entry 99 low
        volatile uint32_t GFXMMU_LUT99H;  ///< Offset: 0x131C - GFXMMU LUT entry 99 high
        volatile uint32_t GFXMMU_LUT100L;  ///< Offset: 0x1320 - GFXMMU LUT entry 100 low
        volatile uint32_t GFXMMU_LUT100H;  ///< Offset: 0x1324 - GFXMMU LUT entry 100 high
        volatile uint32_t GFXMMU_LUT101L;  ///< Offset: 0x1328 - GFXMMU LUT entry 101 low
        volatile uint32_t GFXMMU_LUT101H;  ///< Offset: 0x132C - GFXMMU LUT entry 101 high
        volatile uint32_t GFXMMU_LUT102L;  ///< Offset: 0x1330 - GFXMMU LUT entry 102 low
        volatile uint32_t GFXMMU_LUT102H;  ///< Offset: 0x1334 - GFXMMU LUT entry 102 high
        volatile uint32_t GFXMMU_LUT103L;  ///< Offset: 0x1338 - GFXMMU LUT entry 103 low
        volatile uint32_t GFXMMU_LUT103H;  ///< Offset: 0x133C - GFXMMU LUT entry 103 high
        volatile uint32_t GFXMMU_LUT104L;  ///< Offset: 0x1340 - GFXMMU LUT entry 104 low
        volatile uint32_t GFXMMU_LUT104H;  ///< Offset: 0x1344 - GFXMMU LUT entry 104 high
        volatile uint32_t GFXMMU_LUT105L;  ///< Offset: 0x1348 - GFXMMU LUT entry 105 low
        volatile uint32_t GFXMMU_LUT105H;  ///< Offset: 0x134C - GFXMMU LUT entry 105 high
        volatile uint32_t GFXMMU_LUT106L;  ///< Offset: 0x1350 - GFXMMU LUT entry 106 low
        volatile uint32_t GFXMMU_LUT106H;  ///< Offset: 0x1354 - GFXMMU LUT entry 106 high
        volatile uint32_t GFXMMU_LUT107L;  ///< Offset: 0x1358 - GFXMMU LUT entry 107 low
        volatile uint32_t GFXMMU_LUT107H;  ///< Offset: 0x135C - GFXMMU LUT entry 107 high
        volatile uint32_t GFXMMU_LUT108L;  ///< Offset: 0x1360 - GFXMMU LUT entry 108 low
        volatile uint32_t GFXMMU_LUT108H;  ///< Offset: 0x1364 - GFXMMU LUT entry 108 high
        volatile uint32_t GFXMMU_LUT109L;  ///< Offset: 0x1368 - GFXMMU LUT entry 109 low
        volatile uint32_t GFXMMU_LUT109H;  ///< Offset: 0x136C - GFXMMU LUT entry 109 high
        volatile uint32_t GFXMMU_LUT110L;  ///< Offset: 0x1370 - GFXMMU LUT entry 110 low
        volatile uint32_t GFXMMU_LUT110H;  ///< Offset: 0x1374 - GFXMMU LUT entry 110 high
        volatile uint32_t GFXMMU_LUT111L;  ///< Offset: 0x1378 - GFXMMU LUT entry 111 low
        volatile uint32_t GFXMMU_LUT111H;  ///< Offset: 0x137C - GFXMMU LUT entry 111 high
        volatile uint32_t GFXMMU_LUT112L;  ///< Offset: 0x1380 - GFXMMU LUT entry 112 low
        volatile uint32_t GFXMMU_LUT112H;  ///< Offset: 0x1384 - GFXMMU LUT entry 112 high
        volatile uint32_t GFXMMU_LUT113L;  ///< Offset: 0x1388 - GFXMMU LUT entry 113 low
        volatile uint32_t GFXMMU_LUT113H;  ///< Offset: 0x138C - GFXMMU LUT entry 113 high
        volatile uint32_t GFXMMU_LUT114L;  ///< Offset: 0x1390 - GFXMMU LUT entry 114 low
        volatile uint32_t GFXMMU_LUT114H;  ///< Offset: 0x1394 - GFXMMU LUT entry 114 high
        volatile uint32_t GFXMMU_LUT115L;  ///< Offset: 0x1398 - GFXMMU LUT entry 115 low
        volatile uint32_t GFXMMU_LUT115H;  ///< Offset: 0x139C - GFXMMU LUT entry 115 high
        volatile uint32_t GFXMMU_LUT116L;  ///< Offset: 0x13A0 - GFXMMU LUT entry 116 low
        volatile uint32_t GFXMMU_LUT116H;  ///< Offset: 0x13A4 - GFXMMU LUT entry 116 high
        volatile uint32_t GFXMMU_LUT117L;  ///< Offset: 0x13A8 - GFXMMU LUT entry 117 low
        volatile uint32_t GFXMMU_LUT117H;  ///< Offset: 0x13AC - GFXMMU LUT entry 117 high
        volatile uint32_t GFXMMU_LUT118L;  ///< Offset: 0x13B0 - GFXMMU LUT entry 118 low
        volatile uint32_t GFXMMU_LUT118H;  ///< Offset: 0x13B4 - GFXMMU LUT entry 118 high
        volatile uint32_t GFXMMU_LUT119L;  ///< Offset: 0x13B8 - GFXMMU LUT entry 119 low
        volatile uint32_t GFXMMU_LUT119H;  ///< Offset: 0x13BC - GFXMMU LUT entry 119 high
        volatile uint32_t GFXMMU_LUT120L;  ///< Offset: 0x13C0 - GFXMMU LUT entry 120 low
        volatile uint32_t GFXMMU_LUT120H;  ///< Offset: 0x13C4 - GFXMMU LUT entry 120 high
        volatile uint32_t GFXMMU_LUT121L;  ///< Offset: 0x13C8 - GFXMMU LUT entry 121 low
        volatile uint32_t GFXMMU_LUT121H;  ///< Offset: 0x13CC - GFXMMU LUT entry 121 high
        volatile uint32_t GFXMMU_LUT122L;  ///< Offset: 0x13D0 - GFXMMU LUT entry 122 low
        volatile uint32_t GFXMMU_LUT122H;  ///< Offset: 0x13D4 - GFXMMU LUT entry 122 high
        volatile uint32_t GFXMMU_LUT123L;  ///< Offset: 0x13D8 - GFXMMU LUT entry 123 low
        volatile uint32_t GFXMMU_LUT123H;  ///< Offset: 0x13DC - GFXMMU LUT entry 123 high
        volatile uint32_t GFXMMU_LUT124L;  ///< Offset: 0x13E0 - GFXMMU LUT entry 124 low
        volatile uint32_t GFXMMU_LUT124H;  ///< Offset: 0x13E4 - GFXMMU LUT entry 124 high
        volatile uint32_t GFXMMU_LUT125L;  ///< Offset: 0x13E8 - GFXMMU LUT entry 125 low
        volatile uint32_t GFXMMU_LUT125H;  ///< Offset: 0x13EC - GFXMMU LUT entry 125 high
        volatile uint32_t GFXMMU_LUT126L;  ///< Offset: 0x13F0 - GFXMMU LUT entry 126 low
        volatile uint32_t GFXMMU_LUT126H;  ///< Offset: 0x13F4 - GFXMMU LUT entry 126 high
        volatile uint32_t GFXMMU_LUT127L;  ///< Offset: 0x13F8 - GFXMMU LUT entry 127 low
        volatile uint32_t GFXMMU_LUT127H;  ///< Offset: 0x13FC - GFXMMU LUT entry 127 high
        volatile uint32_t GFXMMU_LUT128L;  ///< Offset: 0x1400 - GFXMMU LUT entry 128 low
        volatile uint32_t GFXMMU_LUT128H;  ///< Offset: 0x1404 - GFXMMU LUT entry 128 high
        volatile uint32_t GFXMMU_LUT129L;  ///< Offset: 0x1408 - GFXMMU LUT entry 129 low
        volatile uint32_t GFXMMU_LUT129H;  ///< Offset: 0x140C - GFXMMU LUT entry 129 high
        volatile uint32_t GFXMMU_LUT130L;  ///< Offset: 0x1410 - GFXMMU LUT entry 130 low
        volatile uint32_t GFXMMU_LUT130H;  ///< Offset: 0x1414 - GFXMMU LUT entry 130 high
        volatile uint32_t GFXMMU_LUT131L;  ///< Offset: 0x1418 - GFXMMU LUT entry 131 low
        volatile uint32_t GFXMMU_LUT131H;  ///< Offset: 0x141C - GFXMMU LUT entry 131 high
        volatile uint32_t GFXMMU_LUT132L;  ///< Offset: 0x1420 - GFXMMU LUT entry 132 low
        volatile uint32_t GFXMMU_LUT132H;  ///< Offset: 0x1424 - GFXMMU LUT entry 132 high
        volatile uint32_t GFXMMU_LUT133L;  ///< Offset: 0x1428 - GFXMMU LUT entry 133 low
        volatile uint32_t GFXMMU_LUT133H;  ///< Offset: 0x142C - GFXMMU LUT entry 133 high
        volatile uint32_t GFXMMU_LUT134L;  ///< Offset: 0x1430 - GFXMMU LUT entry 134 low
        volatile uint32_t GFXMMU_LUT134H;  ///< Offset: 0x1434 - GFXMMU LUT entry 134 high
        volatile uint32_t GFXMMU_LUT135L;  ///< Offset: 0x1438 - GFXMMU LUT entry 135 low
        volatile uint32_t GFXMMU_LUT135H;  ///< Offset: 0x143C - GFXMMU LUT entry 135 high
        volatile uint32_t GFXMMU_LUT136L;  ///< Offset: 0x1440 - GFXMMU LUT entry 136 low
        volatile uint32_t GFXMMU_LUT136H;  ///< Offset: 0x1444 - GFXMMU LUT entry 136 high
        volatile uint32_t GFXMMU_LUT137L;  ///< Offset: 0x1448 - GFXMMU LUT entry 137 low
        volatile uint32_t GFXMMU_LUT137H;  ///< Offset: 0x144C - GFXMMU LUT entry 137 high
        volatile uint32_t GFXMMU_LUT138L;  ///< Offset: 0x1450 - GFXMMU LUT entry 138 low
        volatile uint32_t GFXMMU_LUT138H;  ///< Offset: 0x1454 - GFXMMU LUT entry 138 high
        volatile uint32_t GFXMMU_LUT139L;  ///< Offset: 0x1458 - GFXMMU LUT entry 139 low
        volatile uint32_t GFXMMU_LUT139H;  ///< Offset: 0x145C - GFXMMU LUT entry 139 high
        volatile uint32_t GFXMMU_LUT140L;  ///< Offset: 0x1460 - GFXMMU LUT entry 140 low
        volatile uint32_t GFXMMU_LUT140H;  ///< Offset: 0x1464 - GFXMMU LUT entry 140 high
        volatile uint32_t GFXMMU_LUT141L;  ///< Offset: 0x1468 - GFXMMU LUT entry 141 low
        volatile uint32_t GFXMMU_LUT141H;  ///< Offset: 0x146C - GFXMMU LUT entry 141 high
        volatile uint32_t GFXMMU_LUT142L;  ///< Offset: 0x1470 - GFXMMU LUT entry 142 low
        volatile uint32_t GFXMMU_LUT142H;  ///< Offset: 0x1474 - GFXMMU LUT entry 142 high
        volatile uint32_t GFXMMU_LUT143L;  ///< Offset: 0x1478 - GFXMMU LUT entry 143 low
        volatile uint32_t GFXMMU_LUT143H;  ///< Offset: 0x147C - GFXMMU LUT entry 143 high
        volatile uint32_t GFXMMU_LUT144L;  ///< Offset: 0x1480 - GFXMMU LUT entry 144 low
        volatile uint32_t GFXMMU_LUT144H;  ///< Offset: 0x1484 - GFXMMU LUT entry 144 high
        volatile uint32_t GFXMMU_LUT145L;  ///< Offset: 0x1488 - GFXMMU LUT entry 145 low
        volatile uint32_t GFXMMU_LUT145H;  ///< Offset: 0x148C - GFXMMU LUT entry 145 high
        volatile uint32_t GFXMMU_LUT146L;  ///< Offset: 0x1490 - GFXMMU LUT entry 146 low
        volatile uint32_t GFXMMU_LUT146H;  ///< Offset: 0x1494 - GFXMMU LUT entry 146 high
        volatile uint32_t GFXMMU_LUT147L;  ///< Offset: 0x1498 - GFXMMU LUT entry 147 low
        volatile uint32_t GFXMMU_LUT147H;  ///< Offset: 0x149C - GFXMMU LUT entry 147 high
        volatile uint32_t GFXMMU_LUT148L;  ///< Offset: 0x14A0 - GFXMMU LUT entry 148 low
        volatile uint32_t GFXMMU_LUT148H;  ///< Offset: 0x14A4 - GFXMMU LUT entry 148 high
        volatile uint32_t GFXMMU_LUT149L;  ///< Offset: 0x14A8 - GFXMMU LUT entry 149 low
        volatile uint32_t GFXMMU_LUT149H;  ///< Offset: 0x14AC - GFXMMU LUT entry 149 high
        volatile uint32_t GFXMMU_LUT150L;  ///< Offset: 0x14B0 - GFXMMU LUT entry 150 low
        volatile uint32_t GFXMMU_LUT150H;  ///< Offset: 0x14B4 - GFXMMU LUT entry 150 high
        volatile uint32_t GFXMMU_LUT151L;  ///< Offset: 0x14B8 - GFXMMU LUT entry 151 low
        volatile uint32_t GFXMMU_LUT151H;  ///< Offset: 0x14BC - GFXMMU LUT entry 151 high
        volatile uint32_t GFXMMU_LUT152L;  ///< Offset: 0x14C0 - GFXMMU LUT entry 152 low
        volatile uint32_t GFXMMU_LUT152H;  ///< Offset: 0x14C4 - GFXMMU LUT entry 152 high
        volatile uint32_t GFXMMU_LUT153L;  ///< Offset: 0x14C8 - GFXMMU LUT entry 153 low
        volatile uint32_t GFXMMU_LUT153H;  ///< Offset: 0x14CC - GFXMMU LUT entry 153 high
        volatile uint32_t GFXMMU_LUT154L;  ///< Offset: 0x14D0 - GFXMMU LUT entry 154 low
        volatile uint32_t GFXMMU_LUT154H;  ///< Offset: 0x14D4 - GFXMMU LUT entry 154 high
        volatile uint32_t GFXMMU_LUT155L;  ///< Offset: 0x14D8 - GFXMMU LUT entry 155 low
        volatile uint32_t GFXMMU_LUT155H;  ///< Offset: 0x14DC - GFXMMU LUT entry 155 high
        volatile uint32_t GFXMMU_LUT156L;  ///< Offset: 0x14E0 - GFXMMU LUT entry 156 low
        volatile uint32_t GFXMMU_LUT156H;  ///< Offset: 0x14E4 - GFXMMU LUT entry 156 high
        volatile uint32_t GFXMMU_LUT157L;  ///< Offset: 0x14E8 - GFXMMU LUT entry 157 low
        volatile uint32_t GFXMMU_LUT157H;  ///< Offset: 0x14EC - GFXMMU LUT entry 157 high
        volatile uint32_t GFXMMU_LUT158L;  ///< Offset: 0x14F0 - GFXMMU LUT entry 158 low
        volatile uint32_t GFXMMU_LUT158H;  ///< Offset: 0x14F4 - GFXMMU LUT entry 158 high
        volatile uint32_t GFXMMU_LUT159L;  ///< Offset: 0x14F8 - GFXMMU LUT entry 159 low
        volatile uint32_t GFXMMU_LUT159H;  ///< Offset: 0x14FC - GFXMMU LUT entry 159 high
        volatile uint32_t GFXMMU_LUT160L;  ///< Offset: 0x1500 - GFXMMU LUT entry 160 low
        volatile uint32_t GFXMMU_LUT160H;  ///< Offset: 0x1504 - GFXMMU LUT entry 160 high
        volatile uint32_t GFXMMU_LUT161L;  ///< Offset: 0x1508 - GFXMMU LUT entry 161 low
        volatile uint32_t GFXMMU_LUT161H;  ///< Offset: 0x150C - GFXMMU LUT entry 161 high
        volatile uint32_t GFXMMU_LUT162L;  ///< Offset: 0x1510 - GFXMMU LUT entry 162 low
        volatile uint32_t GFXMMU_LUT162H;  ///< Offset: 0x1514 - GFXMMU LUT entry 162 high
        volatile uint32_t GFXMMU_LUT163L;  ///< Offset: 0x1518 - GFXMMU LUT entry 163 low
        volatile uint32_t GFXMMU_LUT163H;  ///< Offset: 0x151C - GFXMMU LUT entry 163 high
        volatile uint32_t GFXMMU_LUT164L;  ///< Offset: 0x1520 - GFXMMU LUT entry 164 low
        volatile uint32_t GFXMMU_LUT164H;  ///< Offset: 0x1524 - GFXMMU LUT entry 164 high
        volatile uint32_t GFXMMU_LUT165L;  ///< Offset: 0x1528 - GFXMMU LUT entry 165 low
        volatile uint32_t GFXMMU_LUT165H;  ///< Offset: 0x152C - GFXMMU LUT entry 165 high
        volatile uint32_t GFXMMU_LUT166L;  ///< Offset: 0x1530 - GFXMMU LUT entry 166 low
        volatile uint32_t GFXMMU_LUT166H;  ///< Offset: 0x1534 - GFXMMU LUT entry 166 high
        volatile uint32_t GFXMMU_LUT167L;  ///< Offset: 0x1538 - GFXMMU LUT entry 167 low
        volatile uint32_t GFXMMU_LUT167H;  ///< Offset: 0x153C - GFXMMU LUT entry 167 high
        volatile uint32_t GFXMMU_LUT168L;  ///< Offset: 0x1540 - GFXMMU LUT entry 168 low
        volatile uint32_t GFXMMU_LUT168H;  ///< Offset: 0x1544 - GFXMMU LUT entry 168 high
        volatile uint32_t GFXMMU_LUT169L;  ///< Offset: 0x1548 - GFXMMU LUT entry 169 low
        volatile uint32_t GFXMMU_LUT169H;  ///< Offset: 0x154C - GFXMMU LUT entry 169 high
        volatile uint32_t GFXMMU_LUT170L;  ///< Offset: 0x1550 - GFXMMU LUT entry 170 low
        volatile uint32_t GFXMMU_LUT170H;  ///< Offset: 0x1554 - GFXMMU LUT entry 170 high
        volatile uint32_t GFXMMU_LUT171L;  ///< Offset: 0x1558 - GFXMMU LUT entry 171 low
        volatile uint32_t GFXMMU_LUT171H;  ///< Offset: 0x155C - GFXMMU LUT entry 171 high
        volatile uint32_t GFXMMU_LUT172L;  ///< Offset: 0x1560 - GFXMMU LUT entry 172 low
        volatile uint32_t GFXMMU_LUT172H;  ///< Offset: 0x1564 - GFXMMU LUT entry 172 high
        volatile uint32_t GFXMMU_LUT173L;  ///< Offset: 0x1568 - GFXMMU LUT entry 173 low
        volatile uint32_t GFXMMU_LUT173H;  ///< Offset: 0x156C - GFXMMU LUT entry 173 high
        volatile uint32_t GFXMMU_LUT174L;  ///< Offset: 0x1570 - GFXMMU LUT entry 174 low
        volatile uint32_t GFXMMU_LUT174H;  ///< Offset: 0x1574 - GFXMMU LUT entry 174 high
        volatile uint32_t GFXMMU_LUT175L;  ///< Offset: 0x1578 - GFXMMU LUT entry 175 low
        volatile uint32_t GFXMMU_LUT175H;  ///< Offset: 0x157C - GFXMMU LUT entry 175 high
        volatile uint32_t GFXMMU_LUT176L;  ///< Offset: 0x1580 - GFXMMU LUT entry 176 low
        volatile uint32_t GFXMMU_LUT176H;  ///< Offset: 0x1584 - GFXMMU LUT entry 176 high
        volatile uint32_t GFXMMU_LUT177L;  ///< Offset: 0x1588 - GFXMMU LUT entry 177 low
        volatile uint32_t GFXMMU_LUT177H;  ///< Offset: 0x158C - GFXMMU LUT entry 177 high
        volatile uint32_t GFXMMU_LUT178L;  ///< Offset: 0x1590 - GFXMMU LUT entry 178 low
        volatile uint32_t GFXMMU_LUT178H;  ///< Offset: 0x1594 - GFXMMU LUT entry 178 high
        volatile uint32_t GFXMMU_LUT179L;  ///< Offset: 0x1598 - GFXMMU LUT entry 179 low
        volatile uint32_t GFXMMU_LUT179H;  ///< Offset: 0x159C - GFXMMU LUT entry 179 high
        volatile uint32_t GFXMMU_LUT180L;  ///< Offset: 0x15A0 - GFXMMU LUT entry 180 low
        volatile uint32_t GFXMMU_LUT180H;  ///< Offset: 0x15A4 - GFXMMU LUT entry 180 high
        volatile uint32_t GFXMMU_LUT181L;  ///< Offset: 0x15A8 - GFXMMU LUT entry 181 low
        volatile uint32_t GFXMMU_LUT181H;  ///< Offset: 0x15AC - GFXMMU LUT entry 181 high
        volatile uint32_t GFXMMU_LUT182L;  ///< Offset: 0x15B0 - GFXMMU LUT entry 182 low
        volatile uint32_t GFXMMU_LUT182H;  ///< Offset: 0x15B4 - GFXMMU LUT entry 182 high
        volatile uint32_t GFXMMU_LUT183L;  ///< Offset: 0x15B8 - GFXMMU LUT entry 183 low
        volatile uint32_t GFXMMU_LUT183H;  ///< Offset: 0x15BC - GFXMMU LUT entry 183 high
        volatile uint32_t GFXMMU_LUT184L;  ///< Offset: 0x15C0 - GFXMMU LUT entry 184 low
        volatile uint32_t GFXMMU_LUT184H;  ///< Offset: 0x15C4 - GFXMMU LUT entry 184 high
        volatile uint32_t GFXMMU_LUT185L;  ///< Offset: 0x15C8 - GFXMMU LUT entry 185 low
        volatile uint32_t GFXMMU_LUT185H;  ///< Offset: 0x15CC - GFXMMU LUT entry 185 high
        volatile uint32_t GFXMMU_LUT186L;  ///< Offset: 0x15D0 - GFXMMU LUT entry 186 low
        volatile uint32_t GFXMMU_LUT186H;  ///< Offset: 0x15D4 - GFXMMU LUT entry 186 high
        volatile uint32_t GFXMMU_LUT187L;  ///< Offset: 0x15D8 - GFXMMU LUT entry 187 low
        volatile uint32_t GFXMMU_LUT187H;  ///< Offset: 0x15DC - GFXMMU LUT entry 187 high
        volatile uint32_t GFXMMU_LUT188L;  ///< Offset: 0x15E0 - GFXMMU LUT entry 188 low
        volatile uint32_t GFXMMU_LUT188H;  ///< Offset: 0x15E4 - GFXMMU LUT entry 188 high
        volatile uint32_t GFXMMU_LUT189L;  ///< Offset: 0x15E8 - GFXMMU LUT entry 189 low
        volatile uint32_t GFXMMU_LUT189H;  ///< Offset: 0x15EC - GFXMMU LUT entry 189 high
        volatile uint32_t GFXMMU_LUT190L;  ///< Offset: 0x15F0 - GFXMMU LUT entry 190 low
        volatile uint32_t GFXMMU_LUT190H;  ///< Offset: 0x15F4 - GFXMMU LUT entry 190 high
        volatile uint32_t GFXMMU_LUT191L;  ///< Offset: 0x15F8 - GFXMMU LUT entry 191 low
        volatile uint32_t GFXMMU_LUT191H;  ///< Offset: 0x15FC - GFXMMU LUT entry 191 high
        volatile uint32_t GFXMMU_LUT192L;  ///< Offset: 0x1600 - GFXMMU LUT entry 192 low
        volatile uint32_t GFXMMU_LUT192H;  ///< Offset: 0x1604 - GFXMMU LUT entry 192 high
        volatile uint32_t GFXMMU_LUT193L;  ///< Offset: 0x1608 - GFXMMU LUT entry 193 low
        volatile uint32_t GFXMMU_LUT193H;  ///< Offset: 0x160C - GFXMMU LUT entry 193 high
        volatile uint32_t GFXMMU_LUT194L;  ///< Offset: 0x1610 - GFXMMU LUT entry 194 low
        volatile uint32_t GFXMMU_LUT194H;  ///< Offset: 0x1614 - GFXMMU LUT entry 194 high
        volatile uint32_t GFXMMU_LUT195L;  ///< Offset: 0x1618 - GFXMMU LUT entry 195 low
        volatile uint32_t GFXMMU_LUT195H;  ///< Offset: 0x161C - GFXMMU LUT entry 195 high
        volatile uint32_t GFXMMU_LUT196L;  ///< Offset: 0x1620 - GFXMMU LUT entry 196 low
        volatile uint32_t GFXMMU_LUT196H;  ///< Offset: 0x1624 - GFXMMU LUT entry 196 high
        volatile uint32_t GFXMMU_LUT197L;  ///< Offset: 0x1628 - GFXMMU LUT entry 197 low
        volatile uint32_t GFXMMU_LUT197H;  ///< Offset: 0x162C - GFXMMU LUT entry 197 high
        volatile uint32_t GFXMMU_LUT198L;  ///< Offset: 0x1630 - GFXMMU LUT entry 198 low
        volatile uint32_t GFXMMU_LUT198H;  ///< Offset: 0x1634 - GFXMMU LUT entry 198 high
        volatile uint32_t GFXMMU_LUT199L;  ///< Offset: 0x1638 - GFXMMU LUT entry 199 low
        volatile uint32_t GFXMMU_LUT199H;  ///< Offset: 0x163C - GFXMMU LUT entry 199 high
        volatile uint32_t GFXMMU_LUT200L;  ///< Offset: 0x1640 - GFXMMU LUT entry 200 low
        volatile uint32_t GFXMMU_LUT200H;  ///< Offset: 0x1644 - GFXMMU LUT entry 200 high
        volatile uint32_t GFXMMU_LUT201L;  ///< Offset: 0x1648 - GFXMMU LUT entry 201 low
        volatile uint32_t GFXMMU_LUT201H;  ///< Offset: 0x164C - GFXMMU LUT entry 201 high
        volatile uint32_t GFXMMU_LUT202L;  ///< Offset: 0x1650 - GFXMMU LUT entry 202 low
        volatile uint32_t GFXMMU_LUT202H;  ///< Offset: 0x1654 - GFXMMU LUT entry 202 high
        volatile uint32_t GFXMMU_LUT203L;  ///< Offset: 0x1658 - GFXMMU LUT entry 203 low
        volatile uint32_t GFXMMU_LUT203H;  ///< Offset: 0x165C - GFXMMU LUT entry 203 high
        volatile uint32_t GFXMMU_LUT204L;  ///< Offset: 0x1660 - GFXMMU LUT entry 204 low
        volatile uint32_t GFXMMU_LUT204H;  ///< Offset: 0x1664 - GFXMMU LUT entry 204 high
        volatile uint32_t GFXMMU_LUT205L;  ///< Offset: 0x1668 - GFXMMU LUT entry 205 low
        volatile uint32_t GFXMMU_LUT205H;  ///< Offset: 0x166C - GFXMMU LUT entry 205 high
        volatile uint32_t GFXMMU_LUT206L;  ///< Offset: 0x1670 - GFXMMU LUT entry 206 low
        volatile uint32_t GFXMMU_LUT206H;  ///< Offset: 0x1674 - GFXMMU LUT entry 206 high
        volatile uint32_t GFXMMU_LUT207L;  ///< Offset: 0x1678 - GFXMMU LUT entry 207 low
        volatile uint32_t GFXMMU_LUT207H;  ///< Offset: 0x167C - GFXMMU LUT entry 207 high
        volatile uint32_t GFXMMU_LUT208L;  ///< Offset: 0x1680 - GFXMMU LUT entry 208 low
        volatile uint32_t GFXMMU_LUT208H;  ///< Offset: 0x1684 - GFXMMU LUT entry 208 high
        volatile uint32_t GFXMMU_LUT209L;  ///< Offset: 0x1688 - GFXMMU LUT entry 209 low
        volatile uint32_t GFXMMU_LUT209H;  ///< Offset: 0x168C - GFXMMU LUT entry 209 high
        volatile uint32_t GFXMMU_LUT210L;  ///< Offset: 0x1690 - GFXMMU LUT entry 210 low
        volatile uint32_t GFXMMU_LUT210H;  ///< Offset: 0x1694 - GFXMMU LUT entry 210 high
        volatile uint32_t GFXMMU_LUT211L;  ///< Offset: 0x1698 - GFXMMU LUT entry 211 low
        volatile uint32_t GFXMMU_LUT211H;  ///< Offset: 0x169C - GFXMMU LUT entry 211 high
        volatile uint32_t GFXMMU_LUT212L;  ///< Offset: 0x16A0 - GFXMMU LUT entry 212 low
        volatile uint32_t GFXMMU_LUT212H;  ///< Offset: 0x16A4 - GFXMMU LUT entry 212 high
        volatile uint32_t GFXMMU_LUT213L;  ///< Offset: 0x16A8 - GFXMMU LUT entry 213 low
        volatile uint32_t GFXMMU_LUT213H;  ///< Offset: 0x16AC - GFXMMU LUT entry 213 high
        volatile uint32_t GFXMMU_LUT214L;  ///< Offset: 0x16B0 - GFXMMU LUT entry 214 low
        volatile uint32_t GFXMMU_LUT214H;  ///< Offset: 0x16B4 - GFXMMU LUT entry 214 high
        volatile uint32_t GFXMMU_LUT215L;  ///< Offset: 0x16B8 - GFXMMU LUT entry 215 low
        volatile uint32_t GFXMMU_LUT215H;  ///< Offset: 0x16BC - GFXMMU LUT entry 215 high
        volatile uint32_t GFXMMU_LUT216L;  ///< Offset: 0x16C0 - GFXMMU LUT entry 216 low
        volatile uint32_t GFXMMU_LUT216H;  ///< Offset: 0x16C4 - GFXMMU LUT entry 216 high
        volatile uint32_t GFXMMU_LUT217L;  ///< Offset: 0x16C8 - GFXMMU LUT entry 217 low
        volatile uint32_t GFXMMU_LUT217H;  ///< Offset: 0x16CC - GFXMMU LUT entry 217 high
        volatile uint32_t GFXMMU_LUT218L;  ///< Offset: 0x16D0 - GFXMMU LUT entry 218 low
        volatile uint32_t GFXMMU_LUT218H;  ///< Offset: 0x16D4 - GFXMMU LUT entry 218 high
        volatile uint32_t GFXMMU_LUT219L;  ///< Offset: 0x16D8 - GFXMMU LUT entry 219 low
        volatile uint32_t GFXMMU_LUT219H;  ///< Offset: 0x16DC - GFXMMU LUT entry 219 high
        volatile uint32_t GFXMMU_LUT220L;  ///< Offset: 0x16E0 - GFXMMU LUT entry 220 low
        volatile uint32_t GFXMMU_LUT220H;  ///< Offset: 0x16E4 - GFXMMU LUT entry 220 high
        volatile uint32_t GFXMMU_LUT221L;  ///< Offset: 0x16E8 - GFXMMU LUT entry 221 low
        volatile uint32_t GFXMMU_LUT221H;  ///< Offset: 0x16EC - GFXMMU LUT entry 221 high
        volatile uint32_t GFXMMU_LUT222L;  ///< Offset: 0x16F0 - GFXMMU LUT entry 222 low
        volatile uint32_t GFXMMU_LUT222H;  ///< Offset: 0x16F4 - GFXMMU LUT entry 222 high
        volatile uint32_t GFXMMU_LUT223L;  ///< Offset: 0x16F8 - GFXMMU LUT entry 223 low
        volatile uint32_t GFXMMU_LUT223H;  ///< Offset: 0x16FC - GFXMMU LUT entry 223 high
        volatile uint32_t GFXMMU_LUT224L;  ///< Offset: 0x1700 - GFXMMU LUT entry 224 low
        volatile uint32_t GFXMMU_LUT224H;  ///< Offset: 0x1704 - GFXMMU LUT entry 224 high
        volatile uint32_t GFXMMU_LUT225L;  ///< Offset: 0x1708 - GFXMMU LUT entry 225 low
        volatile uint32_t GFXMMU_LUT225H;  ///< Offset: 0x170C - GFXMMU LUT entry 225 high
        volatile uint32_t GFXMMU_LUT226L;  ///< Offset: 0x1710 - GFXMMU LUT entry 226 low
        volatile uint32_t GFXMMU_LUT226H;  ///< Offset: 0x1714 - GFXMMU LUT entry 226 high
        volatile uint32_t GFXMMU_LUT227L;  ///< Offset: 0x1718 - GFXMMU LUT entry 227 low
        volatile uint32_t GFXMMU_LUT227H;  ///< Offset: 0x171C - GFXMMU LUT entry 227 high
        volatile uint32_t GFXMMU_LUT228L;  ///< Offset: 0x1720 - GFXMMU LUT entry 228 low
        volatile uint32_t GFXMMU_LUT228H;  ///< Offset: 0x1724 - GFXMMU LUT entry 228 high
        volatile uint32_t GFXMMU_LUT229L;  ///< Offset: 0x1728 - GFXMMU LUT entry 229 low
        volatile uint32_t GFXMMU_LUT229H;  ///< Offset: 0x172C - GFXMMU LUT entry 229 high
        volatile uint32_t GFXMMU_LUT230L;  ///< Offset: 0x1730 - GFXMMU LUT entry 230 low
        volatile uint32_t GFXMMU_LUT230H;  ///< Offset: 0x1734 - GFXMMU LUT entry 230 high
        volatile uint32_t GFXMMU_LUT231L;  ///< Offset: 0x1738 - GFXMMU LUT entry 231 low
        volatile uint32_t GFXMMU_LUT231H;  ///< Offset: 0x173C - GFXMMU LUT entry 231 high
        volatile uint32_t GFXMMU_LUT232L;  ///< Offset: 0x1740 - GFXMMU LUT entry 232 low
        volatile uint32_t GFXMMU_LUT232H;  ///< Offset: 0x1744 - GFXMMU LUT entry 232 high
        volatile uint32_t GFXMMU_LUT233L;  ///< Offset: 0x1748 - GFXMMU LUT entry 233 low
        volatile uint32_t GFXMMU_LUT233H;  ///< Offset: 0x174C - GFXMMU LUT entry 233 high
        volatile uint32_t GFXMMU_LUT234L;  ///< Offset: 0x1750 - GFXMMU LUT entry 234 low
        volatile uint32_t GFXMMU_LUT234H;  ///< Offset: 0x1754 - GFXMMU LUT entry 234 high
        volatile uint32_t GFXMMU_LUT235L;  ///< Offset: 0x1758 - GFXMMU LUT entry 235 low
        volatile uint32_t GFXMMU_LUT235H;  ///< Offset: 0x175C - GFXMMU LUT entry 235 high
        volatile uint32_t GFXMMU_LUT236L;  ///< Offset: 0x1760 - GFXMMU LUT entry 236 low
        volatile uint32_t GFXMMU_LUT236H;  ///< Offset: 0x1764 - GFXMMU LUT entry 236 high
        volatile uint32_t GFXMMU_LUT237L;  ///< Offset: 0x1768 - GFXMMU LUT entry 237 low
        volatile uint32_t GFXMMU_LUT237H;  ///< Offset: 0x176C - GFXMMU LUT entry 237 high
        volatile uint32_t GFXMMU_LUT238L;  ///< Offset: 0x1770 - GFXMMU LUT entry 238 low
        volatile uint32_t GFXMMU_LUT238H;  ///< Offset: 0x1774 - GFXMMU LUT entry 238 high
        volatile uint32_t GFXMMU_LUT239L;  ///< Offset: 0x1778 - GFXMMU LUT entry 239 low
        volatile uint32_t GFXMMU_LUT239H;  ///< Offset: 0x177C - GFXMMU LUT entry 239 high
        volatile uint32_t GFXMMU_LUT240L;  ///< Offset: 0x1780 - GFXMMU LUT entry 240 low
        volatile uint32_t GFXMMU_LUT240H;  ///< Offset: 0x1784 - GFXMMU LUT entry 240 high
        volatile uint32_t GFXMMU_LUT241L;  ///< Offset: 0x1788 - GFXMMU LUT entry 241 low
        volatile uint32_t GFXMMU_LUT241H;  ///< Offset: 0x178C - GFXMMU LUT entry 241 high
        volatile uint32_t GFXMMU_LUT242L;  ///< Offset: 0x1790 - GFXMMU LUT entry 242 low
        volatile uint32_t GFXMMU_LUT242H;  ///< Offset: 0x1794 - GFXMMU LUT entry 242 high
        volatile uint32_t GFXMMU_LUT243L;  ///< Offset: 0x1798 - GFXMMU LUT entry 243 low
        volatile uint32_t GFXMMU_LUT243H;  ///< Offset: 0x179C - GFXMMU LUT entry 243 high
        volatile uint32_t GFXMMU_LUT244L;  ///< Offset: 0x17A0 - GFXMMU LUT entry 244 low
        volatile uint32_t GFXMMU_LUT244H;  ///< Offset: 0x17A4 - GFXMMU LUT entry 244 high
        volatile uint32_t GFXMMU_LUT245L;  ///< Offset: 0x17A8 - GFXMMU LUT entry 245 low
        volatile uint32_t GFXMMU_LUT245H;  ///< Offset: 0x17AC - GFXMMU LUT entry 245 high
        volatile uint32_t GFXMMU_LUT246L;  ///< Offset: 0x17B0 - GFXMMU LUT entry 246 low
        volatile uint32_t GFXMMU_LUT246H;  ///< Offset: 0x17B4 - GFXMMU LUT entry 246 high
        volatile uint32_t GFXMMU_LUT247L;  ///< Offset: 0x17B8 - GFXMMU LUT entry 247 low
        volatile uint32_t GFXMMU_LUT247H;  ///< Offset: 0x17BC - GFXMMU LUT entry 247 high
        volatile uint32_t GFXMMU_LUT248L;  ///< Offset: 0x17C0 - GFXMMU LUT entry 248 low
        volatile uint32_t GFXMMU_LUT248H;  ///< Offset: 0x17C4 - GFXMMU LUT entry 248 high
        volatile uint32_t GFXMMU_LUT249L;  ///< Offset: 0x17C8 - GFXMMU LUT entry 249 low
        volatile uint32_t GFXMMU_LUT249H;  ///< Offset: 0x17CC - GFXMMU LUT entry 249 high
        volatile uint32_t GFXMMU_LUT250L;  ///< Offset: 0x17D0 - GFXMMU LUT entry 250 low
        volatile uint32_t GFXMMU_LUT250H;  ///< Offset: 0x17D4 - GFXMMU LUT entry 250 high
        volatile uint32_t GFXMMU_LUT251L;  ///< Offset: 0x17D8 - GFXMMU LUT entry 251 low
        volatile uint32_t GFXMMU_LUT251H;  ///< Offset: 0x17DC - GFXMMU LUT entry 251 high
        volatile uint32_t GFXMMU_LUT252L;  ///< Offset: 0x17E0 - GFXMMU LUT entry 252 low
        volatile uint32_t GFXMMU_LUT252H;  ///< Offset: 0x17E4 - GFXMMU LUT entry 252 high
        volatile uint32_t GFXMMU_LUT253L;  ///< Offset: 0x17E8 - GFXMMU LUT entry 253 low
        volatile uint32_t GFXMMU_LUT253H;  ///< Offset: 0x17EC - GFXMMU LUT entry 253 high
        volatile uint32_t GFXMMU_LUT254L;  ///< Offset: 0x17F0 - GFXMMU LUT entry 254 low
        volatile uint32_t GFXMMU_LUT254H;  ///< Offset: 0x17F4 - GFXMMU LUT entry 254 high
        volatile uint32_t GFXMMU_LUT255L;  ///< Offset: 0x17F8 - GFXMMU LUT entry 255 low
        volatile uint32_t GFXMMU_LUT255H;  ///< Offset: 0x17FC - GFXMMU LUT entry 255 high
        volatile uint32_t GFXMMU_LUT256L;  ///< Offset: 0x1800 - GFXMMU LUT entry 256 low
        volatile uint32_t GFXMMU_LUT256H;  ///< Offset: 0x1804 - GFXMMU LUT entry 256 high
        volatile uint32_t GFXMMU_LUT257L;  ///< Offset: 0x1808 - GFXMMU LUT entry 257 low
        volatile uint32_t GFXMMU_LUT257H;  ///< Offset: 0x180C - GFXMMU LUT entry 257 high
        volatile uint32_t GFXMMU_LUT258L;  ///< Offset: 0x1810 - GFXMMU LUT entry 258 low
        volatile uint32_t GFXMMU_LUT258H;  ///< Offset: 0x1814 - GFXMMU LUT entry 258 high
        volatile uint32_t GFXMMU_LUT259L;  ///< Offset: 0x1818 - GFXMMU LUT entry 259 low
        volatile uint32_t GFXMMU_LUT259H;  ///< Offset: 0x181C - GFXMMU LUT entry 259 high
        volatile uint32_t GFXMMU_LUT260L;  ///< Offset: 0x1820 - GFXMMU LUT entry 260 low
        volatile uint32_t GFXMMU_LUT260H;  ///< Offset: 0x1824 - GFXMMU LUT entry 260 high
        volatile uint32_t GFXMMU_LUT261L;  ///< Offset: 0x1828 - GFXMMU LUT entry 261 low
        volatile uint32_t GFXMMU_LUT261H;  ///< Offset: 0x182C - GFXMMU LUT entry 261 high
        volatile uint32_t GFXMMU_LUT262L;  ///< Offset: 0x1830 - GFXMMU LUT entry 262 low
        volatile uint32_t GFXMMU_LUT262H;  ///< Offset: 0x1834 - GFXMMU LUT entry 262 high
        volatile uint32_t GFXMMU_LUT263L;  ///< Offset: 0x1838 - GFXMMU LUT entry 263 low
        volatile uint32_t GFXMMU_LUT263H;  ///< Offset: 0x183C - GFXMMU LUT entry 263 high
        volatile uint32_t GFXMMU_LUT264L;  ///< Offset: 0x1840 - GFXMMU LUT entry 264 low
        volatile uint32_t GFXMMU_LUT264H;  ///< Offset: 0x1844 - GFXMMU LUT entry 264 high
        volatile uint32_t GFXMMU_LUT265L;  ///< Offset: 0x1848 - GFXMMU LUT entry 265 low
        volatile uint32_t GFXMMU_LUT265H;  ///< Offset: 0x184C - GFXMMU LUT entry 265 high
        volatile uint32_t GFXMMU_LUT266L;  ///< Offset: 0x1850 - GFXMMU LUT entry 266 low
        volatile uint32_t GFXMMU_LUT266H;  ///< Offset: 0x1854 - GFXMMU LUT entry 266 high
        volatile uint32_t GFXMMU_LUT267L;  ///< Offset: 0x1858 - GFXMMU LUT entry 267 low
        volatile uint32_t GFXMMU_LUT267H;  ///< Offset: 0x185C - GFXMMU LUT entry 267 high
        volatile uint32_t GFXMMU_LUT268L;  ///< Offset: 0x1860 - GFXMMU LUT entry 268 low
        volatile uint32_t GFXMMU_LUT268H;  ///< Offset: 0x1864 - GFXMMU LUT entry 268 high
        volatile uint32_t GFXMMU_LUT269L;  ///< Offset: 0x1868 - GFXMMU LUT entry 269 low
        volatile uint32_t GFXMMU_LUT269H;  ///< Offset: 0x186C - GFXMMU LUT entry 269 high
        volatile uint32_t GFXMMU_LUT270L;  ///< Offset: 0x1870 - GFXMMU LUT entry 270 low
        volatile uint32_t GFXMMU_LUT270H;  ///< Offset: 0x1874 - GFXMMU LUT entry 270 high
        volatile uint32_t GFXMMU_LUT271L;  ///< Offset: 0x1878 - GFXMMU LUT entry 271 low
        volatile uint32_t GFXMMU_LUT271H;  ///< Offset: 0x187C - GFXMMU LUT entry 271 high
        volatile uint32_t GFXMMU_LUT272L;  ///< Offset: 0x1880 - GFXMMU LUT entry 272 low
        volatile uint32_t GFXMMU_LUT272H;  ///< Offset: 0x1884 - GFXMMU LUT entry 272 high
        volatile uint32_t GFXMMU_LUT273L;  ///< Offset: 0x1888 - GFXMMU LUT entry 273 low
        volatile uint32_t GFXMMU_LUT273H;  ///< Offset: 0x188C - GFXMMU LUT entry 273 high
        volatile uint32_t GFXMMU_LUT274L;  ///< Offset: 0x1890 - GFXMMU LUT entry 274 low
        volatile uint32_t GFXMMU_LUT274H;  ///< Offset: 0x1894 - GFXMMU LUT entry 274 high
        volatile uint32_t GFXMMU_LUT275L;  ///< Offset: 0x1898 - GFXMMU LUT entry 275 low
        volatile uint32_t GFXMMU_LUT275H;  ///< Offset: 0x189C - GFXMMU LUT entry 275 high
        volatile uint32_t GFXMMU_LUT276L;  ///< Offset: 0x18A0 - GFXMMU LUT entry 276 low
        volatile uint32_t GFXMMU_LUT276H;  ///< Offset: 0x18A4 - GFXMMU LUT entry 276 high
        volatile uint32_t GFXMMU_LUT277L;  ///< Offset: 0x18A8 - GFXMMU LUT entry 277 low
        volatile uint32_t GFXMMU_LUT277H;  ///< Offset: 0x18AC - GFXMMU LUT entry 277 high
        volatile uint32_t GFXMMU_LUT278L;  ///< Offset: 0x18B0 - GFXMMU LUT entry 278 low
        volatile uint32_t GFXMMU_LUT278H;  ///< Offset: 0x18B4 - GFXMMU LUT entry 278 high
        volatile uint32_t GFXMMU_LUT279L;  ///< Offset: 0x18B8 - GFXMMU LUT entry 279 low
        volatile uint32_t GFXMMU_LUT279H;  ///< Offset: 0x18BC - GFXMMU LUT entry 279 high
        volatile uint32_t GFXMMU_LUT280L;  ///< Offset: 0x18C0 - GFXMMU LUT entry 280 low
        volatile uint32_t GFXMMU_LUT280H;  ///< Offset: 0x18C4 - GFXMMU LUT entry 280 high
        volatile uint32_t GFXMMU_LUT281L;  ///< Offset: 0x18C8 - GFXMMU LUT entry 281 low
        volatile uint32_t GFXMMU_LUT281H;  ///< Offset: 0x18CC - GFXMMU LUT entry 281 high
        volatile uint32_t GFXMMU_LUT282L;  ///< Offset: 0x18D0 - GFXMMU LUT entry 282 low
        volatile uint32_t GFXMMU_LUT282H;  ///< Offset: 0x18D4 - GFXMMU LUT entry 282 high
        volatile uint32_t GFXMMU_LUT283L;  ///< Offset: 0x18D8 - GFXMMU LUT entry 283 low
        volatile uint32_t GFXMMU_LUT283H;  ///< Offset: 0x18DC - GFXMMU LUT entry 283 high
        volatile uint32_t GFXMMU_LUT284L;  ///< Offset: 0x18E0 - GFXMMU LUT entry 284 low
        volatile uint32_t GFXMMU_LUT284H;  ///< Offset: 0x18E4 - GFXMMU LUT entry 284 high
        volatile uint32_t GFXMMU_LUT285L;  ///< Offset: 0x18E8 - GFXMMU LUT entry 285 low
        volatile uint32_t GFXMMU_LUT285H;  ///< Offset: 0x18EC - GFXMMU LUT entry 285 high
        volatile uint32_t GFXMMU_LUT286L;  ///< Offset: 0x18F0 - GFXMMU LUT entry 286 low
        volatile uint32_t GFXMMU_LUT286H;  ///< Offset: 0x18F4 - GFXMMU LUT entry 286 high
        volatile uint32_t GFXMMU_LUT287L;  ///< Offset: 0x18F8 - GFXMMU LUT entry 287 low
        volatile uint32_t GFXMMU_LUT287H;  ///< Offset: 0x18FC - GFXMMU LUT entry 287 high
        volatile uint32_t GFXMMU_LUT288L;  ///< Offset: 0x1900 - GFXMMU LUT entry 288 low
        volatile uint32_t GFXMMU_LUT288H;  ///< Offset: 0x1904 - GFXMMU LUT entry 288 high
        volatile uint32_t GFXMMU_LUT289L;  ///< Offset: 0x1908 - GFXMMU LUT entry 289 low
        volatile uint32_t GFXMMU_LUT289H;  ///< Offset: 0x190C - GFXMMU LUT entry 289 high
        volatile uint32_t GFXMMU_LUT290L;  ///< Offset: 0x1910 - GFXMMU LUT entry 290 low
        volatile uint32_t GFXMMU_LUT290H;  ///< Offset: 0x1914 - GFXMMU LUT entry 290 high
        volatile uint32_t GFXMMU_LUT291L;  ///< Offset: 0x1918 - GFXMMU LUT entry 291 low
        volatile uint32_t GFXMMU_LUT291H;  ///< Offset: 0x191C - GFXMMU LUT entry 291 high
        volatile uint32_t GFXMMU_LUT292L;  ///< Offset: 0x1920 - GFXMMU LUT entry 292 low
        volatile uint32_t GFXMMU_LUT292H;  ///< Offset: 0x1924 - GFXMMU LUT entry 292 high
        volatile uint32_t GFXMMU_LUT293L;  ///< Offset: 0x1928 - GFXMMU LUT entry 293 low
        volatile uint32_t GFXMMU_LUT293H;  ///< Offset: 0x192C - GFXMMU LUT entry 293 high
        volatile uint32_t GFXMMU_LUT294L;  ///< Offset: 0x1930 - GFXMMU LUT entry 294 low
        volatile uint32_t GFXMMU_LUT294H;  ///< Offset: 0x1934 - GFXMMU LUT entry 294 high
        volatile uint32_t GFXMMU_LUT295L;  ///< Offset: 0x1938 - GFXMMU LUT entry 295 low
        volatile uint32_t GFXMMU_LUT295H;  ///< Offset: 0x193C - GFXMMU LUT entry 295 high
        volatile uint32_t GFXMMU_LUT296L;  ///< Offset: 0x1940 - GFXMMU LUT entry 296 low
        volatile uint32_t GFXMMU_LUT296H;  ///< Offset: 0x1944 - GFXMMU LUT entry 296 high
        volatile uint32_t GFXMMU_LUT297L;  ///< Offset: 0x1948 - GFXMMU LUT entry 297 low
        volatile uint32_t GFXMMU_LUT297H;  ///< Offset: 0x194C - GFXMMU LUT entry 297 high
        volatile uint32_t GFXMMU_LUT298L;  ///< Offset: 0x1950 - GFXMMU LUT entry 298 low
        volatile uint32_t GFXMMU_LUT298H;  ///< Offset: 0x1954 - GFXMMU LUT entry 298 high
        volatile uint32_t GFXMMU_LUT299L;  ///< Offset: 0x1958 - GFXMMU LUT entry 299 low
        volatile uint32_t GFXMMU_LUT299H;  ///< Offset: 0x195C - GFXMMU LUT entry 299 high
        volatile uint32_t GFXMMU_LUT300L;  ///< Offset: 0x1960 - GFXMMU LUT entry 300 low
        volatile uint32_t GFXMMU_LUT300H;  ///< Offset: 0x1964 - GFXMMU LUT entry 300 high
        volatile uint32_t GFXMMU_LUT301L;  ///< Offset: 0x1968 - GFXMMU LUT entry 301 low
        volatile uint32_t GFXMMU_LUT301H;  ///< Offset: 0x196C - GFXMMU LUT entry 301 high
        volatile uint32_t GFXMMU_LUT302L;  ///< Offset: 0x1970 - GFXMMU LUT entry 302 low
        volatile uint32_t GFXMMU_LUT302H;  ///< Offset: 0x1974 - GFXMMU LUT entry 302 high
        volatile uint32_t GFXMMU_LUT303L;  ///< Offset: 0x1978 - GFXMMU LUT entry 303 low
        volatile uint32_t GFXMMU_LUT303H;  ///< Offset: 0x197C - GFXMMU LUT entry 303 high
        volatile uint32_t GFXMMU_LUT304L;  ///< Offset: 0x1980 - GFXMMU LUT entry 304 low
        volatile uint32_t GFXMMU_LUT304H;  ///< Offset: 0x1984 - GFXMMU LUT entry 304 high
        volatile uint32_t GFXMMU_LUT305L;  ///< Offset: 0x1988 - GFXMMU LUT entry 305 low
        volatile uint32_t GFXMMU_LUT305H;  ///< Offset: 0x198C - GFXMMU LUT entry 305 high
        volatile uint32_t GFXMMU_LUT306L;  ///< Offset: 0x1990 - GFXMMU LUT entry 306 low
        volatile uint32_t GFXMMU_LUT306H;  ///< Offset: 0x1994 - GFXMMU LUT entry 306 high
        volatile uint32_t GFXMMU_LUT307L;  ///< Offset: 0x1998 - GFXMMU LUT entry 307 low
        volatile uint32_t GFXMMU_LUT307H;  ///< Offset: 0x199C - GFXMMU LUT entry 307 high
        volatile uint32_t GFXMMU_LUT308L;  ///< Offset: 0x19A0 - GFXMMU LUT entry 308 low
        volatile uint32_t GFXMMU_LUT308H;  ///< Offset: 0x19A4 - GFXMMU LUT entry 308 high
        volatile uint32_t GFXMMU_LUT309L;  ///< Offset: 0x19A8 - GFXMMU LUT entry 309 low
        volatile uint32_t GFXMMU_LUT309H;  ///< Offset: 0x19AC - GFXMMU LUT entry 309 high
        volatile uint32_t GFXMMU_LUT310L;  ///< Offset: 0x19B0 - GFXMMU LUT entry 310 low
        volatile uint32_t GFXMMU_LUT310H;  ///< Offset: 0x19B4 - GFXMMU LUT entry 310 high
        volatile uint32_t GFXMMU_LUT311L;  ///< Offset: 0x19B8 - GFXMMU LUT entry 311 low
        volatile uint32_t GFXMMU_LUT311H;  ///< Offset: 0x19BC - GFXMMU LUT entry 311 high
        volatile uint32_t GFXMMU_LUT312L;  ///< Offset: 0x19C0 - GFXMMU LUT entry 312 low
        volatile uint32_t GFXMMU_LUT312H;  ///< Offset: 0x19C4 - GFXMMU LUT entry 312 high
        volatile uint32_t GFXMMU_LUT313L;  ///< Offset: 0x19C8 - GFXMMU LUT entry 313 low
        volatile uint32_t GFXMMU_LUT313H;  ///< Offset: 0x19CC - GFXMMU LUT entry 313 high
        volatile uint32_t GFXMMU_LUT314L;  ///< Offset: 0x19D0 - GFXMMU LUT entry 314 low
        volatile uint32_t GFXMMU_LUT314H;  ///< Offset: 0x19D4 - GFXMMU LUT entry 314 high
        volatile uint32_t GFXMMU_LUT315L;  ///< Offset: 0x19D8 - GFXMMU LUT entry 315 low
        volatile uint32_t GFXMMU_LUT315H;  ///< Offset: 0x19DC - GFXMMU LUT entry 315 high
        volatile uint32_t GFXMMU_LUT316L;  ///< Offset: 0x19E0 - GFXMMU LUT entry 316 low
        volatile uint32_t GFXMMU_LUT316H;  ///< Offset: 0x19E4 - GFXMMU LUT entry 316 high
        volatile uint32_t GFXMMU_LUT317L;  ///< Offset: 0x19E8 - GFXMMU LUT entry 317 low
        volatile uint32_t GFXMMU_LUT317H;  ///< Offset: 0x19EC - GFXMMU LUT entry 317 high
        volatile uint32_t GFXMMU_LUT318L;  ///< Offset: 0x19F0 - GFXMMU LUT entry 318 low
        volatile uint32_t GFXMMU_LUT318H;  ///< Offset: 0x19F4 - GFXMMU LUT entry 318 high
        volatile uint32_t GFXMMU_LUT319L;  ///< Offset: 0x19F8 - GFXMMU LUT entry 319 low
        volatile uint32_t GFXMMU_LUT319H;  ///< Offset: 0x19FC - GFXMMU LUT entry 319 high
        volatile uint32_t GFXMMU_LUT320L;  ///< Offset: 0x1A00 - GFXMMU LUT entry 320 low
        volatile uint32_t GFXMMU_LUT320H;  ///< Offset: 0x1A04 - GFXMMU LUT entry 320 high
        volatile uint32_t GFXMMU_LUT321L;  ///< Offset: 0x1A08 - GFXMMU LUT entry 321 low
        volatile uint32_t GFXMMU_LUT321H;  ///< Offset: 0x1A0C - GFXMMU LUT entry 321 high
        volatile uint32_t GFXMMU_LUT322L;  ///< Offset: 0x1A10 - GFXMMU LUT entry 322 low
        volatile uint32_t GFXMMU_LUT322H;  ///< Offset: 0x1A14 - GFXMMU LUT entry 322 high
        volatile uint32_t GFXMMU_LUT323L;  ///< Offset: 0x1A18 - GFXMMU LUT entry 323 low
        volatile uint32_t GFXMMU_LUT323H;  ///< Offset: 0x1A1C - GFXMMU LUT entry 323 high
        volatile uint32_t GFXMMU_LUT324L;  ///< Offset: 0x1A20 - GFXMMU LUT entry 324 low
        volatile uint32_t GFXMMU_LUT324H;  ///< Offset: 0x1A24 - GFXMMU LUT entry 324 high
        volatile uint32_t GFXMMU_LUT325L;  ///< Offset: 0x1A28 - GFXMMU LUT entry 325 low
        volatile uint32_t GFXMMU_LUT325H;  ///< Offset: 0x1A2C - GFXMMU LUT entry 325 high
        volatile uint32_t GFXMMU_LUT326L;  ///< Offset: 0x1A30 - GFXMMU LUT entry 326 low
        volatile uint32_t GFXMMU_LUT326H;  ///< Offset: 0x1A34 - GFXMMU LUT entry 326 high
        volatile uint32_t GFXMMU_LUT327L;  ///< Offset: 0x1A38 - GFXMMU LUT entry 327 low
        volatile uint32_t GFXMMU_LUT327H;  ///< Offset: 0x1A3C - GFXMMU LUT entry 327 high
        volatile uint32_t GFXMMU_LUT328L;  ///< Offset: 0x1A40 - GFXMMU LUT entry 328 low
        volatile uint32_t GFXMMU_LUT328H;  ///< Offset: 0x1A44 - GFXMMU LUT entry 328 high
        volatile uint32_t GFXMMU_LUT329L;  ///< Offset: 0x1A48 - GFXMMU LUT entry 329 low
        volatile uint32_t GFXMMU_LUT329H;  ///< Offset: 0x1A4C - GFXMMU LUT entry 329 high
        volatile uint32_t GFXMMU_LUT330L;  ///< Offset: 0x1A50 - GFXMMU LUT entry 330 low
        volatile uint32_t GFXMMU_LUT330H;  ///< Offset: 0x1A54 - GFXMMU LUT entry 330 high
        volatile uint32_t GFXMMU_LUT331L;  ///< Offset: 0x1A58 - GFXMMU LUT entry 331 low
        volatile uint32_t GFXMMU_LUT331H;  ///< Offset: 0x1A5C - GFXMMU LUT entry 331 high
        volatile uint32_t GFXMMU_LUT332L;  ///< Offset: 0x1A60 - GFXMMU LUT entry 332 low
        volatile uint32_t GFXMMU_LUT332H;  ///< Offset: 0x1A64 - GFXMMU LUT entry 332 high
        volatile uint32_t GFXMMU_LUT333L;  ///< Offset: 0x1A68 - GFXMMU LUT entry 333 low
        volatile uint32_t GFXMMU_LUT333H;  ///< Offset: 0x1A6C - GFXMMU LUT entry 333 high
        volatile uint32_t GFXMMU_LUT334L;  ///< Offset: 0x1A70 - GFXMMU LUT entry 334 low
        volatile uint32_t GFXMMU_LUT334H;  ///< Offset: 0x1A74 - GFXMMU LUT entry 334 high
        volatile uint32_t GFXMMU_LUT335L;  ///< Offset: 0x1A78 - GFXMMU LUT entry 335 low
        volatile uint32_t GFXMMU_LUT335H;  ///< Offset: 0x1A7C - GFXMMU LUT entry 335 high
        volatile uint32_t GFXMMU_LUT336L;  ///< Offset: 0x1A80 - GFXMMU LUT entry 336 low
        volatile uint32_t GFXMMU_LUT336H;  ///< Offset: 0x1A84 - GFXMMU LUT entry 336 high
        volatile uint32_t GFXMMU_LUT337L;  ///< Offset: 0x1A88 - GFXMMU LUT entry 337 low
        volatile uint32_t GFXMMU_LUT337H;  ///< Offset: 0x1A8C - GFXMMU LUT entry 337 high
        volatile uint32_t GFXMMU_LUT338L;  ///< Offset: 0x1A90 - GFXMMU LUT entry 338 low
        volatile uint32_t GFXMMU_LUT338H;  ///< Offset: 0x1A94 - GFXMMU LUT entry 338 high
        volatile uint32_t GFXMMU_LUT339L;  ///< Offset: 0x1A98 - GFXMMU LUT entry 339 low
        volatile uint32_t GFXMMU_LUT339H;  ///< Offset: 0x1A9C - GFXMMU LUT entry 339 high
        volatile uint32_t GFXMMU_LUT340L;  ///< Offset: 0x1AA0 - GFXMMU LUT entry 340 low
        volatile uint32_t GFXMMU_LUT340H;  ///< Offset: 0x1AA4 - GFXMMU LUT entry 340 high
        volatile uint32_t GFXMMU_LUT341L;  ///< Offset: 0x1AA8 - GFXMMU LUT entry 341 low
        volatile uint32_t GFXMMU_LUT341H;  ///< Offset: 0x1AAC - GFXMMU LUT entry 341 high
        volatile uint32_t GFXMMU_LUT342L;  ///< Offset: 0x1AB0 - GFXMMU LUT entry 342 low
        volatile uint32_t GFXMMU_LUT342H;  ///< Offset: 0x1AB4 - GFXMMU LUT entry 342 high
        volatile uint32_t GFXMMU_LUT343L;  ///< Offset: 0x1AB8 - GFXMMU LUT entry 343 low
        volatile uint32_t GFXMMU_LUT343H;  ///< Offset: 0x1ABC - GFXMMU LUT entry 343 high
        volatile uint32_t GFXMMU_LUT344L;  ///< Offset: 0x1AC0 - GFXMMU LUT entry 344 low
        volatile uint32_t GFXMMU_LUT344H;  ///< Offset: 0x1AC4 - GFXMMU LUT entry 344 high
        volatile uint32_t GFXMMU_LUT345L;  ///< Offset: 0x1AC8 - GFXMMU LUT entry 345 low
        volatile uint32_t GFXMMU_LUT345H;  ///< Offset: 0x1ACC - GFXMMU LUT entry 345 high
        volatile uint32_t GFXMMU_LUT346L;  ///< Offset: 0x1AD0 - GFXMMU LUT entry 346 low
        volatile uint32_t GFXMMU_LUT346H;  ///< Offset: 0x1AD4 - GFXMMU LUT entry 346 high
        volatile uint32_t GFXMMU_LUT347L;  ///< Offset: 0x1AD8 - GFXMMU LUT entry 347 low
        volatile uint32_t GFXMMU_LUT347H;  ///< Offset: 0x1ADC - GFXMMU LUT entry 347 high
        volatile uint32_t GFXMMU_LUT348L;  ///< Offset: 0x1AE0 - GFXMMU LUT entry 348 low
        volatile uint32_t GFXMMU_LUT348H;  ///< Offset: 0x1AE4 - GFXMMU LUT entry 348 high
        volatile uint32_t GFXMMU_LUT349L;  ///< Offset: 0x1AE8 - GFXMMU LUT entry 349 low
        volatile uint32_t GFXMMU_LUT349H;  ///< Offset: 0x1AEC - GFXMMU LUT entry 349 high
        volatile uint32_t GFXMMU_LUT350L;  ///< Offset: 0x1AF0 - GFXMMU LUT entry 350 low
        volatile uint32_t GFXMMU_LUT350H;  ///< Offset: 0x1AF4 - GFXMMU LUT entry 350 high
        volatile uint32_t GFXMMU_LUT351L;  ///< Offset: 0x1AF8 - GFXMMU LUT entry 351 low
        volatile uint32_t GFXMMU_LUT351H;  ///< Offset: 0x1AFC - GFXMMU LUT entry 351 high
        volatile uint32_t GFXMMU_LUT352L;  ///< Offset: 0x1B00 - GFXMMU LUT entry 352 low
        volatile uint32_t GFXMMU_LUT352H;  ///< Offset: 0x1B04 - GFXMMU LUT entry 352 high
        volatile uint32_t GFXMMU_LUT353L;  ///< Offset: 0x1B08 - GFXMMU LUT entry 353 low
        volatile uint32_t GFXMMU_LUT353H;  ///< Offset: 0x1B0C - GFXMMU LUT entry 353 high
        volatile uint32_t GFXMMU_LUT354L;  ///< Offset: 0x1B10 - GFXMMU LUT entry 354 low
        volatile uint32_t GFXMMU_LUT354H;  ///< Offset: 0x1B14 - GFXMMU LUT entry 354 high
        volatile uint32_t GFXMMU_LUT355L;  ///< Offset: 0x1B18 - GFXMMU LUT entry 355 low
        volatile uint32_t GFXMMU_LUT355H;  ///< Offset: 0x1B1C - GFXMMU LUT entry 355 high
        volatile uint32_t GFXMMU_LUT356L;  ///< Offset: 0x1B20 - GFXMMU LUT entry 356 low
        volatile uint32_t GFXMMU_LUT356H;  ///< Offset: 0x1B24 - GFXMMU LUT entry 356 high
        volatile uint32_t GFXMMU_LUT357L;  ///< Offset: 0x1B28 - GFXMMU LUT entry 357 low
        volatile uint32_t GFXMMU_LUT357H;  ///< Offset: 0x1B2C - GFXMMU LUT entry 357 high
        volatile uint32_t GFXMMU_LUT358L;  ///< Offset: 0x1B30 - GFXMMU LUT entry 358 low
        volatile uint32_t GFXMMU_LUT358H;  ///< Offset: 0x1B34 - GFXMMU LUT entry 358 high
        volatile uint32_t GFXMMU_LUT359L;  ///< Offset: 0x1B38 - GFXMMU LUT entry 359 low
        volatile uint32_t GFXMMU_LUT359H;  ///< Offset: 0x1B3C - GFXMMU LUT entry 359 high
        volatile uint32_t GFXMMU_LUT360L;  ///< Offset: 0x1B40 - GFXMMU LUT entry 360 low
        volatile uint32_t GFXMMU_LUT360H;  ///< Offset: 0x1B44 - GFXMMU LUT entry 360 high
        volatile uint32_t GFXMMU_LUT361L;  ///< Offset: 0x1B48 - GFXMMU LUT entry 361 low
        volatile uint32_t GFXMMU_LUT361H;  ///< Offset: 0x1B4C - GFXMMU LUT entry 361 high
        volatile uint32_t GFXMMU_LUT362L;  ///< Offset: 0x1B50 - GFXMMU LUT entry 362 low
        volatile uint32_t GFXMMU_LUT362H;  ///< Offset: 0x1B54 - GFXMMU LUT entry 362 high
        volatile uint32_t GFXMMU_LUT363L;  ///< Offset: 0x1B58 - GFXMMU LUT entry 363 low
        volatile uint32_t GFXMMU_LUT363H;  ///< Offset: 0x1B5C - GFXMMU LUT entry 363 high
        volatile uint32_t GFXMMU_LUT364L;  ///< Offset: 0x1B60 - GFXMMU LUT entry 364 low
        volatile uint32_t GFXMMU_LUT364H;  ///< Offset: 0x1B64 - GFXMMU LUT entry 364 high
        volatile uint32_t GFXMMU_LUT365L;  ///< Offset: 0x1B68 - GFXMMU LUT entry 365 low
        volatile uint32_t GFXMMU_LUT365H;  ///< Offset: 0x1B6C - GFXMMU LUT entry 365 high
        volatile uint32_t GFXMMU_LUT366L;  ///< Offset: 0x1B70 - GFXMMU LUT entry 366 low
        volatile uint32_t GFXMMU_LUT366H;  ///< Offset: 0x1B74 - GFXMMU LUT entry 366 high
        volatile uint32_t GFXMMU_LUT367L;  ///< Offset: 0x1B78 - GFXMMU LUT entry 367 low
        volatile uint32_t GFXMMU_LUT367H;  ///< Offset: 0x1B7C - GFXMMU LUT entry 367 high
        volatile uint32_t GFXMMU_LUT368L;  ///< Offset: 0x1B80 - GFXMMU LUT entry 368 low
        volatile uint32_t GFXMMU_LUT368H;  ///< Offset: 0x1B84 - GFXMMU LUT entry 368 high
        volatile uint32_t GFXMMU_LUT369L;  ///< Offset: 0x1B88 - GFXMMU LUT entry 369 low
        volatile uint32_t GFXMMU_LUT369H;  ///< Offset: 0x1B8C - GFXMMU LUT entry 369 high
        volatile uint32_t GFXMMU_LUT370L;  ///< Offset: 0x1B90 - GFXMMU LUT entry 370 low
        volatile uint32_t GFXMMU_LUT370H;  ///< Offset: 0x1B94 - GFXMMU LUT entry 370 high
        volatile uint32_t GFXMMU_LUT371L;  ///< Offset: 0x1B98 - GFXMMU LUT entry 371 low
        volatile uint32_t GFXMMU_LUT371H;  ///< Offset: 0x1B9C - GFXMMU LUT entry 371 high
        volatile uint32_t GFXMMU_LUT372L;  ///< Offset: 0x1BA0 - GFXMMU LUT entry 372 low
        volatile uint32_t GFXMMU_LUT372H;  ///< Offset: 0x1BA4 - GFXMMU LUT entry 372 high
        volatile uint32_t GFXMMU_LUT373L;  ///< Offset: 0x1BA8 - GFXMMU LUT entry 373 low
        volatile uint32_t GFXMMU_LUT373H;  ///< Offset: 0x1BAC - GFXMMU LUT entry 373 high
        volatile uint32_t GFXMMU_LUT374L;  ///< Offset: 0x1BB0 - GFXMMU LUT entry 374 low
        volatile uint32_t GFXMMU_LUT374H;  ///< Offset: 0x1BB4 - GFXMMU LUT entry 374 high
        volatile uint32_t GFXMMU_LUT375L;  ///< Offset: 0x1BB8 - GFXMMU LUT entry 375 low
        volatile uint32_t GFXMMU_LUT375H;  ///< Offset: 0x1BBC - GFXMMU LUT entry 375 high
        volatile uint32_t GFXMMU_LUT376L;  ///< Offset: 0x1BC0 - GFXMMU LUT entry 376 low
        volatile uint32_t GFXMMU_LUT376H;  ///< Offset: 0x1BC4 - GFXMMU LUT entry 376 high
        volatile uint32_t GFXMMU_LUT377L;  ///< Offset: 0x1BC8 - GFXMMU LUT entry 377 low
        volatile uint32_t GFXMMU_LUT377H;  ///< Offset: 0x1BCC - GFXMMU LUT entry 377 high
        volatile uint32_t GFXMMU_LUT378L;  ///< Offset: 0x1BD0 - GFXMMU LUT entry 378 low
        volatile uint32_t GFXMMU_LUT378H;  ///< Offset: 0x1BD4 - GFXMMU LUT entry 378 high
        volatile uint32_t GFXMMU_LUT379L;  ///< Offset: 0x1BD8 - GFXMMU LUT entry 379 low
        volatile uint32_t GFXMMU_LUT379H;  ///< Offset: 0x1BDC - GFXMMU LUT entry 379 high
        volatile uint32_t GFXMMU_LUT380L;  ///< Offset: 0x1BE0 - GFXMMU LUT entry 380 low
        volatile uint32_t GFXMMU_LUT380H;  ///< Offset: 0x1BE4 - GFXMMU LUT entry 380 high
        volatile uint32_t GFXMMU_LUT381L;  ///< Offset: 0x1BE8 - GFXMMU LUT entry 381 low
        volatile uint32_t GFXMMU_LUT381H;  ///< Offset: 0x1BEC - GFXMMU LUT entry 381 high
        volatile uint32_t GFXMMU_LUT382L;  ///< Offset: 0x1BF0 - GFXMMU LUT entry 382 low
        volatile uint32_t GFXMMU_LUT382H;  ///< Offset: 0x1BF4 - GFXMMU LUT entry 382 high
        volatile uint32_t GFXMMU_LUT383L;  ///< Offset: 0x1BF8 - GFXMMU LUT entry 383 low
        volatile uint32_t GFXMMU_LUT383H;  ///< Offset: 0x1BFC - GFXMMU LUT entry 383 high
        volatile uint32_t GFXMMU_LUT384L;  ///< Offset: 0x1C00 - GFXMMU LUT entry 384 low
        volatile uint32_t GFXMMU_LUT384H;  ///< Offset: 0x1C04 - GFXMMU LUT entry 384 high
        volatile uint32_t GFXMMU_LUT385L;  ///< Offset: 0x1C08 - GFXMMU LUT entry 385 low
        volatile uint32_t GFXMMU_LUT385H;  ///< Offset: 0x1C0C - GFXMMU LUT entry 385 high
        volatile uint32_t GFXMMU_LUT386L;  ///< Offset: 0x1C10 - GFXMMU LUT entry 386 low
        volatile uint32_t GFXMMU_LUT386H;  ///< Offset: 0x1C14 - GFXMMU LUT entry 386 high
        volatile uint32_t GFXMMU_LUT387L;  ///< Offset: 0x1C18 - GFXMMU LUT entry 387 low
        volatile uint32_t GFXMMU_LUT387H;  ///< Offset: 0x1C1C - GFXMMU LUT entry 387 high
        volatile uint32_t GFXMMU_LUT388L;  ///< Offset: 0x1C20 - GFXMMU LUT entry 388 low
        volatile uint32_t GFXMMU_LUT388H;  ///< Offset: 0x1C24 - GFXMMU LUT entry 388 high
        volatile uint32_t GFXMMU_LUT389L;  ///< Offset: 0x1C28 - GFXMMU LUT entry 389 low
        volatile uint32_t GFXMMU_LUT389H;  ///< Offset: 0x1C2C - GFXMMU LUT entry 389 high
        volatile uint32_t GFXMMU_LUT390L;  ///< Offset: 0x1C30 - GFXMMU LUT entry 390 low
        volatile uint32_t GFXMMU_LUT390H;  ///< Offset: 0x1C34 - GFXMMU LUT entry 390 high
        volatile uint32_t GFXMMU_LUT391L;  ///< Offset: 0x1C38 - GFXMMU LUT entry 391 low
        volatile uint32_t GFXMMU_LUT391H;  ///< Offset: 0x1C3C - GFXMMU LUT entry 391 high
        volatile uint32_t GFXMMU_LUT392L;  ///< Offset: 0x1C40 - GFXMMU LUT entry 392 low
        volatile uint32_t GFXMMU_LUT392H;  ///< Offset: 0x1C44 - GFXMMU LUT entry 392 high
        volatile uint32_t GFXMMU_LUT393L;  ///< Offset: 0x1C48 - GFXMMU LUT entry 393 low
        volatile uint32_t GFXMMU_LUT393H;  ///< Offset: 0x1C4C - GFXMMU LUT entry 393 high
        volatile uint32_t GFXMMU_LUT394L;  ///< Offset: 0x1C50 - GFXMMU LUT entry 394 low
        volatile uint32_t GFXMMU_LUT394H;  ///< Offset: 0x1C54 - GFXMMU LUT entry 394 high
        volatile uint32_t GFXMMU_LUT395L;  ///< Offset: 0x1C58 - GFXMMU LUT entry 395 low
        volatile uint32_t GFXMMU_LUT395H;  ///< Offset: 0x1C5C - GFXMMU LUT entry 395 high
        volatile uint32_t GFXMMU_LUT396L;  ///< Offset: 0x1C60 - GFXMMU LUT entry 396 low
        volatile uint32_t GFXMMU_LUT396H;  ///< Offset: 0x1C64 - GFXMMU LUT entry 396 high
        volatile uint32_t GFXMMU_LUT397L;  ///< Offset: 0x1C68 - GFXMMU LUT entry 397 low
        volatile uint32_t GFXMMU_LUT397H;  ///< Offset: 0x1C6C - GFXMMU LUT entry 397 high
        volatile uint32_t GFXMMU_LUT398L;  ///< Offset: 0x1C70 - GFXMMU LUT entry 398 low
        volatile uint32_t GFXMMU_LUT398H;  ///< Offset: 0x1C74 - GFXMMU LUT entry 398 high
        volatile uint32_t GFXMMU_LUT399L;  ///< Offset: 0x1C78 - GFXMMU LUT entry 399 low
        volatile uint32_t GFXMMU_LUT399H;  ///< Offset: 0x1C7C - GFXMMU LUT entry 399 high
        volatile uint32_t GFXMMU_LUT400L;  ///< Offset: 0x1C80 - GFXMMU LUT entry 400 low
        volatile uint32_t GFXMMU_LUT400H;  ///< Offset: 0x1C84 - GFXMMU LUT entry 400 high
        volatile uint32_t GFXMMU_LUT401L;  ///< Offset: 0x1C88 - GFXMMU LUT entry 401 low
        volatile uint32_t GFXMMU_LUT401H;  ///< Offset: 0x1C8C - GFXMMU LUT entry 401 high
        volatile uint32_t GFXMMU_LUT402L;  ///< Offset: 0x1C90 - GFXMMU LUT entry 402 low
        volatile uint32_t GFXMMU_LUT402H;  ///< Offset: 0x1C94 - GFXMMU LUT entry 402 high
        volatile uint32_t GFXMMU_LUT403L;  ///< Offset: 0x1C98 - GFXMMU LUT entry 403 low
        volatile uint32_t GFXMMU_LUT403H;  ///< Offset: 0x1C9C - GFXMMU LUT entry 403 high
        volatile uint32_t GFXMMU_LUT404L;  ///< Offset: 0x1CA0 - GFXMMU LUT entry 404 low
        volatile uint32_t GFXMMU_LUT404H;  ///< Offset: 0x1CA4 - GFXMMU LUT entry 404 high
        volatile uint32_t GFXMMU_LUT405L;  ///< Offset: 0x1CA8 - GFXMMU LUT entry 405 low
        volatile uint32_t GFXMMU_LUT405H;  ///< Offset: 0x1CAC - GFXMMU LUT entry 405 high
        volatile uint32_t GFXMMU_LUT406L;  ///< Offset: 0x1CB0 - GFXMMU LUT entry 406 low
        volatile uint32_t GFXMMU_LUT406H;  ///< Offset: 0x1CB4 - GFXMMU LUT entry 406 high
        volatile uint32_t GFXMMU_LUT407L;  ///< Offset: 0x1CB8 - GFXMMU LUT entry 407 low
        volatile uint32_t GFXMMU_LUT407H;  ///< Offset: 0x1CBC - GFXMMU LUT entry 407 high
        volatile uint32_t GFXMMU_LUT408L;  ///< Offset: 0x1CC0 - GFXMMU LUT entry 408 low
        volatile uint32_t GFXMMU_LUT408H;  ///< Offset: 0x1CC4 - GFXMMU LUT entry 408 high
        volatile uint32_t GFXMMU_LUT409L;  ///< Offset: 0x1CC8 - GFXMMU LUT entry 409 low
        volatile uint32_t GFXMMU_LUT409H;  ///< Offset: 0x1CCC - GFXMMU LUT entry 409 high
        volatile uint32_t GFXMMU_LUT410L;  ///< Offset: 0x1CD0 - GFXMMU LUT entry 410 low
        volatile uint32_t GFXMMU_LUT410H;  ///< Offset: 0x1CD4 - GFXMMU LUT entry 410 high
        volatile uint32_t GFXMMU_LUT411L;  ///< Offset: 0x1CD8 - GFXMMU LUT entry 411 low
        volatile uint32_t GFXMMU_LUT411H;  ///< Offset: 0x1CDC - GFXMMU LUT entry 411 high
        volatile uint32_t GFXMMU_LUT412L;  ///< Offset: 0x1CE0 - GFXMMU LUT entry 412 low
        volatile uint32_t GFXMMU_LUT412H;  ///< Offset: 0x1CE4 - GFXMMU LUT entry 412 high
        volatile uint32_t GFXMMU_LUT413L;  ///< Offset: 0x1CE8 - GFXMMU LUT entry 413 low
        volatile uint32_t GFXMMU_LUT413H;  ///< Offset: 0x1CEC - GFXMMU LUT entry 413 high
        volatile uint32_t GFXMMU_LUT414L;  ///< Offset: 0x1CF0 - GFXMMU LUT entry 414 low
        volatile uint32_t GFXMMU_LUT414H;  ///< Offset: 0x1CF4 - GFXMMU LUT entry 414 high
        volatile uint32_t GFXMMU_LUT415L;  ///< Offset: 0x1CF8 - GFXMMU LUT entry 415 low
        volatile uint32_t GFXMMU_LUT415H;  ///< Offset: 0x1CFC - GFXMMU LUT entry 415 high
        volatile uint32_t GFXMMU_LUT416L;  ///< Offset: 0x1D00 - GFXMMU LUT entry 416 low
        volatile uint32_t GFXMMU_LUT416H;  ///< Offset: 0x1D04 - GFXMMU LUT entry 416 high
        volatile uint32_t GFXMMU_LUT417L;  ///< Offset: 0x1D08 - GFXMMU LUT entry 417 low
        volatile uint32_t GFXMMU_LUT417H;  ///< Offset: 0x1D0C - GFXMMU LUT entry 417 high
        volatile uint32_t GFXMMU_LUT418L;  ///< Offset: 0x1D10 - GFXMMU LUT entry 418 low
        volatile uint32_t GFXMMU_LUT418H;  ///< Offset: 0x1D14 - GFXMMU LUT entry 418 high
        volatile uint32_t GFXMMU_LUT419L;  ///< Offset: 0x1D18 - GFXMMU LUT entry 419 low
        volatile uint32_t GFXMMU_LUT419H;  ///< Offset: 0x1D1C - GFXMMU LUT entry 419 high
        volatile uint32_t GFXMMU_LUT420L;  ///< Offset: 0x1D20 - GFXMMU LUT entry 420 low
        volatile uint32_t GFXMMU_LUT420H;  ///< Offset: 0x1D24 - GFXMMU LUT entry 420 high
        volatile uint32_t GFXMMU_LUT421L;  ///< Offset: 0x1D28 - GFXMMU LUT entry 421 low
        volatile uint32_t GFXMMU_LUT421H;  ///< Offset: 0x1D2C - GFXMMU LUT entry 421 high
        volatile uint32_t GFXMMU_LUT422L;  ///< Offset: 0x1D30 - GFXMMU LUT entry 422 low
        volatile uint32_t GFXMMU_LUT422H;  ///< Offset: 0x1D34 - GFXMMU LUT entry 422 high
        volatile uint32_t GFXMMU_LUT423L;  ///< Offset: 0x1D38 - GFXMMU LUT entry 423 low
        volatile uint32_t GFXMMU_LUT423H;  ///< Offset: 0x1D3C - GFXMMU LUT entry 423 high
        volatile uint32_t GFXMMU_LUT424L;  ///< Offset: 0x1D40 - GFXMMU LUT entry 424 low
        volatile uint32_t GFXMMU_LUT424H;  ///< Offset: 0x1D44 - GFXMMU LUT entry 424 high
        volatile uint32_t GFXMMU_LUT425L;  ///< Offset: 0x1D48 - GFXMMU LUT entry 425 low
        volatile uint32_t GFXMMU_LUT425H;  ///< Offset: 0x1D4C - GFXMMU LUT entry 425 high
        volatile uint32_t GFXMMU_LUT426L;  ///< Offset: 0x1D50 - GFXMMU LUT entry 426 low
        volatile uint32_t GFXMMU_LUT426H;  ///< Offset: 0x1D54 - GFXMMU LUT entry 426 high
        volatile uint32_t GFXMMU_LUT427L;  ///< Offset: 0x1D58 - GFXMMU LUT entry 427 low
        volatile uint32_t GFXMMU_LUT427H;  ///< Offset: 0x1D5C - GFXMMU LUT entry 427 high
        volatile uint32_t GFXMMU_LUT428L;  ///< Offset: 0x1D60 - GFXMMU LUT entry 428 low
        volatile uint32_t GFXMMU_LUT428H;  ///< Offset: 0x1D64 - GFXMMU LUT entry 428 high
        volatile uint32_t GFXMMU_LUT429L;  ///< Offset: 0x1D68 - GFXMMU LUT entry 429 low
        volatile uint32_t GFXMMU_LUT429H;  ///< Offset: 0x1D6C - GFXMMU LUT entry 429 high
        volatile uint32_t GFXMMU_LUT430L;  ///< Offset: 0x1D70 - GFXMMU LUT entry 430 low
        volatile uint32_t GFXMMU_LUT430H;  ///< Offset: 0x1D74 - GFXMMU LUT entry 430 high
        volatile uint32_t GFXMMU_LUT431L;  ///< Offset: 0x1D78 - GFXMMU LUT entry 431 low
        volatile uint32_t GFXMMU_LUT431H;  ///< Offset: 0x1D7C - GFXMMU LUT entry 431 high
        volatile uint32_t GFXMMU_LUT432L;  ///< Offset: 0x1D80 - GFXMMU LUT entry 432 low
        volatile uint32_t GFXMMU_LUT432H;  ///< Offset: 0x1D84 - GFXMMU LUT entry 432 high
        volatile uint32_t GFXMMU_LUT433L;  ///< Offset: 0x1D88 - GFXMMU LUT entry 433 low
        volatile uint32_t GFXMMU_LUT433H;  ///< Offset: 0x1D8C - GFXMMU LUT entry 433 high
        volatile uint32_t GFXMMU_LUT434L;  ///< Offset: 0x1D90 - GFXMMU LUT entry 434 low
        volatile uint32_t GFXMMU_LUT434H;  ///< Offset: 0x1D94 - GFXMMU LUT entry 434 high
        volatile uint32_t GFXMMU_LUT435L;  ///< Offset: 0x1D98 - GFXMMU LUT entry 435 low
        volatile uint32_t GFXMMU_LUT435H;  ///< Offset: 0x1D9C - GFXMMU LUT entry 435 high
        volatile uint32_t GFXMMU_LUT436L;  ///< Offset: 0x1DA0 - GFXMMU LUT entry 436 low
        volatile uint32_t GFXMMU_LUT436H;  ///< Offset: 0x1DA4 - GFXMMU LUT entry 436 high
        volatile uint32_t GFXMMU_LUT437L;  ///< Offset: 0x1DA8 - GFXMMU LUT entry 437 low
        volatile uint32_t GFXMMU_LUT437H;  ///< Offset: 0x1DAC - GFXMMU LUT entry 437 high
        volatile uint32_t GFXMMU_LUT438L;  ///< Offset: 0x1DB0 - GFXMMU LUT entry 438 low
        volatile uint32_t GFXMMU_LUT438H;  ///< Offset: 0x1DB4 - GFXMMU LUT entry 438 high
        volatile uint32_t GFXMMU_LUT439L;  ///< Offset: 0x1DB8 - GFXMMU LUT entry 439 low
        volatile uint32_t GFXMMU_LUT439H;  ///< Offset: 0x1DBC - GFXMMU LUT entry 439 high
        volatile uint32_t GFXMMU_LUT440L;  ///< Offset: 0x1DC0 - GFXMMU LUT entry 440 low
        volatile uint32_t GFXMMU_LUT440H;  ///< Offset: 0x1DC4 - GFXMMU LUT entry 440 high
        volatile uint32_t GFXMMU_LUT441L;  ///< Offset: 0x1DC8 - GFXMMU LUT entry 441 low
        volatile uint32_t GFXMMU_LUT441H;  ///< Offset: 0x1DCC - GFXMMU LUT entry 441 high
        volatile uint32_t GFXMMU_LUT442L;  ///< Offset: 0x1DD0 - GFXMMU LUT entry 442 low
        volatile uint32_t GFXMMU_LUT442H;  ///< Offset: 0x1DD4 - GFXMMU LUT entry 442 high
        volatile uint32_t GFXMMU_LUT443L;  ///< Offset: 0x1DD8 - GFXMMU LUT entry 443 low
        volatile uint32_t GFXMMU_LUT443H;  ///< Offset: 0x1DDC - GFXMMU LUT entry 443 high
        volatile uint32_t GFXMMU_LUT444L;  ///< Offset: 0x1DE0 - GFXMMU LUT entry 444 low
        volatile uint32_t GFXMMU_LUT444H;  ///< Offset: 0x1DE4 - GFXMMU LUT entry 444 high
        volatile uint32_t GFXMMU_LUT445L;  ///< Offset: 0x1DE8 - GFXMMU LUT entry 445 low
        volatile uint32_t GFXMMU_LUT445H;  ///< Offset: 0x1DEC - GFXMMU LUT entry 445 high
        volatile uint32_t GFXMMU_LUT446L;  ///< Offset: 0x1DF0 - GFXMMU LUT entry 446 low
        volatile uint32_t GFXMMU_LUT446H;  ///< Offset: 0x1DF4 - GFXMMU LUT entry 446 high
        volatile uint32_t GFXMMU_LUT447L;  ///< Offset: 0x1DF8 - GFXMMU LUT entry 447 low
        volatile uint32_t GFXMMU_LUT447H;  ///< Offset: 0x1DFC - GFXMMU LUT entry 447 high
        volatile uint32_t GFXMMU_LUT448L;  ///< Offset: 0x1E00 - GFXMMU LUT entry 448 low
        volatile uint32_t GFXMMU_LUT448H;  ///< Offset: 0x1E04 - GFXMMU LUT entry 448 high
        volatile uint32_t GFXMMU_LUT449L;  ///< Offset: 0x1E08 - GFXMMU LUT entry 449 low
        volatile uint32_t GFXMMU_LUT449H;  ///< Offset: 0x1E0C - GFXMMU LUT entry 449 high
        volatile uint32_t GFXMMU_LUT450L;  ///< Offset: 0x1E10 - GFXMMU LUT entry 450 low
        volatile uint32_t GFXMMU_LUT450H;  ///< Offset: 0x1E14 - GFXMMU LUT entry 450 high
        volatile uint32_t GFXMMU_LUT451L;  ///< Offset: 0x1E18 - GFXMMU LUT entry 451 low
        volatile uint32_t GFXMMU_LUT451H;  ///< Offset: 0x1E1C - GFXMMU LUT entry 451 high
        volatile uint32_t GFXMMU_LUT452L;  ///< Offset: 0x1E20 - GFXMMU LUT entry 452 low
        volatile uint32_t GFXMMU_LUT452H;  ///< Offset: 0x1E24 - GFXMMU LUT entry 452 high
        volatile uint32_t GFXMMU_LUT453L;  ///< Offset: 0x1E28 - GFXMMU LUT entry 453 low
        volatile uint32_t GFXMMU_LUT453H;  ///< Offset: 0x1E2C - GFXMMU LUT entry 453 high
        volatile uint32_t GFXMMU_LUT454L;  ///< Offset: 0x1E30 - GFXMMU LUT entry 454 low
        volatile uint32_t GFXMMU_LUT454H;  ///< Offset: 0x1E34 - GFXMMU LUT entry 454 high
        volatile uint32_t GFXMMU_LUT455L;  ///< Offset: 0x1E38 - GFXMMU LUT entry 455 low
        volatile uint32_t GFXMMU_LUT455H;  ///< Offset: 0x1E3C - GFXMMU LUT entry 455 high
        volatile uint32_t GFXMMU_LUT456L;  ///< Offset: 0x1E40 - GFXMMU LUT entry 456 low
        volatile uint32_t GFXMMU_LUT456H;  ///< Offset: 0x1E44 - GFXMMU LUT entry 456 high
        volatile uint32_t GFXMMU_LUT457L;  ///< Offset: 0x1E48 - GFXMMU LUT entry 457 low
        volatile uint32_t GFXMMU_LUT457H;  ///< Offset: 0x1E4C - GFXMMU LUT entry 457 high
        volatile uint32_t GFXMMU_LUT458L;  ///< Offset: 0x1E50 - GFXMMU LUT entry 458 low
        volatile uint32_t GFXMMU_LUT458H;  ///< Offset: 0x1E54 - GFXMMU LUT entry 458 high
        volatile uint32_t GFXMMU_LUT459L;  ///< Offset: 0x1E58 - GFXMMU LUT entry 459 low
        volatile uint32_t GFXMMU_LUT459H;  ///< Offset: 0x1E5C - GFXMMU LUT entry 459 high
        volatile uint32_t GFXMMU_LUT460L;  ///< Offset: 0x1E60 - GFXMMU LUT entry 460 low
        volatile uint32_t GFXMMU_LUT460H;  ///< Offset: 0x1E64 - GFXMMU LUT entry 460 high
        volatile uint32_t GFXMMU_LUT461L;  ///< Offset: 0x1E68 - GFXMMU LUT entry 461 low
        volatile uint32_t GFXMMU_LUT461H;  ///< Offset: 0x1E6C - GFXMMU LUT entry 461 high
        volatile uint32_t GFXMMU_LUT462L;  ///< Offset: 0x1E70 - GFXMMU LUT entry 462 low
        volatile uint32_t GFXMMU_LUT462H;  ///< Offset: 0x1E74 - GFXMMU LUT entry 462 high
        volatile uint32_t GFXMMU_LUT463L;  ///< Offset: 0x1E78 - GFXMMU LUT entry 463 low
        volatile uint32_t GFXMMU_LUT463H;  ///< Offset: 0x1E7C - GFXMMU LUT entry 463 high
        volatile uint32_t GFXMMU_LUT464L;  ///< Offset: 0x1E80 - GFXMMU LUT entry 464 low
        volatile uint32_t GFXMMU_LUT464H;  ///< Offset: 0x1E84 - GFXMMU LUT entry 464 high
        volatile uint32_t GFXMMU_LUT465L;  ///< Offset: 0x1E88 - GFXMMU LUT entry 465 low
        volatile uint32_t GFXMMU_LUT465H;  ///< Offset: 0x1E8C - GFXMMU LUT entry 465 high
        volatile uint32_t GFXMMU_LUT466L;  ///< Offset: 0x1E90 - GFXMMU LUT entry 466 low
        volatile uint32_t GFXMMU_LUT466H;  ///< Offset: 0x1E94 - GFXMMU LUT entry 466 high
        volatile uint32_t GFXMMU_LUT467L;  ///< Offset: 0x1E98 - GFXMMU LUT entry 467 low
        volatile uint32_t GFXMMU_LUT467H;  ///< Offset: 0x1E9C - GFXMMU LUT entry 467 high
        volatile uint32_t GFXMMU_LUT468L;  ///< Offset: 0x1EA0 - GFXMMU LUT entry 468 low
        volatile uint32_t GFXMMU_LUT468H;  ///< Offset: 0x1EA4 - GFXMMU LUT entry 468 high
        volatile uint32_t GFXMMU_LUT469L;  ///< Offset: 0x1EA8 - GFXMMU LUT entry 469 low
        volatile uint32_t GFXMMU_LUT469H;  ///< Offset: 0x1EAC - GFXMMU LUT entry 469 high
        volatile uint32_t GFXMMU_LUT470L;  ///< Offset: 0x1EB0 - GFXMMU LUT entry 470 low
        volatile uint32_t GFXMMU_LUT470H;  ///< Offset: 0x1EB4 - GFXMMU LUT entry 470 high
        volatile uint32_t GFXMMU_LUT471L;  ///< Offset: 0x1EB8 - GFXMMU LUT entry 471 low
        volatile uint32_t GFXMMU_LUT471H;  ///< Offset: 0x1EBC - GFXMMU LUT entry 471 high
        volatile uint32_t GFXMMU_LUT472L;  ///< Offset: 0x1EC0 - GFXMMU LUT entry 472 low
        volatile uint32_t GFXMMU_LUT472H;  ///< Offset: 0x1EC4 - GFXMMU LUT entry 472 high
        volatile uint32_t GFXMMU_LUT473L;  ///< Offset: 0x1EC8 - GFXMMU LUT entry 473 low
        volatile uint32_t GFXMMU_LUT473H;  ///< Offset: 0x1ECC - GFXMMU LUT entry 473 high
        volatile uint32_t GFXMMU_LUT474L;  ///< Offset: 0x1ED0 - GFXMMU LUT entry 474 low
        volatile uint32_t GFXMMU_LUT474H;  ///< Offset: 0x1ED4 - GFXMMU LUT entry 474 high
        volatile uint32_t GFXMMU_LUT475L;  ///< Offset: 0x1ED8 - GFXMMU LUT entry 475 low
        volatile uint32_t GFXMMU_LUT475H;  ///< Offset: 0x1EDC - GFXMMU LUT entry 475 high
        volatile uint32_t GFXMMU_LUT476L;  ///< Offset: 0x1EE0 - GFXMMU LUT entry 476 low
        volatile uint32_t GFXMMU_LUT476H;  ///< Offset: 0x1EE4 - GFXMMU LUT entry 476 high
        volatile uint32_t GFXMMU_LUT477L;  ///< Offset: 0x1EE8 - GFXMMU LUT entry 477 low
        volatile uint32_t GFXMMU_LUT477H;  ///< Offset: 0x1EEC - GFXMMU LUT entry 477 high
        volatile uint32_t GFXMMU_LUT478L;  ///< Offset: 0x1EF0 - GFXMMU LUT entry 478 low
        volatile uint32_t GFXMMU_LUT478H;  ///< Offset: 0x1EF4 - GFXMMU LUT entry 478 high
        volatile uint32_t GFXMMU_LUT479L;  ///< Offset: 0x1EF8 - GFXMMU LUT entry 479 low
        volatile uint32_t GFXMMU_LUT479H;  ///< Offset: 0x1EFC - GFXMMU LUT entry 479 high
        volatile uint32_t GFXMMU_LUT480L;  ///< Offset: 0x1F00 - GFXMMU LUT entry 480 low
        volatile uint32_t GFXMMU_LUT480H;  ///< Offset: 0x1F04 - GFXMMU LUT entry 480 high
        volatile uint32_t GFXMMU_LUT481L;  ///< Offset: 0x1F08 - GFXMMU LUT entry 481 low
        volatile uint32_t GFXMMU_LUT481H;  ///< Offset: 0x1F0C - GFXMMU LUT entry 481 high
        volatile uint32_t GFXMMU_LUT482L;  ///< Offset: 0x1F10 - GFXMMU LUT entry 482 low
        volatile uint32_t GFXMMU_LUT482H;  ///< Offset: 0x1F14 - GFXMMU LUT entry 482 high
        volatile uint32_t GFXMMU_LUT483L;  ///< Offset: 0x1F18 - GFXMMU LUT entry 483 low
        volatile uint32_t GFXMMU_LUT483H;  ///< Offset: 0x1F1C - GFXMMU LUT entry 483 high
        volatile uint32_t GFXMMU_LUT484L;  ///< Offset: 0x1F20 - GFXMMU LUT entry 484 low
        volatile uint32_t GFXMMU_LUT484H;  ///< Offset: 0x1F24 - GFXMMU LUT entry 484 high
        volatile uint32_t GFXMMU_LUT485L;  ///< Offset: 0x1F28 - GFXMMU LUT entry 485 low
        volatile uint32_t GFXMMU_LUT485H;  ///< Offset: 0x1F2C - GFXMMU LUT entry 485 high
        volatile uint32_t GFXMMU_LUT486L;  ///< Offset: 0x1F30 - GFXMMU LUT entry 486 low
        volatile uint32_t GFXMMU_LUT486H;  ///< Offset: 0x1F34 - GFXMMU LUT entry 486 high
        volatile uint32_t GFXMMU_LUT487L;  ///< Offset: 0x1F38 - GFXMMU LUT entry 487 low
        volatile uint32_t GFXMMU_LUT487H;  ///< Offset: 0x1F3C - GFXMMU LUT entry 487 high
        volatile uint32_t GFXMMU_LUT488L;  ///< Offset: 0x1F40 - GFXMMU LUT entry 488 low
        volatile uint32_t GFXMMU_LUT488H;  ///< Offset: 0x1F44 - GFXMMU LUT entry 488 high
        volatile uint32_t GFXMMU_LUT489L;  ///< Offset: 0x1F48 - GFXMMU LUT entry 489 low
        volatile uint32_t GFXMMU_LUT489H;  ///< Offset: 0x1F4C - GFXMMU LUT entry 489 high
        volatile uint32_t GFXMMU_LUT490L;  ///< Offset: 0x1F50 - GFXMMU LUT entry 490 low
        volatile uint32_t GFXMMU_LUT490H;  ///< Offset: 0x1F54 - GFXMMU LUT entry 490 high
        volatile uint32_t GFXMMU_LUT491L;  ///< Offset: 0x1F58 - GFXMMU LUT entry 491 low
        volatile uint32_t GFXMMU_LUT491H;  ///< Offset: 0x1F5C - GFXMMU LUT entry 491 high
        volatile uint32_t GFXMMU_LUT492L;  ///< Offset: 0x1F60 - GFXMMU LUT entry 492 low
        volatile uint32_t GFXMMU_LUT492H;  ///< Offset: 0x1F64 - GFXMMU LUT entry 492 high
        volatile uint32_t GFXMMU_LUT493L;  ///< Offset: 0x1F68 - GFXMMU LUT entry 493 low
        volatile uint32_t GFXMMU_LUT493H;  ///< Offset: 0x1F6C - GFXMMU LUT entry 493 high
        volatile uint32_t GFXMMU_LUT494L;  ///< Offset: 0x1F70 - GFXMMU LUT entry 494 low
        volatile uint32_t GFXMMU_LUT494H;  ///< Offset: 0x1F74 - GFXMMU LUT entry 494 high
        volatile uint32_t GFXMMU_LUT495L;  ///< Offset: 0x1F78 - GFXMMU LUT entry 495 low
        volatile uint32_t GFXMMU_LUT495H;  ///< Offset: 0x1F7C - GFXMMU LUT entry 495 high
        volatile uint32_t GFXMMU_LUT496L;  ///< Offset: 0x1F80 - GFXMMU LUT entry 496 low
        volatile uint32_t GFXMMU_LUT496H;  ///< Offset: 0x1F84 - GFXMMU LUT entry 496 high
        volatile uint32_t GFXMMU_LUT497L;  ///< Offset: 0x1F88 - GFXMMU LUT entry 497 low
        volatile uint32_t GFXMMU_LUT497H;  ///< Offset: 0x1F8C - GFXMMU LUT entry 497 high
        volatile uint32_t GFXMMU_LUT498L;  ///< Offset: 0x1F90 - GFXMMU LUT entry 498 low
        volatile uint32_t GFXMMU_LUT498H;  ///< Offset: 0x1F94 - GFXMMU LUT entry 498 high
        volatile uint32_t GFXMMU_LUT499L;  ///< Offset: 0x1F98 - GFXMMU LUT entry 499 low
        volatile uint32_t GFXMMU_LUT499H;  ///< Offset: 0x1F9C - GFXMMU LUT entry 499 high
        volatile uint32_t GFXMMU_LUT500L;  ///< Offset: 0x1FA0 - GFXMMU LUT entry 500 low
        volatile uint32_t GFXMMU_LUT500H;  ///< Offset: 0x1FA4 - GFXMMU LUT entry 500 high
        volatile uint32_t GFXMMU_LUT501L;  ///< Offset: 0x1FA8 - GFXMMU LUT entry 501 low
        volatile uint32_t GFXMMU_LUT501H;  ///< Offset: 0x1FAC - GFXMMU LUT entry 501 high
        volatile uint32_t GFXMMU_LUT502L;  ///< Offset: 0x1FB0 - GFXMMU LUT entry 502 low
        volatile uint32_t GFXMMU_LUT502H;  ///< Offset: 0x1FB4 - GFXMMU LUT entry 502 high
        volatile uint32_t GFXMMU_LUT503L;  ///< Offset: 0x1FB8 - GFXMMU LUT entry 503 low
        volatile uint32_t GFXMMU_LUT503H;  ///< Offset: 0x1FBC - GFXMMU LUT entry 503 high
        volatile uint32_t GFXMMU_LUT504L;  ///< Offset: 0x1FC0 - GFXMMU LUT entry 504 low
        volatile uint32_t GFXMMU_LUT504H;  ///< Offset: 0x1FC4 - GFXMMU LUT entry 504 high
        volatile uint32_t GFXMMU_LUT505L;  ///< Offset: 0x1FC8 - GFXMMU LUT entry 505 low
        volatile uint32_t GFXMMU_LUT505H;  ///< Offset: 0x1FCC - GFXMMU LUT entry 505 high
        volatile uint32_t GFXMMU_LUT506L;  ///< Offset: 0x1FD0 - GFXMMU LUT entry 506 low
        volatile uint32_t GFXMMU_LUT506H;  ///< Offset: 0x1FD4 - GFXMMU LUT entry 506 high
        volatile uint32_t GFXMMU_LUT507L;  ///< Offset: 0x1FD8 - GFXMMU LUT entry 507 low
        volatile uint32_t GFXMMU_LUT507H;  ///< Offset: 0x1FDC - GFXMMU LUT entry 507 high
        volatile uint32_t GFXMMU_LUT508L;  ///< Offset: 0x1FE0 - GFXMMU LUT entry 508 low
        volatile uint32_t GFXMMU_LUT508H;  ///< Offset: 0x1FE4 - GFXMMU LUT entry 508 high
        volatile uint32_t GFXMMU_LUT509L;  ///< Offset: 0x1FE8 - GFXMMU LUT entry 509 low
        volatile uint32_t GFXMMU_LUT509H;  ///< Offset: 0x1FEC - GFXMMU LUT entry 509 high
        volatile uint32_t GFXMMU_LUT510L;  ///< Offset: 0x1FF0 - GFXMMU LUT entry 510 low
        volatile uint32_t GFXMMU_LUT510H;  ///< Offset: 0x1FF4 - GFXMMU LUT entry 510 high
        volatile uint32_t GFXMMU_LUT511L;  ///< Offset: 0x1FF8 - GFXMMU LUT entry 511 low
        volatile uint32_t GFXMMU_LUT511H;  ///< Offset: 0x1FFC - GFXMMU LUT entry 511 high
        volatile uint32_t GFXMMU_LUT512L;  ///< Offset: 0x2000 - GFXMMU LUT entry 512 low
        volatile uint32_t GFXMMU_LUT512H;  ///< Offset: 0x2004 - GFXMMU LUT entry 512 high
        volatile uint32_t GFXMMU_LUT513L;  ///< Offset: 0x2008 - GFXMMU LUT entry 513 low
        volatile uint32_t GFXMMU_LUT513H;  ///< Offset: 0x200C - GFXMMU LUT entry 513 high
        volatile uint32_t GFXMMU_LUT514L;  ///< Offset: 0x2010 - GFXMMU LUT entry 514 low
        volatile uint32_t GFXMMU_LUT514H;  ///< Offset: 0x2014 - GFXMMU LUT entry 514 high
        volatile uint32_t GFXMMU_LUT515L;  ///< Offset: 0x2018 - GFXMMU LUT entry 515 low
        volatile uint32_t GFXMMU_LUT515H;  ///< Offset: 0x201C - GFXMMU LUT entry 515 high
        volatile uint32_t GFXMMU_LUT516L;  ///< Offset: 0x2020 - GFXMMU LUT entry 516 low
        volatile uint32_t GFXMMU_LUT516H;  ///< Offset: 0x2024 - GFXMMU LUT entry 516 high
        volatile uint32_t GFXMMU_LUT517L;  ///< Offset: 0x2028 - GFXMMU LUT entry 517 low
        volatile uint32_t GFXMMU_LUT517H;  ///< Offset: 0x202C - GFXMMU LUT entry 517 high
        volatile uint32_t GFXMMU_LUT518L;  ///< Offset: 0x2030 - GFXMMU LUT entry 518 low
        volatile uint32_t GFXMMU_LUT518H;  ///< Offset: 0x2034 - GFXMMU LUT entry 518 high
        volatile uint32_t GFXMMU_LUT519L;  ///< Offset: 0x2038 - GFXMMU LUT entry 519 low
        volatile uint32_t GFXMMU_LUT519H;  ///< Offset: 0x203C - GFXMMU LUT entry 519 high
        volatile uint32_t GFXMMU_LUT520L;  ///< Offset: 0x2040 - GFXMMU LUT entry 520 low
        volatile uint32_t GFXMMU_LUT520H;  ///< Offset: 0x2044 - GFXMMU LUT entry 520 high
        volatile uint32_t GFXMMU_LUT521L;  ///< Offset: 0x2048 - GFXMMU LUT entry 521 low
        volatile uint32_t GFXMMU_LUT521H;  ///< Offset: 0x204C - GFXMMU LUT entry 521 high
        volatile uint32_t GFXMMU_LUT522L;  ///< Offset: 0x2050 - GFXMMU LUT entry 522 low
        volatile uint32_t GFXMMU_LUT522H;  ///< Offset: 0x2054 - GFXMMU LUT entry 522 high
        volatile uint32_t GFXMMU_LUT523L;  ///< Offset: 0x2058 - GFXMMU LUT entry 523 low
        volatile uint32_t GFXMMU_LUT523H;  ///< Offset: 0x205C - GFXMMU LUT entry 523 high
        volatile uint32_t GFXMMU_LUT524L;  ///< Offset: 0x2060 - GFXMMU LUT entry 524 low
        volatile uint32_t GFXMMU_LUT524H;  ///< Offset: 0x2064 - GFXMMU LUT entry 524 high
        volatile uint32_t GFXMMU_LUT525L;  ///< Offset: 0x2068 - GFXMMU LUT entry 525 low
        volatile uint32_t GFXMMU_LUT525H;  ///< Offset: 0x206C - GFXMMU LUT entry 525 high
        volatile uint32_t GFXMMU_LUT526L;  ///< Offset: 0x2070 - GFXMMU LUT entry 526 low
        volatile uint32_t GFXMMU_LUT526H;  ///< Offset: 0x2074 - GFXMMU LUT entry 526 high
        volatile uint32_t GFXMMU_LUT527L;  ///< Offset: 0x2078 - GFXMMU LUT entry 527 low
        volatile uint32_t GFXMMU_LUT527H;  ///< Offset: 0x207C - GFXMMU LUT entry 527 high
        volatile uint32_t GFXMMU_LUT528L;  ///< Offset: 0x2080 - GFXMMU LUT entry 528 low
        volatile uint32_t GFXMMU_LUT528H;  ///< Offset: 0x2084 - GFXMMU LUT entry 528 high
        volatile uint32_t GFXMMU_LUT529L;  ///< Offset: 0x2088 - GFXMMU LUT entry 529 low
        volatile uint32_t GFXMMU_LUT529H;  ///< Offset: 0x208C - GFXMMU LUT entry 529 high
        volatile uint32_t GFXMMU_LUT530L;  ///< Offset: 0x2090 - GFXMMU LUT entry 530 low
        volatile uint32_t GFXMMU_LUT530H;  ///< Offset: 0x2094 - GFXMMU LUT entry 530 high
        volatile uint32_t GFXMMU_LUT531L;  ///< Offset: 0x2098 - GFXMMU LUT entry 531 low
        volatile uint32_t GFXMMU_LUT531H;  ///< Offset: 0x209C - GFXMMU LUT entry 531 high
        volatile uint32_t GFXMMU_LUT532L;  ///< Offset: 0x20A0 - GFXMMU LUT entry 532 low
        volatile uint32_t GFXMMU_LUT532H;  ///< Offset: 0x20A4 - GFXMMU LUT entry 532 high
        volatile uint32_t GFXMMU_LUT533L;  ///< Offset: 0x20A8 - GFXMMU LUT entry 533 low
        volatile uint32_t GFXMMU_LUT533H;  ///< Offset: 0x20AC - GFXMMU LUT entry 533 high
        volatile uint32_t GFXMMU_LUT534L;  ///< Offset: 0x20B0 - GFXMMU LUT entry 534 low
        volatile uint32_t GFXMMU_LUT534H;  ///< Offset: 0x20B4 - GFXMMU LUT entry 534 high
        volatile uint32_t GFXMMU_LUT535L;  ///< Offset: 0x20B8 - GFXMMU LUT entry 535 low
        volatile uint32_t GFXMMU_LUT535H;  ///< Offset: 0x20BC - GFXMMU LUT entry 535 high
        volatile uint32_t GFXMMU_LUT536L;  ///< Offset: 0x20C0 - GFXMMU LUT entry 536 low
        volatile uint32_t GFXMMU_LUT536H;  ///< Offset: 0x20C4 - GFXMMU LUT entry 536 high
        volatile uint32_t GFXMMU_LUT537L;  ///< Offset: 0x20C8 - GFXMMU LUT entry 537 low
        volatile uint32_t GFXMMU_LUT537H;  ///< Offset: 0x20CC - GFXMMU LUT entry 537 high
        volatile uint32_t GFXMMU_LUT538L;  ///< Offset: 0x20D0 - GFXMMU LUT entry 538 low
        volatile uint32_t GFXMMU_LUT538H;  ///< Offset: 0x20D4 - GFXMMU LUT entry 538 high
        volatile uint32_t GFXMMU_LUT539L;  ///< Offset: 0x20D8 - GFXMMU LUT entry 539 low
        volatile uint32_t GFXMMU_LUT539H;  ///< Offset: 0x20DC - GFXMMU LUT entry 539 high
        volatile uint32_t GFXMMU_LUT540L;  ///< Offset: 0x20E0 - GFXMMU LUT entry 540 low
        volatile uint32_t GFXMMU_LUT540H;  ///< Offset: 0x20E4 - GFXMMU LUT entry 540 high
        volatile uint32_t GFXMMU_LUT541L;  ///< Offset: 0x20E8 - GFXMMU LUT entry 541 low
        volatile uint32_t GFXMMU_LUT541H;  ///< Offset: 0x20EC - GFXMMU LUT entry 541 high
        volatile uint32_t GFXMMU_LUT542L;  ///< Offset: 0x20F0 - GFXMMU LUT entry 542 low
        volatile uint32_t GFXMMU_LUT542H;  ///< Offset: 0x20F4 - GFXMMU LUT entry 542 high
        volatile uint32_t GFXMMU_LUT543L;  ///< Offset: 0x20F8 - GFXMMU LUT entry 543 low
        volatile uint32_t GFXMMU_LUT543H;  ///< Offset: 0x20FC - GFXMMU LUT entry 543 high
        volatile uint32_t GFXMMU_LUT544L;  ///< Offset: 0x2100 - GFXMMU LUT entry 544 low
        volatile uint32_t GFXMMU_LUT544H;  ///< Offset: 0x2104 - GFXMMU LUT entry 544 high
        volatile uint32_t GFXMMU_LUT545L;  ///< Offset: 0x2108 - GFXMMU LUT entry 545 low
        volatile uint32_t GFXMMU_LUT545H;  ///< Offset: 0x210C - GFXMMU LUT entry 545 high
        volatile uint32_t GFXMMU_LUT546L;  ///< Offset: 0x2110 - GFXMMU LUT entry 546 low
        volatile uint32_t GFXMMU_LUT546H;  ///< Offset: 0x2114 - GFXMMU LUT entry 546 high
        volatile uint32_t GFXMMU_LUT547L;  ///< Offset: 0x2118 - GFXMMU LUT entry 547 low
        volatile uint32_t GFXMMU_LUT547H;  ///< Offset: 0x211C - GFXMMU LUT entry 547 high
        volatile uint32_t GFXMMU_LUT548L;  ///< Offset: 0x2120 - GFXMMU LUT entry 548 low
        volatile uint32_t GFXMMU_LUT548H;  ///< Offset: 0x2124 - GFXMMU LUT entry 548 high
        volatile uint32_t GFXMMU_LUT549L;  ///< Offset: 0x2128 - GFXMMU LUT entry 549 low
        volatile uint32_t GFXMMU_LUT549H;  ///< Offset: 0x212C - GFXMMU LUT entry 549 high
        volatile uint32_t GFXMMU_LUT550L;  ///< Offset: 0x2130 - GFXMMU LUT entry 550 low
        volatile uint32_t GFXMMU_LUT550H;  ///< Offset: 0x2134 - GFXMMU LUT entry 550 high
        volatile uint32_t GFXMMU_LUT551L;  ///< Offset: 0x2138 - GFXMMU LUT entry 551 low
        volatile uint32_t GFXMMU_LUT551H;  ///< Offset: 0x213C - GFXMMU LUT entry 551 high
        volatile uint32_t GFXMMU_LUT552L;  ///< Offset: 0x2140 - GFXMMU LUT entry 552 low
        volatile uint32_t GFXMMU_LUT552H;  ///< Offset: 0x2144 - GFXMMU LUT entry 552 high
        volatile uint32_t GFXMMU_LUT553L;  ///< Offset: 0x2148 - GFXMMU LUT entry 553 low
        volatile uint32_t GFXMMU_LUT553H;  ///< Offset: 0x214C - GFXMMU LUT entry 553 high
        volatile uint32_t GFXMMU_LUT554L;  ///< Offset: 0x2150 - GFXMMU LUT entry 554 low
        volatile uint32_t GFXMMU_LUT554H;  ///< Offset: 0x2154 - GFXMMU LUT entry 554 high
        volatile uint32_t GFXMMU_LUT555L;  ///< Offset: 0x2158 - GFXMMU LUT entry 555 low
        volatile uint32_t GFXMMU_LUT555H;  ///< Offset: 0x215C - GFXMMU LUT entry 555 high
        volatile uint32_t GFXMMU_LUT556L;  ///< Offset: 0x2160 - GFXMMU LUT entry 556 low
        volatile uint32_t GFXMMU_LUT556H;  ///< Offset: 0x2164 - GFXMMU LUT entry 556 high
        volatile uint32_t GFXMMU_LUT557L;  ///< Offset: 0x2168 - GFXMMU LUT entry 557 low
        volatile uint32_t GFXMMU_LUT557H;  ///< Offset: 0x216C - GFXMMU LUT entry 557 high
        volatile uint32_t GFXMMU_LUT558L;  ///< Offset: 0x2170 - GFXMMU LUT entry 558 low
        volatile uint32_t GFXMMU_LUT558H;  ///< Offset: 0x2174 - GFXMMU LUT entry 558 high
        volatile uint32_t GFXMMU_LUT559L;  ///< Offset: 0x2178 - GFXMMU LUT entry 559 low
        volatile uint32_t GFXMMU_LUT559H;  ///< Offset: 0x217C - GFXMMU LUT entry 559 high
        volatile uint32_t GFXMMU_LUT560L;  ///< Offset: 0x2180 - GFXMMU LUT entry 560 low
        volatile uint32_t GFXMMU_LUT560H;  ///< Offset: 0x2184 - GFXMMU LUT entry 560 high
        volatile uint32_t GFXMMU_LUT561L;  ///< Offset: 0x2188 - GFXMMU LUT entry 561 low
        volatile uint32_t GFXMMU_LUT561H;  ///< Offset: 0x218C - GFXMMU LUT entry 561 high
        volatile uint32_t GFXMMU_LUT562L;  ///< Offset: 0x2190 - GFXMMU LUT entry 562 low
        volatile uint32_t GFXMMU_LUT562H;  ///< Offset: 0x2194 - GFXMMU LUT entry 562 high
        volatile uint32_t GFXMMU_LUT563L;  ///< Offset: 0x2198 - GFXMMU LUT entry 563 low
        volatile uint32_t GFXMMU_LUT563H;  ///< Offset: 0x219C - GFXMMU LUT entry 563 high
        volatile uint32_t GFXMMU_LUT564L;  ///< Offset: 0x21A0 - GFXMMU LUT entry 564 low
        volatile uint32_t GFXMMU_LUT564H;  ///< Offset: 0x21A4 - GFXMMU LUT entry 564 high
        volatile uint32_t GFXMMU_LUT565L;  ///< Offset: 0x21A8 - GFXMMU LUT entry 565 low
        volatile uint32_t GFXMMU_LUT565H;  ///< Offset: 0x21AC - GFXMMU LUT entry 565 high
        volatile uint32_t GFXMMU_LUT566L;  ///< Offset: 0x21B0 - GFXMMU LUT entry 566 low
        volatile uint32_t GFXMMU_LUT566H;  ///< Offset: 0x21B4 - GFXMMU LUT entry 566 high
        volatile uint32_t GFXMMU_LUT567L;  ///< Offset: 0x21B8 - GFXMMU LUT entry 567 low
        volatile uint32_t GFXMMU_LUT567H;  ///< Offset: 0x21BC - GFXMMU LUT entry 567 high
        volatile uint32_t GFXMMU_LUT568L;  ///< Offset: 0x21C0 - GFXMMU LUT entry 568 low
        volatile uint32_t GFXMMU_LUT568H;  ///< Offset: 0x21C4 - GFXMMU LUT entry 568 high
        volatile uint32_t GFXMMU_LUT569L;  ///< Offset: 0x21C8 - GFXMMU LUT entry 569 low
        volatile uint32_t GFXMMU_LUT569H;  ///< Offset: 0x21CC - GFXMMU LUT entry 569 high
        volatile uint32_t GFXMMU_LUT570L;  ///< Offset: 0x21D0 - GFXMMU LUT entry 570 low
        volatile uint32_t GFXMMU_LUT570H;  ///< Offset: 0x21D4 - GFXMMU LUT entry 570 high
        volatile uint32_t GFXMMU_LUT571L;  ///< Offset: 0x21D8 - GFXMMU LUT entry 571 low
        volatile uint32_t GFXMMU_LUT571H;  ///< Offset: 0x21DC - GFXMMU LUT entry 571 high
        volatile uint32_t GFXMMU_LUT572L;  ///< Offset: 0x21E0 - GFXMMU LUT entry 572 low
        volatile uint32_t GFXMMU_LUT572H;  ///< Offset: 0x21E4 - GFXMMU LUT entry 572 high
        volatile uint32_t GFXMMU_LUT573L;  ///< Offset: 0x21E8 - GFXMMU LUT entry 573 low
        volatile uint32_t GFXMMU_LUT573H;  ///< Offset: 0x21EC - GFXMMU LUT entry 573 high
        volatile uint32_t GFXMMU_LUT574L;  ///< Offset: 0x21F0 - GFXMMU LUT entry 574 low
        volatile uint32_t GFXMMU_LUT574H;  ///< Offset: 0x21F4 - GFXMMU LUT entry 574 high
        volatile uint32_t GFXMMU_LUT575L;  ///< Offset: 0x21F8 - GFXMMU LUT entry 575 low
        volatile uint32_t GFXMMU_LUT575H;  ///< Offset: 0x21FC - GFXMMU LUT entry 575 high
        volatile uint32_t GFXMMU_LUT576L;  ///< Offset: 0x2200 - GFXMMU LUT entry 576 low
        volatile uint32_t GFXMMU_LUT576H;  ///< Offset: 0x2204 - GFXMMU LUT entry 576 high
        volatile uint32_t GFXMMU_LUT577L;  ///< Offset: 0x2208 - GFXMMU LUT entry 577 low
        volatile uint32_t GFXMMU_LUT577H;  ///< Offset: 0x220C - GFXMMU LUT entry 577 high
        volatile uint32_t GFXMMU_LUT578L;  ///< Offset: 0x2210 - GFXMMU LUT entry 578 low
        volatile uint32_t GFXMMU_LUT578H;  ///< Offset: 0x2214 - GFXMMU LUT entry 578 high
        volatile uint32_t GFXMMU_LUT579L;  ///< Offset: 0x2218 - GFXMMU LUT entry 579 low
        volatile uint32_t GFXMMU_LUT579H;  ///< Offset: 0x221C - GFXMMU LUT entry 579 high
        volatile uint32_t GFXMMU_LUT580L;  ///< Offset: 0x2220 - GFXMMU LUT entry 580 low
        volatile uint32_t GFXMMU_LUT580H;  ///< Offset: 0x2224 - GFXMMU LUT entry 580 high
        volatile uint32_t GFXMMU_LUT581L;  ///< Offset: 0x2228 - GFXMMU LUT entry 581 low
        volatile uint32_t GFXMMU_LUT581H;  ///< Offset: 0x222C - GFXMMU LUT entry 581 high
        volatile uint32_t GFXMMU_LUT582L;  ///< Offset: 0x2230 - GFXMMU LUT entry 582 low
        volatile uint32_t GFXMMU_LUT582H;  ///< Offset: 0x2234 - GFXMMU LUT entry 582 high
        volatile uint32_t GFXMMU_LUT583L;  ///< Offset: 0x2238 - GFXMMU LUT entry 583 low
        volatile uint32_t GFXMMU_LUT583H;  ///< Offset: 0x223C - GFXMMU LUT entry 583 high
        volatile uint32_t GFXMMU_LUT584L;  ///< Offset: 0x2240 - GFXMMU LUT entry 584 low
        volatile uint32_t GFXMMU_LUT584H;  ///< Offset: 0x2244 - GFXMMU LUT entry 584 high
        volatile uint32_t GFXMMU_LUT585L;  ///< Offset: 0x2248 - GFXMMU LUT entry 585 low
        volatile uint32_t GFXMMU_LUT585H;  ///< Offset: 0x224C - GFXMMU LUT entry 585 high
        volatile uint32_t GFXMMU_LUT586L;  ///< Offset: 0x2250 - GFXMMU LUT entry 586 low
        volatile uint32_t GFXMMU_LUT586H;  ///< Offset: 0x2254 - GFXMMU LUT entry 586 high
        volatile uint32_t GFXMMU_LUT587L;  ///< Offset: 0x2258 - GFXMMU LUT entry 587 low
        volatile uint32_t GFXMMU_LUT587H;  ///< Offset: 0x225C - GFXMMU LUT entry 587 high
        volatile uint32_t GFXMMU_LUT588L;  ///< Offset: 0x2260 - GFXMMU LUT entry 588 low
        volatile uint32_t GFXMMU_LUT588H;  ///< Offset: 0x2264 - GFXMMU LUT entry 588 high
        volatile uint32_t GFXMMU_LUT589L;  ///< Offset: 0x2268 - GFXMMU LUT entry 589 low
        volatile uint32_t GFXMMU_LUT589H;  ///< Offset: 0x226C - GFXMMU LUT entry 589 high
        volatile uint32_t GFXMMU_LUT590L;  ///< Offset: 0x2270 - GFXMMU LUT entry 590 low
        volatile uint32_t GFXMMU_LUT590H;  ///< Offset: 0x2274 - GFXMMU LUT entry 590 high
        volatile uint32_t GFXMMU_LUT591L;  ///< Offset: 0x2278 - GFXMMU LUT entry 591 low
        volatile uint32_t GFXMMU_LUT591H;  ///< Offset: 0x227C - GFXMMU LUT entry 591 high
        volatile uint32_t GFXMMU_LUT592L;  ///< Offset: 0x2280 - GFXMMU LUT entry 592 low
        volatile uint32_t GFXMMU_LUT592H;  ///< Offset: 0x2284 - GFXMMU LUT entry 592 high
        volatile uint32_t GFXMMU_LUT593L;  ///< Offset: 0x2288 - GFXMMU LUT entry 593 low
        volatile uint32_t GFXMMU_LUT593H;  ///< Offset: 0x228C - GFXMMU LUT entry 593 high
        volatile uint32_t GFXMMU_LUT594L;  ///< Offset: 0x2290 - GFXMMU LUT entry 594 low
        volatile uint32_t GFXMMU_LUT594H;  ///< Offset: 0x2294 - GFXMMU LUT entry 594 high
        volatile uint32_t GFXMMU_LUT595L;  ///< Offset: 0x2298 - GFXMMU LUT entry 595 low
        volatile uint32_t GFXMMU_LUT595H;  ///< Offset: 0x229C - GFXMMU LUT entry 595 high
        volatile uint32_t GFXMMU_LUT596L;  ///< Offset: 0x22A0 - GFXMMU LUT entry 596 low
        volatile uint32_t GFXMMU_LUT596H;  ///< Offset: 0x22A4 - GFXMMU LUT entry 596 high
        volatile uint32_t GFXMMU_LUT597L;  ///< Offset: 0x22A8 - GFXMMU LUT entry 597 low
        volatile uint32_t GFXMMU_LUT597H;  ///< Offset: 0x22AC - GFXMMU LUT entry 597 high
        volatile uint32_t GFXMMU_LUT598L;  ///< Offset: 0x22B0 - GFXMMU LUT entry 598 low
        volatile uint32_t GFXMMU_LUT598H;  ///< Offset: 0x22B4 - GFXMMU LUT entry 598 high
        volatile uint32_t GFXMMU_LUT599L;  ///< Offset: 0x22B8 - GFXMMU LUT entry 599 low
        volatile uint32_t GFXMMU_LUT599H;  ///< Offset: 0x22BC - GFXMMU LUT entry 599 high
        volatile uint32_t GFXMMU_LUT600L;  ///< Offset: 0x22C0 - GFXMMU LUT entry 600 low
        volatile uint32_t GFXMMU_LUT600H;  ///< Offset: 0x22C4 - GFXMMU LUT entry 600 high
        volatile uint32_t GFXMMU_LUT601L;  ///< Offset: 0x22C8 - GFXMMU LUT entry 601 low
        volatile uint32_t GFXMMU_LUT601H;  ///< Offset: 0x22CC - GFXMMU LUT entry 601 high
        volatile uint32_t GFXMMU_LUT602L;  ///< Offset: 0x22D0 - GFXMMU LUT entry 602 low
        volatile uint32_t GFXMMU_LUT602H;  ///< Offset: 0x22D4 - GFXMMU LUT entry 602 high
        volatile uint32_t GFXMMU_LUT603L;  ///< Offset: 0x22D8 - GFXMMU LUT entry 603 low
        volatile uint32_t GFXMMU_LUT603H;  ///< Offset: 0x22DC - GFXMMU LUT entry 603 high
        volatile uint32_t GFXMMU_LUT604L;  ///< Offset: 0x22E0 - GFXMMU LUT entry 604 low
        volatile uint32_t GFXMMU_LUT604H;  ///< Offset: 0x22E4 - GFXMMU LUT entry 604 high
        volatile uint32_t GFXMMU_LUT605L;  ///< Offset: 0x22E8 - GFXMMU LUT entry 605 low
        volatile uint32_t GFXMMU_LUT605H;  ///< Offset: 0x22EC - GFXMMU LUT entry 605 high
        volatile uint32_t GFXMMU_LUT606L;  ///< Offset: 0x22F0 - GFXMMU LUT entry 606 low
        volatile uint32_t GFXMMU_LUT606H;  ///< Offset: 0x22F4 - GFXMMU LUT entry 606 high
        volatile uint32_t GFXMMU_LUT607L;  ///< Offset: 0x22F8 - GFXMMU LUT entry 607 low
        volatile uint32_t GFXMMU_LUT607H;  ///< Offset: 0x22FC - GFXMMU LUT entry 607 high
        volatile uint32_t GFXMMU_LUT608L;  ///< Offset: 0x2300 - GFXMMU LUT entry 608 low
        volatile uint32_t GFXMMU_LUT608H;  ///< Offset: 0x2304 - GFXMMU LUT entry 608 high
        volatile uint32_t GFXMMU_LUT609L;  ///< Offset: 0x2308 - GFXMMU LUT entry 609 low
        volatile uint32_t GFXMMU_LUT609H;  ///< Offset: 0x230C - GFXMMU LUT entry 609 high
        volatile uint32_t GFXMMU_LUT610L;  ///< Offset: 0x2310 - GFXMMU LUT entry 610 low
        volatile uint32_t GFXMMU_LUT610H;  ///< Offset: 0x2314 - GFXMMU LUT entry 610 high
        volatile uint32_t GFXMMU_LUT611L;  ///< Offset: 0x2318 - GFXMMU LUT entry 611 low
        volatile uint32_t GFXMMU_LUT611H;  ///< Offset: 0x231C - GFXMMU LUT entry 611 high
        volatile uint32_t GFXMMU_LUT612L;  ///< Offset: 0x2320 - GFXMMU LUT entry 612 low
        volatile uint32_t GFXMMU_LUT612H;  ///< Offset: 0x2324 - GFXMMU LUT entry 612 high
        volatile uint32_t GFXMMU_LUT613L;  ///< Offset: 0x2328 - GFXMMU LUT entry 613 low
        volatile uint32_t GFXMMU_LUT613H;  ///< Offset: 0x232C - GFXMMU LUT entry 613 high
        volatile uint32_t GFXMMU_LUT614L;  ///< Offset: 0x2330 - GFXMMU LUT entry 614 low
        volatile uint32_t GFXMMU_LUT614H;  ///< Offset: 0x2334 - GFXMMU LUT entry 614 high
        volatile uint32_t GFXMMU_LUT615L;  ///< Offset: 0x2338 - GFXMMU LUT entry 615 low
        volatile uint32_t GFXMMU_LUT615H;  ///< Offset: 0x233C - GFXMMU LUT entry 615 high
        volatile uint32_t GFXMMU_LUT616L;  ///< Offset: 0x2340 - GFXMMU LUT entry 616 low
        volatile uint32_t GFXMMU_LUT616H;  ///< Offset: 0x2344 - GFXMMU LUT entry 616 high
        volatile uint32_t GFXMMU_LUT617L;  ///< Offset: 0x2348 - GFXMMU LUT entry 617 low
        volatile uint32_t GFXMMU_LUT617H;  ///< Offset: 0x234C - GFXMMU LUT entry 617 high
        volatile uint32_t GFXMMU_LUT618L;  ///< Offset: 0x2350 - GFXMMU LUT entry 618 low
        volatile uint32_t GFXMMU_LUT618H;  ///< Offset: 0x2354 - GFXMMU LUT entry 618 high
        volatile uint32_t GFXMMU_LUT619L;  ///< Offset: 0x2358 - GFXMMU LUT entry 619 low
        volatile uint32_t GFXMMU_LUT619H;  ///< Offset: 0x235C - GFXMMU LUT entry 619 high
        volatile uint32_t GFXMMU_LUT620L;  ///< Offset: 0x2360 - GFXMMU LUT entry 620 low
        volatile uint32_t GFXMMU_LUT620H;  ///< Offset: 0x2364 - GFXMMU LUT entry 620 high
        volatile uint32_t GFXMMU_LUT621L;  ///< Offset: 0x2368 - GFXMMU LUT entry 621 low
        volatile uint32_t GFXMMU_LUT621H;  ///< Offset: 0x236C - GFXMMU LUT entry 621 high
        volatile uint32_t GFXMMU_LUT622L;  ///< Offset: 0x2370 - GFXMMU LUT entry 622 low
        volatile uint32_t GFXMMU_LUT622H;  ///< Offset: 0x2374 - GFXMMU LUT entry 622 high
        volatile uint32_t GFXMMU_LUT623L;  ///< Offset: 0x2378 - GFXMMU LUT entry 623 low
        volatile uint32_t GFXMMU_LUT623H;  ///< Offset: 0x237C - GFXMMU LUT entry 623 high
        volatile uint32_t GFXMMU_LUT624L;  ///< Offset: 0x2380 - GFXMMU LUT entry 624 low
        volatile uint32_t GFXMMU_LUT624H;  ///< Offset: 0x2384 - GFXMMU LUT entry 624 high
        volatile uint32_t GFXMMU_LUT625L;  ///< Offset: 0x2388 - GFXMMU LUT entry 625 low
        volatile uint32_t GFXMMU_LUT625H;  ///< Offset: 0x238C - GFXMMU LUT entry 625 high
        volatile uint32_t GFXMMU_LUT626L;  ///< Offset: 0x2390 - GFXMMU LUT entry 626 low
        volatile uint32_t GFXMMU_LUT626H;  ///< Offset: 0x2394 - GFXMMU LUT entry 626 high
        volatile uint32_t GFXMMU_LUT627L;  ///< Offset: 0x2398 - GFXMMU LUT entry 627 low
        volatile uint32_t GFXMMU_LUT627H;  ///< Offset: 0x239C - GFXMMU LUT entry 627 high
        volatile uint32_t GFXMMU_LUT628L;  ///< Offset: 0x23A0 - GFXMMU LUT entry 628 low
        volatile uint32_t GFXMMU_LUT628H;  ///< Offset: 0x23A4 - GFXMMU LUT entry 628 high
        volatile uint32_t GFXMMU_LUT629L;  ///< Offset: 0x23A8 - GFXMMU LUT entry 629 low
        volatile uint32_t GFXMMU_LUT629H;  ///< Offset: 0x23AC - GFXMMU LUT entry 629 high
        volatile uint32_t GFXMMU_LUT630L;  ///< Offset: 0x23B0 - GFXMMU LUT entry 630 low
        volatile uint32_t GFXMMU_LUT630H;  ///< Offset: 0x23B4 - GFXMMU LUT entry 630 high
        volatile uint32_t GFXMMU_LUT631L;  ///< Offset: 0x23B8 - GFXMMU LUT entry 631 low
        volatile uint32_t GFXMMU_LUT631H;  ///< Offset: 0x23BC - GFXMMU LUT entry 631 high
        volatile uint32_t GFXMMU_LUT632L;  ///< Offset: 0x23C0 - GFXMMU LUT entry 632 low
        volatile uint32_t GFXMMU_LUT632H;  ///< Offset: 0x23C4 - GFXMMU LUT entry 632 high
        volatile uint32_t GFXMMU_LUT633L;  ///< Offset: 0x23C8 - GFXMMU LUT entry 633 low
        volatile uint32_t GFXMMU_LUT633H;  ///< Offset: 0x23CC - GFXMMU LUT entry 633 high
        volatile uint32_t GFXMMU_LUT634L;  ///< Offset: 0x23D0 - GFXMMU LUT entry 634 low
        volatile uint32_t GFXMMU_LUT634H;  ///< Offset: 0x23D4 - GFXMMU LUT entry 634 high
        volatile uint32_t GFXMMU_LUT635L;  ///< Offset: 0x23D8 - GFXMMU LUT entry 635 low
        volatile uint32_t GFXMMU_LUT635H;  ///< Offset: 0x23DC - GFXMMU LUT entry 635 high
        volatile uint32_t GFXMMU_LUT636L;  ///< Offset: 0x23E0 - GFXMMU LUT entry 636 low
        volatile uint32_t GFXMMU_LUT636H;  ///< Offset: 0x23E4 - GFXMMU LUT entry 636 high
        volatile uint32_t GFXMMU_LUT637L;  ///< Offset: 0x23E8 - GFXMMU LUT entry 637 low
        volatile uint32_t GFXMMU_LUT637H;  ///< Offset: 0x23EC - GFXMMU LUT entry 637 high
        volatile uint32_t GFXMMU_LUT638L;  ///< Offset: 0x23F0 - GFXMMU LUT entry 638 low
        volatile uint32_t GFXMMU_LUT638H;  ///< Offset: 0x23F4 - GFXMMU LUT entry 638 high
        volatile uint32_t GFXMMU_LUT639L;  ///< Offset: 0x23F8 - GFXMMU LUT entry 639 low
        volatile uint32_t GFXMMU_LUT639H;  ///< Offset: 0x23FC - GFXMMU LUT entry 639 high
        volatile uint32_t GFXMMU_LUT640L;  ///< Offset: 0x2400 - GFXMMU LUT entry 640 low
        volatile uint32_t GFXMMU_LUT640H;  ///< Offset: 0x2404 - GFXMMU LUT entry 640 high
        volatile uint32_t GFXMMU_LUT641L;  ///< Offset: 0x2408 - GFXMMU LUT entry 641 low
        volatile uint32_t GFXMMU_LUT641H;  ///< Offset: 0x240C - GFXMMU LUT entry 641 high
        volatile uint32_t GFXMMU_LUT642L;  ///< Offset: 0x2410 - GFXMMU LUT entry 642 low
        volatile uint32_t GFXMMU_LUT642H;  ///< Offset: 0x2414 - GFXMMU LUT entry 642 high
        volatile uint32_t GFXMMU_LUT643L;  ///< Offset: 0x2418 - GFXMMU LUT entry 643 low
        volatile uint32_t GFXMMU_LUT643H;  ///< Offset: 0x241C - GFXMMU LUT entry 643 high
        volatile uint32_t GFXMMU_LUT644L;  ///< Offset: 0x2420 - GFXMMU LUT entry 644 low
        volatile uint32_t GFXMMU_LUT644H;  ///< Offset: 0x2424 - GFXMMU LUT entry 644 high
        volatile uint32_t GFXMMU_LUT645L;  ///< Offset: 0x2428 - GFXMMU LUT entry 645 low
        volatile uint32_t GFXMMU_LUT645H;  ///< Offset: 0x242C - GFXMMU LUT entry 645 high
        volatile uint32_t GFXMMU_LUT646L;  ///< Offset: 0x2430 - GFXMMU LUT entry 646 low
        volatile uint32_t GFXMMU_LUT646H;  ///< Offset: 0x2434 - GFXMMU LUT entry 646 high
        volatile uint32_t GFXMMU_LUT647L;  ///< Offset: 0x2438 - GFXMMU LUT entry 647 low
        volatile uint32_t GFXMMU_LUT647H;  ///< Offset: 0x243C - GFXMMU LUT entry 647 high
        volatile uint32_t GFXMMU_LUT648L;  ///< Offset: 0x2440 - GFXMMU LUT entry 648 low
        volatile uint32_t GFXMMU_LUT648H;  ///< Offset: 0x2444 - GFXMMU LUT entry 648 high
        volatile uint32_t GFXMMU_LUT649L;  ///< Offset: 0x2448 - GFXMMU LUT entry 649 low
        volatile uint32_t GFXMMU_LUT649H;  ///< Offset: 0x244C - GFXMMU LUT entry 649 high
        volatile uint32_t GFXMMU_LUT650L;  ///< Offset: 0x2450 - GFXMMU LUT entry 650 low
        volatile uint32_t GFXMMU_LUT650H;  ///< Offset: 0x2454 - GFXMMU LUT entry 650 high
        volatile uint32_t GFXMMU_LUT651L;  ///< Offset: 0x2458 - GFXMMU LUT entry 651 low
        volatile uint32_t GFXMMU_LUT651H;  ///< Offset: 0x245C - GFXMMU LUT entry 651 high
        volatile uint32_t GFXMMU_LUT652L;  ///< Offset: 0x2460 - GFXMMU LUT entry 652 low
        volatile uint32_t GFXMMU_LUT652H;  ///< Offset: 0x2464 - GFXMMU LUT entry 652 high
        volatile uint32_t GFXMMU_LUT653L;  ///< Offset: 0x2468 - GFXMMU LUT entry 653 low
        volatile uint32_t GFXMMU_LUT653H;  ///< Offset: 0x246C - GFXMMU LUT entry 653 high
        volatile uint32_t GFXMMU_LUT654L;  ///< Offset: 0x2470 - GFXMMU LUT entry 654 low
        volatile uint32_t GFXMMU_LUT654H;  ///< Offset: 0x2474 - GFXMMU LUT entry 654 high
        volatile uint32_t GFXMMU_LUT655L;  ///< Offset: 0x2478 - GFXMMU LUT entry 655 low
        volatile uint32_t GFXMMU_LUT655H;  ///< Offset: 0x247C - GFXMMU LUT entry 655 high
        volatile uint32_t GFXMMU_LUT656L;  ///< Offset: 0x2480 - GFXMMU LUT entry 656 low
        volatile uint32_t GFXMMU_LUT656H;  ///< Offset: 0x2484 - GFXMMU LUT entry 656 high
        volatile uint32_t GFXMMU_LUT657L;  ///< Offset: 0x2488 - GFXMMU LUT entry 657 low
        volatile uint32_t GFXMMU_LUT657H;  ///< Offset: 0x248C - GFXMMU LUT entry 657 high
        volatile uint32_t GFXMMU_LUT658L;  ///< Offset: 0x2490 - GFXMMU LUT entry 658 low
        volatile uint32_t GFXMMU_LUT658H;  ///< Offset: 0x2494 - GFXMMU LUT entry 658 high
        volatile uint32_t GFXMMU_LUT659L;  ///< Offset: 0x2498 - GFXMMU LUT entry 659 low
        volatile uint32_t GFXMMU_LUT659H;  ///< Offset: 0x249C - GFXMMU LUT entry 659 high
        volatile uint32_t GFXMMU_LUT660L;  ///< Offset: 0x24A0 - GFXMMU LUT entry 660 low
        volatile uint32_t GFXMMU_LUT660H;  ///< Offset: 0x24A4 - GFXMMU LUT entry 660 high
        volatile uint32_t GFXMMU_LUT661L;  ///< Offset: 0x24A8 - GFXMMU LUT entry 661 low
        volatile uint32_t GFXMMU_LUT661H;  ///< Offset: 0x24AC - GFXMMU LUT entry 661 high
        volatile uint32_t GFXMMU_LUT662L;  ///< Offset: 0x24B0 - GFXMMU LUT entry 662 low
        volatile uint32_t GFXMMU_LUT662H;  ///< Offset: 0x24B4 - GFXMMU LUT entry 662 high
        volatile uint32_t GFXMMU_LUT663L;  ///< Offset: 0x24B8 - GFXMMU LUT entry 663 low
        volatile uint32_t GFXMMU_LUT663H;  ///< Offset: 0x24BC - GFXMMU LUT entry 663 high
        volatile uint32_t GFXMMU_LUT664L;  ///< Offset: 0x24C0 - GFXMMU LUT entry 664 low
        volatile uint32_t GFXMMU_LUT664H;  ///< Offset: 0x24C4 - GFXMMU LUT entry 664 high
        volatile uint32_t GFXMMU_LUT665L;  ///< Offset: 0x24C8 - GFXMMU LUT entry 665 low
        volatile uint32_t GFXMMU_LUT665H;  ///< Offset: 0x24CC - GFXMMU LUT entry 665 high
        volatile uint32_t GFXMMU_LUT666L;  ///< Offset: 0x24D0 - GFXMMU LUT entry 666 low
        volatile uint32_t GFXMMU_LUT666H;  ///< Offset: 0x24D4 - GFXMMU LUT entry 666 high
        volatile uint32_t GFXMMU_LUT667L;  ///< Offset: 0x24D8 - GFXMMU LUT entry 667 low
        volatile uint32_t GFXMMU_LUT667H;  ///< Offset: 0x24DC - GFXMMU LUT entry 667 high
        volatile uint32_t GFXMMU_LUT668L;  ///< Offset: 0x24E0 - GFXMMU LUT entry 668 low
        volatile uint32_t GFXMMU_LUT668H;  ///< Offset: 0x24E4 - GFXMMU LUT entry 668 high
        volatile uint32_t GFXMMU_LUT669L;  ///< Offset: 0x24E8 - GFXMMU LUT entry 669 low
        volatile uint32_t GFXMMU_LUT669H;  ///< Offset: 0x24EC - GFXMMU LUT entry 669 high
        volatile uint32_t GFXMMU_LUT670L;  ///< Offset: 0x24F0 - GFXMMU LUT entry 670 low
        volatile uint32_t GFXMMU_LUT670H;  ///< Offset: 0x24F4 - GFXMMU LUT entry 670 high
        volatile uint32_t GFXMMU_LUT671L;  ///< Offset: 0x24F8 - GFXMMU LUT entry 671 low
        volatile uint32_t GFXMMU_LUT671H;  ///< Offset: 0x24FC - GFXMMU LUT entry 671 high
        volatile uint32_t GFXMMU_LUT672L;  ///< Offset: 0x2500 - GFXMMU LUT entry 672 low
        volatile uint32_t GFXMMU_LUT672H;  ///< Offset: 0x2504 - GFXMMU LUT entry 672 high
        volatile uint32_t GFXMMU_LUT673L;  ///< Offset: 0x2508 - GFXMMU LUT entry 673 low
        volatile uint32_t GFXMMU_LUT673H;  ///< Offset: 0x250C - GFXMMU LUT entry 673 high
        volatile uint32_t GFXMMU_LUT674L;  ///< Offset: 0x2510 - GFXMMU LUT entry 674 low
        volatile uint32_t GFXMMU_LUT674H;  ///< Offset: 0x2514 - GFXMMU LUT entry 674 high
        volatile uint32_t GFXMMU_LUT675L;  ///< Offset: 0x2518 - GFXMMU LUT entry 675 low
        volatile uint32_t GFXMMU_LUT675H;  ///< Offset: 0x251C - GFXMMU LUT entry 675 high
        volatile uint32_t GFXMMU_LUT676L;  ///< Offset: 0x2520 - GFXMMU LUT entry 676 low
        volatile uint32_t GFXMMU_LUT676H;  ///< Offset: 0x2524 - GFXMMU LUT entry 676 high
        volatile uint32_t GFXMMU_LUT677L;  ///< Offset: 0x2528 - GFXMMU LUT entry 677 low
        volatile uint32_t GFXMMU_LUT677H;  ///< Offset: 0x252C - GFXMMU LUT entry 677 high
        volatile uint32_t GFXMMU_LUT678L;  ///< Offset: 0x2530 - GFXMMU LUT entry 678 low
        volatile uint32_t GFXMMU_LUT678H;  ///< Offset: 0x2534 - GFXMMU LUT entry 678 high
        volatile uint32_t GFXMMU_LUT679L;  ///< Offset: 0x2538 - GFXMMU LUT entry 679 low
        volatile uint32_t GFXMMU_LUT679H;  ///< Offset: 0x253C - GFXMMU LUT entry 679 high
        volatile uint32_t GFXMMU_LUT680L;  ///< Offset: 0x2540 - GFXMMU LUT entry 680 low
        volatile uint32_t GFXMMU_LUT680H;  ///< Offset: 0x2544 - GFXMMU LUT entry 680 high
        volatile uint32_t GFXMMU_LUT681L;  ///< Offset: 0x2548 - GFXMMU LUT entry 681 low
        volatile uint32_t GFXMMU_LUT681H;  ///< Offset: 0x254C - GFXMMU LUT entry 681 high
        volatile uint32_t GFXMMU_LUT682L;  ///< Offset: 0x2550 - GFXMMU LUT entry 682 low
        volatile uint32_t GFXMMU_LUT682H;  ///< Offset: 0x2554 - GFXMMU LUT entry 682 high
        volatile uint32_t GFXMMU_LUT683L;  ///< Offset: 0x2558 - GFXMMU LUT entry 683 low
        volatile uint32_t GFXMMU_LUT683H;  ///< Offset: 0x255C - GFXMMU LUT entry 683 high
        volatile uint32_t GFXMMU_LUT684L;  ///< Offset: 0x2560 - GFXMMU LUT entry 684 low
        volatile uint32_t GFXMMU_LUT684H;  ///< Offset: 0x2564 - GFXMMU LUT entry 684 high
        volatile uint32_t GFXMMU_LUT685L;  ///< Offset: 0x2568 - GFXMMU LUT entry 685 low
        volatile uint32_t GFXMMU_LUT685H;  ///< Offset: 0x256C - GFXMMU LUT entry 685 high
        volatile uint32_t GFXMMU_LUT686L;  ///< Offset: 0x2570 - GFXMMU LUT entry 686 low
        volatile uint32_t GFXMMU_LUT686H;  ///< Offset: 0x2574 - GFXMMU LUT entry 686 high
        volatile uint32_t GFXMMU_LUT687L;  ///< Offset: 0x2578 - GFXMMU LUT entry 687 low
        volatile uint32_t GFXMMU_LUT687H;  ///< Offset: 0x257C - GFXMMU LUT entry 687 high
        volatile uint32_t GFXMMU_LUT688L;  ///< Offset: 0x2580 - GFXMMU LUT entry 688 low
        volatile uint32_t GFXMMU_LUT688H;  ///< Offset: 0x2584 - GFXMMU LUT entry 688 high
        volatile uint32_t GFXMMU_LUT689L;  ///< Offset: 0x2588 - GFXMMU LUT entry 689 low
        volatile uint32_t GFXMMU_LUT689H;  ///< Offset: 0x258C - GFXMMU LUT entry 689 high
        volatile uint32_t GFXMMU_LUT690L;  ///< Offset: 0x2590 - GFXMMU LUT entry 690 low
        volatile uint32_t GFXMMU_LUT690H;  ///< Offset: 0x2594 - GFXMMU LUT entry 690 high
        volatile uint32_t GFXMMU_LUT691L;  ///< Offset: 0x2598 - GFXMMU LUT entry 691 low
        volatile uint32_t GFXMMU_LUT691H;  ///< Offset: 0x259C - GFXMMU LUT entry 691 high
        volatile uint32_t GFXMMU_LUT692L;  ///< Offset: 0x25A0 - GFXMMU LUT entry 692 low
        volatile uint32_t GFXMMU_LUT692H;  ///< Offset: 0x25A4 - GFXMMU LUT entry 692 high
        volatile uint32_t GFXMMU_LUT693L;  ///< Offset: 0x25A8 - GFXMMU LUT entry 693 low
        volatile uint32_t GFXMMU_LUT693H;  ///< Offset: 0x25AC - GFXMMU LUT entry 693 high
        volatile uint32_t GFXMMU_LUT694L;  ///< Offset: 0x25B0 - GFXMMU LUT entry 694 low
        volatile uint32_t GFXMMU_LUT694H;  ///< Offset: 0x25B4 - GFXMMU LUT entry 694 high
        volatile uint32_t GFXMMU_LUT695L;  ///< Offset: 0x25B8 - GFXMMU LUT entry 695 low
        volatile uint32_t GFXMMU_LUT695H;  ///< Offset: 0x25BC - GFXMMU LUT entry 695 high
        volatile uint32_t GFXMMU_LUT696L;  ///< Offset: 0x25C0 - GFXMMU LUT entry 696 low
        volatile uint32_t GFXMMU_LUT696H;  ///< Offset: 0x25C4 - GFXMMU LUT entry 696 high
        volatile uint32_t GFXMMU_LUT697L;  ///< Offset: 0x25C8 - GFXMMU LUT entry 697 low
        volatile uint32_t GFXMMU_LUT697H;  ///< Offset: 0x25CC - GFXMMU LUT entry 697 high
        volatile uint32_t GFXMMU_LUT698L;  ///< Offset: 0x25D0 - GFXMMU LUT entry 698 low
        volatile uint32_t GFXMMU_LUT698H;  ///< Offset: 0x25D4 - GFXMMU LUT entry 698 high
        volatile uint32_t GFXMMU_LUT699L;  ///< Offset: 0x25D8 - GFXMMU LUT entry 699 low
        volatile uint32_t GFXMMU_LUT699H;  ///< Offset: 0x25DC - GFXMMU LUT entry 699 high
        volatile uint32_t GFXMMU_LUT700L;  ///< Offset: 0x25E0 - GFXMMU LUT entry 700 low
        volatile uint32_t GFXMMU_LUT700H;  ///< Offset: 0x25E4 - GFXMMU LUT entry 700 high
        volatile uint32_t GFXMMU_LUT701L;  ///< Offset: 0x25E8 - GFXMMU LUT entry 701 low
        volatile uint32_t GFXMMU_LUT701H;  ///< Offset: 0x25EC - GFXMMU LUT entry 701 high
        volatile uint32_t GFXMMU_LUT702L;  ///< Offset: 0x25F0 - GFXMMU LUT entry 702 low
        volatile uint32_t GFXMMU_LUT702H;  ///< Offset: 0x25F4 - GFXMMU LUT entry 702 high
        volatile uint32_t GFXMMU_LUT703L;  ///< Offset: 0x25F8 - GFXMMU LUT entry 703 low
        volatile uint32_t GFXMMU_LUT703H;  ///< Offset: 0x25FC - GFXMMU LUT entry 703 high
        volatile uint32_t GFXMMU_LUT704L;  ///< Offset: 0x2600 - GFXMMU LUT entry 704 low
        volatile uint32_t GFXMMU_LUT704H;  ///< Offset: 0x2604 - GFXMMU LUT entry 704 high
        volatile uint32_t GFXMMU_LUT705L;  ///< Offset: 0x2608 - GFXMMU LUT entry 705 low
        volatile uint32_t GFXMMU_LUT705H;  ///< Offset: 0x260C - GFXMMU LUT entry 705 high
        volatile uint32_t GFXMMU_LUT706L;  ///< Offset: 0x2610 - GFXMMU LUT entry 706 low
        volatile uint32_t GFXMMU_LUT706H;  ///< Offset: 0x2614 - GFXMMU LUT entry 706 high
        volatile uint32_t GFXMMU_LUT707L;  ///< Offset: 0x2618 - GFXMMU LUT entry 707 low
        volatile uint32_t GFXMMU_LUT707H;  ///< Offset: 0x261C - GFXMMU LUT entry 707 high
        volatile uint32_t GFXMMU_LUT708L;  ///< Offset: 0x2620 - GFXMMU LUT entry 708 low
        volatile uint32_t GFXMMU_LUT708H;  ///< Offset: 0x2624 - GFXMMU LUT entry 708 high
        volatile uint32_t GFXMMU_LUT709L;  ///< Offset: 0x2628 - GFXMMU LUT entry 709 low
        volatile uint32_t GFXMMU_LUT709H;  ///< Offset: 0x262C - GFXMMU LUT entry 709 high
        volatile uint32_t GFXMMU_LUT710L;  ///< Offset: 0x2630 - GFXMMU LUT entry 710 low
        volatile uint32_t GFXMMU_LUT710H;  ///< Offset: 0x2634 - GFXMMU LUT entry 710 high
        volatile uint32_t GFXMMU_LUT711L;  ///< Offset: 0x2638 - GFXMMU LUT entry 711 low
        volatile uint32_t GFXMMU_LUT711H;  ///< Offset: 0x263C - GFXMMU LUT entry 711 high
        volatile uint32_t GFXMMU_LUT712L;  ///< Offset: 0x2640 - GFXMMU LUT entry 712 low
        volatile uint32_t GFXMMU_LUT712H;  ///< Offset: 0x2644 - GFXMMU LUT entry 712 high
        volatile uint32_t GFXMMU_LUT713L;  ///< Offset: 0x2648 - GFXMMU LUT entry 713 low
        volatile uint32_t GFXMMU_LUT713H;  ///< Offset: 0x264C - GFXMMU LUT entry 713 high
        volatile uint32_t GFXMMU_LUT714L;  ///< Offset: 0x2650 - GFXMMU LUT entry 714 low
        volatile uint32_t GFXMMU_LUT714H;  ///< Offset: 0x2654 - GFXMMU LUT entry 714 high
        volatile uint32_t GFXMMU_LUT715L;  ///< Offset: 0x2658 - GFXMMU LUT entry 715 low
        volatile uint32_t GFXMMU_LUT715H;  ///< Offset: 0x265C - GFXMMU LUT entry 715 high
        volatile uint32_t GFXMMU_LUT716L;  ///< Offset: 0x2660 - GFXMMU LUT entry 716 low
        volatile uint32_t GFXMMU_LUT716H;  ///< Offset: 0x2664 - GFXMMU LUT entry 716 high
        volatile uint32_t GFXMMU_LUT717L;  ///< Offset: 0x2668 - GFXMMU LUT entry 717 low
        volatile uint32_t GFXMMU_LUT717H;  ///< Offset: 0x266C - GFXMMU LUT entry 717 high
        volatile uint32_t GFXMMU_LUT718L;  ///< Offset: 0x2670 - GFXMMU LUT entry 718 low
        volatile uint32_t GFXMMU_LUT718H;  ///< Offset: 0x2674 - GFXMMU LUT entry 718 high
        volatile uint32_t GFXMMU_LUT719L;  ///< Offset: 0x2678 - GFXMMU LUT entry 719 low
        volatile uint32_t GFXMMU_LUT719H;  ///< Offset: 0x267C - GFXMMU LUT entry 719 high
        volatile uint32_t GFXMMU_LUT720L;  ///< Offset: 0x2680 - GFXMMU LUT entry 720 low
        volatile uint32_t GFXMMU_LUT720H;  ///< Offset: 0x2684 - GFXMMU LUT entry 720 high
        volatile uint32_t GFXMMU_LUT721L;  ///< Offset: 0x2688 - GFXMMU LUT entry 721 low
        volatile uint32_t GFXMMU_LUT721H;  ///< Offset: 0x268C - GFXMMU LUT entry 721 high
        volatile uint32_t GFXMMU_LUT722L;  ///< Offset: 0x2690 - GFXMMU LUT entry 722 low
        volatile uint32_t GFXMMU_LUT722H;  ///< Offset: 0x2694 - GFXMMU LUT entry 722 high
        volatile uint32_t GFXMMU_LUT723L;  ///< Offset: 0x2698 - GFXMMU LUT entry 723 low
        volatile uint32_t GFXMMU_LUT723H;  ///< Offset: 0x269C - GFXMMU LUT entry 723 high
        volatile uint32_t GFXMMU_LUT724L;  ///< Offset: 0x26A0 - GFXMMU LUT entry 724 low
        volatile uint32_t GFXMMU_LUT724H;  ///< Offset: 0x26A4 - GFXMMU LUT entry 724 high
        volatile uint32_t GFXMMU_LUT725L;  ///< Offset: 0x26A8 - GFXMMU LUT entry 725 low
        volatile uint32_t GFXMMU_LUT725H;  ///< Offset: 0x26AC - GFXMMU LUT entry 725 high
        volatile uint32_t GFXMMU_LUT726L;  ///< Offset: 0x26B0 - GFXMMU LUT entry 726 low
        volatile uint32_t GFXMMU_LUT726H;  ///< Offset: 0x26B4 - GFXMMU LUT entry 726 high
        volatile uint32_t GFXMMU_LUT727L;  ///< Offset: 0x26B8 - GFXMMU LUT entry 727 low
        volatile uint32_t GFXMMU_LUT727H;  ///< Offset: 0x26BC - GFXMMU LUT entry 727 high
        volatile uint32_t GFXMMU_LUT728L;  ///< Offset: 0x26C0 - GFXMMU LUT entry 728 low
        volatile uint32_t GFXMMU_LUT728H;  ///< Offset: 0x26C4 - GFXMMU LUT entry 728 high
        volatile uint32_t GFXMMU_LUT729L;  ///< Offset: 0x26C8 - GFXMMU LUT entry 729 low
        volatile uint32_t GFXMMU_LUT729H;  ///< Offset: 0x26CC - GFXMMU LUT entry 729 high
        volatile uint32_t GFXMMU_LUT730L;  ///< Offset: 0x26D0 - GFXMMU LUT entry 730 low
        volatile uint32_t GFXMMU_LUT730H;  ///< Offset: 0x26D4 - GFXMMU LUT entry 730 high
        volatile uint32_t GFXMMU_LUT731L;  ///< Offset: 0x26D8 - GFXMMU LUT entry 731 low
        volatile uint32_t GFXMMU_LUT731H;  ///< Offset: 0x26DC - GFXMMU LUT entry 731 high
        volatile uint32_t GFXMMU_LUT732L;  ///< Offset: 0x26E0 - GFXMMU LUT entry 732 low
        volatile uint32_t GFXMMU_LUT732H;  ///< Offset: 0x26E4 - GFXMMU LUT entry 732 high
        volatile uint32_t GFXMMU_LUT733L;  ///< Offset: 0x26E8 - GFXMMU LUT entry 733 low
        volatile uint32_t GFXMMU_LUT733H;  ///< Offset: 0x26EC - GFXMMU LUT entry 733 high
        volatile uint32_t GFXMMU_LUT734L;  ///< Offset: 0x26F0 - GFXMMU LUT entry 734 low
        volatile uint32_t GFXMMU_LUT734H;  ///< Offset: 0x26F4 - GFXMMU LUT entry 734 high
        volatile uint32_t GFXMMU_LUT735L;  ///< Offset: 0x26F8 - GFXMMU LUT entry 735 low
        volatile uint32_t GFXMMU_LUT735H;  ///< Offset: 0x26FC - GFXMMU LUT entry 735 high
        volatile uint32_t GFXMMU_LUT736L;  ///< Offset: 0x2700 - GFXMMU LUT entry 736 low
        volatile uint32_t GFXMMU_LUT736H;  ///< Offset: 0x2704 - GFXMMU LUT entry 736 high
        volatile uint32_t GFXMMU_LUT737L;  ///< Offset: 0x2708 - GFXMMU LUT entry 737 low
        volatile uint32_t GFXMMU_LUT737H;  ///< Offset: 0x270C - GFXMMU LUT entry 737 high
        volatile uint32_t GFXMMU_LUT738L;  ///< Offset: 0x2710 - GFXMMU LUT entry 738 low
        volatile uint32_t GFXMMU_LUT738H;  ///< Offset: 0x2714 - GFXMMU LUT entry 738 high
        volatile uint32_t GFXMMU_LUT739L;  ///< Offset: 0x2718 - GFXMMU LUT entry 739 low
        volatile uint32_t GFXMMU_LUT739H;  ///< Offset: 0x271C - GFXMMU LUT entry 739 high
        volatile uint32_t GFXMMU_LUT740L;  ///< Offset: 0x2720 - GFXMMU LUT entry 740 low
        volatile uint32_t GFXMMU_LUT740H;  ///< Offset: 0x2724 - GFXMMU LUT entry 740 high
        volatile uint32_t GFXMMU_LUT741L;  ///< Offset: 0x2728 - GFXMMU LUT entry 741 low
        volatile uint32_t GFXMMU_LUT741H;  ///< Offset: 0x272C - GFXMMU LUT entry 741 high
        volatile uint32_t GFXMMU_LUT742L;  ///< Offset: 0x2730 - GFXMMU LUT entry 742 low
        volatile uint32_t GFXMMU_LUT742H;  ///< Offset: 0x2734 - GFXMMU LUT entry 742 high
        volatile uint32_t GFXMMU_LUT743L;  ///< Offset: 0x2738 - GFXMMU LUT entry 743 low
        volatile uint32_t GFXMMU_LUT743H;  ///< Offset: 0x273C - GFXMMU LUT entry 743 high
        volatile uint32_t GFXMMU_LUT744L;  ///< Offset: 0x2740 - GFXMMU LUT entry 744 low
        volatile uint32_t GFXMMU_LUT744H;  ///< Offset: 0x2744 - GFXMMU LUT entry 744 high
        volatile uint32_t GFXMMU_LUT745L;  ///< Offset: 0x2748 - GFXMMU LUT entry 745 low
        volatile uint32_t GFXMMU_LUT745H;  ///< Offset: 0x274C - GFXMMU LUT entry 745 high
        volatile uint32_t GFXMMU_LUT746L;  ///< Offset: 0x2750 - GFXMMU LUT entry 746 low
        volatile uint32_t GFXMMU_LUT746H;  ///< Offset: 0x2754 - GFXMMU LUT entry 746 high
        volatile uint32_t GFXMMU_LUT747L;  ///< Offset: 0x2758 - GFXMMU LUT entry 747 low
        volatile uint32_t GFXMMU_LUT747H;  ///< Offset: 0x275C - GFXMMU LUT entry 747 high
        volatile uint32_t GFXMMU_LUT748L;  ///< Offset: 0x2760 - GFXMMU LUT entry 748 low
        volatile uint32_t GFXMMU_LUT748H;  ///< Offset: 0x2764 - GFXMMU LUT entry 748 high
        volatile uint32_t GFXMMU_LUT749L;  ///< Offset: 0x2768 - GFXMMU LUT entry 749 low
        volatile uint32_t GFXMMU_LUT749H;  ///< Offset: 0x276C - GFXMMU LUT entry 749 high
        volatile uint32_t GFXMMU_LUT750L;  ///< Offset: 0x2770 - GFXMMU LUT entry 750 low
        volatile uint32_t GFXMMU_LUT750H;  ///< Offset: 0x2774 - GFXMMU LUT entry 750 high
        volatile uint32_t GFXMMU_LUT751L;  ///< Offset: 0x2778 - GFXMMU LUT entry 751 low
        volatile uint32_t GFXMMU_LUT751H;  ///< Offset: 0x277C - GFXMMU LUT entry 751 high
        volatile uint32_t GFXMMU_LUT752L;  ///< Offset: 0x2780 - GFXMMU LUT entry 752 low
        volatile uint32_t GFXMMU_LUT752H;  ///< Offset: 0x2784 - GFXMMU LUT entry 752 high
        volatile uint32_t GFXMMU_LUT753L;  ///< Offset: 0x2788 - GFXMMU LUT entry 753 low
        volatile uint32_t GFXMMU_LUT753H;  ///< Offset: 0x278C - GFXMMU LUT entry 753 high
        volatile uint32_t GFXMMU_LUT754L;  ///< Offset: 0x2790 - GFXMMU LUT entry 754 low
        volatile uint32_t GFXMMU_LUT754H;  ///< Offset: 0x2794 - GFXMMU LUT entry 754 high
        volatile uint32_t GFXMMU_LUT755L;  ///< Offset: 0x2798 - GFXMMU LUT entry 755 low
        volatile uint32_t GFXMMU_LUT755H;  ///< Offset: 0x279C - GFXMMU LUT entry 755 high
        volatile uint32_t GFXMMU_LUT756L;  ///< Offset: 0x27A0 - GFXMMU LUT entry 756 low
        volatile uint32_t GFXMMU_LUT756H;  ///< Offset: 0x27A4 - GFXMMU LUT entry 756 high
        volatile uint32_t GFXMMU_LUT757L;  ///< Offset: 0x27A8 - GFXMMU LUT entry 757 low
        volatile uint32_t GFXMMU_LUT757H;  ///< Offset: 0x27AC - GFXMMU LUT entry 757 high
        volatile uint32_t GFXMMU_LUT758L;  ///< Offset: 0x27B0 - GFXMMU LUT entry 758 low
        volatile uint32_t GFXMMU_LUT758H;  ///< Offset: 0x27B4 - GFXMMU LUT entry 758 high
        volatile uint32_t GFXMMU_LUT759L;  ///< Offset: 0x27B8 - GFXMMU LUT entry 759 low
        volatile uint32_t GFXMMU_LUT759H;  ///< Offset: 0x27BC - GFXMMU LUT entry 759 high
        volatile uint32_t GFXMMU_LUT760L;  ///< Offset: 0x27C0 - GFXMMU LUT entry 760 low
        volatile uint32_t GFXMMU_LUT760H;  ///< Offset: 0x27C4 - GFXMMU LUT entry 760 high
        volatile uint32_t GFXMMU_LUT761L;  ///< Offset: 0x27C8 - GFXMMU LUT entry 761 low
        volatile uint32_t GFXMMU_LUT761H;  ///< Offset: 0x27CC - GFXMMU LUT entry 761 high
        volatile uint32_t GFXMMU_LUT762L;  ///< Offset: 0x27D0 - GFXMMU LUT entry 762 low
        volatile uint32_t GFXMMU_LUT762H;  ///< Offset: 0x27D4 - GFXMMU LUT entry 762 high
        volatile uint32_t GFXMMU_LUT763L;  ///< Offset: 0x27D8 - GFXMMU LUT entry 763 low
        volatile uint32_t GFXMMU_LUT763H;  ///< Offset: 0x27DC - GFXMMU LUT entry 763 high
        volatile uint32_t GFXMMU_LUT764L;  ///< Offset: 0x27E0 - GFXMMU LUT entry 764 low
        volatile uint32_t GFXMMU_LUT764H;  ///< Offset: 0x27E4 - GFXMMU LUT entry 764 high
        volatile uint32_t GFXMMU_LUT765L;  ///< Offset: 0x27E8 - GFXMMU LUT entry 765 low
        volatile uint32_t GFXMMU_LUT765H;  ///< Offset: 0x27EC - GFXMMU LUT entry 765 high
        volatile uint32_t GFXMMU_LUT766L;  ///< Offset: 0x27F0 - GFXMMU LUT entry 766 low
        volatile uint32_t GFXMMU_LUT766H;  ///< Offset: 0x27F4 - GFXMMU LUT entry 766 high
        volatile uint32_t GFXMMU_LUT767L;  ///< Offset: 0x27F8 - GFXMMU LUT entry 767 low
        volatile uint32_t GFXMMU_LUT767H;  ///< Offset: 0x27FC - GFXMMU LUT entry 767 high
        volatile uint32_t GFXMMU_LUT768L;  ///< Offset: 0x2800 - GFXMMU LUT entry 768 low
        volatile uint32_t GFXMMU_LUT768H;  ///< Offset: 0x2804 - GFXMMU LUT entry 768 high
        volatile uint32_t GFXMMU_LUT769L;  ///< Offset: 0x2808 - GFXMMU LUT entry 769 low
        volatile uint32_t GFXMMU_LUT769H;  ///< Offset: 0x280C - GFXMMU LUT entry 769 high
        volatile uint32_t GFXMMU_LUT770L;  ///< Offset: 0x2810 - GFXMMU LUT entry 770 low
        volatile uint32_t GFXMMU_LUT770H;  ///< Offset: 0x2814 - GFXMMU LUT entry 770 high
        volatile uint32_t GFXMMU_LUT771L;  ///< Offset: 0x2818 - GFXMMU LUT entry 771 low
        volatile uint32_t GFXMMU_LUT771H;  ///< Offset: 0x281C - GFXMMU LUT entry 771 high
        volatile uint32_t GFXMMU_LUT772L;  ///< Offset: 0x2820 - GFXMMU LUT entry 772 low
        volatile uint32_t GFXMMU_LUT772H;  ///< Offset: 0x2824 - GFXMMU LUT entry 772 high
        volatile uint32_t GFXMMU_LUT773L;  ///< Offset: 0x2828 - GFXMMU LUT entry 773 low
        volatile uint32_t GFXMMU_LUT773H;  ///< Offset: 0x282C - GFXMMU LUT entry 773 high
        volatile uint32_t GFXMMU_LUT774L;  ///< Offset: 0x2830 - GFXMMU LUT entry 774 low
        volatile uint32_t GFXMMU_LUT774H;  ///< Offset: 0x2834 - GFXMMU LUT entry 774 high
        volatile uint32_t GFXMMU_LUT775L;  ///< Offset: 0x2838 - GFXMMU LUT entry 775 low
        volatile uint32_t GFXMMU_LUT775H;  ///< Offset: 0x283C - GFXMMU LUT entry 775 high
        volatile uint32_t GFXMMU_LUT776L;  ///< Offset: 0x2840 - GFXMMU LUT entry 776 low
        volatile uint32_t GFXMMU_LUT776H;  ///< Offset: 0x2844 - GFXMMU LUT entry 776 high
        volatile uint32_t GFXMMU_LUT777L;  ///< Offset: 0x2848 - GFXMMU LUT entry 777 low
        volatile uint32_t GFXMMU_LUT777H;  ///< Offset: 0x284C - GFXMMU LUT entry 777 high
        volatile uint32_t GFXMMU_LUT778L;  ///< Offset: 0x2850 - GFXMMU LUT entry 778 low
        volatile uint32_t GFXMMU_LUT778H;  ///< Offset: 0x2854 - GFXMMU LUT entry 778 high
        volatile uint32_t GFXMMU_LUT779L;  ///< Offset: 0x2858 - GFXMMU LUT entry 779 low
        volatile uint32_t GFXMMU_LUT779H;  ///< Offset: 0x285C - GFXMMU LUT entry 779 high
        volatile uint32_t GFXMMU_LUT780L;  ///< Offset: 0x2860 - GFXMMU LUT entry 780 low
        volatile uint32_t GFXMMU_LUT780H;  ///< Offset: 0x2864 - GFXMMU LUT entry 780 high
        volatile uint32_t GFXMMU_LUT781L;  ///< Offset: 0x2868 - GFXMMU LUT entry 781 low
        volatile uint32_t GFXMMU_LUT781H;  ///< Offset: 0x286C - GFXMMU LUT entry 781 high
        volatile uint32_t GFXMMU_LUT782L;  ///< Offset: 0x2870 - GFXMMU LUT entry 782 low
        volatile uint32_t GFXMMU_LUT782H;  ///< Offset: 0x2874 - GFXMMU LUT entry 782 high
        volatile uint32_t GFXMMU_LUT783L;  ///< Offset: 0x2878 - GFXMMU LUT entry 783 low
        volatile uint32_t GFXMMU_LUT783H;  ///< Offset: 0x287C - GFXMMU LUT entry 783 high
        volatile uint32_t GFXMMU_LUT784L;  ///< Offset: 0x2880 - GFXMMU LUT entry 784 low
        volatile uint32_t GFXMMU_LUT784H;  ///< Offset: 0x2884 - GFXMMU LUT entry 784 high
        volatile uint32_t GFXMMU_LUT785L;  ///< Offset: 0x2888 - GFXMMU LUT entry 785 low
        volatile uint32_t GFXMMU_LUT785H;  ///< Offset: 0x288C - GFXMMU LUT entry 785 high
        volatile uint32_t GFXMMU_LUT786L;  ///< Offset: 0x2890 - GFXMMU LUT entry 786 low
        volatile uint32_t GFXMMU_LUT786H;  ///< Offset: 0x2894 - GFXMMU LUT entry 786 high
        volatile uint32_t GFXMMU_LUT787L;  ///< Offset: 0x2898 - GFXMMU LUT entry 787 low
        volatile uint32_t GFXMMU_LUT787H;  ///< Offset: 0x289C - GFXMMU LUT entry 787 high
        volatile uint32_t GFXMMU_LUT788L;  ///< Offset: 0x28A0 - GFXMMU LUT entry 788 low
        volatile uint32_t GFXMMU_LUT788H;  ///< Offset: 0x28A4 - GFXMMU LUT entry 788 high
        volatile uint32_t GFXMMU_LUT789L;  ///< Offset: 0x28A8 - GFXMMU LUT entry 789 low
        volatile uint32_t GFXMMU_LUT789H;  ///< Offset: 0x28AC - GFXMMU LUT entry 789 high
        volatile uint32_t GFXMMU_LUT790L;  ///< Offset: 0x28B0 - GFXMMU LUT entry 790 low
        volatile uint32_t GFXMMU_LUT790H;  ///< Offset: 0x28B4 - GFXMMU LUT entry 790 high
        volatile uint32_t GFXMMU_LUT791L;  ///< Offset: 0x28B8 - GFXMMU LUT entry 791 low
        volatile uint32_t GFXMMU_LUT791H;  ///< Offset: 0x28BC - GFXMMU LUT entry 791 high
        volatile uint32_t GFXMMU_LUT792L;  ///< Offset: 0x28C0 - GFXMMU LUT entry 792 low
        volatile uint32_t GFXMMU_LUT792H;  ///< Offset: 0x28C4 - GFXMMU LUT entry 792 high
        volatile uint32_t GFXMMU_LUT793L;  ///< Offset: 0x28C8 - GFXMMU LUT entry 793 low
        volatile uint32_t GFXMMU_LUT793H;  ///< Offset: 0x28CC - GFXMMU LUT entry 793 high
        volatile uint32_t GFXMMU_LUT794L;  ///< Offset: 0x28D0 - GFXMMU LUT entry 794 low
        volatile uint32_t GFXMMU_LUT794H;  ///< Offset: 0x28D4 - GFXMMU LUT entry 794 high
        volatile uint32_t GFXMMU_LUT795L;  ///< Offset: 0x28D8 - GFXMMU LUT entry 795 low
        volatile uint32_t GFXMMU_LUT795H;  ///< Offset: 0x28DC - GFXMMU LUT entry 795 high
        volatile uint32_t GFXMMU_LUT796L;  ///< Offset: 0x28E0 - GFXMMU LUT entry 796 low
        volatile uint32_t GFXMMU_LUT796H;  ///< Offset: 0x28E4 - GFXMMU LUT entry 796 high
        volatile uint32_t GFXMMU_LUT797L;  ///< Offset: 0x28E8 - GFXMMU LUT entry 797 low
        volatile uint32_t GFXMMU_LUT797H;  ///< Offset: 0x28EC - GFXMMU LUT entry 797 high
        volatile uint32_t GFXMMU_LUT798L;  ///< Offset: 0x28F0 - GFXMMU LUT entry 798 low
        volatile uint32_t GFXMMU_LUT798H;  ///< Offset: 0x28F4 - GFXMMU LUT entry 798 high
        volatile uint32_t GFXMMU_LUT799L;  ///< Offset: 0x28F8 - GFXMMU LUT entry 799 low
        volatile uint32_t GFXMMU_LUT799H;  ///< Offset: 0x28FC - GFXMMU LUT entry 799 high
        volatile uint32_t GFXMMU_LUT800L;  ///< Offset: 0x2900 - GFXMMU LUT entry 800 low
        volatile uint32_t GFXMMU_LUT800H;  ///< Offset: 0x2904 - GFXMMU LUT entry 800 high
        volatile uint32_t GFXMMU_LUT801L;  ///< Offset: 0x2908 - GFXMMU LUT entry 801 low
        volatile uint32_t GFXMMU_LUT801H;  ///< Offset: 0x290C - GFXMMU LUT entry 801 high
        volatile uint32_t GFXMMU_LUT802L;  ///< Offset: 0x2910 - GFXMMU LUT entry 802 low
        volatile uint32_t GFXMMU_LUT802H;  ///< Offset: 0x2914 - GFXMMU LUT entry 802 high
        volatile uint32_t GFXMMU_LUT803L;  ///< Offset: 0x2918 - GFXMMU LUT entry 803 low
        volatile uint32_t GFXMMU_LUT803H;  ///< Offset: 0x291C - GFXMMU LUT entry 803 high
        volatile uint32_t GFXMMU_LUT804L;  ///< Offset: 0x2920 - GFXMMU LUT entry 804 low
        volatile uint32_t GFXMMU_LUT804H;  ///< Offset: 0x2924 - GFXMMU LUT entry 804 high
        volatile uint32_t GFXMMU_LUT805L;  ///< Offset: 0x2928 - GFXMMU LUT entry 805 low
        volatile uint32_t GFXMMU_LUT805H;  ///< Offset: 0x292C - GFXMMU LUT entry 805 high
        volatile uint32_t GFXMMU_LUT806L;  ///< Offset: 0x2930 - GFXMMU LUT entry 806 low
        volatile uint32_t GFXMMU_LUT806H;  ///< Offset: 0x2934 - GFXMMU LUT entry 806 high
        volatile uint32_t GFXMMU_LUT807L;  ///< Offset: 0x2938 - GFXMMU LUT entry 807 low
        volatile uint32_t GFXMMU_LUT807H;  ///< Offset: 0x293C - GFXMMU LUT entry 807 high
        volatile uint32_t GFXMMU_LUT808L;  ///< Offset: 0x2940 - GFXMMU LUT entry 808 low
        volatile uint32_t GFXMMU_LUT808H;  ///< Offset: 0x2944 - GFXMMU LUT entry 808 high
        volatile uint32_t GFXMMU_LUT809L;  ///< Offset: 0x2948 - GFXMMU LUT entry 809 low
        volatile uint32_t GFXMMU_LUT809H;  ///< Offset: 0x294C - GFXMMU LUT entry 809 high
        volatile uint32_t GFXMMU_LUT810L;  ///< Offset: 0x2950 - GFXMMU LUT entry 810 low
        volatile uint32_t GFXMMU_LUT810H;  ///< Offset: 0x2954 - GFXMMU LUT entry 810 high
        volatile uint32_t GFXMMU_LUT811L;  ///< Offset: 0x2958 - GFXMMU LUT entry 811 low
        volatile uint32_t GFXMMU_LUT811H;  ///< Offset: 0x295C - GFXMMU LUT entry 811 high
        volatile uint32_t GFXMMU_LUT812L;  ///< Offset: 0x2960 - GFXMMU LUT entry 812 low
        volatile uint32_t GFXMMU_LUT812H;  ///< Offset: 0x2964 - GFXMMU LUT entry 812 high
        volatile uint32_t GFXMMU_LUT813L;  ///< Offset: 0x2968 - GFXMMU LUT entry 813 low
        volatile uint32_t GFXMMU_LUT813H;  ///< Offset: 0x296C - GFXMMU LUT entry 813 high
        volatile uint32_t GFXMMU_LUT814L;  ///< Offset: 0x2970 - GFXMMU LUT entry 814 low
        volatile uint32_t GFXMMU_LUT814H;  ///< Offset: 0x2974 - GFXMMU LUT entry 814 high
        volatile uint32_t GFXMMU_LUT815L;  ///< Offset: 0x2978 - GFXMMU LUT entry 815 low
        volatile uint32_t GFXMMU_LUT815H;  ///< Offset: 0x297C - GFXMMU LUT entry 815 high
        volatile uint32_t GFXMMU_LUT816L;  ///< Offset: 0x2980 - GFXMMU LUT entry 816 low
        volatile uint32_t GFXMMU_LUT816H;  ///< Offset: 0x2984 - GFXMMU LUT entry 816 high
        volatile uint32_t GFXMMU_LUT817L;  ///< Offset: 0x2988 - GFXMMU LUT entry 817 low
        volatile uint32_t GFXMMU_LUT817H;  ///< Offset: 0x298C - GFXMMU LUT entry 817 high
        volatile uint32_t GFXMMU_LUT818L;  ///< Offset: 0x2990 - GFXMMU LUT entry 818 low
        volatile uint32_t GFXMMU_LUT818H;  ///< Offset: 0x2994 - GFXMMU LUT entry 818 high
        volatile uint32_t GFXMMU_LUT819L;  ///< Offset: 0x2998 - GFXMMU LUT entry 819 low
        volatile uint32_t GFXMMU_LUT819H;  ///< Offset: 0x299C - GFXMMU LUT entry 819 high
        volatile uint32_t GFXMMU_LUT820L;  ///< Offset: 0x29A0 - GFXMMU LUT entry 820 low
        volatile uint32_t GFXMMU_LUT820H;  ///< Offset: 0x29A4 - GFXMMU LUT entry 820 high
        volatile uint32_t GFXMMU_LUT821L;  ///< Offset: 0x29A8 - GFXMMU LUT entry 821 low
        volatile uint32_t GFXMMU_LUT821H;  ///< Offset: 0x29AC - GFXMMU LUT entry 821 high
        volatile uint32_t GFXMMU_LUT822L;  ///< Offset: 0x29B0 - GFXMMU LUT entry 822 low
        volatile uint32_t GFXMMU_LUT822H;  ///< Offset: 0x29B4 - GFXMMU LUT entry 822 high
        volatile uint32_t GFXMMU_LUT823L;  ///< Offset: 0x29B8 - GFXMMU LUT entry 823 low
        volatile uint32_t GFXMMU_LUT823H;  ///< Offset: 0x29BC - GFXMMU LUT entry 823 high
        volatile uint32_t GFXMMU_LUT824L;  ///< Offset: 0x29C0 - GFXMMU LUT entry 824 low
        volatile uint32_t GFXMMU_LUT824H;  ///< Offset: 0x29C4 - GFXMMU LUT entry 824 high
        volatile uint32_t GFXMMU_LUT825L;  ///< Offset: 0x29C8 - GFXMMU LUT entry 825 low
        volatile uint32_t GFXMMU_LUT825H;  ///< Offset: 0x29CC - GFXMMU LUT entry 825 high
        volatile uint32_t GFXMMU_LUT826L;  ///< Offset: 0x29D0 - GFXMMU LUT entry 826 low
        volatile uint32_t GFXMMU_LUT826H;  ///< Offset: 0x29D4 - GFXMMU LUT entry 826 high
        volatile uint32_t GFXMMU_LUT827L;  ///< Offset: 0x29D8 - GFXMMU LUT entry 827 low
        volatile uint32_t GFXMMU_LUT827H;  ///< Offset: 0x29DC - GFXMMU LUT entry 827 high
        volatile uint32_t GFXMMU_LUT828L;  ///< Offset: 0x29E0 - GFXMMU LUT entry 828 low
        volatile uint32_t GFXMMU_LUT828H;  ///< Offset: 0x29E4 - GFXMMU LUT entry 828 high
        volatile uint32_t GFXMMU_LUT829L;  ///< Offset: 0x29E8 - GFXMMU LUT entry 829 low
        volatile uint32_t GFXMMU_LUT829H;  ///< Offset: 0x29EC - GFXMMU LUT entry 829 high
        volatile uint32_t GFXMMU_LUT830L;  ///< Offset: 0x29F0 - GFXMMU LUT entry 830 low
        volatile uint32_t GFXMMU_LUT830H;  ///< Offset: 0x29F4 - GFXMMU LUT entry 830 high
        volatile uint32_t GFXMMU_LUT831L;  ///< Offset: 0x29F8 - GFXMMU LUT entry 831 low
        volatile uint32_t GFXMMU_LUT831H;  ///< Offset: 0x29FC - GFXMMU LUT entry 831 high
        volatile uint32_t GFXMMU_LUT832L;  ///< Offset: 0x2A00 - GFXMMU LUT entry 832 low
        volatile uint32_t GFXMMU_LUT832H;  ///< Offset: 0x2A04 - GFXMMU LUT entry 832 high
        volatile uint32_t GFXMMU_LUT833L;  ///< Offset: 0x2A08 - GFXMMU LUT entry 833 low
        volatile uint32_t GFXMMU_LUT833H;  ///< Offset: 0x2A0C - GFXMMU LUT entry 833 high
        volatile uint32_t GFXMMU_LUT834L;  ///< Offset: 0x2A10 - GFXMMU LUT entry 834 low
        volatile uint32_t GFXMMU_LUT834H;  ///< Offset: 0x2A14 - GFXMMU LUT entry 834 high
        volatile uint32_t GFXMMU_LUT835L;  ///< Offset: 0x2A18 - GFXMMU LUT entry 835 low
        volatile uint32_t GFXMMU_LUT835H;  ///< Offset: 0x2A1C - GFXMMU LUT entry 835 high
        volatile uint32_t GFXMMU_LUT836L;  ///< Offset: 0x2A20 - GFXMMU LUT entry 836 low
        volatile uint32_t GFXMMU_LUT836H;  ///< Offset: 0x2A24 - GFXMMU LUT entry 836 high
        volatile uint32_t GFXMMU_LUT837L;  ///< Offset: 0x2A28 - GFXMMU LUT entry 837 low
        volatile uint32_t GFXMMU_LUT837H;  ///< Offset: 0x2A2C - GFXMMU LUT entry 837 high
        volatile uint32_t GFXMMU_LUT838L;  ///< Offset: 0x2A30 - GFXMMU LUT entry 838 low
        volatile uint32_t GFXMMU_LUT838H;  ///< Offset: 0x2A34 - GFXMMU LUT entry 838 high
        volatile uint32_t GFXMMU_LUT839L;  ///< Offset: 0x2A38 - GFXMMU LUT entry 839 low
        volatile uint32_t GFXMMU_LUT839H;  ///< Offset: 0x2A3C - GFXMMU LUT entry 839 high
        volatile uint32_t GFXMMU_LUT840L;  ///< Offset: 0x2A40 - GFXMMU LUT entry 840 low
        volatile uint32_t GFXMMU_LUT840H;  ///< Offset: 0x2A44 - GFXMMU LUT entry 840 high
        volatile uint32_t GFXMMU_LUT841L;  ///< Offset: 0x2A48 - GFXMMU LUT entry 841 low
        volatile uint32_t GFXMMU_LUT841H;  ///< Offset: 0x2A4C - GFXMMU LUT entry 841 high
        volatile uint32_t GFXMMU_LUT842L;  ///< Offset: 0x2A50 - GFXMMU LUT entry 842 low
        volatile uint32_t GFXMMU_LUT842H;  ///< Offset: 0x2A54 - GFXMMU LUT entry 842 high
        volatile uint32_t GFXMMU_LUT843L;  ///< Offset: 0x2A58 - GFXMMU LUT entry 843 low
        volatile uint32_t GFXMMU_LUT843H;  ///< Offset: 0x2A5C - GFXMMU LUT entry 843 high
        volatile uint32_t GFXMMU_LUT844L;  ///< Offset: 0x2A60 - GFXMMU LUT entry 844 low
        volatile uint32_t GFXMMU_LUT844H;  ///< Offset: 0x2A64 - GFXMMU LUT entry 844 high
        volatile uint32_t GFXMMU_LUT845L;  ///< Offset: 0x2A68 - GFXMMU LUT entry 845 low
        volatile uint32_t GFXMMU_LUT845H;  ///< Offset: 0x2A6C - GFXMMU LUT entry 845 high
        volatile uint32_t GFXMMU_LUT846L;  ///< Offset: 0x2A70 - GFXMMU LUT entry 846 low
        volatile uint32_t GFXMMU_LUT846H;  ///< Offset: 0x2A74 - GFXMMU LUT entry 846 high
        volatile uint32_t GFXMMU_LUT847L;  ///< Offset: 0x2A78 - GFXMMU LUT entry 847 low
        volatile uint32_t GFXMMU_LUT847H;  ///< Offset: 0x2A7C - GFXMMU LUT entry 847 high
        volatile uint32_t GFXMMU_LUT848L;  ///< Offset: 0x2A80 - GFXMMU LUT entry 848 low
        volatile uint32_t GFXMMU_LUT848H;  ///< Offset: 0x2A84 - GFXMMU LUT entry 848 high
        volatile uint32_t GFXMMU_LUT849L;  ///< Offset: 0x2A88 - GFXMMU LUT entry 849 low
        volatile uint32_t GFXMMU_LUT849H;  ///< Offset: 0x2A8C - GFXMMU LUT entry 849 high
        volatile uint32_t GFXMMU_LUT850L;  ///< Offset: 0x2A90 - GFXMMU LUT entry 850 low
        volatile uint32_t GFXMMU_LUT850H;  ///< Offset: 0x2A94 - GFXMMU LUT entry 850 high
        volatile uint32_t GFXMMU_LUT851L;  ///< Offset: 0x2A98 - GFXMMU LUT entry 851 low
        volatile uint32_t GFXMMU_LUT851H;  ///< Offset: 0x2A9C - GFXMMU LUT entry 851 high
        volatile uint32_t GFXMMU_LUT852L;  ///< Offset: 0x2AA0 - GFXMMU LUT entry 852 low
        volatile uint32_t GFXMMU_LUT852H;  ///< Offset: 0x2AA4 - GFXMMU LUT entry 852 high
        volatile uint32_t GFXMMU_LUT853L;  ///< Offset: 0x2AA8 - GFXMMU LUT entry 853 low
        volatile uint32_t GFXMMU_LUT853H;  ///< Offset: 0x2AAC - GFXMMU LUT entry 853 high
        volatile uint32_t GFXMMU_LUT854L;  ///< Offset: 0x2AB0 - GFXMMU LUT entry 854 low
        volatile uint32_t GFXMMU_LUT854H;  ///< Offset: 0x2AB4 - GFXMMU LUT entry 854 high
        volatile uint32_t GFXMMU_LUT855L;  ///< Offset: 0x2AB8 - GFXMMU LUT entry 855 low
        volatile uint32_t GFXMMU_LUT855H;  ///< Offset: 0x2ABC - GFXMMU LUT entry 855 high
        volatile uint32_t GFXMMU_LUT856L;  ///< Offset: 0x2AC0 - GFXMMU LUT entry 856 low
        volatile uint32_t GFXMMU_LUT856H;  ///< Offset: 0x2AC4 - GFXMMU LUT entry 856 high
        volatile uint32_t GFXMMU_LUT857L;  ///< Offset: 0x2AC8 - GFXMMU LUT entry 857 low
        volatile uint32_t GFXMMU_LUT857H;  ///< Offset: 0x2ACC - GFXMMU LUT entry 857 high
        volatile uint32_t GFXMMU_LUT858L;  ///< Offset: 0x2AD0 - GFXMMU LUT entry 858 low
        volatile uint32_t GFXMMU_LUT858H;  ///< Offset: 0x2AD4 - GFXMMU LUT entry 858 high
        volatile uint32_t GFXMMU_LUT859L;  ///< Offset: 0x2AD8 - GFXMMU LUT entry 859 low
        volatile uint32_t GFXMMU_LUT859H;  ///< Offset: 0x2ADC - GFXMMU LUT entry 859 high
        volatile uint32_t GFXMMU_LUT860L;  ///< Offset: 0x2AE0 - GFXMMU LUT entry 860 low
        volatile uint32_t GFXMMU_LUT860H;  ///< Offset: 0x2AE4 - GFXMMU LUT entry 860 high
        volatile uint32_t GFXMMU_LUT861L;  ///< Offset: 0x2AE8 - GFXMMU LUT entry 861 low
        volatile uint32_t GFXMMU_LUT861H;  ///< Offset: 0x2AEC - GFXMMU LUT entry 861 high
        volatile uint32_t GFXMMU_LUT862L;  ///< Offset: 0x2AF0 - GFXMMU LUT entry 862 low
        volatile uint32_t GFXMMU_LUT862H;  ///< Offset: 0x2AF4 - GFXMMU LUT entry 862 high
        volatile uint32_t GFXMMU_LUT863L;  ///< Offset: 0x2AF8 - GFXMMU LUT entry 863 low
        volatile uint32_t GFXMMU_LUT863H;  ///< Offset: 0x2AFC - GFXMMU LUT entry 863 high
        volatile uint32_t GFXMMU_LUT864L;  ///< Offset: 0x2B00 - GFXMMU LUT entry 864 low
        volatile uint32_t GFXMMU_LUT864H;  ///< Offset: 0x2B04 - GFXMMU LUT entry 864 high
        volatile uint32_t GFXMMU_LUT865L;  ///< Offset: 0x2B08 - GFXMMU LUT entry 865 low
        volatile uint32_t GFXMMU_LUT865H;  ///< Offset: 0x2B0C - GFXMMU LUT entry 865 high
        volatile uint32_t GFXMMU_LUT866L;  ///< Offset: 0x2B10 - GFXMMU LUT entry 866 low
        volatile uint32_t GFXMMU_LUT866H;  ///< Offset: 0x2B14 - GFXMMU LUT entry 866 high
        volatile uint32_t GFXMMU_LUT867L;  ///< Offset: 0x2B18 - GFXMMU LUT entry 867 low
        volatile uint32_t GFXMMU_LUT867H;  ///< Offset: 0x2B1C - GFXMMU LUT entry 867 high
        volatile uint32_t GFXMMU_LUT868L;  ///< Offset: 0x2B20 - GFXMMU LUT entry 868 low
        volatile uint32_t GFXMMU_LUT868H;  ///< Offset: 0x2B24 - GFXMMU LUT entry 868 high
        volatile uint32_t GFXMMU_LUT869L;  ///< Offset: 0x2B28 - GFXMMU LUT entry 869 low
        volatile uint32_t GFXMMU_LUT869H;  ///< Offset: 0x2B2C - GFXMMU LUT entry 869 high
        volatile uint32_t GFXMMU_LUT870L;  ///< Offset: 0x2B30 - GFXMMU LUT entry 870 low
        volatile uint32_t GFXMMU_LUT870H;  ///< Offset: 0x2B34 - GFXMMU LUT entry 870 high
        volatile uint32_t GFXMMU_LUT871L;  ///< Offset: 0x2B38 - GFXMMU LUT entry 871 low
        volatile uint32_t GFXMMU_LUT871H;  ///< Offset: 0x2B3C - GFXMMU LUT entry 871 high
        volatile uint32_t GFXMMU_LUT872L;  ///< Offset: 0x2B40 - GFXMMU LUT entry 872 low
        volatile uint32_t GFXMMU_LUT872H;  ///< Offset: 0x2B44 - GFXMMU LUT entry 872 high
        volatile uint32_t GFXMMU_LUT873L;  ///< Offset: 0x2B48 - GFXMMU LUT entry 873 low
        volatile uint32_t GFXMMU_LUT873H;  ///< Offset: 0x2B4C - GFXMMU LUT entry 873 high
        volatile uint32_t GFXMMU_LUT874L;  ///< Offset: 0x2B50 - GFXMMU LUT entry 874 low
        volatile uint32_t GFXMMU_LUT874H;  ///< Offset: 0x2B54 - GFXMMU LUT entry 874 high
        volatile uint32_t GFXMMU_LUT875L;  ///< Offset: 0x2B58 - GFXMMU LUT entry 875 low
        volatile uint32_t GFXMMU_LUT875H;  ///< Offset: 0x2B5C - GFXMMU LUT entry 875 high
        volatile uint32_t GFXMMU_LUT876L;  ///< Offset: 0x2B60 - GFXMMU LUT entry 876 low
        volatile uint32_t GFXMMU_LUT876H;  ///< Offset: 0x2B64 - GFXMMU LUT entry 876 high
        volatile uint32_t GFXMMU_LUT877L;  ///< Offset: 0x2B68 - GFXMMU LUT entry 877 low
        volatile uint32_t GFXMMU_LUT877H;  ///< Offset: 0x2B6C - GFXMMU LUT entry 877 high
        volatile uint32_t GFXMMU_LUT878L;  ///< Offset: 0x2B70 - GFXMMU LUT entry 878 low
        volatile uint32_t GFXMMU_LUT878H;  ///< Offset: 0x2B74 - GFXMMU LUT entry 878 high
        volatile uint32_t GFXMMU_LUT879L;  ///< Offset: 0x2B78 - GFXMMU LUT entry 879 low
        volatile uint32_t GFXMMU_LUT879H;  ///< Offset: 0x2B7C - GFXMMU LUT entry 879 high
        volatile uint32_t GFXMMU_LUT880L;  ///< Offset: 0x2B80 - GFXMMU LUT entry 880 low
        volatile uint32_t GFXMMU_LUT880H;  ///< Offset: 0x2B84 - GFXMMU LUT entry 880 high
        volatile uint32_t GFXMMU_LUT881L;  ///< Offset: 0x2B88 - GFXMMU LUT entry 881 low
        volatile uint32_t GFXMMU_LUT881H;  ///< Offset: 0x2B8C - GFXMMU LUT entry 881 high
        volatile uint32_t GFXMMU_LUT882L;  ///< Offset: 0x2B90 - GFXMMU LUT entry 882 low
        volatile uint32_t GFXMMU_LUT882H;  ///< Offset: 0x2B94 - GFXMMU LUT entry 882 high
        volatile uint32_t GFXMMU_LUT883L;  ///< Offset: 0x2B98 - GFXMMU LUT entry 883 low
        volatile uint32_t GFXMMU_LUT883H;  ///< Offset: 0x2B9C - GFXMMU LUT entry 883 high
        volatile uint32_t GFXMMU_LUT884L;  ///< Offset: 0x2BA0 - GFXMMU LUT entry 884 low
        volatile uint32_t GFXMMU_LUT884H;  ///< Offset: 0x2BA4 - GFXMMU LUT entry 884 high
        volatile uint32_t GFXMMU_LUT885L;  ///< Offset: 0x2BA8 - GFXMMU LUT entry 885 low
        volatile uint32_t GFXMMU_LUT885H;  ///< Offset: 0x2BAC - GFXMMU LUT entry 885 high
        volatile uint32_t GFXMMU_LUT886L;  ///< Offset: 0x2BB0 - GFXMMU LUT entry 886 low
        volatile uint32_t GFXMMU_LUT886H;  ///< Offset: 0x2BB4 - GFXMMU LUT entry 886 high
        volatile uint32_t GFXMMU_LUT887L;  ///< Offset: 0x2BB8 - GFXMMU LUT entry 887 low
        volatile uint32_t GFXMMU_LUT887H;  ///< Offset: 0x2BBC - GFXMMU LUT entry 887 high
        volatile uint32_t GFXMMU_LUT888L;  ///< Offset: 0x2BC0 - GFXMMU LUT entry 888 low
        volatile uint32_t GFXMMU_LUT888H;  ///< Offset: 0x2BC4 - GFXMMU LUT entry 888 high
        volatile uint32_t GFXMMU_LUT889L;  ///< Offset: 0x2BC8 - GFXMMU LUT entry 889 low
        volatile uint32_t GFXMMU_LUT889H;  ///< Offset: 0x2BCC - GFXMMU LUT entry 889 high
        volatile uint32_t GFXMMU_LUT890L;  ///< Offset: 0x2BD0 - GFXMMU LUT entry 890 low
        volatile uint32_t GFXMMU_LUT890H;  ///< Offset: 0x2BD4 - GFXMMU LUT entry 890 high
        volatile uint32_t GFXMMU_LUT891L;  ///< Offset: 0x2BD8 - GFXMMU LUT entry 891 low
        volatile uint32_t GFXMMU_LUT891H;  ///< Offset: 0x2BDC - GFXMMU LUT entry 891 high
        volatile uint32_t GFXMMU_LUT892L;  ///< Offset: 0x2BE0 - GFXMMU LUT entry 892 low
        volatile uint32_t GFXMMU_LUT892H;  ///< Offset: 0x2BE4 - GFXMMU LUT entry 892 high
        volatile uint32_t GFXMMU_LUT893L;  ///< Offset: 0x2BE8 - GFXMMU LUT entry 893 low
        volatile uint32_t GFXMMU_LUT893H;  ///< Offset: 0x2BEC - GFXMMU LUT entry 893 high
        volatile uint32_t GFXMMU_LUT894L;  ///< Offset: 0x2BF0 - GFXMMU LUT entry 894 low
        volatile uint32_t GFXMMU_LUT894H;  ///< Offset: 0x2BF4 - GFXMMU LUT entry 894 high
        volatile uint32_t GFXMMU_LUT895L;  ///< Offset: 0x2BF8 - GFXMMU LUT entry 895 low
        volatile uint32_t GFXMMU_LUT895H;  ///< Offset: 0x2BFC - GFXMMU LUT entry 895 high
        volatile uint32_t GFXMMU_LUT896L;  ///< Offset: 0x2C00 - GFXMMU LUT entry 896 low
        volatile uint32_t GFXMMU_LUT896H;  ///< Offset: 0x2C04 - GFXMMU LUT entry 896 high
        volatile uint32_t GFXMMU_LUT897L;  ///< Offset: 0x2C08 - GFXMMU LUT entry 897 low
        volatile uint32_t GFXMMU_LUT897H;  ///< Offset: 0x2C0C - GFXMMU LUT entry 897 high
        volatile uint32_t GFXMMU_LUT898L;  ///< Offset: 0x2C10 - GFXMMU LUT entry 898 low
        volatile uint32_t GFXMMU_LUT898H;  ///< Offset: 0x2C14 - GFXMMU LUT entry 898 high
        volatile uint32_t GFXMMU_LUT899L;  ///< Offset: 0x2C18 - GFXMMU LUT entry 899 low
        volatile uint32_t GFXMMU_LUT899H;  ///< Offset: 0x2C1C - GFXMMU LUT entry 899 high
        volatile uint32_t GFXMMU_LUT900L;  ///< Offset: 0x2C20 - GFXMMU LUT entry 900 low
        volatile uint32_t GFXMMU_LUT900H;  ///< Offset: 0x2C24 - GFXMMU LUT entry 900 high
        volatile uint32_t GFXMMU_LUT901L;  ///< Offset: 0x2C28 - GFXMMU LUT entry 901 low
        volatile uint32_t GFXMMU_LUT901H;  ///< Offset: 0x2C2C - GFXMMU LUT entry 901 high
        volatile uint32_t GFXMMU_LUT902L;  ///< Offset: 0x2C30 - GFXMMU LUT entry 902 low
        volatile uint32_t GFXMMU_LUT902H;  ///< Offset: 0x2C34 - GFXMMU LUT entry 902 high
        volatile uint32_t GFXMMU_LUT903L;  ///< Offset: 0x2C38 - GFXMMU LUT entry 903 low
        volatile uint32_t GFXMMU_LUT903H;  ///< Offset: 0x2C3C - GFXMMU LUT entry 903 high
        volatile uint32_t GFXMMU_LUT904L;  ///< Offset: 0x2C40 - GFXMMU LUT entry 904 low
        volatile uint32_t GFXMMU_LUT904H;  ///< Offset: 0x2C44 - GFXMMU LUT entry 904 high
        volatile uint32_t GFXMMU_LUT905L;  ///< Offset: 0x2C48 - GFXMMU LUT entry 905 low
        volatile uint32_t GFXMMU_LUT905H;  ///< Offset: 0x2C4C - GFXMMU LUT entry 905 high
        volatile uint32_t GFXMMU_LUT906L;  ///< Offset: 0x2C50 - GFXMMU LUT entry 906 low
        volatile uint32_t GFXMMU_LUT906H;  ///< Offset: 0x2C54 - GFXMMU LUT entry 906 high
        volatile uint32_t GFXMMU_LUT907L;  ///< Offset: 0x2C58 - GFXMMU LUT entry 907 low
        volatile uint32_t GFXMMU_LUT907H;  ///< Offset: 0x2C5C - GFXMMU LUT entry 907 high
        volatile uint32_t GFXMMU_LUT908L;  ///< Offset: 0x2C60 - GFXMMU LUT entry 908 low
        volatile uint32_t GFXMMU_LUT908H;  ///< Offset: 0x2C64 - GFXMMU LUT entry 908 high
        volatile uint32_t GFXMMU_LUT909L;  ///< Offset: 0x2C68 - GFXMMU LUT entry 909 low
        volatile uint32_t GFXMMU_LUT909H;  ///< Offset: 0x2C6C - GFXMMU LUT entry 909 high
        volatile uint32_t GFXMMU_LUT910L;  ///< Offset: 0x2C70 - GFXMMU LUT entry 910 low
        volatile uint32_t GFXMMU_LUT910H;  ///< Offset: 0x2C74 - GFXMMU LUT entry 910 high
        volatile uint32_t GFXMMU_LUT911L;  ///< Offset: 0x2C78 - GFXMMU LUT entry 911 low
        volatile uint32_t GFXMMU_LUT911H;  ///< Offset: 0x2C7C - GFXMMU LUT entry 911 high
        volatile uint32_t GFXMMU_LUT912L;  ///< Offset: 0x2C80 - GFXMMU LUT entry 912 low
        volatile uint32_t GFXMMU_LUT912H;  ///< Offset: 0x2C84 - GFXMMU LUT entry 912 high
        volatile uint32_t GFXMMU_LUT913L;  ///< Offset: 0x2C88 - GFXMMU LUT entry 913 low
        volatile uint32_t GFXMMU_LUT913H;  ///< Offset: 0x2C8C - GFXMMU LUT entry 913 high
        volatile uint32_t GFXMMU_LUT914L;  ///< Offset: 0x2C90 - GFXMMU LUT entry 914 low
        volatile uint32_t GFXMMU_LUT914H;  ///< Offset: 0x2C94 - GFXMMU LUT entry 914 high
        volatile uint32_t GFXMMU_LUT915L;  ///< Offset: 0x2C98 - GFXMMU LUT entry 915 low
        volatile uint32_t GFXMMU_LUT915H;  ///< Offset: 0x2C9C - GFXMMU LUT entry 915 high
        volatile uint32_t GFXMMU_LUT916L;  ///< Offset: 0x2CA0 - GFXMMU LUT entry 916 low
        volatile uint32_t GFXMMU_LUT916H;  ///< Offset: 0x2CA4 - GFXMMU LUT entry 916 high
        volatile uint32_t GFXMMU_LUT917L;  ///< Offset: 0x2CA8 - GFXMMU LUT entry 917 low
        volatile uint32_t GFXMMU_LUT917H;  ///< Offset: 0x2CAC - GFXMMU LUT entry 917 high
        volatile uint32_t GFXMMU_LUT918L;  ///< Offset: 0x2CB0 - GFXMMU LUT entry 918 low
        volatile uint32_t GFXMMU_LUT918H;  ///< Offset: 0x2CB4 - GFXMMU LUT entry 918 high
        volatile uint32_t GFXMMU_LUT919L;  ///< Offset: 0x2CB8 - GFXMMU LUT entry 919 low
        volatile uint32_t GFXMMU_LUT919H;  ///< Offset: 0x2CBC - GFXMMU LUT entry 919 high
        volatile uint32_t GFXMMU_LUT920L;  ///< Offset: 0x2CC0 - GFXMMU LUT entry 920 low
        volatile uint32_t GFXMMU_LUT920H;  ///< Offset: 0x2CC4 - GFXMMU LUT entry 920 high
        volatile uint32_t GFXMMU_LUT921L;  ///< Offset: 0x2CC8 - GFXMMU LUT entry 921 low
        volatile uint32_t GFXMMU_LUT921H;  ///< Offset: 0x2CCC - GFXMMU LUT entry 921 high
        volatile uint32_t GFXMMU_LUT922L;  ///< Offset: 0x2CD0 - GFXMMU LUT entry 922 low
        volatile uint32_t GFXMMU_LUT922H;  ///< Offset: 0x2CD4 - GFXMMU LUT entry 922 high
        volatile uint32_t GFXMMU_LUT923L;  ///< Offset: 0x2CD8 - GFXMMU LUT entry 923 low
        volatile uint32_t GFXMMU_LUT923H;  ///< Offset: 0x2CDC - GFXMMU LUT entry 923 high
        volatile uint32_t GFXMMU_LUT924L;  ///< Offset: 0x2CE0 - GFXMMU LUT entry 924 low
        volatile uint32_t GFXMMU_LUT924H;  ///< Offset: 0x2CE4 - GFXMMU LUT entry 924 high
        volatile uint32_t GFXMMU_LUT925L;  ///< Offset: 0x2CE8 - GFXMMU LUT entry 925 low
        volatile uint32_t GFXMMU_LUT925H;  ///< Offset: 0x2CEC - GFXMMU LUT entry 925 high
        volatile uint32_t GFXMMU_LUT926L;  ///< Offset: 0x2CF0 - GFXMMU LUT entry 926 low
        volatile uint32_t GFXMMU_LUT926H;  ///< Offset: 0x2CF4 - GFXMMU LUT entry 926 high
        volatile uint32_t GFXMMU_LUT927L;  ///< Offset: 0x2CF8 - GFXMMU LUT entry 927 low
        volatile uint32_t GFXMMU_LUT927H;  ///< Offset: 0x2CFC - GFXMMU LUT entry 927 high
        volatile uint32_t GFXMMU_LUT928L;  ///< Offset: 0x2D00 - GFXMMU LUT entry 928 low
        volatile uint32_t GFXMMU_LUT928H;  ///< Offset: 0x2D04 - GFXMMU LUT entry 928 high
        volatile uint32_t GFXMMU_LUT929L;  ///< Offset: 0x2D08 - GFXMMU LUT entry 929 low
        volatile uint32_t GFXMMU_LUT929H;  ///< Offset: 0x2D0C - GFXMMU LUT entry 929 high
        volatile uint32_t GFXMMU_LUT930L;  ///< Offset: 0x2D10 - GFXMMU LUT entry 930 low
        volatile uint32_t GFXMMU_LUT930H;  ///< Offset: 0x2D14 - GFXMMU LUT entry 930 high
        volatile uint32_t GFXMMU_LUT931L;  ///< Offset: 0x2D18 - GFXMMU LUT entry 931 low
        volatile uint32_t GFXMMU_LUT931H;  ///< Offset: 0x2D1C - GFXMMU LUT entry 931 high
        volatile uint32_t GFXMMU_LUT932L;  ///< Offset: 0x2D20 - GFXMMU LUT entry 932 low
        volatile uint32_t GFXMMU_LUT932H;  ///< Offset: 0x2D24 - GFXMMU LUT entry 932 high
        volatile uint32_t GFXMMU_LUT933L;  ///< Offset: 0x2D28 - GFXMMU LUT entry 933 low
        volatile uint32_t GFXMMU_LUT933H;  ///< Offset: 0x2D2C - GFXMMU LUT entry 933 high
        volatile uint32_t GFXMMU_LUT934L;  ///< Offset: 0x2D30 - GFXMMU LUT entry 934 low
        volatile uint32_t GFXMMU_LUT934H;  ///< Offset: 0x2D34 - GFXMMU LUT entry 934 high
        volatile uint32_t GFXMMU_LUT935L;  ///< Offset: 0x2D38 - GFXMMU LUT entry 935 low
        volatile uint32_t GFXMMU_LUT935H;  ///< Offset: 0x2D3C - GFXMMU LUT entry 935 high
        volatile uint32_t GFXMMU_LUT936L;  ///< Offset: 0x2D40 - GFXMMU LUT entry 936 low
        volatile uint32_t GFXMMU_LUT936H;  ///< Offset: 0x2D44 - GFXMMU LUT entry 936 high
        volatile uint32_t GFXMMU_LUT937L;  ///< Offset: 0x2D48 - GFXMMU LUT entry 937 low
        volatile uint32_t GFXMMU_LUT937H;  ///< Offset: 0x2D4C - GFXMMU LUT entry 937 high
        volatile uint32_t GFXMMU_LUT938L;  ///< Offset: 0x2D50 - GFXMMU LUT entry 938 low
        volatile uint32_t GFXMMU_LUT938H;  ///< Offset: 0x2D54 - GFXMMU LUT entry 938 high
        volatile uint32_t GFXMMU_LUT939L;  ///< Offset: 0x2D58 - GFXMMU LUT entry 939 low
        volatile uint32_t GFXMMU_LUT939H;  ///< Offset: 0x2D5C - GFXMMU LUT entry 939 high
        volatile uint32_t GFXMMU_LUT940L;  ///< Offset: 0x2D60 - GFXMMU LUT entry 940 low
        volatile uint32_t GFXMMU_LUT940H;  ///< Offset: 0x2D64 - GFXMMU LUT entry 940 high
        volatile uint32_t GFXMMU_LUT941L;  ///< Offset: 0x2D68 - GFXMMU LUT entry 941 low
        volatile uint32_t GFXMMU_LUT941H;  ///< Offset: 0x2D6C - GFXMMU LUT entry 941 high
        volatile uint32_t GFXMMU_LUT942L;  ///< Offset: 0x2D70 - GFXMMU LUT entry 942 low
        volatile uint32_t GFXMMU_LUT942H;  ///< Offset: 0x2D74 - GFXMMU LUT entry 942 high
        volatile uint32_t GFXMMU_LUT943L;  ///< Offset: 0x2D78 - GFXMMU LUT entry 943 low
        volatile uint32_t GFXMMU_LUT943H;  ///< Offset: 0x2D7C - GFXMMU LUT entry 943 high
        volatile uint32_t GFXMMU_LUT944L;  ///< Offset: 0x2D80 - GFXMMU LUT entry 944 low
        volatile uint32_t GFXMMU_LUT944H;  ///< Offset: 0x2D84 - GFXMMU LUT entry 944 high
        volatile uint32_t GFXMMU_LUT945L;  ///< Offset: 0x2D88 - GFXMMU LUT entry 945 low
        volatile uint32_t GFXMMU_LUT945H;  ///< Offset: 0x2D8C - GFXMMU LUT entry 945 high
        volatile uint32_t GFXMMU_LUT946L;  ///< Offset: 0x2D90 - GFXMMU LUT entry 946 low
        volatile uint32_t GFXMMU_LUT946H;  ///< Offset: 0x2D94 - GFXMMU LUT entry 946 high
        volatile uint32_t GFXMMU_LUT947L;  ///< Offset: 0x2D98 - GFXMMU LUT entry 947 low
        volatile uint32_t GFXMMU_LUT947H;  ///< Offset: 0x2D9C - GFXMMU LUT entry 947 high
        volatile uint32_t GFXMMU_LUT948L;  ///< Offset: 0x2DA0 - GFXMMU LUT entry 948 low
        volatile uint32_t GFXMMU_LUT948H;  ///< Offset: 0x2DA4 - GFXMMU LUT entry 948 high
        volatile uint32_t GFXMMU_LUT949L;  ///< Offset: 0x2DA8 - GFXMMU LUT entry 949 low
        volatile uint32_t GFXMMU_LUT949H;  ///< Offset: 0x2DAC - GFXMMU LUT entry 949 high
        volatile uint32_t GFXMMU_LUT950L;  ///< Offset: 0x2DB0 - GFXMMU LUT entry 950 low
        volatile uint32_t GFXMMU_LUT950H;  ///< Offset: 0x2DB4 - GFXMMU LUT entry 950 high
        volatile uint32_t GFXMMU_LUT951L;  ///< Offset: 0x2DB8 - GFXMMU LUT entry 951 low
        volatile uint32_t GFXMMU_LUT951H;  ///< Offset: 0x2DBC - GFXMMU LUT entry 951 high
        volatile uint32_t GFXMMU_LUT952L;  ///< Offset: 0x2DC0 - GFXMMU LUT entry 952 low
        volatile uint32_t GFXMMU_LUT952H;  ///< Offset: 0x2DC4 - GFXMMU LUT entry 952 high
        volatile uint32_t GFXMMU_LUT953L;  ///< Offset: 0x2DC8 - GFXMMU LUT entry 953 low
        volatile uint32_t GFXMMU_LUT953H;  ///< Offset: 0x2DCC - GFXMMU LUT entry 953 high
        volatile uint32_t GFXMMU_LUT954L;  ///< Offset: 0x2DD0 - GFXMMU LUT entry 954 low
        volatile uint32_t GFXMMU_LUT954H;  ///< Offset: 0x2DD4 - GFXMMU LUT entry 954 high
        volatile uint32_t GFXMMU_LUT955L;  ///< Offset: 0x2DD8 - GFXMMU LUT entry 955 low
        volatile uint32_t GFXMMU_LUT955H;  ///< Offset: 0x2DDC - GFXMMU LUT entry 955 high
        volatile uint32_t GFXMMU_LUT956L;  ///< Offset: 0x2DE0 - GFXMMU LUT entry 956 low
        volatile uint32_t GFXMMU_LUT956H;  ///< Offset: 0x2DE4 - GFXMMU LUT entry 956 high
        volatile uint32_t GFXMMU_LUT957L;  ///< Offset: 0x2DE8 - GFXMMU LUT entry 957 low
        volatile uint32_t GFXMMU_LUT957H;  ///< Offset: 0x2DEC - GFXMMU LUT entry 957 high
        volatile uint32_t GFXMMU_LUT958L;  ///< Offset: 0x2DF0 - GFXMMU LUT entry 958 low
        volatile uint32_t GFXMMU_LUT958H;  ///< Offset: 0x2DF4 - GFXMMU LUT entry 958 high
        volatile uint32_t GFXMMU_LUT959L;  ///< Offset: 0x2DF8 - GFXMMU LUT entry 959 low
        volatile uint32_t GFXMMU_LUT959H;  ///< Offset: 0x2DFC - GFXMMU LUT entry 959 high
        volatile uint32_t GFXMMU_LUT960L;  ///< Offset: 0x2E00 - GFXMMU LUT entry 960 low
        volatile uint32_t GFXMMU_LUT960H;  ///< Offset: 0x2E04 - GFXMMU LUT entry 960 high
        volatile uint32_t GFXMMU_LUT961L;  ///< Offset: 0x2E08 - GFXMMU LUT entry 961 low
        volatile uint32_t GFXMMU_LUT961H;  ///< Offset: 0x2E0C - GFXMMU LUT entry 961 high
        volatile uint32_t GFXMMU_LUT962L;  ///< Offset: 0x2E10 - GFXMMU LUT entry 962 low
        volatile uint32_t GFXMMU_LUT962H;  ///< Offset: 0x2E14 - GFXMMU LUT entry 962 high
        volatile uint32_t GFXMMU_LUT963L;  ///< Offset: 0x2E18 - GFXMMU LUT entry 963 low
        volatile uint32_t GFXMMU_LUT963H;  ///< Offset: 0x2E1C - GFXMMU LUT entry 963 high
        volatile uint32_t GFXMMU_LUT964L;  ///< Offset: 0x2E20 - GFXMMU LUT entry 964 low
        volatile uint32_t GFXMMU_LUT964H;  ///< Offset: 0x2E24 - GFXMMU LUT entry 964 high
        volatile uint32_t GFXMMU_LUT965L;  ///< Offset: 0x2E28 - GFXMMU LUT entry 965 low
        volatile uint32_t GFXMMU_LUT965H;  ///< Offset: 0x2E2C - GFXMMU LUT entry 965 high
        volatile uint32_t GFXMMU_LUT966L;  ///< Offset: 0x2E30 - GFXMMU LUT entry 966 low
        volatile uint32_t GFXMMU_LUT966H;  ///< Offset: 0x2E34 - GFXMMU LUT entry 966 high
        volatile uint32_t GFXMMU_LUT967L;  ///< Offset: 0x2E38 - GFXMMU LUT entry 967 low
        volatile uint32_t GFXMMU_LUT967H;  ///< Offset: 0x2E3C - GFXMMU LUT entry 967 high
        volatile uint32_t GFXMMU_LUT968L;  ///< Offset: 0x2E40 - GFXMMU LUT entry 968 low
        volatile uint32_t GFXMMU_LUT968H;  ///< Offset: 0x2E44 - GFXMMU LUT entry 968 high
        volatile uint32_t GFXMMU_LUT969L;  ///< Offset: 0x2E48 - GFXMMU LUT entry 969 low
        volatile uint32_t GFXMMU_LUT969H;  ///< Offset: 0x2E4C - GFXMMU LUT entry 969 high
        volatile uint32_t GFXMMU_LUT970L;  ///< Offset: 0x2E50 - GFXMMU LUT entry 970 low
        volatile uint32_t GFXMMU_LUT970H;  ///< Offset: 0x2E54 - GFXMMU LUT entry 970 high
        volatile uint32_t GFXMMU_LUT971L;  ///< Offset: 0x2E58 - GFXMMU LUT entry 971 low
        volatile uint32_t GFXMMU_LUT971H;  ///< Offset: 0x2E5C - GFXMMU LUT entry 971 high
        volatile uint32_t GFXMMU_LUT972L;  ///< Offset: 0x2E60 - GFXMMU LUT entry 972 low
        volatile uint32_t GFXMMU_LUT972H;  ///< Offset: 0x2E64 - GFXMMU LUT entry 972 high
        volatile uint32_t GFXMMU_LUT973L;  ///< Offset: 0x2E68 - GFXMMU LUT entry 973 low
        volatile uint32_t GFXMMU_LUT973H;  ///< Offset: 0x2E6C - GFXMMU LUT entry 973 high
        volatile uint32_t GFXMMU_LUT974L;  ///< Offset: 0x2E70 - GFXMMU LUT entry 974 low
        volatile uint32_t GFXMMU_LUT974H;  ///< Offset: 0x2E74 - GFXMMU LUT entry 974 high
        volatile uint32_t GFXMMU_LUT975L;  ///< Offset: 0x2E78 - GFXMMU LUT entry 975 low
        volatile uint32_t GFXMMU_LUT975H;  ///< Offset: 0x2E7C - GFXMMU LUT entry 975 high
        volatile uint32_t GFXMMU_LUT976L;  ///< Offset: 0x2E80 - GFXMMU LUT entry 976 low
        volatile uint32_t GFXMMU_LUT976H;  ///< Offset: 0x2E84 - GFXMMU LUT entry 976 high
        volatile uint32_t GFXMMU_LUT977L;  ///< Offset: 0x2E88 - GFXMMU LUT entry 977 low
        volatile uint32_t GFXMMU_LUT977H;  ///< Offset: 0x2E8C - GFXMMU LUT entry 977 high
        volatile uint32_t GFXMMU_LUT978L;  ///< Offset: 0x2E90 - GFXMMU LUT entry 978 low
        volatile uint32_t GFXMMU_LUT978H;  ///< Offset: 0x2E94 - GFXMMU LUT entry 978 high
        volatile uint32_t GFXMMU_LUT979L;  ///< Offset: 0x2E98 - GFXMMU LUT entry 979 low
        volatile uint32_t GFXMMU_LUT979H;  ///< Offset: 0x2E9C - GFXMMU LUT entry 979 high
        volatile uint32_t GFXMMU_LUT980L;  ///< Offset: 0x2EA0 - GFXMMU LUT entry 980 low
        volatile uint32_t GFXMMU_LUT980H;  ///< Offset: 0x2EA4 - GFXMMU LUT entry 980 high
        volatile uint32_t GFXMMU_LUT981L;  ///< Offset: 0x2EA8 - GFXMMU LUT entry 981 low
        volatile uint32_t GFXMMU_LUT981H;  ///< Offset: 0x2EAC - GFXMMU LUT entry 981 high
        volatile uint32_t GFXMMU_LUT982L;  ///< Offset: 0x2EB0 - GFXMMU LUT entry 982 low
        volatile uint32_t GFXMMU_LUT982H;  ///< Offset: 0x2EB4 - GFXMMU LUT entry 982 high
        volatile uint32_t GFXMMU_LUT983L;  ///< Offset: 0x2EB8 - GFXMMU LUT entry 983 low
        volatile uint32_t GFXMMU_LUT983H;  ///< Offset: 0x2EBC - GFXMMU LUT entry 983 high
        volatile uint32_t GFXMMU_LUT984L;  ///< Offset: 0x2EC0 - GFXMMU LUT entry 984 low
        volatile uint32_t GFXMMU_LUT984H;  ///< Offset: 0x2EC4 - GFXMMU LUT entry 984 high
        volatile uint32_t GFXMMU_LUT985L;  ///< Offset: 0x2EC8 - GFXMMU LUT entry 985 low
        volatile uint32_t GFXMMU_LUT985H;  ///< Offset: 0x2ECC - GFXMMU LUT entry 985 high
        volatile uint32_t GFXMMU_LUT986L;  ///< Offset: 0x2ED0 - GFXMMU LUT entry 986 low
        volatile uint32_t GFXMMU_LUT986H;  ///< Offset: 0x2ED4 - GFXMMU LUT entry 986 high
        volatile uint32_t GFXMMU_LUT987L;  ///< Offset: 0x2ED8 - GFXMMU LUT entry 987 low
        volatile uint32_t GFXMMU_LUT987H;  ///< Offset: 0x2EDC - GFXMMU LUT entry 987 high
        volatile uint32_t GFXMMU_LUT988L;  ///< Offset: 0x2EE0 - GFXMMU LUT entry 988 low
        volatile uint32_t GFXMMU_LUT988H;  ///< Offset: 0x2EE4 - GFXMMU LUT entry 988 high
        volatile uint32_t GFXMMU_LUT989L;  ///< Offset: 0x2EE8 - GFXMMU LUT entry 989 low
        volatile uint32_t GFXMMU_LUT989H;  ///< Offset: 0x2EEC - GFXMMU LUT entry 989 high
        volatile uint32_t GFXMMU_LUT990L;  ///< Offset: 0x2EF0 - GFXMMU LUT entry 990 low
        volatile uint32_t GFXMMU_LUT990H;  ///< Offset: 0x2EF4 - GFXMMU LUT entry 990 high
        volatile uint32_t GFXMMU_LUT991L;  ///< Offset: 0x2EF8 - GFXMMU LUT entry 991 low
        volatile uint32_t GFXMMU_LUT991H;  ///< Offset: 0x2EFC - GFXMMU LUT entry 991 high
        volatile uint32_t GFXMMU_LUT992L;  ///< Offset: 0x2F00 - GFXMMU LUT entry 992 low
        volatile uint32_t GFXMMU_LUT992H;  ///< Offset: 0x2F04 - GFXMMU LUT entry 992 high
        volatile uint32_t GFXMMU_LUT993L;  ///< Offset: 0x2F08 - GFXMMU LUT entry 993 low
        volatile uint32_t GFXMMU_LUT993H;  ///< Offset: 0x2F0C - GFXMMU LUT entry 993 high
        volatile uint32_t GFXMMU_LUT994L;  ///< Offset: 0x2F10 - GFXMMU LUT entry 994 low
        volatile uint32_t GFXMMU_LUT994H;  ///< Offset: 0x2F14 - GFXMMU LUT entry 994 high
        volatile uint32_t GFXMMU_LUT995L;  ///< Offset: 0x2F18 - GFXMMU LUT entry 995 low
        volatile uint32_t GFXMMU_LUT995H;  ///< Offset: 0x2F1C - GFXMMU LUT entry 995 high
        volatile uint32_t GFXMMU_LUT996L;  ///< Offset: 0x2F20 - GFXMMU LUT entry 996 low
        volatile uint32_t GFXMMU_LUT996H;  ///< Offset: 0x2F24 - GFXMMU LUT entry 996 high
        volatile uint32_t GFXMMU_LUT997L;  ///< Offset: 0x2F28 - GFXMMU LUT entry 997 low
        volatile uint32_t GFXMMU_LUT997H;  ///< Offset: 0x2F2C - GFXMMU LUT entry 997 high
        volatile uint32_t GFXMMU_LUT998L;  ///< Offset: 0x2F30 - GFXMMU LUT entry 998 low
        volatile uint32_t GFXMMU_LUT998H;  ///< Offset: 0x2F34 - GFXMMU LUT entry 998 high
        volatile uint32_t GFXMMU_LUT999L;  ///< Offset: 0x2F38 - GFXMMU LUT entry 999 low
        volatile uint32_t GFXMMU_LUT999H;  ///< Offset: 0x2F3C - GFXMMU LUT entry 999 high
        volatile uint32_t GFXMMU_LUT1000L;  ///< Offset: 0x2F40 - GFXMMU LUT entry 1000 low
        volatile uint32_t GFXMMU_LUT1000H;  ///< Offset: 0x2F44 - GFXMMU LUT entry 1000 high
        volatile uint32_t GFXMMU_LUT1001L;  ///< Offset: 0x2F48 - GFXMMU LUT entry 1001 low
        volatile uint32_t GFXMMU_LUT1001H;  ///< Offset: 0x2F4C - GFXMMU LUT entry 1001 high
        volatile uint32_t GFXMMU_LUT1002L;  ///< Offset: 0x2F50 - GFXMMU LUT entry 1002 low
        volatile uint32_t GFXMMU_LUT1002H;  ///< Offset: 0x2F54 - GFXMMU LUT entry 1002 high
        volatile uint32_t GFXMMU_LUT1003L;  ///< Offset: 0x2F58 - GFXMMU LUT entry 1003 low
        volatile uint32_t GFXMMU_LUT1003H;  ///< Offset: 0x2F5C - GFXMMU LUT entry 1003 high
        volatile uint32_t GFXMMU_LUT1004L;  ///< Offset: 0x2F60 - GFXMMU LUT entry 1004 low
        volatile uint32_t GFXMMU_LUT1004H;  ///< Offset: 0x2F64 - GFXMMU LUT entry 1004 high
        volatile uint32_t GFXMMU_LUT1005L;  ///< Offset: 0x2F68 - GFXMMU LUT entry 1005 low
        volatile uint32_t GFXMMU_LUT1005H;  ///< Offset: 0x2F6C - GFXMMU LUT entry 1005 high
        volatile uint32_t GFXMMU_LUT1006L;  ///< Offset: 0x2F70 - GFXMMU LUT entry 1006 low
        volatile uint32_t GFXMMU_LUT1006H;  ///< Offset: 0x2F74 - GFXMMU LUT entry 1006 high
        volatile uint32_t GFXMMU_LUT1007L;  ///< Offset: 0x2F78 - GFXMMU LUT entry 1007 low
        volatile uint32_t GFXMMU_LUT1007H;  ///< Offset: 0x2F7C - GFXMMU LUT entry 1007 high
        volatile uint32_t GFXMMU_LUT1008L;  ///< Offset: 0x2F80 - GFXMMU LUT entry 1008 low
        volatile uint32_t GFXMMU_LUT1008H;  ///< Offset: 0x2F84 - GFXMMU LUT entry 1008 high
        volatile uint32_t GFXMMU_LUT1009L;  ///< Offset: 0x2F88 - GFXMMU LUT entry 1009 low
        volatile uint32_t GFXMMU_LUT1009H;  ///< Offset: 0x2F8C - GFXMMU LUT entry 1009 high
        volatile uint32_t GFXMMU_LUT1010L;  ///< Offset: 0x2F90 - GFXMMU LUT entry 1010 low
        volatile uint32_t GFXMMU_LUT1010H;  ///< Offset: 0x2F94 - GFXMMU LUT entry 1010 high
        volatile uint32_t GFXMMU_LUT1011L;  ///< Offset: 0x2F98 - GFXMMU LUT entry 1011 low
        volatile uint32_t GFXMMU_LUT1011H;  ///< Offset: 0x2F9C - GFXMMU LUT entry 1011 high
        volatile uint32_t GFXMMU_LUT1012L;  ///< Offset: 0x2FA0 - GFXMMU LUT entry 1012 low
        volatile uint32_t GFXMMU_LUT1012H;  ///< Offset: 0x2FA4 - GFXMMU LUT entry 1012 high
        volatile uint32_t GFXMMU_LUT1013L;  ///< Offset: 0x2FA8 - GFXMMU LUT entry 1013 low
        volatile uint32_t GFXMMU_LUT1013H;  ///< Offset: 0x2FAC - GFXMMU LUT entry 1013 high
        volatile uint32_t GFXMMU_LUT1014L;  ///< Offset: 0x2FB0 - GFXMMU LUT entry 1014 low
        volatile uint32_t GFXMMU_LUT1014H;  ///< Offset: 0x2FB4 - GFXMMU LUT entry 1014 high
        volatile uint32_t GFXMMU_LUT1015L;  ///< Offset: 0x2FB8 - GFXMMU LUT entry 1015 low
        volatile uint32_t GFXMMU_LUT1015H;  ///< Offset: 0x2FBC - GFXMMU LUT entry 1015 high
        volatile uint32_t GFXMMU_LUT1016L;  ///< Offset: 0x2FC0 - GFXMMU LUT entry 1016 low
        volatile uint32_t GFXMMU_LUT1016H;  ///< Offset: 0x2FC4 - GFXMMU LUT entry 1016 high
        volatile uint32_t GFXMMU_LUT1017L;  ///< Offset: 0x2FC8 - GFXMMU LUT entry 1017 low
        volatile uint32_t GFXMMU_LUT1017H;  ///< Offset: 0x2FCC - GFXMMU LUT entry 1017 high
        volatile uint32_t GFXMMU_LUT1018L;  ///< Offset: 0x2FD0 - GFXMMU LUT entry 1018 low
        volatile uint32_t GFXMMU_LUT1018H;  ///< Offset: 0x2FD4 - GFXMMU LUT entry 1018 high
        volatile uint32_t GFXMMU_LUT1019L;  ///< Offset: 0x2FD8 - GFXMMU LUT entry 1019 low
        volatile uint32_t GFXMMU_LUT1019H;  ///< Offset: 0x2FDC - GFXMMU LUT entry 1019 high
        volatile uint32_t GFXMMU_LUT1020L;  ///< Offset: 0x2FE0 - GFXMMU LUT entry 1020 low
        volatile uint32_t GFXMMU_LUT1020H;  ///< Offset: 0x2FE4 - GFXMMU LUT entry 1020 high
        volatile uint32_t GFXMMU_LUT1021L;  ///< Offset: 0x2FE8 - GFXMMU LUT entry 1021 low
        volatile uint32_t GFXMMU_LUT1021H;  ///< Offset: 0x2FEC - GFXMMU LUT entry 1021 high
        volatile uint32_t GFXMMU_LUT1022L;  ///< Offset: 0x2FF0 - GFXMMU LUT entry 1022 low
        volatile uint32_t GFXMMU_LUT1022H;  ///< Offset: 0x2FF4 - GFXMMU LUT entry 1022 high
        volatile uint32_t GFXMMU_LUT1023L;  ///< Offset: 0x2FF8 - GFXMMU LUT entry 1023 low
        volatile uint32_t GFXMMU_LUT1023H;  ///< Offset: 0x2FFC - GFXMMU LUT entry 1023 high
    };

    /// Peripheral instances
    inline Registers* GFXMMU = reinterpret_cast<Registers*>(GFXMMU_BASE);

    // Bit definitions
    /// GFXMMU_CR Register bits
    namespace gfxmmu_cr_bits {
        constexpr uint32_t B0OIE = (1U << 0);  ///< Buffer 0 overflow interrupt enable This bit enables the buffer 0 overflow interrupt.
        constexpr uint32_t B1OIE = (1U << 1);  ///< Buffer 1 overflow interrupt enable This bit enables the buffer 1 overflow interrupt.
        constexpr uint32_t B2OIE = (1U << 2);  ///< Buffer 2 overflow interrupt enable This bit enables the buffer 2 overflow interrupt.
        constexpr uint32_t B3OIE = (1U << 3);  ///< Buffer 3 overflow interrupt enable This bit enables the buffer 3 overflow interrupt.
        constexpr uint32_t AMEIE = (1U << 4);  ///< AHB master error interrupt enable This bit enables the AHB master error interrupt.
        constexpr uint32_t BM192 = (1U << 6);  ///< 192 Block mode This bit defines the number of blocks per line
        constexpr uint32_t CE = (1U << 7);  ///< Cache enable This bit enables the cache unit.
        constexpr uint32_t CL = (1U << 8);  ///< Cache lock This bit lock the cache onto the buffer defined in the CLB field.
        constexpr uint32_t CLB = (2 << 9);  ///< Cache lock buffer This field select the buffer on which the cache is locked.
        constexpr uint32_t FC = (1U << 11);  ///< Force caching This bit force the caching into the cache regardless of the MPU attributes. The cache must be enable (CE bit set).
        constexpr uint32_t PD = (1U << 12);  ///< Prefetch disable This bit disables the prefetch of the cache.
        constexpr uint32_t OC = (1U << 16);  ///< Outter cachability This bit configure the cachability of an access generated by the GFXMMU cache.
        constexpr uint32_t OB = (1U << 17);  ///< Outter bufferability This bit configure the bufferability of an access generated by the GFXMMU cache.
    }

    /// GFXMMU_SR Register bits
    namespace gfxmmu_sr_bits {
        constexpr uint32_t B0OF = (1U << 0);  ///< Buffer 0 overflow flag This bit is set when an overflow occurs during the offset calculation of the buffer 0. It is cleared by writing 1 to CB0OF.
        constexpr uint32_t B1OF = (1U << 1);  ///< Buffer 1 overflow flag This bit is set when an overflow occurs during the offset calculation of the buffer 1. It is cleared by writing 1 to CB1OF.
        constexpr uint32_t B2OF = (1U << 2);  ///< Buffer 2 overflow flag This bit is set when an overflow occurs during the offset calculation of the buffer 2. It is cleared by writing 1 to CB2OF.
        constexpr uint32_t B3OF = (1U << 3);  ///< Buffer 3 overflow flag This bit is set when an overflow occurs during the offset calculation of the buffer 3. It is cleared by writing 1 to CB3OF.
        constexpr uint32_t AMEF = (1U << 4);  ///< AHB master error flag This bit is set when an AHB error happens during a transaction. It is cleared by writing 1 to CAMEF.
    }

    /// GFXMMU_FCR Register bits
    namespace gfxmmu_fcr_bits {
        constexpr uint32_t CB0OF = (1U << 0);  ///< Clear buffer 0 overflow flag Writing 1 clears the buffer 0 overflow flag in the GFXMMU_SR register.
        constexpr uint32_t CB1OF = (1U << 1);  ///< Clear buffer 1 overflow flag Writing 1 clears the buffer 1 overflow flag in the GFXMMU_SR register.
        constexpr uint32_t CB2OF = (1U << 2);  ///< Clear buffer 2 overflow flag Writing 1 clears the buffer 2 overflow flag in the GFXMMU_SR register.
        constexpr uint32_t CB3OF = (1U << 3);  ///< Clear buffer 3 overflow flag Writing 1 clears the buffer 3 overflow flag in the GFXMMU_SR register.
        constexpr uint32_t CAMEF = (1U << 4);  ///< Clear AHB master error flag Writing 1 clears the AHB master error flag in the GFXMMU_SR register.
    }

    /// GFXMMU_CCR Register bits
    namespace gfxmmu_ccr_bits {
        constexpr uint32_t FF = (1U << 0);  ///< Force flush When set, the cache entries are flushed. This bit is reset by hardware when the flushing is complete. Write 0 has no effect.
        constexpr uint32_t FI = (1U << 1);  ///< Force invalidate When set, the cache entries are invalidated. This bit is reset by hardware when the invalidation is complete. Write 0 has no effect.
    }

    /// GFXMMU_DVR Register bits
    namespace gfxmmu_dvr_bits {
        constexpr uint32_t DV = (32 << 0);  ///< Default value This field indicates the default 32-bit value which is returned when a master accesses a virtual memory location not physically mapped.
    }

    /// GFXMMU_B0CR Register bits
    namespace gfxmmu_b0cr_bits {
        constexpr uint32_t PBO = (19 << 4);  ///< Physical buffer offset Offset of the physical buffer.
        constexpr uint32_t PBBA = (9 << 23);  ///< Physical buffer base address Base address MSB of the physical buffer.
    }

    /// GFXMMU_B1CR Register bits
    namespace gfxmmu_b1cr_bits {
        constexpr uint32_t PBO = (19 << 4);  ///< Physical buffer offset Offset of the physical buffer.
        constexpr uint32_t PBBA = (9 << 23);  ///< Physical buffer base address Base address MSB of the physical buffer.
    }

    /// GFXMMU_B2CR Register bits
    namespace gfxmmu_b2cr_bits {
        constexpr uint32_t PBO = (19 << 4);  ///< Physical buffer offset Offset of the physical buffer.
        constexpr uint32_t PBBA = (9 << 23);  ///< Physical buffer base address Base address MSB of the physical buffer.
    }

    /// GFXMMU_B3CR Register bits
    namespace gfxmmu_b3cr_bits {
        constexpr uint32_t PBO = (19 << 4);  ///< Physical buffer offset Offset of the physical buffer.
        constexpr uint32_t PBBA = (9 << 23);  ///< Physical buffer base address Base address MSB of the physical buffer.
    }

    /// GFXMMU_LUT0L Register bits
    namespace gfxmmu_lut0l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT0H Register bits
    namespace gfxmmu_lut0h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1L Register bits
    namespace gfxmmu_lut1l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1H Register bits
    namespace gfxmmu_lut1h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT2L Register bits
    namespace gfxmmu_lut2l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT2H Register bits
    namespace gfxmmu_lut2h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT3L Register bits
    namespace gfxmmu_lut3l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT3H Register bits
    namespace gfxmmu_lut3h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT4L Register bits
    namespace gfxmmu_lut4l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT4H Register bits
    namespace gfxmmu_lut4h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT5L Register bits
    namespace gfxmmu_lut5l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT5H Register bits
    namespace gfxmmu_lut5h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT6L Register bits
    namespace gfxmmu_lut6l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT6H Register bits
    namespace gfxmmu_lut6h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT7L Register bits
    namespace gfxmmu_lut7l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT7H Register bits
    namespace gfxmmu_lut7h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT8L Register bits
    namespace gfxmmu_lut8l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT8H Register bits
    namespace gfxmmu_lut8h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT9L Register bits
    namespace gfxmmu_lut9l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT9H Register bits
    namespace gfxmmu_lut9h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT10L Register bits
    namespace gfxmmu_lut10l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT10H Register bits
    namespace gfxmmu_lut10h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT11L Register bits
    namespace gfxmmu_lut11l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT11H Register bits
    namespace gfxmmu_lut11h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT12L Register bits
    namespace gfxmmu_lut12l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT12H Register bits
    namespace gfxmmu_lut12h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT13L Register bits
    namespace gfxmmu_lut13l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT13H Register bits
    namespace gfxmmu_lut13h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT14L Register bits
    namespace gfxmmu_lut14l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT14H Register bits
    namespace gfxmmu_lut14h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT15L Register bits
    namespace gfxmmu_lut15l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT15H Register bits
    namespace gfxmmu_lut15h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT16L Register bits
    namespace gfxmmu_lut16l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT16H Register bits
    namespace gfxmmu_lut16h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT17L Register bits
    namespace gfxmmu_lut17l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT17H Register bits
    namespace gfxmmu_lut17h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT18L Register bits
    namespace gfxmmu_lut18l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT18H Register bits
    namespace gfxmmu_lut18h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT19L Register bits
    namespace gfxmmu_lut19l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT19H Register bits
    namespace gfxmmu_lut19h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT20L Register bits
    namespace gfxmmu_lut20l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT20H Register bits
    namespace gfxmmu_lut20h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT21L Register bits
    namespace gfxmmu_lut21l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT21H Register bits
    namespace gfxmmu_lut21h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT22L Register bits
    namespace gfxmmu_lut22l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT22H Register bits
    namespace gfxmmu_lut22h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT23L Register bits
    namespace gfxmmu_lut23l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT23H Register bits
    namespace gfxmmu_lut23h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT24L Register bits
    namespace gfxmmu_lut24l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT24H Register bits
    namespace gfxmmu_lut24h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT25L Register bits
    namespace gfxmmu_lut25l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT25H Register bits
    namespace gfxmmu_lut25h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT26L Register bits
    namespace gfxmmu_lut26l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT26H Register bits
    namespace gfxmmu_lut26h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT27L Register bits
    namespace gfxmmu_lut27l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT27H Register bits
    namespace gfxmmu_lut27h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT28L Register bits
    namespace gfxmmu_lut28l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT28H Register bits
    namespace gfxmmu_lut28h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT29L Register bits
    namespace gfxmmu_lut29l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT29H Register bits
    namespace gfxmmu_lut29h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT30L Register bits
    namespace gfxmmu_lut30l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT30H Register bits
    namespace gfxmmu_lut30h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT31L Register bits
    namespace gfxmmu_lut31l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT31H Register bits
    namespace gfxmmu_lut31h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT32L Register bits
    namespace gfxmmu_lut32l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT32H Register bits
    namespace gfxmmu_lut32h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT33L Register bits
    namespace gfxmmu_lut33l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT33H Register bits
    namespace gfxmmu_lut33h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT34L Register bits
    namespace gfxmmu_lut34l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT34H Register bits
    namespace gfxmmu_lut34h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT35L Register bits
    namespace gfxmmu_lut35l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT35H Register bits
    namespace gfxmmu_lut35h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT36L Register bits
    namespace gfxmmu_lut36l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT36H Register bits
    namespace gfxmmu_lut36h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT37L Register bits
    namespace gfxmmu_lut37l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT37H Register bits
    namespace gfxmmu_lut37h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT38L Register bits
    namespace gfxmmu_lut38l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT38H Register bits
    namespace gfxmmu_lut38h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT39L Register bits
    namespace gfxmmu_lut39l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT39H Register bits
    namespace gfxmmu_lut39h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT40L Register bits
    namespace gfxmmu_lut40l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT40H Register bits
    namespace gfxmmu_lut40h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT41L Register bits
    namespace gfxmmu_lut41l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT41H Register bits
    namespace gfxmmu_lut41h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT42L Register bits
    namespace gfxmmu_lut42l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT42H Register bits
    namespace gfxmmu_lut42h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT43L Register bits
    namespace gfxmmu_lut43l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT43H Register bits
    namespace gfxmmu_lut43h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT44L Register bits
    namespace gfxmmu_lut44l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT44H Register bits
    namespace gfxmmu_lut44h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT45L Register bits
    namespace gfxmmu_lut45l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT45H Register bits
    namespace gfxmmu_lut45h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT46L Register bits
    namespace gfxmmu_lut46l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT46H Register bits
    namespace gfxmmu_lut46h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT47L Register bits
    namespace gfxmmu_lut47l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT47H Register bits
    namespace gfxmmu_lut47h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT48L Register bits
    namespace gfxmmu_lut48l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT48H Register bits
    namespace gfxmmu_lut48h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT49L Register bits
    namespace gfxmmu_lut49l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT49H Register bits
    namespace gfxmmu_lut49h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT50L Register bits
    namespace gfxmmu_lut50l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT50H Register bits
    namespace gfxmmu_lut50h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT51L Register bits
    namespace gfxmmu_lut51l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT51H Register bits
    namespace gfxmmu_lut51h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT52L Register bits
    namespace gfxmmu_lut52l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT52H Register bits
    namespace gfxmmu_lut52h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT53L Register bits
    namespace gfxmmu_lut53l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT53H Register bits
    namespace gfxmmu_lut53h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT54L Register bits
    namespace gfxmmu_lut54l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT54H Register bits
    namespace gfxmmu_lut54h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT55L Register bits
    namespace gfxmmu_lut55l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT55H Register bits
    namespace gfxmmu_lut55h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT56L Register bits
    namespace gfxmmu_lut56l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT56H Register bits
    namespace gfxmmu_lut56h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT57L Register bits
    namespace gfxmmu_lut57l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT57H Register bits
    namespace gfxmmu_lut57h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT58L Register bits
    namespace gfxmmu_lut58l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT58H Register bits
    namespace gfxmmu_lut58h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT59L Register bits
    namespace gfxmmu_lut59l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT59H Register bits
    namespace gfxmmu_lut59h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT60L Register bits
    namespace gfxmmu_lut60l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT60H Register bits
    namespace gfxmmu_lut60h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT61L Register bits
    namespace gfxmmu_lut61l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT61H Register bits
    namespace gfxmmu_lut61h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT62L Register bits
    namespace gfxmmu_lut62l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT62H Register bits
    namespace gfxmmu_lut62h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT63L Register bits
    namespace gfxmmu_lut63l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT63H Register bits
    namespace gfxmmu_lut63h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT64L Register bits
    namespace gfxmmu_lut64l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT64H Register bits
    namespace gfxmmu_lut64h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT65L Register bits
    namespace gfxmmu_lut65l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT65H Register bits
    namespace gfxmmu_lut65h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT66L Register bits
    namespace gfxmmu_lut66l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT66H Register bits
    namespace gfxmmu_lut66h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT67L Register bits
    namespace gfxmmu_lut67l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT67H Register bits
    namespace gfxmmu_lut67h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT68L Register bits
    namespace gfxmmu_lut68l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT68H Register bits
    namespace gfxmmu_lut68h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT69L Register bits
    namespace gfxmmu_lut69l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT69H Register bits
    namespace gfxmmu_lut69h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT70L Register bits
    namespace gfxmmu_lut70l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT70H Register bits
    namespace gfxmmu_lut70h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT71L Register bits
    namespace gfxmmu_lut71l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT71H Register bits
    namespace gfxmmu_lut71h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT72L Register bits
    namespace gfxmmu_lut72l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT72H Register bits
    namespace gfxmmu_lut72h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT73L Register bits
    namespace gfxmmu_lut73l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT73H Register bits
    namespace gfxmmu_lut73h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT74L Register bits
    namespace gfxmmu_lut74l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT74H Register bits
    namespace gfxmmu_lut74h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT75L Register bits
    namespace gfxmmu_lut75l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT75H Register bits
    namespace gfxmmu_lut75h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT76L Register bits
    namespace gfxmmu_lut76l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT76H Register bits
    namespace gfxmmu_lut76h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT77L Register bits
    namespace gfxmmu_lut77l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT77H Register bits
    namespace gfxmmu_lut77h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT78L Register bits
    namespace gfxmmu_lut78l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT78H Register bits
    namespace gfxmmu_lut78h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT79L Register bits
    namespace gfxmmu_lut79l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT79H Register bits
    namespace gfxmmu_lut79h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT80L Register bits
    namespace gfxmmu_lut80l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT80H Register bits
    namespace gfxmmu_lut80h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT81L Register bits
    namespace gfxmmu_lut81l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT81H Register bits
    namespace gfxmmu_lut81h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT82L Register bits
    namespace gfxmmu_lut82l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT82H Register bits
    namespace gfxmmu_lut82h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT83L Register bits
    namespace gfxmmu_lut83l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT83H Register bits
    namespace gfxmmu_lut83h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT84L Register bits
    namespace gfxmmu_lut84l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT84H Register bits
    namespace gfxmmu_lut84h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT85L Register bits
    namespace gfxmmu_lut85l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT85H Register bits
    namespace gfxmmu_lut85h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT86L Register bits
    namespace gfxmmu_lut86l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT86H Register bits
    namespace gfxmmu_lut86h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT87L Register bits
    namespace gfxmmu_lut87l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT87H Register bits
    namespace gfxmmu_lut87h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT88L Register bits
    namespace gfxmmu_lut88l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT88H Register bits
    namespace gfxmmu_lut88h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT89L Register bits
    namespace gfxmmu_lut89l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT89H Register bits
    namespace gfxmmu_lut89h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT90L Register bits
    namespace gfxmmu_lut90l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT90H Register bits
    namespace gfxmmu_lut90h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT91L Register bits
    namespace gfxmmu_lut91l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT91H Register bits
    namespace gfxmmu_lut91h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT92L Register bits
    namespace gfxmmu_lut92l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT92H Register bits
    namespace gfxmmu_lut92h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT93L Register bits
    namespace gfxmmu_lut93l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT93H Register bits
    namespace gfxmmu_lut93h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT94L Register bits
    namespace gfxmmu_lut94l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT94H Register bits
    namespace gfxmmu_lut94h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT95L Register bits
    namespace gfxmmu_lut95l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT95H Register bits
    namespace gfxmmu_lut95h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT96L Register bits
    namespace gfxmmu_lut96l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT96H Register bits
    namespace gfxmmu_lut96h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT97L Register bits
    namespace gfxmmu_lut97l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT97H Register bits
    namespace gfxmmu_lut97h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT98L Register bits
    namespace gfxmmu_lut98l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT98H Register bits
    namespace gfxmmu_lut98h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT99L Register bits
    namespace gfxmmu_lut99l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT99H Register bits
    namespace gfxmmu_lut99h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT100L Register bits
    namespace gfxmmu_lut100l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT100H Register bits
    namespace gfxmmu_lut100h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT101L Register bits
    namespace gfxmmu_lut101l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT101H Register bits
    namespace gfxmmu_lut101h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT102L Register bits
    namespace gfxmmu_lut102l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT102H Register bits
    namespace gfxmmu_lut102h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT103L Register bits
    namespace gfxmmu_lut103l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT103H Register bits
    namespace gfxmmu_lut103h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT104L Register bits
    namespace gfxmmu_lut104l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT104H Register bits
    namespace gfxmmu_lut104h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT105L Register bits
    namespace gfxmmu_lut105l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT105H Register bits
    namespace gfxmmu_lut105h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT106L Register bits
    namespace gfxmmu_lut106l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT106H Register bits
    namespace gfxmmu_lut106h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT107L Register bits
    namespace gfxmmu_lut107l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT107H Register bits
    namespace gfxmmu_lut107h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT108L Register bits
    namespace gfxmmu_lut108l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT108H Register bits
    namespace gfxmmu_lut108h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT109L Register bits
    namespace gfxmmu_lut109l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT109H Register bits
    namespace gfxmmu_lut109h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT110L Register bits
    namespace gfxmmu_lut110l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT110H Register bits
    namespace gfxmmu_lut110h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT111L Register bits
    namespace gfxmmu_lut111l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT111H Register bits
    namespace gfxmmu_lut111h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT112L Register bits
    namespace gfxmmu_lut112l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT112H Register bits
    namespace gfxmmu_lut112h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT113L Register bits
    namespace gfxmmu_lut113l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT113H Register bits
    namespace gfxmmu_lut113h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT114L Register bits
    namespace gfxmmu_lut114l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT114H Register bits
    namespace gfxmmu_lut114h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT115L Register bits
    namespace gfxmmu_lut115l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT115H Register bits
    namespace gfxmmu_lut115h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT116L Register bits
    namespace gfxmmu_lut116l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT116H Register bits
    namespace gfxmmu_lut116h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT117L Register bits
    namespace gfxmmu_lut117l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT117H Register bits
    namespace gfxmmu_lut117h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT118L Register bits
    namespace gfxmmu_lut118l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT118H Register bits
    namespace gfxmmu_lut118h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT119L Register bits
    namespace gfxmmu_lut119l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT119H Register bits
    namespace gfxmmu_lut119h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT120L Register bits
    namespace gfxmmu_lut120l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT120H Register bits
    namespace gfxmmu_lut120h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT121L Register bits
    namespace gfxmmu_lut121l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT121H Register bits
    namespace gfxmmu_lut121h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT122L Register bits
    namespace gfxmmu_lut122l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT122H Register bits
    namespace gfxmmu_lut122h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT123L Register bits
    namespace gfxmmu_lut123l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT123H Register bits
    namespace gfxmmu_lut123h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT124L Register bits
    namespace gfxmmu_lut124l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT124H Register bits
    namespace gfxmmu_lut124h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT125L Register bits
    namespace gfxmmu_lut125l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT125H Register bits
    namespace gfxmmu_lut125h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT126L Register bits
    namespace gfxmmu_lut126l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT126H Register bits
    namespace gfxmmu_lut126h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT127L Register bits
    namespace gfxmmu_lut127l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT127H Register bits
    namespace gfxmmu_lut127h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT128L Register bits
    namespace gfxmmu_lut128l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT128H Register bits
    namespace gfxmmu_lut128h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT129L Register bits
    namespace gfxmmu_lut129l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT129H Register bits
    namespace gfxmmu_lut129h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT130L Register bits
    namespace gfxmmu_lut130l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT130H Register bits
    namespace gfxmmu_lut130h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT131L Register bits
    namespace gfxmmu_lut131l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT131H Register bits
    namespace gfxmmu_lut131h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT132L Register bits
    namespace gfxmmu_lut132l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT132H Register bits
    namespace gfxmmu_lut132h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT133L Register bits
    namespace gfxmmu_lut133l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT133H Register bits
    namespace gfxmmu_lut133h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT134L Register bits
    namespace gfxmmu_lut134l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT134H Register bits
    namespace gfxmmu_lut134h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT135L Register bits
    namespace gfxmmu_lut135l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT135H Register bits
    namespace gfxmmu_lut135h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT136L Register bits
    namespace gfxmmu_lut136l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT136H Register bits
    namespace gfxmmu_lut136h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT137L Register bits
    namespace gfxmmu_lut137l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT137H Register bits
    namespace gfxmmu_lut137h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT138L Register bits
    namespace gfxmmu_lut138l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT138H Register bits
    namespace gfxmmu_lut138h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT139L Register bits
    namespace gfxmmu_lut139l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT139H Register bits
    namespace gfxmmu_lut139h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT140L Register bits
    namespace gfxmmu_lut140l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT140H Register bits
    namespace gfxmmu_lut140h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT141L Register bits
    namespace gfxmmu_lut141l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT141H Register bits
    namespace gfxmmu_lut141h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT142L Register bits
    namespace gfxmmu_lut142l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT142H Register bits
    namespace gfxmmu_lut142h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT143L Register bits
    namespace gfxmmu_lut143l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT143H Register bits
    namespace gfxmmu_lut143h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT144L Register bits
    namespace gfxmmu_lut144l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT144H Register bits
    namespace gfxmmu_lut144h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT145L Register bits
    namespace gfxmmu_lut145l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT145H Register bits
    namespace gfxmmu_lut145h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT146L Register bits
    namespace gfxmmu_lut146l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT146H Register bits
    namespace gfxmmu_lut146h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT147L Register bits
    namespace gfxmmu_lut147l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT147H Register bits
    namespace gfxmmu_lut147h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT148L Register bits
    namespace gfxmmu_lut148l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT148H Register bits
    namespace gfxmmu_lut148h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT149L Register bits
    namespace gfxmmu_lut149l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT149H Register bits
    namespace gfxmmu_lut149h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT150L Register bits
    namespace gfxmmu_lut150l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT150H Register bits
    namespace gfxmmu_lut150h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT151L Register bits
    namespace gfxmmu_lut151l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT151H Register bits
    namespace gfxmmu_lut151h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT152L Register bits
    namespace gfxmmu_lut152l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT152H Register bits
    namespace gfxmmu_lut152h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT153L Register bits
    namespace gfxmmu_lut153l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT153H Register bits
    namespace gfxmmu_lut153h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT154L Register bits
    namespace gfxmmu_lut154l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT154H Register bits
    namespace gfxmmu_lut154h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT155L Register bits
    namespace gfxmmu_lut155l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT155H Register bits
    namespace gfxmmu_lut155h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT156L Register bits
    namespace gfxmmu_lut156l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT156H Register bits
    namespace gfxmmu_lut156h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT157L Register bits
    namespace gfxmmu_lut157l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT157H Register bits
    namespace gfxmmu_lut157h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT158L Register bits
    namespace gfxmmu_lut158l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT158H Register bits
    namespace gfxmmu_lut158h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT159L Register bits
    namespace gfxmmu_lut159l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT159H Register bits
    namespace gfxmmu_lut159h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT160L Register bits
    namespace gfxmmu_lut160l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT160H Register bits
    namespace gfxmmu_lut160h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT161L Register bits
    namespace gfxmmu_lut161l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT161H Register bits
    namespace gfxmmu_lut161h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT162L Register bits
    namespace gfxmmu_lut162l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT162H Register bits
    namespace gfxmmu_lut162h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT163L Register bits
    namespace gfxmmu_lut163l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT163H Register bits
    namespace gfxmmu_lut163h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT164L Register bits
    namespace gfxmmu_lut164l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT164H Register bits
    namespace gfxmmu_lut164h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT165L Register bits
    namespace gfxmmu_lut165l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT165H Register bits
    namespace gfxmmu_lut165h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT166L Register bits
    namespace gfxmmu_lut166l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT166H Register bits
    namespace gfxmmu_lut166h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT167L Register bits
    namespace gfxmmu_lut167l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT167H Register bits
    namespace gfxmmu_lut167h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT168L Register bits
    namespace gfxmmu_lut168l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT168H Register bits
    namespace gfxmmu_lut168h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT169L Register bits
    namespace gfxmmu_lut169l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT169H Register bits
    namespace gfxmmu_lut169h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT170L Register bits
    namespace gfxmmu_lut170l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT170H Register bits
    namespace gfxmmu_lut170h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT171L Register bits
    namespace gfxmmu_lut171l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT171H Register bits
    namespace gfxmmu_lut171h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT172L Register bits
    namespace gfxmmu_lut172l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT172H Register bits
    namespace gfxmmu_lut172h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT173L Register bits
    namespace gfxmmu_lut173l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT173H Register bits
    namespace gfxmmu_lut173h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT174L Register bits
    namespace gfxmmu_lut174l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT174H Register bits
    namespace gfxmmu_lut174h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT175L Register bits
    namespace gfxmmu_lut175l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT175H Register bits
    namespace gfxmmu_lut175h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT176L Register bits
    namespace gfxmmu_lut176l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT176H Register bits
    namespace gfxmmu_lut176h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT177L Register bits
    namespace gfxmmu_lut177l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT177H Register bits
    namespace gfxmmu_lut177h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT178L Register bits
    namespace gfxmmu_lut178l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT178H Register bits
    namespace gfxmmu_lut178h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT179L Register bits
    namespace gfxmmu_lut179l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT179H Register bits
    namespace gfxmmu_lut179h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT180L Register bits
    namespace gfxmmu_lut180l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT180H Register bits
    namespace gfxmmu_lut180h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT181L Register bits
    namespace gfxmmu_lut181l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT181H Register bits
    namespace gfxmmu_lut181h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT182L Register bits
    namespace gfxmmu_lut182l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT182H Register bits
    namespace gfxmmu_lut182h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT183L Register bits
    namespace gfxmmu_lut183l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT183H Register bits
    namespace gfxmmu_lut183h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT184L Register bits
    namespace gfxmmu_lut184l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT184H Register bits
    namespace gfxmmu_lut184h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT185L Register bits
    namespace gfxmmu_lut185l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT185H Register bits
    namespace gfxmmu_lut185h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT186L Register bits
    namespace gfxmmu_lut186l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT186H Register bits
    namespace gfxmmu_lut186h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT187L Register bits
    namespace gfxmmu_lut187l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT187H Register bits
    namespace gfxmmu_lut187h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT188L Register bits
    namespace gfxmmu_lut188l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT188H Register bits
    namespace gfxmmu_lut188h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT189L Register bits
    namespace gfxmmu_lut189l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT189H Register bits
    namespace gfxmmu_lut189h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT190L Register bits
    namespace gfxmmu_lut190l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT190H Register bits
    namespace gfxmmu_lut190h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT191L Register bits
    namespace gfxmmu_lut191l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT191H Register bits
    namespace gfxmmu_lut191h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT192L Register bits
    namespace gfxmmu_lut192l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT192H Register bits
    namespace gfxmmu_lut192h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT193L Register bits
    namespace gfxmmu_lut193l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT193H Register bits
    namespace gfxmmu_lut193h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT194L Register bits
    namespace gfxmmu_lut194l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT194H Register bits
    namespace gfxmmu_lut194h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT195L Register bits
    namespace gfxmmu_lut195l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT195H Register bits
    namespace gfxmmu_lut195h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT196L Register bits
    namespace gfxmmu_lut196l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT196H Register bits
    namespace gfxmmu_lut196h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT197L Register bits
    namespace gfxmmu_lut197l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT197H Register bits
    namespace gfxmmu_lut197h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT198L Register bits
    namespace gfxmmu_lut198l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT198H Register bits
    namespace gfxmmu_lut198h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT199L Register bits
    namespace gfxmmu_lut199l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT199H Register bits
    namespace gfxmmu_lut199h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT200L Register bits
    namespace gfxmmu_lut200l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT200H Register bits
    namespace gfxmmu_lut200h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT201L Register bits
    namespace gfxmmu_lut201l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT201H Register bits
    namespace gfxmmu_lut201h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT202L Register bits
    namespace gfxmmu_lut202l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT202H Register bits
    namespace gfxmmu_lut202h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT203L Register bits
    namespace gfxmmu_lut203l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT203H Register bits
    namespace gfxmmu_lut203h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT204L Register bits
    namespace gfxmmu_lut204l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT204H Register bits
    namespace gfxmmu_lut204h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT205L Register bits
    namespace gfxmmu_lut205l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT205H Register bits
    namespace gfxmmu_lut205h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT206L Register bits
    namespace gfxmmu_lut206l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT206H Register bits
    namespace gfxmmu_lut206h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT207L Register bits
    namespace gfxmmu_lut207l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT207H Register bits
    namespace gfxmmu_lut207h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT208L Register bits
    namespace gfxmmu_lut208l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT208H Register bits
    namespace gfxmmu_lut208h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT209L Register bits
    namespace gfxmmu_lut209l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT209H Register bits
    namespace gfxmmu_lut209h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT210L Register bits
    namespace gfxmmu_lut210l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT210H Register bits
    namespace gfxmmu_lut210h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT211L Register bits
    namespace gfxmmu_lut211l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT211H Register bits
    namespace gfxmmu_lut211h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT212L Register bits
    namespace gfxmmu_lut212l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT212H Register bits
    namespace gfxmmu_lut212h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT213L Register bits
    namespace gfxmmu_lut213l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT213H Register bits
    namespace gfxmmu_lut213h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT214L Register bits
    namespace gfxmmu_lut214l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT214H Register bits
    namespace gfxmmu_lut214h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT215L Register bits
    namespace gfxmmu_lut215l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT215H Register bits
    namespace gfxmmu_lut215h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT216L Register bits
    namespace gfxmmu_lut216l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT216H Register bits
    namespace gfxmmu_lut216h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT217L Register bits
    namespace gfxmmu_lut217l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT217H Register bits
    namespace gfxmmu_lut217h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT218L Register bits
    namespace gfxmmu_lut218l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT218H Register bits
    namespace gfxmmu_lut218h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT219L Register bits
    namespace gfxmmu_lut219l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT219H Register bits
    namespace gfxmmu_lut219h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT220L Register bits
    namespace gfxmmu_lut220l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT220H Register bits
    namespace gfxmmu_lut220h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT221L Register bits
    namespace gfxmmu_lut221l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT221H Register bits
    namespace gfxmmu_lut221h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT222L Register bits
    namespace gfxmmu_lut222l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT222H Register bits
    namespace gfxmmu_lut222h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT223L Register bits
    namespace gfxmmu_lut223l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT223H Register bits
    namespace gfxmmu_lut223h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT224L Register bits
    namespace gfxmmu_lut224l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT224H Register bits
    namespace gfxmmu_lut224h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT225L Register bits
    namespace gfxmmu_lut225l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT225H Register bits
    namespace gfxmmu_lut225h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT226L Register bits
    namespace gfxmmu_lut226l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT226H Register bits
    namespace gfxmmu_lut226h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT227L Register bits
    namespace gfxmmu_lut227l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT227H Register bits
    namespace gfxmmu_lut227h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT228L Register bits
    namespace gfxmmu_lut228l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT228H Register bits
    namespace gfxmmu_lut228h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT229L Register bits
    namespace gfxmmu_lut229l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT229H Register bits
    namespace gfxmmu_lut229h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT230L Register bits
    namespace gfxmmu_lut230l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT230H Register bits
    namespace gfxmmu_lut230h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT231L Register bits
    namespace gfxmmu_lut231l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT231H Register bits
    namespace gfxmmu_lut231h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT232L Register bits
    namespace gfxmmu_lut232l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT232H Register bits
    namespace gfxmmu_lut232h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT233L Register bits
    namespace gfxmmu_lut233l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT233H Register bits
    namespace gfxmmu_lut233h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT234L Register bits
    namespace gfxmmu_lut234l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT234H Register bits
    namespace gfxmmu_lut234h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT235L Register bits
    namespace gfxmmu_lut235l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT235H Register bits
    namespace gfxmmu_lut235h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT236L Register bits
    namespace gfxmmu_lut236l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT236H Register bits
    namespace gfxmmu_lut236h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT237L Register bits
    namespace gfxmmu_lut237l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT237H Register bits
    namespace gfxmmu_lut237h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT238L Register bits
    namespace gfxmmu_lut238l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT238H Register bits
    namespace gfxmmu_lut238h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT239L Register bits
    namespace gfxmmu_lut239l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT239H Register bits
    namespace gfxmmu_lut239h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT240L Register bits
    namespace gfxmmu_lut240l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT240H Register bits
    namespace gfxmmu_lut240h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT241L Register bits
    namespace gfxmmu_lut241l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT241H Register bits
    namespace gfxmmu_lut241h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT242L Register bits
    namespace gfxmmu_lut242l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT242H Register bits
    namespace gfxmmu_lut242h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT243L Register bits
    namespace gfxmmu_lut243l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT243H Register bits
    namespace gfxmmu_lut243h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT244L Register bits
    namespace gfxmmu_lut244l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT244H Register bits
    namespace gfxmmu_lut244h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT245L Register bits
    namespace gfxmmu_lut245l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT245H Register bits
    namespace gfxmmu_lut245h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT246L Register bits
    namespace gfxmmu_lut246l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT246H Register bits
    namespace gfxmmu_lut246h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT247L Register bits
    namespace gfxmmu_lut247l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT247H Register bits
    namespace gfxmmu_lut247h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT248L Register bits
    namespace gfxmmu_lut248l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT248H Register bits
    namespace gfxmmu_lut248h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT249L Register bits
    namespace gfxmmu_lut249l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT249H Register bits
    namespace gfxmmu_lut249h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT250L Register bits
    namespace gfxmmu_lut250l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT250H Register bits
    namespace gfxmmu_lut250h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT251L Register bits
    namespace gfxmmu_lut251l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT251H Register bits
    namespace gfxmmu_lut251h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT252L Register bits
    namespace gfxmmu_lut252l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT252H Register bits
    namespace gfxmmu_lut252h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT253L Register bits
    namespace gfxmmu_lut253l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT253H Register bits
    namespace gfxmmu_lut253h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT254L Register bits
    namespace gfxmmu_lut254l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT254H Register bits
    namespace gfxmmu_lut254h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT255L Register bits
    namespace gfxmmu_lut255l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT255H Register bits
    namespace gfxmmu_lut255h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT256L Register bits
    namespace gfxmmu_lut256l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT256H Register bits
    namespace gfxmmu_lut256h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT257L Register bits
    namespace gfxmmu_lut257l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT257H Register bits
    namespace gfxmmu_lut257h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT258L Register bits
    namespace gfxmmu_lut258l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT258H Register bits
    namespace gfxmmu_lut258h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT259L Register bits
    namespace gfxmmu_lut259l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT259H Register bits
    namespace gfxmmu_lut259h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT260L Register bits
    namespace gfxmmu_lut260l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT260H Register bits
    namespace gfxmmu_lut260h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT261L Register bits
    namespace gfxmmu_lut261l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT261H Register bits
    namespace gfxmmu_lut261h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT262L Register bits
    namespace gfxmmu_lut262l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT262H Register bits
    namespace gfxmmu_lut262h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT263L Register bits
    namespace gfxmmu_lut263l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT263H Register bits
    namespace gfxmmu_lut263h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT264L Register bits
    namespace gfxmmu_lut264l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT264H Register bits
    namespace gfxmmu_lut264h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT265L Register bits
    namespace gfxmmu_lut265l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT265H Register bits
    namespace gfxmmu_lut265h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT266L Register bits
    namespace gfxmmu_lut266l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT266H Register bits
    namespace gfxmmu_lut266h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT267L Register bits
    namespace gfxmmu_lut267l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT267H Register bits
    namespace gfxmmu_lut267h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT268L Register bits
    namespace gfxmmu_lut268l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT268H Register bits
    namespace gfxmmu_lut268h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT269L Register bits
    namespace gfxmmu_lut269l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT269H Register bits
    namespace gfxmmu_lut269h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT270L Register bits
    namespace gfxmmu_lut270l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT270H Register bits
    namespace gfxmmu_lut270h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT271L Register bits
    namespace gfxmmu_lut271l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT271H Register bits
    namespace gfxmmu_lut271h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT272L Register bits
    namespace gfxmmu_lut272l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT272H Register bits
    namespace gfxmmu_lut272h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT273L Register bits
    namespace gfxmmu_lut273l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT273H Register bits
    namespace gfxmmu_lut273h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT274L Register bits
    namespace gfxmmu_lut274l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT274H Register bits
    namespace gfxmmu_lut274h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT275L Register bits
    namespace gfxmmu_lut275l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT275H Register bits
    namespace gfxmmu_lut275h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT276L Register bits
    namespace gfxmmu_lut276l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT276H Register bits
    namespace gfxmmu_lut276h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT277L Register bits
    namespace gfxmmu_lut277l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT277H Register bits
    namespace gfxmmu_lut277h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT278L Register bits
    namespace gfxmmu_lut278l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT278H Register bits
    namespace gfxmmu_lut278h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT279L Register bits
    namespace gfxmmu_lut279l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT279H Register bits
    namespace gfxmmu_lut279h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT280L Register bits
    namespace gfxmmu_lut280l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT280H Register bits
    namespace gfxmmu_lut280h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT281L Register bits
    namespace gfxmmu_lut281l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT281H Register bits
    namespace gfxmmu_lut281h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT282L Register bits
    namespace gfxmmu_lut282l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT282H Register bits
    namespace gfxmmu_lut282h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT283L Register bits
    namespace gfxmmu_lut283l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT283H Register bits
    namespace gfxmmu_lut283h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT284L Register bits
    namespace gfxmmu_lut284l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT284H Register bits
    namespace gfxmmu_lut284h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT285L Register bits
    namespace gfxmmu_lut285l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT285H Register bits
    namespace gfxmmu_lut285h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT286L Register bits
    namespace gfxmmu_lut286l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT286H Register bits
    namespace gfxmmu_lut286h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT287L Register bits
    namespace gfxmmu_lut287l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT287H Register bits
    namespace gfxmmu_lut287h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT288L Register bits
    namespace gfxmmu_lut288l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT288H Register bits
    namespace gfxmmu_lut288h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT289L Register bits
    namespace gfxmmu_lut289l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT289H Register bits
    namespace gfxmmu_lut289h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT290L Register bits
    namespace gfxmmu_lut290l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT290H Register bits
    namespace gfxmmu_lut290h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT291L Register bits
    namespace gfxmmu_lut291l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT291H Register bits
    namespace gfxmmu_lut291h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT292L Register bits
    namespace gfxmmu_lut292l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT292H Register bits
    namespace gfxmmu_lut292h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT293L Register bits
    namespace gfxmmu_lut293l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT293H Register bits
    namespace gfxmmu_lut293h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT294L Register bits
    namespace gfxmmu_lut294l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT294H Register bits
    namespace gfxmmu_lut294h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT295L Register bits
    namespace gfxmmu_lut295l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT295H Register bits
    namespace gfxmmu_lut295h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT296L Register bits
    namespace gfxmmu_lut296l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT296H Register bits
    namespace gfxmmu_lut296h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT297L Register bits
    namespace gfxmmu_lut297l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT297H Register bits
    namespace gfxmmu_lut297h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT298L Register bits
    namespace gfxmmu_lut298l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT298H Register bits
    namespace gfxmmu_lut298h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT299L Register bits
    namespace gfxmmu_lut299l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT299H Register bits
    namespace gfxmmu_lut299h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT300L Register bits
    namespace gfxmmu_lut300l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT300H Register bits
    namespace gfxmmu_lut300h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT301L Register bits
    namespace gfxmmu_lut301l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT301H Register bits
    namespace gfxmmu_lut301h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT302L Register bits
    namespace gfxmmu_lut302l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT302H Register bits
    namespace gfxmmu_lut302h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT303L Register bits
    namespace gfxmmu_lut303l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT303H Register bits
    namespace gfxmmu_lut303h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT304L Register bits
    namespace gfxmmu_lut304l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT304H Register bits
    namespace gfxmmu_lut304h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT305L Register bits
    namespace gfxmmu_lut305l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT305H Register bits
    namespace gfxmmu_lut305h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT306L Register bits
    namespace gfxmmu_lut306l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT306H Register bits
    namespace gfxmmu_lut306h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT307L Register bits
    namespace gfxmmu_lut307l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT307H Register bits
    namespace gfxmmu_lut307h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT308L Register bits
    namespace gfxmmu_lut308l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT308H Register bits
    namespace gfxmmu_lut308h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT309L Register bits
    namespace gfxmmu_lut309l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT309H Register bits
    namespace gfxmmu_lut309h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT310L Register bits
    namespace gfxmmu_lut310l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT310H Register bits
    namespace gfxmmu_lut310h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT311L Register bits
    namespace gfxmmu_lut311l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT311H Register bits
    namespace gfxmmu_lut311h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT312L Register bits
    namespace gfxmmu_lut312l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT312H Register bits
    namespace gfxmmu_lut312h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT313L Register bits
    namespace gfxmmu_lut313l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT313H Register bits
    namespace gfxmmu_lut313h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT314L Register bits
    namespace gfxmmu_lut314l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT314H Register bits
    namespace gfxmmu_lut314h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT315L Register bits
    namespace gfxmmu_lut315l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT315H Register bits
    namespace gfxmmu_lut315h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT316L Register bits
    namespace gfxmmu_lut316l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT316H Register bits
    namespace gfxmmu_lut316h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT317L Register bits
    namespace gfxmmu_lut317l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT317H Register bits
    namespace gfxmmu_lut317h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT318L Register bits
    namespace gfxmmu_lut318l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT318H Register bits
    namespace gfxmmu_lut318h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT319L Register bits
    namespace gfxmmu_lut319l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT319H Register bits
    namespace gfxmmu_lut319h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT320L Register bits
    namespace gfxmmu_lut320l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT320H Register bits
    namespace gfxmmu_lut320h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT321L Register bits
    namespace gfxmmu_lut321l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT321H Register bits
    namespace gfxmmu_lut321h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT322L Register bits
    namespace gfxmmu_lut322l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT322H Register bits
    namespace gfxmmu_lut322h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT323L Register bits
    namespace gfxmmu_lut323l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT323H Register bits
    namespace gfxmmu_lut323h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT324L Register bits
    namespace gfxmmu_lut324l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT324H Register bits
    namespace gfxmmu_lut324h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT325L Register bits
    namespace gfxmmu_lut325l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT325H Register bits
    namespace gfxmmu_lut325h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT326L Register bits
    namespace gfxmmu_lut326l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT326H Register bits
    namespace gfxmmu_lut326h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT327L Register bits
    namespace gfxmmu_lut327l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT327H Register bits
    namespace gfxmmu_lut327h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT328L Register bits
    namespace gfxmmu_lut328l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT328H Register bits
    namespace gfxmmu_lut328h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT329L Register bits
    namespace gfxmmu_lut329l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT329H Register bits
    namespace gfxmmu_lut329h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT330L Register bits
    namespace gfxmmu_lut330l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT330H Register bits
    namespace gfxmmu_lut330h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT331L Register bits
    namespace gfxmmu_lut331l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT331H Register bits
    namespace gfxmmu_lut331h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT332L Register bits
    namespace gfxmmu_lut332l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT332H Register bits
    namespace gfxmmu_lut332h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT333L Register bits
    namespace gfxmmu_lut333l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT333H Register bits
    namespace gfxmmu_lut333h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT334L Register bits
    namespace gfxmmu_lut334l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT334H Register bits
    namespace gfxmmu_lut334h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT335L Register bits
    namespace gfxmmu_lut335l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT335H Register bits
    namespace gfxmmu_lut335h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT336L Register bits
    namespace gfxmmu_lut336l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT336H Register bits
    namespace gfxmmu_lut336h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT337L Register bits
    namespace gfxmmu_lut337l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT337H Register bits
    namespace gfxmmu_lut337h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT338L Register bits
    namespace gfxmmu_lut338l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT338H Register bits
    namespace gfxmmu_lut338h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT339L Register bits
    namespace gfxmmu_lut339l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT339H Register bits
    namespace gfxmmu_lut339h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT340L Register bits
    namespace gfxmmu_lut340l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT340H Register bits
    namespace gfxmmu_lut340h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT341L Register bits
    namespace gfxmmu_lut341l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT341H Register bits
    namespace gfxmmu_lut341h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT342L Register bits
    namespace gfxmmu_lut342l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT342H Register bits
    namespace gfxmmu_lut342h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT343L Register bits
    namespace gfxmmu_lut343l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT343H Register bits
    namespace gfxmmu_lut343h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT344L Register bits
    namespace gfxmmu_lut344l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT344H Register bits
    namespace gfxmmu_lut344h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT345L Register bits
    namespace gfxmmu_lut345l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT345H Register bits
    namespace gfxmmu_lut345h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT346L Register bits
    namespace gfxmmu_lut346l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT346H Register bits
    namespace gfxmmu_lut346h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT347L Register bits
    namespace gfxmmu_lut347l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT347H Register bits
    namespace gfxmmu_lut347h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT348L Register bits
    namespace gfxmmu_lut348l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT348H Register bits
    namespace gfxmmu_lut348h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT349L Register bits
    namespace gfxmmu_lut349l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT349H Register bits
    namespace gfxmmu_lut349h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT350L Register bits
    namespace gfxmmu_lut350l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT350H Register bits
    namespace gfxmmu_lut350h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT351L Register bits
    namespace gfxmmu_lut351l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT351H Register bits
    namespace gfxmmu_lut351h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT352L Register bits
    namespace gfxmmu_lut352l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT352H Register bits
    namespace gfxmmu_lut352h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT353L Register bits
    namespace gfxmmu_lut353l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT353H Register bits
    namespace gfxmmu_lut353h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT354L Register bits
    namespace gfxmmu_lut354l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT354H Register bits
    namespace gfxmmu_lut354h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT355L Register bits
    namespace gfxmmu_lut355l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT355H Register bits
    namespace gfxmmu_lut355h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT356L Register bits
    namespace gfxmmu_lut356l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT356H Register bits
    namespace gfxmmu_lut356h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT357L Register bits
    namespace gfxmmu_lut357l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT357H Register bits
    namespace gfxmmu_lut357h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT358L Register bits
    namespace gfxmmu_lut358l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT358H Register bits
    namespace gfxmmu_lut358h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT359L Register bits
    namespace gfxmmu_lut359l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT359H Register bits
    namespace gfxmmu_lut359h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT360L Register bits
    namespace gfxmmu_lut360l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT360H Register bits
    namespace gfxmmu_lut360h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT361L Register bits
    namespace gfxmmu_lut361l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT361H Register bits
    namespace gfxmmu_lut361h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT362L Register bits
    namespace gfxmmu_lut362l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT362H Register bits
    namespace gfxmmu_lut362h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT363L Register bits
    namespace gfxmmu_lut363l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT363H Register bits
    namespace gfxmmu_lut363h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT364L Register bits
    namespace gfxmmu_lut364l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT364H Register bits
    namespace gfxmmu_lut364h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT365L Register bits
    namespace gfxmmu_lut365l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT365H Register bits
    namespace gfxmmu_lut365h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT366L Register bits
    namespace gfxmmu_lut366l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT366H Register bits
    namespace gfxmmu_lut366h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT367L Register bits
    namespace gfxmmu_lut367l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT367H Register bits
    namespace gfxmmu_lut367h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT368L Register bits
    namespace gfxmmu_lut368l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT368H Register bits
    namespace gfxmmu_lut368h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT369L Register bits
    namespace gfxmmu_lut369l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT369H Register bits
    namespace gfxmmu_lut369h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT370L Register bits
    namespace gfxmmu_lut370l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT370H Register bits
    namespace gfxmmu_lut370h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT371L Register bits
    namespace gfxmmu_lut371l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT371H Register bits
    namespace gfxmmu_lut371h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT372L Register bits
    namespace gfxmmu_lut372l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT372H Register bits
    namespace gfxmmu_lut372h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT373L Register bits
    namespace gfxmmu_lut373l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT373H Register bits
    namespace gfxmmu_lut373h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT374L Register bits
    namespace gfxmmu_lut374l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT374H Register bits
    namespace gfxmmu_lut374h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT375L Register bits
    namespace gfxmmu_lut375l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT375H Register bits
    namespace gfxmmu_lut375h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT376L Register bits
    namespace gfxmmu_lut376l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT376H Register bits
    namespace gfxmmu_lut376h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT377L Register bits
    namespace gfxmmu_lut377l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT377H Register bits
    namespace gfxmmu_lut377h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT378L Register bits
    namespace gfxmmu_lut378l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT378H Register bits
    namespace gfxmmu_lut378h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT379L Register bits
    namespace gfxmmu_lut379l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT379H Register bits
    namespace gfxmmu_lut379h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT380L Register bits
    namespace gfxmmu_lut380l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT380H Register bits
    namespace gfxmmu_lut380h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT381L Register bits
    namespace gfxmmu_lut381l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT381H Register bits
    namespace gfxmmu_lut381h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT382L Register bits
    namespace gfxmmu_lut382l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT382H Register bits
    namespace gfxmmu_lut382h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT383L Register bits
    namespace gfxmmu_lut383l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT383H Register bits
    namespace gfxmmu_lut383h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT384L Register bits
    namespace gfxmmu_lut384l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT384H Register bits
    namespace gfxmmu_lut384h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT385L Register bits
    namespace gfxmmu_lut385l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT385H Register bits
    namespace gfxmmu_lut385h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT386L Register bits
    namespace gfxmmu_lut386l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT386H Register bits
    namespace gfxmmu_lut386h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT387L Register bits
    namespace gfxmmu_lut387l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT387H Register bits
    namespace gfxmmu_lut387h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT388L Register bits
    namespace gfxmmu_lut388l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT388H Register bits
    namespace gfxmmu_lut388h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT389L Register bits
    namespace gfxmmu_lut389l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT389H Register bits
    namespace gfxmmu_lut389h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT390L Register bits
    namespace gfxmmu_lut390l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT390H Register bits
    namespace gfxmmu_lut390h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT391L Register bits
    namespace gfxmmu_lut391l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT391H Register bits
    namespace gfxmmu_lut391h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT392L Register bits
    namespace gfxmmu_lut392l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT392H Register bits
    namespace gfxmmu_lut392h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT393L Register bits
    namespace gfxmmu_lut393l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT393H Register bits
    namespace gfxmmu_lut393h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT394L Register bits
    namespace gfxmmu_lut394l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT394H Register bits
    namespace gfxmmu_lut394h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT395L Register bits
    namespace gfxmmu_lut395l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT395H Register bits
    namespace gfxmmu_lut395h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT396L Register bits
    namespace gfxmmu_lut396l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT396H Register bits
    namespace gfxmmu_lut396h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT397L Register bits
    namespace gfxmmu_lut397l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT397H Register bits
    namespace gfxmmu_lut397h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT398L Register bits
    namespace gfxmmu_lut398l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT398H Register bits
    namespace gfxmmu_lut398h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT399L Register bits
    namespace gfxmmu_lut399l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT399H Register bits
    namespace gfxmmu_lut399h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT400L Register bits
    namespace gfxmmu_lut400l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT400H Register bits
    namespace gfxmmu_lut400h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT401L Register bits
    namespace gfxmmu_lut401l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT401H Register bits
    namespace gfxmmu_lut401h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT402L Register bits
    namespace gfxmmu_lut402l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT402H Register bits
    namespace gfxmmu_lut402h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT403L Register bits
    namespace gfxmmu_lut403l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT403H Register bits
    namespace gfxmmu_lut403h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT404L Register bits
    namespace gfxmmu_lut404l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT404H Register bits
    namespace gfxmmu_lut404h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT405L Register bits
    namespace gfxmmu_lut405l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT405H Register bits
    namespace gfxmmu_lut405h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT406L Register bits
    namespace gfxmmu_lut406l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT406H Register bits
    namespace gfxmmu_lut406h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT407L Register bits
    namespace gfxmmu_lut407l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT407H Register bits
    namespace gfxmmu_lut407h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT408L Register bits
    namespace gfxmmu_lut408l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT408H Register bits
    namespace gfxmmu_lut408h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT409L Register bits
    namespace gfxmmu_lut409l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT409H Register bits
    namespace gfxmmu_lut409h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT410L Register bits
    namespace gfxmmu_lut410l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT410H Register bits
    namespace gfxmmu_lut410h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT411L Register bits
    namespace gfxmmu_lut411l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT411H Register bits
    namespace gfxmmu_lut411h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT412L Register bits
    namespace gfxmmu_lut412l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT412H Register bits
    namespace gfxmmu_lut412h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT413L Register bits
    namespace gfxmmu_lut413l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT413H Register bits
    namespace gfxmmu_lut413h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT414L Register bits
    namespace gfxmmu_lut414l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT414H Register bits
    namespace gfxmmu_lut414h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT415L Register bits
    namespace gfxmmu_lut415l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT415H Register bits
    namespace gfxmmu_lut415h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT416L Register bits
    namespace gfxmmu_lut416l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT416H Register bits
    namespace gfxmmu_lut416h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT417L Register bits
    namespace gfxmmu_lut417l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT417H Register bits
    namespace gfxmmu_lut417h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT418L Register bits
    namespace gfxmmu_lut418l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT418H Register bits
    namespace gfxmmu_lut418h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT419L Register bits
    namespace gfxmmu_lut419l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT419H Register bits
    namespace gfxmmu_lut419h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT420L Register bits
    namespace gfxmmu_lut420l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT420H Register bits
    namespace gfxmmu_lut420h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT421L Register bits
    namespace gfxmmu_lut421l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT421H Register bits
    namespace gfxmmu_lut421h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT422L Register bits
    namespace gfxmmu_lut422l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT422H Register bits
    namespace gfxmmu_lut422h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT423L Register bits
    namespace gfxmmu_lut423l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT423H Register bits
    namespace gfxmmu_lut423h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT424L Register bits
    namespace gfxmmu_lut424l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT424H Register bits
    namespace gfxmmu_lut424h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT425L Register bits
    namespace gfxmmu_lut425l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT425H Register bits
    namespace gfxmmu_lut425h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT426L Register bits
    namespace gfxmmu_lut426l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT426H Register bits
    namespace gfxmmu_lut426h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT427L Register bits
    namespace gfxmmu_lut427l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT427H Register bits
    namespace gfxmmu_lut427h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT428L Register bits
    namespace gfxmmu_lut428l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT428H Register bits
    namespace gfxmmu_lut428h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT429L Register bits
    namespace gfxmmu_lut429l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT429H Register bits
    namespace gfxmmu_lut429h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT430L Register bits
    namespace gfxmmu_lut430l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT430H Register bits
    namespace gfxmmu_lut430h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT431L Register bits
    namespace gfxmmu_lut431l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT431H Register bits
    namespace gfxmmu_lut431h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT432L Register bits
    namespace gfxmmu_lut432l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT432H Register bits
    namespace gfxmmu_lut432h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT433L Register bits
    namespace gfxmmu_lut433l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT433H Register bits
    namespace gfxmmu_lut433h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT434L Register bits
    namespace gfxmmu_lut434l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT434H Register bits
    namespace gfxmmu_lut434h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT435L Register bits
    namespace gfxmmu_lut435l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT435H Register bits
    namespace gfxmmu_lut435h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT436L Register bits
    namespace gfxmmu_lut436l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT436H Register bits
    namespace gfxmmu_lut436h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT437L Register bits
    namespace gfxmmu_lut437l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT437H Register bits
    namespace gfxmmu_lut437h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT438L Register bits
    namespace gfxmmu_lut438l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT438H Register bits
    namespace gfxmmu_lut438h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT439L Register bits
    namespace gfxmmu_lut439l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT439H Register bits
    namespace gfxmmu_lut439h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT440L Register bits
    namespace gfxmmu_lut440l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT440H Register bits
    namespace gfxmmu_lut440h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT441L Register bits
    namespace gfxmmu_lut441l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT441H Register bits
    namespace gfxmmu_lut441h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT442L Register bits
    namespace gfxmmu_lut442l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT442H Register bits
    namespace gfxmmu_lut442h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT443L Register bits
    namespace gfxmmu_lut443l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT443H Register bits
    namespace gfxmmu_lut443h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT444L Register bits
    namespace gfxmmu_lut444l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT444H Register bits
    namespace gfxmmu_lut444h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT445L Register bits
    namespace gfxmmu_lut445l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT445H Register bits
    namespace gfxmmu_lut445h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT446L Register bits
    namespace gfxmmu_lut446l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT446H Register bits
    namespace gfxmmu_lut446h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT447L Register bits
    namespace gfxmmu_lut447l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT447H Register bits
    namespace gfxmmu_lut447h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT448L Register bits
    namespace gfxmmu_lut448l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT448H Register bits
    namespace gfxmmu_lut448h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT449L Register bits
    namespace gfxmmu_lut449l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT449H Register bits
    namespace gfxmmu_lut449h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT450L Register bits
    namespace gfxmmu_lut450l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT450H Register bits
    namespace gfxmmu_lut450h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT451L Register bits
    namespace gfxmmu_lut451l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT451H Register bits
    namespace gfxmmu_lut451h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT452L Register bits
    namespace gfxmmu_lut452l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT452H Register bits
    namespace gfxmmu_lut452h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT453L Register bits
    namespace gfxmmu_lut453l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT453H Register bits
    namespace gfxmmu_lut453h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT454L Register bits
    namespace gfxmmu_lut454l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT454H Register bits
    namespace gfxmmu_lut454h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT455L Register bits
    namespace gfxmmu_lut455l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT455H Register bits
    namespace gfxmmu_lut455h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT456L Register bits
    namespace gfxmmu_lut456l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT456H Register bits
    namespace gfxmmu_lut456h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT457L Register bits
    namespace gfxmmu_lut457l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT457H Register bits
    namespace gfxmmu_lut457h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT458L Register bits
    namespace gfxmmu_lut458l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT458H Register bits
    namespace gfxmmu_lut458h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT459L Register bits
    namespace gfxmmu_lut459l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT459H Register bits
    namespace gfxmmu_lut459h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT460L Register bits
    namespace gfxmmu_lut460l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT460H Register bits
    namespace gfxmmu_lut460h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT461L Register bits
    namespace gfxmmu_lut461l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT461H Register bits
    namespace gfxmmu_lut461h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT462L Register bits
    namespace gfxmmu_lut462l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT462H Register bits
    namespace gfxmmu_lut462h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT463L Register bits
    namespace gfxmmu_lut463l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT463H Register bits
    namespace gfxmmu_lut463h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT464L Register bits
    namespace gfxmmu_lut464l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT464H Register bits
    namespace gfxmmu_lut464h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT465L Register bits
    namespace gfxmmu_lut465l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT465H Register bits
    namespace gfxmmu_lut465h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT466L Register bits
    namespace gfxmmu_lut466l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT466H Register bits
    namespace gfxmmu_lut466h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT467L Register bits
    namespace gfxmmu_lut467l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT467H Register bits
    namespace gfxmmu_lut467h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT468L Register bits
    namespace gfxmmu_lut468l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT468H Register bits
    namespace gfxmmu_lut468h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT469L Register bits
    namespace gfxmmu_lut469l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT469H Register bits
    namespace gfxmmu_lut469h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT470L Register bits
    namespace gfxmmu_lut470l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT470H Register bits
    namespace gfxmmu_lut470h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT471L Register bits
    namespace gfxmmu_lut471l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT471H Register bits
    namespace gfxmmu_lut471h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT472L Register bits
    namespace gfxmmu_lut472l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT472H Register bits
    namespace gfxmmu_lut472h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT473L Register bits
    namespace gfxmmu_lut473l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT473H Register bits
    namespace gfxmmu_lut473h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT474L Register bits
    namespace gfxmmu_lut474l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT474H Register bits
    namespace gfxmmu_lut474h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT475L Register bits
    namespace gfxmmu_lut475l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT475H Register bits
    namespace gfxmmu_lut475h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT476L Register bits
    namespace gfxmmu_lut476l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT476H Register bits
    namespace gfxmmu_lut476h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT477L Register bits
    namespace gfxmmu_lut477l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT477H Register bits
    namespace gfxmmu_lut477h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT478L Register bits
    namespace gfxmmu_lut478l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT478H Register bits
    namespace gfxmmu_lut478h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT479L Register bits
    namespace gfxmmu_lut479l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT479H Register bits
    namespace gfxmmu_lut479h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT480L Register bits
    namespace gfxmmu_lut480l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT480H Register bits
    namespace gfxmmu_lut480h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT481L Register bits
    namespace gfxmmu_lut481l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT481H Register bits
    namespace gfxmmu_lut481h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT482L Register bits
    namespace gfxmmu_lut482l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT482H Register bits
    namespace gfxmmu_lut482h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT483L Register bits
    namespace gfxmmu_lut483l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT483H Register bits
    namespace gfxmmu_lut483h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT484L Register bits
    namespace gfxmmu_lut484l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT484H Register bits
    namespace gfxmmu_lut484h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT485L Register bits
    namespace gfxmmu_lut485l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT485H Register bits
    namespace gfxmmu_lut485h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT486L Register bits
    namespace gfxmmu_lut486l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT486H Register bits
    namespace gfxmmu_lut486h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT487L Register bits
    namespace gfxmmu_lut487l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT487H Register bits
    namespace gfxmmu_lut487h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT488L Register bits
    namespace gfxmmu_lut488l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT488H Register bits
    namespace gfxmmu_lut488h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT489L Register bits
    namespace gfxmmu_lut489l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT489H Register bits
    namespace gfxmmu_lut489h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT490L Register bits
    namespace gfxmmu_lut490l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT490H Register bits
    namespace gfxmmu_lut490h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT491L Register bits
    namespace gfxmmu_lut491l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT491H Register bits
    namespace gfxmmu_lut491h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT492L Register bits
    namespace gfxmmu_lut492l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT492H Register bits
    namespace gfxmmu_lut492h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT493L Register bits
    namespace gfxmmu_lut493l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT493H Register bits
    namespace gfxmmu_lut493h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT494L Register bits
    namespace gfxmmu_lut494l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT494H Register bits
    namespace gfxmmu_lut494h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT495L Register bits
    namespace gfxmmu_lut495l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT495H Register bits
    namespace gfxmmu_lut495h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT496L Register bits
    namespace gfxmmu_lut496l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT496H Register bits
    namespace gfxmmu_lut496h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT497L Register bits
    namespace gfxmmu_lut497l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT497H Register bits
    namespace gfxmmu_lut497h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT498L Register bits
    namespace gfxmmu_lut498l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT498H Register bits
    namespace gfxmmu_lut498h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT499L Register bits
    namespace gfxmmu_lut499l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT499H Register bits
    namespace gfxmmu_lut499h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT500L Register bits
    namespace gfxmmu_lut500l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT500H Register bits
    namespace gfxmmu_lut500h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT501L Register bits
    namespace gfxmmu_lut501l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT501H Register bits
    namespace gfxmmu_lut501h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT502L Register bits
    namespace gfxmmu_lut502l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT502H Register bits
    namespace gfxmmu_lut502h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT503L Register bits
    namespace gfxmmu_lut503l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT503H Register bits
    namespace gfxmmu_lut503h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT504L Register bits
    namespace gfxmmu_lut504l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT504H Register bits
    namespace gfxmmu_lut504h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT505L Register bits
    namespace gfxmmu_lut505l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT505H Register bits
    namespace gfxmmu_lut505h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT506L Register bits
    namespace gfxmmu_lut506l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT506H Register bits
    namespace gfxmmu_lut506h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT507L Register bits
    namespace gfxmmu_lut507l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT507H Register bits
    namespace gfxmmu_lut507h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT508L Register bits
    namespace gfxmmu_lut508l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT508H Register bits
    namespace gfxmmu_lut508h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT509L Register bits
    namespace gfxmmu_lut509l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT509H Register bits
    namespace gfxmmu_lut509h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT510L Register bits
    namespace gfxmmu_lut510l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT510H Register bits
    namespace gfxmmu_lut510h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT511L Register bits
    namespace gfxmmu_lut511l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT511H Register bits
    namespace gfxmmu_lut511h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT512L Register bits
    namespace gfxmmu_lut512l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT512H Register bits
    namespace gfxmmu_lut512h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT513L Register bits
    namespace gfxmmu_lut513l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT513H Register bits
    namespace gfxmmu_lut513h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT514L Register bits
    namespace gfxmmu_lut514l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT514H Register bits
    namespace gfxmmu_lut514h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT515L Register bits
    namespace gfxmmu_lut515l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT515H Register bits
    namespace gfxmmu_lut515h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT516L Register bits
    namespace gfxmmu_lut516l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT516H Register bits
    namespace gfxmmu_lut516h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT517L Register bits
    namespace gfxmmu_lut517l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT517H Register bits
    namespace gfxmmu_lut517h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT518L Register bits
    namespace gfxmmu_lut518l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT518H Register bits
    namespace gfxmmu_lut518h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT519L Register bits
    namespace gfxmmu_lut519l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT519H Register bits
    namespace gfxmmu_lut519h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT520L Register bits
    namespace gfxmmu_lut520l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT520H Register bits
    namespace gfxmmu_lut520h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT521L Register bits
    namespace gfxmmu_lut521l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT521H Register bits
    namespace gfxmmu_lut521h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT522L Register bits
    namespace gfxmmu_lut522l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT522H Register bits
    namespace gfxmmu_lut522h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT523L Register bits
    namespace gfxmmu_lut523l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT523H Register bits
    namespace gfxmmu_lut523h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT524L Register bits
    namespace gfxmmu_lut524l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT524H Register bits
    namespace gfxmmu_lut524h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT525L Register bits
    namespace gfxmmu_lut525l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT525H Register bits
    namespace gfxmmu_lut525h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT526L Register bits
    namespace gfxmmu_lut526l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT526H Register bits
    namespace gfxmmu_lut526h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT527L Register bits
    namespace gfxmmu_lut527l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT527H Register bits
    namespace gfxmmu_lut527h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT528L Register bits
    namespace gfxmmu_lut528l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT528H Register bits
    namespace gfxmmu_lut528h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT529L Register bits
    namespace gfxmmu_lut529l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT529H Register bits
    namespace gfxmmu_lut529h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT530L Register bits
    namespace gfxmmu_lut530l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT530H Register bits
    namespace gfxmmu_lut530h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT531L Register bits
    namespace gfxmmu_lut531l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT531H Register bits
    namespace gfxmmu_lut531h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT532L Register bits
    namespace gfxmmu_lut532l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT532H Register bits
    namespace gfxmmu_lut532h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT533L Register bits
    namespace gfxmmu_lut533l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT533H Register bits
    namespace gfxmmu_lut533h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT534L Register bits
    namespace gfxmmu_lut534l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT534H Register bits
    namespace gfxmmu_lut534h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT535L Register bits
    namespace gfxmmu_lut535l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT535H Register bits
    namespace gfxmmu_lut535h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT536L Register bits
    namespace gfxmmu_lut536l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT536H Register bits
    namespace gfxmmu_lut536h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT537L Register bits
    namespace gfxmmu_lut537l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT537H Register bits
    namespace gfxmmu_lut537h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT538L Register bits
    namespace gfxmmu_lut538l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT538H Register bits
    namespace gfxmmu_lut538h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT539L Register bits
    namespace gfxmmu_lut539l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT539H Register bits
    namespace gfxmmu_lut539h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT540L Register bits
    namespace gfxmmu_lut540l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT540H Register bits
    namespace gfxmmu_lut540h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT541L Register bits
    namespace gfxmmu_lut541l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT541H Register bits
    namespace gfxmmu_lut541h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT542L Register bits
    namespace gfxmmu_lut542l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT542H Register bits
    namespace gfxmmu_lut542h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT543L Register bits
    namespace gfxmmu_lut543l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT543H Register bits
    namespace gfxmmu_lut543h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT544L Register bits
    namespace gfxmmu_lut544l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT544H Register bits
    namespace gfxmmu_lut544h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT545L Register bits
    namespace gfxmmu_lut545l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT545H Register bits
    namespace gfxmmu_lut545h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT546L Register bits
    namespace gfxmmu_lut546l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT546H Register bits
    namespace gfxmmu_lut546h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT547L Register bits
    namespace gfxmmu_lut547l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT547H Register bits
    namespace gfxmmu_lut547h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT548L Register bits
    namespace gfxmmu_lut548l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT548H Register bits
    namespace gfxmmu_lut548h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT549L Register bits
    namespace gfxmmu_lut549l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT549H Register bits
    namespace gfxmmu_lut549h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT550L Register bits
    namespace gfxmmu_lut550l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT550H Register bits
    namespace gfxmmu_lut550h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT551L Register bits
    namespace gfxmmu_lut551l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT551H Register bits
    namespace gfxmmu_lut551h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT552L Register bits
    namespace gfxmmu_lut552l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT552H Register bits
    namespace gfxmmu_lut552h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT553L Register bits
    namespace gfxmmu_lut553l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT553H Register bits
    namespace gfxmmu_lut553h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT554L Register bits
    namespace gfxmmu_lut554l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT554H Register bits
    namespace gfxmmu_lut554h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT555L Register bits
    namespace gfxmmu_lut555l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT555H Register bits
    namespace gfxmmu_lut555h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT556L Register bits
    namespace gfxmmu_lut556l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT556H Register bits
    namespace gfxmmu_lut556h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT557L Register bits
    namespace gfxmmu_lut557l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT557H Register bits
    namespace gfxmmu_lut557h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT558L Register bits
    namespace gfxmmu_lut558l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT558H Register bits
    namespace gfxmmu_lut558h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT559L Register bits
    namespace gfxmmu_lut559l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT559H Register bits
    namespace gfxmmu_lut559h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT560L Register bits
    namespace gfxmmu_lut560l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT560H Register bits
    namespace gfxmmu_lut560h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT561L Register bits
    namespace gfxmmu_lut561l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT561H Register bits
    namespace gfxmmu_lut561h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT562L Register bits
    namespace gfxmmu_lut562l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT562H Register bits
    namespace gfxmmu_lut562h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT563L Register bits
    namespace gfxmmu_lut563l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT563H Register bits
    namespace gfxmmu_lut563h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT564L Register bits
    namespace gfxmmu_lut564l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT564H Register bits
    namespace gfxmmu_lut564h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT565L Register bits
    namespace gfxmmu_lut565l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT565H Register bits
    namespace gfxmmu_lut565h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT566L Register bits
    namespace gfxmmu_lut566l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT566H Register bits
    namespace gfxmmu_lut566h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT567L Register bits
    namespace gfxmmu_lut567l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT567H Register bits
    namespace gfxmmu_lut567h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT568L Register bits
    namespace gfxmmu_lut568l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT568H Register bits
    namespace gfxmmu_lut568h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT569L Register bits
    namespace gfxmmu_lut569l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT569H Register bits
    namespace gfxmmu_lut569h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT570L Register bits
    namespace gfxmmu_lut570l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT570H Register bits
    namespace gfxmmu_lut570h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT571L Register bits
    namespace gfxmmu_lut571l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT571H Register bits
    namespace gfxmmu_lut571h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT572L Register bits
    namespace gfxmmu_lut572l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT572H Register bits
    namespace gfxmmu_lut572h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT573L Register bits
    namespace gfxmmu_lut573l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT573H Register bits
    namespace gfxmmu_lut573h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT574L Register bits
    namespace gfxmmu_lut574l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT574H Register bits
    namespace gfxmmu_lut574h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT575L Register bits
    namespace gfxmmu_lut575l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT575H Register bits
    namespace gfxmmu_lut575h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT576L Register bits
    namespace gfxmmu_lut576l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT576H Register bits
    namespace gfxmmu_lut576h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT577L Register bits
    namespace gfxmmu_lut577l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT577H Register bits
    namespace gfxmmu_lut577h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT578L Register bits
    namespace gfxmmu_lut578l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT578H Register bits
    namespace gfxmmu_lut578h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT579L Register bits
    namespace gfxmmu_lut579l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT579H Register bits
    namespace gfxmmu_lut579h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT580L Register bits
    namespace gfxmmu_lut580l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT580H Register bits
    namespace gfxmmu_lut580h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT581L Register bits
    namespace gfxmmu_lut581l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT581H Register bits
    namespace gfxmmu_lut581h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT582L Register bits
    namespace gfxmmu_lut582l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT582H Register bits
    namespace gfxmmu_lut582h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT583L Register bits
    namespace gfxmmu_lut583l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT583H Register bits
    namespace gfxmmu_lut583h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT584L Register bits
    namespace gfxmmu_lut584l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT584H Register bits
    namespace gfxmmu_lut584h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT585L Register bits
    namespace gfxmmu_lut585l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT585H Register bits
    namespace gfxmmu_lut585h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT586L Register bits
    namespace gfxmmu_lut586l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT586H Register bits
    namespace gfxmmu_lut586h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT587L Register bits
    namespace gfxmmu_lut587l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT587H Register bits
    namespace gfxmmu_lut587h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT588L Register bits
    namespace gfxmmu_lut588l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT588H Register bits
    namespace gfxmmu_lut588h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT589L Register bits
    namespace gfxmmu_lut589l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT589H Register bits
    namespace gfxmmu_lut589h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT590L Register bits
    namespace gfxmmu_lut590l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT590H Register bits
    namespace gfxmmu_lut590h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT591L Register bits
    namespace gfxmmu_lut591l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT591H Register bits
    namespace gfxmmu_lut591h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT592L Register bits
    namespace gfxmmu_lut592l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT592H Register bits
    namespace gfxmmu_lut592h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT593L Register bits
    namespace gfxmmu_lut593l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT593H Register bits
    namespace gfxmmu_lut593h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT594L Register bits
    namespace gfxmmu_lut594l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT594H Register bits
    namespace gfxmmu_lut594h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT595L Register bits
    namespace gfxmmu_lut595l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT595H Register bits
    namespace gfxmmu_lut595h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT596L Register bits
    namespace gfxmmu_lut596l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT596H Register bits
    namespace gfxmmu_lut596h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT597L Register bits
    namespace gfxmmu_lut597l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT597H Register bits
    namespace gfxmmu_lut597h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT598L Register bits
    namespace gfxmmu_lut598l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT598H Register bits
    namespace gfxmmu_lut598h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT599L Register bits
    namespace gfxmmu_lut599l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT599H Register bits
    namespace gfxmmu_lut599h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT600L Register bits
    namespace gfxmmu_lut600l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT600H Register bits
    namespace gfxmmu_lut600h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT601L Register bits
    namespace gfxmmu_lut601l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT601H Register bits
    namespace gfxmmu_lut601h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT602L Register bits
    namespace gfxmmu_lut602l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT602H Register bits
    namespace gfxmmu_lut602h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT603L Register bits
    namespace gfxmmu_lut603l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT603H Register bits
    namespace gfxmmu_lut603h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT604L Register bits
    namespace gfxmmu_lut604l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT604H Register bits
    namespace gfxmmu_lut604h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT605L Register bits
    namespace gfxmmu_lut605l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT605H Register bits
    namespace gfxmmu_lut605h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT606L Register bits
    namespace gfxmmu_lut606l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT606H Register bits
    namespace gfxmmu_lut606h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT607L Register bits
    namespace gfxmmu_lut607l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT607H Register bits
    namespace gfxmmu_lut607h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT608L Register bits
    namespace gfxmmu_lut608l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT608H Register bits
    namespace gfxmmu_lut608h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT609L Register bits
    namespace gfxmmu_lut609l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT609H Register bits
    namespace gfxmmu_lut609h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT610L Register bits
    namespace gfxmmu_lut610l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT610H Register bits
    namespace gfxmmu_lut610h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT611L Register bits
    namespace gfxmmu_lut611l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT611H Register bits
    namespace gfxmmu_lut611h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT612L Register bits
    namespace gfxmmu_lut612l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT612H Register bits
    namespace gfxmmu_lut612h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT613L Register bits
    namespace gfxmmu_lut613l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT613H Register bits
    namespace gfxmmu_lut613h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT614L Register bits
    namespace gfxmmu_lut614l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT614H Register bits
    namespace gfxmmu_lut614h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT615L Register bits
    namespace gfxmmu_lut615l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT615H Register bits
    namespace gfxmmu_lut615h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT616L Register bits
    namespace gfxmmu_lut616l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT616H Register bits
    namespace gfxmmu_lut616h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT617L Register bits
    namespace gfxmmu_lut617l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT617H Register bits
    namespace gfxmmu_lut617h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT618L Register bits
    namespace gfxmmu_lut618l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT618H Register bits
    namespace gfxmmu_lut618h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT619L Register bits
    namespace gfxmmu_lut619l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT619H Register bits
    namespace gfxmmu_lut619h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT620L Register bits
    namespace gfxmmu_lut620l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT620H Register bits
    namespace gfxmmu_lut620h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT621L Register bits
    namespace gfxmmu_lut621l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT621H Register bits
    namespace gfxmmu_lut621h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT622L Register bits
    namespace gfxmmu_lut622l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT622H Register bits
    namespace gfxmmu_lut622h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT623L Register bits
    namespace gfxmmu_lut623l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT623H Register bits
    namespace gfxmmu_lut623h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT624L Register bits
    namespace gfxmmu_lut624l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT624H Register bits
    namespace gfxmmu_lut624h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT625L Register bits
    namespace gfxmmu_lut625l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT625H Register bits
    namespace gfxmmu_lut625h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT626L Register bits
    namespace gfxmmu_lut626l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT626H Register bits
    namespace gfxmmu_lut626h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT627L Register bits
    namespace gfxmmu_lut627l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT627H Register bits
    namespace gfxmmu_lut627h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT628L Register bits
    namespace gfxmmu_lut628l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT628H Register bits
    namespace gfxmmu_lut628h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT629L Register bits
    namespace gfxmmu_lut629l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT629H Register bits
    namespace gfxmmu_lut629h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT630L Register bits
    namespace gfxmmu_lut630l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT630H Register bits
    namespace gfxmmu_lut630h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT631L Register bits
    namespace gfxmmu_lut631l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT631H Register bits
    namespace gfxmmu_lut631h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT632L Register bits
    namespace gfxmmu_lut632l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT632H Register bits
    namespace gfxmmu_lut632h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT633L Register bits
    namespace gfxmmu_lut633l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT633H Register bits
    namespace gfxmmu_lut633h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT634L Register bits
    namespace gfxmmu_lut634l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT634H Register bits
    namespace gfxmmu_lut634h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT635L Register bits
    namespace gfxmmu_lut635l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT635H Register bits
    namespace gfxmmu_lut635h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT636L Register bits
    namespace gfxmmu_lut636l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT636H Register bits
    namespace gfxmmu_lut636h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT637L Register bits
    namespace gfxmmu_lut637l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT637H Register bits
    namespace gfxmmu_lut637h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT638L Register bits
    namespace gfxmmu_lut638l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT638H Register bits
    namespace gfxmmu_lut638h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT639L Register bits
    namespace gfxmmu_lut639l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT639H Register bits
    namespace gfxmmu_lut639h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT640L Register bits
    namespace gfxmmu_lut640l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT640H Register bits
    namespace gfxmmu_lut640h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT641L Register bits
    namespace gfxmmu_lut641l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT641H Register bits
    namespace gfxmmu_lut641h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT642L Register bits
    namespace gfxmmu_lut642l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT642H Register bits
    namespace gfxmmu_lut642h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT643L Register bits
    namespace gfxmmu_lut643l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT643H Register bits
    namespace gfxmmu_lut643h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT644L Register bits
    namespace gfxmmu_lut644l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT644H Register bits
    namespace gfxmmu_lut644h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT645L Register bits
    namespace gfxmmu_lut645l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT645H Register bits
    namespace gfxmmu_lut645h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT646L Register bits
    namespace gfxmmu_lut646l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT646H Register bits
    namespace gfxmmu_lut646h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT647L Register bits
    namespace gfxmmu_lut647l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT647H Register bits
    namespace gfxmmu_lut647h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT648L Register bits
    namespace gfxmmu_lut648l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT648H Register bits
    namespace gfxmmu_lut648h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT649L Register bits
    namespace gfxmmu_lut649l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT649H Register bits
    namespace gfxmmu_lut649h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT650L Register bits
    namespace gfxmmu_lut650l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT650H Register bits
    namespace gfxmmu_lut650h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT651L Register bits
    namespace gfxmmu_lut651l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT651H Register bits
    namespace gfxmmu_lut651h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT652L Register bits
    namespace gfxmmu_lut652l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT652H Register bits
    namespace gfxmmu_lut652h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT653L Register bits
    namespace gfxmmu_lut653l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT653H Register bits
    namespace gfxmmu_lut653h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT654L Register bits
    namespace gfxmmu_lut654l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT654H Register bits
    namespace gfxmmu_lut654h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT655L Register bits
    namespace gfxmmu_lut655l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT655H Register bits
    namespace gfxmmu_lut655h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT656L Register bits
    namespace gfxmmu_lut656l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT656H Register bits
    namespace gfxmmu_lut656h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT657L Register bits
    namespace gfxmmu_lut657l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT657H Register bits
    namespace gfxmmu_lut657h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT658L Register bits
    namespace gfxmmu_lut658l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT658H Register bits
    namespace gfxmmu_lut658h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT659L Register bits
    namespace gfxmmu_lut659l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT659H Register bits
    namespace gfxmmu_lut659h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT660L Register bits
    namespace gfxmmu_lut660l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT660H Register bits
    namespace gfxmmu_lut660h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT661L Register bits
    namespace gfxmmu_lut661l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT661H Register bits
    namespace gfxmmu_lut661h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT662L Register bits
    namespace gfxmmu_lut662l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT662H Register bits
    namespace gfxmmu_lut662h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT663L Register bits
    namespace gfxmmu_lut663l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT663H Register bits
    namespace gfxmmu_lut663h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT664L Register bits
    namespace gfxmmu_lut664l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT664H Register bits
    namespace gfxmmu_lut664h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT665L Register bits
    namespace gfxmmu_lut665l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT665H Register bits
    namespace gfxmmu_lut665h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT666L Register bits
    namespace gfxmmu_lut666l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT666H Register bits
    namespace gfxmmu_lut666h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT667L Register bits
    namespace gfxmmu_lut667l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT667H Register bits
    namespace gfxmmu_lut667h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT668L Register bits
    namespace gfxmmu_lut668l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT668H Register bits
    namespace gfxmmu_lut668h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT669L Register bits
    namespace gfxmmu_lut669l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT669H Register bits
    namespace gfxmmu_lut669h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT670L Register bits
    namespace gfxmmu_lut670l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT670H Register bits
    namespace gfxmmu_lut670h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT671L Register bits
    namespace gfxmmu_lut671l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT671H Register bits
    namespace gfxmmu_lut671h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT672L Register bits
    namespace gfxmmu_lut672l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT672H Register bits
    namespace gfxmmu_lut672h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT673L Register bits
    namespace gfxmmu_lut673l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT673H Register bits
    namespace gfxmmu_lut673h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT674L Register bits
    namespace gfxmmu_lut674l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT674H Register bits
    namespace gfxmmu_lut674h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT675L Register bits
    namespace gfxmmu_lut675l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT675H Register bits
    namespace gfxmmu_lut675h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT676L Register bits
    namespace gfxmmu_lut676l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT676H Register bits
    namespace gfxmmu_lut676h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT677L Register bits
    namespace gfxmmu_lut677l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT677H Register bits
    namespace gfxmmu_lut677h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT678L Register bits
    namespace gfxmmu_lut678l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT678H Register bits
    namespace gfxmmu_lut678h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT679L Register bits
    namespace gfxmmu_lut679l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT679H Register bits
    namespace gfxmmu_lut679h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT680L Register bits
    namespace gfxmmu_lut680l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT680H Register bits
    namespace gfxmmu_lut680h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT681L Register bits
    namespace gfxmmu_lut681l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT681H Register bits
    namespace gfxmmu_lut681h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT682L Register bits
    namespace gfxmmu_lut682l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT682H Register bits
    namespace gfxmmu_lut682h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT683L Register bits
    namespace gfxmmu_lut683l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT683H Register bits
    namespace gfxmmu_lut683h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT684L Register bits
    namespace gfxmmu_lut684l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT684H Register bits
    namespace gfxmmu_lut684h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT685L Register bits
    namespace gfxmmu_lut685l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT685H Register bits
    namespace gfxmmu_lut685h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT686L Register bits
    namespace gfxmmu_lut686l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT686H Register bits
    namespace gfxmmu_lut686h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT687L Register bits
    namespace gfxmmu_lut687l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT687H Register bits
    namespace gfxmmu_lut687h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT688L Register bits
    namespace gfxmmu_lut688l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT688H Register bits
    namespace gfxmmu_lut688h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT689L Register bits
    namespace gfxmmu_lut689l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT689H Register bits
    namespace gfxmmu_lut689h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT690L Register bits
    namespace gfxmmu_lut690l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT690H Register bits
    namespace gfxmmu_lut690h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT691L Register bits
    namespace gfxmmu_lut691l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT691H Register bits
    namespace gfxmmu_lut691h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT692L Register bits
    namespace gfxmmu_lut692l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT692H Register bits
    namespace gfxmmu_lut692h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT693L Register bits
    namespace gfxmmu_lut693l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT693H Register bits
    namespace gfxmmu_lut693h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT694L Register bits
    namespace gfxmmu_lut694l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT694H Register bits
    namespace gfxmmu_lut694h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT695L Register bits
    namespace gfxmmu_lut695l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT695H Register bits
    namespace gfxmmu_lut695h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT696L Register bits
    namespace gfxmmu_lut696l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT696H Register bits
    namespace gfxmmu_lut696h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT697L Register bits
    namespace gfxmmu_lut697l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT697H Register bits
    namespace gfxmmu_lut697h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT698L Register bits
    namespace gfxmmu_lut698l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT698H Register bits
    namespace gfxmmu_lut698h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT699L Register bits
    namespace gfxmmu_lut699l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT699H Register bits
    namespace gfxmmu_lut699h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT700L Register bits
    namespace gfxmmu_lut700l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT700H Register bits
    namespace gfxmmu_lut700h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT701L Register bits
    namespace gfxmmu_lut701l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT701H Register bits
    namespace gfxmmu_lut701h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT702L Register bits
    namespace gfxmmu_lut702l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT702H Register bits
    namespace gfxmmu_lut702h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT703L Register bits
    namespace gfxmmu_lut703l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT703H Register bits
    namespace gfxmmu_lut703h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT704L Register bits
    namespace gfxmmu_lut704l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT704H Register bits
    namespace gfxmmu_lut704h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT705L Register bits
    namespace gfxmmu_lut705l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT705H Register bits
    namespace gfxmmu_lut705h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT706L Register bits
    namespace gfxmmu_lut706l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT706H Register bits
    namespace gfxmmu_lut706h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT707L Register bits
    namespace gfxmmu_lut707l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT707H Register bits
    namespace gfxmmu_lut707h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT708L Register bits
    namespace gfxmmu_lut708l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT708H Register bits
    namespace gfxmmu_lut708h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT709L Register bits
    namespace gfxmmu_lut709l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT709H Register bits
    namespace gfxmmu_lut709h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT710L Register bits
    namespace gfxmmu_lut710l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT710H Register bits
    namespace gfxmmu_lut710h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT711L Register bits
    namespace gfxmmu_lut711l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT711H Register bits
    namespace gfxmmu_lut711h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT712L Register bits
    namespace gfxmmu_lut712l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT712H Register bits
    namespace gfxmmu_lut712h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT713L Register bits
    namespace gfxmmu_lut713l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT713H Register bits
    namespace gfxmmu_lut713h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT714L Register bits
    namespace gfxmmu_lut714l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT714H Register bits
    namespace gfxmmu_lut714h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT715L Register bits
    namespace gfxmmu_lut715l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT715H Register bits
    namespace gfxmmu_lut715h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT716L Register bits
    namespace gfxmmu_lut716l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT716H Register bits
    namespace gfxmmu_lut716h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT717L Register bits
    namespace gfxmmu_lut717l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT717H Register bits
    namespace gfxmmu_lut717h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT718L Register bits
    namespace gfxmmu_lut718l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT718H Register bits
    namespace gfxmmu_lut718h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT719L Register bits
    namespace gfxmmu_lut719l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT719H Register bits
    namespace gfxmmu_lut719h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT720L Register bits
    namespace gfxmmu_lut720l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT720H Register bits
    namespace gfxmmu_lut720h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT721L Register bits
    namespace gfxmmu_lut721l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT721H Register bits
    namespace gfxmmu_lut721h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT722L Register bits
    namespace gfxmmu_lut722l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT722H Register bits
    namespace gfxmmu_lut722h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT723L Register bits
    namespace gfxmmu_lut723l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT723H Register bits
    namespace gfxmmu_lut723h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT724L Register bits
    namespace gfxmmu_lut724l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT724H Register bits
    namespace gfxmmu_lut724h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT725L Register bits
    namespace gfxmmu_lut725l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT725H Register bits
    namespace gfxmmu_lut725h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT726L Register bits
    namespace gfxmmu_lut726l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT726H Register bits
    namespace gfxmmu_lut726h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT727L Register bits
    namespace gfxmmu_lut727l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT727H Register bits
    namespace gfxmmu_lut727h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT728L Register bits
    namespace gfxmmu_lut728l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT728H Register bits
    namespace gfxmmu_lut728h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT729L Register bits
    namespace gfxmmu_lut729l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT729H Register bits
    namespace gfxmmu_lut729h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT730L Register bits
    namespace gfxmmu_lut730l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT730H Register bits
    namespace gfxmmu_lut730h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT731L Register bits
    namespace gfxmmu_lut731l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT731H Register bits
    namespace gfxmmu_lut731h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT732L Register bits
    namespace gfxmmu_lut732l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT732H Register bits
    namespace gfxmmu_lut732h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT733L Register bits
    namespace gfxmmu_lut733l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT733H Register bits
    namespace gfxmmu_lut733h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT734L Register bits
    namespace gfxmmu_lut734l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT734H Register bits
    namespace gfxmmu_lut734h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT735L Register bits
    namespace gfxmmu_lut735l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT735H Register bits
    namespace gfxmmu_lut735h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT736L Register bits
    namespace gfxmmu_lut736l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT736H Register bits
    namespace gfxmmu_lut736h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT737L Register bits
    namespace gfxmmu_lut737l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT737H Register bits
    namespace gfxmmu_lut737h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT738L Register bits
    namespace gfxmmu_lut738l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT738H Register bits
    namespace gfxmmu_lut738h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT739L Register bits
    namespace gfxmmu_lut739l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT739H Register bits
    namespace gfxmmu_lut739h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT740L Register bits
    namespace gfxmmu_lut740l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT740H Register bits
    namespace gfxmmu_lut740h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT741L Register bits
    namespace gfxmmu_lut741l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT741H Register bits
    namespace gfxmmu_lut741h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT742L Register bits
    namespace gfxmmu_lut742l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT742H Register bits
    namespace gfxmmu_lut742h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT743L Register bits
    namespace gfxmmu_lut743l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT743H Register bits
    namespace gfxmmu_lut743h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT744L Register bits
    namespace gfxmmu_lut744l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT744H Register bits
    namespace gfxmmu_lut744h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT745L Register bits
    namespace gfxmmu_lut745l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT745H Register bits
    namespace gfxmmu_lut745h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT746L Register bits
    namespace gfxmmu_lut746l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT746H Register bits
    namespace gfxmmu_lut746h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT747L Register bits
    namespace gfxmmu_lut747l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT747H Register bits
    namespace gfxmmu_lut747h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT748L Register bits
    namespace gfxmmu_lut748l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT748H Register bits
    namespace gfxmmu_lut748h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT749L Register bits
    namespace gfxmmu_lut749l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT749H Register bits
    namespace gfxmmu_lut749h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT750L Register bits
    namespace gfxmmu_lut750l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT750H Register bits
    namespace gfxmmu_lut750h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT751L Register bits
    namespace gfxmmu_lut751l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT751H Register bits
    namespace gfxmmu_lut751h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT752L Register bits
    namespace gfxmmu_lut752l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT752H Register bits
    namespace gfxmmu_lut752h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT753L Register bits
    namespace gfxmmu_lut753l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT753H Register bits
    namespace gfxmmu_lut753h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT754L Register bits
    namespace gfxmmu_lut754l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT754H Register bits
    namespace gfxmmu_lut754h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT755L Register bits
    namespace gfxmmu_lut755l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT755H Register bits
    namespace gfxmmu_lut755h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT756L Register bits
    namespace gfxmmu_lut756l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT756H Register bits
    namespace gfxmmu_lut756h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT757L Register bits
    namespace gfxmmu_lut757l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT757H Register bits
    namespace gfxmmu_lut757h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT758L Register bits
    namespace gfxmmu_lut758l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT758H Register bits
    namespace gfxmmu_lut758h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT759L Register bits
    namespace gfxmmu_lut759l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT759H Register bits
    namespace gfxmmu_lut759h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT760L Register bits
    namespace gfxmmu_lut760l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT760H Register bits
    namespace gfxmmu_lut760h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT761L Register bits
    namespace gfxmmu_lut761l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT761H Register bits
    namespace gfxmmu_lut761h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT762L Register bits
    namespace gfxmmu_lut762l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT762H Register bits
    namespace gfxmmu_lut762h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT763L Register bits
    namespace gfxmmu_lut763l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT763H Register bits
    namespace gfxmmu_lut763h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT764L Register bits
    namespace gfxmmu_lut764l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT764H Register bits
    namespace gfxmmu_lut764h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT765L Register bits
    namespace gfxmmu_lut765l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT765H Register bits
    namespace gfxmmu_lut765h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT766L Register bits
    namespace gfxmmu_lut766l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT766H Register bits
    namespace gfxmmu_lut766h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT767L Register bits
    namespace gfxmmu_lut767l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT767H Register bits
    namespace gfxmmu_lut767h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT768L Register bits
    namespace gfxmmu_lut768l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT768H Register bits
    namespace gfxmmu_lut768h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT769L Register bits
    namespace gfxmmu_lut769l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT769H Register bits
    namespace gfxmmu_lut769h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT770L Register bits
    namespace gfxmmu_lut770l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT770H Register bits
    namespace gfxmmu_lut770h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT771L Register bits
    namespace gfxmmu_lut771l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT771H Register bits
    namespace gfxmmu_lut771h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT772L Register bits
    namespace gfxmmu_lut772l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT772H Register bits
    namespace gfxmmu_lut772h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT773L Register bits
    namespace gfxmmu_lut773l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT773H Register bits
    namespace gfxmmu_lut773h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT774L Register bits
    namespace gfxmmu_lut774l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT774H Register bits
    namespace gfxmmu_lut774h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT775L Register bits
    namespace gfxmmu_lut775l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT775H Register bits
    namespace gfxmmu_lut775h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT776L Register bits
    namespace gfxmmu_lut776l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT776H Register bits
    namespace gfxmmu_lut776h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT777L Register bits
    namespace gfxmmu_lut777l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT777H Register bits
    namespace gfxmmu_lut777h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT778L Register bits
    namespace gfxmmu_lut778l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT778H Register bits
    namespace gfxmmu_lut778h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT779L Register bits
    namespace gfxmmu_lut779l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT779H Register bits
    namespace gfxmmu_lut779h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT780L Register bits
    namespace gfxmmu_lut780l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT780H Register bits
    namespace gfxmmu_lut780h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT781L Register bits
    namespace gfxmmu_lut781l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT781H Register bits
    namespace gfxmmu_lut781h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT782L Register bits
    namespace gfxmmu_lut782l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT782H Register bits
    namespace gfxmmu_lut782h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT783L Register bits
    namespace gfxmmu_lut783l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT783H Register bits
    namespace gfxmmu_lut783h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT784L Register bits
    namespace gfxmmu_lut784l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT784H Register bits
    namespace gfxmmu_lut784h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT785L Register bits
    namespace gfxmmu_lut785l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT785H Register bits
    namespace gfxmmu_lut785h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT786L Register bits
    namespace gfxmmu_lut786l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT786H Register bits
    namespace gfxmmu_lut786h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT787L Register bits
    namespace gfxmmu_lut787l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT787H Register bits
    namespace gfxmmu_lut787h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT788L Register bits
    namespace gfxmmu_lut788l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT788H Register bits
    namespace gfxmmu_lut788h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT789L Register bits
    namespace gfxmmu_lut789l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT789H Register bits
    namespace gfxmmu_lut789h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT790L Register bits
    namespace gfxmmu_lut790l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT790H Register bits
    namespace gfxmmu_lut790h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT791L Register bits
    namespace gfxmmu_lut791l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT791H Register bits
    namespace gfxmmu_lut791h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT792L Register bits
    namespace gfxmmu_lut792l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT792H Register bits
    namespace gfxmmu_lut792h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT793L Register bits
    namespace gfxmmu_lut793l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT793H Register bits
    namespace gfxmmu_lut793h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT794L Register bits
    namespace gfxmmu_lut794l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT794H Register bits
    namespace gfxmmu_lut794h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT795L Register bits
    namespace gfxmmu_lut795l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT795H Register bits
    namespace gfxmmu_lut795h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT796L Register bits
    namespace gfxmmu_lut796l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT796H Register bits
    namespace gfxmmu_lut796h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT797L Register bits
    namespace gfxmmu_lut797l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT797H Register bits
    namespace gfxmmu_lut797h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT798L Register bits
    namespace gfxmmu_lut798l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT798H Register bits
    namespace gfxmmu_lut798h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT799L Register bits
    namespace gfxmmu_lut799l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT799H Register bits
    namespace gfxmmu_lut799h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT800L Register bits
    namespace gfxmmu_lut800l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT800H Register bits
    namespace gfxmmu_lut800h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT801L Register bits
    namespace gfxmmu_lut801l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT801H Register bits
    namespace gfxmmu_lut801h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT802L Register bits
    namespace gfxmmu_lut802l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT802H Register bits
    namespace gfxmmu_lut802h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT803L Register bits
    namespace gfxmmu_lut803l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT803H Register bits
    namespace gfxmmu_lut803h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT804L Register bits
    namespace gfxmmu_lut804l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT804H Register bits
    namespace gfxmmu_lut804h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT805L Register bits
    namespace gfxmmu_lut805l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT805H Register bits
    namespace gfxmmu_lut805h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT806L Register bits
    namespace gfxmmu_lut806l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT806H Register bits
    namespace gfxmmu_lut806h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT807L Register bits
    namespace gfxmmu_lut807l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT807H Register bits
    namespace gfxmmu_lut807h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT808L Register bits
    namespace gfxmmu_lut808l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT808H Register bits
    namespace gfxmmu_lut808h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT809L Register bits
    namespace gfxmmu_lut809l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT809H Register bits
    namespace gfxmmu_lut809h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT810L Register bits
    namespace gfxmmu_lut810l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT810H Register bits
    namespace gfxmmu_lut810h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT811L Register bits
    namespace gfxmmu_lut811l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT811H Register bits
    namespace gfxmmu_lut811h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT812L Register bits
    namespace gfxmmu_lut812l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT812H Register bits
    namespace gfxmmu_lut812h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT813L Register bits
    namespace gfxmmu_lut813l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT813H Register bits
    namespace gfxmmu_lut813h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT814L Register bits
    namespace gfxmmu_lut814l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT814H Register bits
    namespace gfxmmu_lut814h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT815L Register bits
    namespace gfxmmu_lut815l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT815H Register bits
    namespace gfxmmu_lut815h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT816L Register bits
    namespace gfxmmu_lut816l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT816H Register bits
    namespace gfxmmu_lut816h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT817L Register bits
    namespace gfxmmu_lut817l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT817H Register bits
    namespace gfxmmu_lut817h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT818L Register bits
    namespace gfxmmu_lut818l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT818H Register bits
    namespace gfxmmu_lut818h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT819L Register bits
    namespace gfxmmu_lut819l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT819H Register bits
    namespace gfxmmu_lut819h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT820L Register bits
    namespace gfxmmu_lut820l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT820H Register bits
    namespace gfxmmu_lut820h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT821L Register bits
    namespace gfxmmu_lut821l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT821H Register bits
    namespace gfxmmu_lut821h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT822L Register bits
    namespace gfxmmu_lut822l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT822H Register bits
    namespace gfxmmu_lut822h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT823L Register bits
    namespace gfxmmu_lut823l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT823H Register bits
    namespace gfxmmu_lut823h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT824L Register bits
    namespace gfxmmu_lut824l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT824H Register bits
    namespace gfxmmu_lut824h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT825L Register bits
    namespace gfxmmu_lut825l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT825H Register bits
    namespace gfxmmu_lut825h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT826L Register bits
    namespace gfxmmu_lut826l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT826H Register bits
    namespace gfxmmu_lut826h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT827L Register bits
    namespace gfxmmu_lut827l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT827H Register bits
    namespace gfxmmu_lut827h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT828L Register bits
    namespace gfxmmu_lut828l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT828H Register bits
    namespace gfxmmu_lut828h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT829L Register bits
    namespace gfxmmu_lut829l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT829H Register bits
    namespace gfxmmu_lut829h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT830L Register bits
    namespace gfxmmu_lut830l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT830H Register bits
    namespace gfxmmu_lut830h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT831L Register bits
    namespace gfxmmu_lut831l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT831H Register bits
    namespace gfxmmu_lut831h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT832L Register bits
    namespace gfxmmu_lut832l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT832H Register bits
    namespace gfxmmu_lut832h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT833L Register bits
    namespace gfxmmu_lut833l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT833H Register bits
    namespace gfxmmu_lut833h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT834L Register bits
    namespace gfxmmu_lut834l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT834H Register bits
    namespace gfxmmu_lut834h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT835L Register bits
    namespace gfxmmu_lut835l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT835H Register bits
    namespace gfxmmu_lut835h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT836L Register bits
    namespace gfxmmu_lut836l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT836H Register bits
    namespace gfxmmu_lut836h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT837L Register bits
    namespace gfxmmu_lut837l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT837H Register bits
    namespace gfxmmu_lut837h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT838L Register bits
    namespace gfxmmu_lut838l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT838H Register bits
    namespace gfxmmu_lut838h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT839L Register bits
    namespace gfxmmu_lut839l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT839H Register bits
    namespace gfxmmu_lut839h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT840L Register bits
    namespace gfxmmu_lut840l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT840H Register bits
    namespace gfxmmu_lut840h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT841L Register bits
    namespace gfxmmu_lut841l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT841H Register bits
    namespace gfxmmu_lut841h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT842L Register bits
    namespace gfxmmu_lut842l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT842H Register bits
    namespace gfxmmu_lut842h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT843L Register bits
    namespace gfxmmu_lut843l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT843H Register bits
    namespace gfxmmu_lut843h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT844L Register bits
    namespace gfxmmu_lut844l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT844H Register bits
    namespace gfxmmu_lut844h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT845L Register bits
    namespace gfxmmu_lut845l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT845H Register bits
    namespace gfxmmu_lut845h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT846L Register bits
    namespace gfxmmu_lut846l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT846H Register bits
    namespace gfxmmu_lut846h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT847L Register bits
    namespace gfxmmu_lut847l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT847H Register bits
    namespace gfxmmu_lut847h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT848L Register bits
    namespace gfxmmu_lut848l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT848H Register bits
    namespace gfxmmu_lut848h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT849L Register bits
    namespace gfxmmu_lut849l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT849H Register bits
    namespace gfxmmu_lut849h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT850L Register bits
    namespace gfxmmu_lut850l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT850H Register bits
    namespace gfxmmu_lut850h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT851L Register bits
    namespace gfxmmu_lut851l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT851H Register bits
    namespace gfxmmu_lut851h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT852L Register bits
    namespace gfxmmu_lut852l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT852H Register bits
    namespace gfxmmu_lut852h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT853L Register bits
    namespace gfxmmu_lut853l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT853H Register bits
    namespace gfxmmu_lut853h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT854L Register bits
    namespace gfxmmu_lut854l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT854H Register bits
    namespace gfxmmu_lut854h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT855L Register bits
    namespace gfxmmu_lut855l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT855H Register bits
    namespace gfxmmu_lut855h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT856L Register bits
    namespace gfxmmu_lut856l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT856H Register bits
    namespace gfxmmu_lut856h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT857L Register bits
    namespace gfxmmu_lut857l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT857H Register bits
    namespace gfxmmu_lut857h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT858L Register bits
    namespace gfxmmu_lut858l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT858H Register bits
    namespace gfxmmu_lut858h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT859L Register bits
    namespace gfxmmu_lut859l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT859H Register bits
    namespace gfxmmu_lut859h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT860L Register bits
    namespace gfxmmu_lut860l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT860H Register bits
    namespace gfxmmu_lut860h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT861L Register bits
    namespace gfxmmu_lut861l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT861H Register bits
    namespace gfxmmu_lut861h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT862L Register bits
    namespace gfxmmu_lut862l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT862H Register bits
    namespace gfxmmu_lut862h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT863L Register bits
    namespace gfxmmu_lut863l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT863H Register bits
    namespace gfxmmu_lut863h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT864L Register bits
    namespace gfxmmu_lut864l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT864H Register bits
    namespace gfxmmu_lut864h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT865L Register bits
    namespace gfxmmu_lut865l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT865H Register bits
    namespace gfxmmu_lut865h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT866L Register bits
    namespace gfxmmu_lut866l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT866H Register bits
    namespace gfxmmu_lut866h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT867L Register bits
    namespace gfxmmu_lut867l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT867H Register bits
    namespace gfxmmu_lut867h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT868L Register bits
    namespace gfxmmu_lut868l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT868H Register bits
    namespace gfxmmu_lut868h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT869L Register bits
    namespace gfxmmu_lut869l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT869H Register bits
    namespace gfxmmu_lut869h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT870L Register bits
    namespace gfxmmu_lut870l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT870H Register bits
    namespace gfxmmu_lut870h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT871L Register bits
    namespace gfxmmu_lut871l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT871H Register bits
    namespace gfxmmu_lut871h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT872L Register bits
    namespace gfxmmu_lut872l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT872H Register bits
    namespace gfxmmu_lut872h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT873L Register bits
    namespace gfxmmu_lut873l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT873H Register bits
    namespace gfxmmu_lut873h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT874L Register bits
    namespace gfxmmu_lut874l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT874H Register bits
    namespace gfxmmu_lut874h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT875L Register bits
    namespace gfxmmu_lut875l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT875H Register bits
    namespace gfxmmu_lut875h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT876L Register bits
    namespace gfxmmu_lut876l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT876H Register bits
    namespace gfxmmu_lut876h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT877L Register bits
    namespace gfxmmu_lut877l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT877H Register bits
    namespace gfxmmu_lut877h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT878L Register bits
    namespace gfxmmu_lut878l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT878H Register bits
    namespace gfxmmu_lut878h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT879L Register bits
    namespace gfxmmu_lut879l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT879H Register bits
    namespace gfxmmu_lut879h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT880L Register bits
    namespace gfxmmu_lut880l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT880H Register bits
    namespace gfxmmu_lut880h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT881L Register bits
    namespace gfxmmu_lut881l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT881H Register bits
    namespace gfxmmu_lut881h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT882L Register bits
    namespace gfxmmu_lut882l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT882H Register bits
    namespace gfxmmu_lut882h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT883L Register bits
    namespace gfxmmu_lut883l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT883H Register bits
    namespace gfxmmu_lut883h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT884L Register bits
    namespace gfxmmu_lut884l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT884H Register bits
    namespace gfxmmu_lut884h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT885L Register bits
    namespace gfxmmu_lut885l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT885H Register bits
    namespace gfxmmu_lut885h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT886L Register bits
    namespace gfxmmu_lut886l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT886H Register bits
    namespace gfxmmu_lut886h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT887L Register bits
    namespace gfxmmu_lut887l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT887H Register bits
    namespace gfxmmu_lut887h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT888L Register bits
    namespace gfxmmu_lut888l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT888H Register bits
    namespace gfxmmu_lut888h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT889L Register bits
    namespace gfxmmu_lut889l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT889H Register bits
    namespace gfxmmu_lut889h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT890L Register bits
    namespace gfxmmu_lut890l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT890H Register bits
    namespace gfxmmu_lut890h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT891L Register bits
    namespace gfxmmu_lut891l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT891H Register bits
    namespace gfxmmu_lut891h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT892L Register bits
    namespace gfxmmu_lut892l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT892H Register bits
    namespace gfxmmu_lut892h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT893L Register bits
    namespace gfxmmu_lut893l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT893H Register bits
    namespace gfxmmu_lut893h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT894L Register bits
    namespace gfxmmu_lut894l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT894H Register bits
    namespace gfxmmu_lut894h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT895L Register bits
    namespace gfxmmu_lut895l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT895H Register bits
    namespace gfxmmu_lut895h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT896L Register bits
    namespace gfxmmu_lut896l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT896H Register bits
    namespace gfxmmu_lut896h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT897L Register bits
    namespace gfxmmu_lut897l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT897H Register bits
    namespace gfxmmu_lut897h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT898L Register bits
    namespace gfxmmu_lut898l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT898H Register bits
    namespace gfxmmu_lut898h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT899L Register bits
    namespace gfxmmu_lut899l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT899H Register bits
    namespace gfxmmu_lut899h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT900L Register bits
    namespace gfxmmu_lut900l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT900H Register bits
    namespace gfxmmu_lut900h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT901L Register bits
    namespace gfxmmu_lut901l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT901H Register bits
    namespace gfxmmu_lut901h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT902L Register bits
    namespace gfxmmu_lut902l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT902H Register bits
    namespace gfxmmu_lut902h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT903L Register bits
    namespace gfxmmu_lut903l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT903H Register bits
    namespace gfxmmu_lut903h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT904L Register bits
    namespace gfxmmu_lut904l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT904H Register bits
    namespace gfxmmu_lut904h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT905L Register bits
    namespace gfxmmu_lut905l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT905H Register bits
    namespace gfxmmu_lut905h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT906L Register bits
    namespace gfxmmu_lut906l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT906H Register bits
    namespace gfxmmu_lut906h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT907L Register bits
    namespace gfxmmu_lut907l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT907H Register bits
    namespace gfxmmu_lut907h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT908L Register bits
    namespace gfxmmu_lut908l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT908H Register bits
    namespace gfxmmu_lut908h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT909L Register bits
    namespace gfxmmu_lut909l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT909H Register bits
    namespace gfxmmu_lut909h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT910L Register bits
    namespace gfxmmu_lut910l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT910H Register bits
    namespace gfxmmu_lut910h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT911L Register bits
    namespace gfxmmu_lut911l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT911H Register bits
    namespace gfxmmu_lut911h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT912L Register bits
    namespace gfxmmu_lut912l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT912H Register bits
    namespace gfxmmu_lut912h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT913L Register bits
    namespace gfxmmu_lut913l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT913H Register bits
    namespace gfxmmu_lut913h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT914L Register bits
    namespace gfxmmu_lut914l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT914H Register bits
    namespace gfxmmu_lut914h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT915L Register bits
    namespace gfxmmu_lut915l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT915H Register bits
    namespace gfxmmu_lut915h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT916L Register bits
    namespace gfxmmu_lut916l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT916H Register bits
    namespace gfxmmu_lut916h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT917L Register bits
    namespace gfxmmu_lut917l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT917H Register bits
    namespace gfxmmu_lut917h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT918L Register bits
    namespace gfxmmu_lut918l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT918H Register bits
    namespace gfxmmu_lut918h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT919L Register bits
    namespace gfxmmu_lut919l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT919H Register bits
    namespace gfxmmu_lut919h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT920L Register bits
    namespace gfxmmu_lut920l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT920H Register bits
    namespace gfxmmu_lut920h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT921L Register bits
    namespace gfxmmu_lut921l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT921H Register bits
    namespace gfxmmu_lut921h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT922L Register bits
    namespace gfxmmu_lut922l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT922H Register bits
    namespace gfxmmu_lut922h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT923L Register bits
    namespace gfxmmu_lut923l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT923H Register bits
    namespace gfxmmu_lut923h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT924L Register bits
    namespace gfxmmu_lut924l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT924H Register bits
    namespace gfxmmu_lut924h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT925L Register bits
    namespace gfxmmu_lut925l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT925H Register bits
    namespace gfxmmu_lut925h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT926L Register bits
    namespace gfxmmu_lut926l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT926H Register bits
    namespace gfxmmu_lut926h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT927L Register bits
    namespace gfxmmu_lut927l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT927H Register bits
    namespace gfxmmu_lut927h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT928L Register bits
    namespace gfxmmu_lut928l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT928H Register bits
    namespace gfxmmu_lut928h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT929L Register bits
    namespace gfxmmu_lut929l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT929H Register bits
    namespace gfxmmu_lut929h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT930L Register bits
    namespace gfxmmu_lut930l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT930H Register bits
    namespace gfxmmu_lut930h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT931L Register bits
    namespace gfxmmu_lut931l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT931H Register bits
    namespace gfxmmu_lut931h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT932L Register bits
    namespace gfxmmu_lut932l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT932H Register bits
    namespace gfxmmu_lut932h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT933L Register bits
    namespace gfxmmu_lut933l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT933H Register bits
    namespace gfxmmu_lut933h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT934L Register bits
    namespace gfxmmu_lut934l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT934H Register bits
    namespace gfxmmu_lut934h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT935L Register bits
    namespace gfxmmu_lut935l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT935H Register bits
    namespace gfxmmu_lut935h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT936L Register bits
    namespace gfxmmu_lut936l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT936H Register bits
    namespace gfxmmu_lut936h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT937L Register bits
    namespace gfxmmu_lut937l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT937H Register bits
    namespace gfxmmu_lut937h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT938L Register bits
    namespace gfxmmu_lut938l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT938H Register bits
    namespace gfxmmu_lut938h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT939L Register bits
    namespace gfxmmu_lut939l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT939H Register bits
    namespace gfxmmu_lut939h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT940L Register bits
    namespace gfxmmu_lut940l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT940H Register bits
    namespace gfxmmu_lut940h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT941L Register bits
    namespace gfxmmu_lut941l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT941H Register bits
    namespace gfxmmu_lut941h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT942L Register bits
    namespace gfxmmu_lut942l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT942H Register bits
    namespace gfxmmu_lut942h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT943L Register bits
    namespace gfxmmu_lut943l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT943H Register bits
    namespace gfxmmu_lut943h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT944L Register bits
    namespace gfxmmu_lut944l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT944H Register bits
    namespace gfxmmu_lut944h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT945L Register bits
    namespace gfxmmu_lut945l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT945H Register bits
    namespace gfxmmu_lut945h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT946L Register bits
    namespace gfxmmu_lut946l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT946H Register bits
    namespace gfxmmu_lut946h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT947L Register bits
    namespace gfxmmu_lut947l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT947H Register bits
    namespace gfxmmu_lut947h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT948L Register bits
    namespace gfxmmu_lut948l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT948H Register bits
    namespace gfxmmu_lut948h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT949L Register bits
    namespace gfxmmu_lut949l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT949H Register bits
    namespace gfxmmu_lut949h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT950L Register bits
    namespace gfxmmu_lut950l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT950H Register bits
    namespace gfxmmu_lut950h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT951L Register bits
    namespace gfxmmu_lut951l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT951H Register bits
    namespace gfxmmu_lut951h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT952L Register bits
    namespace gfxmmu_lut952l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT952H Register bits
    namespace gfxmmu_lut952h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT953L Register bits
    namespace gfxmmu_lut953l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT953H Register bits
    namespace gfxmmu_lut953h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT954L Register bits
    namespace gfxmmu_lut954l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT954H Register bits
    namespace gfxmmu_lut954h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT955L Register bits
    namespace gfxmmu_lut955l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT955H Register bits
    namespace gfxmmu_lut955h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT956L Register bits
    namespace gfxmmu_lut956l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT956H Register bits
    namespace gfxmmu_lut956h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT957L Register bits
    namespace gfxmmu_lut957l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT957H Register bits
    namespace gfxmmu_lut957h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT958L Register bits
    namespace gfxmmu_lut958l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT958H Register bits
    namespace gfxmmu_lut958h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT959L Register bits
    namespace gfxmmu_lut959l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT959H Register bits
    namespace gfxmmu_lut959h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT960L Register bits
    namespace gfxmmu_lut960l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT960H Register bits
    namespace gfxmmu_lut960h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT961L Register bits
    namespace gfxmmu_lut961l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT961H Register bits
    namespace gfxmmu_lut961h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT962L Register bits
    namespace gfxmmu_lut962l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT962H Register bits
    namespace gfxmmu_lut962h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT963L Register bits
    namespace gfxmmu_lut963l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT963H Register bits
    namespace gfxmmu_lut963h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT964L Register bits
    namespace gfxmmu_lut964l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT964H Register bits
    namespace gfxmmu_lut964h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT965L Register bits
    namespace gfxmmu_lut965l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT965H Register bits
    namespace gfxmmu_lut965h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT966L Register bits
    namespace gfxmmu_lut966l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT966H Register bits
    namespace gfxmmu_lut966h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT967L Register bits
    namespace gfxmmu_lut967l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT967H Register bits
    namespace gfxmmu_lut967h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT968L Register bits
    namespace gfxmmu_lut968l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT968H Register bits
    namespace gfxmmu_lut968h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT969L Register bits
    namespace gfxmmu_lut969l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT969H Register bits
    namespace gfxmmu_lut969h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT970L Register bits
    namespace gfxmmu_lut970l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT970H Register bits
    namespace gfxmmu_lut970h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT971L Register bits
    namespace gfxmmu_lut971l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT971H Register bits
    namespace gfxmmu_lut971h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT972L Register bits
    namespace gfxmmu_lut972l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT972H Register bits
    namespace gfxmmu_lut972h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT973L Register bits
    namespace gfxmmu_lut973l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT973H Register bits
    namespace gfxmmu_lut973h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT974L Register bits
    namespace gfxmmu_lut974l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT974H Register bits
    namespace gfxmmu_lut974h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT975L Register bits
    namespace gfxmmu_lut975l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT975H Register bits
    namespace gfxmmu_lut975h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT976L Register bits
    namespace gfxmmu_lut976l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT976H Register bits
    namespace gfxmmu_lut976h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT977L Register bits
    namespace gfxmmu_lut977l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT977H Register bits
    namespace gfxmmu_lut977h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT978L Register bits
    namespace gfxmmu_lut978l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT978H Register bits
    namespace gfxmmu_lut978h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT979L Register bits
    namespace gfxmmu_lut979l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT979H Register bits
    namespace gfxmmu_lut979h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT980L Register bits
    namespace gfxmmu_lut980l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT980H Register bits
    namespace gfxmmu_lut980h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT981L Register bits
    namespace gfxmmu_lut981l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT981H Register bits
    namespace gfxmmu_lut981h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT982L Register bits
    namespace gfxmmu_lut982l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT982H Register bits
    namespace gfxmmu_lut982h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT983L Register bits
    namespace gfxmmu_lut983l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT983H Register bits
    namespace gfxmmu_lut983h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT984L Register bits
    namespace gfxmmu_lut984l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT984H Register bits
    namespace gfxmmu_lut984h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT985L Register bits
    namespace gfxmmu_lut985l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT985H Register bits
    namespace gfxmmu_lut985h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT986L Register bits
    namespace gfxmmu_lut986l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT986H Register bits
    namespace gfxmmu_lut986h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT987L Register bits
    namespace gfxmmu_lut987l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT987H Register bits
    namespace gfxmmu_lut987h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT988L Register bits
    namespace gfxmmu_lut988l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT988H Register bits
    namespace gfxmmu_lut988h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT989L Register bits
    namespace gfxmmu_lut989l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT989H Register bits
    namespace gfxmmu_lut989h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT990L Register bits
    namespace gfxmmu_lut990l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT990H Register bits
    namespace gfxmmu_lut990h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT991L Register bits
    namespace gfxmmu_lut991l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT991H Register bits
    namespace gfxmmu_lut991h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT992L Register bits
    namespace gfxmmu_lut992l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT992H Register bits
    namespace gfxmmu_lut992h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT993L Register bits
    namespace gfxmmu_lut993l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT993H Register bits
    namespace gfxmmu_lut993h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT994L Register bits
    namespace gfxmmu_lut994l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT994H Register bits
    namespace gfxmmu_lut994h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT995L Register bits
    namespace gfxmmu_lut995l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT995H Register bits
    namespace gfxmmu_lut995h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT996L Register bits
    namespace gfxmmu_lut996l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT996H Register bits
    namespace gfxmmu_lut996h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT997L Register bits
    namespace gfxmmu_lut997l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT997H Register bits
    namespace gfxmmu_lut997h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT998L Register bits
    namespace gfxmmu_lut998l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT998H Register bits
    namespace gfxmmu_lut998h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT999L Register bits
    namespace gfxmmu_lut999l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT999H Register bits
    namespace gfxmmu_lut999h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1000L Register bits
    namespace gfxmmu_lut1000l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1000H Register bits
    namespace gfxmmu_lut1000h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1001L Register bits
    namespace gfxmmu_lut1001l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1001H Register bits
    namespace gfxmmu_lut1001h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1002L Register bits
    namespace gfxmmu_lut1002l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1002H Register bits
    namespace gfxmmu_lut1002h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1003L Register bits
    namespace gfxmmu_lut1003l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1003H Register bits
    namespace gfxmmu_lut1003h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1004L Register bits
    namespace gfxmmu_lut1004l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1004H Register bits
    namespace gfxmmu_lut1004h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1005L Register bits
    namespace gfxmmu_lut1005l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1005H Register bits
    namespace gfxmmu_lut1005h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1006L Register bits
    namespace gfxmmu_lut1006l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1006H Register bits
    namespace gfxmmu_lut1006h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1007L Register bits
    namespace gfxmmu_lut1007l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1007H Register bits
    namespace gfxmmu_lut1007h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1008L Register bits
    namespace gfxmmu_lut1008l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1008H Register bits
    namespace gfxmmu_lut1008h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1009L Register bits
    namespace gfxmmu_lut1009l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1009H Register bits
    namespace gfxmmu_lut1009h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1010L Register bits
    namespace gfxmmu_lut1010l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1010H Register bits
    namespace gfxmmu_lut1010h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1011L Register bits
    namespace gfxmmu_lut1011l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1011H Register bits
    namespace gfxmmu_lut1011h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1012L Register bits
    namespace gfxmmu_lut1012l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1012H Register bits
    namespace gfxmmu_lut1012h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1013L Register bits
    namespace gfxmmu_lut1013l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1013H Register bits
    namespace gfxmmu_lut1013h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1014L Register bits
    namespace gfxmmu_lut1014l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1014H Register bits
    namespace gfxmmu_lut1014h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1015L Register bits
    namespace gfxmmu_lut1015l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1015H Register bits
    namespace gfxmmu_lut1015h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1016L Register bits
    namespace gfxmmu_lut1016l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1016H Register bits
    namespace gfxmmu_lut1016h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1017L Register bits
    namespace gfxmmu_lut1017l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1017H Register bits
    namespace gfxmmu_lut1017h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1018L Register bits
    namespace gfxmmu_lut1018l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1018H Register bits
    namespace gfxmmu_lut1018h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1019L Register bits
    namespace gfxmmu_lut1019l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1019H Register bits
    namespace gfxmmu_lut1019h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1020L Register bits
    namespace gfxmmu_lut1020l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1020H Register bits
    namespace gfxmmu_lut1020h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1021L Register bits
    namespace gfxmmu_lut1021l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1021H Register bits
    namespace gfxmmu_lut1021h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1022L Register bits
    namespace gfxmmu_lut1022l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1022H Register bits
    namespace gfxmmu_lut1022h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

    /// GFXMMU_LUT1023L Register bits
    namespace gfxmmu_lut1023l_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable Line enable.
        constexpr uint32_t FVB = (8 << 8);  ///< First Valid Block Number of the first valid block of line number x.
        constexpr uint32_t LVB = (8 << 16);  ///< Last Valid Block Number of the last valid block of line number X.
    }

    /// GFXMMU_LUT1023H Register bits
    namespace gfxmmu_lut1023h_bits {
        constexpr uint32_t LO = (18 << 4);  ///< Line offset Line offset of line number x (i.e. offset of block 0 of line x)
    }

}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t GFXTIM_BASE = 0x40016400;
    constexpr uint32_t SEC_GFXTIM_BASE = 0x50016400;
    constexpr uint32_t LPTIM1_BASE = 0x46004400;
    constexpr uint32_t SEC_LPTIM1_BASE = 0x56004400;
    constexpr uint32_t LPTIM2_BASE = 0x40009400;
    constexpr uint32_t SEC_LPTIM2_BASE = 0x50009400;
    constexpr uint32_t LPTIM3_BASE = 0x46004800;
    constexpr uint32_t SEC_LPTIM3_BASE = 0x56004800;
    constexpr uint32_t LPTIM4_BASE = 0x46004C00;
    constexpr uint32_t SEC_LPTIM4_BASE = 0x56004C00;
    constexpr uint32_t TIM1_BASE = 0x40012C00;
    constexpr uint32_t SEC_TIM1_BASE = 0x50012C00;
    constexpr uint32_t TIM2_BASE = 0x40000000;
    constexpr uint32_t SEC_TIM2_BASE = 0x50000000;
    constexpr uint32_t TIM3_BASE = 0x40000400;
    constexpr uint32_t SEC_TIM3_BASE = 0x50000400;
    constexpr uint32_t TIM4_BASE = 0x40000800;
    constexpr uint32_t SEC_TIM4_BASE = 0x50000800;
    constexpr uint32_t TIM5_BASE = 0x40000C00;
    constexpr uint32_t SEC_TIM5_BASE = 0x50000C00;
    constexpr uint32_t TIM6_BASE = 0x40001000;
    constexpr uint32_t SEC_TIM6_BASE = 0x50001000;
    constexpr uint32_t TIM7_BASE = 0x40001400;
    constexpr uint32_t SEC_TIM7_BASE = 0x50001400;
    constexpr uint32_t TIM8_BASE = 0x40013400;
    constexpr uint32_t SEC_TIM8_BASE = 0x50013400;
    constexpr uint32_t TIM15_BASE = 0x40014000;
    constexpr uint32_t SEC_TIM15_BASE = 0x50014000;
    constexpr uint32_t TIM16_BASE = 0x40014400;
    constexpr uint32_t SEC_TIM16_BASE = 0x50014400;
    constexpr uint32_t TIM17_BASE = 0x40014800;
    constexpr uint32_t SEC_TIM17_BASE = 0x50014800;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t GFXTIM_CR;  ///< Offset: 0x00 - GFXTIM configuration register
        volatile uint32_t GFXTIM_CGCR;  ///< Offset: 0x04 - GFXTIM clock generator configuration register
        volatile uint32_t GFXTIM_TCR;  ///< Offset: 0x08 - GFXTIM timers configuration register
        volatile uint32_t GFXTIM_TDR;  ///< Offset: 0x0C - GFXTIM timers disable register
        volatile uint32_t GFXTIM_EVCR;  ///< Offset: 0x10 - GFXTIM events control register
        volatile uint32_t GFXTIM_EVSR;  ///< Offset: 0x14 - GFXTIM events selection register
        volatile uint32_t GFXTIM_WDGTCR;  ///< Offset: 0x20 - GFXTIM watchdog timer configuration register
        volatile uint32_t GFXTIM_ISR;  ///< Offset: 0x30 - GFXTIM interrupt status register
        volatile uint32_t GFXTIM_ICR;  ///< Offset: 0x34 - GFXTIM interrupt clear register
        volatile uint32_t GFXTIM_IER;  ///< Offset: 0x38 - GFXTIM interrupt enable register
        volatile uint32_t GFXTIM_TSR;  ///< Offset: 0x3C - GFXTIM timers status register
        volatile uint32_t GFXTIM_LCCRR;  ///< Offset: 0x40 - GFXTIM line clock counter reload register
        volatile uint32_t GFXTIM_FCCRR;  ///< Offset: 0x44 - GFXTIM frame clock counter reload register
        volatile uint32_t GFXTIM_ATR;  ///< Offset: 0x50 - GFXTIM absolute time register
        volatile uint32_t GFXTIM_AFCR;  ///< Offset: 0x54 - GFXTIM absolute frame counter register
        volatile uint32_t GFXTIM_ALCR;  ///< Offset: 0x58 - GFXTIM absolute line counter register
        volatile uint32_t GFXTIM_AFCC1R;  ///< Offset: 0x60 - GFXTIM absolute frame counter compare 1 register
        volatile uint32_t GFXTIM_ALCC1R;  ///< Offset: 0x70 - GFXTIM absolute line counter compare 1 register
        volatile uint32_t GFXTIM_ALCC2R;  ///< Offset: 0x74 - GFXTIM absolute line counter compare 2 register
        volatile uint32_t GFXTIM_RFC1R;  ///< Offset: 0x80 - GFXTIM relative frame counter 1 register
        volatile uint32_t GFXTIM_RFC1RR;  ///< Offset: 0x84 - GFXTIM relative frame counter 1 reload register
        volatile uint32_t GFXTIM_RFC2R;  ///< Offset: 0x88 - GFXTIM relative frame counter 2 register
        volatile uint32_t GFXTIM_RFC2RR;  ///< Offset: 0x8C - GFXTIM relative frame counter 2 reload register
        volatile uint32_t GFXTIM_WDGCR;  ///< Offset: 0xA0 - GFXTIM watchdog counter register
        volatile uint32_t GFXTIM_WDGRR;  ///< Offset: 0xA4 - GFXTIM watchdog reload register
        volatile uint32_t GFXTIM_WDGPAR;  ///< Offset: 0xA8 - GFXTIM watchdog pre-alarm register
    };

    /// Peripheral instances
    inline Registers* GFXTIM = reinterpret_cast<Registers*>(GFXTIM_BASE);
    inline Registers* SEC_GFXTIM = reinterpret_cast<Registers*>(SEC_GFXTIM_BASE);
    inline Registers* LPTIM1 = reinterpret_cast<Registers*>(LPTIM1_BASE);
    inline Registers* SEC_LPTIM1 = reinterpret_cast<Registers*>(SEC_LPTIM1_BASE);
    inline Registers* LPTIM2 = reinterpret_cast<Registers*>(LPTIM2_BASE);
    inline Registers* SEC_LPTIM2 = reinterpret_cast<Registers*>(SEC_LPTIM2_BASE);
    inline Registers* LPTIM3 = reinterpret_cast<Registers*>(LPTIM3_BASE);
    inline Registers* SEC_LPTIM3 = reinterpret_cast<Registers*>(SEC_LPTIM3_BASE);
    inline Registers* LPTIM4 = reinterpret_cast<Registers*>(LPTIM4_BASE);
    inline Registers* SEC_LPTIM4 = reinterpret_cast<Registers*>(SEC_LPTIM4_BASE);
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* SEC_TIM1 = reinterpret_cast<Registers*>(SEC_TIM1_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* SEC_TIM2 = reinterpret_cast<Registers*>(SEC_TIM2_BASE);
    inline Registers* TIM3 = reinterpret_cast<Registers*>(TIM3_BASE);
    inline Registers* SEC_TIM3 = reinterpret_cast<Registers*>(SEC_TIM3_BASE);
    inline Registers* TIM4 = reinterpret_cast<Registers*>(TIM4_BASE);
    inline Registers* SEC_TIM4 = reinterpret_cast<Registers*>(SEC_TIM4_BASE);
    inline Registers* TIM5 = reinterpret_cast<Registers*>(TIM5_BASE);
    inline Registers* SEC_TIM5 = reinterpret_cast<Registers*>(SEC_TIM5_BASE);
    inline Registers* TIM6 = reinterpret_cast<Registers*>(TIM6_BASE);
    inline Registers* SEC_TIM6 = reinterpret_cast<Registers*>(SEC_TIM6_BASE);
    inline Registers* TIM7 = reinterpret_cast<Registers*>(TIM7_BASE);
    inline Registers* SEC_TIM7 = reinterpret_cast<Registers*>(SEC_TIM7_BASE);
    inline Registers* TIM8 = reinterpret_cast<Registers*>(TIM8_BASE);
    inline Registers* SEC_TIM8 = reinterpret_cast<Registers*>(SEC_TIM8_BASE);
    inline Registers* TIM15 = reinterpret_cast<Registers*>(TIM15_BASE);
    inline Registers* SEC_TIM15 = reinterpret_cast<Registers*>(SEC_TIM15_BASE);
    inline Registers* TIM16 = reinterpret_cast<Registers*>(TIM16_BASE);
    inline Registers* SEC_TIM16 = reinterpret_cast<Registers*>(SEC_TIM16_BASE);
    inline Registers* TIM17 = reinterpret_cast<Registers*>(TIM17_BASE);
    inline Registers* SEC_TIM17 = reinterpret_cast<Registers*>(SEC_TIM17_BASE);

    // Bit definitions
    /// GFXTIM_CR Register bits
    namespace gfxtim_cr_bits {
        constexpr uint32_t TES = (2 << 0);  ///< tearing source This field selects the tearing-effect source.
        constexpr uint32_t TEPOL = (1U << 4);  ///< tearing--effect polarity This bit selects the tearing-effect polarity.
        constexpr uint32_t SYNCS = (2 << 8);  ///< synchronization source This field selects the synchronization signals (HSYNC and VSYNC) sources.
        constexpr uint32_t FCCOE = (1U << 16);  ///< frame-clock calibration output enable This bit enables the frame-clock output.
        constexpr uint32_t LCCOE = (1U << 17);  ///< line-clock calibration output enable This bit enables the line-clock output.
    }

    /// GFXTIM_CGCR Register bits
    namespace gfxtim_cgcr_bits {
        constexpr uint32_t LCS = (3 << 0);  ///< line clock source This field configures the line clock source.
        constexpr uint32_t LCCCS = (1U << 4);  ///< line clock counter clock source This bit configures the clock source for the line clock counter.
        constexpr uint32_t LCCFR = (1U << 8);  ///< line clock counter force reload This bit forces line clock counter reload.
        constexpr uint32_t LCCHRS = (3 << 12);  ///< line clock counter hardware reload source This field configures the hardware reload source for the line clock counter.
        constexpr uint32_t FCS = (3 << 16);  ///< frame clock source This field configures the frame clock source
        constexpr uint32_t FCCCS = (3 << 20);  ///< frame clock counter clock source This field configures the clock source for the frame clock counter.
        constexpr uint32_t FCCFR = (1U << 24);  ///< frame clock counter force reload This bit forces frame clock counter reload
        constexpr uint32_t FCCHRS = (3 << 28);  ///< frame- -clock counter hardware reload source This field configures the hardware reload source for the frame- -clock counter.
    }

    /// GFXTIM_TCR Register bits
    namespace gfxtim_tcr_bits {
        constexpr uint32_t AFCEN = (1U << 0);  ///< absolute frame counter enable This bit enables the absolute frame counter.
        constexpr uint32_t FAFCR = (1U << 1);  ///< force absolute frame counter reset This bit forces the reset of the absolute frame counter.
        constexpr uint32_t ALCEN = (1U << 4);  ///< absolute line counter enable This bit enables the absolute line counter.
        constexpr uint32_t FALCR = (1U << 5);  ///< force absolute line counter reset This bit forces the reset of the absolute line counter.
        constexpr uint32_t RFC1EN = (1U << 16);  ///< relative frame counter 1 enable This bit enables the relative frame counter 1.
        constexpr uint32_t RFC1CM = (1U << 17);  ///< relative frame counter 1 continuous mode This bit enables the continuous mode of the relative frame counter 1.
        constexpr uint32_t FRFC1R = (1U << 18);  ///< force relative frame counter 1 reload This bit forces the reload of the relative frame counter 1.
        constexpr uint32_t RFC2EN = (1U << 20);  ///< relative frame counter 2 enable This bit enables the relative frame counter 2.
        constexpr uint32_t RFC2CM = (1U << 21);  ///< relative frame counter 2 continuous mode This bit enables the continuous mode of the relative frame counter 2.
        constexpr uint32_t FRFC2R = (1U << 22);  ///< force relative frame counter 2 reload This bit forces the reload of the relative frame counter 2.
    }

    /// GFXTIM_TDR Register bits
    namespace gfxtim_tdr_bits {
        constexpr uint32_t AFCDIS = (1U << 0);  ///< absolute frame counter disable This bit disables the absolute frame counter.
        constexpr uint32_t ALCDIS = (1U << 4);  ///< absolute line counter disable This bit disables the absolute line counter.
        constexpr uint32_t RFC1DIS = (1U << 16);  ///< relative frame counter 1 disable This bit disables the relative frame counter 1.
        constexpr uint32_t RFC2DIS = (1U << 20);  ///< relative frame counter 2 disable This bit disables the relative frame counter 2.
    }

    /// GFXTIM_EVCR Register bits
    namespace gfxtim_evcr_bits {
        constexpr uint32_t EV1EN = (1U << 0);  ///< event 1 enable This bit enables the complex event 1 generation.
        constexpr uint32_t EV2EN = (1U << 1);  ///< event 2 enable This bit enables the complex event 2 generation.
        constexpr uint32_t EV3EN = (1U << 2);  ///< event 3 enable This bit enables the complex event 3 generation.
        constexpr uint32_t EV4EN = (1U << 3);  ///< event 4 enable This bit enables the complex event 4 generation.
    }

    /// GFXTIM_EVSR Register bits
    namespace gfxtim_evsr_bits {
        constexpr uint32_t LES1 = (3 << 0);  ///< line-event selection 1 This field defines the line-event selection for complex event 1 generation. others: reserved
        constexpr uint32_t FES1 = (3 << 4);  ///< frame-event selection 1 This field defines the frame-event selection for complex event 1 generation. others: reserved
        constexpr uint32_t LES2 = (3 << 8);  ///< line-event selection 2 This field defines the line-event selection for complex event 2 generation. others: reserved
        constexpr uint32_t FES2 = (3 << 12);  ///< frame-event selection 2 This field defines the frame-event selection for complex event 2 generation. others: reserved
        constexpr uint32_t LES3 = (3 << 16);  ///< line-event selection 3 This field defines the line-event selection for complex event 3 generation. others: reserved
        constexpr uint32_t FES3 = (3 << 20);  ///< frame-event selection 3 This field defines the frame-event selection for complex event 3 generation. others: reserved
        constexpr uint32_t LES4 = (3 << 24);  ///< line-event selection 4 This field defines the line-event selection for complex event 4 generation. others: Reserved
        constexpr uint32_t FES4 = (3 << 28);  ///< frame-event selection 4 This field defines the frame-event selection for complex event 4 generation. others: reserved
    }

    /// GFXTIM_WDGTCR Register bits
    namespace gfxtim_wdgtcr_bits {
        constexpr uint32_t WDGEN = (1U << 0);  ///< watchdog enable This bit enables the graphic watchdog.
        constexpr uint32_t WDGDIS = (1U << 1);  ///< watchdog disable This bit disables the graphic watchdog.
        constexpr uint32_t WDGS = (1U << 2);  ///< watchdog status This bit returns the status of the graphic watchdog.
        constexpr uint32_t WDGHRC = (2 << 4);  ///< watchdog hardware reload configuration This field configures the watchdog hardware reload.
        constexpr uint32_t WDGCS = (4 << 8);  ///< watchdog clock source This field selects the watchdog clock source. others: reserved
        constexpr uint32_t FWDGR = (1U << 16);  ///< force watchdog reload This bit forces the reload of the graphic watchdog.
    }

    /// GFXTIM_ISR Register bits
    namespace gfxtim_isr_bits {
        constexpr uint32_t AFCOF = (1U << 0);  ///< absolute frame counter overflow flag This bit indicates an overflow occurred on the absolute frame counter.
        constexpr uint32_t ALCOF = (1U << 1);  ///< absolute line counter overflow flag This bit indicates an overflow occurred on the absolute line counter.
        constexpr uint32_t TEF = (1U << 2);  ///< tearing-effect flag This bit indicates a tearing effect event occurred.
        constexpr uint32_t AFCC1F = (1U << 4);  ///< absolute frame counter compare 1 flag This bit indicates match on compare 1 of the absolute frame counter.
        constexpr uint32_t ALCC1F = (1U << 8);  ///< absolute line counter compare 1 flag This bit indicates match on compare 1 of the absolute line counter.
        constexpr uint32_t ALCC2F = (1U << 9);  ///< absolute line counter compare 2 flag This bit indicates match on compare 2 of the absolute line counter.
        constexpr uint32_t RFC1RF = (1U << 12);  ///< relative frame counter 1 reload flag This bit indicates relative frame counter 1 has been reloaded.
        constexpr uint32_t RFC2RF = (1U << 13);  ///< relative frame counter 2 reload flag This bit indicates relative frame counter 2 has been reloaded.
        constexpr uint32_t EV1F = (1U << 16);  ///< event 1 flag This bit indicates a complex event 1 occurred.
        constexpr uint32_t EV2F = (1U << 17);  ///< event 2 flag This bit indicates a complex event 2 occurred.
        constexpr uint32_t EV3F = (1U << 18);  ///< event 3 flag This bit indicates a complex event 3 occurred.
        constexpr uint32_t EV4F = (1U << 19);  ///< event 4 flag This bit indicates a complex event 4 occurred.
        constexpr uint32_t WDGAF = (1U << 24);  ///< watchdog alarm flag This bit indicates that a graphic watchdog alarm occurred.
        constexpr uint32_t WDGPF = (1U << 25);  ///< watchdog pre-alarm flag This bit indicates that a graphic watchdog pre-alarm occurred.
    }

    /// GFXTIM_ICR Register bits
    namespace gfxtim_icr_bits {
        constexpr uint32_t CAFCOF = (1U << 0);  ///< clear absolute frame counter overflow flag This bit clears AFCOF in GXTIM_ISR.
        constexpr uint32_t CALCOF = (1U << 1);  ///< clear absolute line counter overflow flag This bit clears ALCOF in GXTIM_ISR.
        constexpr uint32_t CTEF = (1U << 2);  ///< clear tearing-effect flag This bit clears TEF in GXTIM_ISR.
        constexpr uint32_t CAFCC1F = (1U << 4);  ///< clear absolute frame counter compare 1 flag This bit clears AFCC1F in GXTIM_ISR.
        constexpr uint32_t CALCC1F = (1U << 8);  ///< clear absolute line counter compare 1 flag This bit clears ALCC1F in GXTIM_ISR.
        constexpr uint32_t CALCC2F = (1U << 9);  ///< clear absolute line counter compare 2 flag This bit clears ALCC2F in GXTIM_ISR.
        constexpr uint32_t CRFC1RF = (1U << 12);  ///< clear relative frame counter 1 reload flag This bit clears RFC1RF in GXTIM_ISR.
        constexpr uint32_t CRFC2RF = (1U << 13);  ///< clear relative frame counter 2 reload flag This bit clears RFC2RF in GXFXTIM_ISR.
        constexpr uint32_t CEV1F = (1U << 16);  ///< clear event 1 flag This bit EV1F in GXFXTIM_ISR.
        constexpr uint32_t CEV2F = (1U << 17);  ///< clear event 2 flag This bit clears EV2F in GXFXTIM_ISR.
        constexpr uint32_t CEV3F = (1U << 18);  ///< clear event 3 flag This bit clears EV3F in GXFXTIM_ISR.
        constexpr uint32_t CEV4F = (1U << 19);  ///< clear event 4 flag This bit clears EV4F in GXFXTIM_ISR.
        constexpr uint32_t CWDGAF = (1U << 24);  ///< clear watchdog alarm flag This bit clears WDGAF in GXFXTIM_ISR.
        constexpr uint32_t CWDGPF = (1U << 25);  ///< clear watchdog pre-alarm flag This bit clears WDGPF in GXFXTIM_ISR.
    }

    /// GFXTIM_IER Register bits
    namespace gfxtim_ier_bits {
        constexpr uint32_t AFCOIE = (1U << 0);  ///< absolute frame counter overflow interrupt enable This bit enables the absolute frame counter overflow interrupt generation.
        constexpr uint32_t ALCOIE = (1U << 1);  ///< absolute line counter overflow interrupt enable This bit enables the absolute line counter overflow interrupt generation.
        constexpr uint32_t TEIE = (1U << 2);  ///< tearing-effect interrupt enable This bit enables the Tearing Effect interrupt generation.
        constexpr uint32_t AFCC1IE = (1U << 4);  ///< absolute frame counter compare 1 interrupt enable This bit enables the absolute frame counter compare interrupt generation.
        constexpr uint32_t ALCC1IE = (1U << 8);  ///< absolute line counter compare 1 interrupt enable This bit enables the absolute line counter compare 1 interrupt generation.
        constexpr uint32_t ALCC2IE = (1U << 9);  ///< absolute line counter compare 2 interrupt enable This bit enables the absolute line counter compare 2 interrupt generation.
        constexpr uint32_t RFC1RIE = (1U << 12);  ///< relative frame counter 1 reload interrupt enable This bit enables the relative frame counter 1 reload interrupt generation.
        constexpr uint32_t RFC2RIE = (1U << 13);  ///< relative frame counter 2 reload interrupt enable This bit enables the relative frame counter 2 reload interrupt generation.
        constexpr uint32_t EV1IE = (1U << 16);  ///< event 1 interrupt enable This bit enables the complex event 1 interrupt generation.
        constexpr uint32_t EV2IE = (1U << 17);  ///< event 2 interrupt enable This bit enables the complex event 2 interrupt generation.
        constexpr uint32_t EV3IE = (1U << 18);  ///< event 3 interrupt enable This bit enables the complex event 3 interrupt generation.
        constexpr uint32_t EV4IE = (1U << 19);  ///< event 4 interrupt enable This bit enables the complex event 4 interrupt generation.
        constexpr uint32_t WDGAIE = (1U << 24);  ///< watchdog alarm interrupt enable This bit enables the watchdog alarm interrupt generation.
        constexpr uint32_t WDGPIE = (1U << 25);  ///< watchdog pre-alarm interrupt enable This bit enables the watchdog pre-alarm interrupt generation.
    }

    /// GFXTIM_TSR Register bits
    namespace gfxtim_tsr_bits {
        constexpr uint32_t AFCS = (1U << 0);  ///< absolute frame counter status This bit returns the status of the absolute frame counter.
        constexpr uint32_t ALCS = (1U << 4);  ///< absolute line counter status This bit returns the status of the absolute line counter.
        constexpr uint32_t RFC1S = (1U << 16);  ///< relative frame counter 1 status This bit returns the status of the relative frame counter 1.
        constexpr uint32_t RFC2S = (1U << 20);  ///< relative frame counter 2 status This bit returns the status of the relative frame counter 2.
    }

    /// GFXTIM_LCCRR Register bits
    namespace gfxtim_lccrr_bits {
        constexpr uint32_t RELOAD = (22 << 0);  ///< reload value Reload value of the line clock counter.
    }

    /// GFXTIM_FCCRR Register bits
    namespace gfxtim_fccrr_bits {
        constexpr uint32_t RELOAD = (12 << 0);  ///< reload value Reload value of the frame clock counter.
    }

    /// GFXTIM_ATR Register bits
    namespace gfxtim_atr_bits {
        constexpr uint32_t LINE = (12 << 0);  ///< line number Current value of the absolute line counter.
        constexpr uint32_t FRAME = (20 << 12);  ///< fame number Current value of the absolute frame counter.
    }

    /// GFXTIM_AFCR Register bits
    namespace gfxtim_afcr_bits {
        constexpr uint32_t FRAME = (20 << 0);  ///< frame number Current value of the absolute frame counter. Note: This field can only be written when the absolute frame counter is disabled.
    }

    /// GFXTIM_ALCR Register bits
    namespace gfxtim_alcr_bits {
        constexpr uint32_t LINE = (12 << 0);  ///< line number Current value of the absolute line counter. Note: This field can only be written when the absolute frame counter is disabled.
    }

    /// GFXTIM_AFCC1R Register bits
    namespace gfxtim_afcc1r_bits {
        constexpr uint32_t FRAME = (20 << 0);  ///< frame number Compare 1 value for the absolute frame counter.
    }

    /// GFXTIM_ALCC1R Register bits
    namespace gfxtim_alcc1r_bits {
        constexpr uint32_t LINE = (12 << 0);  ///< line number Compare value 1 for the absolute line counter.
    }

    /// GFXTIM_ALCC2R Register bits
    namespace gfxtim_alcc2r_bits {
        constexpr uint32_t LINE = (12 << 0);  ///< line number Compare value 2 for the absolute line counter.
    }

    /// GFXTIM_RFC1R Register bits
    namespace gfxtim_rfc1r_bits {
        constexpr uint32_t FRAME = (12 << 0);  ///< frame number Current value of the relative frame counter 1.
    }

    /// GFXTIM_RFC1RR Register bits
    namespace gfxtim_rfc1rr_bits {
        constexpr uint32_t FRAME = (12 << 0);  ///< frame reload value Reload value for the relative frame counter 1.
    }

    /// GFXTIM_RFC2R Register bits
    namespace gfxtim_rfc2r_bits {
        constexpr uint32_t FRAME = (12 << 0);  ///< frame number Current value of the relative frame counter 2.
    }

    /// GFXTIM_RFC2RR Register bits
    namespace gfxtim_rfc2rr_bits {
        constexpr uint32_t FRAME = (12 << 0);  ///< frame reload value Reload value for the relative frame counter 2.
    }

    /// GFXTIM_WDGCR Register bits
    namespace gfxtim_wdgcr_bits {
        constexpr uint32_t VALUE = (16 << 0);  ///< value Current value of the watchdog counter.
    }

    /// GFXTIM_WDGRR Register bits
    namespace gfxtim_wdgrr_bits {
        constexpr uint32_t RELOAD = (16 << 0);  ///< reload value Reload value of the watchdog counter.
    }

    /// GFXTIM_WDGPAR Register bits
    namespace gfxtim_wdgpar_bits {
        constexpr uint32_t PREALARM = (16 << 0);  ///< pre-alarm value Pre-alarm value of the watchdog counter.
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x42020000;
    constexpr uint32_t SEC_GPIOA_BASE = 0x52020000;
    constexpr uint32_t GPIOB_BASE = 0x42020400;
    constexpr uint32_t SEC_GPIOB_BASE = 0x52020400;
    constexpr uint32_t GPIOC_BASE = 0x42020800;
    constexpr uint32_t SEC_GPIOC_BASE = 0x52020800;
    constexpr uint32_t GPIOD_BASE = 0x42020C00;
    constexpr uint32_t SEC_GPIOD_BASE = 0x52020C00;
    constexpr uint32_t GPIOE_BASE = 0x42021000;
    constexpr uint32_t SEC_GPIOE_BASE = 0x52021000;
    constexpr uint32_t GPIOF_BASE = 0x42021400;
    constexpr uint32_t SEC_GPIOF_BASE = 0x52021400;
    constexpr uint32_t GPIOG_BASE = 0x42021800;
    constexpr uint32_t SEC_GPIOG_BASE = 0x52021800;
    constexpr uint32_t GPIOH_BASE = 0x42021C00;
    constexpr uint32_t SEC_GPIOH_BASE = 0x52021C00;
    constexpr uint32_t GPIOI_BASE = 0x42022000;
    constexpr uint32_t SEC_GPIOI_BASE = 0x52022000;
    constexpr uint32_t GPIOJ_BASE = 0x42022400;
    constexpr uint32_t SEC_GPIOJ_BASE = 0x52022400;
    constexpr uint32_t LPGPIO1_BASE = 0x46020000;
    constexpr uint32_t SEC_LPGPIO1_BASE = 0x56020000;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t GPIO_MODER;  ///< Offset: 0x00 - GPIO port mode register
        volatile uint32_t GPIO_OTYPER;  ///< Offset: 0x04 - GPIO port output type register
        volatile uint32_t GPIO_OSPEEDR;  ///< Offset: 0x08 - GPIO port output speed register
        volatile uint32_t GPIO_PUPDR;  ///< Offset: 0x0C - GPIO port pull-up/pull-down register
        volatile uint32_t GPIO_IDR;  ///< Offset: 0x10 - GPIO port input data register
        volatile uint32_t GPIO_ODR;  ///< Offset: 0x14 - GPIO port output data register
        volatile uint32_t GPIO_BSRR;  ///< Offset: 0x18 - GPIO port bit set/reset register
        volatile uint32_t GPIO_LCKR;  ///< Offset: 0x1C - GPIO port configuration lock register
        volatile uint32_t GPIO_AFRL;  ///< Offset: 0x20 - GPIO alternate function low register
        volatile uint32_t GPIO_AFRH;  ///< Offset: 0x24 - GPIO alternate function high register
        volatile uint32_t GPIO_BRR;  ///< Offset: 0x28 - GPIO port bit reset register
        volatile uint32_t GPIO_HSLVR;  ///< Offset: 0x2C - GPIO high-speed low-voltage register
        volatile uint32_t GPIO_SECCFGR;  ///< Offset: 0x30 - GPIO secure configuration register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* SEC_GPIOA = reinterpret_cast<Registers*>(SEC_GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* SEC_GPIOB = reinterpret_cast<Registers*>(SEC_GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* SEC_GPIOC = reinterpret_cast<Registers*>(SEC_GPIOC_BASE);
    inline Registers* GPIOD = reinterpret_cast<Registers*>(GPIOD_BASE);
    inline Registers* SEC_GPIOD = reinterpret_cast<Registers*>(SEC_GPIOD_BASE);
    inline Registers* GPIOE = reinterpret_cast<Registers*>(GPIOE_BASE);
    inline Registers* SEC_GPIOE = reinterpret_cast<Registers*>(SEC_GPIOE_BASE);
    inline Registers* GPIOF = reinterpret_cast<Registers*>(GPIOF_BASE);
    inline Registers* SEC_GPIOF = reinterpret_cast<Registers*>(SEC_GPIOF_BASE);
    inline Registers* GPIOG = reinterpret_cast<Registers*>(GPIOG_BASE);
    inline Registers* SEC_GPIOG = reinterpret_cast<Registers*>(SEC_GPIOG_BASE);
    inline Registers* GPIOH = reinterpret_cast<Registers*>(GPIOH_BASE);
    inline Registers* SEC_GPIOH = reinterpret_cast<Registers*>(SEC_GPIOH_BASE);
    inline Registers* GPIOI = reinterpret_cast<Registers*>(GPIOI_BASE);
    inline Registers* SEC_GPIOI = reinterpret_cast<Registers*>(SEC_GPIOI_BASE);
    inline Registers* GPIOJ = reinterpret_cast<Registers*>(GPIOJ_BASE);
    inline Registers* SEC_GPIOJ = reinterpret_cast<Registers*>(SEC_GPIOJ_BASE);
    inline Registers* LPGPIO1 = reinterpret_cast<Registers*>(LPGPIO1_BASE);
    inline Registers* SEC_LPGPIO1 = reinterpret_cast<Registers*>(SEC_LPGPIO1_BASE);

    // Bit definitions
    /// GPIO_MODER Register bits
    namespace gpio_moder_bits {
        constexpr uint32_t MODE0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t MODE15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O mode. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_OTYPER Register bits
    namespace gpio_otyper_bits {
        constexpr uint32_t OT0 = (1U << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT1 = (1U << 1);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT2 = (1U << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT3 = (1U << 3);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT4 = (1U << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT5 = (1U << 5);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT6 = (1U << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT7 = (1U << 7);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT8 = (1U << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT9 = (1U << 9);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT10 = (1U << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT11 = (1U << 11);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT12 = (1U << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT13 = (1U << 13);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT14 = (1U << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OT15 = (1U << 15);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output type. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_OSPEEDR Register bits
    namespace gpio_ospeedr_bits {
        constexpr uint32_t OSPEED0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OSPEED15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications, and the power supply and load conditions for each speed. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_PUPDR Register bits
    namespace gpio_pupdr_bits {
        constexpr uint32_t PUPD0 = (2 << 0);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD1 = (2 << 2);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD2 = (2 << 4);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD3 = (2 << 6);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD4 = (2 << 8);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD5 = (2 << 10);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD6 = (2 << 12);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD7 = (2 << 14);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD8 = (2 << 16);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD9 = (2 << 18);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD10 = (2 << 20);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD11 = (2 << 22);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD12 = (2 << 24);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD13 = (2 << 26);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD14 = (2 << 28);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t PUPD15 = (2 << 30);  ///< Port x configuration I/O pin y These bits are written by software to configure the I/O pull-up or pull-down Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_IDR Register bits
    namespace gpio_idr_bits {
        constexpr uint32_t ID0 = (1U << 0);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID1 = (1U << 1);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID2 = (1U << 2);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID3 = (1U << 3);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID4 = (1U << 4);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID5 = (1U << 5);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID6 = (1U << 6);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID7 = (1U << 7);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID8 = (1U << 8);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID9 = (1U << 9);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID10 = (1U << 10);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID11 = (1U << 11);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID12 = (1U << 12);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID13 = (1U << 13);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID14 = (1U << 14);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t ID15 = (1U << 15);  ///< Port x input data I/O pin y These bits are read-only. They contain the input value of the corresponding I/O port. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_ODR Register bits
    namespace gpio_odr_bits {
        constexpr uint32_t OD0 = (1U << 0);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD1 = (1U << 1);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD2 = (1U << 2);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD3 = (1U << 3);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD4 = (1U << 4);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD5 = (1U << 5);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD6 = (1U << 6);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD7 = (1U << 7);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD8 = (1U << 8);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD9 = (1U << 9);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD10 = (1U << 10);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD11 = (1U << 11);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD12 = (1U << 12);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD13 = (1U << 13);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD14 = (1U << 14);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t OD15 = (1U << 15);  ///< Port output data I/O pin y These bits can be read and written by software. Note: For atomic bit set/reset, these bits can be individually set and/or reset by writing to�GPIOx_BSRR or GPIOx_BRR (x = A to J). Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_BSRR Register bits
    namespace gpio_bsrr_bits {
        constexpr uint32_t BS0 = (1U << 0);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS1 = (1U << 1);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS2 = (1U << 2);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS3 = (1U << 3);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS4 = (1U << 4);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS5 = (1U << 5);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS6 = (1U << 6);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS7 = (1U << 7);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS8 = (1U << 8);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS9 = (1U << 9);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS10 = (1U << 10);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS11 = (1U << 11);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS12 = (1U << 12);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS13 = (1U << 13);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS14 = (1U << 14);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BS15 = (1U << 15);  ///< Port x set I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: The bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR0 = (1U << 16);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR1 = (1U << 17);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR2 = (1U << 18);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR3 = (1U << 19);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR4 = (1U << 20);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR5 = (1U << 21);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR6 = (1U << 22);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR7 = (1U << 23);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR8 = (1U << 24);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR9 = (1U << 25);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR10 = (1U << 26);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR11 = (1U << 27);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR12 = (1U << 28);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR13 = (1U << 29);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR14 = (1U << 30);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR15 = (1U << 31);  ///< Port x reset I/O pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSy and BRy are set, BSy has priority. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_LCKR Register bits
    namespace gpio_lckr_bits {
        constexpr uint32_t LCK0 = (1U << 0);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK1 = (1U << 1);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK2 = (1U << 2);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK3 = (1U << 3);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK4 = (1U << 4);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK5 = (1U << 5);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK6 = (1U << 6);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK7 = (1U << 7);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK8 = (1U << 8);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK9 = (1U << 9);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK10 = (1U << 10);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK11 = (1U << 11);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK12 = (1U << 12);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK13 = (1U << 13);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK14 = (1U << 14);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCK15 = (1U << 15);  ///< Port x lock I/O pin y These bits are read/write but can only be written when the LCKK bit is 0 Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t LCKK = (1U << 16);  ///< Lock key This bit can be read any time. It can only be modified using the lock key write sequence. - LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] - LOCK key read RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the lock key write sequence, the value of LCK[15:0] must not change. Note: Any error in the lock sequence aborts the LOCK. Note: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.
    }

    /// GPIO_AFRL Register bits
    namespace gpio_afrl_bits {
        constexpr uint32_t AFSEL0 = (4 << 0);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL1 = (4 << 4);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL2 = (4 << 8);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL3 = (4 << 12);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL4 = (4 << 16);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL5 = (4 << 20);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL6 = (4 << 24);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL7 = (4 << 28);  ///< Alternate function selection for port x I/O pin y These bits are written by software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_AFRH Register bits
    namespace gpio_afrh_bits {
        constexpr uint32_t AFSEL8 = (4 << 0);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL9 = (4 << 4);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL10 = (4 << 8);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL11 = (4 << 12);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL12 = (4 << 16);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL13 = (4 << 20);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL14 = (4 << 24);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t AFSEL15 = (4 << 28);  ///< Alternate function selection for port x I/O pin y These bits are written by the software to configure alternate function I/Os. Note: This field is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_BRR Register bits
    namespace gpio_brr_bits {
        constexpr uint32_t BR0 = (1U << 0);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR1 = (1U << 1);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR2 = (1U << 2);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR3 = (1U << 3);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR4 = (1U << 4);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR5 = (1U << 5);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR6 = (1U << 6);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR7 = (1U << 7);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR8 = (1U << 8);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR9 = (1U << 9);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR10 = (1U << 10);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR11 = (1U << 11);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR12 = (1U << 12);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR13 = (1U << 13);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR14 = (1U << 14);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t BR15 = (1U << 15);  ///< Port x reset IO pin y These bits are write-only. A read to these bits returns the value 0x0000. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_HSLVR Register bits
    namespace gpio_hslvr_bits {
        constexpr uint32_t HSLV0 = (1U << 0);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV1 = (1U << 1);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV2 = (1U << 2);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV3 = (1U << 3);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV4 = (1U << 4);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV5 = (1U << 5);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV6 = (1U << 6);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV7 = (1U << 7);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV8 = (1U << 8);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV9 = (1U << 9);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV10 = (1U << 10);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV11 = (1U << 11);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV12 = (1U << 12);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV13 = (1U << 13);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV14 = (1U << 14);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t HSLV15 = (1U << 15);  ///< Port x high-speed low-voltage configuration These bits are written by software to optimize the I/O speed when the I/O supply is low. Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V. Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive. Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value. Note: This bit is reserved and must be kept at reset value when the corresponding I/O is not available on the selected package.
    }

    /// GPIO_SECCFGR Register bits
    namespace gpio_seccfgr_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC1 = (1U << 1);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC2 = (1U << 2);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC3 = (1U << 3);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC4 = (1U << 4);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC5 = (1U << 5);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC6 = (1U << 6);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC7 = (1U << 7);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC8 = (1U << 8);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC9 = (1U << 9);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC10 = (1U << 10);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC11 = (1U << 11);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC12 = (1U << 12);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC13 = (1U << 13);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC14 = (1U << 14);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
        constexpr uint32_t SEC15 = (1U << 15);  ///< I/O pin of Port x secure bit enable y These bits are written by software to enable or disable the I/O port pin security. Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.
    }

}

// ============================================================================
// GTZC1 Peripheral
// ============================================================================

namespace gtzc1 {
    /// Base addresses
    constexpr uint32_t GTZC1_MPCBB1_BASE = 0x40032C00;
    constexpr uint32_t GTZC1_MPCBB2_BASE = 0x40033000;
    constexpr uint32_t GTZC1_MPCBB3_BASE = 0x40033400;
    constexpr uint32_t GTZC1_MPCBB5_BASE = 0x40033800;
    constexpr uint32_t GTZC1_MPCBB6_BASE = 0x40033C00;
    constexpr uint32_t GTZC1_TZIC_BASE = 0x40032800;
    constexpr uint32_t GTZC1_TZSC_BASE = 0x40032400;

    /// GTZC1 Register structure
    struct Registers {
        volatile uint32_t MPCBB1_CR;  ///< Offset: 0x00 - MPCBB control register
        volatile uint32_t MPCBB1_CFGLOCK1;  ///< Offset: 0x10 - GTZC1 SRAMz MPCBB configuration lock register 1
        volatile uint32_t MPCBB1_CFGLOCK2;  ///< Offset: 0x14 - GTZC1 SRAMz MPCBB configuration lock register 2
        volatile uint32_t MPCBB1_SECCFGR0;  ///< Offset: 0x100 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR1;  ///< Offset: 0x104 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR2;  ///< Offset: 0x108 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR3;  ///< Offset: 0x10C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR4;  ///< Offset: 0x110 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR5;  ///< Offset: 0x114 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR6;  ///< Offset: 0x118 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR7;  ///< Offset: 0x11C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR8;  ///< Offset: 0x120 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR9;  ///< Offset: 0x124 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR10;  ///< Offset: 0x128 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR11;  ///< Offset: 0x12C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR12;  ///< Offset: 0x130 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR13;  ///< Offset: 0x134 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR14;  ///< Offset: 0x138 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR15;  ///< Offset: 0x13C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR16;  ///< Offset: 0x140 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR17;  ///< Offset: 0x144 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR18;  ///< Offset: 0x148 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR19;  ///< Offset: 0x14C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR20;  ///< Offset: 0x150 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR21;  ///< Offset: 0x154 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR22;  ///< Offset: 0x158 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR23;  ///< Offset: 0x15C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR24;  ///< Offset: 0x160 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR25;  ///< Offset: 0x164 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR26;  ///< Offset: 0x168 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR27;  ///< Offset: 0x16C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR28;  ///< Offset: 0x170 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR29;  ///< Offset: 0x174 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR30;  ///< Offset: 0x178 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR31;  ///< Offset: 0x17C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR32;  ///< Offset: 0x180 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR33;  ///< Offset: 0x184 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR34;  ///< Offset: 0x188 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR35;  ///< Offset: 0x18C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR36;  ///< Offset: 0x190 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR37;  ///< Offset: 0x194 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR38;  ///< Offset: 0x198 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR39;  ///< Offset: 0x19C - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR40;  ///< Offset: 0x1A0 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR41;  ///< Offset: 0x1A4 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR42;  ///< Offset: 0x1A8 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR43;  ///< Offset: 0x1AC - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR44;  ///< Offset: 0x1B0 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR45;  ///< Offset: 0x1B4 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR46;  ///< Offset: 0x1B8 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR47;  ///< Offset: 0x1BC - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR48;  ///< Offset: 0x1C0 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR49;  ///< Offset: 0x1C4 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR50;  ///< Offset: 0x1C8 - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_SECCFGR51;  ///< Offset: 0x1CC - MPCBBx security configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR0;  ///< Offset: 0x200 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR1;  ///< Offset: 0x204 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR2;  ///< Offset: 0x208 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR3;  ///< Offset: 0x20C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR4;  ///< Offset: 0x210 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR5;  ///< Offset: 0x214 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR6;  ///< Offset: 0x218 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR7;  ///< Offset: 0x21C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR8;  ///< Offset: 0x220 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR9;  ///< Offset: 0x224 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR10;  ///< Offset: 0x228 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR11;  ///< Offset: 0x22C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR12;  ///< Offset: 0x230 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR13;  ///< Offset: 0x234 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR14;  ///< Offset: 0x238 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR15;  ///< Offset: 0x23C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR16;  ///< Offset: 0x240 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR17;  ///< Offset: 0x244 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR18;  ///< Offset: 0x248 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR19;  ///< Offset: 0x24C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR20;  ///< Offset: 0x250 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR21;  ///< Offset: 0x254 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR22;  ///< Offset: 0x258 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR23;  ///< Offset: 0x25C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR24;  ///< Offset: 0x260 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR25;  ///< Offset: 0x264 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR26;  ///< Offset: 0x268 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR27;  ///< Offset: 0x26C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR28;  ///< Offset: 0x270 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR29;  ///< Offset: 0x274 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR30;  ///< Offset: 0x278 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR31;  ///< Offset: 0x27C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR32;  ///< Offset: 0x280 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR33;  ///< Offset: 0x284 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR34;  ///< Offset: 0x288 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR35;  ///< Offset: 0x28C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR36;  ///< Offset: 0x290 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR37;  ///< Offset: 0x294 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR38;  ///< Offset: 0x298 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR39;  ///< Offset: 0x29C - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR40;  ///< Offset: 0x2A0 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR41;  ///< Offset: 0x2A4 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR42;  ///< Offset: 0x2A8 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR43;  ///< Offset: 0x2AC - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR44;  ///< Offset: 0x2B0 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR45;  ///< Offset: 0x2B4 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR46;  ///< Offset: 0x2B8 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR47;  ///< Offset: 0x2BC - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR48;  ///< Offset: 0x2C0 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR49;  ///< Offset: 0x2C4 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR50;  ///< Offset: 0x2C8 - MPCBB privileged configuration for super-block x register
        volatile uint32_t MPCBB1_PRIVCFGR51;  ///< Offset: 0x2CC - MPCBB privileged configuration for super-block x register
    };

    /// Peripheral instances
    inline Registers* GTZC1_MPCBB1 = reinterpret_cast<Registers*>(GTZC1_MPCBB1_BASE);
    inline Registers* GTZC1_MPCBB2 = reinterpret_cast<Registers*>(GTZC1_MPCBB2_BASE);
    inline Registers* GTZC1_MPCBB3 = reinterpret_cast<Registers*>(GTZC1_MPCBB3_BASE);
    inline Registers* GTZC1_MPCBB5 = reinterpret_cast<Registers*>(GTZC1_MPCBB5_BASE);
    inline Registers* GTZC1_MPCBB6 = reinterpret_cast<Registers*>(GTZC1_MPCBB6_BASE);
    inline Registers* GTZC1_TZIC = reinterpret_cast<Registers*>(GTZC1_TZIC_BASE);
    inline Registers* GTZC1_TZSC = reinterpret_cast<Registers*>(GTZC1_TZSC_BASE);

    // Bit definitions
    /// MPCBB1_CR Register bits
    namespace mpcbb1_cr_bits {
        constexpr uint32_t GLOCK = (1U << 0);  ///< lock the control register of the MPCBB until next reset
        constexpr uint32_t INVSECSTATE = (1U << 30);  ///< SRAMx clocks security state
        constexpr uint32_t SRWILADIS = (1U << 31);  ///< secure read/write illegal access disable
    }

    /// MPCBB1_CFGLOCK1 Register bits
    namespace mpcbb1_cfglock1_bits {
        constexpr uint32_t SPLCK0 = (1U << 0);  ///< SPLCK0
        constexpr uint32_t SPLCK1 = (1U << 1);  ///< SPLCK1
        constexpr uint32_t SPLCK2 = (1U << 2);  ///< SPLCK2
        constexpr uint32_t SPLCK3 = (1U << 3);  ///< SPLCK3
        constexpr uint32_t SPLCK4 = (1U << 4);  ///< SPLCK4
        constexpr uint32_t SPLCK5 = (1U << 5);  ///< SPLCK5
        constexpr uint32_t SPLCK6 = (1U << 6);  ///< SPLCK6
        constexpr uint32_t SPLCK7 = (1U << 7);  ///< SPLCK7
        constexpr uint32_t SPLCK8 = (1U << 8);  ///< SPLCK8
        constexpr uint32_t SPLCK9 = (1U << 9);  ///< SPLCK9
        constexpr uint32_t SPLCK10 = (1U << 10);  ///< SPLCK10
        constexpr uint32_t SPLCK11 = (1U << 11);  ///< SPLCK11
        constexpr uint32_t SPLCK12 = (1U << 12);  ///< SPLCK12
        constexpr uint32_t SPLCK13 = (1U << 13);  ///< SPLCK13
        constexpr uint32_t SPLCK14 = (1U << 14);  ///< SPLCK14
        constexpr uint32_t SPLCK15 = (1U << 15);  ///< SPLCK15
        constexpr uint32_t SPLCK16 = (1U << 16);  ///< SPLCK16
        constexpr uint32_t SPLCK17 = (1U << 17);  ///< SPLCK17
        constexpr uint32_t SPLCK18 = (1U << 18);  ///< SPLCK18
        constexpr uint32_t SPLCK19 = (1U << 19);  ///< SPLCK19
        constexpr uint32_t SPLCK20 = (1U << 20);  ///< SPLCK20
        constexpr uint32_t SPLCK21 = (1U << 21);  ///< SPLCK21
        constexpr uint32_t SPLCK22 = (1U << 22);  ///< SPLCK22
        constexpr uint32_t SPLCK23 = (1U << 23);  ///< SPLCK23
        constexpr uint32_t SPLCK24 = (1U << 24);  ///< SPLCK24
        constexpr uint32_t SPLCK25 = (1U << 25);  ///< SPLCK25
        constexpr uint32_t SPLCK26 = (1U << 26);  ///< SPLCK26
        constexpr uint32_t SPLCK27 = (1U << 27);  ///< SPLCK27
        constexpr uint32_t SPLCK28 = (1U << 28);  ///< SPLCK28
        constexpr uint32_t SPLCK29 = (1U << 29);  ///< SPLCK29
        constexpr uint32_t SPLCK30 = (1U << 30);  ///< SPLCK30
        constexpr uint32_t SPLCK31 = (1U << 31);  ///< SPLCK31
    }

    /// MPCBB1_CFGLOCK2 Register bits
    namespace mpcbb1_cfglock2_bits {
        constexpr uint32_t SPLCK32 = (1U << 0);  ///< SPLCK32
        constexpr uint32_t SPLCK33 = (1U << 1);  ///< SPLCK33
        constexpr uint32_t SPLCK34 = (1U << 2);  ///< SPLCK34
        constexpr uint32_t SPLCK35 = (1U << 3);  ///< SPLCK35
        constexpr uint32_t SPLCK36 = (1U << 4);  ///< SPLCK36
        constexpr uint32_t SPLCK37 = (1U << 5);  ///< SPLCK37
        constexpr uint32_t SPLCK38 = (1U << 6);  ///< SPLCK38
        constexpr uint32_t SPLCK39 = (1U << 7);  ///< SPLCK39
        constexpr uint32_t SPLCK40 = (1U << 8);  ///< SPLCK40
        constexpr uint32_t SPLCK41 = (1U << 9);  ///< SPLCK41
        constexpr uint32_t SPLCK42 = (1U << 10);  ///< SPLCK42
        constexpr uint32_t SPLCK43 = (1U << 11);  ///< SPLCK43
        constexpr uint32_t SPLCK44 = (1U << 12);  ///< SPLCK44
        constexpr uint32_t SPLCK45 = (1U << 13);  ///< SPLCK45
        constexpr uint32_t SPLCK46 = (1U << 14);  ///< SPLCK46
        constexpr uint32_t SPLCK47 = (1U << 15);  ///< SPLCK47
        constexpr uint32_t SPLCK48 = (1U << 16);  ///< SPLCK48
        constexpr uint32_t SPLCK49 = (1U << 17);  ///< SPLCK49
        constexpr uint32_t SPLCK50 = (1U << 18);  ///< SPLCK50
        constexpr uint32_t SPLCK51 = (1U << 19);  ///< SPLCK51
    }

    /// MPCBB1_SECCFGR0 Register bits
    namespace mpcbb1_seccfgr0_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR1 Register bits
    namespace mpcbb1_seccfgr1_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR2 Register bits
    namespace mpcbb1_seccfgr2_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR3 Register bits
    namespace mpcbb1_seccfgr3_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR4 Register bits
    namespace mpcbb1_seccfgr4_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR5 Register bits
    namespace mpcbb1_seccfgr5_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR6 Register bits
    namespace mpcbb1_seccfgr6_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR7 Register bits
    namespace mpcbb1_seccfgr7_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR8 Register bits
    namespace mpcbb1_seccfgr8_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR9 Register bits
    namespace mpcbb1_seccfgr9_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR10 Register bits
    namespace mpcbb1_seccfgr10_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR11 Register bits
    namespace mpcbb1_seccfgr11_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR12 Register bits
    namespace mpcbb1_seccfgr12_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR13 Register bits
    namespace mpcbb1_seccfgr13_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR14 Register bits
    namespace mpcbb1_seccfgr14_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR15 Register bits
    namespace mpcbb1_seccfgr15_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR16 Register bits
    namespace mpcbb1_seccfgr16_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR17 Register bits
    namespace mpcbb1_seccfgr17_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR18 Register bits
    namespace mpcbb1_seccfgr18_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR19 Register bits
    namespace mpcbb1_seccfgr19_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR20 Register bits
    namespace mpcbb1_seccfgr20_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR21 Register bits
    namespace mpcbb1_seccfgr21_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR22 Register bits
    namespace mpcbb1_seccfgr22_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR23 Register bits
    namespace mpcbb1_seccfgr23_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR24 Register bits
    namespace mpcbb1_seccfgr24_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR25 Register bits
    namespace mpcbb1_seccfgr25_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR26 Register bits
    namespace mpcbb1_seccfgr26_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR27 Register bits
    namespace mpcbb1_seccfgr27_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR28 Register bits
    namespace mpcbb1_seccfgr28_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR29 Register bits
    namespace mpcbb1_seccfgr29_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR30 Register bits
    namespace mpcbb1_seccfgr30_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR31 Register bits
    namespace mpcbb1_seccfgr31_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR32 Register bits
    namespace mpcbb1_seccfgr32_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR33 Register bits
    namespace mpcbb1_seccfgr33_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR34 Register bits
    namespace mpcbb1_seccfgr34_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR35 Register bits
    namespace mpcbb1_seccfgr35_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR36 Register bits
    namespace mpcbb1_seccfgr36_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR37 Register bits
    namespace mpcbb1_seccfgr37_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR38 Register bits
    namespace mpcbb1_seccfgr38_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR39 Register bits
    namespace mpcbb1_seccfgr39_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR40 Register bits
    namespace mpcbb1_seccfgr40_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR41 Register bits
    namespace mpcbb1_seccfgr41_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR42 Register bits
    namespace mpcbb1_seccfgr42_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR43 Register bits
    namespace mpcbb1_seccfgr43_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR44 Register bits
    namespace mpcbb1_seccfgr44_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR45 Register bits
    namespace mpcbb1_seccfgr45_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR46 Register bits
    namespace mpcbb1_seccfgr46_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR47 Register bits
    namespace mpcbb1_seccfgr47_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR48 Register bits
    namespace mpcbb1_seccfgr48_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR49 Register bits
    namespace mpcbb1_seccfgr49_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR50 Register bits
    namespace mpcbb1_seccfgr50_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_SECCFGR51 Register bits
    namespace mpcbb1_seccfgr51_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB1_PRIVCFGR0 Register bits
    namespace mpcbb1_privcfgr0_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR1 Register bits
    namespace mpcbb1_privcfgr1_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR2 Register bits
    namespace mpcbb1_privcfgr2_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR3 Register bits
    namespace mpcbb1_privcfgr3_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR4 Register bits
    namespace mpcbb1_privcfgr4_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR5 Register bits
    namespace mpcbb1_privcfgr5_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR6 Register bits
    namespace mpcbb1_privcfgr6_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR7 Register bits
    namespace mpcbb1_privcfgr7_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR8 Register bits
    namespace mpcbb1_privcfgr8_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR9 Register bits
    namespace mpcbb1_privcfgr9_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR10 Register bits
    namespace mpcbb1_privcfgr10_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR11 Register bits
    namespace mpcbb1_privcfgr11_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR12 Register bits
    namespace mpcbb1_privcfgr12_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR13 Register bits
    namespace mpcbb1_privcfgr13_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR14 Register bits
    namespace mpcbb1_privcfgr14_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR15 Register bits
    namespace mpcbb1_privcfgr15_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR16 Register bits
    namespace mpcbb1_privcfgr16_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR17 Register bits
    namespace mpcbb1_privcfgr17_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR18 Register bits
    namespace mpcbb1_privcfgr18_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR19 Register bits
    namespace mpcbb1_privcfgr19_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR20 Register bits
    namespace mpcbb1_privcfgr20_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR21 Register bits
    namespace mpcbb1_privcfgr21_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR22 Register bits
    namespace mpcbb1_privcfgr22_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR23 Register bits
    namespace mpcbb1_privcfgr23_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR24 Register bits
    namespace mpcbb1_privcfgr24_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR25 Register bits
    namespace mpcbb1_privcfgr25_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR26 Register bits
    namespace mpcbb1_privcfgr26_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR27 Register bits
    namespace mpcbb1_privcfgr27_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR28 Register bits
    namespace mpcbb1_privcfgr28_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR29 Register bits
    namespace mpcbb1_privcfgr29_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR30 Register bits
    namespace mpcbb1_privcfgr30_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR31 Register bits
    namespace mpcbb1_privcfgr31_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR32 Register bits
    namespace mpcbb1_privcfgr32_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR33 Register bits
    namespace mpcbb1_privcfgr33_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR34 Register bits
    namespace mpcbb1_privcfgr34_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR35 Register bits
    namespace mpcbb1_privcfgr35_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR36 Register bits
    namespace mpcbb1_privcfgr36_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR37 Register bits
    namespace mpcbb1_privcfgr37_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR38 Register bits
    namespace mpcbb1_privcfgr38_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR39 Register bits
    namespace mpcbb1_privcfgr39_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR40 Register bits
    namespace mpcbb1_privcfgr40_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR41 Register bits
    namespace mpcbb1_privcfgr41_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR42 Register bits
    namespace mpcbb1_privcfgr42_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR43 Register bits
    namespace mpcbb1_privcfgr43_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR44 Register bits
    namespace mpcbb1_privcfgr44_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR45 Register bits
    namespace mpcbb1_privcfgr45_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR46 Register bits
    namespace mpcbb1_privcfgr46_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR47 Register bits
    namespace mpcbb1_privcfgr47_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR48 Register bits
    namespace mpcbb1_privcfgr48_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR49 Register bits
    namespace mpcbb1_privcfgr49_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR50 Register bits
    namespace mpcbb1_privcfgr50_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

    /// MPCBB1_PRIVCFGR51 Register bits
    namespace mpcbb1_privcfgr51_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

}

// ============================================================================
// GTZC2 Peripheral
// ============================================================================

namespace gtzc2 {
    /// Base addresses
    constexpr uint32_t GTZC2_MPCBB4_BASE = 0x46023800;
    constexpr uint32_t GTZC2_TZIC_BASE = 0x46023400;
    constexpr uint32_t GTZC2_TZSC_BASE = 0x46023000;

    /// GTZC2 Register structure
    struct Registers {
        volatile uint32_t MPCBB4_CR;  ///< Offset: 0x00 - MPCBB control register
        volatile uint32_t MPCBB4_CFGLOCK;  ///< Offset: 0x10 - GTZC2 SRAM4 MPCBB configuration lock register
        volatile uint32_t MPCBB4_SECCFGR0;  ///< Offset: 0x100 - MPCBB security configuration for super-block 0 register
        volatile uint32_t MPCBB4_PRIVCFGR0;  ///< Offset: 0x200 - MPCBB privileged configuration for super-block 0 register
    };

    /// Peripheral instances
    inline Registers* GTZC2_MPCBB4 = reinterpret_cast<Registers*>(GTZC2_MPCBB4_BASE);
    inline Registers* GTZC2_TZIC = reinterpret_cast<Registers*>(GTZC2_TZIC_BASE);
    inline Registers* GTZC2_TZSC = reinterpret_cast<Registers*>(GTZC2_TZSC_BASE);

    // Bit definitions
    /// MPCBB4_CR Register bits
    namespace mpcbb4_cr_bits {
        constexpr uint32_t GLOCK = (1U << 0);  ///< lock the control register of the MPCBB until next reset
        constexpr uint32_t INVSECSTATE = (1U << 30);  ///< SRAMx clocks security state
        constexpr uint32_t SRWILADIS = (1U << 31);  ///< secure read/write illegal access disable
    }

    /// MPCBB4_CFGLOCK Register bits
    namespace mpcbb4_cfglock_bits {
        constexpr uint32_t SPLCK0 = (1U << 0);  ///< Security/privilege configuration lock for super-block 0
    }

    /// MPCBB4_SECCFGR0 Register bits
    namespace mpcbb4_seccfgr0_bits {
        constexpr uint32_t SEC0 = (1U << 0);  ///< SEC0
        constexpr uint32_t SEC1 = (1U << 1);  ///< SEC1
        constexpr uint32_t SEC2 = (1U << 2);  ///< SEC2
        constexpr uint32_t SEC3 = (1U << 3);  ///< SEC3
        constexpr uint32_t SEC4 = (1U << 4);  ///< SEC4
        constexpr uint32_t SEC5 = (1U << 5);  ///< SEC5
        constexpr uint32_t SEC6 = (1U << 6);  ///< SEC6
        constexpr uint32_t SEC7 = (1U << 7);  ///< SEC7
        constexpr uint32_t SEC8 = (1U << 8);  ///< SEC8
        constexpr uint32_t SEC9 = (1U << 9);  ///< SEC9
        constexpr uint32_t SEC10 = (1U << 10);  ///< SEC10
        constexpr uint32_t SEC11 = (1U << 11);  ///< SEC11
        constexpr uint32_t SEC12 = (1U << 12);  ///< SEC12
        constexpr uint32_t SEC13 = (1U << 13);  ///< SEC13
        constexpr uint32_t SEC14 = (1U << 14);  ///< SEC14
        constexpr uint32_t SEC15 = (1U << 15);  ///< SEC15
        constexpr uint32_t SEC16 = (1U << 16);  ///< SEC16
        constexpr uint32_t SEC17 = (1U << 17);  ///< SEC17
        constexpr uint32_t SEC18 = (1U << 18);  ///< SEC18
        constexpr uint32_t SEC19 = (1U << 19);  ///< SEC19
        constexpr uint32_t SEC20 = (1U << 20);  ///< SEC20
        constexpr uint32_t SEC21 = (1U << 21);  ///< SEC21
        constexpr uint32_t SEC22 = (1U << 22);  ///< SEC22
        constexpr uint32_t SEC23 = (1U << 23);  ///< SEC23
        constexpr uint32_t SEC24 = (1U << 24);  ///< SEC24
        constexpr uint32_t SEC25 = (1U << 25);  ///< SEC25
        constexpr uint32_t SEC26 = (1U << 26);  ///< SEC26
        constexpr uint32_t SEC27 = (1U << 27);  ///< SEC27
        constexpr uint32_t SEC28 = (1U << 28);  ///< SEC28
        constexpr uint32_t SEC29 = (1U << 29);  ///< SEC29
        constexpr uint32_t SEC30 = (1U << 30);  ///< SEC30
        constexpr uint32_t SEC31 = (1U << 31);  ///< SEC31
    }

    /// MPCBB4_PRIVCFGR0 Register bits
    namespace mpcbb4_privcfgr0_bits {
        constexpr uint32_t PRIV0 = (1U << 0);  ///< PRIV0
        constexpr uint32_t PRIV1 = (1U << 1);  ///< PRIV1
        constexpr uint32_t PRIV2 = (1U << 2);  ///< PRIV2
        constexpr uint32_t PRIV3 = (1U << 3);  ///< PRIV3
        constexpr uint32_t PRIV4 = (1U << 4);  ///< PRIV4
        constexpr uint32_t PRIV5 = (1U << 5);  ///< PRIV5
        constexpr uint32_t PRIV6 = (1U << 6);  ///< PRIV6
        constexpr uint32_t PRIV7 = (1U << 7);  ///< PRIV7
        constexpr uint32_t PRIV8 = (1U << 8);  ///< PRIV8
        constexpr uint32_t PRIV9 = (1U << 9);  ///< PRIV9
        constexpr uint32_t PRIV10 = (1U << 10);  ///< PRIV10
        constexpr uint32_t PRIV11 = (1U << 11);  ///< PRIV11
        constexpr uint32_t PRIV12 = (1U << 12);  ///< PRIV12
        constexpr uint32_t PRIV13 = (1U << 13);  ///< PRIV13
        constexpr uint32_t PRIV14 = (1U << 14);  ///< PRIV14
        constexpr uint32_t PRIV15 = (1U << 15);  ///< PRIV15
        constexpr uint32_t PRIV16 = (1U << 16);  ///< PRIV16
        constexpr uint32_t PRIV17 = (1U << 17);  ///< PRIV17
        constexpr uint32_t PRIV18 = (1U << 18);  ///< PRIV18
        constexpr uint32_t PRIV19 = (1U << 19);  ///< PRIV19
        constexpr uint32_t PRIV20 = (1U << 20);  ///< PRIV20
        constexpr uint32_t PRIV21 = (1U << 21);  ///< PRIV21
        constexpr uint32_t PRIV22 = (1U << 22);  ///< PRIV22
        constexpr uint32_t PRIV23 = (1U << 23);  ///< PRIV23
        constexpr uint32_t PRIV24 = (1U << 24);  ///< PRIV24
        constexpr uint32_t PRIV25 = (1U << 25);  ///< PRIV25
        constexpr uint32_t PRIV26 = (1U << 26);  ///< PRIV26
        constexpr uint32_t PRIV27 = (1U << 27);  ///< PRIV27
        constexpr uint32_t PRIV28 = (1U << 28);  ///< PRIV28
        constexpr uint32_t PRIV29 = (1U << 29);  ///< PRIV29
        constexpr uint32_t PRIV30 = (1U << 30);  ///< PRIV30
        constexpr uint32_t PRIV31 = (1U << 31);  ///< PRIV31
    }

}

// ============================================================================
// HASH Peripheral
// ============================================================================

namespace hash {
    /// Base addresses
    constexpr uint32_t HASH_BASE = 0x420C0400;

    /// HASH Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t DIN;  ///< Offset: 0x04 - data input register
        volatile uint32_t STR;  ///< Offset: 0x08 - start register
        volatile uint32_t HRA0;  ///< Offset: 0x0C - HASH aliased digest register 0
        volatile uint32_t HRA1;  ///< Offset: 0x10 - HASH aliased digest register 1
        volatile uint32_t HRA2;  ///< Offset: 0x14 - HASH aliased digest register 2
        volatile uint32_t HRA3;  ///< Offset: 0x18 - HASH aliased digest register 3
        volatile uint32_t HRA4;  ///< Offset: 0x1C - HASH aliased digest register 4
        volatile uint32_t HR0;  ///< Offset: 0x310 - digest register 0
        volatile uint32_t HR1;  ///< Offset: 0x314 - digest register 1
        volatile uint32_t HR2;  ///< Offset: 0x318 - digest register 4
        volatile uint32_t HR3;  ///< Offset: 0x31C - digest register 3
        volatile uint32_t HR4;  ///< Offset: 0x320 - digest register 4
        volatile uint32_t HR5;  ///< Offset: 0x324 - supplementary digest register 5
        volatile uint32_t HR6;  ///< Offset: 0x328 - supplementary digest register 6
        volatile uint32_t HR7;  ///< Offset: 0x32C - supplementary digest register 7
        volatile uint32_t IMR;  ///< Offset: 0x20 - interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x24 - status register
        volatile uint32_t CSR0;  ///< Offset: 0xF8 - context swap registers
        volatile uint32_t CSR1;  ///< Offset: 0xFC - context swap registers
        volatile uint32_t CSR2;  ///< Offset: 0x100 - context swap registers
        volatile uint32_t CSR3;  ///< Offset: 0x104 - context swap registers
        volatile uint32_t CSR4;  ///< Offset: 0x108 - context swap registers
        volatile uint32_t CSR5;  ///< Offset: 0x10C - context swap registers
        volatile uint32_t CSR6;  ///< Offset: 0x110 - context swap registers
        volatile uint32_t CSR7;  ///< Offset: 0x114 - context swap registers
        volatile uint32_t CSR8;  ///< Offset: 0x118 - context swap registers
        volatile uint32_t CSR9;  ///< Offset: 0x11C - context swap registers
        volatile uint32_t CSR10;  ///< Offset: 0x120 - context swap registers
        volatile uint32_t CSR11;  ///< Offset: 0x124 - context swap registers
        volatile uint32_t CSR12;  ///< Offset: 0x128 - context swap registers
        volatile uint32_t CSR13;  ///< Offset: 0x12C - context swap registers
        volatile uint32_t CSR14;  ///< Offset: 0x130 - context swap registers
        volatile uint32_t CSR15;  ///< Offset: 0x134 - context swap registers
        volatile uint32_t CSR16;  ///< Offset: 0x138 - context swap registers
        volatile uint32_t CSR17;  ///< Offset: 0x13C - context swap registers
        volatile uint32_t CSR18;  ///< Offset: 0x140 - context swap registers
        volatile uint32_t CSR19;  ///< Offset: 0x144 - context swap registers
        volatile uint32_t CSR20;  ///< Offset: 0x148 - context swap registers
        volatile uint32_t CSR21;  ///< Offset: 0x14C - context swap registers
        volatile uint32_t CSR22;  ///< Offset: 0x150 - context swap registers
        volatile uint32_t CSR23;  ///< Offset: 0x154 - context swap registers
        volatile uint32_t CSR24;  ///< Offset: 0x158 - context swap registers
        volatile uint32_t CSR25;  ///< Offset: 0x15C - context swap registers
        volatile uint32_t CSR26;  ///< Offset: 0x160 - context swap registers
        volatile uint32_t CSR27;  ///< Offset: 0x164 - context swap registers
        volatile uint32_t CSR28;  ///< Offset: 0x168 - context swap registers
        volatile uint32_t CSR29;  ///< Offset: 0x16C - context swap registers
        volatile uint32_t CSR30;  ///< Offset: 0x170 - context swap registers
        volatile uint32_t CSR31;  ///< Offset: 0x174 - context swap registers
        volatile uint32_t CSR32;  ///< Offset: 0x178 - context swap registers
        volatile uint32_t CSR33;  ///< Offset: 0x17C - context swap registers
        volatile uint32_t CSR34;  ///< Offset: 0x180 - context swap registers
        volatile uint32_t CSR35;  ///< Offset: 0x184 - context swap registers
        volatile uint32_t CSR36;  ///< Offset: 0x188 - context swap registers
        volatile uint32_t CSR37;  ///< Offset: 0x18C - context swap registers
        volatile uint32_t CSR38;  ///< Offset: 0x190 - context swap registers
        volatile uint32_t CSR39;  ///< Offset: 0x194 - context swap registers
        volatile uint32_t CSR40;  ///< Offset: 0x198 - context swap registers
        volatile uint32_t CSR41;  ///< Offset: 0x19C - context swap registers
        volatile uint32_t CSR42;  ///< Offset: 0x1A0 - context swap registers
        volatile uint32_t CSR43;  ///< Offset: 0x1A4 - context swap registers
        volatile uint32_t CSR44;  ///< Offset: 0x1A8 - context swap registers
        volatile uint32_t CSR45;  ///< Offset: 0x1AC - context swap registers
        volatile uint32_t CSR46;  ///< Offset: 0x1B0 - context swap registers
        volatile uint32_t CSR47;  ///< Offset: 0x1B4 - context swap registers
        volatile uint32_t CSR48;  ///< Offset: 0x1B8 - context swap registers
        volatile uint32_t CSR49;  ///< Offset: 0x1BC - context swap registers
        volatile uint32_t CSR50;  ///< Offset: 0x1C0 - context swap registers
        volatile uint32_t CSR51;  ///< Offset: 0x1C4 - context swap registers
        volatile uint32_t CSR52;  ///< Offset: 0x1C8 - context swap registers
        volatile uint32_t CSR53;  ///< Offset: 0x1CC - context swap registers
    };

    /// Peripheral instances
    inline Registers* HASH = reinterpret_cast<Registers*>(HASH_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t INIT = (1U << 2);  ///< Initialize message digest calculation
        constexpr uint32_t DMAE = (1U << 3);  ///< DMA enable
        constexpr uint32_t DATATYPE = (2 << 4);  ///< Data type selection
        constexpr uint32_t MODE = (1U << 6);  ///< Mode selection
        constexpr uint32_t ALGO = (2 << 17);  ///< Algorithm selection
        constexpr uint32_t NBW = (4 << 8);  ///< Number of words already pushed
        constexpr uint32_t DINNE = (1U << 12);  ///< DIN not empty
        constexpr uint32_t MDMAT = (1U << 13);  ///< Multiple DMA Transfers
        constexpr uint32_t LKEY = (1U << 16);  ///< Long key selection
    }

    /// DIN Register bits
    namespace din_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Data input
    }

    /// STR Register bits
    namespace str_bits {
        constexpr uint32_t DCAL = (1U << 8);  ///< Digest calculation
        constexpr uint32_t NBLW = (5 << 0);  ///< Number of valid bits in the last word of the message
    }

    /// HRA0 Register bits
    namespace hra0_bits {
        constexpr uint32_t H0 = (32 << 0);  ///< H0
    }

    /// HRA1 Register bits
    namespace hra1_bits {
        constexpr uint32_t H1 = (32 << 0);  ///< H1
    }

    /// HRA2 Register bits
    namespace hra2_bits {
        constexpr uint32_t H2 = (32 << 0);  ///< H2
    }

    /// HRA3 Register bits
    namespace hra3_bits {
        constexpr uint32_t H3 = (32 << 0);  ///< H3
    }

    /// HRA4 Register bits
    namespace hra4_bits {
        constexpr uint32_t H4 = (32 << 0);  ///< H4
    }

    /// HR0 Register bits
    namespace hr0_bits {
        constexpr uint32_t H0 = (32 << 0);  ///< H0
    }

    /// HR1 Register bits
    namespace hr1_bits {
        constexpr uint32_t H1 = (32 << 0);  ///< H1
    }

    /// HR2 Register bits
    namespace hr2_bits {
        constexpr uint32_t H2 = (32 << 0);  ///< H2
    }

    /// HR3 Register bits
    namespace hr3_bits {
        constexpr uint32_t H3 = (32 << 0);  ///< H3
    }

    /// HR4 Register bits
    namespace hr4_bits {
        constexpr uint32_t H4 = (32 << 0);  ///< H4
    }

    /// HR5 Register bits
    namespace hr5_bits {
        constexpr uint32_t H5 = (32 << 0);  ///< H5
    }

    /// HR6 Register bits
    namespace hr6_bits {
        constexpr uint32_t H6 = (32 << 0);  ///< H6
    }

    /// HR7 Register bits
    namespace hr7_bits {
        constexpr uint32_t H7 = (32 << 0);  ///< H7
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t DCIE = (1U << 1);  ///< Digest calculation completion interrupt enable
        constexpr uint32_t DINIE = (1U << 0);  ///< Data input interrupt enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t BUSY = (1U << 3);  ///< Busy bit
        constexpr uint32_t DMAS = (1U << 2);  ///< DMA Status
        constexpr uint32_t DCIS = (1U << 1);  ///< Digest calculation completion interrupt status
        constexpr uint32_t DINIS = (1U << 0);  ///< Data input interrupt status
        constexpr uint32_t NBWE = (5 << 16);  ///< Number of words expected
        constexpr uint32_t DINNE = (1U << 15);  ///< DIN not empty
        constexpr uint32_t NBWP = (5 << 9);  ///< Number of words already pushed
    }

    /// CSR0 Register bits
    namespace csr0_bits {
        constexpr uint32_t CS0 = (32 << 0);  ///< CS0
    }

    /// CSR1 Register bits
    namespace csr1_bits {
        constexpr uint32_t CS1 = (32 << 0);  ///< CS1
    }

    /// CSR2 Register bits
    namespace csr2_bits {
        constexpr uint32_t CS2 = (32 << 0);  ///< CS2
    }

    /// CSR3 Register bits
    namespace csr3_bits {
        constexpr uint32_t CS3 = (32 << 0);  ///< CS3
    }

    /// CSR4 Register bits
    namespace csr4_bits {
        constexpr uint32_t CS4 = (32 << 0);  ///< CS4
    }

    /// CSR5 Register bits
    namespace csr5_bits {
        constexpr uint32_t CS5 = (32 << 0);  ///< CS5
    }

    /// CSR6 Register bits
    namespace csr6_bits {
        constexpr uint32_t CS6 = (32 << 0);  ///< CS6
    }

    /// CSR7 Register bits
    namespace csr7_bits {
        constexpr uint32_t CS7 = (32 << 0);  ///< CS7
    }

    /// CSR8 Register bits
    namespace csr8_bits {
        constexpr uint32_t CS8 = (32 << 0);  ///< CS8
    }

    /// CSR9 Register bits
    namespace csr9_bits {
        constexpr uint32_t CS9 = (32 << 0);  ///< CS9
    }

    /// CSR10 Register bits
    namespace csr10_bits {
        constexpr uint32_t CS10 = (32 << 0);  ///< CS10
    }

    /// CSR11 Register bits
    namespace csr11_bits {
        constexpr uint32_t CS11 = (32 << 0);  ///< CS11
    }

    /// CSR12 Register bits
    namespace csr12_bits {
        constexpr uint32_t CS12 = (32 << 0);  ///< CS12
    }

    /// CSR13 Register bits
    namespace csr13_bits {
        constexpr uint32_t CS13 = (32 << 0);  ///< CS13
    }

    /// CSR14 Register bits
    namespace csr14_bits {
        constexpr uint32_t CS14 = (32 << 0);  ///< CS14
    }

    /// CSR15 Register bits
    namespace csr15_bits {
        constexpr uint32_t CS15 = (32 << 0);  ///< CS15
    }

    /// CSR16 Register bits
    namespace csr16_bits {
        constexpr uint32_t CS16 = (32 << 0);  ///< CS16
    }

    /// CSR17 Register bits
    namespace csr17_bits {
        constexpr uint32_t CS17 = (32 << 0);  ///< CS17
    }

    /// CSR18 Register bits
    namespace csr18_bits {
        constexpr uint32_t CS18 = (32 << 0);  ///< CS18
    }

    /// CSR19 Register bits
    namespace csr19_bits {
        constexpr uint32_t CS19 = (32 << 0);  ///< CS19
    }

    /// CSR20 Register bits
    namespace csr20_bits {
        constexpr uint32_t CS20 = (32 << 0);  ///< CS20
    }

    /// CSR21 Register bits
    namespace csr21_bits {
        constexpr uint32_t CS21 = (32 << 0);  ///< CS21
    }

    /// CSR22 Register bits
    namespace csr22_bits {
        constexpr uint32_t CS22 = (32 << 0);  ///< CS22
    }

    /// CSR23 Register bits
    namespace csr23_bits {
        constexpr uint32_t CS23 = (32 << 0);  ///< CS23
    }

    /// CSR24 Register bits
    namespace csr24_bits {
        constexpr uint32_t CS24 = (32 << 0);  ///< CS24
    }

    /// CSR25 Register bits
    namespace csr25_bits {
        constexpr uint32_t CS25 = (32 << 0);  ///< CS25
    }

    /// CSR26 Register bits
    namespace csr26_bits {
        constexpr uint32_t CS26 = (32 << 0);  ///< CS26
    }

    /// CSR27 Register bits
    namespace csr27_bits {
        constexpr uint32_t CS27 = (32 << 0);  ///< CS27
    }

    /// CSR28 Register bits
    namespace csr28_bits {
        constexpr uint32_t CS28 = (32 << 0);  ///< CS28
    }

    /// CSR29 Register bits
    namespace csr29_bits {
        constexpr uint32_t CS29 = (32 << 0);  ///< CS29
    }

    /// CSR30 Register bits
    namespace csr30_bits {
        constexpr uint32_t CS30 = (32 << 0);  ///< CS30
    }

    /// CSR31 Register bits
    namespace csr31_bits {
        constexpr uint32_t CS31 = (32 << 0);  ///< CS31
    }

    /// CSR32 Register bits
    namespace csr32_bits {
        constexpr uint32_t CS32 = (32 << 0);  ///< CS32
    }

    /// CSR33 Register bits
    namespace csr33_bits {
        constexpr uint32_t CS33 = (32 << 0);  ///< CS33
    }

    /// CSR34 Register bits
    namespace csr34_bits {
        constexpr uint32_t CS34 = (32 << 0);  ///< CS34
    }

    /// CSR35 Register bits
    namespace csr35_bits {
        constexpr uint32_t CS35 = (32 << 0);  ///< CS35
    }

    /// CSR36 Register bits
    namespace csr36_bits {
        constexpr uint32_t CS36 = (32 << 0);  ///< CS36
    }

    /// CSR37 Register bits
    namespace csr37_bits {
        constexpr uint32_t CS37 = (32 << 0);  ///< CS37
    }

    /// CSR38 Register bits
    namespace csr38_bits {
        constexpr uint32_t CS38 = (32 << 0);  ///< CS38
    }

    /// CSR39 Register bits
    namespace csr39_bits {
        constexpr uint32_t CS39 = (32 << 0);  ///< CS39
    }

    /// CSR40 Register bits
    namespace csr40_bits {
        constexpr uint32_t CS40 = (32 << 0);  ///< CS40
    }

    /// CSR41 Register bits
    namespace csr41_bits {
        constexpr uint32_t CS41 = (32 << 0);  ///< CS41
    }

    /// CSR42 Register bits
    namespace csr42_bits {
        constexpr uint32_t CS42 = (32 << 0);  ///< CS42
    }

    /// CSR43 Register bits
    namespace csr43_bits {
        constexpr uint32_t CS43 = (32 << 0);  ///< CS43
    }

    /// CSR44 Register bits
    namespace csr44_bits {
        constexpr uint32_t CS44 = (32 << 0);  ///< CS44
    }

    /// CSR45 Register bits
    namespace csr45_bits {
        constexpr uint32_t CS45 = (32 << 0);  ///< CS45
    }

    /// CSR46 Register bits
    namespace csr46_bits {
        constexpr uint32_t CS46 = (32 << 0);  ///< CS46
    }

    /// CSR47 Register bits
    namespace csr47_bits {
        constexpr uint32_t CS47 = (32 << 0);  ///< CS47
    }

    /// CSR48 Register bits
    namespace csr48_bits {
        constexpr uint32_t CS48 = (32 << 0);  ///< CS48
    }

    /// CSR49 Register bits
    namespace csr49_bits {
        constexpr uint32_t CS49 = (32 << 0);  ///< CS49
    }

    /// CSR50 Register bits
    namespace csr50_bits {
        constexpr uint32_t CS50 = (32 << 0);  ///< CS50
    }

    /// CSR51 Register bits
    namespace csr51_bits {
        constexpr uint32_t CS51 = (32 << 0);  ///< CS51
    }

    /// CSR52 Register bits
    namespace csr52_bits {
        constexpr uint32_t CS52 = (32 << 0);  ///< CS52
    }

    /// CSR53 Register bits
    namespace csr53_bits {
        constexpr uint32_t CS53 = (32 << 0);  ///< CS53
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t HSPI1_BASE = 0x420D3400;
    constexpr uint32_t SEC_HSPI1_BASE = 0x520D3400;
    constexpr uint32_t OCTOSPI1_BASE = 0x420D1400;
    constexpr uint32_t SEC_OCTOSPI1_BASE = 0x520D1400;
    constexpr uint32_t OCTOSPI2_BASE = 0x420D2400;
    constexpr uint32_t SEC_OCTOSPI2_BASE = 0x520D2400;
    constexpr uint32_t OCTOSPIM_BASE = 0x420C4000;
    constexpr uint32_t SEC_OCTOSPIM_BASE = 0x520C4000;
    constexpr uint32_t SPI1_BASE = 0x40013000;
    constexpr uint32_t SEC_SPI1_BASE = 0x50013000;
    constexpr uint32_t SPI2_BASE = 0x40003800;
    constexpr uint32_t SEC_SPI2_BASE = 0x50003800;
    constexpr uint32_t SPI3_BASE = 0x46002000;
    constexpr uint32_t SEC_SPI3_BASE = 0x56002000;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t HSPI_CR;  ///< Offset: 0x00 - HSPI control register
        volatile uint32_t HSPI_DCR1;  ///< Offset: 0x08 - HSPI device configuration register 1
        volatile uint32_t HSPI_DCR2;  ///< Offset: 0x0C - HSPI device configuration register 2
        volatile uint32_t HSPI_DCR3;  ///< Offset: 0x10 - HSPI device configuration register 3
        volatile uint32_t HSPI_DCR4;  ///< Offset: 0x14 - HSPI device configuration register 4
        volatile uint32_t HSPI_SR;  ///< Offset: 0x20 - Transfer error flag This bit is set in Indirect mode...
        volatile uint32_t HSPI_FCR;  ///< Offset: 0x24 - Clear transfer error flag Writing 1 clears the TEF flag...
        volatile uint32_t HSPI_DLR;  ///< Offset: 0x40 - HSPI data length register
        volatile uint32_t HSPI_AR;  ///< Offset: 0x48 - Address Address to be sent to the external device. In...
        volatile uint32_t HSPI_DR;  ///< Offset: 0x50 - [31: 0]: Data Data to be sent/received to/from the...
        volatile uint32_t HSPI_PSMKR;  ///< Offset: 0x80 - HSPI polling status mask register
        volatile uint32_t HSPI_PSMAR;  ///< Offset: 0x88 - HSPI polling status match register
        volatile uint32_t HSPI_PIR;  ///< Offset: 0x90 - HSPI polling interval register
        volatile uint32_t HSPI_CCR;  ///< Offset: 0x100 - HSPI communication configuration register
        volatile uint32_t HSPI_TCR;  ///< Offset: 0x108 - HSPI timing configuration register
        volatile uint32_t HSPI_IR;  ///< Offset: 0x110 - HSPI instruction register
        volatile uint32_t HSPI_ABR;  ///< Offset: 0x120 - HSPI alternate bytes register
        volatile uint32_t HSPI_LPTR;  ///< Offset: 0x130 - HSPI low-power timeout register
        volatile uint32_t HSPI_WPCCR;  ///< Offset: 0x140 - HSPI wrap communication configuration register
        volatile uint32_t HSPI_WPTCR;  ///< Offset: 0x148 - HSPI wrap timing configuration register
        volatile uint32_t HSPI_WPIR;  ///< Offset: 0x150 - HSPI wrap instruction register
        volatile uint32_t HSPI_WPABR;  ///< Offset: 0x160 - HSPI wrap alternate bytes register
        volatile uint32_t HSPI_WCCR;  ///< Offset: 0x180 - HSPI write communication configuration register
        volatile uint32_t HSPI_WTCR;  ///< Offset: 0x188 - HSPI write timing configuration register
        volatile uint32_t HSPI_WIR;  ///< Offset: 0x190 - HSPI write instruction register
        volatile uint32_t HSPI_WABR;  ///< Offset: 0x1A0 - HSPI write alternate bytes register
        volatile uint32_t HSPI_HLCR;  ///< Offset: 0x200 - HSPI HyperBus latency configuration register
        volatile uint32_t HSPI_CALFCR;  ///< Offset: 0x210 - HSPI full-cycle calibration configuration
        volatile uint32_t HSPI_CALMR;  ///< Offset: 0x218 - HSPI DLL master calibration configuration
        volatile uint32_t HSPI_CALSOR;  ///< Offset: 0x220 - HSPI DLL slave output calibration configuration
        volatile uint32_t HSPI_CALSIR;  ///< Offset: 0x228 - HSPI DLL slave input calibration configuration
    };

    /// Peripheral instances
    inline Registers* HSPI1 = reinterpret_cast<Registers*>(HSPI1_BASE);
    inline Registers* SEC_HSPI1 = reinterpret_cast<Registers*>(SEC_HSPI1_BASE);
    inline Registers* OCTOSPI1 = reinterpret_cast<Registers*>(OCTOSPI1_BASE);
    inline Registers* SEC_OCTOSPI1 = reinterpret_cast<Registers*>(SEC_OCTOSPI1_BASE);
    inline Registers* OCTOSPI2 = reinterpret_cast<Registers*>(OCTOSPI2_BASE);
    inline Registers* SEC_OCTOSPI2 = reinterpret_cast<Registers*>(SEC_OCTOSPI2_BASE);
    inline Registers* OCTOSPIM = reinterpret_cast<Registers*>(OCTOSPIM_BASE);
    inline Registers* SEC_OCTOSPIM = reinterpret_cast<Registers*>(SEC_OCTOSPIM_BASE);
    inline Registers* SPI1 = reinterpret_cast<Registers*>(SPI1_BASE);
    inline Registers* SEC_SPI1 = reinterpret_cast<Registers*>(SEC_SPI1_BASE);
    inline Registers* SPI2 = reinterpret_cast<Registers*>(SPI2_BASE);
    inline Registers* SEC_SPI2 = reinterpret_cast<Registers*>(SEC_SPI2_BASE);
    inline Registers* SPI3 = reinterpret_cast<Registers*>(SPI3_BASE);
    inline Registers* SEC_SPI3 = reinterpret_cast<Registers*>(SEC_SPI3_BASE);

    // Bit definitions
    /// HSPI_CR Register bits
    namespace hspi_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< Enable This bit enables the HSPI. Note: The DMA request can be aborted without having received the ACK in case this EN bit is cleared during the operation. In case this bit is set to 0 during a DMA transfer, the REQ signal to DMA returns to inactive state without waiting for the ACK signal from DMA to be active.
        constexpr uint32_t ABORT = (1U << 1);  ///< Abort request This bit aborts the on-going command sequence. It is automatically reset once the abort is completed. This bit stops the current transfer. Note: This bit is always read as 0.
        constexpr uint32_t DMAEN = (1U << 2);  ///< DMA enable In Indirect mode, the DMA can be used to input or output data via HSPI_DR. DMA transfers are initiated when FTF is set. Note: Resetting the DMAEN bit while a DMA transfer is ongoing, breaks the handshake with the DMA. Do not write this bit during DMA operation.
        constexpr uint32_t TCEN = (1U << 3);  ///< Timeout counter enable This bit is valid only when the Memory-mapped mode (FMODE[1:0]Â =Â 11) is selected. This bit enables the timeout counter.
        constexpr uint32_t DMM = (1U << 6);  ///< Dual-memory mode This bit activates the Dual-memory mode, where two external devices are used simultaneously to double the throughput and the capacity
        constexpr uint32_t FSEL = (1U << 7);  ///< Memory select This bit is the mirror of bit 30. Refer to the description of MSEL[1:0] above. This bit is set when 1 is written in bit 30 or bit 7. When this bit is set, both b30 and b7 are read as 1. This bit is reset when bit 30 and bit7 are set to 0. When this bit is reset, both bit 30 and bit7 are read as 0.
        constexpr uint32_t FTHRES = (6 << 8);  ///< FIFO threshold level This field defines, in Indirect mode, the threshold number of bytes in the FIFO that causes the FIFO threshold flag FTF in HSPI_SR, to be set. ... Note: If DMAENÂ =Â 1, the DMA controller for the corresponding channel must be disabled before changing the FTHRES[5:0] value.
        constexpr uint32_t TEIE = (1U << 16);  ///< Transfer error interrupt enable This bit enables the transfer error interrupt.
        constexpr uint32_t TCIE = (1U << 17);  ///< Transfer complete interrupt enable This bit enables the transfer complete interrupt.
        constexpr uint32_t FTIE = (1U << 18);  ///< FIFO threshold interrupt enable This bit enables the FIFO threshold interrupt.
        constexpr uint32_t SMIE = (1U << 19);  ///< Status match interrupt enable This bit enables the status match interrupt.
        constexpr uint32_t TOIE = (1U << 20);  ///< Timeout interrupt enable This bit enables the timeout interrupt.
        constexpr uint32_t APMS = (1U << 22);  ///< Automatic-polling mode stop This bit determines if the automatic polling is stopped after a match.
        constexpr uint32_t PMM = (1U << 23);  ///< Polling match mode This bit indicates which method must be used to determine a match during the Automatic-polling mode.
        constexpr uint32_t FMODE = (2 << 28);  ///< Functional mode This field defines the HSPI functional mode of operation. If DMAENÂ =Â 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE[1:0] value. If FMODE[1:0] and FTHRES[4:0] are wrongly updated while DMAENÂ =Â 1, the DMA request signal automatically goes to inactive state.
        constexpr uint32_t MSEL = (2 << 30);  ///< Flash select These bits select the memory to be addressed in Single, Dual, Quad or Octal mode in singleâmemory configuration (when DMM = 0). - when in Quad mode: - when in Octal mode or Dual-quad mode: 0x: data exchanged over IO[7:0] 1x: data exchanged over IO[15:8] These bits are ignored when in dual-octal configuration (data on 8 bits and DMMÂ =Â 1) or 16âbit configuration (data exchanged over IO[15:0]).
    }

    /// HSPI_DCR1 Register bits
    namespace hspi_dcr1_bits {
        constexpr uint32_t CKMODE = (1U << 0);  ///< Mode 0/Mode 3 This bit indicates the level taken by the CLK between commands (when nCSÂ =Â 1).
        constexpr uint32_t FRCK = (1U << 1);  ///< Free running clock This bit configures the free running clock.
        constexpr uint32_t DLYBYP = (1U << 3);  ///< Delay block bypass
        constexpr uint32_t CSHT = (6 << 8);  ///< Chip-select high time CSHTÂ +Â 1 defines the minimum number of CLK cycles where the chip-select (nCS) must remain high between commands issued to the external device. ... 63: nCS stays high for at least 64 cycles between external device commands. Note: When the extended CSHT timeout feature is not supported, CSHT[5:3] are reserved and the number of cycles is limited to eight (refer to implementation).
        constexpr uint32_t DEVSIZE = (5 << 16);  ///< Device size This field defines the size of the external device using the following formula: Number of bytes in device = 2[DEVSIZE+1]. DEVSIZE+1 is effectively the number of address bits required to address the external device. The device capacity can be up to 4Â Gbytes (addressed using 32-bits) in Indirect mode, but the addressable space in Memory-mapped mode is limited to 256Â Mbytes. In Regular-command mode, if DMMÂ =Â 1, DEVSIZE[4:0] indicates the total capacity of the two devices together.
        constexpr uint32_t MTYP = (3 << 24);  ///< Memory type This bit indicates the type of memory to be supported. Note: In this mode, DQS signal polarity is inverted with respect to the memory clock signal. This is the default value and care must be taken to change MTYP[2:0] for memories different from Micron. Others: Reserved
    }

    /// HSPI_DCR2 Register bits
    namespace hspi_dcr2_bits {
        constexpr uint32_t PRESCALER = (8 << 0);  ///< Clock prescaler This field defines the scaler factor for generating the CLK based on the kernel clock (valueÂ +Â 1). 2: FCLK = FKERNEL/3 ... 255: FCLK = FKERNEL/256 For odd clock division factors, the CLK duty cycle is not 50Â %. The clock signal remains low one cycle longer than it stays high. Writing this field automatically starts a new calibration of high-speed interface DLL at the start of next transfer, except in case HSPI_CALOSR or HSPI_CALISR have been written in the meantime. BUSY stays high during the whole calibration execution.
        constexpr uint32_t WRAPSIZE = (3 << 16);  ///< Wrap size This field indicates the wrap size to which the memory is configured. For memories which have a separate command for wrapped instructions, this field indicates the wrap-size associated with the command held in the HSPI_WPIR register. 110-111: Reserved
    }

    /// HSPI_DCR3 Register bits
    namespace hspi_dcr3_bits {
        constexpr uint32_t MAXTRAN = (8 << 0);  ///< Maximum transfer This field enables the communication regulation feature. The nCS is released every MAXTRAN+1 clock cycles when the other HSPI request the access to the bus. others: Maximum communication is set to MAXTRAN+1 bytes
        constexpr uint32_t CSBOUND = (5 << 16);  ///< CS boundary This field enables the transaction boundary feature. When active, a minimum value of 3 is recommended. The nCS is released on each boundary of 2CSBOUND bytes. others: CS boundary set to 2CSBOUND bytes
    }

    /// HSPI_DCR4 Register bits
    namespace hspi_dcr4_bits {
        constexpr uint32_t REFRESH = (32 << 0);  ///< Refresh rate This field enables the refresh rate feature. The nCS is released every REFRESH+1 clock cycles for writes, and REFRESH+4 clock cycles for reads. Note: These two values can be extended with few clock cycles when refresh occurs during a byte transmission in single, dual or quad mode, because the byte transmission must be completed. others: Maximum communication length is set to REFRESH+1 clock cycles.
    }

    /// HSPI_SR Register bits
    namespace hspi_sr_bits {
        constexpr uint32_t TEF = (1U << 0);  ///< Transfer error flag This bit is set in Indirect mode when an invalid address is being accessed in Indirect mode. It is cleared by writing 1 to CTEF.
        constexpr uint32_t TCF = (1U << 1);  ///< Transfer complete flag This bit is set in Indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.It is cleared by writing 1 to CTCF.
        constexpr uint32_t FTF = (1U << 2);  ///< FIFO threshold flag In Indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after the reads from the external device are complete. It is cleared automatically as soon as the threshold condition is no longer true. In Automatic-polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read.
        constexpr uint32_t SMF = (1U << 3);  ///< Status match flag This bit is set in Automatic-polling mode when the unmasked received data matches the corresponding bits in the match register (HSPI_PSMAR). It is cleared by writing 1 to CSMF.
        constexpr uint32_t TOF = (1U << 4);  ///< Timeout flag This bit is set when timeout occurs. It is cleared by writing 1 to CTOF.
        constexpr uint32_t BUSY = (1U << 5);  ///< Busy This bit is set when an operation is ongoing. It is cleared automatically when the operation with the external device is finished and the FIFO is empty.
        constexpr uint32_t FLEVEL = (7 << 8);  ///< FIFO level This field gives the number of valid bytes that are being held in the FIFO. FLEVELÂ =Â 0 when the FIFO is empty, and 64 when it is full. In Automatic-status polling mode, FLEVEL is zero.
    }

    /// HSPI_FCR Register bits
    namespace hspi_fcr_bits {
        constexpr uint32_t CTEF = (1U << 0);  ///< Clear transfer error flag Writing 1 clears the TEF flag in the HSPI_SR register.
        constexpr uint32_t CTCF = (1U << 1);  ///< Clear transfer complete flag Writing 1 clears the TCF flag in the HSPI_SR register.
        constexpr uint32_t CSMF = (1U << 3);  ///< Clear status match flag Writing 1 clears the SMF flag in the HSPI_SR register.
        constexpr uint32_t CTOF = (1U << 4);  ///< Clear timeout flag Writing 1 clears the TOF flag in the HSPI_SR register.
    }

    /// HSPI_DLR Register bits
    namespace hspi_dlr_bits {
        constexpr uint32_t DL = (32 << 0);  ///< [31: 0]: Data length Number of data to be retrieved (value+1) in Indirect and Status-polling modes. A value not greater than three (indicating 4 bytes) must be used for status polling-mode. All 1's in Indirect mode means undefined length, where HSPI continues until the end of the memory, as defined by DEVSIZE. 0x0000_0000: 1 byte is to be transferred. 0x0000_0001: 2 bytes are to be transferred. 0x0000_0002: 3 bytes are to be transferred. 0x0000_0003: 4 bytes are to be transferred. ... 0xFFFF_FFFD: 4,294,967,294 (4G-2) bytes are to be transferred. 0xFFFF_FFFE: 4,294,967,295 (4G-1) bytes are to be transferred. 0xFFFF_FFFF: undefined length; all bytes, until the end of the external device, (as defined by DEVSIZE) are to be transferred. Continue reading indefinitely if DEVSIZEÂ =Â 0x1F. DL[0] is stuck at 1 in Dual-memory mode (DMMÂ =Â 1) even when 0 is written to this bit, thus assuring that each access transfers an even number of bytes. This field has no effect when in Memory-mapped mode.
    }

    /// HSPI_AR Register bits
    namespace hspi_ar_bits {
        constexpr uint32_t ADDRESS = (32 << 0);  ///< Address Address to be sent to the external device. In HyperBus mode, this field must be even as this protocol is 16-bit word oriented. In dual-memory mode, AR[0] is forced to 1. Writes to this field are ignored when BUSYÂ =Â 1 or when FMODE = 11 (Memory-mapped mode).
    }

    /// HSPI_DR Register bits
    namespace hspi_dr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< [31: 0]: Data Data to be sent/received to/from the external SPI device In Indirect-write mode, data written to this register is stored on the FIFO before it is sent to the external device during the data phase. If the FIFO is too full, a write operation is stalled until the FIFO has enough space to accept the amount of data being written. In Indirect-read mode, reading this register gives (via the FIFO) the data that was received from the external device. If the FIFO does not have as many bytes as requested by the read operation and if BUSYÂ =Â 1, the read operation is stalled until enough data is present or until the transfer is complete, whichever happens first. In Automatic-polling mode, this register contains the last data read from the external device (without masking). Word, half-word, and byte accesses to this register are supported. In Indirect-write mode, a byte write adds 1 byte to the FIFO, a half-word write 2 bytes, and a word write 4 bytes. Similarly, in Indirect-read mode, a byte read removes 1 byte from the FIFO, a halfword read 2Â bytes, and a word read 4Â bytes. Accesses in Indirect mode must be aligned to the bottom of this register: A byte read must read DATA[7:0] and a half-word read must read DATA[15:0].
    }

    /// HSPI_PSMKR Register bits
    namespace hspi_psmkr_bits {
        constexpr uint32_t MASK = (32 << 0);  ///< Status mask Mask to be applied to the status bytes received in Polling mode For bit n:
    }

    /// HSPI_PSMAR Register bits
    namespace hspi_psmar_bits {
        constexpr uint32_t MATCH = (32 << 0);  ///< [31: 0]: Status match Value to be compared with the masked status register to get a match
    }

    /// HSPI_PIR Register bits
    namespace hspi_pir_bits {
        constexpr uint32_t INTERVAL = (16 << 0);  ///< [15: 0]: Polling interval Number of CLK cycle between a read during the automatic-polling phases
    }

    /// HSPI_CCR Register bits
    namespace hspi_ccr_bits {
        constexpr uint32_t IMODE = (3 << 0);  ///< Instruction mode This field defines the instruction phase mode of operation. 101-111: Reserved
        constexpr uint32_t IDTR = (1U << 3);  ///< Instruction double transfer rate This bit sets the DTR mode for the instruction phase.
        constexpr uint32_t ISIZE = (2 << 4);  ///< Instruction size This bit defines instruction size.
        constexpr uint32_t ADMODE = (3 << 8);  ///< Address mode This field defines the address phase mode of operation. 101-111: Reserved
        constexpr uint32_t ADDTR = (1U << 11);  ///< Address double transfer rate This bit sets the DTR mode for the address phase.
        constexpr uint32_t ADSIZE = (2 << 12);  ///< Address size This field defines address size.
        constexpr uint32_t ABMODE = (3 << 16);  ///< Alternate-byte mode This field defines the alternate byte phase mode of operation. 100-111: Reserved
        constexpr uint32_t ABDTR = (1U << 19);  ///< Alternate bytes double transfer rate This bit sets the DTR mode for the alternate bytes phase. This field can be written only when BUSYÂ =Â 0.
        constexpr uint32_t ABSIZE = (2 << 20);  ///< Alternate bytes size This bit defines alternate bytes size.
        constexpr uint32_t DMODE = (3 << 24);  ///< Data mode This field defines the data phase mode of operation. 110-111: Reserved
        constexpr uint32_t DDTR = (1U << 27);  ///< Data double transfer rate This bit sets the DTR mode for the data phase.
        constexpr uint32_t DQSE = (1U << 29);  ///< DQS enable This bit enables the data strobe management.
        constexpr uint32_t SIOO = (1U << 31);  ///< Send instruction only once mode This bit has no effect when IMODEÂ =Â 00 (see ).
    }

    /// HSPI_TCR Register bits
    namespace hspi_tcr_bits {
        constexpr uint32_t DCYC = (5 << 0);  ///< Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DTR modes, it specifies a number of CLK cycles (0-31).
        constexpr uint32_t DHQC = (1U << 28);  ///< Delay hold quarter cycle
        constexpr uint32_t SSHIFT = (1U << 30);  ///< Sample shift By default, the HSPI samples data 1/2 of a CLK cycle after the data is driven by the external device. This bit allows the data to be sampled later in order to consider the external signal delays. The software must ensure that SSHIFTÂ =Â 0 when the data phase is configured in DTR mode (when DDTRÂ =Â 1.)
    }

    /// HSPI_IR Register bits
    namespace hspi_ir_bits {
        constexpr uint32_t INSTRUCTION = (32 << 0);  ///< Instruction Instruction to be sent to the external SPI device
    }

    /// HSPI_ABR Register bits
    namespace hspi_abr_bits {
        constexpr uint32_t ALTERNATE = (32 << 0);  ///< [31: 0]: Alternate bytes Optional data to be send to the external SPI device right after the address.
    }

    /// HSPI_LPTR Register bits
    namespace hspi_lptr_bits {
        constexpr uint32_t TIMEOUT = (16 << 0);  ///< [15: 0]: Timeout period After each access in Memory-mapped mode, the HSPI prefetches the subsequent bytes and hold them in the FIFO. This field indicates how many CLK cycles the HSPI waits after the clock becomes inactive and until it raises the nCS, putting the external device in a lower-consumption state.
    }

    /// HSPI_WPCCR Register bits
    namespace hspi_wpccr_bits {
        constexpr uint32_t IMODE = (3 << 0);  ///< Instruction mode This field defines the instruction phase mode of operation. 101-111: Reserved
        constexpr uint32_t IDTR = (1U << 3);  ///< Instruction double transfer rate This bit sets the DTR mode for the instruction phase.
        constexpr uint32_t ISIZE = (2 << 4);  ///< Instruction size This field defines instruction size.
        constexpr uint32_t ADMODE = (3 << 8);  ///< Address mode This field defines the address phase mode of operation. 101-111: Reserved
        constexpr uint32_t ADDTR = (1U << 11);  ///< Address double transfer rate This bit sets the DTR mode for the address phase.
        constexpr uint32_t ADSIZE = (2 << 12);  ///< Address size This field defines address size.
        constexpr uint32_t ABMODE = (3 << 16);  ///< Alternate-byte mode This field defines the alternate byte phase mode of operation.
        constexpr uint32_t ABDTR = (1U << 19);  ///< Alternate bytes double transfer rate This bit sets the DTR mode for the alternate bytes phase.
        constexpr uint32_t ABSIZE = (2 << 20);  ///< Alternate bytes size This bit defines alternate bytes size.
        constexpr uint32_t DMODE = (3 << 24);  ///< Data mode This field defines the data phase mode of operation. 101; Data on 16 lines 110-111: Reserved
        constexpr uint32_t DDTR = (1U << 27);  ///< Data double transfer rate This bit sets the DTR mode for the data phase.
        constexpr uint32_t DQSE = (1U << 29);  ///< DQS enable This bit enables the data strobe management.
    }

    /// HSPI_WPTCR Register bits
    namespace hspi_wptcr_bits {
        constexpr uint32_t DCYC = (5 << 0);  ///< Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DTR modes, it specifies a number of CLK cycles (0-31). It is recommended to have at least 5 dummy cycles when using memories with DQS activated.
        constexpr uint32_t DHQC = (1U << 28);  ///< Delay hold quarter cycle Add a quarter cycle delay on the outputs in DTR communication to match hold requirement.
        constexpr uint32_t SSHIFT = (1U << 30);  ///< Sample shift By default, the HSPI samples data 1/2 of a CLK cycle after the data is driven by the external device. This bit allows the data to be sampled later in order to consider the external signal delays. The firmware must assure that SSHIFT=0 when the data phase is configured in DTR mode (when DDTRÂ =Â 1).
    }

    /// HSPI_WPIR Register bits
    namespace hspi_wpir_bits {
        constexpr uint32_t INSTRUCTION = (32 << 0);  ///< [31: 0]: Instruction Instruction to be sent to the external SPI device
    }

    /// HSPI_WPABR Register bits
    namespace hspi_wpabr_bits {
        constexpr uint32_t ALTERNATE = (32 << 0);  ///< [31: 0]: Alternate bytes Optional data to be sent to the external SPI device right after the address
    }

    /// HSPI_WCCR Register bits
    namespace hspi_wccr_bits {
        constexpr uint32_t IMODE = (3 << 0);  ///< Instruction mode This field defines the instruction phase mode of operation. 101-111: Reserved
        constexpr uint32_t IDTR = (1U << 3);  ///< Instruction double transfer rate This bit sets the DTR mode for the instruction phase.
        constexpr uint32_t ISIZE = (2 << 4);  ///< Instruction size This bit defines instruction size:
        constexpr uint32_t ADMODE = (3 << 8);  ///< Address mode This field defines the address phase mode of operation. 101-111: Reserved
        constexpr uint32_t ADDTR = (1U << 11);  ///< Address double transfer rate This bit sets the DTR mode for the address phase.
        constexpr uint32_t ADSIZE = (2 << 12);  ///< Address size This field defines address size.
        constexpr uint32_t ABMODE = (3 << 16);  ///< Alternate-byte mode This field defines the alternate-byte phase mode of operation. 101-111: Reserved
        constexpr uint32_t ABDTR = (1U << 19);  ///< Alternate bytes double-transfer rate This bit sets the DTR mode for the alternate-bytes phase.
        constexpr uint32_t ABSIZE = (2 << 20);  ///< Alternate bytes size This field defines alternate bytes size:
        constexpr uint32_t DMODE = (3 << 24);  ///< Data mode This field defines the data phase mode of operation.
        constexpr uint32_t DDTR = (1U << 27);  ///< data double transfer rate This bit sets the DTR mode for the data phase.
        constexpr uint32_t DQSE = (1U << 29);  ///< DQS enable This bit enables the data strobe management.
    }

    /// HSPI_WTCR Register bits
    namespace hspi_wtcr_bits {
        constexpr uint32_t DCYC = (5 << 0);  ///< Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DTR modes, it specifies a number of CLK cycles (0-31). It is recommended to have at least 5 dummy cycles when using memories with DQS activated.
    }

    /// HSPI_WIR Register bits
    namespace hspi_wir_bits {
        constexpr uint32_t INSTRUCTION = (32 << 0);  ///< Instruction Instruction to be sent to the external SPI device
    }

    /// HSPI_WABR Register bits
    namespace hspi_wabr_bits {
        constexpr uint32_t ALTERNATE = (32 << 0);  ///< [31: 0]: Alternate bytes Optional data to be sent to the external SPI device right after the address
    }

    /// HSPI_HLCR Register bits
    namespace hspi_hlcr_bits {
        constexpr uint32_t LM = (1U << 0);  ///< Latency mode This bit selects the Latency mode.
        constexpr uint32_t WZL = (1U << 1);  ///< Write zero latency This bit enables zero latency on write operations.
        constexpr uint32_t TACC = (8 << 8);  ///< [7: 0]: Access time Device access time expressed in number of communication clock cycles
        constexpr uint32_t TRWR = (8 << 16);  ///< Read write recovery time Device read write recovery time expressed in number of communication clock cycles
    }

    /// HSPI_CALFCR Register bits
    namespace hspi_calfcr_bits {
        constexpr uint32_t FINE = (7 << 0);  ///< [6: 0]: Fine calibration The unitary value of delay for this field depends on product technology (refer to the product datasheet).
        constexpr uint32_t COARSE = (5 << 16);  ///< [4: 0]: Coarse calibration The unitary value of delay for this field depends on product technology (refer to the product datasheet).
        constexpr uint32_t CALMAX = (1U << 31);  ///< Max value This bit gets set when the memory-clock period is outside the range of DLLM, in which case HSPI_CALFCR and HSPI_CALSR are updated with the values for the maximum delay.
    }

    /// HSPI_CALMR Register bits
    namespace hspi_calmr_bits {
        constexpr uint32_t FINE = (7 << 0);  ///< [6: 0]: Fine calibration The unitary value of delay for this field depends on product technology (refer to the product datasheet).
        constexpr uint32_t COARSE = (5 << 16);  ///< [4: 0]: Coarse calibration The unitary value of delay for this field depends on product technology (refer to the product datasheet).
    }

    /// HSPI_CALSOR Register bits
    namespace hspi_calsor_bits {
        constexpr uint32_t FINE = (7 << 0);  ///< [6: 0]: Fine calibration The unitary value of delay for this field depends on product technology (refer to the product datasheet).
        constexpr uint32_t COARSE = (5 << 16);  ///< [4: 0]: Coarse calibration The unitary value of delay for this field depends on product technology (refer to the product datasheet).
    }

    /// HSPI_CALSIR Register bits
    namespace hspi_calsir_bits {
        constexpr uint32_t FINE = (7 << 0);  ///< [6: 0]: Fine calibration The unitary value of delay for this field depends on product technology (refer to the product datasheet).
        constexpr uint32_t COARSE = (5 << 16);  ///< [4: 0]: Coarse calibration The unitary value of delay for this field depends on product technology (refer to the product datasheet).
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t I2C1_BASE = 0x40005400;
    constexpr uint32_t SEC_I2C1_BASE = 0x50005400;
    constexpr uint32_t I2C2_BASE = 0x40005800;
    constexpr uint32_t SEC_I2C2_BASE = 0x50005800;
    constexpr uint32_t I2C3_BASE = 0x46002800;
    constexpr uint32_t SEC_I2C3_BASE = 0x56002800;
    constexpr uint32_t I2C4_BASE = 0x40008400;
    constexpr uint32_t SEC_I2C4_BASE = 0x50008400;
    constexpr uint32_t I2C5_BASE = 0x40009800;
    constexpr uint32_t SEC_I2C5_BASE = 0x50009800;
    constexpr uint32_t I2C6_BASE = 0x40009C00;
    constexpr uint32_t SEC_I2C6_BASE = 0x50009C00;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t OAR1;  ///< Offset: 0x08 - Own address register 1
        volatile uint32_t OAR2;  ///< Offset: 0x0C - Own address register 2
        volatile uint32_t TIMINGR;  ///< Offset: 0x10 - Timing register
        volatile uint32_t TIMEOUTR;  ///< Offset: 0x14 - Status register 1
        volatile uint32_t ISR;  ///< Offset: 0x18 - Interrupt and Status register
        volatile uint32_t ICR;  ///< Offset: 0x1C - Interrupt clear register
        volatile uint32_t PECR;  ///< Offset: 0x20 - PEC register
        volatile uint32_t RXDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TXDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t I2C_AUTOCR;  ///< Offset: 0x2C - I2C Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* I2C1 = reinterpret_cast<Registers*>(I2C1_BASE);
    inline Registers* SEC_I2C1 = reinterpret_cast<Registers*>(SEC_I2C1_BASE);
    inline Registers* I2C2 = reinterpret_cast<Registers*>(I2C2_BASE);
    inline Registers* SEC_I2C2 = reinterpret_cast<Registers*>(SEC_I2C2_BASE);
    inline Registers* I2C3 = reinterpret_cast<Registers*>(I2C3_BASE);
    inline Registers* SEC_I2C3 = reinterpret_cast<Registers*>(SEC_I2C3_BASE);
    inline Registers* I2C4 = reinterpret_cast<Registers*>(I2C4_BASE);
    inline Registers* SEC_I2C4 = reinterpret_cast<Registers*>(SEC_I2C4_BASE);
    inline Registers* I2C5 = reinterpret_cast<Registers*>(I2C5_BASE);
    inline Registers* SEC_I2C5 = reinterpret_cast<Registers*>(SEC_I2C5_BASE);
    inline Registers* I2C6 = reinterpret_cast<Registers*>(I2C6_BASE);
    inline Registers* SEC_I2C6 = reinterpret_cast<Registers*>(SEC_I2C6_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t PE = (1U << 0);  ///< Peripheral enable
        constexpr uint32_t TXIE = (1U << 1);  ///< TX Interrupt enable
        constexpr uint32_t RXIE = (1U << 2);  ///< RX Interrupt enable
        constexpr uint32_t ADDRIE = (1U << 3);  ///< Address match interrupt enable (slave only)
        constexpr uint32_t NACKIE = (1U << 4);  ///< Not acknowledge received interrupt enable
        constexpr uint32_t STOPIE = (1U << 5);  ///< STOP detection Interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transfer Complete interrupt enable
        constexpr uint32_t ERRIE = (1U << 7);  ///< Error interrupts enable
        constexpr uint32_t DNF = (4 << 8);  ///< Digital noise filter
        constexpr uint32_t ANFOFF = (1U << 12);  ///< Analog noise filter OFF
        constexpr uint32_t TXDMAEN = (1U << 14);  ///< DMA transmission requests enable
        constexpr uint32_t RXDMAEN = (1U << 15);  ///< DMA reception requests enable
        constexpr uint32_t SBC = (1U << 16);  ///< Slave byte control
        constexpr uint32_t NOSTRETCH = (1U << 17);  ///< Clock stretching disable
        constexpr uint32_t WUPEN = (1U << 18);  ///< Wakeup from STOP enable
        constexpr uint32_t GCEN = (1U << 19);  ///< General call enable
        constexpr uint32_t SMBHEN = (1U << 20);  ///< SMBus Host address enable
        constexpr uint32_t SMBDEN = (1U << 21);  ///< SMBus Device Default address enable
        constexpr uint32_t ALERTEN = (1U << 22);  ///< SMBUS alert enable
        constexpr uint32_t PECEN = (1U << 23);  ///< PEC enable
        constexpr uint32_t FMP = (1U << 24);  ///< Fast-mode Plus 20 mA drive enable
        constexpr uint32_t ADDRACLR = (1U << 30);  ///< Address match flag (ADDR) automatic clear
        constexpr uint32_t STOPFACLR = (1U << 31);  ///< STOP detection flag (STOPF) automatic clear
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t PECBYTE = (1U << 26);  ///< Packet error checking byte
        constexpr uint32_t AUTOEND = (1U << 25);  ///< Automatic end mode (master mode)
        constexpr uint32_t RELOAD = (1U << 24);  ///< NBYTES reload mode
        constexpr uint32_t NBYTES = (8 << 16);  ///< Number of bytes
        constexpr uint32_t NACK = (1U << 15);  ///< NACK generation (slave mode)
        constexpr uint32_t STOP = (1U << 14);  ///< Stop generation (master mode)
        constexpr uint32_t START = (1U << 13);  ///< Start generation
        constexpr uint32_t HEAD10R = (1U << 12);  ///< 10-bit address header only read direction (master receiver mode)
        constexpr uint32_t ADD10 = (1U << 11);  ///< 10-bit addressing mode (master mode)
        constexpr uint32_t RD_WRN = (1U << 10);  ///< Transfer direction (master mode)
        constexpr uint32_t SADD = (10 << 0);  ///< Slave address bit (master mode)
    }

    /// OAR1 Register bits
    namespace oar1_bits {
        constexpr uint32_t OA1 = (10 << 0);  ///< Interface address
        constexpr uint32_t OA1MODE = (1U << 10);  ///< Own Address 1 10-bit mode
        constexpr uint32_t OA1EN = (1U << 15);  ///< Own Address 1 enable
    }

    /// OAR2 Register bits
    namespace oar2_bits {
        constexpr uint32_t OA2 = (7 << 1);  ///< Interface address
        constexpr uint32_t OA2MSK = (3 << 8);  ///< Own Address 2 masks
        constexpr uint32_t OA2EN = (1U << 15);  ///< Own Address 2 enable
    }

    /// TIMINGR Register bits
    namespace timingr_bits {
        constexpr uint32_t SCLL = (8 << 0);  ///< SCL low period (master mode)
        constexpr uint32_t SCLH = (8 << 8);  ///< SCL high period (master mode)
        constexpr uint32_t SDADEL = (4 << 16);  ///< Data hold time
        constexpr uint32_t SCLDEL = (4 << 20);  ///< Data setup time
        constexpr uint32_t PRESC = (4 << 28);  ///< Timing prescaler
    }

    /// TIMEOUTR Register bits
    namespace timeoutr_bits {
        constexpr uint32_t TIMEOUTA = (12 << 0);  ///< Bus timeout A
        constexpr uint32_t TIDLE = (1U << 12);  ///< Idle clock timeout detection
        constexpr uint32_t TIMOUTEN = (1U << 15);  ///< Clock timeout enable
        constexpr uint32_t TIMEOUTB = (12 << 16);  ///< Bus timeout B
        constexpr uint32_t TEXTEN = (1U << 31);  ///< Extended clock timeout enable
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t ADDCODE = (7 << 17);  ///< Address match code (Slave mode)
        constexpr uint32_t DIR = (1U << 16);  ///< Transfer direction (Slave mode)
        constexpr uint32_t BUSY = (1U << 15);  ///< Bus busy
        constexpr uint32_t ALERT = (1U << 13);  ///< SMBus alert
        constexpr uint32_t TIMEOUT = (1U << 12);  ///< Timeout or t_low detection flag
        constexpr uint32_t PECERR = (1U << 11);  ///< PEC Error in reception
        constexpr uint32_t OVR = (1U << 10);  ///< Overrun/Underrun (slave mode)
        constexpr uint32_t ARLO = (1U << 9);  ///< Arbitration lost
        constexpr uint32_t BERR = (1U << 8);  ///< Bus error
        constexpr uint32_t TCR = (1U << 7);  ///< Transfer Complete Reload
        constexpr uint32_t TC = (1U << 6);  ///< Transfer Complete (master mode)
        constexpr uint32_t STOPF = (1U << 5);  ///< Stop detection flag
        constexpr uint32_t NACKF = (1U << 4);  ///< Not acknowledge received flag
        constexpr uint32_t ADDR = (1U << 3);  ///< Address matched (slave mode)
        constexpr uint32_t RXNE = (1U << 2);  ///< Receive data register not empty (receivers)
        constexpr uint32_t TXIS = (1U << 1);  ///< Transmit interrupt status (transmitters)
        constexpr uint32_t TXE = (1U << 0);  ///< Transmit data register empty (transmitters)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t ALERTCF = (1U << 13);  ///< Alert flag clear
        constexpr uint32_t TIMOUTCF = (1U << 12);  ///< Timeout detection flag clear
        constexpr uint32_t PECCF = (1U << 11);  ///< PEC Error flag clear
        constexpr uint32_t OVRCF = (1U << 10);  ///< Overrun/Underrun flag clear
        constexpr uint32_t ARLOCF = (1U << 9);  ///< Arbitration lost flag clear
        constexpr uint32_t BERRCF = (1U << 8);  ///< Bus error flag clear
        constexpr uint32_t STOPCF = (1U << 5);  ///< Stop detection flag clear
        constexpr uint32_t NACKCF = (1U << 4);  ///< Not Acknowledge flag clear
        constexpr uint32_t ADDRCF = (1U << 3);  ///< Address Matched flag clear
    }

    /// PECR Register bits
    namespace pecr_bits {
        constexpr uint32_t PEC = (8 << 0);  ///< Packet error checking register
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< 8-bit receive data
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< 8-bit transmit data
    }

    /// I2C_AUTOCR Register bits
    namespace i2c_autocr_bits {
        constexpr uint32_t TCDMAEN = (1U << 6);  ///< DMA request enable on Transfer Complete event
        constexpr uint32_t TCRDMAEN = (1U << 7);  ///< DMA request enable on Transfer Complete Reload event
        constexpr uint32_t TRIGSEL = (4 << 16);  ///< Trigger selection
        constexpr uint32_t TRIGPOL = (1U << 20);  ///< Trigger polarity
        constexpr uint32_t TRIGEN = (1U << 21);  ///< Trigger enable
    }

}

// ============================================================================
// ICache Peripheral
// ============================================================================

namespace icache {
    /// Base addresses
    constexpr uint32_t ICache_BASE = 0x40030400;

    /// ICache Register structure
    struct Registers {
        volatile uint32_t ICACHE_CR;  ///< Offset: 0x00 - ICACHE control register
        volatile uint32_t ICACHE_SR;  ///< Offset: 0x04 - ICACHE status register
        volatile uint32_t ICACHE_IER;  ///< Offset: 0x08 - ICACHE interrupt enable register
        volatile uint32_t ICACHE_FCR;  ///< Offset: 0x0C - ICACHE flag clear register
        volatile uint32_t ICACHE_HMONR;  ///< Offset: 0x10 - ICACHE hit monitor register
        volatile uint32_t ICACHE_MMONR;  ///< Offset: 0x14 - ICACHE miss monitor register
        volatile uint32_t ICACHE_CRR0;  ///< Offset: 0x20 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR1;  ///< Offset: 0x24 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR2;  ///< Offset: 0x28 - ICACHE region configuration register
        volatile uint32_t ICACHE_CRR3;  ///< Offset: 0x2C - ICACHE region configuration register
    };

    /// Peripheral instances
    inline Registers* ICache = reinterpret_cast<Registers*>(ICache_BASE);

    // Bit definitions
    /// ICACHE_CR Register bits
    namespace icache_cr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t CACHEINV = (1U << 1);  ///< CACHEINV
        constexpr uint32_t WAYSEL = (1U << 2);  ///< WAYSEL
        constexpr uint32_t HITMEN = (1U << 16);  ///< HITMEN
        constexpr uint32_t MISSMEN = (1U << 17);  ///< MISSMEN
        constexpr uint32_t HITMRST = (1U << 18);  ///< HITMRST
        constexpr uint32_t MISSMRST = (1U << 19);  ///< MISSMRST
    }

    /// ICACHE_SR Register bits
    namespace icache_sr_bits {
        constexpr uint32_t BUSYF = (1U << 0);  ///< BUSYF
        constexpr uint32_t BSYENDF = (1U << 1);  ///< BSYENDF
        constexpr uint32_t ERRF = (1U << 2);  ///< ERRF
    }

    /// ICACHE_IER Register bits
    namespace icache_ier_bits {
        constexpr uint32_t BSYENDIE = (1U << 1);  ///< BSYENDIE
        constexpr uint32_t ERRIE = (1U << 2);  ///< ERRIE
    }

    /// ICACHE_FCR Register bits
    namespace icache_fcr_bits {
        constexpr uint32_t CBSYENDF = (1U << 1);  ///< CBSYENDF
        constexpr uint32_t CERRF = (1U << 2);  ///< CERRF
    }

    /// ICACHE_HMONR Register bits
    namespace icache_hmonr_bits {
        constexpr uint32_t HITMON = (32 << 0);  ///< HITMON
    }

    /// ICACHE_MMONR Register bits
    namespace icache_mmonr_bits {
        constexpr uint32_t MISSMON = (16 << 0);  ///< MISSMON
    }

    /// ICACHE_CRR0 Register bits
    namespace icache_crr0_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR1 Register bits
    namespace icache_crr1_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR2 Register bits
    namespace icache_crr2_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

    /// ICACHE_CRR3 Register bits
    namespace icache_crr3_bits {
        constexpr uint32_t BASEADDR = (8 << 0);  ///< BASEADDR
        constexpr uint32_t RSIZE = (3 << 9);  ///< RSIZE
        constexpr uint32_t REN = (1U << 15);  ///< REN
        constexpr uint32_t REMAPADDR = (11 << 16);  ///< REMAPADDR
        constexpr uint32_t MSTSEL = (1U << 28);  ///< MSTSEL
        constexpr uint32_t HBURST = (1U << 31);  ///< HBURST
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t IWDG_BASE = 0x40003000;
    constexpr uint32_t SEC_IWDG_BASE = 0x50003000;
    constexpr uint32_t WWDG_BASE = 0x40002C00;
    constexpr uint32_t SEC_WWDG_BASE = 0x50002C00;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t KR;  ///< Offset: 0x00 - Key register
        volatile uint32_t PR;  ///< Offset: 0x04 - Prescaler register
        volatile uint32_t RLR;  ///< Offset: 0x08 - Reload register
        volatile uint32_t SR;  ///< Offset: 0x0C - Status register
        volatile uint32_t WINR;  ///< Offset: 0x10 - Window register
        volatile uint32_t EWCR;  ///< Offset: 0x14 - IWDG early wakeup interrupt register
    };

    /// Peripheral instances
    inline Registers* IWDG = reinterpret_cast<Registers*>(IWDG_BASE);
    inline Registers* SEC_IWDG = reinterpret_cast<Registers*>(SEC_IWDG_BASE);
    inline Registers* WWDG = reinterpret_cast<Registers*>(WWDG_BASE);
    inline Registers* SEC_WWDG = reinterpret_cast<Registers*>(SEC_WWDG_BASE);

    // Bit definitions
    /// KR Register bits
    namespace kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< Key value (write only, read 0x0000)
    }

    /// PR Register bits
    namespace pr_bits {
        constexpr uint32_t PR = (4 << 0);  ///< Prescaler divider
    }

    /// RLR Register bits
    namespace rlr_bits {
        constexpr uint32_t RL = (12 << 0);  ///< Watchdog counter reload value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t EWIF = (1U << 14);  ///< Watchdog Early interrupt flag
        constexpr uint32_t EWU = (1U << 3);  ///< Watchdog interrupt comparator value update
        constexpr uint32_t WVU = (1U << 2);  ///< Watchdog counter window value update
        constexpr uint32_t RVU = (1U << 1);  ///< Watchdog counter reload value update
        constexpr uint32_t PVU = (1U << 0);  ///< Watchdog prescaler value update
    }

    /// WINR Register bits
    namespace winr_bits {
        constexpr uint32_t WIN = (12 << 0);  ///< Watchdog counter window value
    }

    /// EWCR Register bits
    namespace ewcr_bits {
        constexpr uint32_t EWIT = (12 << 0);  ///< Watchdog counter window value
        constexpr uint32_t EWIC = (1U << 14);  ///< Watchdog early interrupt acknowledge
        constexpr uint32_t EWIE = (1U << 15);  ///< Watchdog early interrupt enable
    }

}

// ============================================================================
// JPEG Peripheral
// ============================================================================

namespace jpeg {
    /// Base addresses
    constexpr uint32_t JPEG_BASE = 0x4002A000;

    /// JPEG Register structure
    struct Registers {
        volatile uint32_t JPEG_CONFR0;  ///< Offset: 0x00 - JPEG codec control register
        volatile uint32_t JPEG_CONFR1;  ///< Offset: 0x04 - JPEG codec configuration register 1
        volatile uint32_t JPEG_CONFR2;  ///< Offset: 0x08 - JPEG codec configuration register 2
        volatile uint32_t JPEG_CONFR3;  ///< Offset: 0x0C - JPEG codec configuration register 3
        volatile uint32_t JPEG_CONFR4;  ///< Offset: 0x10 - JPEG codec configuration register 4
        volatile uint32_t JPEG_CONFR5;  ///< Offset: 0x14 - JPEG codec configuration register 5
        volatile uint32_t JPEG_CONFR6;  ///< Offset: 0x18 - JPEG codec configuration register 6
        volatile uint32_t JPEG_CONFR7;  ///< Offset: 0x1C - JPEG codec configuration register 7
        volatile uint32_t JPEG_CR;  ///< Offset: 0x30 - JPEG control register
        volatile uint32_t JPEG_SR;  ///< Offset: 0x34 - JPEG status register
        volatile uint32_t JPEG_CFR;  ///< Offset: 0x38 - JPEG clear flag register
        volatile uint32_t JPEG_DIR;  ///< Offset: 0x40 - JPEG data input register
        volatile uint32_t JPEG_DOR;  ///< Offset: 0x44 - JPEG data output register
        volatile uint32_t JPEG_QMEM0_0;  ///< Offset: 0x50 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_1;  ///< Offset: 0x54 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_2;  ///< Offset: 0x58 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_3;  ///< Offset: 0x5C - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_4;  ///< Offset: 0x60 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_5;  ///< Offset: 0x64 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_6;  ///< Offset: 0x68 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_7;  ///< Offset: 0x6C - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_8;  ///< Offset: 0x70 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_9;  ///< Offset: 0x74 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_10;  ///< Offset: 0x78 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_11;  ///< Offset: 0x7C - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_12;  ///< Offset: 0x80 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_13;  ///< Offset: 0x84 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_14;  ///< Offset: 0x88 - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM0_15;  ///< Offset: 0x8C - JPEG quantization memory 0
        volatile uint32_t JPEG_QMEM1_0;  ///< Offset: 0x90 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_1;  ///< Offset: 0x94 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_2;  ///< Offset: 0x98 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_3;  ///< Offset: 0x9C - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_4;  ///< Offset: 0xA0 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_5;  ///< Offset: 0xA4 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_6;  ///< Offset: 0xA8 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_7;  ///< Offset: 0xAC - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_8;  ///< Offset: 0xB0 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_9;  ///< Offset: 0xB4 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_10;  ///< Offset: 0xB8 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_11;  ///< Offset: 0xBC - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_12;  ///< Offset: 0xC0 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_13;  ///< Offset: 0xC4 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_14;  ///< Offset: 0xC8 - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM1_15;  ///< Offset: 0xCC - JPEG quantization memory 1
        volatile uint32_t JPEG_QMEM2_0;  ///< Offset: 0xD0 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_1;  ///< Offset: 0xD4 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_2;  ///< Offset: 0xD8 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_3;  ///< Offset: 0xDC - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_4;  ///< Offset: 0xE0 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_5;  ///< Offset: 0xE4 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_6;  ///< Offset: 0xE8 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_7;  ///< Offset: 0xEC - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_8;  ///< Offset: 0xF0 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_9;  ///< Offset: 0xF4 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_10;  ///< Offset: 0xF8 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_11;  ///< Offset: 0xFC - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_12;  ///< Offset: 0x100 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_13;  ///< Offset: 0x104 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_14;  ///< Offset: 0x108 - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM2_15;  ///< Offset: 0x10C - JPEG quantization memory 2
        volatile uint32_t JPEG_QMEM3_0;  ///< Offset: 0x110 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_1;  ///< Offset: 0x114 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_2;  ///< Offset: 0x118 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_3;  ///< Offset: 0x11C - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_4;  ///< Offset: 0x120 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_5;  ///< Offset: 0x124 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_6;  ///< Offset: 0x128 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_7;  ///< Offset: 0x12C - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_8;  ///< Offset: 0x130 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_9;  ///< Offset: 0x134 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_10;  ///< Offset: 0x138 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_11;  ///< Offset: 0x13C - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_12;  ///< Offset: 0x140 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_13;  ///< Offset: 0x144 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_14;  ///< Offset: 0x148 - JPEG quantization memory 3
        volatile uint32_t JPEG_QMEM3_15;  ///< Offset: 0x14C - JPEG quantization memory 3
        volatile uint32_t JPEG_HUFFMIN0_0;  ///< Offset: 0x150 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN0_1;  ///< Offset: 0x154 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN0_2;  ///< Offset: 0x158 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN0_3;  ///< Offset: 0x15C - JPEG Huffman min 0 [alternate]
        volatile uint32_t JPEG_HUFFMIN1_0;  ///< Offset: 0x160 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN1_1;  ///< Offset: 0x164 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN1_2;  ///< Offset: 0x168 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN1_3;  ///< Offset: 0x16C - JPEG Huffman min 1 [alternate]
        volatile uint32_t JPEG_HUFFMIN2_0;  ///< Offset: 0x170 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN2_1;  ///< Offset: 0x174 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN2_2;  ///< Offset: 0x178 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN2_3;  ///< Offset: 0x17C - JPEG Huffman min 2 [alternate]
        volatile uint32_t JPEG_HUFFMIN3_0;  ///< Offset: 0x180 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN3_1;  ///< Offset: 0x184 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN3_2;  ///< Offset: 0x188 - JPEG Huffman min
        volatile uint32_t JPEG_HUFFMIN3_3;  ///< Offset: 0x18C - JPEG Huffman min 3 [alternate]
        volatile uint32_t JPEG_HUFFBASE0;  ///< Offset: 0x190 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE1;  ///< Offset: 0x194 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE2;  ///< Offset: 0x198 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE3;  ///< Offset: 0x19C - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE4;  ///< Offset: 0x1A0 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE5;  ///< Offset: 0x1A4 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE6;  ///< Offset: 0x1A8 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE7;  ///< Offset: 0x1AC - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE8;  ///< Offset: 0x1B0 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE9;  ///< Offset: 0x1B4 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE10;  ///< Offset: 0x1B8 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE11;  ///< Offset: 0x1BC - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE12;  ///< Offset: 0x1C0 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE13;  ///< Offset: 0x1C4 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE14;  ///< Offset: 0x1C8 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE15;  ///< Offset: 0x1CC - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE16;  ///< Offset: 0x1D0 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE17;  ///< Offset: 0x1D4 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE18;  ///< Offset: 0x1D8 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE19;  ///< Offset: 0x1DC - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE20;  ///< Offset: 0x1E0 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE21;  ///< Offset: 0x1E4 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE22;  ///< Offset: 0x1E8 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE23;  ///< Offset: 0x1EC - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE24;  ///< Offset: 0x1F0 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE25;  ///< Offset: 0x1F4 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE26;  ///< Offset: 0x1F8 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE27;  ///< Offset: 0x1FC - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE28;  ///< Offset: 0x200 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE29;  ///< Offset: 0x204 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE30;  ///< Offset: 0x208 - JPEG Huffman base
        volatile uint32_t JPEG_HUFFBASE31;  ///< Offset: 0x20C - JPEG Huffman base
        volatile uint32_t JPEG_HUFFSYMB0;  ///< Offset: 0x210 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB1;  ///< Offset: 0x214 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB2;  ///< Offset: 0x218 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB3;  ///< Offset: 0x21C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB4;  ///< Offset: 0x220 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB5;  ///< Offset: 0x224 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB6;  ///< Offset: 0x228 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB7;  ///< Offset: 0x22C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB8;  ///< Offset: 0x230 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB9;  ///< Offset: 0x234 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB10;  ///< Offset: 0x238 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB11;  ///< Offset: 0x23C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB12;  ///< Offset: 0x240 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB13;  ///< Offset: 0x244 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB14;  ///< Offset: 0x248 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB15;  ///< Offset: 0x24C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB16;  ///< Offset: 0x250 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB17;  ///< Offset: 0x254 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB18;  ///< Offset: 0x258 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB19;  ///< Offset: 0x25C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB20;  ///< Offset: 0x260 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB21;  ///< Offset: 0x264 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB22;  ///< Offset: 0x268 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB23;  ///< Offset: 0x26C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB24;  ///< Offset: 0x270 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB25;  ///< Offset: 0x274 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB26;  ///< Offset: 0x278 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB27;  ///< Offset: 0x27C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB28;  ///< Offset: 0x280 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB29;  ///< Offset: 0x284 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB30;  ///< Offset: 0x288 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB31;  ///< Offset: 0x28C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB32;  ///< Offset: 0x290 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB33;  ///< Offset: 0x294 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB34;  ///< Offset: 0x298 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB35;  ///< Offset: 0x29C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB36;  ///< Offset: 0x2A0 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB37;  ///< Offset: 0x2A4 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB38;  ///< Offset: 0x2A8 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB39;  ///< Offset: 0x2AC - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB40;  ///< Offset: 0x2B0 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB41;  ///< Offset: 0x2B4 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB42;  ///< Offset: 0x2B8 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB43;  ///< Offset: 0x2BC - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB44;  ///< Offset: 0x2C0 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB45;  ///< Offset: 0x2C4 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB46;  ///< Offset: 0x2C8 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB47;  ///< Offset: 0x2CC - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB48;  ///< Offset: 0x2D0 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB49;  ///< Offset: 0x2D4 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB50;  ///< Offset: 0x2D8 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB51;  ///< Offset: 0x2DC - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB52;  ///< Offset: 0x2E0 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB53;  ///< Offset: 0x2E4 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB54;  ///< Offset: 0x2E8 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB55;  ///< Offset: 0x2EC - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB56;  ///< Offset: 0x2F0 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB57;  ///< Offset: 0x2F4 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB58;  ///< Offset: 0x2F8 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB59;  ///< Offset: 0x2FC - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB60;  ///< Offset: 0x300 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB61;  ///< Offset: 0x304 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB62;  ///< Offset: 0x308 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB63;  ///< Offset: 0x30C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB64;  ///< Offset: 0x310 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB65;  ///< Offset: 0x314 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB66;  ///< Offset: 0x318 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB67;  ///< Offset: 0x31C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB68;  ///< Offset: 0x320 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB69;  ///< Offset: 0x324 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB70;  ///< Offset: 0x328 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB71;  ///< Offset: 0x32C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB72;  ///< Offset: 0x330 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB73;  ///< Offset: 0x334 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB74;  ///< Offset: 0x338 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB75;  ///< Offset: 0x33C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB76;  ///< Offset: 0x340 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB77;  ///< Offset: 0x344 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB78;  ///< Offset: 0x348 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB79;  ///< Offset: 0x34C - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB80;  ///< Offset: 0x350 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB81;  ///< Offset: 0x354 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB82;  ///< Offset: 0x358 - JPEG Huffman symbol
        volatile uint32_t JPEG_HUFFSYMB83;  ///< Offset: 0x35C - JPEG Huffman symbol
        volatile uint32_t JPEG_DHTMEM0;  ///< Offset: 0x360 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM1;  ///< Offset: 0x364 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM2;  ///< Offset: 0x368 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM3;  ///< Offset: 0x36C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM4;  ///< Offset: 0x370 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM5;  ///< Offset: 0x374 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM6;  ///< Offset: 0x378 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM7;  ///< Offset: 0x37C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM8;  ///< Offset: 0x380 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM9;  ///< Offset: 0x384 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM10;  ///< Offset: 0x388 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM11;  ///< Offset: 0x38C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM12;  ///< Offset: 0x390 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM13;  ///< Offset: 0x394 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM14;  ///< Offset: 0x398 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM15;  ///< Offset: 0x39C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM16;  ///< Offset: 0x3A0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM17;  ///< Offset: 0x3A4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM18;  ///< Offset: 0x3A8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM19;  ///< Offset: 0x3AC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM20;  ///< Offset: 0x3B0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM21;  ///< Offset: 0x3B4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM22;  ///< Offset: 0x3B8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM23;  ///< Offset: 0x3BC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM24;  ///< Offset: 0x3C0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM25;  ///< Offset: 0x3C4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM26;  ///< Offset: 0x3C8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM27;  ///< Offset: 0x3CC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM28;  ///< Offset: 0x3D0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM29;  ///< Offset: 0x3D4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM30;  ///< Offset: 0x3D8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM31;  ///< Offset: 0x3DC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM32;  ///< Offset: 0x3E0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM33;  ///< Offset: 0x3E4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM34;  ///< Offset: 0x3E8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM35;  ///< Offset: 0x3EC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM36;  ///< Offset: 0x3F0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM37;  ///< Offset: 0x3F4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM38;  ///< Offset: 0x3F8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM39;  ///< Offset: 0x3FC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM40;  ///< Offset: 0x400 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM41;  ///< Offset: 0x404 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM42;  ///< Offset: 0x408 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM43;  ///< Offset: 0x40C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM44;  ///< Offset: 0x410 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM45;  ///< Offset: 0x414 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM46;  ///< Offset: 0x418 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM47;  ///< Offset: 0x41C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM48;  ///< Offset: 0x420 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM49;  ///< Offset: 0x424 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM50;  ///< Offset: 0x428 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM51;  ///< Offset: 0x42C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM52;  ///< Offset: 0x430 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM53;  ///< Offset: 0x434 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM54;  ///< Offset: 0x438 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM55;  ///< Offset: 0x43C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM56;  ///< Offset: 0x440 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM57;  ///< Offset: 0x444 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM58;  ///< Offset: 0x448 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM59;  ///< Offset: 0x44C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM60;  ///< Offset: 0x450 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM61;  ///< Offset: 0x454 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM62;  ///< Offset: 0x458 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM63;  ///< Offset: 0x45C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM64;  ///< Offset: 0x460 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM65;  ///< Offset: 0x464 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM66;  ///< Offset: 0x468 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM67;  ///< Offset: 0x46C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM68;  ///< Offset: 0x470 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM69;  ///< Offset: 0x474 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM70;  ///< Offset: 0x478 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM71;  ///< Offset: 0x47C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM72;  ///< Offset: 0x480 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM73;  ///< Offset: 0x484 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM74;  ///< Offset: 0x488 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM75;  ///< Offset: 0x48C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM76;  ///< Offset: 0x490 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM77;  ///< Offset: 0x494 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM78;  ///< Offset: 0x498 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM79;  ///< Offset: 0x49C - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM80;  ///< Offset: 0x4A0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM81;  ///< Offset: 0x4A4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM82;  ///< Offset: 0x4A8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM83;  ///< Offset: 0x4AC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM84;  ///< Offset: 0x4B0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM85;  ///< Offset: 0x4B4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM86;  ///< Offset: 0x4B8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM87;  ///< Offset: 0x4BC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM88;  ///< Offset: 0x4C0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM89;  ///< Offset: 0x4C4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM90;  ///< Offset: 0x4C8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM91;  ///< Offset: 0x4CC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM92;  ///< Offset: 0x4D0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM93;  ///< Offset: 0x4D4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM94;  ///< Offset: 0x4D8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM95;  ///< Offset: 0x4DC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM96;  ///< Offset: 0x4E0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM97;  ///< Offset: 0x4E4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM98;  ///< Offset: 0x4E8 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM99;  ///< Offset: 0x4EC - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM100;  ///< Offset: 0x4F0 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM101;  ///< Offset: 0x4F4 - JPEG DHT memory
        volatile uint32_t JPEG_DHTMEM102;  ///< Offset: 0x4F8 - JPEG DHT memory
        volatile uint32_t JPEG_HUFFENC_AC0_0;  ///< Offset: 0x500 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_1;  ///< Offset: 0x504 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_2;  ///< Offset: 0x508 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_3;  ///< Offset: 0x50C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_4;  ///< Offset: 0x510 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_5;  ///< Offset: 0x514 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_6;  ///< Offset: 0x518 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_7;  ///< Offset: 0x51C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_8;  ///< Offset: 0x520 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_9;  ///< Offset: 0x524 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_10;  ///< Offset: 0x528 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_11;  ///< Offset: 0x52C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_12;  ///< Offset: 0x530 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_13;  ///< Offset: 0x534 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_14;  ///< Offset: 0x538 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_15;  ///< Offset: 0x53C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_16;  ///< Offset: 0x540 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_17;  ///< Offset: 0x544 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_18;  ///< Offset: 0x548 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_19;  ///< Offset: 0x54C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_20;  ///< Offset: 0x550 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_21;  ///< Offset: 0x554 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_22;  ///< Offset: 0x558 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_23;  ///< Offset: 0x55C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_24;  ///< Offset: 0x560 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_25;  ///< Offset: 0x564 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_26;  ///< Offset: 0x568 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_27;  ///< Offset: 0x56C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_28;  ///< Offset: 0x570 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_29;  ///< Offset: 0x574 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_30;  ///< Offset: 0x578 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_31;  ///< Offset: 0x57C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_32;  ///< Offset: 0x580 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_33;  ///< Offset: 0x584 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_34;  ///< Offset: 0x588 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_35;  ///< Offset: 0x58C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_36;  ///< Offset: 0x590 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_37;  ///< Offset: 0x594 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_38;  ///< Offset: 0x598 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_39;  ///< Offset: 0x59C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_40;  ///< Offset: 0x5A0 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_41;  ///< Offset: 0x5A4 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_42;  ///< Offset: 0x5A8 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_43;  ///< Offset: 0x5AC - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_44;  ///< Offset: 0x5B0 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_45;  ///< Offset: 0x5B4 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_46;  ///< Offset: 0x5B8 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_47;  ///< Offset: 0x5BC - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_48;  ///< Offset: 0x5C0 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_49;  ///< Offset: 0x5C4 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_50;  ///< Offset: 0x5C8 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_51;  ///< Offset: 0x5CC - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_52;  ///< Offset: 0x5D0 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_53;  ///< Offset: 0x5D4 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_54;  ///< Offset: 0x5D8 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC0_55;  ///< Offset: 0x5DC - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_0;  ///< Offset: 0x5DC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_56;  ///< Offset: 0x5E0 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_1;  ///< Offset: 0x5E0 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_57;  ///< Offset: 0x5E4 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_2;  ///< Offset: 0x5E4 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_58;  ///< Offset: 0x5E8 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_3;  ///< Offset: 0x5E8 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_59;  ///< Offset: 0x5EC - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_4;  ///< Offset: 0x5EC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_60;  ///< Offset: 0x5F0 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_5;  ///< Offset: 0x5F0 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_61;  ///< Offset: 0x5F4 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_6;  ///< Offset: 0x5F4 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_62;  ///< Offset: 0x5F8 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_7;  ///< Offset: 0x5F8 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_63;  ///< Offset: 0x5FC - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_8;  ///< Offset: 0x5FC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_64;  ///< Offset: 0x600 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_9;  ///< Offset: 0x600 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_65;  ///< Offset: 0x604 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_10;  ///< Offset: 0x604 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_66;  ///< Offset: 0x608 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_11;  ///< Offset: 0x608 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_67;  ///< Offset: 0x60C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_12;  ///< Offset: 0x60C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_68;  ///< Offset: 0x610 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_13;  ///< Offset: 0x610 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_69;  ///< Offset: 0x614 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_14;  ///< Offset: 0x614 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_70;  ///< Offset: 0x618 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_15;  ///< Offset: 0x618 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_71;  ///< Offset: 0x61C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_16;  ///< Offset: 0x61C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_72;  ///< Offset: 0x620 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_17;  ///< Offset: 0x620 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_73;  ///< Offset: 0x624 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_18;  ///< Offset: 0x624 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_74;  ///< Offset: 0x628 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_19;  ///< Offset: 0x628 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_75;  ///< Offset: 0x62C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_20;  ///< Offset: 0x62C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_76;  ///< Offset: 0x630 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_21;  ///< Offset: 0x630 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_77;  ///< Offset: 0x634 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_22;  ///< Offset: 0x634 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_78;  ///< Offset: 0x638 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_23;  ///< Offset: 0x638 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_79;  ///< Offset: 0x63C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_24;  ///< Offset: 0x63C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_80;  ///< Offset: 0x640 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_25;  ///< Offset: 0x640 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_81;  ///< Offset: 0x644 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_26;  ///< Offset: 0x644 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_82;  ///< Offset: 0x648 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_27;  ///< Offset: 0x648 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_83;  ///< Offset: 0x64C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_28;  ///< Offset: 0x64C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_84;  ///< Offset: 0x650 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_29;  ///< Offset: 0x650 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_85;  ///< Offset: 0x654 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_30;  ///< Offset: 0x654 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_86;  ///< Offset: 0x658 - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_31;  ///< Offset: 0x658 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC0_87;  ///< Offset: 0x65C - JPEG Huffman encoder AC0
        volatile uint32_t JPEG_HUFFENC_AC1_32;  ///< Offset: 0x65C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_33;  ///< Offset: 0x660 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_34;  ///< Offset: 0x664 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_35;  ///< Offset: 0x668 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_36;  ///< Offset: 0x66C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_37;  ///< Offset: 0x670 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_38;  ///< Offset: 0x674 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_39;  ///< Offset: 0x678 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_40;  ///< Offset: 0x67C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_41;  ///< Offset: 0x680 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_42;  ///< Offset: 0x684 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_43;  ///< Offset: 0x688 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_44;  ///< Offset: 0x68C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_45;  ///< Offset: 0x690 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_46;  ///< Offset: 0x694 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_47;  ///< Offset: 0x698 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_48;  ///< Offset: 0x69C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_49;  ///< Offset: 0x6A0 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_50;  ///< Offset: 0x6A4 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_51;  ///< Offset: 0x6A8 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_52;  ///< Offset: 0x6AC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_53;  ///< Offset: 0x6B0 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_54;  ///< Offset: 0x6B4 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_55;  ///< Offset: 0x6B8 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_56;  ///< Offset: 0x6BC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_57;  ///< Offset: 0x6C0 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_58;  ///< Offset: 0x6C4 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_59;  ///< Offset: 0x6C8 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_60;  ///< Offset: 0x6CC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_61;  ///< Offset: 0x6D0 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_62;  ///< Offset: 0x6D4 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_63;  ///< Offset: 0x6D8 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_64;  ///< Offset: 0x6DC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_65;  ///< Offset: 0x6E0 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_66;  ///< Offset: 0x6E4 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_67;  ///< Offset: 0x6E8 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_68;  ///< Offset: 0x6EC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_69;  ///< Offset: 0x6F0 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_70;  ///< Offset: 0x6F4 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_71;  ///< Offset: 0x6F8 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_72;  ///< Offset: 0x6FC - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_73;  ///< Offset: 0x700 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_74;  ///< Offset: 0x704 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_75;  ///< Offset: 0x708 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_76;  ///< Offset: 0x70C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_77;  ///< Offset: 0x710 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_78;  ///< Offset: 0x714 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_79;  ///< Offset: 0x718 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_80;  ///< Offset: 0x71C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_81;  ///< Offset: 0x720 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_82;  ///< Offset: 0x724 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_83;  ///< Offset: 0x728 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_84;  ///< Offset: 0x72C - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_85;  ///< Offset: 0x730 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_86;  ///< Offset: 0x734 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_AC1_87;  ///< Offset: 0x738 - JPEG Huffman encoder AC1
        volatile uint32_t JPEG_HUFFENC_DC0_0;  ///< Offset: 0x7C0 - JPEG Huffman encoder DC0
        volatile uint32_t JPEG_HUFFENC_DC0_1;  ///< Offset: 0x7C4 - JPEG Huffman encoder DC0
        volatile uint32_t JPEG_HUFFENC_DC0_2;  ///< Offset: 0x7C8 - JPEG Huffman encoder DC0
        volatile uint32_t JPEG_HUFFENC_DC0_3;  ///< Offset: 0x7CC - JPEG Huffman encoder DC0
        volatile uint32_t JPEG_HUFFENC_DC0_4;  ///< Offset: 0x7D0 - JPEG Huffman encoder DC0
        volatile uint32_t JPEG_HUFFENC_DC0_5;  ///< Offset: 0x7D4 - JPEG Huffman encoder DC0
        volatile uint32_t JPEG_HUFFENC_DC0_6;  ///< Offset: 0x7D8 - JPEG Huffman encoder DC0
        volatile uint32_t JPEG_HUFFENC_DC0_7;  ///< Offset: 0x7DC - JPEG Huffman encoder DC0
        volatile uint32_t JPEG_HUFFENC_DC1_0;  ///< Offset: 0x89C - JPEG Huffman encoder DC1
        volatile uint32_t JPEG_HUFFENC_DC1_1;  ///< Offset: 0x8A0 - JPEG Huffman encoder DC1
        volatile uint32_t JPEG_HUFFENC_DC1_2;  ///< Offset: 0x8A4 - JPEG Huffman encoder DC1
        volatile uint32_t JPEG_HUFFENC_DC1_3;  ///< Offset: 0x8A8 - JPEG Huffman encoder DC1
        volatile uint32_t JPEG_HUFFENC_DC1_4;  ///< Offset: 0x8AC - JPEG Huffman encoder DC1
        volatile uint32_t JPEG_HUFFENC_DC1_5;  ///< Offset: 0x8B0 - JPEG Huffman encoder DC1
        volatile uint32_t JPEG_HUFFENC_DC1_6;  ///< Offset: 0x8B4 - JPEG Huffman encoder DC1
        volatile uint32_t JPEG_HUFFENC_DC1_7;  ///< Offset: 0x8B8 - JPEG Huffman encoder DC1
    };

    /// Peripheral instances
    inline Registers* JPEG = reinterpret_cast<Registers*>(JPEG_BASE);

    // Bit definitions
    /// JPEG_CONFR0 Register bits
    namespace jpeg_confr0_bits {
        constexpr uint32_t START = (1U << 0);  ///< Start This bit start or stop the encoding or decoding process. Note: Reads always return 0.
    }

    /// JPEG_CONFR1 Register bits
    namespace jpeg_confr1_bits {
        constexpr uint32_t NF = (2 << 0);  ///< Number of color components This field defines the number of color components minus 1.
        constexpr uint32_t DE = (1U << 3);  ///< Codec operation as coder or decoder This bit selects the code or decode process
        constexpr uint32_t COLSPACE = (2 << 4);  ///< Color space This filed defines the number of quantization tables minus 1 to insert in the output stream.
        constexpr uint32_t NS = (2 << 6);  ///< Number of components for scan This field defines the number of components minus 1 for scan header marker segment.
        constexpr uint32_t HDR = (1U << 8);  ///< Header processing This bit enables the header processing (generation/parsing).
        constexpr uint32_t YSIZE = (16 << 16);  ///< Y Size This field defines the number of lines in source image.
    }

    /// JPEG_CONFR2 Register bits
    namespace jpeg_confr2_bits {
        constexpr uint32_t NMCU = (26 << 0);  ///< Number of MCUs For encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCUs generated.
    }

    /// JPEG_CONFR3 Register bits
    namespace jpeg_confr3_bits {
        constexpr uint32_t XSIZE = (16 << 16);  ///< X size This field defines the number of pixels per line.
    }

    /// JPEG_CONFR4 Register bits
    namespace jpeg_confr4_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Huffman DC Selects the Huffman table for encoding DC coefficients.
        constexpr uint32_t HA = (1U << 1);  ///< Huffman AC Selects the Huffman table for encoding AC coefficients.
        constexpr uint32_t QT = (2 << 2);  ///< Quantization table Selects quantization table used for component 0.
        constexpr uint32_t NB = (4 << 4);  ///< Number of blocks Number of data units minus 1 that belong to a particular color in the MCU.
        constexpr uint32_t VSF = (4 << 8);  ///< Vertical sampling factor Vertical sampling factor for component 0.
        constexpr uint32_t HSF = (4 << 12);  ///< Horizontal sampling factor Horizontal sampling factor for component 0.
    }

    /// JPEG_CONFR5 Register bits
    namespace jpeg_confr5_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Huffman DC Selects the Huffman table for encoding DC coefficients.
        constexpr uint32_t HA = (1U << 1);  ///< Huffman AC Selects the Huffman table for encoding AC coefficients.
        constexpr uint32_t QT = (2 << 2);  ///< Quantization table Selects quantization table used for component 1.
        constexpr uint32_t NB = (4 << 4);  ///< Number of blocks Number of data units minus 1 that belong to a particular color in the MCU.
        constexpr uint32_t VSF = (4 << 8);  ///< Vertical sampling factor Vertical sampling factor for component 1.
        constexpr uint32_t HSF = (4 << 12);  ///< Horizontal sampling factor Horizontal sampling factor for component 1.
    }

    /// JPEG_CONFR6 Register bits
    namespace jpeg_confr6_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Huffman DC Selects the Huffman table for encoding DC coefficients.
        constexpr uint32_t HA = (1U << 1);  ///< Huffman AC Selects the Huffman table for encoding AC coefficients.
        constexpr uint32_t QT = (2 << 2);  ///< Quantization table Selects quantization table used for component 2.
        constexpr uint32_t NB = (4 << 4);  ///< Number of blocks Number of data units minus 1 that belong to a particular color in the MCU.
        constexpr uint32_t VSF = (4 << 8);  ///< Vertical sampling factor Vertical sampling factor for component 2.
        constexpr uint32_t HSF = (4 << 12);  ///< Horizontal sampling factor Horizontal sampling factor for component 2.
    }

    /// JPEG_CONFR7 Register bits
    namespace jpeg_confr7_bits {
        constexpr uint32_t HD = (1U << 0);  ///< Huffman DC Selects the Huffman table for encoding DC coefficients.
        constexpr uint32_t HA = (1U << 1);  ///< Huffman AC Selects the Huffman table for encoding AC coefficients.
        constexpr uint32_t QT = (2 << 2);  ///< Quantization table Selects quantization table used for component 3.
        constexpr uint32_t NB = (4 << 4);  ///< Number of blocks Number of data units minus 1 that belong to a particular color in the MCU.
        constexpr uint32_t VSF = (4 << 8);  ///< Vertical sampling factor Vertical sampling factor for component 3.
        constexpr uint32_t HSF = (4 << 12);  ///< Horizontal sampling factor Horizontal sampling factor for component 3.
    }

    /// JPEG_CR Register bits
    namespace jpeg_cr_bits {
        constexpr uint32_t JCEN = (1U << 0);  ///< JPEG core enable This bit enables the JPEG codec core.
        constexpr uint32_t IFTIE = (1U << 1);  ///< Input FIFO threshold interrupt enable This bit enables interrupt generation when the input FIFO reaches a threshold.
        constexpr uint32_t IFNFIE = (1U << 2);  ///< Input FIFO not full interrupt enable This bit enables interrupt generation when the input FIFO is not empty.
        constexpr uint32_t OFTIE = (1U << 3);  ///< Output FIFO threshold interrupt enable This bit enables interrupt generation when the output FIFO reaches a threshold.
        constexpr uint32_t OFNEIE = (1U << 4);  ///< Output FIFO not empty interrupt enable This bit enables interrupt generation when the output FIFO is not empty.
        constexpr uint32_t EOCIE = (1U << 5);  ///< End of conversion interrupt enable This bit enables interrupt generation at the end of conversion.
        constexpr uint32_t HPDIE = (1U << 6);  ///< Header parsing done interrupt enable This bit enables interrupt generation upon the completion of the header parsing operation.
        constexpr uint32_t IDMAEN = (1U << 11);  ///< Input DMA enable Enables DMA request generation for the input FIFO.
        constexpr uint32_t ODMAEN = (1U << 12);  ///< Output DMA enable Enables DMA request generation for the output FIFO.
        constexpr uint32_t IFF = (1U << 13);  ///< Input FIFO flush This bit flushes the input FIFO. Note: Reads always return 0.
        constexpr uint32_t OFF = (1U << 14);  ///< Output FIFO flush This bit flushes the output FIFO. Note: Reads always return 0.
    }

    /// JPEG_SR Register bits
    namespace jpeg_sr_bits {
        constexpr uint32_t IFTF = (1U << 1);  ///< Input FIFO threshold flag This bit flags that the amount of data in the input FIFO is below a threshold. This flag must not be considered when using DMA.
        constexpr uint32_t IFNFF = (1U << 2);  ///< Input FIFO not full flag This bit flags that the input FIFO is not full (data can be written). This flag must not be considered when using DMA.
        constexpr uint32_t OFTF = (1U << 3);  ///< Output FIFO threshold flag This bit flags that the amount of data in the output FIFO reaches or exceeds a threshold. This flag must not be considered when using DMA.
        constexpr uint32_t OFNEF = (1U << 4);  ///< Output FIFO not empty flag This bit flags that data is available in the output FIFO. This flag must not be considered when using DMA.
        constexpr uint32_t EOCF = (1U << 5);  ///< End of conversion flag This bit flags the completion of encode/decode process and data transfer to the output FIFO.
        constexpr uint32_t HPDF = (1U << 6);  ///< Header parsing done flag In decode mode, this bit flags the completion of header parsing and updating internal registers.
        constexpr uint32_t COF = (1U << 7);  ///< Codec operation flag This bit flags code/decode operation in progress.
    }

    /// JPEG_CFR Register bits
    namespace jpeg_cfr_bits {
        constexpr uint32_t CEOCF = (1U << 5);  ///< Clear end of conversion flag Writing 1 clears the ECF bit of the JPEG_SR register.
        constexpr uint32_t CHPDF = (1U << 6);  ///< Clear header parsing done flag Writing 1 clears the HPDF bit of the JPEG_SR register.
    }

    /// JPEG_DIR Register bits
    namespace jpeg_dir_bits {
        constexpr uint32_t DATAIN = (32 << 0);  ///< Data input FIFO Input FIFO data register
    }

    /// JPEG_DOR Register bits
    namespace jpeg_dor_bits {
        constexpr uint32_t DATAOUT = (32 << 0);  ///< Data output FIFO Output FIFO data register.
    }

    /// JPEG_QMEM0_0 Register bits
    namespace jpeg_qmem0_0_bits {
        constexpr uint32_t QCOEF0 = (8 << 0);  ///< Quantization coefficient 0 8-bit quantization coefficient.
        constexpr uint32_t QCOEF1 = (8 << 8);  ///< Quantization coefficient 1 8-bit quantization coefficient.
        constexpr uint32_t QCOEF2 = (8 << 16);  ///< Quantization coefficient 2 8-bit quantization coefficient.
        constexpr uint32_t QCOEF3 = (8 << 24);  ///< Quantization coefficient 3 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_1 Register bits
    namespace jpeg_qmem0_1_bits {
        constexpr uint32_t QCOEF4 = (8 << 0);  ///< Quantization coefficient 4 8-bit quantization coefficient.
        constexpr uint32_t QCOEF5 = (8 << 8);  ///< Quantization coefficient 5 8-bit quantization coefficient.
        constexpr uint32_t QCOEF6 = (8 << 16);  ///< Quantization coefficient 6 8-bit quantization coefficient.
        constexpr uint32_t QCOEF7 = (8 << 24);  ///< Quantization coefficient 7 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_2 Register bits
    namespace jpeg_qmem0_2_bits {
        constexpr uint32_t QCOEF8 = (8 << 0);  ///< Quantization coefficient 8 8-bit quantization coefficient.
        constexpr uint32_t QCOEF9 = (8 << 8);  ///< Quantization coefficient 9 8-bit quantization coefficient.
        constexpr uint32_t QCOEF10 = (8 << 16);  ///< Quantization coefficient 10 8-bit quantization coefficient.
        constexpr uint32_t QCOEF11 = (8 << 24);  ///< Quantization coefficient 11 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_3 Register bits
    namespace jpeg_qmem0_3_bits {
        constexpr uint32_t QCOEF12 = (8 << 0);  ///< Quantization coefficient 12 8-bit quantization coefficient.
        constexpr uint32_t QCOEF13 = (8 << 8);  ///< Quantization coefficient 13 8-bit quantization coefficient.
        constexpr uint32_t QCOEF14 = (8 << 16);  ///< Quantization coefficient 14 8-bit quantization coefficient.
        constexpr uint32_t QCOEF15 = (8 << 24);  ///< Quantization coefficient 15 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_4 Register bits
    namespace jpeg_qmem0_4_bits {
        constexpr uint32_t QCOEF16 = (8 << 0);  ///< Quantization coefficient 16 8-bit quantization coefficient.
        constexpr uint32_t QCOEF17 = (8 << 8);  ///< Quantization coefficient 17 8-bit quantization coefficient.
        constexpr uint32_t QCOEF18 = (8 << 16);  ///< Quantization coefficient 18 8-bit quantization coefficient.
        constexpr uint32_t QCOEF19 = (8 << 24);  ///< Quantization coefficient 19 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_5 Register bits
    namespace jpeg_qmem0_5_bits {
        constexpr uint32_t QCOEF20 = (8 << 0);  ///< Quantization coefficient 20 8-bit quantization coefficient.
        constexpr uint32_t QCOEF21 = (8 << 8);  ///< Quantization coefficient 21 8-bit quantization coefficient.
        constexpr uint32_t QCOEF22 = (8 << 16);  ///< Quantization coefficient 22 8-bit quantization coefficient.
        constexpr uint32_t QCOEF23 = (8 << 24);  ///< Quantization coefficient 23 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_6 Register bits
    namespace jpeg_qmem0_6_bits {
        constexpr uint32_t QCOEF24 = (8 << 0);  ///< Quantization coefficient 24 8-bit quantization coefficient.
        constexpr uint32_t QCOEF25 = (8 << 8);  ///< Quantization coefficient 25 8-bit quantization coefficient.
        constexpr uint32_t QCOEF26 = (8 << 16);  ///< Quantization coefficient 26 8-bit quantization coefficient.
        constexpr uint32_t QCOEF27 = (8 << 24);  ///< Quantization coefficient 27 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_7 Register bits
    namespace jpeg_qmem0_7_bits {
        constexpr uint32_t QCOEF28 = (8 << 0);  ///< Quantization coefficient 28 8-bit quantization coefficient.
        constexpr uint32_t QCOEF29 = (8 << 8);  ///< Quantization coefficient 29 8-bit quantization coefficient.
        constexpr uint32_t QCOEF30 = (8 << 16);  ///< Quantization coefficient 30 8-bit quantization coefficient.
        constexpr uint32_t QCOEF31 = (8 << 24);  ///< Quantization coefficient 31 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_8 Register bits
    namespace jpeg_qmem0_8_bits {
        constexpr uint32_t QCOEF32 = (8 << 0);  ///< Quantization coefficient 32 8-bit quantization coefficient.
        constexpr uint32_t QCOEF33 = (8 << 8);  ///< Quantization coefficient 33 8-bit quantization coefficient.
        constexpr uint32_t QCOEF34 = (8 << 16);  ///< Quantization coefficient 34 8-bit quantization coefficient.
        constexpr uint32_t QCOEF35 = (8 << 24);  ///< Quantization coefficient 35 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_9 Register bits
    namespace jpeg_qmem0_9_bits {
        constexpr uint32_t QCOEF36 = (8 << 0);  ///< Quantization coefficient 36 8-bit quantization coefficient.
        constexpr uint32_t QCOEF37 = (8 << 8);  ///< Quantization coefficient 37 8-bit quantization coefficient.
        constexpr uint32_t QCOEF38 = (8 << 16);  ///< Quantization coefficient 38 8-bit quantization coefficient.
        constexpr uint32_t QCOEF39 = (8 << 24);  ///< Quantization coefficient 39 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_10 Register bits
    namespace jpeg_qmem0_10_bits {
        constexpr uint32_t QCOEF40 = (8 << 0);  ///< Quantization coefficient 40 8-bit quantization coefficient.
        constexpr uint32_t QCOEF41 = (8 << 8);  ///< Quantization coefficient 41 8-bit quantization coefficient.
        constexpr uint32_t QCOEF42 = (8 << 16);  ///< Quantization coefficient 42 8-bit quantization coefficient.
        constexpr uint32_t QCOEF43 = (8 << 24);  ///< Quantization coefficient 43 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_11 Register bits
    namespace jpeg_qmem0_11_bits {
        constexpr uint32_t QCOEF44 = (8 << 0);  ///< Quantization coefficient 44 8-bit quantization coefficient.
        constexpr uint32_t QCOEF45 = (8 << 8);  ///< Quantization coefficient 45 8-bit quantization coefficient.
        constexpr uint32_t QCOEF46 = (8 << 16);  ///< Quantization coefficient 46 8-bit quantization coefficient.
        constexpr uint32_t QCOEF47 = (8 << 24);  ///< Quantization coefficient 47 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_12 Register bits
    namespace jpeg_qmem0_12_bits {
        constexpr uint32_t QCOEF48 = (8 << 0);  ///< Quantization coefficient 48 8-bit quantization coefficient.
        constexpr uint32_t QCOEF49 = (8 << 8);  ///< Quantization coefficient 49 8-bit quantization coefficient.
        constexpr uint32_t QCOEF50 = (8 << 16);  ///< Quantization coefficient 50 8-bit quantization coefficient.
        constexpr uint32_t QCOEF51 = (8 << 24);  ///< Quantization coefficient 51 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_13 Register bits
    namespace jpeg_qmem0_13_bits {
        constexpr uint32_t QCOEF52 = (8 << 0);  ///< Quantization coefficient 52 8-bit quantization coefficient.
        constexpr uint32_t QCOEF53 = (8 << 8);  ///< Quantization coefficient 53 8-bit quantization coefficient.
        constexpr uint32_t QCOEF54 = (8 << 16);  ///< Quantization coefficient 54 8-bit quantization coefficient.
        constexpr uint32_t QCOEF55 = (8 << 24);  ///< Quantization coefficient 55 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_14 Register bits
    namespace jpeg_qmem0_14_bits {
        constexpr uint32_t QCOEF56 = (8 << 0);  ///< Quantization coefficient 56 8-bit quantization coefficient.
        constexpr uint32_t QCOEF57 = (8 << 8);  ///< Quantization coefficient 57 8-bit quantization coefficient.
        constexpr uint32_t QCOEF58 = (8 << 16);  ///< Quantization coefficient 58 8-bit quantization coefficient.
        constexpr uint32_t QCOEF59 = (8 << 24);  ///< Quantization coefficient 59 8-bit quantization coefficient.
    }

    /// JPEG_QMEM0_15 Register bits
    namespace jpeg_qmem0_15_bits {
        constexpr uint32_t QCOEF60 = (8 << 0);  ///< Quantization coefficient 60 8-bit quantization coefficient.
        constexpr uint32_t QCOEF61 = (8 << 8);  ///< Quantization coefficient 61 8-bit quantization coefficient.
        constexpr uint32_t QCOEF62 = (8 << 16);  ///< Quantization coefficient 62 8-bit quantization coefficient.
        constexpr uint32_t QCOEF63 = (8 << 24);  ///< Quantization coefficient 63 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_0 Register bits
    namespace jpeg_qmem1_0_bits {
        constexpr uint32_t QCOEF0 = (8 << 0);  ///< Quantization coefficient 0 8-bit quantization coefficient.
        constexpr uint32_t QCOEF1 = (8 << 8);  ///< Quantization coefficient 1 8-bit quantization coefficient.
        constexpr uint32_t QCOEF2 = (8 << 16);  ///< Quantization coefficient 2 8-bit quantization coefficient.
        constexpr uint32_t QCOEF3 = (8 << 24);  ///< Quantization coefficient 3 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_1 Register bits
    namespace jpeg_qmem1_1_bits {
        constexpr uint32_t QCOEF4 = (8 << 0);  ///< Quantization coefficient 4 8-bit quantization coefficient.
        constexpr uint32_t QCOEF5 = (8 << 8);  ///< Quantization coefficient 5 8-bit quantization coefficient.
        constexpr uint32_t QCOEF6 = (8 << 16);  ///< Quantization coefficient 6 8-bit quantization coefficient.
        constexpr uint32_t QCOEF7 = (8 << 24);  ///< Quantization coefficient 7 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_2 Register bits
    namespace jpeg_qmem1_2_bits {
        constexpr uint32_t QCOEF8 = (8 << 0);  ///< Quantization coefficient 8 8-bit quantization coefficient.
        constexpr uint32_t QCOEF9 = (8 << 8);  ///< Quantization coefficient 9 8-bit quantization coefficient.
        constexpr uint32_t QCOEF10 = (8 << 16);  ///< Quantization coefficient 10 8-bit quantization coefficient.
        constexpr uint32_t QCOEF11 = (8 << 24);  ///< Quantization coefficient 11 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_3 Register bits
    namespace jpeg_qmem1_3_bits {
        constexpr uint32_t QCOEF12 = (8 << 0);  ///< Quantization coefficient 12 8-bit quantization coefficient.
        constexpr uint32_t QCOEF13 = (8 << 8);  ///< Quantization coefficient 13 8-bit quantization coefficient.
        constexpr uint32_t QCOEF14 = (8 << 16);  ///< Quantization coefficient 14 8-bit quantization coefficient.
        constexpr uint32_t QCOEF15 = (8 << 24);  ///< Quantization coefficient 15 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_4 Register bits
    namespace jpeg_qmem1_4_bits {
        constexpr uint32_t QCOEF16 = (8 << 0);  ///< Quantization coefficient 16 8-bit quantization coefficient.
        constexpr uint32_t QCOEF17 = (8 << 8);  ///< Quantization coefficient 17 8-bit quantization coefficient.
        constexpr uint32_t QCOEF18 = (8 << 16);  ///< Quantization coefficient 18 8-bit quantization coefficient.
        constexpr uint32_t QCOEF19 = (8 << 24);  ///< Quantization coefficient 19 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_5 Register bits
    namespace jpeg_qmem1_5_bits {
        constexpr uint32_t QCOEF20 = (8 << 0);  ///< Quantization coefficient 20 8-bit quantization coefficient.
        constexpr uint32_t QCOEF21 = (8 << 8);  ///< Quantization coefficient 21 8-bit quantization coefficient.
        constexpr uint32_t QCOEF22 = (8 << 16);  ///< Quantization coefficient 22 8-bit quantization coefficient.
        constexpr uint32_t QCOEF23 = (8 << 24);  ///< Quantization coefficient 23 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_6 Register bits
    namespace jpeg_qmem1_6_bits {
        constexpr uint32_t QCOEF24 = (8 << 0);  ///< Quantization coefficient 24 8-bit quantization coefficient.
        constexpr uint32_t QCOEF25 = (8 << 8);  ///< Quantization coefficient 25 8-bit quantization coefficient.
        constexpr uint32_t QCOEF26 = (8 << 16);  ///< Quantization coefficient 26 8-bit quantization coefficient.
        constexpr uint32_t QCOEF27 = (8 << 24);  ///< Quantization coefficient 27 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_7 Register bits
    namespace jpeg_qmem1_7_bits {
        constexpr uint32_t QCOEF28 = (8 << 0);  ///< Quantization coefficient 28 8-bit quantization coefficient.
        constexpr uint32_t QCOEF29 = (8 << 8);  ///< Quantization coefficient 29 8-bit quantization coefficient.
        constexpr uint32_t QCOEF30 = (8 << 16);  ///< Quantization coefficient 30 8-bit quantization coefficient.
        constexpr uint32_t QCOEF31 = (8 << 24);  ///< Quantization coefficient 31 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_8 Register bits
    namespace jpeg_qmem1_8_bits {
        constexpr uint32_t QCOEF32 = (8 << 0);  ///< Quantization coefficient 32 8-bit quantization coefficient.
        constexpr uint32_t QCOEF33 = (8 << 8);  ///< Quantization coefficient 33 8-bit quantization coefficient.
        constexpr uint32_t QCOEF34 = (8 << 16);  ///< Quantization coefficient 34 8-bit quantization coefficient.
        constexpr uint32_t QCOEF35 = (8 << 24);  ///< Quantization coefficient 35 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_9 Register bits
    namespace jpeg_qmem1_9_bits {
        constexpr uint32_t QCOEF36 = (8 << 0);  ///< Quantization coefficient 36 8-bit quantization coefficient.
        constexpr uint32_t QCOEF37 = (8 << 8);  ///< Quantization coefficient 37 8-bit quantization coefficient.
        constexpr uint32_t QCOEF38 = (8 << 16);  ///< Quantization coefficient 38 8-bit quantization coefficient.
        constexpr uint32_t QCOEF39 = (8 << 24);  ///< Quantization coefficient 39 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_10 Register bits
    namespace jpeg_qmem1_10_bits {
        constexpr uint32_t QCOEF40 = (8 << 0);  ///< Quantization coefficient 40 8-bit quantization coefficient.
        constexpr uint32_t QCOEF41 = (8 << 8);  ///< Quantization coefficient 41 8-bit quantization coefficient.
        constexpr uint32_t QCOEF42 = (8 << 16);  ///< Quantization coefficient 42 8-bit quantization coefficient.
        constexpr uint32_t QCOEF43 = (8 << 24);  ///< Quantization coefficient 43 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_11 Register bits
    namespace jpeg_qmem1_11_bits {
        constexpr uint32_t QCOEF44 = (8 << 0);  ///< Quantization coefficient 44 8-bit quantization coefficient.
        constexpr uint32_t QCOEF45 = (8 << 8);  ///< Quantization coefficient 45 8-bit quantization coefficient.
        constexpr uint32_t QCOEF46 = (8 << 16);  ///< Quantization coefficient 46 8-bit quantization coefficient.
        constexpr uint32_t QCOEF47 = (8 << 24);  ///< Quantization coefficient 47 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_12 Register bits
    namespace jpeg_qmem1_12_bits {
        constexpr uint32_t QCOEF48 = (8 << 0);  ///< Quantization coefficient 48 8-bit quantization coefficient.
        constexpr uint32_t QCOEF49 = (8 << 8);  ///< Quantization coefficient 49 8-bit quantization coefficient.
        constexpr uint32_t QCOEF50 = (8 << 16);  ///< Quantization coefficient 50 8-bit quantization coefficient.
        constexpr uint32_t QCOEF51 = (8 << 24);  ///< Quantization coefficient 51 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_13 Register bits
    namespace jpeg_qmem1_13_bits {
        constexpr uint32_t QCOEF52 = (8 << 0);  ///< Quantization coefficient 52 8-bit quantization coefficient.
        constexpr uint32_t QCOEF53 = (8 << 8);  ///< Quantization coefficient 53 8-bit quantization coefficient.
        constexpr uint32_t QCOEF54 = (8 << 16);  ///< Quantization coefficient 54 8-bit quantization coefficient.
        constexpr uint32_t QCOEF55 = (8 << 24);  ///< Quantization coefficient 55 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_14 Register bits
    namespace jpeg_qmem1_14_bits {
        constexpr uint32_t QCOEF56 = (8 << 0);  ///< Quantization coefficient 56 8-bit quantization coefficient.
        constexpr uint32_t QCOEF57 = (8 << 8);  ///< Quantization coefficient 57 8-bit quantization coefficient.
        constexpr uint32_t QCOEF58 = (8 << 16);  ///< Quantization coefficient 58 8-bit quantization coefficient.
        constexpr uint32_t QCOEF59 = (8 << 24);  ///< Quantization coefficient 59 8-bit quantization coefficient.
    }

    /// JPEG_QMEM1_15 Register bits
    namespace jpeg_qmem1_15_bits {
        constexpr uint32_t QCOEF60 = (8 << 0);  ///< Quantization coefficient 60 8-bit quantization coefficient.
        constexpr uint32_t QCOEF61 = (8 << 8);  ///< Quantization coefficient 61 8-bit quantization coefficient.
        constexpr uint32_t QCOEF62 = (8 << 16);  ///< Quantization coefficient 62 8-bit quantization coefficient.
        constexpr uint32_t QCOEF63 = (8 << 24);  ///< Quantization coefficient 63 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_0 Register bits
    namespace jpeg_qmem2_0_bits {
        constexpr uint32_t QCOEF0 = (8 << 0);  ///< Quantization coefficient 0 8-bit quantization coefficient.
        constexpr uint32_t QCOEF1 = (8 << 8);  ///< Quantization coefficient 1 8-bit quantization coefficient.
        constexpr uint32_t QCOEF2 = (8 << 16);  ///< Quantization coefficient 2 8-bit quantization coefficient.
        constexpr uint32_t QCOEF3 = (8 << 24);  ///< Quantization coefficient 3 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_1 Register bits
    namespace jpeg_qmem2_1_bits {
        constexpr uint32_t QCOEF4 = (8 << 0);  ///< Quantization coefficient 4 8-bit quantization coefficient.
        constexpr uint32_t QCOEF5 = (8 << 8);  ///< Quantization coefficient 5 8-bit quantization coefficient.
        constexpr uint32_t QCOEF6 = (8 << 16);  ///< Quantization coefficient 6 8-bit quantization coefficient.
        constexpr uint32_t QCOEF7 = (8 << 24);  ///< Quantization coefficient 7 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_2 Register bits
    namespace jpeg_qmem2_2_bits {
        constexpr uint32_t QCOEF8 = (8 << 0);  ///< Quantization coefficient 8 8-bit quantization coefficient.
        constexpr uint32_t QCOEF9 = (8 << 8);  ///< Quantization coefficient 9 8-bit quantization coefficient.
        constexpr uint32_t QCOEF10 = (8 << 16);  ///< Quantization coefficient 10 8-bit quantization coefficient.
        constexpr uint32_t QCOEF11 = (8 << 24);  ///< Quantization coefficient 11 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_3 Register bits
    namespace jpeg_qmem2_3_bits {
        constexpr uint32_t QCOEF12 = (8 << 0);  ///< Quantization coefficient 12 8-bit quantization coefficient.
        constexpr uint32_t QCOEF13 = (8 << 8);  ///< Quantization coefficient 13 8-bit quantization coefficient.
        constexpr uint32_t QCOEF14 = (8 << 16);  ///< Quantization coefficient 14 8-bit quantization coefficient.
        constexpr uint32_t QCOEF15 = (8 << 24);  ///< Quantization coefficient 15 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_4 Register bits
    namespace jpeg_qmem2_4_bits {
        constexpr uint32_t QCOEF16 = (8 << 0);  ///< Quantization coefficient 16 8-bit quantization coefficient.
        constexpr uint32_t QCOEF17 = (8 << 8);  ///< Quantization coefficient 17 8-bit quantization coefficient.
        constexpr uint32_t QCOEF18 = (8 << 16);  ///< Quantization coefficient 18 8-bit quantization coefficient.
        constexpr uint32_t QCOEF19 = (8 << 24);  ///< Quantization coefficient 19 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_5 Register bits
    namespace jpeg_qmem2_5_bits {
        constexpr uint32_t QCOEF20 = (8 << 0);  ///< Quantization coefficient 20 8-bit quantization coefficient.
        constexpr uint32_t QCOEF21 = (8 << 8);  ///< Quantization coefficient 21 8-bit quantization coefficient.
        constexpr uint32_t QCOEF22 = (8 << 16);  ///< Quantization coefficient 22 8-bit quantization coefficient.
        constexpr uint32_t QCOEF23 = (8 << 24);  ///< Quantization coefficient 23 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_6 Register bits
    namespace jpeg_qmem2_6_bits {
        constexpr uint32_t QCOEF24 = (8 << 0);  ///< Quantization coefficient 24 8-bit quantization coefficient.
        constexpr uint32_t QCOEF25 = (8 << 8);  ///< Quantization coefficient 25 8-bit quantization coefficient.
        constexpr uint32_t QCOEF26 = (8 << 16);  ///< Quantization coefficient 26 8-bit quantization coefficient.
        constexpr uint32_t QCOEF27 = (8 << 24);  ///< Quantization coefficient 27 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_7 Register bits
    namespace jpeg_qmem2_7_bits {
        constexpr uint32_t QCOEF28 = (8 << 0);  ///< Quantization coefficient 28 8-bit quantization coefficient.
        constexpr uint32_t QCOEF29 = (8 << 8);  ///< Quantization coefficient 29 8-bit quantization coefficient.
        constexpr uint32_t QCOEF30 = (8 << 16);  ///< Quantization coefficient 30 8-bit quantization coefficient.
        constexpr uint32_t QCOEF31 = (8 << 24);  ///< Quantization coefficient 31 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_8 Register bits
    namespace jpeg_qmem2_8_bits {
        constexpr uint32_t QCOEF32 = (8 << 0);  ///< Quantization coefficient 32 8-bit quantization coefficient.
        constexpr uint32_t QCOEF33 = (8 << 8);  ///< Quantization coefficient 33 8-bit quantization coefficient.
        constexpr uint32_t QCOEF34 = (8 << 16);  ///< Quantization coefficient 34 8-bit quantization coefficient.
        constexpr uint32_t QCOEF35 = (8 << 24);  ///< Quantization coefficient 35 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_9 Register bits
    namespace jpeg_qmem2_9_bits {
        constexpr uint32_t QCOEF36 = (8 << 0);  ///< Quantization coefficient 36 8-bit quantization coefficient.
        constexpr uint32_t QCOEF37 = (8 << 8);  ///< Quantization coefficient 37 8-bit quantization coefficient.
        constexpr uint32_t QCOEF38 = (8 << 16);  ///< Quantization coefficient 38 8-bit quantization coefficient.
        constexpr uint32_t QCOEF39 = (8 << 24);  ///< Quantization coefficient 39 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_10 Register bits
    namespace jpeg_qmem2_10_bits {
        constexpr uint32_t QCOEF40 = (8 << 0);  ///< Quantization coefficient 40 8-bit quantization coefficient.
        constexpr uint32_t QCOEF41 = (8 << 8);  ///< Quantization coefficient 41 8-bit quantization coefficient.
        constexpr uint32_t QCOEF42 = (8 << 16);  ///< Quantization coefficient 42 8-bit quantization coefficient.
        constexpr uint32_t QCOEF43 = (8 << 24);  ///< Quantization coefficient 43 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_11 Register bits
    namespace jpeg_qmem2_11_bits {
        constexpr uint32_t QCOEF44 = (8 << 0);  ///< Quantization coefficient 44 8-bit quantization coefficient.
        constexpr uint32_t QCOEF45 = (8 << 8);  ///< Quantization coefficient 45 8-bit quantization coefficient.
        constexpr uint32_t QCOEF46 = (8 << 16);  ///< Quantization coefficient 46 8-bit quantization coefficient.
        constexpr uint32_t QCOEF47 = (8 << 24);  ///< Quantization coefficient 47 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_12 Register bits
    namespace jpeg_qmem2_12_bits {
        constexpr uint32_t QCOEF48 = (8 << 0);  ///< Quantization coefficient 48 8-bit quantization coefficient.
        constexpr uint32_t QCOEF49 = (8 << 8);  ///< Quantization coefficient 49 8-bit quantization coefficient.
        constexpr uint32_t QCOEF50 = (8 << 16);  ///< Quantization coefficient 50 8-bit quantization coefficient.
        constexpr uint32_t QCOEF51 = (8 << 24);  ///< Quantization coefficient 51 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_13 Register bits
    namespace jpeg_qmem2_13_bits {
        constexpr uint32_t QCOEF52 = (8 << 0);  ///< Quantization coefficient 52 8-bit quantization coefficient.
        constexpr uint32_t QCOEF53 = (8 << 8);  ///< Quantization coefficient 53 8-bit quantization coefficient.
        constexpr uint32_t QCOEF54 = (8 << 16);  ///< Quantization coefficient 54 8-bit quantization coefficient.
        constexpr uint32_t QCOEF55 = (8 << 24);  ///< Quantization coefficient 55 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_14 Register bits
    namespace jpeg_qmem2_14_bits {
        constexpr uint32_t QCOEF56 = (8 << 0);  ///< Quantization coefficient 56 8-bit quantization coefficient.
        constexpr uint32_t QCOEF57 = (8 << 8);  ///< Quantization coefficient 57 8-bit quantization coefficient.
        constexpr uint32_t QCOEF58 = (8 << 16);  ///< Quantization coefficient 58 8-bit quantization coefficient.
        constexpr uint32_t QCOEF59 = (8 << 24);  ///< Quantization coefficient 59 8-bit quantization coefficient.
    }

    /// JPEG_QMEM2_15 Register bits
    namespace jpeg_qmem2_15_bits {
        constexpr uint32_t QCOEF60 = (8 << 0);  ///< Quantization coefficient 60 8-bit quantization coefficient.
        constexpr uint32_t QCOEF61 = (8 << 8);  ///< Quantization coefficient 61 8-bit quantization coefficient.
        constexpr uint32_t QCOEF62 = (8 << 16);  ///< Quantization coefficient 62 8-bit quantization coefficient.
        constexpr uint32_t QCOEF63 = (8 << 24);  ///< Quantization coefficient 63 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_0 Register bits
    namespace jpeg_qmem3_0_bits {
        constexpr uint32_t QCOEF0 = (8 << 0);  ///< Quantization coefficient 0 8-bit quantization coefficient.
        constexpr uint32_t QCOEF1 = (8 << 8);  ///< Quantization coefficient 1 8-bit quantization coefficient.
        constexpr uint32_t QCOEF2 = (8 << 16);  ///< Quantization coefficient 2 8-bit quantization coefficient.
        constexpr uint32_t QCOEF3 = (8 << 24);  ///< Quantization coefficient 3 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_1 Register bits
    namespace jpeg_qmem3_1_bits {
        constexpr uint32_t QCOEF4 = (8 << 0);  ///< Quantization coefficient 4 8-bit quantization coefficient.
        constexpr uint32_t QCOEF5 = (8 << 8);  ///< Quantization coefficient 5 8-bit quantization coefficient.
        constexpr uint32_t QCOEF6 = (8 << 16);  ///< Quantization coefficient 6 8-bit quantization coefficient.
        constexpr uint32_t QCOEF7 = (8 << 24);  ///< Quantization coefficient 7 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_2 Register bits
    namespace jpeg_qmem3_2_bits {
        constexpr uint32_t QCOEF8 = (8 << 0);  ///< Quantization coefficient 8 8-bit quantization coefficient.
        constexpr uint32_t QCOEF9 = (8 << 8);  ///< Quantization coefficient 9 8-bit quantization coefficient.
        constexpr uint32_t QCOEF10 = (8 << 16);  ///< Quantization coefficient 10 8-bit quantization coefficient.
        constexpr uint32_t QCOEF11 = (8 << 24);  ///< Quantization coefficient 11 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_3 Register bits
    namespace jpeg_qmem3_3_bits {
        constexpr uint32_t QCOEF12 = (8 << 0);  ///< Quantization coefficient 12 8-bit quantization coefficient.
        constexpr uint32_t QCOEF13 = (8 << 8);  ///< Quantization coefficient 13 8-bit quantization coefficient.
        constexpr uint32_t QCOEF14 = (8 << 16);  ///< Quantization coefficient 14 8-bit quantization coefficient.
        constexpr uint32_t QCOEF15 = (8 << 24);  ///< Quantization coefficient 15 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_4 Register bits
    namespace jpeg_qmem3_4_bits {
        constexpr uint32_t QCOEF16 = (8 << 0);  ///< Quantization coefficient 16 8-bit quantization coefficient.
        constexpr uint32_t QCOEF17 = (8 << 8);  ///< Quantization coefficient 17 8-bit quantization coefficient.
        constexpr uint32_t QCOEF18 = (8 << 16);  ///< Quantization coefficient 18 8-bit quantization coefficient.
        constexpr uint32_t QCOEF19 = (8 << 24);  ///< Quantization coefficient 19 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_5 Register bits
    namespace jpeg_qmem3_5_bits {
        constexpr uint32_t QCOEF20 = (8 << 0);  ///< Quantization coefficient 20 8-bit quantization coefficient.
        constexpr uint32_t QCOEF21 = (8 << 8);  ///< Quantization coefficient 21 8-bit quantization coefficient.
        constexpr uint32_t QCOEF22 = (8 << 16);  ///< Quantization coefficient 22 8-bit quantization coefficient.
        constexpr uint32_t QCOEF23 = (8 << 24);  ///< Quantization coefficient 23 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_6 Register bits
    namespace jpeg_qmem3_6_bits {
        constexpr uint32_t QCOEF24 = (8 << 0);  ///< Quantization coefficient 24 8-bit quantization coefficient.
        constexpr uint32_t QCOEF25 = (8 << 8);  ///< Quantization coefficient 25 8-bit quantization coefficient.
        constexpr uint32_t QCOEF26 = (8 << 16);  ///< Quantization coefficient 26 8-bit quantization coefficient.
        constexpr uint32_t QCOEF27 = (8 << 24);  ///< Quantization coefficient 27 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_7 Register bits
    namespace jpeg_qmem3_7_bits {
        constexpr uint32_t QCOEF28 = (8 << 0);  ///< Quantization coefficient 28 8-bit quantization coefficient.
        constexpr uint32_t QCOEF29 = (8 << 8);  ///< Quantization coefficient 29 8-bit quantization coefficient.
        constexpr uint32_t QCOEF30 = (8 << 16);  ///< Quantization coefficient 30 8-bit quantization coefficient.
        constexpr uint32_t QCOEF31 = (8 << 24);  ///< Quantization coefficient 31 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_8 Register bits
    namespace jpeg_qmem3_8_bits {
        constexpr uint32_t QCOEF32 = (8 << 0);  ///< Quantization coefficient 32 8-bit quantization coefficient.
        constexpr uint32_t QCOEF33 = (8 << 8);  ///< Quantization coefficient 33 8-bit quantization coefficient.
        constexpr uint32_t QCOEF34 = (8 << 16);  ///< Quantization coefficient 34 8-bit quantization coefficient.
        constexpr uint32_t QCOEF35 = (8 << 24);  ///< Quantization coefficient 35 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_9 Register bits
    namespace jpeg_qmem3_9_bits {
        constexpr uint32_t QCOEF36 = (8 << 0);  ///< Quantization coefficient 36 8-bit quantization coefficient.
        constexpr uint32_t QCOEF37 = (8 << 8);  ///< Quantization coefficient 37 8-bit quantization coefficient.
        constexpr uint32_t QCOEF38 = (8 << 16);  ///< Quantization coefficient 38 8-bit quantization coefficient.
        constexpr uint32_t QCOEF39 = (8 << 24);  ///< Quantization coefficient 39 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_10 Register bits
    namespace jpeg_qmem3_10_bits {
        constexpr uint32_t QCOEF40 = (8 << 0);  ///< Quantization coefficient 40 8-bit quantization coefficient.
        constexpr uint32_t QCOEF41 = (8 << 8);  ///< Quantization coefficient 41 8-bit quantization coefficient.
        constexpr uint32_t QCOEF42 = (8 << 16);  ///< Quantization coefficient 42 8-bit quantization coefficient.
        constexpr uint32_t QCOEF43 = (8 << 24);  ///< Quantization coefficient 43 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_11 Register bits
    namespace jpeg_qmem3_11_bits {
        constexpr uint32_t QCOEF44 = (8 << 0);  ///< Quantization coefficient 44 8-bit quantization coefficient.
        constexpr uint32_t QCOEF45 = (8 << 8);  ///< Quantization coefficient 45 8-bit quantization coefficient.
        constexpr uint32_t QCOEF46 = (8 << 16);  ///< Quantization coefficient 46 8-bit quantization coefficient.
        constexpr uint32_t QCOEF47 = (8 << 24);  ///< Quantization coefficient 47 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_12 Register bits
    namespace jpeg_qmem3_12_bits {
        constexpr uint32_t QCOEF48 = (8 << 0);  ///< Quantization coefficient 48 8-bit quantization coefficient.
        constexpr uint32_t QCOEF49 = (8 << 8);  ///< Quantization coefficient 49 8-bit quantization coefficient.
        constexpr uint32_t QCOEF50 = (8 << 16);  ///< Quantization coefficient 50 8-bit quantization coefficient.
        constexpr uint32_t QCOEF51 = (8 << 24);  ///< Quantization coefficient 51 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_13 Register bits
    namespace jpeg_qmem3_13_bits {
        constexpr uint32_t QCOEF52 = (8 << 0);  ///< Quantization coefficient 52 8-bit quantization coefficient.
        constexpr uint32_t QCOEF53 = (8 << 8);  ///< Quantization coefficient 53 8-bit quantization coefficient.
        constexpr uint32_t QCOEF54 = (8 << 16);  ///< Quantization coefficient 54 8-bit quantization coefficient.
        constexpr uint32_t QCOEF55 = (8 << 24);  ///< Quantization coefficient 55 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_14 Register bits
    namespace jpeg_qmem3_14_bits {
        constexpr uint32_t QCOEF56 = (8 << 0);  ///< Quantization coefficient 56 8-bit quantization coefficient.
        constexpr uint32_t QCOEF57 = (8 << 8);  ///< Quantization coefficient 57 8-bit quantization coefficient.
        constexpr uint32_t QCOEF58 = (8 << 16);  ///< Quantization coefficient 58 8-bit quantization coefficient.
        constexpr uint32_t QCOEF59 = (8 << 24);  ///< Quantization coefficient 59 8-bit quantization coefficient.
    }

    /// JPEG_QMEM3_15 Register bits
    namespace jpeg_qmem3_15_bits {
        constexpr uint32_t QCOEF60 = (8 << 0);  ///< Quantization coefficient 60 8-bit quantization coefficient.
        constexpr uint32_t QCOEF61 = (8 << 8);  ///< Quantization coefficient 61 8-bit quantization coefficient.
        constexpr uint32_t QCOEF62 = (8 << 16);  ///< Quantization coefficient 62 8-bit quantization coefficient.
        constexpr uint32_t QCOEF63 = (8 << 24);  ///< Quantization coefficient 63 8-bit quantization coefficient.
    }

    /// JPEG_HUFFMIN0_0 Register bits
    namespace jpeg_huffmin0_0_bits {
        constexpr uint32_t DATA0 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN0_1 Register bits
    namespace jpeg_huffmin0_1_bits {
        constexpr uint32_t DATA0 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN0_2 Register bits
    namespace jpeg_huffmin0_2_bits {
        constexpr uint32_t DATA0 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN0_3 Register bits
    namespace jpeg_huffmin0_3_bits {
        constexpr uint32_t DATA0 = (4 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN1_0 Register bits
    namespace jpeg_huffmin1_0_bits {
        constexpr uint32_t DATA1 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN1_1 Register bits
    namespace jpeg_huffmin1_1_bits {
        constexpr uint32_t DATA1 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN1_2 Register bits
    namespace jpeg_huffmin1_2_bits {
        constexpr uint32_t DATA1 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN1_3 Register bits
    namespace jpeg_huffmin1_3_bits {
        constexpr uint32_t DATA1 = (4 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN2_0 Register bits
    namespace jpeg_huffmin2_0_bits {
        constexpr uint32_t DATA2 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN2_1 Register bits
    namespace jpeg_huffmin2_1_bits {
        constexpr uint32_t DATA2 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN2_2 Register bits
    namespace jpeg_huffmin2_2_bits {
        constexpr uint32_t DATA2 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN2_3 Register bits
    namespace jpeg_huffmin2_3_bits {
        constexpr uint32_t DATA2 = (4 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN3_0 Register bits
    namespace jpeg_huffmin3_0_bits {
        constexpr uint32_t DATA3 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN3_1 Register bits
    namespace jpeg_huffmin3_1_bits {
        constexpr uint32_t DATA3 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN3_2 Register bits
    namespace jpeg_huffmin3_2_bits {
        constexpr uint32_t DATA3 = (32 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFMIN3_3 Register bits
    namespace jpeg_huffmin3_3_bits {
        constexpr uint32_t DATA3 = (4 << 0);  ///< Minimum Huffman value 100-bit minimum Huffman value used internally by the JPEG decoder.
    }

    /// JPEG_HUFFBASE0 Register bits
    namespace jpeg_huffbase0_bits {
        constexpr uint32_t DATA0 = (9 << 0);  ///< Data 0 Base Huffman value.
        constexpr uint32_t DATA1 = (9 << 16);  ///< Data 1 Base Huffman value.
    }

    /// JPEG_HUFFBASE1 Register bits
    namespace jpeg_huffbase1_bits {
        constexpr uint32_t DATA2 = (9 << 0);  ///< Data 2 Base Huffman value.
        constexpr uint32_t DATA3 = (9 << 16);  ///< Data 3 Base Huffman value.
    }

    /// JPEG_HUFFBASE2 Register bits
    namespace jpeg_huffbase2_bits {
        constexpr uint32_t DATA4 = (9 << 0);  ///< Data 4 Base Huffman value.
        constexpr uint32_t DATA5 = (9 << 16);  ///< Data 5 Base Huffman value.
    }

    /// JPEG_HUFFBASE3 Register bits
    namespace jpeg_huffbase3_bits {
        constexpr uint32_t DATA6 = (9 << 0);  ///< Data 6 Base Huffman value.
        constexpr uint32_t DATA7 = (9 << 16);  ///< Data 7 Base Huffman value.
    }

    /// JPEG_HUFFBASE4 Register bits
    namespace jpeg_huffbase4_bits {
        constexpr uint32_t DATA8 = (9 << 0);  ///< Data 8 Base Huffman value.
        constexpr uint32_t DATA9 = (9 << 16);  ///< Data 9 Base Huffman value.
    }

    /// JPEG_HUFFBASE5 Register bits
    namespace jpeg_huffbase5_bits {
        constexpr uint32_t DATA10 = (9 << 0);  ///< Data 10 Base Huffman value.
        constexpr uint32_t DATA11 = (9 << 16);  ///< Data 11 Base Huffman value.
    }

    /// JPEG_HUFFBASE6 Register bits
    namespace jpeg_huffbase6_bits {
        constexpr uint32_t DATA12 = (9 << 0);  ///< Data 12 Base Huffman value.
        constexpr uint32_t DATA13 = (9 << 16);  ///< Data 13 Base Huffman value.
    }

    /// JPEG_HUFFBASE7 Register bits
    namespace jpeg_huffbase7_bits {
        constexpr uint32_t DATA14 = (9 << 0);  ///< Data 14 Base Huffman value.
        constexpr uint32_t DATA15 = (9 << 16);  ///< Data 15 Base Huffman value.
    }

    /// JPEG_HUFFBASE8 Register bits
    namespace jpeg_huffbase8_bits {
        constexpr uint32_t DATA16 = (9 << 0);  ///< Data 16 Base Huffman value.
        constexpr uint32_t DATA17 = (9 << 16);  ///< Data 17 Base Huffman value.
    }

    /// JPEG_HUFFBASE9 Register bits
    namespace jpeg_huffbase9_bits {
        constexpr uint32_t DATA18 = (9 << 0);  ///< Data 18 Base Huffman value.
        constexpr uint32_t DATA19 = (9 << 16);  ///< Data 19 Base Huffman value.
    }

    /// JPEG_HUFFBASE10 Register bits
    namespace jpeg_huffbase10_bits {
        constexpr uint32_t DATA20 = (9 << 0);  ///< Data 20 Base Huffman value.
        constexpr uint32_t DATA21 = (9 << 16);  ///< Data 21 Base Huffman value.
    }

    /// JPEG_HUFFBASE11 Register bits
    namespace jpeg_huffbase11_bits {
        constexpr uint32_t DATA22 = (9 << 0);  ///< Data 22 Base Huffman value.
        constexpr uint32_t DATA23 = (9 << 16);  ///< Data 23 Base Huffman value.
    }

    /// JPEG_HUFFBASE12 Register bits
    namespace jpeg_huffbase12_bits {
        constexpr uint32_t DATA24 = (9 << 0);  ///< Data 24 Base Huffman value.
        constexpr uint32_t DATA25 = (9 << 16);  ///< Data 25 Base Huffman value.
    }

    /// JPEG_HUFFBASE13 Register bits
    namespace jpeg_huffbase13_bits {
        constexpr uint32_t DATA26 = (9 << 0);  ///< Data 26 Base Huffman value.
        constexpr uint32_t DATA27 = (9 << 16);  ///< Data 27 Base Huffman value.
    }

    /// JPEG_HUFFBASE14 Register bits
    namespace jpeg_huffbase14_bits {
        constexpr uint32_t DATA28 = (9 << 0);  ///< Data 28 Base Huffman value.
        constexpr uint32_t DATA29 = (9 << 16);  ///< Data 29 Base Huffman value.
    }

    /// JPEG_HUFFBASE15 Register bits
    namespace jpeg_huffbase15_bits {
        constexpr uint32_t DATA30 = (9 << 0);  ///< Data 30 Base Huffman value.
        constexpr uint32_t DATA31 = (9 << 16);  ///< Data 31 Base Huffman value.
    }

    /// JPEG_HUFFBASE16 Register bits
    namespace jpeg_huffbase16_bits {
        constexpr uint32_t DATA32 = (9 << 0);  ///< Data 32 Base Huffman value.
        constexpr uint32_t DATA33 = (9 << 16);  ///< Data 33 Base Huffman value.
    }

    /// JPEG_HUFFBASE17 Register bits
    namespace jpeg_huffbase17_bits {
        constexpr uint32_t DATA34 = (9 << 0);  ///< Data 34 Base Huffman value.
        constexpr uint32_t DATA35 = (9 << 16);  ///< Data 35 Base Huffman value.
    }

    /// JPEG_HUFFBASE18 Register bits
    namespace jpeg_huffbase18_bits {
        constexpr uint32_t DATA36 = (9 << 0);  ///< Data 36 Base Huffman value.
        constexpr uint32_t DATA37 = (9 << 16);  ///< Data 37 Base Huffman value.
    }

    /// JPEG_HUFFBASE19 Register bits
    namespace jpeg_huffbase19_bits {
        constexpr uint32_t DATA38 = (9 << 0);  ///< Data 38 Base Huffman value.
        constexpr uint32_t DATA39 = (9 << 16);  ///< Data 39 Base Huffman value.
    }

    /// JPEG_HUFFBASE20 Register bits
    namespace jpeg_huffbase20_bits {
        constexpr uint32_t DATA40 = (9 << 0);  ///< Data 40 Base Huffman value.
        constexpr uint32_t DATA41 = (9 << 16);  ///< Data 41 Base Huffman value.
    }

    /// JPEG_HUFFBASE21 Register bits
    namespace jpeg_huffbase21_bits {
        constexpr uint32_t DATA42 = (9 << 0);  ///< Data 42 Base Huffman value.
        constexpr uint32_t DATA43 = (9 << 16);  ///< Data 43 Base Huffman value.
    }

    /// JPEG_HUFFBASE22 Register bits
    namespace jpeg_huffbase22_bits {
        constexpr uint32_t DATA44 = (9 << 0);  ///< Data 44 Base Huffman value.
        constexpr uint32_t DATA45 = (9 << 16);  ///< Data 45 Base Huffman value.
    }

    /// JPEG_HUFFBASE23 Register bits
    namespace jpeg_huffbase23_bits {
        constexpr uint32_t DATA46 = (9 << 0);  ///< Data 46 Base Huffman value.
        constexpr uint32_t DATA47 = (9 << 16);  ///< Data 47 Base Huffman value.
    }

    /// JPEG_HUFFBASE24 Register bits
    namespace jpeg_huffbase24_bits {
        constexpr uint32_t DATA48 = (9 << 0);  ///< Data 48 Base Huffman value.
        constexpr uint32_t DATA49 = (9 << 16);  ///< Data 49 Base Huffman value.
    }

    /// JPEG_HUFFBASE25 Register bits
    namespace jpeg_huffbase25_bits {
        constexpr uint32_t DATA50 = (9 << 0);  ///< Data 50 Base Huffman value.
        constexpr uint32_t DATA51 = (9 << 16);  ///< Data 51 Base Huffman value.
    }

    /// JPEG_HUFFBASE26 Register bits
    namespace jpeg_huffbase26_bits {
        constexpr uint32_t DATA52 = (9 << 0);  ///< Data 52 Base Huffman value.
        constexpr uint32_t DATA53 = (9 << 16);  ///< Data 53 Base Huffman value.
    }

    /// JPEG_HUFFBASE27 Register bits
    namespace jpeg_huffbase27_bits {
        constexpr uint32_t DATA54 = (9 << 0);  ///< Data 54 Base Huffman value.
        constexpr uint32_t DATA55 = (9 << 16);  ///< Data 55 Base Huffman value.
    }

    /// JPEG_HUFFBASE28 Register bits
    namespace jpeg_huffbase28_bits {
        constexpr uint32_t DATA56 = (9 << 0);  ///< Data 56 Base Huffman value.
        constexpr uint32_t DATA57 = (9 << 16);  ///< Data 57 Base Huffman value.
    }

    /// JPEG_HUFFBASE29 Register bits
    namespace jpeg_huffbase29_bits {
        constexpr uint32_t DATA58 = (9 << 0);  ///< Data 58 Base Huffman value.
        constexpr uint32_t DATA59 = (9 << 16);  ///< Data 59 Base Huffman value.
    }

    /// JPEG_HUFFBASE30 Register bits
    namespace jpeg_huffbase30_bits {
        constexpr uint32_t DATA60 = (9 << 0);  ///< Data 60 Base Huffman value.
        constexpr uint32_t DATA61 = (9 << 16);  ///< Data 61 Base Huffman value.
    }

    /// JPEG_HUFFBASE31 Register bits
    namespace jpeg_huffbase31_bits {
        constexpr uint32_t DATA62 = (9 << 0);  ///< Data 62 Base Huffman value.
        constexpr uint32_t DATA63 = (9 << 16);  ///< Data 63 Base Huffman value.
    }

    /// JPEG_HUFFSYMB0 Register bits
    namespace jpeg_huffsymb0_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< Data 0 Huffman symbol.
        constexpr uint32_t DATA1 = (8 << 8);  ///< Data 1 Huffman symbol.
        constexpr uint32_t DATA2 = (8 << 16);  ///< Data 2 Huffman symbol.
        constexpr uint32_t DATA3 = (8 << 24);  ///< Data 3 Huffman symbol.
    }

    /// JPEG_HUFFSYMB1 Register bits
    namespace jpeg_huffsymb1_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< Data 4 Huffman symbol.
        constexpr uint32_t DATA5 = (8 << 8);  ///< Data 5 Huffman symbol.
        constexpr uint32_t DATA6 = (8 << 16);  ///< Data 6 Huffman symbol.
        constexpr uint32_t DATA7 = (8 << 24);  ///< Data 7 Huffman symbol.
    }

    /// JPEG_HUFFSYMB2 Register bits
    namespace jpeg_huffsymb2_bits {
        constexpr uint32_t DATA8 = (8 << 0);  ///< Data 8 Huffman symbol.
        constexpr uint32_t DATA9 = (8 << 8);  ///< Data 9 Huffman symbol.
        constexpr uint32_t DATA10 = (8 << 16);  ///< Data 10 Huffman symbol.
        constexpr uint32_t DATA11 = (8 << 24);  ///< Data 11 Huffman symbol.
    }

    /// JPEG_HUFFSYMB3 Register bits
    namespace jpeg_huffsymb3_bits {
        constexpr uint32_t DATA12 = (8 << 0);  ///< Data 12 Huffman symbol.
        constexpr uint32_t DATA13 = (8 << 8);  ///< Data 13 Huffman symbol.
        constexpr uint32_t DATA14 = (8 << 16);  ///< Data 14 Huffman symbol.
        constexpr uint32_t DATA15 = (8 << 24);  ///< Data 15 Huffman symbol.
    }

    /// JPEG_HUFFSYMB4 Register bits
    namespace jpeg_huffsymb4_bits {
        constexpr uint32_t DATA16 = (8 << 0);  ///< Data 16 Huffman symbol.
        constexpr uint32_t DATA17 = (8 << 8);  ///< Data 17 Huffman symbol.
        constexpr uint32_t DATA18 = (8 << 16);  ///< Data 18 Huffman symbol.
        constexpr uint32_t DATA19 = (8 << 24);  ///< Data 19 Huffman symbol.
    }

    /// JPEG_HUFFSYMB5 Register bits
    namespace jpeg_huffsymb5_bits {
        constexpr uint32_t DATA20 = (8 << 0);  ///< Data 20 Huffman symbol.
        constexpr uint32_t DATA21 = (8 << 8);  ///< Data 21 Huffman symbol.
        constexpr uint32_t DATA22 = (8 << 16);  ///< Data 22 Huffman symbol.
        constexpr uint32_t DATA23 = (8 << 24);  ///< Data 23 Huffman symbol.
    }

    /// JPEG_HUFFSYMB6 Register bits
    namespace jpeg_huffsymb6_bits {
        constexpr uint32_t DATA24 = (8 << 0);  ///< Data 24 Huffman symbol.
        constexpr uint32_t DATA25 = (8 << 8);  ///< Data 25 Huffman symbol.
        constexpr uint32_t DATA26 = (8 << 16);  ///< Data 26 Huffman symbol.
        constexpr uint32_t DATA27 = (8 << 24);  ///< Data 27 Huffman symbol.
    }

    /// JPEG_HUFFSYMB7 Register bits
    namespace jpeg_huffsymb7_bits {
        constexpr uint32_t DATA28 = (8 << 0);  ///< Data 28 Huffman symbol.
        constexpr uint32_t DATA29 = (8 << 8);  ///< Data 29 Huffman symbol.
        constexpr uint32_t DATA30 = (8 << 16);  ///< Data 30 Huffman symbol.
        constexpr uint32_t DATA31 = (8 << 24);  ///< Data 31 Huffman symbol.
    }

    /// JPEG_HUFFSYMB8 Register bits
    namespace jpeg_huffsymb8_bits {
        constexpr uint32_t DATA32 = (8 << 0);  ///< Data 32 Huffman symbol.
        constexpr uint32_t DATA33 = (8 << 8);  ///< Data 33 Huffman symbol.
        constexpr uint32_t DATA34 = (8 << 16);  ///< Data 34 Huffman symbol.
        constexpr uint32_t DATA35 = (8 << 24);  ///< Data 35 Huffman symbol.
    }

    /// JPEG_HUFFSYMB9 Register bits
    namespace jpeg_huffsymb9_bits {
        constexpr uint32_t DATA36 = (8 << 0);  ///< Data 36 Huffman symbol.
        constexpr uint32_t DATA37 = (8 << 8);  ///< Data 37 Huffman symbol.
        constexpr uint32_t DATA38 = (8 << 16);  ///< Data 38 Huffman symbol.
        constexpr uint32_t DATA39 = (8 << 24);  ///< Data 39 Huffman symbol.
    }

    /// JPEG_HUFFSYMB10 Register bits
    namespace jpeg_huffsymb10_bits {
        constexpr uint32_t DATA40 = (8 << 0);  ///< Data 40 Huffman symbol.
        constexpr uint32_t DATA41 = (8 << 8);  ///< Data 41 Huffman symbol.
        constexpr uint32_t DATA42 = (8 << 16);  ///< Data 42 Huffman symbol.
        constexpr uint32_t DATA43 = (8 << 24);  ///< Data 43 Huffman symbol.
    }

    /// JPEG_HUFFSYMB11 Register bits
    namespace jpeg_huffsymb11_bits {
        constexpr uint32_t DATA44 = (8 << 0);  ///< Data 44 Huffman symbol.
        constexpr uint32_t DATA45 = (8 << 8);  ///< Data 45 Huffman symbol.
        constexpr uint32_t DATA46 = (8 << 16);  ///< Data 46 Huffman symbol.
        constexpr uint32_t DATA47 = (8 << 24);  ///< Data 47 Huffman symbol.
    }

    /// JPEG_HUFFSYMB12 Register bits
    namespace jpeg_huffsymb12_bits {
        constexpr uint32_t DATA48 = (8 << 0);  ///< Data 48 Huffman symbol.
        constexpr uint32_t DATA49 = (8 << 8);  ///< Data 49 Huffman symbol.
        constexpr uint32_t DATA50 = (8 << 16);  ///< Data 50 Huffman symbol.
        constexpr uint32_t DATA51 = (8 << 24);  ///< Data 51 Huffman symbol.
    }

    /// JPEG_HUFFSYMB13 Register bits
    namespace jpeg_huffsymb13_bits {
        constexpr uint32_t DATA52 = (8 << 0);  ///< Data 52 Huffman symbol.
        constexpr uint32_t DATA53 = (8 << 8);  ///< Data 53 Huffman symbol.
        constexpr uint32_t DATA54 = (8 << 16);  ///< Data 54 Huffman symbol.
        constexpr uint32_t DATA55 = (8 << 24);  ///< Data 55 Huffman symbol.
    }

    /// JPEG_HUFFSYMB14 Register bits
    namespace jpeg_huffsymb14_bits {
        constexpr uint32_t DATA56 = (8 << 0);  ///< Data 56 Huffman symbol.
        constexpr uint32_t DATA57 = (8 << 8);  ///< Data 57 Huffman symbol.
        constexpr uint32_t DATA58 = (8 << 16);  ///< Data 58 Huffman symbol.
        constexpr uint32_t DATA59 = (8 << 24);  ///< Data 59 Huffman symbol.
    }

    /// JPEG_HUFFSYMB15 Register bits
    namespace jpeg_huffsymb15_bits {
        constexpr uint32_t DATA60 = (8 << 0);  ///< Data 60 Huffman symbol.
        constexpr uint32_t DATA61 = (8 << 8);  ///< Data 61 Huffman symbol.
        constexpr uint32_t DATA62 = (8 << 16);  ///< Data 62 Huffman symbol.
        constexpr uint32_t DATA63 = (8 << 24);  ///< Data 63 Huffman symbol.
    }

    /// JPEG_HUFFSYMB16 Register bits
    namespace jpeg_huffsymb16_bits {
        constexpr uint32_t DATA64 = (8 << 0);  ///< Data 64 Huffman symbol.
        constexpr uint32_t DATA65 = (8 << 8);  ///< Data 65 Huffman symbol.
        constexpr uint32_t DATA66 = (8 << 16);  ///< Data 66 Huffman symbol.
        constexpr uint32_t DATA67 = (8 << 24);  ///< Data 67 Huffman symbol.
    }

    /// JPEG_HUFFSYMB17 Register bits
    namespace jpeg_huffsymb17_bits {
        constexpr uint32_t DATA68 = (8 << 0);  ///< Data 68 Huffman symbol.
        constexpr uint32_t DATA69 = (8 << 8);  ///< Data 69 Huffman symbol.
        constexpr uint32_t DATA70 = (8 << 16);  ///< Data 70 Huffman symbol.
        constexpr uint32_t DATA71 = (8 << 24);  ///< Data 71 Huffman symbol.
    }

    /// JPEG_HUFFSYMB18 Register bits
    namespace jpeg_huffsymb18_bits {
        constexpr uint32_t DATA72 = (8 << 0);  ///< Data 72 Huffman symbol.
        constexpr uint32_t DATA73 = (8 << 8);  ///< Data 73 Huffman symbol.
        constexpr uint32_t DATA74 = (8 << 16);  ///< Data 74 Huffman symbol.
        constexpr uint32_t DATA75 = (8 << 24);  ///< Data 75 Huffman symbol.
    }

    /// JPEG_HUFFSYMB19 Register bits
    namespace jpeg_huffsymb19_bits {
        constexpr uint32_t DATA76 = (8 << 0);  ///< Data 76 Huffman symbol.
        constexpr uint32_t DATA77 = (8 << 8);  ///< Data 77 Huffman symbol.
        constexpr uint32_t DATA78 = (8 << 16);  ///< Data 78 Huffman symbol.
        constexpr uint32_t DATA79 = (8 << 24);  ///< Data 79 Huffman symbol.
    }

    /// JPEG_HUFFSYMB20 Register bits
    namespace jpeg_huffsymb20_bits {
        constexpr uint32_t DATA80 = (8 << 0);  ///< Data 80 Huffman symbol.
        constexpr uint32_t DATA81 = (8 << 8);  ///< Data 81 Huffman symbol.
        constexpr uint32_t DATA82 = (8 << 16);  ///< Data 82 Huffman symbol.
        constexpr uint32_t DATA83 = (8 << 24);  ///< Data 83 Huffman symbol.
    }

    /// JPEG_HUFFSYMB21 Register bits
    namespace jpeg_huffsymb21_bits {
        constexpr uint32_t DATA84 = (8 << 0);  ///< Data 84 Huffman symbol.
        constexpr uint32_t DATA85 = (8 << 8);  ///< Data 85 Huffman symbol.
        constexpr uint32_t DATA86 = (8 << 16);  ///< Data 86 Huffman symbol.
        constexpr uint32_t DATA87 = (8 << 24);  ///< Data 87 Huffman symbol.
    }

    /// JPEG_HUFFSYMB22 Register bits
    namespace jpeg_huffsymb22_bits {
        constexpr uint32_t DATA88 = (8 << 0);  ///< Data 88 Huffman symbol.
        constexpr uint32_t DATA89 = (8 << 8);  ///< Data 89 Huffman symbol.
        constexpr uint32_t DATA90 = (8 << 16);  ///< Data 90 Huffman symbol.
        constexpr uint32_t DATA91 = (8 << 24);  ///< Data 91 Huffman symbol.
    }

    /// JPEG_HUFFSYMB23 Register bits
    namespace jpeg_huffsymb23_bits {
        constexpr uint32_t DATA92 = (8 << 0);  ///< Data 92 Huffman symbol.
        constexpr uint32_t DATA93 = (8 << 8);  ///< Data 93 Huffman symbol.
        constexpr uint32_t DATA94 = (8 << 16);  ///< Data 94 Huffman symbol.
        constexpr uint32_t DATA95 = (8 << 24);  ///< Data 95 Huffman symbol.
    }

    /// JPEG_HUFFSYMB24 Register bits
    namespace jpeg_huffsymb24_bits {
        constexpr uint32_t DATA96 = (8 << 0);  ///< Data 96 Huffman symbol.
        constexpr uint32_t DATA97 = (8 << 8);  ///< Data 97 Huffman symbol.
        constexpr uint32_t DATA98 = (8 << 16);  ///< Data 98 Huffman symbol.
        constexpr uint32_t DATA99 = (8 << 24);  ///< Data 99 Huffman symbol.
    }

    /// JPEG_HUFFSYMB25 Register bits
    namespace jpeg_huffsymb25_bits {
        constexpr uint32_t DATA100 = (8 << 0);  ///< Data 100 Huffman symbol.
        constexpr uint32_t DATA101 = (8 << 8);  ///< Data 101 Huffman symbol.
        constexpr uint32_t DATA102 = (8 << 16);  ///< Data 102 Huffman symbol.
        constexpr uint32_t DATA103 = (8 << 24);  ///< Data 103 Huffman symbol.
    }

    /// JPEG_HUFFSYMB26 Register bits
    namespace jpeg_huffsymb26_bits {
        constexpr uint32_t DATA104 = (8 << 0);  ///< Data 104 Huffman symbol.
        constexpr uint32_t DATA105 = (8 << 8);  ///< Data 105 Huffman symbol.
        constexpr uint32_t DATA106 = (8 << 16);  ///< Data 106 Huffman symbol.
        constexpr uint32_t DATA107 = (8 << 24);  ///< Data 107 Huffman symbol.
    }

    /// JPEG_HUFFSYMB27 Register bits
    namespace jpeg_huffsymb27_bits {
        constexpr uint32_t DATA108 = (8 << 0);  ///< Data 108 Huffman symbol.
        constexpr uint32_t DATA109 = (8 << 8);  ///< Data 109 Huffman symbol.
        constexpr uint32_t DATA110 = (8 << 16);  ///< Data 110 Huffman symbol.
        constexpr uint32_t DATA111 = (8 << 24);  ///< Data 111 Huffman symbol.
    }

    /// JPEG_HUFFSYMB28 Register bits
    namespace jpeg_huffsymb28_bits {
        constexpr uint32_t DATA112 = (8 << 0);  ///< Data 112 Huffman symbol.
        constexpr uint32_t DATA113 = (8 << 8);  ///< Data 113 Huffman symbol.
        constexpr uint32_t DATA114 = (8 << 16);  ///< Data 114 Huffman symbol.
        constexpr uint32_t DATA115 = (8 << 24);  ///< Data 115 Huffman symbol.
    }

    /// JPEG_HUFFSYMB29 Register bits
    namespace jpeg_huffsymb29_bits {
        constexpr uint32_t DATA116 = (8 << 0);  ///< Data 116 Huffman symbol.
        constexpr uint32_t DATA117 = (8 << 8);  ///< Data 117 Huffman symbol.
        constexpr uint32_t DATA118 = (8 << 16);  ///< Data 118 Huffman symbol.
        constexpr uint32_t DATA119 = (8 << 24);  ///< Data 119 Huffman symbol.
    }

    /// JPEG_HUFFSYMB30 Register bits
    namespace jpeg_huffsymb30_bits {
        constexpr uint32_t DATA120 = (8 << 0);  ///< Data 120 Huffman symbol.
        constexpr uint32_t DATA121 = (8 << 8);  ///< Data 121 Huffman symbol.
        constexpr uint32_t DATA122 = (8 << 16);  ///< Data 122 Huffman symbol.
        constexpr uint32_t DATA123 = (8 << 24);  ///< Data 123 Huffman symbol.
    }

    /// JPEG_HUFFSYMB31 Register bits
    namespace jpeg_huffsymb31_bits {
        constexpr uint32_t DATA124 = (8 << 0);  ///< Data 124 Huffman symbol.
        constexpr uint32_t DATA125 = (8 << 8);  ///< Data 125 Huffman symbol.
        constexpr uint32_t DATA126 = (8 << 16);  ///< Data 126 Huffman symbol.
        constexpr uint32_t DATA127 = (8 << 24);  ///< Data 127 Huffman symbol.
    }

    /// JPEG_HUFFSYMB32 Register bits
    namespace jpeg_huffsymb32_bits {
        constexpr uint32_t DATA128 = (8 << 0);  ///< Data 128 Huffman symbol.
        constexpr uint32_t DATA129 = (8 << 8);  ///< Data 129 Huffman symbol.
        constexpr uint32_t DATA130 = (8 << 16);  ///< Data 130 Huffman symbol.
        constexpr uint32_t DATA131 = (8 << 24);  ///< Data 131 Huffman symbol.
    }

    /// JPEG_HUFFSYMB33 Register bits
    namespace jpeg_huffsymb33_bits {
        constexpr uint32_t DATA132 = (8 << 0);  ///< Data 132 Huffman symbol.
        constexpr uint32_t DATA133 = (8 << 8);  ///< Data 133 Huffman symbol.
        constexpr uint32_t DATA134 = (8 << 16);  ///< Data 134 Huffman symbol.
        constexpr uint32_t DATA135 = (8 << 24);  ///< Data 135 Huffman symbol.
    }

    /// JPEG_HUFFSYMB34 Register bits
    namespace jpeg_huffsymb34_bits {
        constexpr uint32_t DATA136 = (8 << 0);  ///< Data 136 Huffman symbol.
        constexpr uint32_t DATA137 = (8 << 8);  ///< Data 137 Huffman symbol.
        constexpr uint32_t DATA138 = (8 << 16);  ///< Data 138 Huffman symbol.
        constexpr uint32_t DATA139 = (8 << 24);  ///< Data 139 Huffman symbol.
    }

    /// JPEG_HUFFSYMB35 Register bits
    namespace jpeg_huffsymb35_bits {
        constexpr uint32_t DATA140 = (8 << 0);  ///< Data 140 Huffman symbol.
        constexpr uint32_t DATA141 = (8 << 8);  ///< Data 141 Huffman symbol.
        constexpr uint32_t DATA142 = (8 << 16);  ///< Data 142 Huffman symbol.
        constexpr uint32_t DATA143 = (8 << 24);  ///< Data 143 Huffman symbol.
    }

    /// JPEG_HUFFSYMB36 Register bits
    namespace jpeg_huffsymb36_bits {
        constexpr uint32_t DATA144 = (8 << 0);  ///< Data 144 Huffman symbol.
        constexpr uint32_t DATA145 = (8 << 8);  ///< Data 145 Huffman symbol.
        constexpr uint32_t DATA146 = (8 << 16);  ///< Data 146 Huffman symbol.
        constexpr uint32_t DATA147 = (8 << 24);  ///< Data 147 Huffman symbol.
    }

    /// JPEG_HUFFSYMB37 Register bits
    namespace jpeg_huffsymb37_bits {
        constexpr uint32_t DATA148 = (8 << 0);  ///< Data 148 Huffman symbol.
        constexpr uint32_t DATA149 = (8 << 8);  ///< Data 149 Huffman symbol.
        constexpr uint32_t DATA150 = (8 << 16);  ///< Data 150 Huffman symbol.
        constexpr uint32_t DATA151 = (8 << 24);  ///< Data 151 Huffman symbol.
    }

    /// JPEG_HUFFSYMB38 Register bits
    namespace jpeg_huffsymb38_bits {
        constexpr uint32_t DATA152 = (8 << 0);  ///< Data 152 Huffman symbol.
        constexpr uint32_t DATA153 = (8 << 8);  ///< Data 153 Huffman symbol.
        constexpr uint32_t DATA154 = (8 << 16);  ///< Data 154 Huffman symbol.
        constexpr uint32_t DATA155 = (8 << 24);  ///< Data 155 Huffman symbol.
    }

    /// JPEG_HUFFSYMB39 Register bits
    namespace jpeg_huffsymb39_bits {
        constexpr uint32_t DATA156 = (8 << 0);  ///< Data 156 Huffman symbol.
        constexpr uint32_t DATA157 = (8 << 8);  ///< Data 157 Huffman symbol.
        constexpr uint32_t DATA158 = (8 << 16);  ///< Data 158 Huffman symbol.
        constexpr uint32_t DATA159 = (8 << 24);  ///< Data 159 Huffman symbol.
    }

    /// JPEG_HUFFSYMB40 Register bits
    namespace jpeg_huffsymb40_bits {
        constexpr uint32_t DATA160 = (8 << 0);  ///< Data 160 Huffman symbol.
        constexpr uint32_t DATA161 = (8 << 8);  ///< Data 161 Huffman symbol.
        constexpr uint32_t DATA162 = (8 << 16);  ///< Data 162 Huffman symbol.
        constexpr uint32_t DATA163 = (8 << 24);  ///< Data 163 Huffman symbol.
    }

    /// JPEG_HUFFSYMB41 Register bits
    namespace jpeg_huffsymb41_bits {
        constexpr uint32_t DATA164 = (8 << 0);  ///< Data 164 Huffman symbol.
        constexpr uint32_t DATA165 = (8 << 8);  ///< Data 165 Huffman symbol.
        constexpr uint32_t DATA166 = (8 << 16);  ///< Data 166 Huffman symbol.
        constexpr uint32_t DATA167 = (8 << 24);  ///< Data 167 Huffman symbol.
    }

    /// JPEG_HUFFSYMB42 Register bits
    namespace jpeg_huffsymb42_bits {
        constexpr uint32_t DATA168 = (8 << 0);  ///< Data 168 Huffman symbol.
        constexpr uint32_t DATA169 = (8 << 8);  ///< Data 169 Huffman symbol.
        constexpr uint32_t DATA170 = (8 << 16);  ///< Data 170 Huffman symbol.
        constexpr uint32_t DATA171 = (8 << 24);  ///< Data 171 Huffman symbol.
    }

    /// JPEG_HUFFSYMB43 Register bits
    namespace jpeg_huffsymb43_bits {
        constexpr uint32_t DATA172 = (8 << 0);  ///< Data 172 Huffman symbol.
        constexpr uint32_t DATA173 = (8 << 8);  ///< Data 173 Huffman symbol.
        constexpr uint32_t DATA174 = (8 << 16);  ///< Data 174 Huffman symbol.
        constexpr uint32_t DATA175 = (8 << 24);  ///< Data 175 Huffman symbol.
    }

    /// JPEG_HUFFSYMB44 Register bits
    namespace jpeg_huffsymb44_bits {
        constexpr uint32_t DATA176 = (8 << 0);  ///< Data 176 Huffman symbol.
        constexpr uint32_t DATA177 = (8 << 8);  ///< Data 177 Huffman symbol.
        constexpr uint32_t DATA178 = (8 << 16);  ///< Data 178 Huffman symbol.
        constexpr uint32_t DATA179 = (8 << 24);  ///< Data 179 Huffman symbol.
    }

    /// JPEG_HUFFSYMB45 Register bits
    namespace jpeg_huffsymb45_bits {
        constexpr uint32_t DATA180 = (8 << 0);  ///< Data 180 Huffman symbol.
        constexpr uint32_t DATA181 = (8 << 8);  ///< Data 181 Huffman symbol.
        constexpr uint32_t DATA182 = (8 << 16);  ///< Data 182 Huffman symbol.
        constexpr uint32_t DATA183 = (8 << 24);  ///< Data 183 Huffman symbol.
    }

    /// JPEG_HUFFSYMB46 Register bits
    namespace jpeg_huffsymb46_bits {
        constexpr uint32_t DATA184 = (8 << 0);  ///< Data 184 Huffman symbol.
        constexpr uint32_t DATA185 = (8 << 8);  ///< Data 185 Huffman symbol.
        constexpr uint32_t DATA186 = (8 << 16);  ///< Data 186 Huffman symbol.
        constexpr uint32_t DATA187 = (8 << 24);  ///< Data 187 Huffman symbol.
    }

    /// JPEG_HUFFSYMB47 Register bits
    namespace jpeg_huffsymb47_bits {
        constexpr uint32_t DATA188 = (8 << 0);  ///< Data 188 Huffman symbol.
        constexpr uint32_t DATA189 = (8 << 8);  ///< Data 189 Huffman symbol.
        constexpr uint32_t DATA190 = (8 << 16);  ///< Data 190 Huffman symbol.
        constexpr uint32_t DATA191 = (8 << 24);  ///< Data 191 Huffman symbol.
    }

    /// JPEG_HUFFSYMB48 Register bits
    namespace jpeg_huffsymb48_bits {
        constexpr uint32_t DATA192 = (8 << 0);  ///< Data 192 Huffman symbol.
        constexpr uint32_t DATA193 = (8 << 8);  ///< Data 193 Huffman symbol.
        constexpr uint32_t DATA194 = (8 << 16);  ///< Data 194 Huffman symbol.
        constexpr uint32_t DATA195 = (8 << 24);  ///< Data 195 Huffman symbol.
    }

    /// JPEG_HUFFSYMB49 Register bits
    namespace jpeg_huffsymb49_bits {
        constexpr uint32_t DATA196 = (8 << 0);  ///< Data 196 Huffman symbol.
        constexpr uint32_t DATA197 = (8 << 8);  ///< Data 197 Huffman symbol.
        constexpr uint32_t DATA198 = (8 << 16);  ///< Data 198 Huffman symbol.
        constexpr uint32_t DATA199 = (8 << 24);  ///< Data 199 Huffman symbol.
    }

    /// JPEG_HUFFSYMB50 Register bits
    namespace jpeg_huffsymb50_bits {
        constexpr uint32_t DATA200 = (8 << 0);  ///< Data 200 Huffman symbol.
        constexpr uint32_t DATA201 = (8 << 8);  ///< Data 201 Huffman symbol.
        constexpr uint32_t DATA202 = (8 << 16);  ///< Data 202 Huffman symbol.
        constexpr uint32_t DATA203 = (8 << 24);  ///< Data 203 Huffman symbol.
    }

    /// JPEG_HUFFSYMB51 Register bits
    namespace jpeg_huffsymb51_bits {
        constexpr uint32_t DATA204 = (8 << 0);  ///< Data 204 Huffman symbol.
        constexpr uint32_t DATA205 = (8 << 8);  ///< Data 205 Huffman symbol.
        constexpr uint32_t DATA206 = (8 << 16);  ///< Data 206 Huffman symbol.
        constexpr uint32_t DATA207 = (8 << 24);  ///< Data 207 Huffman symbol.
    }

    /// JPEG_HUFFSYMB52 Register bits
    namespace jpeg_huffsymb52_bits {
        constexpr uint32_t DATA208 = (8 << 0);  ///< Data 208 Huffman symbol.
        constexpr uint32_t DATA209 = (8 << 8);  ///< Data 209 Huffman symbol.
        constexpr uint32_t DATA210 = (8 << 16);  ///< Data 210 Huffman symbol.
        constexpr uint32_t DATA211 = (8 << 24);  ///< Data 211 Huffman symbol.
    }

    /// JPEG_HUFFSYMB53 Register bits
    namespace jpeg_huffsymb53_bits {
        constexpr uint32_t DATA212 = (8 << 0);  ///< Data 212 Huffman symbol.
        constexpr uint32_t DATA213 = (8 << 8);  ///< Data 213 Huffman symbol.
        constexpr uint32_t DATA214 = (8 << 16);  ///< Data 214 Huffman symbol.
        constexpr uint32_t DATA215 = (8 << 24);  ///< Data 215 Huffman symbol.
    }

    /// JPEG_HUFFSYMB54 Register bits
    namespace jpeg_huffsymb54_bits {
        constexpr uint32_t DATA216 = (8 << 0);  ///< Data 216 Huffman symbol.
        constexpr uint32_t DATA217 = (8 << 8);  ///< Data 217 Huffman symbol.
        constexpr uint32_t DATA218 = (8 << 16);  ///< Data 218 Huffman symbol.
        constexpr uint32_t DATA219 = (8 << 24);  ///< Data 219 Huffman symbol.
    }

    /// JPEG_HUFFSYMB55 Register bits
    namespace jpeg_huffsymb55_bits {
        constexpr uint32_t DATA220 = (8 << 0);  ///< Data 220 Huffman symbol.
        constexpr uint32_t DATA221 = (8 << 8);  ///< Data 221 Huffman symbol.
        constexpr uint32_t DATA222 = (8 << 16);  ///< Data 222 Huffman symbol.
        constexpr uint32_t DATA223 = (8 << 24);  ///< Data 223 Huffman symbol.
    }

    /// JPEG_HUFFSYMB56 Register bits
    namespace jpeg_huffsymb56_bits {
        constexpr uint32_t DATA224 = (8 << 0);  ///< Data 224 Huffman symbol.
        constexpr uint32_t DATA225 = (8 << 8);  ///< Data 225 Huffman symbol.
        constexpr uint32_t DATA226 = (8 << 16);  ///< Data 226 Huffman symbol.
        constexpr uint32_t DATA227 = (8 << 24);  ///< Data 227 Huffman symbol.
    }

    /// JPEG_HUFFSYMB57 Register bits
    namespace jpeg_huffsymb57_bits {
        constexpr uint32_t DATA228 = (8 << 0);  ///< Data 228 Huffman symbol.
        constexpr uint32_t DATA229 = (8 << 8);  ///< Data 229 Huffman symbol.
        constexpr uint32_t DATA230 = (8 << 16);  ///< Data 230 Huffman symbol.
        constexpr uint32_t DATA231 = (8 << 24);  ///< Data 231 Huffman symbol.
    }

    /// JPEG_HUFFSYMB58 Register bits
    namespace jpeg_huffsymb58_bits {
        constexpr uint32_t DATA232 = (8 << 0);  ///< Data 232 Huffman symbol.
        constexpr uint32_t DATA233 = (8 << 8);  ///< Data 233 Huffman symbol.
        constexpr uint32_t DATA234 = (8 << 16);  ///< Data 234 Huffman symbol.
        constexpr uint32_t DATA235 = (8 << 24);  ///< Data 235 Huffman symbol.
    }

    /// JPEG_HUFFSYMB59 Register bits
    namespace jpeg_huffsymb59_bits {
        constexpr uint32_t DATA236 = (8 << 0);  ///< Data 236 Huffman symbol.
        constexpr uint32_t DATA237 = (8 << 8);  ///< Data 237 Huffman symbol.
        constexpr uint32_t DATA238 = (8 << 16);  ///< Data 238 Huffman symbol.
        constexpr uint32_t DATA239 = (8 << 24);  ///< Data 239 Huffman symbol.
    }

    /// JPEG_HUFFSYMB60 Register bits
    namespace jpeg_huffsymb60_bits {
        constexpr uint32_t DATA240 = (8 << 0);  ///< Data 240 Huffman symbol.
        constexpr uint32_t DATA241 = (8 << 8);  ///< Data 241 Huffman symbol.
        constexpr uint32_t DATA242 = (8 << 16);  ///< Data 242 Huffman symbol.
        constexpr uint32_t DATA243 = (8 << 24);  ///< Data 243 Huffman symbol.
    }

    /// JPEG_HUFFSYMB61 Register bits
    namespace jpeg_huffsymb61_bits {
        constexpr uint32_t DATA244 = (8 << 0);  ///< Data 244 Huffman symbol.
        constexpr uint32_t DATA245 = (8 << 8);  ///< Data 245 Huffman symbol.
        constexpr uint32_t DATA246 = (8 << 16);  ///< Data 246 Huffman symbol.
        constexpr uint32_t DATA247 = (8 << 24);  ///< Data 247 Huffman symbol.
    }

    /// JPEG_HUFFSYMB62 Register bits
    namespace jpeg_huffsymb62_bits {
        constexpr uint32_t DATA248 = (8 << 0);  ///< Data 248 Huffman symbol.
        constexpr uint32_t DATA249 = (8 << 8);  ///< Data 249 Huffman symbol.
        constexpr uint32_t DATA250 = (8 << 16);  ///< Data 250 Huffman symbol.
        constexpr uint32_t DATA251 = (8 << 24);  ///< Data 251 Huffman symbol.
    }

    /// JPEG_HUFFSYMB63 Register bits
    namespace jpeg_huffsymb63_bits {
        constexpr uint32_t DATA252 = (8 << 0);  ///< Data 252 Huffman symbol.
        constexpr uint32_t DATA253 = (8 << 8);  ///< Data 253 Huffman symbol.
        constexpr uint32_t DATA254 = (8 << 16);  ///< Data 254 Huffman symbol.
        constexpr uint32_t DATA255 = (8 << 24);  ///< Data 255 Huffman symbol.
    }

    /// JPEG_HUFFSYMB64 Register bits
    namespace jpeg_huffsymb64_bits {
        constexpr uint32_t DATA256 = (8 << 0);  ///< Data 256 Huffman symbol.
        constexpr uint32_t DATA257 = (8 << 8);  ///< Data 257 Huffman symbol.
        constexpr uint32_t DATA258 = (8 << 16);  ///< Data 258 Huffman symbol.
        constexpr uint32_t DATA259 = (8 << 24);  ///< Data 259 Huffman symbol.
    }

    /// JPEG_HUFFSYMB65 Register bits
    namespace jpeg_huffsymb65_bits {
        constexpr uint32_t DATA260 = (8 << 0);  ///< Data 260 Huffman symbol.
        constexpr uint32_t DATA261 = (8 << 8);  ///< Data 261 Huffman symbol.
        constexpr uint32_t DATA262 = (8 << 16);  ///< Data 262 Huffman symbol.
        constexpr uint32_t DATA263 = (8 << 24);  ///< Data 263 Huffman symbol.
    }

    /// JPEG_HUFFSYMB66 Register bits
    namespace jpeg_huffsymb66_bits {
        constexpr uint32_t DATA264 = (8 << 0);  ///< Data 264 Huffman symbol.
        constexpr uint32_t DATA265 = (8 << 8);  ///< Data 265 Huffman symbol.
        constexpr uint32_t DATA266 = (8 << 16);  ///< Data 266 Huffman symbol.
        constexpr uint32_t DATA267 = (8 << 24);  ///< Data 267 Huffman symbol.
    }

    /// JPEG_HUFFSYMB67 Register bits
    namespace jpeg_huffsymb67_bits {
        constexpr uint32_t DATA268 = (8 << 0);  ///< Data 268 Huffman symbol.
        constexpr uint32_t DATA269 = (8 << 8);  ///< Data 269 Huffman symbol.
        constexpr uint32_t DATA270 = (8 << 16);  ///< Data 270 Huffman symbol.
        constexpr uint32_t DATA271 = (8 << 24);  ///< Data 271 Huffman symbol.
    }

    /// JPEG_HUFFSYMB68 Register bits
    namespace jpeg_huffsymb68_bits {
        constexpr uint32_t DATA272 = (8 << 0);  ///< Data 272 Huffman symbol.
        constexpr uint32_t DATA273 = (8 << 8);  ///< Data 273 Huffman symbol.
        constexpr uint32_t DATA274 = (8 << 16);  ///< Data 274 Huffman symbol.
        constexpr uint32_t DATA275 = (8 << 24);  ///< Data 275 Huffman symbol.
    }

    /// JPEG_HUFFSYMB69 Register bits
    namespace jpeg_huffsymb69_bits {
        constexpr uint32_t DATA276 = (8 << 0);  ///< Data 276 Huffman symbol.
        constexpr uint32_t DATA277 = (8 << 8);  ///< Data 277 Huffman symbol.
        constexpr uint32_t DATA278 = (8 << 16);  ///< Data 278 Huffman symbol.
        constexpr uint32_t DATA279 = (8 << 24);  ///< Data 279 Huffman symbol.
    }

    /// JPEG_HUFFSYMB70 Register bits
    namespace jpeg_huffsymb70_bits {
        constexpr uint32_t DATA280 = (8 << 0);  ///< Data 280 Huffman symbol.
        constexpr uint32_t DATA281 = (8 << 8);  ///< Data 281 Huffman symbol.
        constexpr uint32_t DATA282 = (8 << 16);  ///< Data 282 Huffman symbol.
        constexpr uint32_t DATA283 = (8 << 24);  ///< Data 283 Huffman symbol.
    }

    /// JPEG_HUFFSYMB71 Register bits
    namespace jpeg_huffsymb71_bits {
        constexpr uint32_t DATA284 = (8 << 0);  ///< Data 284 Huffman symbol.
        constexpr uint32_t DATA285 = (8 << 8);  ///< Data 285 Huffman symbol.
        constexpr uint32_t DATA286 = (8 << 16);  ///< Data 286 Huffman symbol.
        constexpr uint32_t DATA287 = (8 << 24);  ///< Data 287 Huffman symbol.
    }

    /// JPEG_HUFFSYMB72 Register bits
    namespace jpeg_huffsymb72_bits {
        constexpr uint32_t DATA288 = (8 << 0);  ///< Data 288 Huffman symbol.
        constexpr uint32_t DATA289 = (8 << 8);  ///< Data 289 Huffman symbol.
        constexpr uint32_t DATA290 = (8 << 16);  ///< Data 290 Huffman symbol.
        constexpr uint32_t DATA291 = (8 << 24);  ///< Data 291 Huffman symbol.
    }

    /// JPEG_HUFFSYMB73 Register bits
    namespace jpeg_huffsymb73_bits {
        constexpr uint32_t DATA292 = (8 << 0);  ///< Data 292 Huffman symbol.
        constexpr uint32_t DATA293 = (8 << 8);  ///< Data 293 Huffman symbol.
        constexpr uint32_t DATA294 = (8 << 16);  ///< Data 294 Huffman symbol.
        constexpr uint32_t DATA295 = (8 << 24);  ///< Data 295 Huffman symbol.
    }

    /// JPEG_HUFFSYMB74 Register bits
    namespace jpeg_huffsymb74_bits {
        constexpr uint32_t DATA296 = (8 << 0);  ///< Data 296 Huffman symbol.
        constexpr uint32_t DATA297 = (8 << 8);  ///< Data 297 Huffman symbol.
        constexpr uint32_t DATA298 = (8 << 16);  ///< Data 298 Huffman symbol.
        constexpr uint32_t DATA299 = (8 << 24);  ///< Data 299 Huffman symbol.
    }

    /// JPEG_HUFFSYMB75 Register bits
    namespace jpeg_huffsymb75_bits {
        constexpr uint32_t DATA300 = (8 << 0);  ///< Data 300 Huffman symbol.
        constexpr uint32_t DATA301 = (8 << 8);  ///< Data 301 Huffman symbol.
        constexpr uint32_t DATA302 = (8 << 16);  ///< Data 302 Huffman symbol.
        constexpr uint32_t DATA303 = (8 << 24);  ///< Data 303 Huffman symbol.
    }

    /// JPEG_HUFFSYMB76 Register bits
    namespace jpeg_huffsymb76_bits {
        constexpr uint32_t DATA304 = (8 << 0);  ///< Data 304 Huffman symbol.
        constexpr uint32_t DATA305 = (8 << 8);  ///< Data 305 Huffman symbol.
        constexpr uint32_t DATA306 = (8 << 16);  ///< Data 306 Huffman symbol.
        constexpr uint32_t DATA307 = (8 << 24);  ///< Data 307 Huffman symbol.
    }

    /// JPEG_HUFFSYMB77 Register bits
    namespace jpeg_huffsymb77_bits {
        constexpr uint32_t DATA308 = (8 << 0);  ///< Data 308 Huffman symbol.
        constexpr uint32_t DATA309 = (8 << 8);  ///< Data 309 Huffman symbol.
        constexpr uint32_t DATA310 = (8 << 16);  ///< Data 310 Huffman symbol.
        constexpr uint32_t DATA311 = (8 << 24);  ///< Data 311 Huffman symbol.
    }

    /// JPEG_HUFFSYMB78 Register bits
    namespace jpeg_huffsymb78_bits {
        constexpr uint32_t DATA312 = (8 << 0);  ///< Data 312 Huffman symbol.
        constexpr uint32_t DATA313 = (8 << 8);  ///< Data 313 Huffman symbol.
        constexpr uint32_t DATA314 = (8 << 16);  ///< Data 314 Huffman symbol.
        constexpr uint32_t DATA315 = (8 << 24);  ///< Data 315 Huffman symbol.
    }

    /// JPEG_HUFFSYMB79 Register bits
    namespace jpeg_huffsymb79_bits {
        constexpr uint32_t DATA316 = (8 << 0);  ///< Data 316 Huffman symbol.
        constexpr uint32_t DATA317 = (8 << 8);  ///< Data 317 Huffman symbol.
        constexpr uint32_t DATA318 = (8 << 16);  ///< Data 318 Huffman symbol.
        constexpr uint32_t DATA319 = (8 << 24);  ///< Data 319 Huffman symbol.
    }

    /// JPEG_HUFFSYMB80 Register bits
    namespace jpeg_huffsymb80_bits {
        constexpr uint32_t DATA320 = (8 << 0);  ///< Data 320 Huffman symbol.
        constexpr uint32_t DATA321 = (8 << 8);  ///< Data 321 Huffman symbol.
        constexpr uint32_t DATA322 = (8 << 16);  ///< Data 322 Huffman symbol.
        constexpr uint32_t DATA323 = (8 << 24);  ///< Data 323 Huffman symbol.
    }

    /// JPEG_HUFFSYMB81 Register bits
    namespace jpeg_huffsymb81_bits {
        constexpr uint32_t DATA324 = (8 << 0);  ///< Data 324 Huffman symbol.
        constexpr uint32_t DATA325 = (8 << 8);  ///< Data 325 Huffman symbol.
        constexpr uint32_t DATA326 = (8 << 16);  ///< Data 326 Huffman symbol.
        constexpr uint32_t DATA327 = (8 << 24);  ///< Data 327 Huffman symbol.
    }

    /// JPEG_HUFFSYMB82 Register bits
    namespace jpeg_huffsymb82_bits {
        constexpr uint32_t DATA328 = (8 << 0);  ///< Data 328 Huffman symbol.
        constexpr uint32_t DATA329 = (8 << 8);  ///< Data 329 Huffman symbol.
        constexpr uint32_t DATA330 = (8 << 16);  ///< Data 330 Huffman symbol.
        constexpr uint32_t DATA331 = (8 << 24);  ///< Data 331 Huffman symbol.
    }

    /// JPEG_HUFFSYMB83 Register bits
    namespace jpeg_huffsymb83_bits {
        constexpr uint32_t DATA332 = (8 << 0);  ///< Data 332 Huffman symbol.
        constexpr uint32_t DATA333 = (8 << 8);  ///< Data 333 Huffman symbol.
        constexpr uint32_t DATA334 = (8 << 16);  ///< Data 334 Huffman symbol.
        constexpr uint32_t DATA335 = (8 << 24);  ///< Data 335 Huffman symbol.
    }

    /// JPEG_DHTMEM0 Register bits
    namespace jpeg_dhtmem0_bits {
        constexpr uint32_t DATA0 = (8 << 0);  ///< Huffman table data 0 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA1 = (8 << 8);  ///< Huffman table data 1 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA2 = (8 << 16);  ///< Huffman table data 2 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA3 = (8 << 24);  ///< Huffman table data 3 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM1 Register bits
    namespace jpeg_dhtmem1_bits {
        constexpr uint32_t DATA4 = (8 << 0);  ///< Huffman table data 4 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA5 = (8 << 8);  ///< Huffman table data 5 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA6 = (8 << 16);  ///< Huffman table data 6 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA7 = (8 << 24);  ///< Huffman table data 7 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM2 Register bits
    namespace jpeg_dhtmem2_bits {
        constexpr uint32_t DATA8 = (8 << 0);  ///< Huffman table data 8 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA9 = (8 << 8);  ///< Huffman table data 9 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA10 = (8 << 16);  ///< Huffman table data 10 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA11 = (8 << 24);  ///< Huffman table data 11 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM3 Register bits
    namespace jpeg_dhtmem3_bits {
        constexpr uint32_t DATA12 = (8 << 0);  ///< Huffman table data 12 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA13 = (8 << 8);  ///< Huffman table data 13 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA14 = (8 << 16);  ///< Huffman table data 14 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA15 = (8 << 24);  ///< Huffman table data 15 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM4 Register bits
    namespace jpeg_dhtmem4_bits {
        constexpr uint32_t DATA16 = (8 << 0);  ///< Huffman table data 16 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA17 = (8 << 8);  ///< Huffman table data 17 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA18 = (8 << 16);  ///< Huffman table data 18 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA19 = (8 << 24);  ///< Huffman table data 19 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM5 Register bits
    namespace jpeg_dhtmem5_bits {
        constexpr uint32_t DATA20 = (8 << 0);  ///< Huffman table data 20 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA21 = (8 << 8);  ///< Huffman table data 21 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA22 = (8 << 16);  ///< Huffman table data 22 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA23 = (8 << 24);  ///< Huffman table data 23 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM6 Register bits
    namespace jpeg_dhtmem6_bits {
        constexpr uint32_t DATA24 = (8 << 0);  ///< Huffman table data 24 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA25 = (8 << 8);  ///< Huffman table data 25 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA26 = (8 << 16);  ///< Huffman table data 26 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA27 = (8 << 24);  ///< Huffman table data 27 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM7 Register bits
    namespace jpeg_dhtmem7_bits {
        constexpr uint32_t DATA28 = (8 << 0);  ///< Huffman table data 28 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA29 = (8 << 8);  ///< Huffman table data 29 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA30 = (8 << 16);  ///< Huffman table data 30 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA31 = (8 << 24);  ///< Huffman table data 31 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM8 Register bits
    namespace jpeg_dhtmem8_bits {
        constexpr uint32_t DATA32 = (8 << 0);  ///< Huffman table data 32 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA33 = (8 << 8);  ///< Huffman table data 33 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA34 = (8 << 16);  ///< Huffman table data 34 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA35 = (8 << 24);  ///< Huffman table data 35 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM9 Register bits
    namespace jpeg_dhtmem9_bits {
        constexpr uint32_t DATA36 = (8 << 0);  ///< Huffman table data 36 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA37 = (8 << 8);  ///< Huffman table data 37 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA38 = (8 << 16);  ///< Huffman table data 38 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA39 = (8 << 24);  ///< Huffman table data 39 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM10 Register bits
    namespace jpeg_dhtmem10_bits {
        constexpr uint32_t DATA40 = (8 << 0);  ///< Huffman table data 40 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA41 = (8 << 8);  ///< Huffman table data 41 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA42 = (8 << 16);  ///< Huffman table data 42 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA43 = (8 << 24);  ///< Huffman table data 43 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM11 Register bits
    namespace jpeg_dhtmem11_bits {
        constexpr uint32_t DATA44 = (8 << 0);  ///< Huffman table data 44 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA45 = (8 << 8);  ///< Huffman table data 45 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA46 = (8 << 16);  ///< Huffman table data 46 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA47 = (8 << 24);  ///< Huffman table data 47 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM12 Register bits
    namespace jpeg_dhtmem12_bits {
        constexpr uint32_t DATA48 = (8 << 0);  ///< Huffman table data 48 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA49 = (8 << 8);  ///< Huffman table data 49 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA50 = (8 << 16);  ///< Huffman table data 50 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA51 = (8 << 24);  ///< Huffman table data 51 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM13 Register bits
    namespace jpeg_dhtmem13_bits {
        constexpr uint32_t DATA52 = (8 << 0);  ///< Huffman table data 52 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA53 = (8 << 8);  ///< Huffman table data 53 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA54 = (8 << 16);  ///< Huffman table data 54 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA55 = (8 << 24);  ///< Huffman table data 55 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM14 Register bits
    namespace jpeg_dhtmem14_bits {
        constexpr uint32_t DATA56 = (8 << 0);  ///< Huffman table data 56 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA57 = (8 << 8);  ///< Huffman table data 57 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA58 = (8 << 16);  ///< Huffman table data 58 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA59 = (8 << 24);  ///< Huffman table data 59 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM15 Register bits
    namespace jpeg_dhtmem15_bits {
        constexpr uint32_t DATA60 = (8 << 0);  ///< Huffman table data 60 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA61 = (8 << 8);  ///< Huffman table data 61 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA62 = (8 << 16);  ///< Huffman table data 62 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA63 = (8 << 24);  ///< Huffman table data 63 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM16 Register bits
    namespace jpeg_dhtmem16_bits {
        constexpr uint32_t DATA64 = (8 << 0);  ///< Huffman table data 64 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA65 = (8 << 8);  ///< Huffman table data 65 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA66 = (8 << 16);  ///< Huffman table data 66 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA67 = (8 << 24);  ///< Huffman table data 67 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM17 Register bits
    namespace jpeg_dhtmem17_bits {
        constexpr uint32_t DATA68 = (8 << 0);  ///< Huffman table data 68 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA69 = (8 << 8);  ///< Huffman table data 69 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA70 = (8 << 16);  ///< Huffman table data 70 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA71 = (8 << 24);  ///< Huffman table data 71 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM18 Register bits
    namespace jpeg_dhtmem18_bits {
        constexpr uint32_t DATA72 = (8 << 0);  ///< Huffman table data 72 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA73 = (8 << 8);  ///< Huffman table data 73 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA74 = (8 << 16);  ///< Huffman table data 74 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA75 = (8 << 24);  ///< Huffman table data 75 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM19 Register bits
    namespace jpeg_dhtmem19_bits {
        constexpr uint32_t DATA76 = (8 << 0);  ///< Huffman table data 76 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA77 = (8 << 8);  ///< Huffman table data 77 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA78 = (8 << 16);  ///< Huffman table data 78 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA79 = (8 << 24);  ///< Huffman table data 79 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM20 Register bits
    namespace jpeg_dhtmem20_bits {
        constexpr uint32_t DATA80 = (8 << 0);  ///< Huffman table data 80 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA81 = (8 << 8);  ///< Huffman table data 81 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA82 = (8 << 16);  ///< Huffman table data 82 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA83 = (8 << 24);  ///< Huffman table data 83 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM21 Register bits
    namespace jpeg_dhtmem21_bits {
        constexpr uint32_t DATA84 = (8 << 0);  ///< Huffman table data 84 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA85 = (8 << 8);  ///< Huffman table data 85 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA86 = (8 << 16);  ///< Huffman table data 86 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA87 = (8 << 24);  ///< Huffman table data 87 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM22 Register bits
    namespace jpeg_dhtmem22_bits {
        constexpr uint32_t DATA88 = (8 << 0);  ///< Huffman table data 88 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA89 = (8 << 8);  ///< Huffman table data 89 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA90 = (8 << 16);  ///< Huffman table data 90 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA91 = (8 << 24);  ///< Huffman table data 91 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM23 Register bits
    namespace jpeg_dhtmem23_bits {
        constexpr uint32_t DATA92 = (8 << 0);  ///< Huffman table data 92 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA93 = (8 << 8);  ///< Huffman table data 93 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA94 = (8 << 16);  ///< Huffman table data 94 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA95 = (8 << 24);  ///< Huffman table data 95 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM24 Register bits
    namespace jpeg_dhtmem24_bits {
        constexpr uint32_t DATA96 = (8 << 0);  ///< Huffman table data 96 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA97 = (8 << 8);  ///< Huffman table data 97 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA98 = (8 << 16);  ///< Huffman table data 98 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA99 = (8 << 24);  ///< Huffman table data 99 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM25 Register bits
    namespace jpeg_dhtmem25_bits {
        constexpr uint32_t DATA100 = (8 << 0);  ///< Huffman table data 100 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA101 = (8 << 8);  ///< Huffman table data 101 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA102 = (8 << 16);  ///< Huffman table data 102 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA103 = (8 << 24);  ///< Huffman table data 103 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM26 Register bits
    namespace jpeg_dhtmem26_bits {
        constexpr uint32_t DATA104 = (8 << 0);  ///< Huffman table data 104 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA105 = (8 << 8);  ///< Huffman table data 105 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA106 = (8 << 16);  ///< Huffman table data 106 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA107 = (8 << 24);  ///< Huffman table data 107 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM27 Register bits
    namespace jpeg_dhtmem27_bits {
        constexpr uint32_t DATA108 = (8 << 0);  ///< Huffman table data 108 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA109 = (8 << 8);  ///< Huffman table data 109 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA110 = (8 << 16);  ///< Huffman table data 110 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA111 = (8 << 24);  ///< Huffman table data 111 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM28 Register bits
    namespace jpeg_dhtmem28_bits {
        constexpr uint32_t DATA112 = (8 << 0);  ///< Huffman table data 112 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA113 = (8 << 8);  ///< Huffman table data 113 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA114 = (8 << 16);  ///< Huffman table data 114 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA115 = (8 << 24);  ///< Huffman table data 115 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM29 Register bits
    namespace jpeg_dhtmem29_bits {
        constexpr uint32_t DATA116 = (8 << 0);  ///< Huffman table data 116 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA117 = (8 << 8);  ///< Huffman table data 117 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA118 = (8 << 16);  ///< Huffman table data 118 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA119 = (8 << 24);  ///< Huffman table data 119 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM30 Register bits
    namespace jpeg_dhtmem30_bits {
        constexpr uint32_t DATA120 = (8 << 0);  ///< Huffman table data 120 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA121 = (8 << 8);  ///< Huffman table data 121 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA122 = (8 << 16);  ///< Huffman table data 122 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA123 = (8 << 24);  ///< Huffman table data 123 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM31 Register bits
    namespace jpeg_dhtmem31_bits {
        constexpr uint32_t DATA124 = (8 << 0);  ///< Huffman table data 124 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA125 = (8 << 8);  ///< Huffman table data 125 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA126 = (8 << 16);  ///< Huffman table data 126 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA127 = (8 << 24);  ///< Huffman table data 127 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM32 Register bits
    namespace jpeg_dhtmem32_bits {
        constexpr uint32_t DATA128 = (8 << 0);  ///< Huffman table data 128 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA129 = (8 << 8);  ///< Huffman table data 129 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA130 = (8 << 16);  ///< Huffman table data 130 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA131 = (8 << 24);  ///< Huffman table data 131 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM33 Register bits
    namespace jpeg_dhtmem33_bits {
        constexpr uint32_t DATA132 = (8 << 0);  ///< Huffman table data 132 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA133 = (8 << 8);  ///< Huffman table data 133 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA134 = (8 << 16);  ///< Huffman table data 134 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA135 = (8 << 24);  ///< Huffman table data 135 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM34 Register bits
    namespace jpeg_dhtmem34_bits {
        constexpr uint32_t DATA136 = (8 << 0);  ///< Huffman table data 136 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA137 = (8 << 8);  ///< Huffman table data 137 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA138 = (8 << 16);  ///< Huffman table data 138 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA139 = (8 << 24);  ///< Huffman table data 139 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM35 Register bits
    namespace jpeg_dhtmem35_bits {
        constexpr uint32_t DATA140 = (8 << 0);  ///< Huffman table data 140 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA141 = (8 << 8);  ///< Huffman table data 141 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA142 = (8 << 16);  ///< Huffman table data 142 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA143 = (8 << 24);  ///< Huffman table data 143 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM36 Register bits
    namespace jpeg_dhtmem36_bits {
        constexpr uint32_t DATA144 = (8 << 0);  ///< Huffman table data 144 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA145 = (8 << 8);  ///< Huffman table data 145 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA146 = (8 << 16);  ///< Huffman table data 146 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA147 = (8 << 24);  ///< Huffman table data 147 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM37 Register bits
    namespace jpeg_dhtmem37_bits {
        constexpr uint32_t DATA148 = (8 << 0);  ///< Huffman table data 148 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA149 = (8 << 8);  ///< Huffman table data 149 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA150 = (8 << 16);  ///< Huffman table data 150 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA151 = (8 << 24);  ///< Huffman table data 151 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM38 Register bits
    namespace jpeg_dhtmem38_bits {
        constexpr uint32_t DATA152 = (8 << 0);  ///< Huffman table data 152 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA153 = (8 << 8);  ///< Huffman table data 153 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA154 = (8 << 16);  ///< Huffman table data 154 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA155 = (8 << 24);  ///< Huffman table data 155 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM39 Register bits
    namespace jpeg_dhtmem39_bits {
        constexpr uint32_t DATA156 = (8 << 0);  ///< Huffman table data 156 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA157 = (8 << 8);  ///< Huffman table data 157 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA158 = (8 << 16);  ///< Huffman table data 158 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA159 = (8 << 24);  ///< Huffman table data 159 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM40 Register bits
    namespace jpeg_dhtmem40_bits {
        constexpr uint32_t DATA160 = (8 << 0);  ///< Huffman table data 160 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA161 = (8 << 8);  ///< Huffman table data 161 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA162 = (8 << 16);  ///< Huffman table data 162 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA163 = (8 << 24);  ///< Huffman table data 163 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM41 Register bits
    namespace jpeg_dhtmem41_bits {
        constexpr uint32_t DATA164 = (8 << 0);  ///< Huffman table data 164 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA165 = (8 << 8);  ///< Huffman table data 165 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA166 = (8 << 16);  ///< Huffman table data 166 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA167 = (8 << 24);  ///< Huffman table data 167 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM42 Register bits
    namespace jpeg_dhtmem42_bits {
        constexpr uint32_t DATA168 = (8 << 0);  ///< Huffman table data 168 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA169 = (8 << 8);  ///< Huffman table data 169 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA170 = (8 << 16);  ///< Huffman table data 170 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA171 = (8 << 24);  ///< Huffman table data 171 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM43 Register bits
    namespace jpeg_dhtmem43_bits {
        constexpr uint32_t DATA172 = (8 << 0);  ///< Huffman table data 172 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA173 = (8 << 8);  ///< Huffman table data 173 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA174 = (8 << 16);  ///< Huffman table data 174 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA175 = (8 << 24);  ///< Huffman table data 175 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM44 Register bits
    namespace jpeg_dhtmem44_bits {
        constexpr uint32_t DATA176 = (8 << 0);  ///< Huffman table data 176 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA177 = (8 << 8);  ///< Huffman table data 177 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA178 = (8 << 16);  ///< Huffman table data 178 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA179 = (8 << 24);  ///< Huffman table data 179 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM45 Register bits
    namespace jpeg_dhtmem45_bits {
        constexpr uint32_t DATA180 = (8 << 0);  ///< Huffman table data 180 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA181 = (8 << 8);  ///< Huffman table data 181 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA182 = (8 << 16);  ///< Huffman table data 182 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA183 = (8 << 24);  ///< Huffman table data 183 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM46 Register bits
    namespace jpeg_dhtmem46_bits {
        constexpr uint32_t DATA184 = (8 << 0);  ///< Huffman table data 184 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA185 = (8 << 8);  ///< Huffman table data 185 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA186 = (8 << 16);  ///< Huffman table data 186 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA187 = (8 << 24);  ///< Huffman table data 187 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM47 Register bits
    namespace jpeg_dhtmem47_bits {
        constexpr uint32_t DATA188 = (8 << 0);  ///< Huffman table data 188 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA189 = (8 << 8);  ///< Huffman table data 189 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA190 = (8 << 16);  ///< Huffman table data 190 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA191 = (8 << 24);  ///< Huffman table data 191 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM48 Register bits
    namespace jpeg_dhtmem48_bits {
        constexpr uint32_t DATA192 = (8 << 0);  ///< Huffman table data 192 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA193 = (8 << 8);  ///< Huffman table data 193 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA194 = (8 << 16);  ///< Huffman table data 194 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA195 = (8 << 24);  ///< Huffman table data 195 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM49 Register bits
    namespace jpeg_dhtmem49_bits {
        constexpr uint32_t DATA196 = (8 << 0);  ///< Huffman table data 196 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA197 = (8 << 8);  ///< Huffman table data 197 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA198 = (8 << 16);  ///< Huffman table data 198 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA199 = (8 << 24);  ///< Huffman table data 199 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM50 Register bits
    namespace jpeg_dhtmem50_bits {
        constexpr uint32_t DATA200 = (8 << 0);  ///< Huffman table data 200 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA201 = (8 << 8);  ///< Huffman table data 201 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA202 = (8 << 16);  ///< Huffman table data 202 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA203 = (8 << 24);  ///< Huffman table data 203 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM51 Register bits
    namespace jpeg_dhtmem51_bits {
        constexpr uint32_t DATA204 = (8 << 0);  ///< Huffman table data 204 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA205 = (8 << 8);  ///< Huffman table data 205 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA206 = (8 << 16);  ///< Huffman table data 206 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA207 = (8 << 24);  ///< Huffman table data 207 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM52 Register bits
    namespace jpeg_dhtmem52_bits {
        constexpr uint32_t DATA208 = (8 << 0);  ///< Huffman table data 208 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA209 = (8 << 8);  ///< Huffman table data 209 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA210 = (8 << 16);  ///< Huffman table data 210 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA211 = (8 << 24);  ///< Huffman table data 211 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM53 Register bits
    namespace jpeg_dhtmem53_bits {
        constexpr uint32_t DATA212 = (8 << 0);  ///< Huffman table data 212 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA213 = (8 << 8);  ///< Huffman table data 213 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA214 = (8 << 16);  ///< Huffman table data 214 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA215 = (8 << 24);  ///< Huffman table data 215 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM54 Register bits
    namespace jpeg_dhtmem54_bits {
        constexpr uint32_t DATA216 = (8 << 0);  ///< Huffman table data 216 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA217 = (8 << 8);  ///< Huffman table data 217 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA218 = (8 << 16);  ///< Huffman table data 218 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA219 = (8 << 24);  ///< Huffman table data 219 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM55 Register bits
    namespace jpeg_dhtmem55_bits {
        constexpr uint32_t DATA220 = (8 << 0);  ///< Huffman table data 220 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA221 = (8 << 8);  ///< Huffman table data 221 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA222 = (8 << 16);  ///< Huffman table data 222 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA223 = (8 << 24);  ///< Huffman table data 223 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM56 Register bits
    namespace jpeg_dhtmem56_bits {
        constexpr uint32_t DATA224 = (8 << 0);  ///< Huffman table data 224 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA225 = (8 << 8);  ///< Huffman table data 225 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA226 = (8 << 16);  ///< Huffman table data 226 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA227 = (8 << 24);  ///< Huffman table data 227 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM57 Register bits
    namespace jpeg_dhtmem57_bits {
        constexpr uint32_t DATA228 = (8 << 0);  ///< Huffman table data 228 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA229 = (8 << 8);  ///< Huffman table data 229 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA230 = (8 << 16);  ///< Huffman table data 230 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA231 = (8 << 24);  ///< Huffman table data 231 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM58 Register bits
    namespace jpeg_dhtmem58_bits {
        constexpr uint32_t DATA232 = (8 << 0);  ///< Huffman table data 232 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA233 = (8 << 8);  ///< Huffman table data 233 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA234 = (8 << 16);  ///< Huffman table data 234 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA235 = (8 << 24);  ///< Huffman table data 235 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM59 Register bits
    namespace jpeg_dhtmem59_bits {
        constexpr uint32_t DATA236 = (8 << 0);  ///< Huffman table data 236 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA237 = (8 << 8);  ///< Huffman table data 237 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA238 = (8 << 16);  ///< Huffman table data 238 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA239 = (8 << 24);  ///< Huffman table data 239 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM60 Register bits
    namespace jpeg_dhtmem60_bits {
        constexpr uint32_t DATA240 = (8 << 0);  ///< Huffman table data 240 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA241 = (8 << 8);  ///< Huffman table data 241 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA242 = (8 << 16);  ///< Huffman table data 242 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA243 = (8 << 24);  ///< Huffman table data 243 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM61 Register bits
    namespace jpeg_dhtmem61_bits {
        constexpr uint32_t DATA244 = (8 << 0);  ///< Huffman table data 244 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA245 = (8 << 8);  ///< Huffman table data 245 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA246 = (8 << 16);  ///< Huffman table data 246 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA247 = (8 << 24);  ///< Huffman table data 247 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM62 Register bits
    namespace jpeg_dhtmem62_bits {
        constexpr uint32_t DATA248 = (8 << 0);  ///< Huffman table data 248 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA249 = (8 << 8);  ///< Huffman table data 249 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA250 = (8 << 16);  ///< Huffman table data 250 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA251 = (8 << 24);  ///< Huffman table data 251 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM63 Register bits
    namespace jpeg_dhtmem63_bits {
        constexpr uint32_t DATA252 = (8 << 0);  ///< Huffman table data 252 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA253 = (8 << 8);  ///< Huffman table data 253 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA254 = (8 << 16);  ///< Huffman table data 254 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA255 = (8 << 24);  ///< Huffman table data 255 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM64 Register bits
    namespace jpeg_dhtmem64_bits {
        constexpr uint32_t DATA256 = (8 << 0);  ///< Huffman table data 256 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA257 = (8 << 8);  ///< Huffman table data 257 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA258 = (8 << 16);  ///< Huffman table data 258 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA259 = (8 << 24);  ///< Huffman table data 259 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM65 Register bits
    namespace jpeg_dhtmem65_bits {
        constexpr uint32_t DATA260 = (8 << 0);  ///< Huffman table data 260 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA261 = (8 << 8);  ///< Huffman table data 261 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA262 = (8 << 16);  ///< Huffman table data 262 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA263 = (8 << 24);  ///< Huffman table data 263 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM66 Register bits
    namespace jpeg_dhtmem66_bits {
        constexpr uint32_t DATA264 = (8 << 0);  ///< Huffman table data 264 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA265 = (8 << 8);  ///< Huffman table data 265 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA266 = (8 << 16);  ///< Huffman table data 266 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA267 = (8 << 24);  ///< Huffman table data 267 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM67 Register bits
    namespace jpeg_dhtmem67_bits {
        constexpr uint32_t DATA268 = (8 << 0);  ///< Huffman table data 268 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA269 = (8 << 8);  ///< Huffman table data 269 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA270 = (8 << 16);  ///< Huffman table data 270 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA271 = (8 << 24);  ///< Huffman table data 271 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM68 Register bits
    namespace jpeg_dhtmem68_bits {
        constexpr uint32_t DATA272 = (8 << 0);  ///< Huffman table data 272 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA273 = (8 << 8);  ///< Huffman table data 273 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA274 = (8 << 16);  ///< Huffman table data 274 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA275 = (8 << 24);  ///< Huffman table data 275 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM69 Register bits
    namespace jpeg_dhtmem69_bits {
        constexpr uint32_t DATA276 = (8 << 0);  ///< Huffman table data 276 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA277 = (8 << 8);  ///< Huffman table data 277 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA278 = (8 << 16);  ///< Huffman table data 278 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA279 = (8 << 24);  ///< Huffman table data 279 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM70 Register bits
    namespace jpeg_dhtmem70_bits {
        constexpr uint32_t DATA280 = (8 << 0);  ///< Huffman table data 280 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA281 = (8 << 8);  ///< Huffman table data 281 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA282 = (8 << 16);  ///< Huffman table data 282 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA283 = (8 << 24);  ///< Huffman table data 283 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM71 Register bits
    namespace jpeg_dhtmem71_bits {
        constexpr uint32_t DATA284 = (8 << 0);  ///< Huffman table data 284 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA285 = (8 << 8);  ///< Huffman table data 285 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA286 = (8 << 16);  ///< Huffman table data 286 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA287 = (8 << 24);  ///< Huffman table data 287 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM72 Register bits
    namespace jpeg_dhtmem72_bits {
        constexpr uint32_t DATA288 = (8 << 0);  ///< Huffman table data 288 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA289 = (8 << 8);  ///< Huffman table data 289 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA290 = (8 << 16);  ///< Huffman table data 290 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA291 = (8 << 24);  ///< Huffman table data 291 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM73 Register bits
    namespace jpeg_dhtmem73_bits {
        constexpr uint32_t DATA292 = (8 << 0);  ///< Huffman table data 292 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA293 = (8 << 8);  ///< Huffman table data 293 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA294 = (8 << 16);  ///< Huffman table data 294 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA295 = (8 << 24);  ///< Huffman table data 295 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM74 Register bits
    namespace jpeg_dhtmem74_bits {
        constexpr uint32_t DATA296 = (8 << 0);  ///< Huffman table data 296 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA297 = (8 << 8);  ///< Huffman table data 297 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA298 = (8 << 16);  ///< Huffman table data 298 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA299 = (8 << 24);  ///< Huffman table data 299 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM75 Register bits
    namespace jpeg_dhtmem75_bits {
        constexpr uint32_t DATA300 = (8 << 0);  ///< Huffman table data 300 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA301 = (8 << 8);  ///< Huffman table data 301 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA302 = (8 << 16);  ///< Huffman table data 302 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA303 = (8 << 24);  ///< Huffman table data 303 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM76 Register bits
    namespace jpeg_dhtmem76_bits {
        constexpr uint32_t DATA304 = (8 << 0);  ///< Huffman table data 304 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA305 = (8 << 8);  ///< Huffman table data 305 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA306 = (8 << 16);  ///< Huffman table data 306 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA307 = (8 << 24);  ///< Huffman table data 307 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM77 Register bits
    namespace jpeg_dhtmem77_bits {
        constexpr uint32_t DATA308 = (8 << 0);  ///< Huffman table data 308 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA309 = (8 << 8);  ///< Huffman table data 309 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA310 = (8 << 16);  ///< Huffman table data 310 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA311 = (8 << 24);  ///< Huffman table data 311 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM78 Register bits
    namespace jpeg_dhtmem78_bits {
        constexpr uint32_t DATA312 = (8 << 0);  ///< Huffman table data 312 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA313 = (8 << 8);  ///< Huffman table data 313 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA314 = (8 << 16);  ///< Huffman table data 314 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA315 = (8 << 24);  ///< Huffman table data 315 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM79 Register bits
    namespace jpeg_dhtmem79_bits {
        constexpr uint32_t DATA316 = (8 << 0);  ///< Huffman table data 316 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA317 = (8 << 8);  ///< Huffman table data 317 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA318 = (8 << 16);  ///< Huffman table data 318 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA319 = (8 << 24);  ///< Huffman table data 319 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM80 Register bits
    namespace jpeg_dhtmem80_bits {
        constexpr uint32_t DATA320 = (8 << 0);  ///< Huffman table data 320 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA321 = (8 << 8);  ///< Huffman table data 321 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA322 = (8 << 16);  ///< Huffman table data 322 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA323 = (8 << 24);  ///< Huffman table data 323 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM81 Register bits
    namespace jpeg_dhtmem81_bits {
        constexpr uint32_t DATA324 = (8 << 0);  ///< Huffman table data 324 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA325 = (8 << 8);  ///< Huffman table data 325 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA326 = (8 << 16);  ///< Huffman table data 326 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA327 = (8 << 24);  ///< Huffman table data 327 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM82 Register bits
    namespace jpeg_dhtmem82_bits {
        constexpr uint32_t DATA328 = (8 << 0);  ///< Huffman table data 328 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA329 = (8 << 8);  ///< Huffman table data 329 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA330 = (8 << 16);  ///< Huffman table data 330 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA331 = (8 << 24);  ///< Huffman table data 331 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM83 Register bits
    namespace jpeg_dhtmem83_bits {
        constexpr uint32_t DATA332 = (8 << 0);  ///< Huffman table data 332 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA333 = (8 << 8);  ///< Huffman table data 333 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA334 = (8 << 16);  ///< Huffman table data 334 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA335 = (8 << 24);  ///< Huffman table data 335 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM84 Register bits
    namespace jpeg_dhtmem84_bits {
        constexpr uint32_t DATA336 = (8 << 0);  ///< Huffman table data 336 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA337 = (8 << 8);  ///< Huffman table data 337 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA338 = (8 << 16);  ///< Huffman table data 338 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA339 = (8 << 24);  ///< Huffman table data 339 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM85 Register bits
    namespace jpeg_dhtmem85_bits {
        constexpr uint32_t DATA340 = (8 << 0);  ///< Huffman table data 340 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA341 = (8 << 8);  ///< Huffman table data 341 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA342 = (8 << 16);  ///< Huffman table data 342 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA343 = (8 << 24);  ///< Huffman table data 343 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM86 Register bits
    namespace jpeg_dhtmem86_bits {
        constexpr uint32_t DATA344 = (8 << 0);  ///< Huffman table data 344 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA345 = (8 << 8);  ///< Huffman table data 345 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA346 = (8 << 16);  ///< Huffman table data 346 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA347 = (8 << 24);  ///< Huffman table data 347 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM87 Register bits
    namespace jpeg_dhtmem87_bits {
        constexpr uint32_t DATA348 = (8 << 0);  ///< Huffman table data 348 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA349 = (8 << 8);  ///< Huffman table data 349 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA350 = (8 << 16);  ///< Huffman table data 350 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA351 = (8 << 24);  ///< Huffman table data 351 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM88 Register bits
    namespace jpeg_dhtmem88_bits {
        constexpr uint32_t DATA352 = (8 << 0);  ///< Huffman table data 352 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA353 = (8 << 8);  ///< Huffman table data 353 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA354 = (8 << 16);  ///< Huffman table data 354 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA355 = (8 << 24);  ///< Huffman table data 355 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM89 Register bits
    namespace jpeg_dhtmem89_bits {
        constexpr uint32_t DATA356 = (8 << 0);  ///< Huffman table data 356 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA357 = (8 << 8);  ///< Huffman table data 357 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA358 = (8 << 16);  ///< Huffman table data 358 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA359 = (8 << 24);  ///< Huffman table data 359 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM90 Register bits
    namespace jpeg_dhtmem90_bits {
        constexpr uint32_t DATA360 = (8 << 0);  ///< Huffman table data 360 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA361 = (8 << 8);  ///< Huffman table data 361 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA362 = (8 << 16);  ///< Huffman table data 362 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA363 = (8 << 24);  ///< Huffman table data 363 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM91 Register bits
    namespace jpeg_dhtmem91_bits {
        constexpr uint32_t DATA364 = (8 << 0);  ///< Huffman table data 364 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA365 = (8 << 8);  ///< Huffman table data 365 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA366 = (8 << 16);  ///< Huffman table data 366 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA367 = (8 << 24);  ///< Huffman table data 367 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM92 Register bits
    namespace jpeg_dhtmem92_bits {
        constexpr uint32_t DATA368 = (8 << 0);  ///< Huffman table data 368 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA369 = (8 << 8);  ///< Huffman table data 369 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA370 = (8 << 16);  ///< Huffman table data 370 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA371 = (8 << 24);  ///< Huffman table data 371 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM93 Register bits
    namespace jpeg_dhtmem93_bits {
        constexpr uint32_t DATA372 = (8 << 0);  ///< Huffman table data 372 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA373 = (8 << 8);  ///< Huffman table data 373 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA374 = (8 << 16);  ///< Huffman table data 374 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA375 = (8 << 24);  ///< Huffman table data 375 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM94 Register bits
    namespace jpeg_dhtmem94_bits {
        constexpr uint32_t DATA376 = (8 << 0);  ///< Huffman table data 376 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA377 = (8 << 8);  ///< Huffman table data 377 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA378 = (8 << 16);  ///< Huffman table data 378 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA379 = (8 << 24);  ///< Huffman table data 379 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM95 Register bits
    namespace jpeg_dhtmem95_bits {
        constexpr uint32_t DATA380 = (8 << 0);  ///< Huffman table data 380 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA381 = (8 << 8);  ///< Huffman table data 381 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA382 = (8 << 16);  ///< Huffman table data 382 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA383 = (8 << 24);  ///< Huffman table data 383 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM96 Register bits
    namespace jpeg_dhtmem96_bits {
        constexpr uint32_t DATA384 = (8 << 0);  ///< Huffman table data 384 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA385 = (8 << 8);  ///< Huffman table data 385 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA386 = (8 << 16);  ///< Huffman table data 386 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA387 = (8 << 24);  ///< Huffman table data 387 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM97 Register bits
    namespace jpeg_dhtmem97_bits {
        constexpr uint32_t DATA388 = (8 << 0);  ///< Huffman table data 388 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA389 = (8 << 8);  ///< Huffman table data 389 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA390 = (8 << 16);  ///< Huffman table data 390 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA391 = (8 << 24);  ///< Huffman table data 391 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM98 Register bits
    namespace jpeg_dhtmem98_bits {
        constexpr uint32_t DATA392 = (8 << 0);  ///< Huffman table data 392 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA393 = (8 << 8);  ///< Huffman table data 393 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA394 = (8 << 16);  ///< Huffman table data 394 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA395 = (8 << 24);  ///< Huffman table data 395 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM99 Register bits
    namespace jpeg_dhtmem99_bits {
        constexpr uint32_t DATA396 = (8 << 0);  ///< Huffman table data 396 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA397 = (8 << 8);  ///< Huffman table data 397 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA398 = (8 << 16);  ///< Huffman table data 398 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA399 = (8 << 24);  ///< Huffman table data 399 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM100 Register bits
    namespace jpeg_dhtmem100_bits {
        constexpr uint32_t DATA400 = (8 << 0);  ///< Huffman table data 400 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA401 = (8 << 8);  ///< Huffman table data 401 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA402 = (8 << 16);  ///< Huffman table data 402 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA403 = (8 << 24);  ///< Huffman table data 403 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM101 Register bits
    namespace jpeg_dhtmem101_bits {
        constexpr uint32_t DATA404 = (8 << 0);  ///< Huffman table data 404 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA405 = (8 << 8);  ///< Huffman table data 405 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA406 = (8 << 16);  ///< Huffman table data 406 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA407 = (8 << 24);  ///< Huffman table data 407 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_DHTMEM102 Register bits
    namespace jpeg_dhtmem102_bits {
        constexpr uint32_t DATA408 = (8 << 0);  ///< Huffman table data 408 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA409 = (8 << 8);  ///< Huffman table data 409 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA410 = (8 << 16);  ///< Huffman table data 410 Huffman table data for DHT marker segment generation.
        constexpr uint32_t DATA411 = (8 << 24);  ///< Huffman table data 411 Huffman table data for DHT marker segment generation.
    }

    /// JPEG_HUFFENC_AC0_0 Register bits
    namespace jpeg_huffenc_ac0_0_bits {
        constexpr uint32_t HCODE0 = (8 << 0);  ///< Huffman code 0 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN0 = (4 << 8);  ///< Huffman length 0 Number of bits in the Huffman code HCODE0 minus 1.
        constexpr uint32_t HCODE1 = (8 << 16);  ///< Huffman code 1 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN1 = (4 << 24);  ///< Huffman length 1 Number of bits in the Huffman code HCODE1 minus 1.
    }

    /// JPEG_HUFFENC_AC0_1 Register bits
    namespace jpeg_huffenc_ac0_1_bits {
        constexpr uint32_t HCODE2 = (8 << 0);  ///< Huffman code 2 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN2 = (4 << 8);  ///< Huffman length 2 Number of bits in the Huffman code HCODE2 minus 1.
        constexpr uint32_t HCODE3 = (8 << 16);  ///< Huffman code 3 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN3 = (4 << 24);  ///< Huffman length 3 Number of bits in the Huffman code HCODE3 minus 1.
    }

    /// JPEG_HUFFENC_AC0_2 Register bits
    namespace jpeg_huffenc_ac0_2_bits {
        constexpr uint32_t HCODE4 = (8 << 0);  ///< Huffman code 4 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN4 = (4 << 8);  ///< Huffman length 4 Number of bits in the Huffman code HCODE4 minus 1.
        constexpr uint32_t HCODE5 = (8 << 16);  ///< Huffman code 5 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN5 = (4 << 24);  ///< Huffman length 5 Number of bits in the Huffman code HCODE5 minus 1.
    }

    /// JPEG_HUFFENC_AC0_3 Register bits
    namespace jpeg_huffenc_ac0_3_bits {
        constexpr uint32_t HCODE6 = (8 << 0);  ///< Huffman code 6 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN6 = (4 << 8);  ///< Huffman length 6 Number of bits in the Huffman code HCODE6 minus 1.
        constexpr uint32_t HCODE7 = (8 << 16);  ///< Huffman code 7 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN7 = (4 << 24);  ///< Huffman length 7 Number of bits in the Huffman code HCODE7 minus 1.
    }

    /// JPEG_HUFFENC_AC0_4 Register bits
    namespace jpeg_huffenc_ac0_4_bits {
        constexpr uint32_t HCODE8 = (8 << 0);  ///< Huffman code 8 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN8 = (4 << 8);  ///< Huffman length 8 Number of bits in the Huffman code HCODE8 minus 1.
        constexpr uint32_t HCODE9 = (8 << 16);  ///< Huffman code 9 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN9 = (4 << 24);  ///< Huffman length 9 Number of bits in the Huffman code HCODE9 minus 1.
    }

    /// JPEG_HUFFENC_AC0_5 Register bits
    namespace jpeg_huffenc_ac0_5_bits {
        constexpr uint32_t HCODE10 = (8 << 0);  ///< Huffman code 10 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN10 = (4 << 8);  ///< Huffman length 10 Number of bits in the Huffman code HCODE10 minus 1.
        constexpr uint32_t HCODE11 = (8 << 16);  ///< Huffman code 11 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN11 = (4 << 24);  ///< Huffman length 11 Number of bits in the Huffman code HCODE11 minus 1.
    }

    /// JPEG_HUFFENC_AC0_6 Register bits
    namespace jpeg_huffenc_ac0_6_bits {
        constexpr uint32_t HCODE12 = (8 << 0);  ///< Huffman code 12 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN12 = (4 << 8);  ///< Huffman length 12 Number of bits in the Huffman code HCODE12 minus 1.
        constexpr uint32_t HCODE13 = (8 << 16);  ///< Huffman code 13 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN13 = (4 << 24);  ///< Huffman length 13 Number of bits in the Huffman code HCODE13 minus 1.
    }

    /// JPEG_HUFFENC_AC0_7 Register bits
    namespace jpeg_huffenc_ac0_7_bits {
        constexpr uint32_t HCODE14 = (8 << 0);  ///< Huffman code 14 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN14 = (4 << 8);  ///< Huffman length 14 Number of bits in the Huffman code HCODE14 minus 1.
        constexpr uint32_t HCODE15 = (8 << 16);  ///< Huffman code 15 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN15 = (4 << 24);  ///< Huffman length 15 Number of bits in the Huffman code HCODE15 minus 1.
    }

    /// JPEG_HUFFENC_AC0_8 Register bits
    namespace jpeg_huffenc_ac0_8_bits {
        constexpr uint32_t HCODE16 = (8 << 0);  ///< Huffman code 16 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN16 = (4 << 8);  ///< Huffman length 16 Number of bits in the Huffman code HCODE16 minus 1.
        constexpr uint32_t HCODE17 = (8 << 16);  ///< Huffman code 17 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN17 = (4 << 24);  ///< Huffman length 17 Number of bits in the Huffman code HCODE17 minus 1.
    }

    /// JPEG_HUFFENC_AC0_9 Register bits
    namespace jpeg_huffenc_ac0_9_bits {
        constexpr uint32_t HCODE18 = (8 << 0);  ///< Huffman code 18 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN18 = (4 << 8);  ///< Huffman length 18 Number of bits in the Huffman code HCODE18 minus 1.
        constexpr uint32_t HCODE19 = (8 << 16);  ///< Huffman code 19 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN19 = (4 << 24);  ///< Huffman length 19 Number of bits in the Huffman code HCODE19 minus 1.
    }

    /// JPEG_HUFFENC_AC0_10 Register bits
    namespace jpeg_huffenc_ac0_10_bits {
        constexpr uint32_t HCODE20 = (8 << 0);  ///< Huffman code 20 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN20 = (4 << 8);  ///< Huffman length 20 Number of bits in the Huffman code HCODE20 minus 1.
        constexpr uint32_t HCODE21 = (8 << 16);  ///< Huffman code 21 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN21 = (4 << 24);  ///< Huffman length 21 Number of bits in the Huffman code HCODE21 minus 1.
    }

    /// JPEG_HUFFENC_AC0_11 Register bits
    namespace jpeg_huffenc_ac0_11_bits {
        constexpr uint32_t HCODE22 = (8 << 0);  ///< Huffman code 22 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN22 = (4 << 8);  ///< Huffman length 22 Number of bits in the Huffman code HCODE22 minus 1.
        constexpr uint32_t HCODE23 = (8 << 16);  ///< Huffman code 23 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN23 = (4 << 24);  ///< Huffman length 23 Number of bits in the Huffman code HCODE23 minus 1.
    }

    /// JPEG_HUFFENC_AC0_12 Register bits
    namespace jpeg_huffenc_ac0_12_bits {
        constexpr uint32_t HCODE24 = (8 << 0);  ///< Huffman code 24 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN24 = (4 << 8);  ///< Huffman length 24 Number of bits in the Huffman code HCODE24 minus 1.
        constexpr uint32_t HCODE25 = (8 << 16);  ///< Huffman code 25 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN25 = (4 << 24);  ///< Huffman length 25 Number of bits in the Huffman code HCODE25 minus 1.
    }

    /// JPEG_HUFFENC_AC0_13 Register bits
    namespace jpeg_huffenc_ac0_13_bits {
        constexpr uint32_t HCODE26 = (8 << 0);  ///< Huffman code 26 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN26 = (4 << 8);  ///< Huffman length 26 Number of bits in the Huffman code HCODE26 minus 1.
        constexpr uint32_t HCODE27 = (8 << 16);  ///< Huffman code 27 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN27 = (4 << 24);  ///< Huffman length 27 Number of bits in the Huffman code HCODE27 minus 1.
    }

    /// JPEG_HUFFENC_AC0_14 Register bits
    namespace jpeg_huffenc_ac0_14_bits {
        constexpr uint32_t HCODE28 = (8 << 0);  ///< Huffman code 28 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN28 = (4 << 8);  ///< Huffman length 28 Number of bits in the Huffman code HCODE28 minus 1.
        constexpr uint32_t HCODE29 = (8 << 16);  ///< Huffman code 29 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN29 = (4 << 24);  ///< Huffman length 29 Number of bits in the Huffman code HCODE29 minus 1.
    }

    /// JPEG_HUFFENC_AC0_15 Register bits
    namespace jpeg_huffenc_ac0_15_bits {
        constexpr uint32_t HCODE30 = (8 << 0);  ///< Huffman code 30 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN30 = (4 << 8);  ///< Huffman length 30 Number of bits in the Huffman code HCODE30 minus 1.
        constexpr uint32_t HCODE31 = (8 << 16);  ///< Huffman code 31 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN31 = (4 << 24);  ///< Huffman length 31 Number of bits in the Huffman code HCODE31 minus 1.
    }

    /// JPEG_HUFFENC_AC0_16 Register bits
    namespace jpeg_huffenc_ac0_16_bits {
        constexpr uint32_t HCODE32 = (8 << 0);  ///< Huffman code 32 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN32 = (4 << 8);  ///< Huffman length 32 Number of bits in the Huffman code HCODE32 minus 1.
        constexpr uint32_t HCODE33 = (8 << 16);  ///< Huffman code 33 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN33 = (4 << 24);  ///< Huffman length 33 Number of bits in the Huffman code HCODE33 minus 1.
    }

    /// JPEG_HUFFENC_AC0_17 Register bits
    namespace jpeg_huffenc_ac0_17_bits {
        constexpr uint32_t HCODE34 = (8 << 0);  ///< Huffman code 34 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN34 = (4 << 8);  ///< Huffman length 34 Number of bits in the Huffman code HCODE34 minus 1.
        constexpr uint32_t HCODE35 = (8 << 16);  ///< Huffman code 35 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN35 = (4 << 24);  ///< Huffman length 35 Number of bits in the Huffman code HCODE35 minus 1.
    }

    /// JPEG_HUFFENC_AC0_18 Register bits
    namespace jpeg_huffenc_ac0_18_bits {
        constexpr uint32_t HCODE36 = (8 << 0);  ///< Huffman code 36 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN36 = (4 << 8);  ///< Huffman length 36 Number of bits in the Huffman code HCODE36 minus 1.
        constexpr uint32_t HCODE37 = (8 << 16);  ///< Huffman code 37 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN37 = (4 << 24);  ///< Huffman length 37 Number of bits in the Huffman code HCODE37 minus 1.
    }

    /// JPEG_HUFFENC_AC0_19 Register bits
    namespace jpeg_huffenc_ac0_19_bits {
        constexpr uint32_t HCODE38 = (8 << 0);  ///< Huffman code 38 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN38 = (4 << 8);  ///< Huffman length 38 Number of bits in the Huffman code HCODE38 minus 1.
        constexpr uint32_t HCODE39 = (8 << 16);  ///< Huffman code 39 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN39 = (4 << 24);  ///< Huffman length 39 Number of bits in the Huffman code HCODE39 minus 1.
    }

    /// JPEG_HUFFENC_AC0_20 Register bits
    namespace jpeg_huffenc_ac0_20_bits {
        constexpr uint32_t HCODE40 = (8 << 0);  ///< Huffman code 40 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN40 = (4 << 8);  ///< Huffman length 40 Number of bits in the Huffman code HCODE40 minus 1.
        constexpr uint32_t HCODE41 = (8 << 16);  ///< Huffman code 41 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN41 = (4 << 24);  ///< Huffman length 41 Number of bits in the Huffman code HCODE41 minus 1.
    }

    /// JPEG_HUFFENC_AC0_21 Register bits
    namespace jpeg_huffenc_ac0_21_bits {
        constexpr uint32_t HCODE42 = (8 << 0);  ///< Huffman code 42 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN42 = (4 << 8);  ///< Huffman length 42 Number of bits in the Huffman code HCODE42 minus 1.
        constexpr uint32_t HCODE43 = (8 << 16);  ///< Huffman code 43 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN43 = (4 << 24);  ///< Huffman length 43 Number of bits in the Huffman code HCODE43 minus 1.
    }

    /// JPEG_HUFFENC_AC0_22 Register bits
    namespace jpeg_huffenc_ac0_22_bits {
        constexpr uint32_t HCODE44 = (8 << 0);  ///< Huffman code 44 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN44 = (4 << 8);  ///< Huffman length 44 Number of bits in the Huffman code HCODE44 minus 1.
        constexpr uint32_t HCODE45 = (8 << 16);  ///< Huffman code 45 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN45 = (4 << 24);  ///< Huffman length 45 Number of bits in the Huffman code HCODE45 minus 1.
    }

    /// JPEG_HUFFENC_AC0_23 Register bits
    namespace jpeg_huffenc_ac0_23_bits {
        constexpr uint32_t HCODE46 = (8 << 0);  ///< Huffman code 46 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN46 = (4 << 8);  ///< Huffman length 46 Number of bits in the Huffman code HCODE46 minus 1.
        constexpr uint32_t HCODE47 = (8 << 16);  ///< Huffman code 47 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN47 = (4 << 24);  ///< Huffman length 47 Number of bits in the Huffman code HCODE47 minus 1.
    }

    /// JPEG_HUFFENC_AC0_24 Register bits
    namespace jpeg_huffenc_ac0_24_bits {
        constexpr uint32_t HCODE48 = (8 << 0);  ///< Huffman code 48 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN48 = (4 << 8);  ///< Huffman length 48 Number of bits in the Huffman code HCODE48 minus 1.
        constexpr uint32_t HCODE49 = (8 << 16);  ///< Huffman code 49 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN49 = (4 << 24);  ///< Huffman length 49 Number of bits in the Huffman code HCODE49 minus 1.
    }

    /// JPEG_HUFFENC_AC0_25 Register bits
    namespace jpeg_huffenc_ac0_25_bits {
        constexpr uint32_t HCODE50 = (8 << 0);  ///< Huffman code 50 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN50 = (4 << 8);  ///< Huffman length 50 Number of bits in the Huffman code HCODE50 minus 1.
        constexpr uint32_t HCODE51 = (8 << 16);  ///< Huffman code 51 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN51 = (4 << 24);  ///< Huffman length 51 Number of bits in the Huffman code HCODE51 minus 1.
    }

    /// JPEG_HUFFENC_AC0_26 Register bits
    namespace jpeg_huffenc_ac0_26_bits {
        constexpr uint32_t HCODE52 = (8 << 0);  ///< Huffman code 52 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN52 = (4 << 8);  ///< Huffman length 52 Number of bits in the Huffman code HCODE52 minus 1.
        constexpr uint32_t HCODE53 = (8 << 16);  ///< Huffman code 53 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN53 = (4 << 24);  ///< Huffman length 53 Number of bits in the Huffman code HCODE53 minus 1.
    }

    /// JPEG_HUFFENC_AC0_27 Register bits
    namespace jpeg_huffenc_ac0_27_bits {
        constexpr uint32_t HCODE54 = (8 << 0);  ///< Huffman code 54 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN54 = (4 << 8);  ///< Huffman length 54 Number of bits in the Huffman code HCODE54 minus 1.
        constexpr uint32_t HCODE55 = (8 << 16);  ///< Huffman code 55 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN55 = (4 << 24);  ///< Huffman length 55 Number of bits in the Huffman code HCODE55 minus 1.
    }

    /// JPEG_HUFFENC_AC0_28 Register bits
    namespace jpeg_huffenc_ac0_28_bits {
        constexpr uint32_t HCODE56 = (8 << 0);  ///< Huffman code 56 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN56 = (4 << 8);  ///< Huffman length 56 Number of bits in the Huffman code HCODE56 minus 1.
        constexpr uint32_t HCODE57 = (8 << 16);  ///< Huffman code 57 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN57 = (4 << 24);  ///< Huffman length 57 Number of bits in the Huffman code HCODE57 minus 1.
    }

    /// JPEG_HUFFENC_AC0_29 Register bits
    namespace jpeg_huffenc_ac0_29_bits {
        constexpr uint32_t HCODE58 = (8 << 0);  ///< Huffman code 58 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN58 = (4 << 8);  ///< Huffman length 58 Number of bits in the Huffman code HCODE58 minus 1.
        constexpr uint32_t HCODE59 = (8 << 16);  ///< Huffman code 59 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN59 = (4 << 24);  ///< Huffman length 59 Number of bits in the Huffman code HCODE59 minus 1.
    }

    /// JPEG_HUFFENC_AC0_30 Register bits
    namespace jpeg_huffenc_ac0_30_bits {
        constexpr uint32_t HCODE60 = (8 << 0);  ///< Huffman code 60 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN60 = (4 << 8);  ///< Huffman length 60 Number of bits in the Huffman code HCODE60 minus 1.
        constexpr uint32_t HCODE61 = (8 << 16);  ///< Huffman code 61 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN61 = (4 << 24);  ///< Huffman length 61 Number of bits in the Huffman code HCODE61 minus 1.
    }

    /// JPEG_HUFFENC_AC0_31 Register bits
    namespace jpeg_huffenc_ac0_31_bits {
        constexpr uint32_t HCODE62 = (8 << 0);  ///< Huffman code 62 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN62 = (4 << 8);  ///< Huffman length 62 Number of bits in the Huffman code HCODE62 minus 1.
        constexpr uint32_t HCODE63 = (8 << 16);  ///< Huffman code 63 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN63 = (4 << 24);  ///< Huffman length 63 Number of bits in the Huffman code HCODE63 minus 1.
    }

    /// JPEG_HUFFENC_AC0_32 Register bits
    namespace jpeg_huffenc_ac0_32_bits {
        constexpr uint32_t HCODE64 = (8 << 0);  ///< Huffman code 64 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN64 = (4 << 8);  ///< Huffman length 64 Number of bits in the Huffman code HCODE64 minus 1.
        constexpr uint32_t HCODE65 = (8 << 16);  ///< Huffman code 65 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN65 = (4 << 24);  ///< Huffman length 65 Number of bits in the Huffman code HCODE65 minus 1.
    }

    /// JPEG_HUFFENC_AC0_33 Register bits
    namespace jpeg_huffenc_ac0_33_bits {
        constexpr uint32_t HCODE66 = (8 << 0);  ///< Huffman code 66 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN66 = (4 << 8);  ///< Huffman length 66 Number of bits in the Huffman code HCODE66 minus 1.
        constexpr uint32_t HCODE67 = (8 << 16);  ///< Huffman code 67 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN67 = (4 << 24);  ///< Huffman length 67 Number of bits in the Huffman code HCODE67 minus 1.
    }

    /// JPEG_HUFFENC_AC0_34 Register bits
    namespace jpeg_huffenc_ac0_34_bits {
        constexpr uint32_t HCODE68 = (8 << 0);  ///< Huffman code 68 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN68 = (4 << 8);  ///< Huffman length 68 Number of bits in the Huffman code HCODE68 minus 1.
        constexpr uint32_t HCODE69 = (8 << 16);  ///< Huffman code 69 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN69 = (4 << 24);  ///< Huffman length 69 Number of bits in the Huffman code HCODE69 minus 1.
    }

    /// JPEG_HUFFENC_AC0_35 Register bits
    namespace jpeg_huffenc_ac0_35_bits {
        constexpr uint32_t HCODE70 = (8 << 0);  ///< Huffman code 70 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN70 = (4 << 8);  ///< Huffman length 70 Number of bits in the Huffman code HCODE70 minus 1.
        constexpr uint32_t HCODE71 = (8 << 16);  ///< Huffman code 71 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN71 = (4 << 24);  ///< Huffman length 71 Number of bits in the Huffman code HCODE71 minus 1.
    }

    /// JPEG_HUFFENC_AC0_36 Register bits
    namespace jpeg_huffenc_ac0_36_bits {
        constexpr uint32_t HCODE72 = (8 << 0);  ///< Huffman code 72 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN72 = (4 << 8);  ///< Huffman length 72 Number of bits in the Huffman code HCODE72 minus 1.
        constexpr uint32_t HCODE73 = (8 << 16);  ///< Huffman code 73 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN73 = (4 << 24);  ///< Huffman length 73 Number of bits in the Huffman code HCODE73 minus 1.
    }

    /// JPEG_HUFFENC_AC0_37 Register bits
    namespace jpeg_huffenc_ac0_37_bits {
        constexpr uint32_t HCODE74 = (8 << 0);  ///< Huffman code 74 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN74 = (4 << 8);  ///< Huffman length 74 Number of bits in the Huffman code HCODE74 minus 1.
        constexpr uint32_t HCODE75 = (8 << 16);  ///< Huffman code 75 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN75 = (4 << 24);  ///< Huffman length 75 Number of bits in the Huffman code HCODE75 minus 1.
    }

    /// JPEG_HUFFENC_AC0_38 Register bits
    namespace jpeg_huffenc_ac0_38_bits {
        constexpr uint32_t HCODE76 = (8 << 0);  ///< Huffman code 76 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN76 = (4 << 8);  ///< Huffman length 76 Number of bits in the Huffman code HCODE76 minus 1.
        constexpr uint32_t HCODE77 = (8 << 16);  ///< Huffman code 77 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN77 = (4 << 24);  ///< Huffman length 77 Number of bits in the Huffman code HCODE77 minus 1.
    }

    /// JPEG_HUFFENC_AC0_39 Register bits
    namespace jpeg_huffenc_ac0_39_bits {
        constexpr uint32_t HCODE78 = (8 << 0);  ///< Huffman code 78 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN78 = (4 << 8);  ///< Huffman length 78 Number of bits in the Huffman code HCODE78 minus 1.
        constexpr uint32_t HCODE79 = (8 << 16);  ///< Huffman code 79 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN79 = (4 << 24);  ///< Huffman length 79 Number of bits in the Huffman code HCODE79 minus 1.
    }

    /// JPEG_HUFFENC_AC0_40 Register bits
    namespace jpeg_huffenc_ac0_40_bits {
        constexpr uint32_t HCODE80 = (8 << 0);  ///< Huffman code 80 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN80 = (4 << 8);  ///< Huffman length 80 Number of bits in the Huffman code HCODE80 minus 1.
        constexpr uint32_t HCODE81 = (8 << 16);  ///< Huffman code 81 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN81 = (4 << 24);  ///< Huffman length 81 Number of bits in the Huffman code HCODE81 minus 1.
    }

    /// JPEG_HUFFENC_AC0_41 Register bits
    namespace jpeg_huffenc_ac0_41_bits {
        constexpr uint32_t HCODE82 = (8 << 0);  ///< Huffman code 82 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN82 = (4 << 8);  ///< Huffman length 82 Number of bits in the Huffman code HCODE82 minus 1.
        constexpr uint32_t HCODE83 = (8 << 16);  ///< Huffman code 83 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN83 = (4 << 24);  ///< Huffman length 83 Number of bits in the Huffman code HCODE83 minus 1.
    }

    /// JPEG_HUFFENC_AC0_42 Register bits
    namespace jpeg_huffenc_ac0_42_bits {
        constexpr uint32_t HCODE84 = (8 << 0);  ///< Huffman code 84 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN84 = (4 << 8);  ///< Huffman length 84 Number of bits in the Huffman code HCODE84 minus 1.
        constexpr uint32_t HCODE85 = (8 << 16);  ///< Huffman code 85 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN85 = (4 << 24);  ///< Huffman length 85 Number of bits in the Huffman code HCODE85 minus 1.
    }

    /// JPEG_HUFFENC_AC0_43 Register bits
    namespace jpeg_huffenc_ac0_43_bits {
        constexpr uint32_t HCODE86 = (8 << 0);  ///< Huffman code 86 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN86 = (4 << 8);  ///< Huffman length 86 Number of bits in the Huffman code HCODE86 minus 1.
        constexpr uint32_t HCODE87 = (8 << 16);  ///< Huffman code 87 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN87 = (4 << 24);  ///< Huffman length 87 Number of bits in the Huffman code HCODE87 minus 1.
    }

    /// JPEG_HUFFENC_AC0_44 Register bits
    namespace jpeg_huffenc_ac0_44_bits {
        constexpr uint32_t HCODE88 = (8 << 0);  ///< Huffman code 88 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN88 = (4 << 8);  ///< Huffman length 88 Number of bits in the Huffman code HCODE88 minus 1.
        constexpr uint32_t HCODE89 = (8 << 16);  ///< Huffman code 89 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN89 = (4 << 24);  ///< Huffman length 89 Number of bits in the Huffman code HCODE89 minus 1.
    }

    /// JPEG_HUFFENC_AC0_45 Register bits
    namespace jpeg_huffenc_ac0_45_bits {
        constexpr uint32_t HCODE90 = (8 << 0);  ///< Huffman code 90 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN90 = (4 << 8);  ///< Huffman length 90 Number of bits in the Huffman code HCODE90 minus 1.
        constexpr uint32_t HCODE91 = (8 << 16);  ///< Huffman code 91 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN91 = (4 << 24);  ///< Huffman length 91 Number of bits in the Huffman code HCODE91 minus 1.
    }

    /// JPEG_HUFFENC_AC0_46 Register bits
    namespace jpeg_huffenc_ac0_46_bits {
        constexpr uint32_t HCODE92 = (8 << 0);  ///< Huffman code 92 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN92 = (4 << 8);  ///< Huffman length 92 Number of bits in the Huffman code HCODE92 minus 1.
        constexpr uint32_t HCODE93 = (8 << 16);  ///< Huffman code 93 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN93 = (4 << 24);  ///< Huffman length 93 Number of bits in the Huffman code HCODE93 minus 1.
    }

    /// JPEG_HUFFENC_AC0_47 Register bits
    namespace jpeg_huffenc_ac0_47_bits {
        constexpr uint32_t HCODE94 = (8 << 0);  ///< Huffman code 94 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN94 = (4 << 8);  ///< Huffman length 94 Number of bits in the Huffman code HCODE94 minus 1.
        constexpr uint32_t HCODE95 = (8 << 16);  ///< Huffman code 95 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN95 = (4 << 24);  ///< Huffman length 95 Number of bits in the Huffman code HCODE95 minus 1.
    }

    /// JPEG_HUFFENC_AC0_48 Register bits
    namespace jpeg_huffenc_ac0_48_bits {
        constexpr uint32_t HCODE96 = (8 << 0);  ///< Huffman code 96 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN96 = (4 << 8);  ///< Huffman length 96 Number of bits in the Huffman code HCODE96 minus 1.
        constexpr uint32_t HCODE97 = (8 << 16);  ///< Huffman code 97 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN97 = (4 << 24);  ///< Huffman length 97 Number of bits in the Huffman code HCODE97 minus 1.
    }

    /// JPEG_HUFFENC_AC0_49 Register bits
    namespace jpeg_huffenc_ac0_49_bits {
        constexpr uint32_t HCODE98 = (8 << 0);  ///< Huffman code 98 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN98 = (4 << 8);  ///< Huffman length 98 Number of bits in the Huffman code HCODE98 minus 1.
        constexpr uint32_t HCODE99 = (8 << 16);  ///< Huffman code 99 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN99 = (4 << 24);  ///< Huffman length 99 Number of bits in the Huffman code HCODE99 minus 1.
    }

    /// JPEG_HUFFENC_AC0_50 Register bits
    namespace jpeg_huffenc_ac0_50_bits {
        constexpr uint32_t HCODE100 = (8 << 0);  ///< Huffman code 100 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN100 = (4 << 8);  ///< Huffman length 100 Number of bits in the Huffman code HCODE100 minus 1.
        constexpr uint32_t HCODE101 = (8 << 16);  ///< Huffman code 101 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN101 = (4 << 24);  ///< Huffman length 101 Number of bits in the Huffman code HCODE101 minus 1.
    }

    /// JPEG_HUFFENC_AC0_51 Register bits
    namespace jpeg_huffenc_ac0_51_bits {
        constexpr uint32_t HCODE102 = (8 << 0);  ///< Huffman code 102 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN102 = (4 << 8);  ///< Huffman length 102 Number of bits in the Huffman code HCODE102 minus 1.
        constexpr uint32_t HCODE103 = (8 << 16);  ///< Huffman code 103 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN103 = (4 << 24);  ///< Huffman length 103 Number of bits in the Huffman code HCODE103 minus 1.
    }

    /// JPEG_HUFFENC_AC0_52 Register bits
    namespace jpeg_huffenc_ac0_52_bits {
        constexpr uint32_t HCODE104 = (8 << 0);  ///< Huffman code 104 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN104 = (4 << 8);  ///< Huffman length 104 Number of bits in the Huffman code HCODE104 minus 1.
        constexpr uint32_t HCODE105 = (8 << 16);  ///< Huffman code 105 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN105 = (4 << 24);  ///< Huffman length 105 Number of bits in the Huffman code HCODE105 minus 1.
    }

    /// JPEG_HUFFENC_AC0_53 Register bits
    namespace jpeg_huffenc_ac0_53_bits {
        constexpr uint32_t HCODE106 = (8 << 0);  ///< Huffman code 106 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN106 = (4 << 8);  ///< Huffman length 106 Number of bits in the Huffman code HCODE106 minus 1.
        constexpr uint32_t HCODE107 = (8 << 16);  ///< Huffman code 107 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN107 = (4 << 24);  ///< Huffman length 107 Number of bits in the Huffman code HCODE107 minus 1.
    }

    /// JPEG_HUFFENC_AC0_54 Register bits
    namespace jpeg_huffenc_ac0_54_bits {
        constexpr uint32_t HCODE108 = (8 << 0);  ///< Huffman code 108 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN108 = (4 << 8);  ///< Huffman length 108 Number of bits in the Huffman code HCODE108 minus 1.
        constexpr uint32_t HCODE109 = (8 << 16);  ///< Huffman code 109 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN109 = (4 << 24);  ///< Huffman length 109 Number of bits in the Huffman code HCODE109 minus 1.
    }

    /// JPEG_HUFFENC_AC0_55 Register bits
    namespace jpeg_huffenc_ac0_55_bits {
        constexpr uint32_t HCODE110 = (8 << 0);  ///< Huffman code 110 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN110 = (4 << 8);  ///< Huffman length 110 Number of bits in the Huffman code HCODE110 minus 1.
        constexpr uint32_t HCODE111 = (8 << 16);  ///< Huffman code 111 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN111 = (4 << 24);  ///< Huffman length 111 Number of bits in the Huffman code HCODE111 minus 1.
    }

    /// JPEG_HUFFENC_AC1_0 Register bits
    namespace jpeg_huffenc_ac1_0_bits {
        constexpr uint32_t HCODE0 = (8 << 0);  ///< Huffman code 0 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN0 = (4 << 8);  ///< Huffman length 0 Number of bits in the Huffman code HCODE0 minus 1.
        constexpr uint32_t HCODE1 = (8 << 16);  ///< Huffman code 1 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN1 = (4 << 24);  ///< Huffman length 1 Number of bits in the Huffman code HCODE1 minus 1.
    }

    /// JPEG_HUFFENC_AC0_56 Register bits
    namespace jpeg_huffenc_ac0_56_bits {
        constexpr uint32_t HCODE112 = (8 << 0);  ///< Huffman code 112 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN112 = (4 << 8);  ///< Huffman length 112 Number of bits in the Huffman code HCODE112 minus 1.
        constexpr uint32_t HCODE113 = (8 << 16);  ///< Huffman code 113 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN113 = (4 << 24);  ///< Huffman length 113 Number of bits in the Huffman code HCODE113 minus 1.
    }

    /// JPEG_HUFFENC_AC1_1 Register bits
    namespace jpeg_huffenc_ac1_1_bits {
        constexpr uint32_t HCODE2 = (8 << 0);  ///< Huffman code 2 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN2 = (4 << 8);  ///< Huffman length 2 Number of bits in the Huffman code HCODE2 minus 1.
        constexpr uint32_t HCODE3 = (8 << 16);  ///< Huffman code 3 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN3 = (4 << 24);  ///< Huffman length 3 Number of bits in the Huffman code HCODE3 minus 1.
    }

    /// JPEG_HUFFENC_AC0_57 Register bits
    namespace jpeg_huffenc_ac0_57_bits {
        constexpr uint32_t HCODE114 = (8 << 0);  ///< Huffman code 114 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN114 = (4 << 8);  ///< Huffman length 114 Number of bits in the Huffman code HCODE114 minus 1.
        constexpr uint32_t HCODE115 = (8 << 16);  ///< Huffman code 115 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN115 = (4 << 24);  ///< Huffman length 115 Number of bits in the Huffman code HCODE115 minus 1.
    }

    /// JPEG_HUFFENC_AC1_2 Register bits
    namespace jpeg_huffenc_ac1_2_bits {
        constexpr uint32_t HCODE4 = (8 << 0);  ///< Huffman code 4 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN4 = (4 << 8);  ///< Huffman length 4 Number of bits in the Huffman code HCODE4 minus 1.
        constexpr uint32_t HCODE5 = (8 << 16);  ///< Huffman code 5 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN5 = (4 << 24);  ///< Huffman length 5 Number of bits in the Huffman code HCODE5 minus 1.
    }

    /// JPEG_HUFFENC_AC0_58 Register bits
    namespace jpeg_huffenc_ac0_58_bits {
        constexpr uint32_t HCODE116 = (8 << 0);  ///< Huffman code 116 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN116 = (4 << 8);  ///< Huffman length 116 Number of bits in the Huffman code HCODE116 minus 1.
        constexpr uint32_t HCODE117 = (8 << 16);  ///< Huffman code 117 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN117 = (4 << 24);  ///< Huffman length 117 Number of bits in the Huffman code HCODE117 minus 1.
    }

    /// JPEG_HUFFENC_AC1_3 Register bits
    namespace jpeg_huffenc_ac1_3_bits {
        constexpr uint32_t HCODE6 = (8 << 0);  ///< Huffman code 6 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN6 = (4 << 8);  ///< Huffman length 6 Number of bits in the Huffman code HCODE6 minus 1.
        constexpr uint32_t HCODE7 = (8 << 16);  ///< Huffman code 7 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN7 = (4 << 24);  ///< Huffman length 7 Number of bits in the Huffman code HCODE7 minus 1.
    }

    /// JPEG_HUFFENC_AC0_59 Register bits
    namespace jpeg_huffenc_ac0_59_bits {
        constexpr uint32_t HCODE118 = (8 << 0);  ///< Huffman code 118 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN118 = (4 << 8);  ///< Huffman length 118 Number of bits in the Huffman code HCODE118 minus 1.
        constexpr uint32_t HCODE119 = (8 << 16);  ///< Huffman code 119 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN119 = (4 << 24);  ///< Huffman length 119 Number of bits in the Huffman code HCODE119 minus 1.
    }

    /// JPEG_HUFFENC_AC1_4 Register bits
    namespace jpeg_huffenc_ac1_4_bits {
        constexpr uint32_t HCODE8 = (8 << 0);  ///< Huffman code 8 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN8 = (4 << 8);  ///< Huffman length 8 Number of bits in the Huffman code HCODE8 minus 1.
        constexpr uint32_t HCODE9 = (8 << 16);  ///< Huffman code 9 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN9 = (4 << 24);  ///< Huffman length 9 Number of bits in the Huffman code HCODE9 minus 1.
    }

    /// JPEG_HUFFENC_AC0_60 Register bits
    namespace jpeg_huffenc_ac0_60_bits {
        constexpr uint32_t HCODE120 = (8 << 0);  ///< Huffman code 120 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN120 = (4 << 8);  ///< Huffman length 120 Number of bits in the Huffman code HCODE120 minus 1.
        constexpr uint32_t HCODE121 = (8 << 16);  ///< Huffman code 121 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN121 = (4 << 24);  ///< Huffman length 121 Number of bits in the Huffman code HCODE121 minus 1.
    }

    /// JPEG_HUFFENC_AC1_5 Register bits
    namespace jpeg_huffenc_ac1_5_bits {
        constexpr uint32_t HCODE10 = (8 << 0);  ///< Huffman code 10 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN10 = (4 << 8);  ///< Huffman length 10 Number of bits in the Huffman code HCODE10 minus 1.
        constexpr uint32_t HCODE11 = (8 << 16);  ///< Huffman code 11 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN11 = (4 << 24);  ///< Huffman length 11 Number of bits in the Huffman code HCODE11 minus 1.
    }

    /// JPEG_HUFFENC_AC0_61 Register bits
    namespace jpeg_huffenc_ac0_61_bits {
        constexpr uint32_t HCODE122 = (8 << 0);  ///< Huffman code 122 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN122 = (4 << 8);  ///< Huffman length 122 Number of bits in the Huffman code HCODE122 minus 1.
        constexpr uint32_t HCODE123 = (8 << 16);  ///< Huffman code 123 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN123 = (4 << 24);  ///< Huffman length 123 Number of bits in the Huffman code HCODE123 minus 1.
    }

    /// JPEG_HUFFENC_AC1_6 Register bits
    namespace jpeg_huffenc_ac1_6_bits {
        constexpr uint32_t HCODE12 = (8 << 0);  ///< Huffman code 12 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN12 = (4 << 8);  ///< Huffman length 12 Number of bits in the Huffman code HCODE12 minus 1.
        constexpr uint32_t HCODE13 = (8 << 16);  ///< Huffman code 13 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN13 = (4 << 24);  ///< Huffman length 13 Number of bits in the Huffman code HCODE13 minus 1.
    }

    /// JPEG_HUFFENC_AC0_62 Register bits
    namespace jpeg_huffenc_ac0_62_bits {
        constexpr uint32_t HCODE124 = (8 << 0);  ///< Huffman code 124 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN124 = (4 << 8);  ///< Huffman length 124 Number of bits in the Huffman code HCODE124 minus 1.
        constexpr uint32_t HCODE125 = (8 << 16);  ///< Huffman code 125 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN125 = (4 << 24);  ///< Huffman length 125 Number of bits in the Huffman code HCODE125 minus 1.
    }

    /// JPEG_HUFFENC_AC1_7 Register bits
    namespace jpeg_huffenc_ac1_7_bits {
        constexpr uint32_t HCODE14 = (8 << 0);  ///< Huffman code 14 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN14 = (4 << 8);  ///< Huffman length 14 Number of bits in the Huffman code HCODE14 minus 1.
        constexpr uint32_t HCODE15 = (8 << 16);  ///< Huffman code 15 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN15 = (4 << 24);  ///< Huffman length 15 Number of bits in the Huffman code HCODE15 minus 1.
    }

    /// JPEG_HUFFENC_AC0_63 Register bits
    namespace jpeg_huffenc_ac0_63_bits {
        constexpr uint32_t HCODE126 = (8 << 0);  ///< Huffman code 126 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN126 = (4 << 8);  ///< Huffman length 126 Number of bits in the Huffman code HCODE126 minus 1.
        constexpr uint32_t HCODE127 = (8 << 16);  ///< Huffman code 127 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN127 = (4 << 24);  ///< Huffman length 127 Number of bits in the Huffman code HCODE127 minus 1.
    }

    /// JPEG_HUFFENC_AC1_8 Register bits
    namespace jpeg_huffenc_ac1_8_bits {
        constexpr uint32_t HCODE16 = (8 << 0);  ///< Huffman code 16 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN16 = (4 << 8);  ///< Huffman length 16 Number of bits in the Huffman code HCODE16 minus 1.
        constexpr uint32_t HCODE17 = (8 << 16);  ///< Huffman code 17 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN17 = (4 << 24);  ///< Huffman length 17 Number of bits in the Huffman code HCODE17 minus 1.
    }

    /// JPEG_HUFFENC_AC0_64 Register bits
    namespace jpeg_huffenc_ac0_64_bits {
        constexpr uint32_t HCODE128 = (8 << 0);  ///< Huffman code 128 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN128 = (4 << 8);  ///< Huffman length 128 Number of bits in the Huffman code HCODE128 minus 1.
        constexpr uint32_t HCODE129 = (8 << 16);  ///< Huffman code 129 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN129 = (4 << 24);  ///< Huffman length 129 Number of bits in the Huffman code HCODE129 minus 1.
    }

    /// JPEG_HUFFENC_AC1_9 Register bits
    namespace jpeg_huffenc_ac1_9_bits {
        constexpr uint32_t HCODE18 = (8 << 0);  ///< Huffman code 18 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN18 = (4 << 8);  ///< Huffman length 18 Number of bits in the Huffman code HCODE18 minus 1.
        constexpr uint32_t HCODE19 = (8 << 16);  ///< Huffman code 19 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN19 = (4 << 24);  ///< Huffman length 19 Number of bits in the Huffman code HCODE19 minus 1.
    }

    /// JPEG_HUFFENC_AC0_65 Register bits
    namespace jpeg_huffenc_ac0_65_bits {
        constexpr uint32_t HCODE130 = (8 << 0);  ///< Huffman code 130 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN130 = (4 << 8);  ///< Huffman length 130 Number of bits in the Huffman code HCODE130 minus 1.
        constexpr uint32_t HCODE131 = (8 << 16);  ///< Huffman code 131 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN131 = (4 << 24);  ///< Huffman length 131 Number of bits in the Huffman code HCODE131 minus 1.
    }

    /// JPEG_HUFFENC_AC1_10 Register bits
    namespace jpeg_huffenc_ac1_10_bits {
        constexpr uint32_t HCODE20 = (8 << 0);  ///< Huffman code 20 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN20 = (4 << 8);  ///< Huffman length 20 Number of bits in the Huffman code HCODE20 minus 1.
        constexpr uint32_t HCODE21 = (8 << 16);  ///< Huffman code 21 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN21 = (4 << 24);  ///< Huffman length 21 Number of bits in the Huffman code HCODE21 minus 1.
    }

    /// JPEG_HUFFENC_AC0_66 Register bits
    namespace jpeg_huffenc_ac0_66_bits {
        constexpr uint32_t HCODE132 = (8 << 0);  ///< Huffman code 132 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN132 = (4 << 8);  ///< Huffman length 132 Number of bits in the Huffman code HCODE132 minus 1.
        constexpr uint32_t HCODE133 = (8 << 16);  ///< Huffman code 133 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN133 = (4 << 24);  ///< Huffman length 133 Number of bits in the Huffman code HCODE133 minus 1.
    }

    /// JPEG_HUFFENC_AC1_11 Register bits
    namespace jpeg_huffenc_ac1_11_bits {
        constexpr uint32_t HCODE22 = (8 << 0);  ///< Huffman code 22 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN22 = (4 << 8);  ///< Huffman length 22 Number of bits in the Huffman code HCODE22 minus 1.
        constexpr uint32_t HCODE23 = (8 << 16);  ///< Huffman code 23 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN23 = (4 << 24);  ///< Huffman length 23 Number of bits in the Huffman code HCODE23 minus 1.
    }

    /// JPEG_HUFFENC_AC0_67 Register bits
    namespace jpeg_huffenc_ac0_67_bits {
        constexpr uint32_t HCODE134 = (8 << 0);  ///< Huffman code 134 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN134 = (4 << 8);  ///< Huffman length 134 Number of bits in the Huffman code HCODE134 minus 1.
        constexpr uint32_t HCODE135 = (8 << 16);  ///< Huffman code 135 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN135 = (4 << 24);  ///< Huffman length 135 Number of bits in the Huffman code HCODE135 minus 1.
    }

    /// JPEG_HUFFENC_AC1_12 Register bits
    namespace jpeg_huffenc_ac1_12_bits {
        constexpr uint32_t HCODE24 = (8 << 0);  ///< Huffman code 24 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN24 = (4 << 8);  ///< Huffman length 24 Number of bits in the Huffman code HCODE24 minus 1.
        constexpr uint32_t HCODE25 = (8 << 16);  ///< Huffman code 25 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN25 = (4 << 24);  ///< Huffman length 25 Number of bits in the Huffman code HCODE25 minus 1.
    }

    /// JPEG_HUFFENC_AC0_68 Register bits
    namespace jpeg_huffenc_ac0_68_bits {
        constexpr uint32_t HCODE136 = (8 << 0);  ///< Huffman code 136 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN136 = (4 << 8);  ///< Huffman length 136 Number of bits in the Huffman code HCODE136 minus 1.
        constexpr uint32_t HCODE137 = (8 << 16);  ///< Huffman code 137 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN137 = (4 << 24);  ///< Huffman length 137 Number of bits in the Huffman code HCODE137 minus 1.
    }

    /// JPEG_HUFFENC_AC1_13 Register bits
    namespace jpeg_huffenc_ac1_13_bits {
        constexpr uint32_t HCODE26 = (8 << 0);  ///< Huffman code 26 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN26 = (4 << 8);  ///< Huffman length 26 Number of bits in the Huffman code HCODE26 minus 1.
        constexpr uint32_t HCODE27 = (8 << 16);  ///< Huffman code 27 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN27 = (4 << 24);  ///< Huffman length 27 Number of bits in the Huffman code HCODE27 minus 1.
    }

    /// JPEG_HUFFENC_AC0_69 Register bits
    namespace jpeg_huffenc_ac0_69_bits {
        constexpr uint32_t HCODE138 = (8 << 0);  ///< Huffman code 138 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN138 = (4 << 8);  ///< Huffman length 138 Number of bits in the Huffman code HCODE138 minus 1.
        constexpr uint32_t HCODE139 = (8 << 16);  ///< Huffman code 139 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN139 = (4 << 24);  ///< Huffman length 139 Number of bits in the Huffman code HCODE139 minus 1.
    }

    /// JPEG_HUFFENC_AC1_14 Register bits
    namespace jpeg_huffenc_ac1_14_bits {
        constexpr uint32_t HCODE28 = (8 << 0);  ///< Huffman code 28 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN28 = (4 << 8);  ///< Huffman length 28 Number of bits in the Huffman code HCODE28 minus 1.
        constexpr uint32_t HCODE29 = (8 << 16);  ///< Huffman code 29 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN29 = (4 << 24);  ///< Huffman length 29 Number of bits in the Huffman code HCODE29 minus 1.
    }

    /// JPEG_HUFFENC_AC0_70 Register bits
    namespace jpeg_huffenc_ac0_70_bits {
        constexpr uint32_t HCODE140 = (8 << 0);  ///< Huffman code 140 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN140 = (4 << 8);  ///< Huffman length 140 Number of bits in the Huffman code HCODE140 minus 1.
        constexpr uint32_t HCODE141 = (8 << 16);  ///< Huffman code 141 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN141 = (4 << 24);  ///< Huffman length 141 Number of bits in the Huffman code HCODE141 minus 1.
    }

    /// JPEG_HUFFENC_AC1_15 Register bits
    namespace jpeg_huffenc_ac1_15_bits {
        constexpr uint32_t HCODE30 = (8 << 0);  ///< Huffman code 30 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN30 = (4 << 8);  ///< Huffman length 30 Number of bits in the Huffman code HCODE30 minus 1.
        constexpr uint32_t HCODE31 = (8 << 16);  ///< Huffman code 31 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN31 = (4 << 24);  ///< Huffman length 31 Number of bits in the Huffman code HCODE31 minus 1.
    }

    /// JPEG_HUFFENC_AC0_71 Register bits
    namespace jpeg_huffenc_ac0_71_bits {
        constexpr uint32_t HCODE142 = (8 << 0);  ///< Huffman code 142 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN142 = (4 << 8);  ///< Huffman length 142 Number of bits in the Huffman code HCODE142 minus 1.
        constexpr uint32_t HCODE143 = (8 << 16);  ///< Huffman code 143 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN143 = (4 << 24);  ///< Huffman length 143 Number of bits in the Huffman code HCODE143 minus 1.
    }

    /// JPEG_HUFFENC_AC1_16 Register bits
    namespace jpeg_huffenc_ac1_16_bits {
        constexpr uint32_t HCODE32 = (8 << 0);  ///< Huffman code 32 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN32 = (4 << 8);  ///< Huffman length 32 Number of bits in the Huffman code HCODE32 minus 1.
        constexpr uint32_t HCODE33 = (8 << 16);  ///< Huffman code 33 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN33 = (4 << 24);  ///< Huffman length 33 Number of bits in the Huffman code HCODE33 minus 1.
    }

    /// JPEG_HUFFENC_AC0_72 Register bits
    namespace jpeg_huffenc_ac0_72_bits {
        constexpr uint32_t HCODE144 = (8 << 0);  ///< Huffman code 144 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN144 = (4 << 8);  ///< Huffman length 144 Number of bits in the Huffman code HCODE144 minus 1.
        constexpr uint32_t HCODE145 = (8 << 16);  ///< Huffman code 145 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN145 = (4 << 24);  ///< Huffman length 145 Number of bits in the Huffman code HCODE145 minus 1.
    }

    /// JPEG_HUFFENC_AC1_17 Register bits
    namespace jpeg_huffenc_ac1_17_bits {
        constexpr uint32_t HCODE34 = (8 << 0);  ///< Huffman code 34 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN34 = (4 << 8);  ///< Huffman length 34 Number of bits in the Huffman code HCODE34 minus 1.
        constexpr uint32_t HCODE35 = (8 << 16);  ///< Huffman code 35 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN35 = (4 << 24);  ///< Huffman length 35 Number of bits in the Huffman code HCODE35 minus 1.
    }

    /// JPEG_HUFFENC_AC0_73 Register bits
    namespace jpeg_huffenc_ac0_73_bits {
        constexpr uint32_t HCODE146 = (8 << 0);  ///< Huffman code 146 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN146 = (4 << 8);  ///< Huffman length 146 Number of bits in the Huffman code HCODE146 minus 1.
        constexpr uint32_t HCODE147 = (8 << 16);  ///< Huffman code 147 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN147 = (4 << 24);  ///< Huffman length 147 Number of bits in the Huffman code HCODE147 minus 1.
    }

    /// JPEG_HUFFENC_AC1_18 Register bits
    namespace jpeg_huffenc_ac1_18_bits {
        constexpr uint32_t HCODE36 = (8 << 0);  ///< Huffman code 36 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN36 = (4 << 8);  ///< Huffman length 36 Number of bits in the Huffman code HCODE36 minus 1.
        constexpr uint32_t HCODE37 = (8 << 16);  ///< Huffman code 37 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN37 = (4 << 24);  ///< Huffman length 37 Number of bits in the Huffman code HCODE37 minus 1.
    }

    /// JPEG_HUFFENC_AC0_74 Register bits
    namespace jpeg_huffenc_ac0_74_bits {
        constexpr uint32_t HCODE148 = (8 << 0);  ///< Huffman code 148 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN148 = (4 << 8);  ///< Huffman length 148 Number of bits in the Huffman code HCODE148 minus 1.
        constexpr uint32_t HCODE149 = (8 << 16);  ///< Huffman code 149 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN149 = (4 << 24);  ///< Huffman length 149 Number of bits in the Huffman code HCODE149 minus 1.
    }

    /// JPEG_HUFFENC_AC1_19 Register bits
    namespace jpeg_huffenc_ac1_19_bits {
        constexpr uint32_t HCODE38 = (8 << 0);  ///< Huffman code 38 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN38 = (4 << 8);  ///< Huffman length 38 Number of bits in the Huffman code HCODE38 minus 1.
        constexpr uint32_t HCODE39 = (8 << 16);  ///< Huffman code 39 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN39 = (4 << 24);  ///< Huffman length 39 Number of bits in the Huffman code HCODE39 minus 1.
    }

    /// JPEG_HUFFENC_AC0_75 Register bits
    namespace jpeg_huffenc_ac0_75_bits {
        constexpr uint32_t HCODE150 = (8 << 0);  ///< Huffman code 150 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN150 = (4 << 8);  ///< Huffman length 150 Number of bits in the Huffman code HCODE150 minus 1.
        constexpr uint32_t HCODE151 = (8 << 16);  ///< Huffman code 151 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN151 = (4 << 24);  ///< Huffman length 151 Number of bits in the Huffman code HCODE151 minus 1.
    }

    /// JPEG_HUFFENC_AC1_20 Register bits
    namespace jpeg_huffenc_ac1_20_bits {
        constexpr uint32_t HCODE40 = (8 << 0);  ///< Huffman code 40 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN40 = (4 << 8);  ///< Huffman length 40 Number of bits in the Huffman code HCODE40 minus 1.
        constexpr uint32_t HCODE41 = (8 << 16);  ///< Huffman code 41 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN41 = (4 << 24);  ///< Huffman length 41 Number of bits in the Huffman code HCODE41 minus 1.
    }

    /// JPEG_HUFFENC_AC0_76 Register bits
    namespace jpeg_huffenc_ac0_76_bits {
        constexpr uint32_t HCODE152 = (8 << 0);  ///< Huffman code 152 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN152 = (4 << 8);  ///< Huffman length 152 Number of bits in the Huffman code HCODE152 minus 1.
        constexpr uint32_t HCODE153 = (8 << 16);  ///< Huffman code 153 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN153 = (4 << 24);  ///< Huffman length 153 Number of bits in the Huffman code HCODE153 minus 1.
    }

    /// JPEG_HUFFENC_AC1_21 Register bits
    namespace jpeg_huffenc_ac1_21_bits {
        constexpr uint32_t HCODE42 = (8 << 0);  ///< Huffman code 42 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN42 = (4 << 8);  ///< Huffman length 42 Number of bits in the Huffman code HCODE42 minus 1.
        constexpr uint32_t HCODE43 = (8 << 16);  ///< Huffman code 43 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN43 = (4 << 24);  ///< Huffman length 43 Number of bits in the Huffman code HCODE43 minus 1.
    }

    /// JPEG_HUFFENC_AC0_77 Register bits
    namespace jpeg_huffenc_ac0_77_bits {
        constexpr uint32_t HCODE154 = (8 << 0);  ///< Huffman code 154 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN154 = (4 << 8);  ///< Huffman length 154 Number of bits in the Huffman code HCODE154 minus 1.
        constexpr uint32_t HCODE155 = (8 << 16);  ///< Huffman code 155 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN155 = (4 << 24);  ///< Huffman length 155 Number of bits in the Huffman code HCODE155 minus 1.
    }

    /// JPEG_HUFFENC_AC1_22 Register bits
    namespace jpeg_huffenc_ac1_22_bits {
        constexpr uint32_t HCODE44 = (8 << 0);  ///< Huffman code 44 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN44 = (4 << 8);  ///< Huffman length 44 Number of bits in the Huffman code HCODE44 minus 1.
        constexpr uint32_t HCODE45 = (8 << 16);  ///< Huffman code 45 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN45 = (4 << 24);  ///< Huffman length 45 Number of bits in the Huffman code HCODE45 minus 1.
    }

    /// JPEG_HUFFENC_AC0_78 Register bits
    namespace jpeg_huffenc_ac0_78_bits {
        constexpr uint32_t HCODE156 = (8 << 0);  ///< Huffman code 156 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN156 = (4 << 8);  ///< Huffman length 156 Number of bits in the Huffman code HCODE156 minus 1.
        constexpr uint32_t HCODE157 = (8 << 16);  ///< Huffman code 157 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN157 = (4 << 24);  ///< Huffman length 157 Number of bits in the Huffman code HCODE157 minus 1.
    }

    /// JPEG_HUFFENC_AC1_23 Register bits
    namespace jpeg_huffenc_ac1_23_bits {
        constexpr uint32_t HCODE46 = (8 << 0);  ///< Huffman code 46 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN46 = (4 << 8);  ///< Huffman length 46 Number of bits in the Huffman code HCODE46 minus 1.
        constexpr uint32_t HCODE47 = (8 << 16);  ///< Huffman code 47 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN47 = (4 << 24);  ///< Huffman length 47 Number of bits in the Huffman code HCODE47 minus 1.
    }

    /// JPEG_HUFFENC_AC0_79 Register bits
    namespace jpeg_huffenc_ac0_79_bits {
        constexpr uint32_t HCODE158 = (8 << 0);  ///< Huffman code 158 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN158 = (4 << 8);  ///< Huffman length 158 Number of bits in the Huffman code HCODE158 minus 1.
        constexpr uint32_t HCODE159 = (8 << 16);  ///< Huffman code 159 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN159 = (4 << 24);  ///< Huffman length 159 Number of bits in the Huffman code HCODE159 minus 1.
    }

    /// JPEG_HUFFENC_AC1_24 Register bits
    namespace jpeg_huffenc_ac1_24_bits {
        constexpr uint32_t HCODE48 = (8 << 0);  ///< Huffman code 48 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN48 = (4 << 8);  ///< Huffman length 48 Number of bits in the Huffman code HCODE48 minus 1.
        constexpr uint32_t HCODE49 = (8 << 16);  ///< Huffman code 49 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN49 = (4 << 24);  ///< Huffman length 49 Number of bits in the Huffman code HCODE49 minus 1.
    }

    /// JPEG_HUFFENC_AC0_80 Register bits
    namespace jpeg_huffenc_ac0_80_bits {
        constexpr uint32_t HCODE160 = (8 << 0);  ///< Huffman code 160 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN160 = (4 << 8);  ///< Huffman length 160 Number of bits in the Huffman code HCODE160 minus 1.
        constexpr uint32_t HCODE161 = (8 << 16);  ///< Huffman code 161 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN161 = (4 << 24);  ///< Huffman length 161 Number of bits in the Huffman code HCODE161 minus 1.
    }

    /// JPEG_HUFFENC_AC1_25 Register bits
    namespace jpeg_huffenc_ac1_25_bits {
        constexpr uint32_t HCODE50 = (8 << 0);  ///< Huffman code 50 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN50 = (4 << 8);  ///< Huffman length 50 Number of bits in the Huffman code HCODE50 minus 1.
        constexpr uint32_t HCODE51 = (8 << 16);  ///< Huffman code 51 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN51 = (4 << 24);  ///< Huffman length 51 Number of bits in the Huffman code HCODE51 minus 1.
    }

    /// JPEG_HUFFENC_AC0_81 Register bits
    namespace jpeg_huffenc_ac0_81_bits {
        constexpr uint32_t HCODE162 = (8 << 0);  ///< Huffman code 162 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN162 = (4 << 8);  ///< Huffman length 162 Number of bits in the Huffman code HCODE162 minus 1.
        constexpr uint32_t HCODE163 = (8 << 16);  ///< Huffman code 163 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN163 = (4 << 24);  ///< Huffman length 163 Number of bits in the Huffman code HCODE163 minus 1.
    }

    /// JPEG_HUFFENC_AC1_26 Register bits
    namespace jpeg_huffenc_ac1_26_bits {
        constexpr uint32_t HCODE52 = (8 << 0);  ///< Huffman code 52 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN52 = (4 << 8);  ///< Huffman length 52 Number of bits in the Huffman code HCODE52 minus 1.
        constexpr uint32_t HCODE53 = (8 << 16);  ///< Huffman code 53 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN53 = (4 << 24);  ///< Huffman length 53 Number of bits in the Huffman code HCODE53 minus 1.
    }

    /// JPEG_HUFFENC_AC0_82 Register bits
    namespace jpeg_huffenc_ac0_82_bits {
        constexpr uint32_t HCODE164 = (8 << 0);  ///< Huffman code 164 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN164 = (4 << 8);  ///< Huffman length 164 Number of bits in the Huffman code HCODE164 minus 1.
        constexpr uint32_t HCODE165 = (8 << 16);  ///< Huffman code 165 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN165 = (4 << 24);  ///< Huffman length 165 Number of bits in the Huffman code HCODE165 minus 1.
    }

    /// JPEG_HUFFENC_AC1_27 Register bits
    namespace jpeg_huffenc_ac1_27_bits {
        constexpr uint32_t HCODE54 = (8 << 0);  ///< Huffman code 54 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN54 = (4 << 8);  ///< Huffman length 54 Number of bits in the Huffman code HCODE54 minus 1.
        constexpr uint32_t HCODE55 = (8 << 16);  ///< Huffman code 55 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN55 = (4 << 24);  ///< Huffman length 55 Number of bits in the Huffman code HCODE55 minus 1.
    }

    /// JPEG_HUFFENC_AC0_83 Register bits
    namespace jpeg_huffenc_ac0_83_bits {
        constexpr uint32_t HCODE166 = (8 << 0);  ///< Huffman code 166 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN166 = (4 << 8);  ///< Huffman length 166 Number of bits in the Huffman code HCODE166 minus 1.
        constexpr uint32_t HCODE167 = (8 << 16);  ///< Huffman code 167 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN167 = (4 << 24);  ///< Huffman length 167 Number of bits in the Huffman code HCODE167 minus 1.
    }

    /// JPEG_HUFFENC_AC1_28 Register bits
    namespace jpeg_huffenc_ac1_28_bits {
        constexpr uint32_t HCODE56 = (8 << 0);  ///< Huffman code 56 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN56 = (4 << 8);  ///< Huffman length 56 Number of bits in the Huffman code HCODE56 minus 1.
        constexpr uint32_t HCODE57 = (8 << 16);  ///< Huffman code 57 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN57 = (4 << 24);  ///< Huffman length 57 Number of bits in the Huffman code HCODE57 minus 1.
    }

    /// JPEG_HUFFENC_AC0_84 Register bits
    namespace jpeg_huffenc_ac0_84_bits {
        constexpr uint32_t HCODE168 = (8 << 0);  ///< Huffman code 168 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN168 = (4 << 8);  ///< Huffman length 168 Number of bits in the Huffman code HCODE168 minus 1.
        constexpr uint32_t HCODE169 = (8 << 16);  ///< Huffman code 169 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN169 = (4 << 24);  ///< Huffman length 169 Number of bits in the Huffman code HCODE169 minus 1.
    }

    /// JPEG_HUFFENC_AC1_29 Register bits
    namespace jpeg_huffenc_ac1_29_bits {
        constexpr uint32_t HCODE58 = (8 << 0);  ///< Huffman code 58 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN58 = (4 << 8);  ///< Huffman length 58 Number of bits in the Huffman code HCODE58 minus 1.
        constexpr uint32_t HCODE59 = (8 << 16);  ///< Huffman code 59 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN59 = (4 << 24);  ///< Huffman length 59 Number of bits in the Huffman code HCODE59 minus 1.
    }

    /// JPEG_HUFFENC_AC0_85 Register bits
    namespace jpeg_huffenc_ac0_85_bits {
        constexpr uint32_t HCODE170 = (8 << 0);  ///< Huffman code 170 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN170 = (4 << 8);  ///< Huffman length 170 Number of bits in the Huffman code HCODE170 minus 1.
        constexpr uint32_t HCODE171 = (8 << 16);  ///< Huffman code 171 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN171 = (4 << 24);  ///< Huffman length 171 Number of bits in the Huffman code HCODE171 minus 1.
    }

    /// JPEG_HUFFENC_AC1_30 Register bits
    namespace jpeg_huffenc_ac1_30_bits {
        constexpr uint32_t HCODE60 = (8 << 0);  ///< Huffman code 60 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN60 = (4 << 8);  ///< Huffman length 60 Number of bits in the Huffman code HCODE60 minus 1.
        constexpr uint32_t HCODE61 = (8 << 16);  ///< Huffman code 61 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN61 = (4 << 24);  ///< Huffman length 61 Number of bits in the Huffman code HCODE61 minus 1.
    }

    /// JPEG_HUFFENC_AC0_86 Register bits
    namespace jpeg_huffenc_ac0_86_bits {
        constexpr uint32_t HCODE172 = (8 << 0);  ///< Huffman code 172 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN172 = (4 << 8);  ///< Huffman length 172 Number of bits in the Huffman code HCODE172 minus 1.
        constexpr uint32_t HCODE173 = (8 << 16);  ///< Huffman code 173 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN173 = (4 << 24);  ///< Huffman length 173 Number of bits in the Huffman code HCODE173 minus 1.
    }

    /// JPEG_HUFFENC_AC1_31 Register bits
    namespace jpeg_huffenc_ac1_31_bits {
        constexpr uint32_t HCODE62 = (8 << 0);  ///< Huffman code 62 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN62 = (4 << 8);  ///< Huffman length 62 Number of bits in the Huffman code HCODE62 minus 1.
        constexpr uint32_t HCODE63 = (8 << 16);  ///< Huffman code 63 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN63 = (4 << 24);  ///< Huffman length 63 Number of bits in the Huffman code HCODE63 minus 1.
    }

    /// JPEG_HUFFENC_AC0_87 Register bits
    namespace jpeg_huffenc_ac0_87_bits {
        constexpr uint32_t HCODE174 = (8 << 0);  ///< Huffman code 174 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN174 = (4 << 8);  ///< Huffman length 174 Number of bits in the Huffman code HCODE174 minus 1.
        constexpr uint32_t HCODE175 = (8 << 16);  ///< Huffman code 175 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN175 = (4 << 24);  ///< Huffman length 175 Number of bits in the Huffman code HCODE175 minus 1.
    }

    /// JPEG_HUFFENC_AC1_32 Register bits
    namespace jpeg_huffenc_ac1_32_bits {
        constexpr uint32_t HCODE64 = (8 << 0);  ///< Huffman code 64 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN64 = (4 << 8);  ///< Huffman length 64 Number of bits in the Huffman code HCODE64 minus 1.
        constexpr uint32_t HCODE65 = (8 << 16);  ///< Huffman code 65 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN65 = (4 << 24);  ///< Huffman length 65 Number of bits in the Huffman code HCODE65 minus 1.
    }

    /// JPEG_HUFFENC_AC1_33 Register bits
    namespace jpeg_huffenc_ac1_33_bits {
        constexpr uint32_t HCODE66 = (8 << 0);  ///< Huffman code 66 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN66 = (4 << 8);  ///< Huffman length 66 Number of bits in the Huffman code HCODE66 minus 1.
        constexpr uint32_t HCODE67 = (8 << 16);  ///< Huffman code 67 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN67 = (4 << 24);  ///< Huffman length 67 Number of bits in the Huffman code HCODE67 minus 1.
    }

    /// JPEG_HUFFENC_AC1_34 Register bits
    namespace jpeg_huffenc_ac1_34_bits {
        constexpr uint32_t HCODE68 = (8 << 0);  ///< Huffman code 68 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN68 = (4 << 8);  ///< Huffman length 68 Number of bits in the Huffman code HCODE68 minus 1.
        constexpr uint32_t HCODE69 = (8 << 16);  ///< Huffman code 69 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN69 = (4 << 24);  ///< Huffman length 69 Number of bits in the Huffman code HCODE69 minus 1.
    }

    /// JPEG_HUFFENC_AC1_35 Register bits
    namespace jpeg_huffenc_ac1_35_bits {
        constexpr uint32_t HCODE70 = (8 << 0);  ///< Huffman code 70 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN70 = (4 << 8);  ///< Huffman length 70 Number of bits in the Huffman code HCODE70 minus 1.
        constexpr uint32_t HCODE71 = (8 << 16);  ///< Huffman code 71 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN71 = (4 << 24);  ///< Huffman length 71 Number of bits in the Huffman code HCODE71 minus 1.
    }

    /// JPEG_HUFFENC_AC1_36 Register bits
    namespace jpeg_huffenc_ac1_36_bits {
        constexpr uint32_t HCODE72 = (8 << 0);  ///< Huffman code 72 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN72 = (4 << 8);  ///< Huffman length 72 Number of bits in the Huffman code HCODE72 minus 1.
        constexpr uint32_t HCODE73 = (8 << 16);  ///< Huffman code 73 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN73 = (4 << 24);  ///< Huffman length 73 Number of bits in the Huffman code HCODE73 minus 1.
    }

    /// JPEG_HUFFENC_AC1_37 Register bits
    namespace jpeg_huffenc_ac1_37_bits {
        constexpr uint32_t HCODE74 = (8 << 0);  ///< Huffman code 74 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN74 = (4 << 8);  ///< Huffman length 74 Number of bits in the Huffman code HCODE74 minus 1.
        constexpr uint32_t HCODE75 = (8 << 16);  ///< Huffman code 75 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN75 = (4 << 24);  ///< Huffman length 75 Number of bits in the Huffman code HCODE75 minus 1.
    }

    /// JPEG_HUFFENC_AC1_38 Register bits
    namespace jpeg_huffenc_ac1_38_bits {
        constexpr uint32_t HCODE76 = (8 << 0);  ///< Huffman code 76 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN76 = (4 << 8);  ///< Huffman length 76 Number of bits in the Huffman code HCODE76 minus 1.
        constexpr uint32_t HCODE77 = (8 << 16);  ///< Huffman code 77 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN77 = (4 << 24);  ///< Huffman length 77 Number of bits in the Huffman code HCODE77 minus 1.
    }

    /// JPEG_HUFFENC_AC1_39 Register bits
    namespace jpeg_huffenc_ac1_39_bits {
        constexpr uint32_t HCODE78 = (8 << 0);  ///< Huffman code 78 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN78 = (4 << 8);  ///< Huffman length 78 Number of bits in the Huffman code HCODE78 minus 1.
        constexpr uint32_t HCODE79 = (8 << 16);  ///< Huffman code 79 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN79 = (4 << 24);  ///< Huffman length 79 Number of bits in the Huffman code HCODE79 minus 1.
    }

    /// JPEG_HUFFENC_AC1_40 Register bits
    namespace jpeg_huffenc_ac1_40_bits {
        constexpr uint32_t HCODE80 = (8 << 0);  ///< Huffman code 80 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN80 = (4 << 8);  ///< Huffman length 80 Number of bits in the Huffman code HCODE80 minus 1.
        constexpr uint32_t HCODE81 = (8 << 16);  ///< Huffman code 81 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN81 = (4 << 24);  ///< Huffman length 81 Number of bits in the Huffman code HCODE81 minus 1.
    }

    /// JPEG_HUFFENC_AC1_41 Register bits
    namespace jpeg_huffenc_ac1_41_bits {
        constexpr uint32_t HCODE82 = (8 << 0);  ///< Huffman code 82 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN82 = (4 << 8);  ///< Huffman length 82 Number of bits in the Huffman code HCODE82 minus 1.
        constexpr uint32_t HCODE83 = (8 << 16);  ///< Huffman code 83 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN83 = (4 << 24);  ///< Huffman length 83 Number of bits in the Huffman code HCODE83 minus 1.
    }

    /// JPEG_HUFFENC_AC1_42 Register bits
    namespace jpeg_huffenc_ac1_42_bits {
        constexpr uint32_t HCODE84 = (8 << 0);  ///< Huffman code 84 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN84 = (4 << 8);  ///< Huffman length 84 Number of bits in the Huffman code HCODE84 minus 1.
        constexpr uint32_t HCODE85 = (8 << 16);  ///< Huffman code 85 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN85 = (4 << 24);  ///< Huffman length 85 Number of bits in the Huffman code HCODE85 minus 1.
    }

    /// JPEG_HUFFENC_AC1_43 Register bits
    namespace jpeg_huffenc_ac1_43_bits {
        constexpr uint32_t HCODE86 = (8 << 0);  ///< Huffman code 86 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN86 = (4 << 8);  ///< Huffman length 86 Number of bits in the Huffman code HCODE86 minus 1.
        constexpr uint32_t HCODE87 = (8 << 16);  ///< Huffman code 87 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN87 = (4 << 24);  ///< Huffman length 87 Number of bits in the Huffman code HCODE87 minus 1.
    }

    /// JPEG_HUFFENC_AC1_44 Register bits
    namespace jpeg_huffenc_ac1_44_bits {
        constexpr uint32_t HCODE88 = (8 << 0);  ///< Huffman code 88 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN88 = (4 << 8);  ///< Huffman length 88 Number of bits in the Huffman code HCODE88 minus 1.
        constexpr uint32_t HCODE89 = (8 << 16);  ///< Huffman code 89 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN89 = (4 << 24);  ///< Huffman length 89 Number of bits in the Huffman code HCODE89 minus 1.
    }

    /// JPEG_HUFFENC_AC1_45 Register bits
    namespace jpeg_huffenc_ac1_45_bits {
        constexpr uint32_t HCODE90 = (8 << 0);  ///< Huffman code 90 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN90 = (4 << 8);  ///< Huffman length 90 Number of bits in the Huffman code HCODE90 minus 1.
        constexpr uint32_t HCODE91 = (8 << 16);  ///< Huffman code 91 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN91 = (4 << 24);  ///< Huffman length 91 Number of bits in the Huffman code HCODE91 minus 1.
    }

    /// JPEG_HUFFENC_AC1_46 Register bits
    namespace jpeg_huffenc_ac1_46_bits {
        constexpr uint32_t HCODE92 = (8 << 0);  ///< Huffman code 92 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN92 = (4 << 8);  ///< Huffman length 92 Number of bits in the Huffman code HCODE92 minus 1.
        constexpr uint32_t HCODE93 = (8 << 16);  ///< Huffman code 93 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN93 = (4 << 24);  ///< Huffman length 93 Number of bits in the Huffman code HCODE93 minus 1.
    }

    /// JPEG_HUFFENC_AC1_47 Register bits
    namespace jpeg_huffenc_ac1_47_bits {
        constexpr uint32_t HCODE94 = (8 << 0);  ///< Huffman code 94 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN94 = (4 << 8);  ///< Huffman length 94 Number of bits in the Huffman code HCODE94 minus 1.
        constexpr uint32_t HCODE95 = (8 << 16);  ///< Huffman code 95 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN95 = (4 << 24);  ///< Huffman length 95 Number of bits in the Huffman code HCODE95 minus 1.
    }

    /// JPEG_HUFFENC_AC1_48 Register bits
    namespace jpeg_huffenc_ac1_48_bits {
        constexpr uint32_t HCODE96 = (8 << 0);  ///< Huffman code 96 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN96 = (4 << 8);  ///< Huffman length 96 Number of bits in the Huffman code HCODE96 minus 1.
        constexpr uint32_t HCODE97 = (8 << 16);  ///< Huffman code 97 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN97 = (4 << 24);  ///< Huffman length 97 Number of bits in the Huffman code HCODE97 minus 1.
    }

    /// JPEG_HUFFENC_AC1_49 Register bits
    namespace jpeg_huffenc_ac1_49_bits {
        constexpr uint32_t HCODE98 = (8 << 0);  ///< Huffman code 98 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN98 = (4 << 8);  ///< Huffman length 98 Number of bits in the Huffman code HCODE98 minus 1.
        constexpr uint32_t HCODE99 = (8 << 16);  ///< Huffman code 99 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN99 = (4 << 24);  ///< Huffman length 99 Number of bits in the Huffman code HCODE99 minus 1.
    }

    /// JPEG_HUFFENC_AC1_50 Register bits
    namespace jpeg_huffenc_ac1_50_bits {
        constexpr uint32_t HCODE100 = (8 << 0);  ///< Huffman code 100 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN100 = (4 << 8);  ///< Huffman length 100 Number of bits in the Huffman code HCODE100 minus 1.
        constexpr uint32_t HCODE101 = (8 << 16);  ///< Huffman code 101 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN101 = (4 << 24);  ///< Huffman length 101 Number of bits in the Huffman code HCODE101 minus 1.
    }

    /// JPEG_HUFFENC_AC1_51 Register bits
    namespace jpeg_huffenc_ac1_51_bits {
        constexpr uint32_t HCODE102 = (8 << 0);  ///< Huffman code 102 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN102 = (4 << 8);  ///< Huffman length 102 Number of bits in the Huffman code HCODE102 minus 1.
        constexpr uint32_t HCODE103 = (8 << 16);  ///< Huffman code 103 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN103 = (4 << 24);  ///< Huffman length 103 Number of bits in the Huffman code HCODE103 minus 1.
    }

    /// JPEG_HUFFENC_AC1_52 Register bits
    namespace jpeg_huffenc_ac1_52_bits {
        constexpr uint32_t HCODE104 = (8 << 0);  ///< Huffman code 104 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN104 = (4 << 8);  ///< Huffman length 104 Number of bits in the Huffman code HCODE104 minus 1.
        constexpr uint32_t HCODE105 = (8 << 16);  ///< Huffman code 105 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN105 = (4 << 24);  ///< Huffman length 105 Number of bits in the Huffman code HCODE105 minus 1.
    }

    /// JPEG_HUFFENC_AC1_53 Register bits
    namespace jpeg_huffenc_ac1_53_bits {
        constexpr uint32_t HCODE106 = (8 << 0);  ///< Huffman code 106 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN106 = (4 << 8);  ///< Huffman length 106 Number of bits in the Huffman code HCODE106 minus 1.
        constexpr uint32_t HCODE107 = (8 << 16);  ///< Huffman code 107 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN107 = (4 << 24);  ///< Huffman length 107 Number of bits in the Huffman code HCODE107 minus 1.
    }

    /// JPEG_HUFFENC_AC1_54 Register bits
    namespace jpeg_huffenc_ac1_54_bits {
        constexpr uint32_t HCODE108 = (8 << 0);  ///< Huffman code 108 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN108 = (4 << 8);  ///< Huffman length 108 Number of bits in the Huffman code HCODE108 minus 1.
        constexpr uint32_t HCODE109 = (8 << 16);  ///< Huffman code 109 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN109 = (4 << 24);  ///< Huffman length 109 Number of bits in the Huffman code HCODE109 minus 1.
    }

    /// JPEG_HUFFENC_AC1_55 Register bits
    namespace jpeg_huffenc_ac1_55_bits {
        constexpr uint32_t HCODE110 = (8 << 0);  ///< Huffman code 110 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN110 = (4 << 8);  ///< Huffman length 110 Number of bits in the Huffman code HCODE110 minus 1.
        constexpr uint32_t HCODE111 = (8 << 16);  ///< Huffman code 111 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN111 = (4 << 24);  ///< Huffman length 111 Number of bits in the Huffman code HCODE111 minus 1.
    }

    /// JPEG_HUFFENC_AC1_56 Register bits
    namespace jpeg_huffenc_ac1_56_bits {
        constexpr uint32_t HCODE112 = (8 << 0);  ///< Huffman code 112 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN112 = (4 << 8);  ///< Huffman length 112 Number of bits in the Huffman code HCODE112 minus 1.
        constexpr uint32_t HCODE113 = (8 << 16);  ///< Huffman code 113 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN113 = (4 << 24);  ///< Huffman length 113 Number of bits in the Huffman code HCODE113 minus 1.
    }

    /// JPEG_HUFFENC_AC1_57 Register bits
    namespace jpeg_huffenc_ac1_57_bits {
        constexpr uint32_t HCODE114 = (8 << 0);  ///< Huffman code 114 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN114 = (4 << 8);  ///< Huffman length 114 Number of bits in the Huffman code HCODE114 minus 1.
        constexpr uint32_t HCODE115 = (8 << 16);  ///< Huffman code 115 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN115 = (4 << 24);  ///< Huffman length 115 Number of bits in the Huffman code HCODE115 minus 1.
    }

    /// JPEG_HUFFENC_AC1_58 Register bits
    namespace jpeg_huffenc_ac1_58_bits {
        constexpr uint32_t HCODE116 = (8 << 0);  ///< Huffman code 116 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN116 = (4 << 8);  ///< Huffman length 116 Number of bits in the Huffman code HCODE116 minus 1.
        constexpr uint32_t HCODE117 = (8 << 16);  ///< Huffman code 117 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN117 = (4 << 24);  ///< Huffman length 117 Number of bits in the Huffman code HCODE117 minus 1.
    }

    /// JPEG_HUFFENC_AC1_59 Register bits
    namespace jpeg_huffenc_ac1_59_bits {
        constexpr uint32_t HCODE118 = (8 << 0);  ///< Huffman code 118 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN118 = (4 << 8);  ///< Huffman length 118 Number of bits in the Huffman code HCODE118 minus 1.
        constexpr uint32_t HCODE119 = (8 << 16);  ///< Huffman code 119 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN119 = (4 << 24);  ///< Huffman length 119 Number of bits in the Huffman code HCODE119 minus 1.
    }

    /// JPEG_HUFFENC_AC1_60 Register bits
    namespace jpeg_huffenc_ac1_60_bits {
        constexpr uint32_t HCODE120 = (8 << 0);  ///< Huffman code 120 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN120 = (4 << 8);  ///< Huffman length 120 Number of bits in the Huffman code HCODE120 minus 1.
        constexpr uint32_t HCODE121 = (8 << 16);  ///< Huffman code 121 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN121 = (4 << 24);  ///< Huffman length 121 Number of bits in the Huffman code HCODE121 minus 1.
    }

    /// JPEG_HUFFENC_AC1_61 Register bits
    namespace jpeg_huffenc_ac1_61_bits {
        constexpr uint32_t HCODE122 = (8 << 0);  ///< Huffman code 122 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN122 = (4 << 8);  ///< Huffman length 122 Number of bits in the Huffman code HCODE122 minus 1.
        constexpr uint32_t HCODE123 = (8 << 16);  ///< Huffman code 123 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN123 = (4 << 24);  ///< Huffman length 123 Number of bits in the Huffman code HCODE123 minus 1.
    }

    /// JPEG_HUFFENC_AC1_62 Register bits
    namespace jpeg_huffenc_ac1_62_bits {
        constexpr uint32_t HCODE124 = (8 << 0);  ///< Huffman code 124 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN124 = (4 << 8);  ///< Huffman length 124 Number of bits in the Huffman code HCODE124 minus 1.
        constexpr uint32_t HCODE125 = (8 << 16);  ///< Huffman code 125 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN125 = (4 << 24);  ///< Huffman length 125 Number of bits in the Huffman code HCODE125 minus 1.
    }

    /// JPEG_HUFFENC_AC1_63 Register bits
    namespace jpeg_huffenc_ac1_63_bits {
        constexpr uint32_t HCODE126 = (8 << 0);  ///< Huffman code 126 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN126 = (4 << 8);  ///< Huffman length 126 Number of bits in the Huffman code HCODE126 minus 1.
        constexpr uint32_t HCODE127 = (8 << 16);  ///< Huffman code 127 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN127 = (4 << 24);  ///< Huffman length 127 Number of bits in the Huffman code HCODE127 minus 1.
    }

    /// JPEG_HUFFENC_AC1_64 Register bits
    namespace jpeg_huffenc_ac1_64_bits {
        constexpr uint32_t HCODE128 = (8 << 0);  ///< Huffman code 128 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN128 = (4 << 8);  ///< Huffman length 128 Number of bits in the Huffman code HCODE128 minus 1.
        constexpr uint32_t HCODE129 = (8 << 16);  ///< Huffman code 129 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN129 = (4 << 24);  ///< Huffman length 129 Number of bits in the Huffman code HCODE129 minus 1.
    }

    /// JPEG_HUFFENC_AC1_65 Register bits
    namespace jpeg_huffenc_ac1_65_bits {
        constexpr uint32_t HCODE130 = (8 << 0);  ///< Huffman code 130 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN130 = (4 << 8);  ///< Huffman length 130 Number of bits in the Huffman code HCODE130 minus 1.
        constexpr uint32_t HCODE131 = (8 << 16);  ///< Huffman code 131 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN131 = (4 << 24);  ///< Huffman length 131 Number of bits in the Huffman code HCODE131 minus 1.
    }

    /// JPEG_HUFFENC_AC1_66 Register bits
    namespace jpeg_huffenc_ac1_66_bits {
        constexpr uint32_t HCODE132 = (8 << 0);  ///< Huffman code 132 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN132 = (4 << 8);  ///< Huffman length 132 Number of bits in the Huffman code HCODE132 minus 1.
        constexpr uint32_t HCODE133 = (8 << 16);  ///< Huffman code 133 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN133 = (4 << 24);  ///< Huffman length 133 Number of bits in the Huffman code HCODE133 minus 1.
    }

    /// JPEG_HUFFENC_AC1_67 Register bits
    namespace jpeg_huffenc_ac1_67_bits {
        constexpr uint32_t HCODE134 = (8 << 0);  ///< Huffman code 134 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN134 = (4 << 8);  ///< Huffman length 134 Number of bits in the Huffman code HCODE134 minus 1.
        constexpr uint32_t HCODE135 = (8 << 16);  ///< Huffman code 135 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN135 = (4 << 24);  ///< Huffman length 135 Number of bits in the Huffman code HCODE135 minus 1.
    }

    /// JPEG_HUFFENC_AC1_68 Register bits
    namespace jpeg_huffenc_ac1_68_bits {
        constexpr uint32_t HCODE136 = (8 << 0);  ///< Huffman code 136 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN136 = (4 << 8);  ///< Huffman length 136 Number of bits in the Huffman code HCODE136 minus 1.
        constexpr uint32_t HCODE137 = (8 << 16);  ///< Huffman code 137 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN137 = (4 << 24);  ///< Huffman length 137 Number of bits in the Huffman code HCODE137 minus 1.
    }

    /// JPEG_HUFFENC_AC1_69 Register bits
    namespace jpeg_huffenc_ac1_69_bits {
        constexpr uint32_t HCODE138 = (8 << 0);  ///< Huffman code 138 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN138 = (4 << 8);  ///< Huffman length 138 Number of bits in the Huffman code HCODE138 minus 1.
        constexpr uint32_t HCODE139 = (8 << 16);  ///< Huffman code 139 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN139 = (4 << 24);  ///< Huffman length 139 Number of bits in the Huffman code HCODE139 minus 1.
    }

    /// JPEG_HUFFENC_AC1_70 Register bits
    namespace jpeg_huffenc_ac1_70_bits {
        constexpr uint32_t HCODE140 = (8 << 0);  ///< Huffman code 140 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN140 = (4 << 8);  ///< Huffman length 140 Number of bits in the Huffman code HCODE140 minus 1.
        constexpr uint32_t HCODE141 = (8 << 16);  ///< Huffman code 141 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN141 = (4 << 24);  ///< Huffman length 141 Number of bits in the Huffman code HCODE141 minus 1.
    }

    /// JPEG_HUFFENC_AC1_71 Register bits
    namespace jpeg_huffenc_ac1_71_bits {
        constexpr uint32_t HCODE142 = (8 << 0);  ///< Huffman code 142 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN142 = (4 << 8);  ///< Huffman length 142 Number of bits in the Huffman code HCODE142 minus 1.
        constexpr uint32_t HCODE143 = (8 << 16);  ///< Huffman code 143 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN143 = (4 << 24);  ///< Huffman length 143 Number of bits in the Huffman code HCODE143 minus 1.
    }

    /// JPEG_HUFFENC_AC1_72 Register bits
    namespace jpeg_huffenc_ac1_72_bits {
        constexpr uint32_t HCODE144 = (8 << 0);  ///< Huffman code 144 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN144 = (4 << 8);  ///< Huffman length 144 Number of bits in the Huffman code HCODE144 minus 1.
        constexpr uint32_t HCODE145 = (8 << 16);  ///< Huffman code 145 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN145 = (4 << 24);  ///< Huffman length 145 Number of bits in the Huffman code HCODE145 minus 1.
    }

    /// JPEG_HUFFENC_AC1_73 Register bits
    namespace jpeg_huffenc_ac1_73_bits {
        constexpr uint32_t HCODE146 = (8 << 0);  ///< Huffman code 146 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN146 = (4 << 8);  ///< Huffman length 146 Number of bits in the Huffman code HCODE146 minus 1.
        constexpr uint32_t HCODE147 = (8 << 16);  ///< Huffman code 147 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN147 = (4 << 24);  ///< Huffman length 147 Number of bits in the Huffman code HCODE147 minus 1.
    }

    /// JPEG_HUFFENC_AC1_74 Register bits
    namespace jpeg_huffenc_ac1_74_bits {
        constexpr uint32_t HCODE148 = (8 << 0);  ///< Huffman code 148 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN148 = (4 << 8);  ///< Huffman length 148 Number of bits in the Huffman code HCODE148 minus 1.
        constexpr uint32_t HCODE149 = (8 << 16);  ///< Huffman code 149 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN149 = (4 << 24);  ///< Huffman length 149 Number of bits in the Huffman code HCODE149 minus 1.
    }

    /// JPEG_HUFFENC_AC1_75 Register bits
    namespace jpeg_huffenc_ac1_75_bits {
        constexpr uint32_t HCODE150 = (8 << 0);  ///< Huffman code 150 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN150 = (4 << 8);  ///< Huffman length 150 Number of bits in the Huffman code HCODE150 minus 1.
        constexpr uint32_t HCODE151 = (8 << 16);  ///< Huffman code 151 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN151 = (4 << 24);  ///< Huffman length 151 Number of bits in the Huffman code HCODE151 minus 1.
    }

    /// JPEG_HUFFENC_AC1_76 Register bits
    namespace jpeg_huffenc_ac1_76_bits {
        constexpr uint32_t HCODE152 = (8 << 0);  ///< Huffman code 152 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN152 = (4 << 8);  ///< Huffman length 152 Number of bits in the Huffman code HCODE152 minus 1.
        constexpr uint32_t HCODE153 = (8 << 16);  ///< Huffman code 153 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN153 = (4 << 24);  ///< Huffman length 153 Number of bits in the Huffman code HCODE153 minus 1.
    }

    /// JPEG_HUFFENC_AC1_77 Register bits
    namespace jpeg_huffenc_ac1_77_bits {
        constexpr uint32_t HCODE154 = (8 << 0);  ///< Huffman code 154 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN154 = (4 << 8);  ///< Huffman length 154 Number of bits in the Huffman code HCODE154 minus 1.
        constexpr uint32_t HCODE155 = (8 << 16);  ///< Huffman code 155 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN155 = (4 << 24);  ///< Huffman length 155 Number of bits in the Huffman code HCODE155 minus 1.
    }

    /// JPEG_HUFFENC_AC1_78 Register bits
    namespace jpeg_huffenc_ac1_78_bits {
        constexpr uint32_t HCODE156 = (8 << 0);  ///< Huffman code 156 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN156 = (4 << 8);  ///< Huffman length 156 Number of bits in the Huffman code HCODE156 minus 1.
        constexpr uint32_t HCODE157 = (8 << 16);  ///< Huffman code 157 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN157 = (4 << 24);  ///< Huffman length 157 Number of bits in the Huffman code HCODE157 minus 1.
    }

    /// JPEG_HUFFENC_AC1_79 Register bits
    namespace jpeg_huffenc_ac1_79_bits {
        constexpr uint32_t HCODE158 = (8 << 0);  ///< Huffman code 158 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN158 = (4 << 8);  ///< Huffman length 158 Number of bits in the Huffman code HCODE158 minus 1.
        constexpr uint32_t HCODE159 = (8 << 16);  ///< Huffman code 159 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN159 = (4 << 24);  ///< Huffman length 159 Number of bits in the Huffman code HCODE159 minus 1.
    }

    /// JPEG_HUFFENC_AC1_80 Register bits
    namespace jpeg_huffenc_ac1_80_bits {
        constexpr uint32_t HCODE160 = (8 << 0);  ///< Huffman code 160 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN160 = (4 << 8);  ///< Huffman length 160 Number of bits in the Huffman code HCODE160 minus 1.
        constexpr uint32_t HCODE161 = (8 << 16);  ///< Huffman code 161 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN161 = (4 << 24);  ///< Huffman length 161 Number of bits in the Huffman code HCODE161 minus 1.
    }

    /// JPEG_HUFFENC_AC1_81 Register bits
    namespace jpeg_huffenc_ac1_81_bits {
        constexpr uint32_t HCODE162 = (8 << 0);  ///< Huffman code 162 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN162 = (4 << 8);  ///< Huffman length 162 Number of bits in the Huffman code HCODE162 minus 1.
        constexpr uint32_t HCODE163 = (8 << 16);  ///< Huffman code 163 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN163 = (4 << 24);  ///< Huffman length 163 Number of bits in the Huffman code HCODE163 minus 1.
    }

    /// JPEG_HUFFENC_AC1_82 Register bits
    namespace jpeg_huffenc_ac1_82_bits {
        constexpr uint32_t HCODE164 = (8 << 0);  ///< Huffman code 164 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN164 = (4 << 8);  ///< Huffman length 164 Number of bits in the Huffman code HCODE164 minus 1.
        constexpr uint32_t HCODE165 = (8 << 16);  ///< Huffman code 165 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN165 = (4 << 24);  ///< Huffman length 165 Number of bits in the Huffman code HCODE165 minus 1.
    }

    /// JPEG_HUFFENC_AC1_83 Register bits
    namespace jpeg_huffenc_ac1_83_bits {
        constexpr uint32_t HCODE166 = (8 << 0);  ///< Huffman code 166 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN166 = (4 << 8);  ///< Huffman length 166 Number of bits in the Huffman code HCODE166 minus 1.
        constexpr uint32_t HCODE167 = (8 << 16);  ///< Huffman code 167 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN167 = (4 << 24);  ///< Huffman length 167 Number of bits in the Huffman code HCODE167 minus 1.
    }

    /// JPEG_HUFFENC_AC1_84 Register bits
    namespace jpeg_huffenc_ac1_84_bits {
        constexpr uint32_t HCODE168 = (8 << 0);  ///< Huffman code 168 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN168 = (4 << 8);  ///< Huffman length 168 Number of bits in the Huffman code HCODE168 minus 1.
        constexpr uint32_t HCODE169 = (8 << 16);  ///< Huffman code 169 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN169 = (4 << 24);  ///< Huffman length 169 Number of bits in the Huffman code HCODE169 minus 1.
    }

    /// JPEG_HUFFENC_AC1_85 Register bits
    namespace jpeg_huffenc_ac1_85_bits {
        constexpr uint32_t HCODE170 = (8 << 0);  ///< Huffman code 170 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN170 = (4 << 8);  ///< Huffman length 170 Number of bits in the Huffman code HCODE170 minus 1.
        constexpr uint32_t HCODE171 = (8 << 16);  ///< Huffman code 171 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN171 = (4 << 24);  ///< Huffman length 171 Number of bits in the Huffman code HCODE171 minus 1.
    }

    /// JPEG_HUFFENC_AC1_86 Register bits
    namespace jpeg_huffenc_ac1_86_bits {
        constexpr uint32_t HCODE172 = (8 << 0);  ///< Huffman code 172 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN172 = (4 << 8);  ///< Huffman length 172 Number of bits in the Huffman code HCODE172 minus 1.
        constexpr uint32_t HCODE173 = (8 << 16);  ///< Huffman code 173 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN173 = (4 << 24);  ///< Huffman length 173 Number of bits in the Huffman code HCODE173 minus 1.
    }

    /// JPEG_HUFFENC_AC1_87 Register bits
    namespace jpeg_huffenc_ac1_87_bits {
        constexpr uint32_t HCODE174 = (8 << 0);  ///< Huffman code 174 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN174 = (4 << 8);  ///< Huffman length 174 Number of bits in the Huffman code HCODE174 minus 1.
        constexpr uint32_t HCODE175 = (8 << 16);  ///< Huffman code 175 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN175 = (4 << 24);  ///< Huffman length 175 Number of bits in the Huffman code HCODE175 minus 1.
    }

    /// JPEG_HUFFENC_DC0_0 Register bits
    namespace jpeg_huffenc_dc0_0_bits {
        constexpr uint32_t HCODE0 = (8 << 0);  ///< Huffman code 0 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN0 = (4 << 8);  ///< Huffman length 0 Number of bits in the Huffman code HCODE0 minus 1.
        constexpr uint32_t HCODE1 = (8 << 16);  ///< Huffman code 1 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN1 = (4 << 24);  ///< Huffman length 1 Number of bits in the Huffman code HCODE1 minus 1.
    }

    /// JPEG_HUFFENC_DC0_1 Register bits
    namespace jpeg_huffenc_dc0_1_bits {
        constexpr uint32_t HCODE2 = (8 << 0);  ///< Huffman code 2 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN2 = (4 << 8);  ///< Huffman length 2 Number of bits in the Huffman code HCODE2 minus 1.
        constexpr uint32_t HCODE3 = (8 << 16);  ///< Huffman code 3 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN3 = (4 << 24);  ///< Huffman length 3 Number of bits in the Huffman code HCODE3 minus 1.
    }

    /// JPEG_HUFFENC_DC0_2 Register bits
    namespace jpeg_huffenc_dc0_2_bits {
        constexpr uint32_t HCODE4 = (8 << 0);  ///< Huffman code 4 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN4 = (4 << 8);  ///< Huffman length 4 Number of bits in the Huffman code HCODE4 minus 1.
        constexpr uint32_t HCODE5 = (8 << 16);  ///< Huffman code 5 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN5 = (4 << 24);  ///< Huffman length 5 Number of bits in the Huffman code HCODE5 minus 1.
    }

    /// JPEG_HUFFENC_DC0_3 Register bits
    namespace jpeg_huffenc_dc0_3_bits {
        constexpr uint32_t HCODE6 = (8 << 0);  ///< Huffman code 6 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN6 = (4 << 8);  ///< Huffman length 6 Number of bits in the Huffman code HCODE6 minus 1.
        constexpr uint32_t HCODE7 = (8 << 16);  ///< Huffman code 7 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN7 = (4 << 24);  ///< Huffman length 7 Number of bits in the Huffman code HCODE7 minus 1.
    }

    /// JPEG_HUFFENC_DC0_4 Register bits
    namespace jpeg_huffenc_dc0_4_bits {
        constexpr uint32_t HCODE8 = (8 << 0);  ///< Huffman code 8 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN8 = (4 << 8);  ///< Huffman length 8 Number of bits in the Huffman code HCODE8 minus 1.
        constexpr uint32_t HCODE9 = (8 << 16);  ///< Huffman code 9 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN9 = (4 << 24);  ///< Huffman length 9 Number of bits in the Huffman code HCODE9 minus 1.
    }

    /// JPEG_HUFFENC_DC0_5 Register bits
    namespace jpeg_huffenc_dc0_5_bits {
        constexpr uint32_t HCODE10 = (8 << 0);  ///< Huffman code 10 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN10 = (4 << 8);  ///< Huffman length 10 Number of bits in the Huffman code HCODE10 minus 1.
        constexpr uint32_t HCODE11 = (8 << 16);  ///< Huffman code 11 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN11 = (4 << 24);  ///< Huffman length 11 Number of bits in the Huffman code HCODE11 minus 1.
    }

    /// JPEG_HUFFENC_DC0_6 Register bits
    namespace jpeg_huffenc_dc0_6_bits {
        constexpr uint32_t HCODE12 = (8 << 0);  ///< Huffman code 12 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN12 = (4 << 8);  ///< Huffman length 12 Number of bits in the Huffman code HCODE12 minus 1.
        constexpr uint32_t HCODE13 = (8 << 16);  ///< Huffman code 13 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN13 = (4 << 24);  ///< Huffman length 13 Number of bits in the Huffman code HCODE13 minus 1.
    }

    /// JPEG_HUFFENC_DC0_7 Register bits
    namespace jpeg_huffenc_dc0_7_bits {
        constexpr uint32_t HCODE14 = (8 << 0);  ///< Huffman code 14 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN14 = (4 << 8);  ///< Huffman length 14 Number of bits in the Huffman code HCODE14 minus 1.
        constexpr uint32_t HCODE15 = (8 << 16);  ///< Huffman code 15 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN15 = (4 << 24);  ///< Huffman length 15 Number of bits in the Huffman code HCODE15 minus 1.
    }

    /// JPEG_HUFFENC_DC1_0 Register bits
    namespace jpeg_huffenc_dc1_0_bits {
        constexpr uint32_t HCODE0 = (8 << 0);  ///< Huffman code 0 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN0 = (4 << 8);  ///< Huffman length 0 Number of bits in the Huffman code HCODE0 minus 1.
        constexpr uint32_t HCODE1 = (8 << 16);  ///< Huffman code 1 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN1 = (4 << 24);  ///< Huffman length 1 Number of bits in the Huffman code HCODE1 minus 1.
    }

    /// JPEG_HUFFENC_DC1_1 Register bits
    namespace jpeg_huffenc_dc1_1_bits {
        constexpr uint32_t HCODE2 = (8 << 0);  ///< Huffman code 2 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN2 = (4 << 8);  ///< Huffman length 2 Number of bits in the Huffman code HCODE2 minus 1.
        constexpr uint32_t HCODE3 = (8 << 16);  ///< Huffman code 3 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN3 = (4 << 24);  ///< Huffman length 3 Number of bits in the Huffman code HCODE3 minus 1.
    }

    /// JPEG_HUFFENC_DC1_2 Register bits
    namespace jpeg_huffenc_dc1_2_bits {
        constexpr uint32_t HCODE4 = (8 << 0);  ///< Huffman code 4 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN4 = (4 << 8);  ///< Huffman length 4 Number of bits in the Huffman code HCODE4 minus 1.
        constexpr uint32_t HCODE5 = (8 << 16);  ///< Huffman code 5 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN5 = (4 << 24);  ///< Huffman length 5 Number of bits in the Huffman code HCODE5 minus 1.
    }

    /// JPEG_HUFFENC_DC1_3 Register bits
    namespace jpeg_huffenc_dc1_3_bits {
        constexpr uint32_t HCODE6 = (8 << 0);  ///< Huffman code 6 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN6 = (4 << 8);  ///< Huffman length 6 Number of bits in the Huffman code HCODE6 minus 1.
        constexpr uint32_t HCODE7 = (8 << 16);  ///< Huffman code 7 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN7 = (4 << 24);  ///< Huffman length 7 Number of bits in the Huffman code HCODE7 minus 1.
    }

    /// JPEG_HUFFENC_DC1_4 Register bits
    namespace jpeg_huffenc_dc1_4_bits {
        constexpr uint32_t HCODE8 = (8 << 0);  ///< Huffman code 8 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN8 = (4 << 8);  ///< Huffman length 8 Number of bits in the Huffman code HCODE8 minus 1.
        constexpr uint32_t HCODE9 = (8 << 16);  ///< Huffman code 9 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN9 = (4 << 24);  ///< Huffman length 9 Number of bits in the Huffman code HCODE9 minus 1.
    }

    /// JPEG_HUFFENC_DC1_5 Register bits
    namespace jpeg_huffenc_dc1_5_bits {
        constexpr uint32_t HCODE10 = (8 << 0);  ///< Huffman code 10 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN10 = (4 << 8);  ///< Huffman length 10 Number of bits in the Huffman code HCODE10 minus 1.
        constexpr uint32_t HCODE11 = (8 << 16);  ///< Huffman code 11 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN11 = (4 << 24);  ///< Huffman length 11 Number of bits in the Huffman code HCODE11 minus 1.
    }

    /// JPEG_HUFFENC_DC1_6 Register bits
    namespace jpeg_huffenc_dc1_6_bits {
        constexpr uint32_t HCODE12 = (8 << 0);  ///< Huffman code 12 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN12 = (4 << 8);  ///< Huffman length 12 Number of bits in the Huffman code HCODE12 minus 1.
        constexpr uint32_t HCODE13 = (8 << 16);  ///< Huffman code 13 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN13 = (4 << 24);  ///< Huffman length 13 Number of bits in the Huffman code HCODE13 minus 1.
    }

    /// JPEG_HUFFENC_DC1_7 Register bits
    namespace jpeg_huffenc_dc1_7_bits {
        constexpr uint32_t HCODE14 = (8 << 0);  ///< Huffman code 14 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN14 = (4 << 8);  ///< Huffman length 14 Number of bits in the Huffman code HCODE14 minus 1.
        constexpr uint32_t HCODE15 = (8 << 16);  ///< Huffman code 15 8 least significant bits of the Huffman code. If the Huffman code is less than 8 bits long, the unused bits must be 0.
        constexpr uint32_t HLEN15 = (4 << 24);  ///< Huffman length 15 Number of bits in the Huffman code HCODE15 minus 1.
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t LPUART1_BASE = 0x46002400;
    constexpr uint32_t SEC_LPUART1_BASE = 0x56002400;
    constexpr uint32_t USART1_BASE = 0x40013800;
    constexpr uint32_t SEC_USART1_BASE = 0x50013800;
    constexpr uint32_t USART2_BASE = 0x40004400;
    constexpr uint32_t SEC_USART2_BASE = 0x50004400;
    constexpr uint32_t USART3_BASE = 0x40004800;
    constexpr uint32_t SEC_USART3_BASE = 0x50004800;
    constexpr uint32_t UART4_BASE = 0x40004C00;
    constexpr uint32_t SEC_UART4_BASE = 0x50004C00;
    constexpr uint32_t UART5_BASE = 0x40005000;
    constexpr uint32_t SEC_UART5_BASE = 0x50005000;
    constexpr uint32_t USART6_BASE = 0x40006400;
    constexpr uint32_t SEC_USART6_BASE = 0x50006400;

    /// USART Register structure
    struct Registers {
        volatile uint32_t CR1_enabled;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR1_disabled;  ///< Offset: 0x00 - Control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - Control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - Control register 3
        volatile uint32_t BRR;  ///< Offset: 0x0C - Baud rate register
        volatile uint32_t RQR;  ///< Offset: 0x18 - Request register
        volatile uint32_t ISR_enabled;  ///< Offset: 0x1C - Interrupt and status register
        volatile uint32_t ISR_disabled;  ///< Offset: 0x1C - Interrupt and status register
        volatile uint32_t ICR;  ///< Offset: 0x20 - Interrupt flag clear register
        volatile uint32_t RDR;  ///< Offset: 0x24 - Receive data register
        volatile uint32_t TDR;  ///< Offset: 0x28 - Transmit data register
        volatile uint32_t PRESC;  ///< Offset: 0x2C - prescaler register
        volatile uint32_t AUTOCR;  ///< Offset: 0x30 - Autonomous mode control register
    };

    /// Peripheral instances
    inline Registers* LPUART1 = reinterpret_cast<Registers*>(LPUART1_BASE);
    inline Registers* SEC_LPUART1 = reinterpret_cast<Registers*>(SEC_LPUART1_BASE);
    inline Registers* USART1 = reinterpret_cast<Registers*>(USART1_BASE);
    inline Registers* SEC_USART1 = reinterpret_cast<Registers*>(SEC_USART1_BASE);
    inline Registers* USART2 = reinterpret_cast<Registers*>(USART2_BASE);
    inline Registers* SEC_USART2 = reinterpret_cast<Registers*>(SEC_USART2_BASE);
    inline Registers* USART3 = reinterpret_cast<Registers*>(USART3_BASE);
    inline Registers* SEC_USART3 = reinterpret_cast<Registers*>(SEC_USART3_BASE);
    inline Registers* UART4 = reinterpret_cast<Registers*>(UART4_BASE);
    inline Registers* SEC_UART4 = reinterpret_cast<Registers*>(SEC_UART4_BASE);
    inline Registers* UART5 = reinterpret_cast<Registers*>(UART5_BASE);
    inline Registers* SEC_UART5 = reinterpret_cast<Registers*>(SEC_UART5_BASE);
    inline Registers* USART6 = reinterpret_cast<Registers*>(USART6_BASE);
    inline Registers* SEC_USART6 = reinterpret_cast<Registers*>(SEC_USART6_BASE);

    // Bit definitions
    /// CR1_enabled Register bits
    namespace cr1_enabled_bits {
        constexpr uint32_t RXFFIE = (1U << 31);  ///< RXFFIE
        constexpr uint32_t TXFEIE = (1U << 30);  ///< TXFEIE
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFOEN
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXFNFIE = (1U << 7);  ///< TXFIFO not full interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXFNEIE = (1U << 5);  ///< RXFNEIE
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR1_disabled Register bits
    namespace cr1_disabled_bits {
        constexpr uint32_t FIFOEN = (1U << 29);  ///< FIFOEN
        constexpr uint32_t M1 = (1U << 28);  ///< Word length
        constexpr uint32_t DEAT = (5 << 21);  ///< DEAT
        constexpr uint32_t DEDT = (5 << 16);  ///< DEDT
        constexpr uint32_t CMIE = (1U << 14);  ///< Character match interrupt enable
        constexpr uint32_t MME = (1U << 13);  ///< Mute mode enable
        constexpr uint32_t M0 = (1U << 12);  ///< Word length
        constexpr uint32_t WAKE = (1U << 11);  ///< Receiver wakeup method
        constexpr uint32_t PCE = (1U << 10);  ///< Parity control enable
        constexpr uint32_t PS = (1U << 9);  ///< Parity selection
        constexpr uint32_t PEIE = (1U << 8);  ///< PE interrupt enable
        constexpr uint32_t TXFNFIE = (1U << 7);  ///< TXFIFO not full interrupt enable
        constexpr uint32_t TCIE = (1U << 6);  ///< Transmission complete interrupt enable
        constexpr uint32_t RXFNEIE = (1U << 5);  ///< RXFNEIE
        constexpr uint32_t IDLEIE = (1U << 4);  ///< IDLE interrupt enable
        constexpr uint32_t TE = (1U << 3);  ///< Transmitter enable
        constexpr uint32_t RE = (1U << 2);  ///< Receiver enable
        constexpr uint32_t UESM = (1U << 1);  ///< USART enable in Stop mode
        constexpr uint32_t UE = (1U << 0);  ///< USART enable
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t ADD = (8 << 24);  ///< Address of the LPUART node
        constexpr uint32_t MSBFIRST = (1U << 19);  ///< Most significant bit first
        constexpr uint32_t DATAINV = (1U << 18);  ///< Binary data inversion
        constexpr uint32_t TXINV = (1U << 17);  ///< TX pin active level inversion
        constexpr uint32_t RXINV = (1U << 16);  ///< RX pin active level inversion
        constexpr uint32_t SWAP = (1U << 15);  ///< Swap TX/RX pins
        constexpr uint32_t STOP = (2 << 12);  ///< STOP bits
        constexpr uint32_t ADDM7 = (1U << 4);  ///< 7-bit Address Detection/4-bit Address Detection
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t TXFTCFG = (3 << 29);  ///< TXFTCFG
        constexpr uint32_t RXFTIE = (1U << 28);  ///< RXFTIE
        constexpr uint32_t RXFTCFG = (3 << 25);  ///< RXFTCFG
        constexpr uint32_t TXFTIE = (1U << 23);  ///< TXFTIE
        constexpr uint32_t DEP = (1U << 15);  ///< Driver enable polarity selection
        constexpr uint32_t DEM = (1U << 14);  ///< Driver enable mode
        constexpr uint32_t DDRE = (1U << 13);  ///< DMA Disable on Reception Error
        constexpr uint32_t OVRDIS = (1U << 12);  ///< Overrun Disable
        constexpr uint32_t CTSIE = (1U << 10);  ///< CTS interrupt enable
        constexpr uint32_t CTSE = (1U << 9);  ///< CTS enable
        constexpr uint32_t RTSE = (1U << 8);  ///< RTS enable
        constexpr uint32_t DMAT = (1U << 7);  ///< DMA enable transmitter
        constexpr uint32_t DMAR = (1U << 6);  ///< DMA enable receiver
        constexpr uint32_t HDSEL = (1U << 3);  ///< Half-duplex selection
        constexpr uint32_t EIE = (1U << 0);  ///< Error interrupt enable
    }

    /// BRR Register bits
    namespace brr_bits {
        constexpr uint32_t BRR = (20 << 0);  ///< BRR
    }

    /// RQR Register bits
    namespace rqr_bits {
        constexpr uint32_t TXFRQ = (1U << 4);  ///< TXFRQ
        constexpr uint32_t RXFRQ = (1U << 3);  ///< Receive data flush request
        constexpr uint32_t MMRQ = (1U << 2);  ///< Mute mode request
        constexpr uint32_t SBKRQ = (1U << 1);  ///< Send break request
    }

    /// ISR_enabled Register bits
    namespace isr_enabled_bits {
        constexpr uint32_t TXFT = (1U << 27);  ///< TXFT
        constexpr uint32_t RXFT = (1U << 26);  ///< RXFT
        constexpr uint32_t RXFF = (1U << 24);  ///< RXFF
        constexpr uint32_t TXFF = (1U << 23);  ///< TXFF
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t TXFNF = (1U << 7);  ///< TXFNF
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXFNE = (1U << 5);  ///< RXFNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NE = (1U << 2);  ///< NE
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ISR_disabled Register bits
    namespace isr_disabled_bits {
        constexpr uint32_t REACK = (1U << 22);  ///< REACK
        constexpr uint32_t TEACK = (1U << 21);  ///< TEACK
        constexpr uint32_t RWU = (1U << 19);  ///< RWU
        constexpr uint32_t SBKF = (1U << 18);  ///< SBKF
        constexpr uint32_t CMF = (1U << 17);  ///< CMF
        constexpr uint32_t BUSY = (1U << 16);  ///< BUSY
        constexpr uint32_t CTS = (1U << 10);  ///< CTS
        constexpr uint32_t CTSIF = (1U << 9);  ///< CTSIF
        constexpr uint32_t TXE = (1U << 7);  ///< TXE
        constexpr uint32_t TC = (1U << 6);  ///< TC
        constexpr uint32_t RXNE = (1U << 5);  ///< RXNE
        constexpr uint32_t IDLE = (1U << 4);  ///< IDLE
        constexpr uint32_t ORE = (1U << 3);  ///< ORE
        constexpr uint32_t NE = (1U << 2);  ///< NE
        constexpr uint32_t FE = (1U << 1);  ///< FE
        constexpr uint32_t PE = (1U << 0);  ///< PE
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t CMCF = (1U << 17);  ///< Character match clear flag
        constexpr uint32_t CTSCF = (1U << 9);  ///< CTS clear flag
        constexpr uint32_t TCCF = (1U << 6);  ///< Transmission complete clear flag
        constexpr uint32_t IDLECF = (1U << 4);  ///< Idle line detected clear flag
        constexpr uint32_t ORECF = (1U << 3);  ///< Overrun error clear flag
        constexpr uint32_t NECF = (1U << 2);  ///< Noise detected clear flag
        constexpr uint32_t FECF = (1U << 1);  ///< Framing error clear flag
        constexpr uint32_t PECF = (1U << 0);  ///< Parity error clear flag
    }

    /// RDR Register bits
    namespace rdr_bits {
        constexpr uint32_t RDR = (9 << 0);  ///< Receive data value
    }

    /// TDR Register bits
    namespace tdr_bits {
        constexpr uint32_t TDR = (9 << 0);  ///< Transmit data value
    }

    /// PRESC Register bits
    namespace presc_bits {
        constexpr uint32_t PRESCALER = (4 << 0);  ///< PRESCALER
    }

    /// AUTOCR Register bits
    namespace autocr_bits {
        constexpr uint32_t TDN = (16 << 0);  ///< TDN
        constexpr uint32_t TRIGPOL = (1U << 16);  ///< TRIGPOL
        constexpr uint32_t TRIGEN = (1U << 17);  ///< TRIGEN
        constexpr uint32_t IDLEDIS = (1U << 18);  ///< IDLEDIS
        constexpr uint32_t TRIGSEL = (4 << 19);  ///< TRIGSEL
    }

}

// ============================================================================
// LTDC Peripheral
// ============================================================================

namespace ltdc {
    /// Base addresses
    constexpr uint32_t LTDC_BASE = 0x40016800;

    /// LTDC Register structure
    struct Registers {
        volatile uint32_t LTDC_SSCR;  ///< Offset: 0x08 - LTDC synchronization size configuration register
        volatile uint32_t LTDC_BPCR;  ///< Offset: 0x0C - LTDC back porch configuration register
        volatile uint32_t LTDC_AWCR;  ///< Offset: 0x10 - LTDC active width configuration register
        volatile uint32_t LTDC_TWCR;  ///< Offset: 0x14 - LTDC total width configuration register
        volatile uint32_t LTDC_GCR;  ///< Offset: 0x18 - LTDC global control register
        volatile uint32_t LTDC_SRCR;  ///< Offset: 0x24 - LTDC shadow reload configuration register
        volatile uint32_t LTDC_BCCR;  ///< Offset: 0x2C - LTDC background color configuration register
        volatile uint32_t LTDC_IER;  ///< Offset: 0x34 - LTDC interrupt enable register
        volatile uint32_t LTDC_ISR;  ///< Offset: 0x38 - LTDC interrupt status register
        volatile uint32_t LTDC_ICR;  ///< Offset: 0x3C - clears the line interrupt flag
        volatile uint32_t LTDC_LIPCR;  ///< Offset: 0x40 - LTDC line interrupt position configuration register
        volatile uint32_t LTDC_CPSR;  ///< Offset: 0x44 - current Y position These bits return the current Y position.
        volatile uint32_t LTDC_CDSR;  ///< Offset: 0x48 - LTDC current display status register
        volatile uint32_t LTDC_L1CR;  ///< Offset: 0x84 - layer enable This bit is set and cleared by software.
        volatile uint32_t LTDC_L1WHPCR;  ///< Offset: 0x88 - LTDC layer 1 window horizontal position configuration register
        volatile uint32_t LTDC_L1WVPCR;  ///< Offset: 0x8C - LTDC layer 1 window vertical position configuration register
        volatile uint32_t LTDC_L1CKCR;  ///< Offset: 0x90 - LTDC layer 1 color keying configuration register
        volatile uint32_t LTDC_L1PFCR;  ///< Offset: 0x94 - LTDC layer 1 pixel format configuration register
        volatile uint32_t LTDC_L1CACR;  ///< Offset: 0x98 - LTDC layer 1 constant alpha configuration register
        volatile uint32_t LTDC_L1DCCR;  ///< Offset: 0x9C - LTDC layer 1 default color configuration register
        volatile uint32_t LTDC_L1BFCR;  ///< Offset: 0xA0 - LTDC layer 1 blending factors configuration register
        volatile uint32_t LTDC_L1CFBAR;  ///< Offset: 0xAC - LTDC layer 1 color frame buffer address register
        volatile uint32_t LTDC_L1CFBLR;  ///< Offset: 0xB0 - LTDC layer 1 color frame buffer length register
        volatile uint32_t LTDC_L1CFBLNR;  ///< Offset: 0xB4 - LTDC layer 1 color frame buffer line number register
        volatile uint32_t LTDC_L1CLUTWR;  ///< Offset: 0xC4 - LTDC layer 1 CLUT write register
        volatile uint32_t LTDC_L2CR;  ///< Offset: 0x104 - layer enable This bit is set and cleared by software.
        volatile uint32_t LTDC_L2WHPCR;  ///< Offset: 0x108 - LTDC layer 2 window horizontal position configuration register
        volatile uint32_t LTDC_L2WVPCR;  ///< Offset: 0x10C - LTDC layer 2 window vertical position configuration register
        volatile uint32_t LTDC_L2CKCR;  ///< Offset: 0x110 - LTDC layer 2 color keying configuration register
        volatile uint32_t LTDC_L2PFCR;  ///< Offset: 0x114 - LTDC layer 2 pixel format configuration register
        volatile uint32_t LTDC_L2CACR;  ///< Offset: 0x118 - LTDC layer 2 constant alpha configuration register
        volatile uint32_t LTDC_L2DCCR;  ///< Offset: 0x11C - LTDC layer 2 default color configuration register
        volatile uint32_t LTDC_L2BFCR;  ///< Offset: 0x120 - LTDC layer 2 blending factors configuration register
        volatile uint32_t LTDC_L2CFBAR;  ///< Offset: 0x12C - LTDC layer 2 color frame buffer address register
        volatile uint32_t LTDC_L2CFBLR;  ///< Offset: 0x130 - LTDC layer 2 color frame buffer length register
        volatile uint32_t LTDC_L2CFBLNR;  ///< Offset: 0x134 - LTDC layer 2 color frame buffer line number register
        volatile uint32_t LTDC_L2CLUTWR;  ///< Offset: 0x144 - LTDC layer 2 CLUT write register
    };

    /// Peripheral instances
    inline Registers* LTDC = reinterpret_cast<Registers*>(LTDC_BASE);

    // Bit definitions
    /// LTDC_SSCR Register bits
    namespace ltdc_sscr_bits {
        constexpr uint32_t VSH = (11 << 0);  ///< vertical synchronization height (in units of horizontal scan line) These bits define the vertical Synchronization height minus 1. It represents the number of horizontal synchronization lines.
        constexpr uint32_t HSW = (12 << 16);  ///< horizontal synchronization width (in units of pixel clock period) These bits define the number of Horizontal Synchronization pixel minus 1.
    }

    /// LTDC_BPCR Register bits
    namespace ltdc_bpcr_bits {
        constexpr uint32_t AVBP = (11 << 0);  ///< accumulated Vertical back porch (in units of horizontal scan line) These bits define the accumulated vertical back porch width that includes the vertical synchronization and vertical back porch lines minus 1. The vertical back porch is the number of horizontal scan lines at a start of frame to the start of the first active scan line of the next frame.
        constexpr uint32_t AHBP = (12 << 16);  ///< accumulated horizontal back porch (in units of pixel clock period) These bits define the accumulated horizontal back porch width that includes the horizontal synchronization and horizontal back porch pixels minus 1. The horizontal back porch is the period between horizontal synchronization going inactive and the start of the active display part of the next scan line.
    }

    /// LTDC_AWCR Register bits
    namespace ltdc_awcr_bits {
        constexpr uint32_t AAH = (11 << 0);  ///< accumulated active height (in units of horizontal scan line) These bits define the accumulated height which includes the vertical synchronization, vertical back porch and the active height lines minus 1. The active height is the number of active lines in the panel. Refer to device datasheet for maximum active height supported following maximum pixel clock.
        constexpr uint32_t AAW = (12 << 16);  ///< accumulated active width (in units of pixel clock period) These bits define the accumulated active width which includes the horizontal synchronization, horizontal back porch and active pixels minus 1. The active width is the number of pixels in active display area of the panel scan line. Refer to device datasheet for maximum active width supported following maximum pixel clock.
    }

    /// LTDC_TWCR Register bits
    namespace ltdc_twcr_bits {
        constexpr uint32_t TOTALH = (11 << 0);  ///< total height (in units of horizontal scan line) These bits defines the accumulated height which includes the vertical synchronization, vertical back porch, the active height and vertical front porch height lines minus 1.
        constexpr uint32_t TOTALW = (12 << 16);  ///< total width (in units of pixel clock period) These bits defines the accumulated total width which includes the horizontal synchronization, horizontal back porch, active width and horizontal front porch pixels minus 1.
    }

    /// LTDC_GCR Register bits
    namespace ltdc_gcr_bits {
        constexpr uint32_t LTDCEN = (1U << 0);  ///< LCD-TFT controller enable This bit is set and cleared by software.
        constexpr uint32_t DBW = (3 << 4);  ///< dither blue width These bits return the dither blue bits.
        constexpr uint32_t DGW = (3 << 8);  ///< dither green width These bits return the dither green bits.
        constexpr uint32_t DRW = (3 << 12);  ///< dither red width These bits return the Dither Red Bits.
        constexpr uint32_t DEN = (1U << 16);  ///< dither enable This bit is set and cleared by software.
        constexpr uint32_t PCPOL = (1U << 28);  ///< pixel clock polarity This bit is set and cleared by software.
        constexpr uint32_t DEPOL = (1U << 29);  ///< not data enable polarity This bit is set and cleared by software.
        constexpr uint32_t VSPOL = (1U << 30);  ///< vertical synchronization polarity This bit is set and cleared by software.
        constexpr uint32_t HSPOL = (1U << 31);  ///< horizontal synchronization polarity This bit is set and cleared by software.
    }

    /// LTDC_SRCR Register bits
    namespace ltdc_srcr_bits {
        constexpr uint32_t IMR = (1U << 0);  ///< immediate reload This bit is set by software and cleared only by hardware after reload.
        constexpr uint32_t VBR = (1U << 1);  ///< vertical blanking reload This bit is set by software and cleared only by hardware after reload (it cannot be cleared through register write once it is set).
    }

    /// LTDC_BCCR Register bits
    namespace ltdc_bccr_bits {
        constexpr uint32_t BCBLUE = (8 << 0);  ///< background color blue value These bits configure the background blue value.
        constexpr uint32_t BCGREEN = (8 << 8);  ///< background color green value These bits configure the background green value.
        constexpr uint32_t BCRED = (8 << 16);  ///< background color red value These bits configure the background red value.
    }

    /// LTDC_IER Register bits
    namespace ltdc_ier_bits {
        constexpr uint32_t LIE = (1U << 0);  ///< line interrupt enable This bit is set and cleared by software.
        constexpr uint32_t FUIE = (1U << 1);  ///< FIFO underrun interrupt enable This bit is set and cleared by software.
        constexpr uint32_t TERRIE = (1U << 2);  ///< transfer error interrupt enable This bit is set and cleared by software.
        constexpr uint32_t RRIE = (1U << 3);  ///< register reload interrupt enable This bit is set and cleared by software.
    }

    /// LTDC_ISR Register bits
    namespace ltdc_isr_bits {
        constexpr uint32_t LIF = (1U << 0);  ///< line interrupt flag
        constexpr uint32_t FUIF = (1U << 1);  ///< FIFO underrun interrupt flag
        constexpr uint32_t TERRIF = (1U << 2);  ///< transfer error interrupt flag
        constexpr uint32_t RRIF = (1U << 3);  ///< register reload interrupt flag
    }

    /// LTDC_ICR Register bits
    namespace ltdc_icr_bits {
        constexpr uint32_t CLIF = (1U << 0);  ///< clears the line interrupt flag
        constexpr uint32_t CFUIF = (1U << 1);  ///< clears the FIFO underrun interrupt flag
        constexpr uint32_t CTERRIF = (1U << 2);  ///< clears the transfer error interrupt flag
        constexpr uint32_t CRRIF = (1U << 3);  ///< clears register reload interrupt flag
    }

    /// LTDC_LIPCR Register bits
    namespace ltdc_lipcr_bits {
        constexpr uint32_t LIPOS = (11 << 0);  ///< line interrupt position These bits configure the line interrupt position.
    }

    /// LTDC_CPSR Register bits
    namespace ltdc_cpsr_bits {
        constexpr uint32_t CYPOS = (16 << 0);  ///< current Y position These bits return the current Y position.
        constexpr uint32_t CXPOS = (16 << 16);  ///< current X position These bits return the current X position.
    }

    /// LTDC_CDSR Register bits
    namespace ltdc_cdsr_bits {
        constexpr uint32_t VDES = (1U << 0);  ///< vertical data enable display status
        constexpr uint32_t HDES = (1U << 1);  ///< horizontal data enable display status
        constexpr uint32_t VSYNCS = (1U << 2);  ///< vertical synchronization display status
        constexpr uint32_t HSYNCS = (1U << 3);  ///< horizontal synchronization display status
    }

    /// LTDC_L1CR Register bits
    namespace ltdc_l1cr_bits {
        constexpr uint32_t LEN = (1U << 0);  ///< layer enable This bit is set and cleared by software.
        constexpr uint32_t COLKEN = (1U << 1);  ///< color keying enable This bit is set and cleared by software.
        constexpr uint32_t CLUTEN = (1U << 4);  ///< color look-up table enable This bit is set and cleared by software. The CLUT is only meaningful for L8, AL44 and AL88 pixel format. Refer to table (CLUT)
    }

    /// LTDC_L1WHPCR Register bits
    namespace ltdc_l1whpcr_bits {
        constexpr uint32_t WHSTPOS = (12 << 0);  ///< window horizontal start position These bits configure the first visible pixel of a line of the layer window. WHSTPOS[11:0] must be ≤ AAW[11:0] bits (programmed in LTDC_AWCR register).
        constexpr uint32_t WHSPPOS = (12 << 16);  ///< window horizontal stop position These bits configure the last visible pixel of a line of the layer window. WHSPPOS[11:0] must be ≥ AHBP[11:0] bits + 1 (programmed in LTDC_BPCR register).
    }

    /// LTDC_L1WVPCR Register bits
    namespace ltdc_l1wvpcr_bits {
        constexpr uint32_t WVSTPOS = (11 << 0);  ///< window vertical start position These bits configure the first visible line of the layer window. WVSTPOS[10:0] must be ≤ AAH[10:0] bits (programmed in LTDC_AWCR register).
        constexpr uint32_t WVSPPOS = (11 << 16);  ///< window vertical stop position These bits configure the last visible line of the layer window. WVSPPOS[10:0] must be ≥ AVBP[10:0] bits + 1 (programmed in LTDC_BPCR register).
    }

    /// LTDC_L1CKCR Register bits
    namespace ltdc_l1ckcr_bits {
        constexpr uint32_t CKBLUE = (8 << 0);  ///< color key blue value
        constexpr uint32_t CKGREEN = (8 << 8);  ///< color key green value
        constexpr uint32_t CKRED = (8 << 16);  ///< color key red value
    }

    /// LTDC_L1PFCR Register bits
    namespace ltdc_l1pfcr_bits {
        constexpr uint32_t PF = (3 << 0);  ///< pixel format These bits configure the pixel format
    }

    /// LTDC_L1CACR Register bits
    namespace ltdc_l1cacr_bits {
        constexpr uint32_t CONSTA = (8 << 0);  ///< constant alpha These bits configure the constant alpha used for blending. The constant alpha is divided by 255 by hardware. Example: if the programmed constant alpha is 0xFF, the constant alpha value is 255 / 255 = 1.
    }

    /// LTDC_L1DCCR Register bits
    namespace ltdc_l1dccr_bits {
        constexpr uint32_t DCBLUE = (8 << 0);  ///< default color blue These bits configure the default blue value.
        constexpr uint32_t DCGREEN = (8 << 8);  ///< default color green These bits configure the default green value.
        constexpr uint32_t DCRED = (8 << 16);  ///< default color red These bits configure the default red value.
        constexpr uint32_t DCALPHA = (8 << 24);  ///< default color alpha These bits configure the default alpha value.
    }

    /// LTDC_L1BFCR Register bits
    namespace ltdc_l1bfcr_bits {
        constexpr uint32_t BF2 = (3 << 0);  ///< blending factor 2 These bits select the blending factor F2
        constexpr uint32_t BF1 = (3 << 8);  ///< blending factor 1 These bits select the blending factor F1.
    }

    /// LTDC_L1CFBAR Register bits
    namespace ltdc_l1cfbar_bits {
        constexpr uint32_t CFBADD = (32 << 0);  ///< color frame buffer start address These bits define the color frame buffer start address.
    }

    /// LTDC_L1CFBLR Register bits
    namespace ltdc_l1cfblr_bits {
        constexpr uint32_t CFBLL = (13 << 0);  ///< color frame buffer line length These bits define the length of one line of pixels in bytes + 3. The line length is computed as follows: active high width *  number of bytes per pixel + 3.
        constexpr uint32_t CFBP = (13 << 16);  ///< color frame buffer pitch in bytes These bits define the pitch that is the increment from the start of one line of pixels to the start of the next line in bytes.
    }

    /// LTDC_L1CFBLNR Register bits
    namespace ltdc_l1cfblnr_bits {
        constexpr uint32_t CFBLNBR = (11 << 0);  ///< frame buffer line number These bits define the number of lines in the frame buffer that corresponds to the active high width.
    }

    /// LTDC_L1CLUTWR Register bits
    namespace ltdc_l1clutwr_bits {
        constexpr uint32_t BLUE = (8 << 0);  ///< blue value These bits configure the blue value.
        constexpr uint32_t GREEN = (8 << 8);  ///< green value These bits configure the green value.
        constexpr uint32_t RED = (8 << 16);  ///< red value These bits configure the red value.
        constexpr uint32_t CLUTADD = (8 << 24);  ///< CLUT address These bits configure the CLUT address (color position within the CLUT) of each RGB value.
    }

    /// LTDC_L2CR Register bits
    namespace ltdc_l2cr_bits {
        constexpr uint32_t LEN = (1U << 0);  ///< layer enable This bit is set and cleared by software.
        constexpr uint32_t COLKEN = (1U << 1);  ///< color keying enable This bit is set and cleared by software.
        constexpr uint32_t CLUTEN = (1U << 4);  ///< color look-up table enable This bit is set and cleared by software. The CLUT is only meaningful for L8, AL44 and AL88 pixel format. Refer to table (CLUT)
    }

    /// LTDC_L2WHPCR Register bits
    namespace ltdc_l2whpcr_bits {
        constexpr uint32_t WHSTPOS = (12 << 0);  ///< window horizontal start position These bits configure the first visible pixel of a line of the layer window. WHSTPOS[11:0] must be ≤ AAW[11:0] bits (programmed in LTDC_AWCR register).
        constexpr uint32_t WHSPPOS = (12 << 16);  ///< window horizontal stop position These bits configure the last visible pixel of a line of the layer window. WHSPPOS[11:0] must be ≥ AHBP[11:0] bits + 1 (programmed in LTDC_BPCR register).
    }

    /// LTDC_L2WVPCR Register bits
    namespace ltdc_l2wvpcr_bits {
        constexpr uint32_t WVSTPOS = (11 << 0);  ///< window vertical start position These bits configure the first visible line of the layer window. WVSTPOS[10:0] must be ≤ AAH[10:0] bits (programmed in LTDC_AWCR register).
        constexpr uint32_t WVSPPOS = (11 << 16);  ///< window vertical stop position These bits configure the last visible line of the layer window. WVSPPOS[10:0] must be ≥ AVBP[10:0] bits + 1 (programmed in LTDC_BPCR register).
    }

    /// LTDC_L2CKCR Register bits
    namespace ltdc_l2ckcr_bits {
        constexpr uint32_t CKBLUE = (8 << 0);  ///< color key blue value
        constexpr uint32_t CKGREEN = (8 << 8);  ///< color key green value
        constexpr uint32_t CKRED = (8 << 16);  ///< color key red value
    }

    /// LTDC_L2PFCR Register bits
    namespace ltdc_l2pfcr_bits {
        constexpr uint32_t PF = (3 << 0);  ///< pixel format These bits configure the pixel format
    }

    /// LTDC_L2CACR Register bits
    namespace ltdc_l2cacr_bits {
        constexpr uint32_t CONSTA = (8 << 0);  ///< constant alpha These bits configure the constant alpha used for blending. The constant alpha is divided by 255 by hardware. Example: if the programmed constant alpha is 0xFF, the constant alpha value is 255 / 255 = 1.
    }

    /// LTDC_L2DCCR Register bits
    namespace ltdc_l2dccr_bits {
        constexpr uint32_t DCBLUE = (8 << 0);  ///< default color blue These bits configure the default blue value.
        constexpr uint32_t DCGREEN = (8 << 8);  ///< default color green These bits configure the default green value.
        constexpr uint32_t DCRED = (8 << 16);  ///< default color red These bits configure the default red value.
        constexpr uint32_t DCALPHA = (8 << 24);  ///< default color alpha These bits configure the default alpha value.
    }

    /// LTDC_L2BFCR Register bits
    namespace ltdc_l2bfcr_bits {
        constexpr uint32_t BF2 = (3 << 0);  ///< blending factor 2 These bits select the blending factor F2
        constexpr uint32_t BF1 = (3 << 8);  ///< blending factor 1 These bits select the blending factor F1.
    }

    /// LTDC_L2CFBAR Register bits
    namespace ltdc_l2cfbar_bits {
        constexpr uint32_t CFBADD = (32 << 0);  ///< color frame buffer start address These bits define the color frame buffer start address.
    }

    /// LTDC_L2CFBLR Register bits
    namespace ltdc_l2cfblr_bits {
        constexpr uint32_t CFBLL = (13 << 0);  ///< color frame buffer line length These bits define the length of one line of pixels in bytes + 3. The line length is computed as follows: active high width *  number of bytes per pixel + 3.
        constexpr uint32_t CFBP = (13 << 16);  ///< color frame buffer pitch in bytes These bits define the pitch that is the increment from the start of one line of pixels to the start of the next line in bytes.
    }

    /// LTDC_L2CFBLNR Register bits
    namespace ltdc_l2cfblnr_bits {
        constexpr uint32_t CFBLNBR = (11 << 0);  ///< frame buffer line number These bits define the number of lines in the frame buffer that corresponds to the active high width.
    }

    /// LTDC_L2CLUTWR Register bits
    namespace ltdc_l2clutwr_bits {
        constexpr uint32_t BLUE = (8 << 0);  ///< blue value These bits configure the blue value.
        constexpr uint32_t GREEN = (8 << 8);  ///< green value These bits configure the green value.
        constexpr uint32_t RED = (8 << 16);  ///< red value These bits configure the red value.
        constexpr uint32_t CLUTADD = (8 << 24);  ///< CLUT address These bits configure the CLUT address (color position within the CLUT) of each RGB value.
    }

}

// ============================================================================
// MDF1 Peripheral
// ============================================================================

namespace mdf1 {
    /// Base addresses
    constexpr uint32_t MDF1_BASE = 0x40025000;

    /// MDF1 Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - MDF global control register
        volatile uint32_t CKGCR;  ///< Offset: 0x04 - MDF clock generator control register
        volatile uint32_t MDF_SITF0CR;  ///< Offset: 0x80 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF1CR;  ///< Offset: 0x100 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF2CR;  ///< Offset: 0x180 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF3CR;  ///< Offset: 0x200 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF4CR;  ///< Offset: 0x280 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_SITF5CR;  ///< Offset: 0x300 - This register is used to control the serial interfaces (SITFx).
        volatile uint32_t MDF_BSMX0CR;  ///< Offset: 0x84 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX1CR;  ///< Offset: 0x104 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX2CR;  ///< Offset: 0x184 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX3CR;  ///< Offset: 0x204 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX4CR;  ///< Offset: 0x284 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_BSMX5CR;  ///< Offset: 0x304 - This register is used to select the bitstream to be...
        volatile uint32_t MDF_DFLT0CR;  ///< Offset: 0x88 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT1CR;  ///< Offset: 0x108 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT2CR;  ///< Offset: 0x188 - This register is used to control the digital filter 2.
        volatile uint32_t MDF_DFLT3CR;  ///< Offset: 0x208 - This register is used to control the digital filter 3.
        volatile uint32_t MDF_DFLT4CR;  ///< Offset: 0x288 - This register is used to control the digital filter 4.
        volatile uint32_t MDF_DFLT5CR;  ///< Offset: 0x308 - This register is used to control the digital filter x.
        volatile uint32_t MDF_DFLT0CICR;  ///< Offset: 0x8C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT1CICR;  ///< Offset: 0x10C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT2CICR;  ///< Offset: 0x18C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT3CICR;  ///< Offset: 0x20C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT4CICR;  ///< Offset: 0x28C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT5CICR;  ///< Offset: 0x30C - This register is used to control the main CIC filter.
        volatile uint32_t MDF_DFLT0RSFR;  ///< Offset: 0x90 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT1RSFR;  ///< Offset: 0x110 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT2RSFR;  ///< Offset: 0x190 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT3RSFR;  ///< Offset: 0x210 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT4RSFR;  ///< Offset: 0x290 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT5RSFR;  ///< Offset: 0x310 - This register is used to control the reshape and HPF filters.
        volatile uint32_t MDF_DFLT0INTR;  ///< Offset: 0x94 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT1INTR;  ///< Offset: 0x114 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT2INTR;  ///< Offset: 0x194 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT3INTR;  ///< Offset: 0x214 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT4INTR;  ///< Offset: 0x294 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_DFLT5INTR;  ///< Offset: 0x314 - This register is used to the integrator (INT) settings.
        volatile uint32_t MDF_OLD0CR;  ///< Offset: 0x98 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD1CR;  ///< Offset: 0x118 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD2CR;  ///< Offset: 0x198 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD3CR;  ///< Offset: 0x218 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD4CR;  ///< Offset: 0x298 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD5CR;  ///< Offset: 0x318 - This register is used to configure the Out-of Limit...
        volatile uint32_t MDF_OLD0THLR;  ///< Offset: 0x9C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD1THLR;  ///< Offset: 0x11C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD2THLR;  ///< Offset: 0x19C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD3THLR;  ///< Offset: 0x21C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD4THLR;  ///< Offset: 0x29C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD5THLR;  ///< Offset: 0x31C - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD0THHR;  ///< Offset: 0xA0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD1THHR;  ///< Offset: 0x120 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD2THHR;  ///< Offset: 0x1A0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD3THHR;  ///< Offset: 0x220 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD4THHR;  ///< Offset: 0x2A0 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_OLD5THHR;  ///< Offset: 0x320 - This register is used for the adjustment of the Out-off...
        volatile uint32_t MDF_DLY0CR;  ///< Offset: 0xA4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY1CR;  ///< Offset: 0x124 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY2CR;  ///< Offset: 0x1A4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY3CR;  ///< Offset: 0x224 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY4CR;  ///< Offset: 0x2A4 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DLY5CR;  ///< Offset: 0x324 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD0CR;  ///< Offset: 0xA8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD1CR;  ///< Offset: 0x128 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD2CR;  ///< Offset: 0x1A8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD3CR;  ///< Offset: 0x228 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD4CR;  ///< Offset: 0x2A8 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_SCD5CR;  ///< Offset: 0x328 - This register is used for the adjustment stream delays.
        volatile uint32_t MDF_DFLT0IER;  ///< Offset: 0xAC - This register is used for allowing or not the events to...
        volatile uint32_t MDF_DFLT0ISR;  ///< Offset: 0xB0 - MDF DFLT0 interrupt status register 0
        volatile uint32_t MDF_DFLT1IER;  ///< Offset: 0x12C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT2IER;  ///< Offset: 0x1AC - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT3IER;  ///< Offset: 0x22C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT4IER;  ///< Offset: 0x2AC - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT5IER;  ///< Offset: 0x32C - MDF DFLTx interrupt enable register x
        volatile uint32_t MDF_DFLT1ISR;  ///< Offset: 0x130 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT2ISR;  ///< Offset: 0x1B0 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT3ISR;  ///< Offset: 0x230 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT4ISR;  ///< Offset: 0x2B0 - This register contains the status flags for each digital...
        volatile uint32_t MDF_DFLT5ISR;  ///< Offset: 0x330 - This register contains the status flags for each digital...
        volatile uint32_t MDF_OEC0CR;  ///< Offset: 0xB4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC1CR;  ///< Offset: 0x134 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC2CR;  ///< Offset: 0x1B4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC3CR;  ///< Offset: 0x234 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC4CR;  ///< Offset: 0x2B4 - This register contains the offset compensation value.
        volatile uint32_t MDF_OEC5CR;  ///< Offset: 0x334 - This register contains the offset compensation value.
        volatile uint32_t MDF_SNPS0DR;  ///< Offset: 0xEC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS1DR;  ///< Offset: 0x16C - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS2DR;  ///< Offset: 0x1EC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS3DR;  ///< Offset: 0x26C - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS4DR;  ///< Offset: 0x2EC - This register is used to read the data processed by each...
        volatile uint32_t MDF_SNPS5DR;  ///< Offset: 0x36C - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT0DR;  ///< Offset: 0xF0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT1DR;  ///< Offset: 0x170 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT2DR;  ///< Offset: 0x1F0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT3DR;  ///< Offset: 0x270 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT4DR;  ///< Offset: 0x2F0 - This register is used to read the data processed by each...
        volatile uint32_t MDF_DFLT5DR;  ///< Offset: 0x370 - This register is used to read the data processed by each...
    };

    /// Peripheral instances
    inline Registers* MDF1 = reinterpret_cast<Registers*>(MDF1_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t TRGO = (1U << 0);  ///< TRGO
        constexpr uint32_t ILVNB = (4 << 4);  ///< ILVNB
    }

    /// CKGCR Register bits
    namespace ckgcr_bits {
        constexpr uint32_t CKGDEN = (1U << 0);  ///< CKGDEN
        constexpr uint32_t CCK0EN = (1U << 1);  ///< CCK0EN
        constexpr uint32_t CCK1EN = (1U << 2);  ///< CCK1EN
        constexpr uint32_t CKGMOD = (1U << 4);  ///< CKGMOD
        constexpr uint32_t CCK0DIR = (1U << 5);  ///< CCK0DIR
        constexpr uint32_t CCK1DIR = (1U << 6);  ///< CCK1DIR
        constexpr uint32_t TRGSENS = (1U << 8);  ///< TRGSENS
        constexpr uint32_t TRGSRC = (4 << 12);  ///< TRGSRC
        constexpr uint32_t CCKDIV = (4 << 16);  ///< CCKDIV
        constexpr uint32_t PROCDIV = (7 << 24);  ///< PROCDIV
        constexpr uint32_t CKGACTIVE = (1U << 31);  ///< CKGACTIVE
    }

    /// MDF_SITF0CR Register bits
    namespace mdf_sitf0cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF1CR Register bits
    namespace mdf_sitf1cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag
    }

    /// MDF_SITF2CR Register bits
    namespace mdf_sitf2cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag
    }

    /// MDF_SITF3CR Register bits
    namespace mdf_sitf3cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF4CR Register bits
    namespace mdf_sitf4cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_SITF5CR Register bits
    namespace mdf_sitf5cr_bits {
        constexpr uint32_t SITFEN = (1U << 0);  ///< Serial interface enable Set and cleared by software. This bit is used to enable/disable the serial interface. - 0: Serial interface disabled - 1: Serial interface enabled
        constexpr uint32_t SCKSRC = (2 << 1);  ///< Serial clock source Set and cleared by software. This bit is used to select the clock source of the serial interface. - 00: Serial clock source is MDF_CCK0 - 01: Serial clock source is MDF_CCK1 1x: Serial clock source is MDF_CKIx, not allowed in LF_MASTER SPI mode This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFMOD = (2 << 4);  ///< Serial interface type Set and cleared by software. This field is used to defined the serial interface type. - 00: LF_MASTER (Low-Frequency MASTER) SPI mode - 01: Normal SPI mode - 10: Manchester mode: rising edge = logic 0, falling edge = logic 1 - 11: Manchester mode: rising edge = logic 1, falling edge = logic 0 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t STH = (5 << 8);  ///< Manchester Symbol threshold / SPI threshold Set and cleared by software. This field is used for Manchester mode, in order to define the expected symbol threshold levels. Please refer to Section : Manchester mode for details on computation. In addition this field is used to define the timeout value for the clock absence detection in Normal SPI mode. Values of STH[4:0] lower than 4 are invalid. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SITFACTIVE = (1U << 31);  ///< Serial interface Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the serial interface is effectively enabled (active) or not. The protected fields of this function can only be updated when the SITFACTIVE is set , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SITFEN and a transition on SITFACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The serial interface is not active, and can be configured if needed - 1: The serial interface is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX0CR Register bits
    namespace mdf_bsmx0cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX1CR Register bits
    namespace mdf_bsmx1cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX2CR Register bits
    namespace mdf_bsmx2cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to a . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX3CR Register bits
    namespace mdf_bsmx3cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to a . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to a in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX4CR Register bits
    namespace mdf_bsmx4cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_BSMX5CR Register bits
    namespace mdf_bsmx5cr_bits {
        constexpr uint32_t BSSEL = (5 << 0);  ///< Bitstream Selection Set and cleared by software. This field is used to select the bitstream to be processed for the digital filter x and for the SCDx. The size of this field depends on the number of DFLTx instantiated. If the BSSEL is selecting an input which is not instantiated, the MDF will select the valid stream bs[x]_F having the higher index number. - 00000: The bitstream bs[0]_R is provided to DFLTx and SCDx - 00001: The bitstream bs[0]_F is provided to DFLTx and SCDx - 00010: The bitstream bs[1]_R is provided to DFLTx and SCDx (if instantiated) - 00011: The bitstream bs[1]_F is provided to DFLTx and SCDx (if instantiated) ... - 11110: The bitstream bs[15]_R is provided to DFLTx and SCDx (if instantiated) - 11111: The bitstream bs[15]_F is provided to DFLTx and SCDx (if instantiated) This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BSMXACTIVE = (1U << 31);  ///< BSMX Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the BSMX is effectively enabled (active) or not. BSSEL[4:0] can only be updated when the BSMXACTIVE is set to . The BSMXACTIVE flag is a logical between OLDACTIVE, DFLTACTIVE, and SCDACTIVE flags. Both of them must be set to in order update BSSEL[4:0] field. - 0: The BSMX is not active, and can be configured if needed - 1: The BSMX is active, and protected fields cannot be configured.
    }

    /// MDF_DFLT0CR Register bits
    namespace mdf_dflt0cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT1CR Register bits
    namespace mdf_dflt1cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT2CR Register bits
    namespace mdf_dflt2cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT3CR Register bits
    namespace mdf_dflt3cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT4CR Register bits
    namespace mdf_dflt4cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in a interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT5CR Register bits
    namespace mdf_dflt5cr_bits {
        constexpr uint32_t DFLTEN = (1U << 0);  ///< Digital Filter Enable Set and cleared by software. This bit is used to control the start of acquisition of the corresponding digital filter path. The behavior of this bit depends on ACQMOD and external events. or the acquisition starts when the proper trigger event occurs if ACQMOD = 01x . The serial or parallel interface delivering the samples shall be enabled as well. - 0: The acquisition is stopped immediately - 1: The acquisition is immediately started if ACQMOD = 00x or 1xx ,
        constexpr uint32_t DMAEN = (1U << 1);  ///< DMA Requests Enable Set and cleared by software. This bit is used to control the generation of DMA request in order to transfer the processed samples into the memory. - 0: The DMA interface for the corresponding digital filter is disabled - 1: The DMA interface for the corresponding digital filter is enabled This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t FTH = (1U << 2);  ///< RXFIFO Threshold selection Set and cleared by software. This bit is used to select the RXFIFO threshold. This bit is not significant for RXFIFOs working in interleaved transfer mode. Refer to Section 1.4.13.4: Using the interleaved transfer mode for details. - 0: RXFIFO threshold event generated when the RXFIFO is not empty - 1: RXFIFO threshold event generated when the RXFIFO is half-full This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACQMOD = (3 << 4);  ///< Digital filter Trigger mode Set and cleared by software. This field is used to select the filter trigger mode. - 000: Asynchronous, continuous acquisition mode - 001: Asynchronous, single-shot acquisition mode - 010: Synchronous, continuous acquisition mode - 011: Synchronous, single-shot acquisition mode - 100: Window, continuous acquisition mode - 101: Synchronous, snapshot mode others: same a 000 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSENS = (1U << 8);  ///< Digital filter Trigger sensitivity selection Set and cleared by software. This field is used to select the trigger sensitivity of the external signals - 0: A rising edge event triggers the acquisition - 1: A falling edge even triggers the acquisition Note that when the trigger source is TRGO or OLDx event, TRGSENS value is not taken into account. When TRGO is selected, the sensitivity is forced to falling edge, when OLDx event is selected, the sensitivity is forced to rising edge. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t TRGSRC = (4 << 12);  ///< Digital filter Trigger signal selection, Set and cleared by software. This field is used to select which external signals is used as trigger for the corresponding filter. - 0000: TRGO is selected - 0001: OLDx event is selected - 0010: mdf_trg[0] is selected ... - 1111: mdf_trg[13] is selected This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SNPSFMT = (1U << 16);  ///< Snapshot data format Set and cleared by software. This field is used to select the data format for the snapshot mode. - 0: The integrator counter (INT_CNT) is not inserted into the MDF_SNPSxDR register, leaving a data resolution of 23 bits. - 1: The integrator counter (INT_CNT) is inserted at position [15:9] of MDF_SNPSxDR register, leaving a data resolution of 16 bits. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t NBDIS = (8 << 20);  ///< Number of samples to be discarded Set and cleared by software. This field is used to define the number of samples to be discarded every time the DFLTx is re-started. - 0: no sample discarded - 1: 1 sample discarded - 2: 2 samples discarded ... - 255: 255 samples discarded This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t DFLTRUN = (1U << 30);  ///< Digital filter Run Status Flag Set and cleared by hardware. This bit indicates if the digital filter is running or not. - 0: The digital filter is not running, and ready to accept a new trigger event - 1: The digital filter is running
        constexpr uint32_t DFLTACTIVE = (1U << 31);  ///< Digital filter Active Flag Set and cleared by hardware. This bit indicates if the digital filter is active: can be running or waiting for events. - 0: The digital filter is not active, and can be re-enabled again (via DFLTEN bit) if needed - 1: The digital filter is active
    }

    /// MDF_DFLT0CICR Register bits
    namespace mdf_dflt0cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT1CICR Register bits
    namespace mdf_dflt1cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT2CICR Register bits
    namespace mdf_dflt2cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT3CICR Register bits
    namespace mdf_dflt3cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT4CICR Register bits
    namespace mdf_dflt4cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT5CICR Register bits
    namespace mdf_dflt5cicr_bits {
        constexpr uint32_t DATSRC = (2 << 0);  ///< Source data for the digital filter Set and cleared by software. 0x: Select the stream coming from the BSMX - 10: Select the stream coming from the ADCITF1 - 11: Select the stream coming from the ADCITF2 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t CICMOD = (3 << 4);  ///< Select the CIC mode Set and cleared by software. This field allows the application to select the configuration and the order of the MCIC. When CICMOD[2:0] is equal to 0xx , the CIC is split into two filters: - The main CIC (MCIC) - The auxiliary CIC (ACIC), used for the out-off limit detector - 000: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in FastSinc filter - 001: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc1 filter - 010: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc2 filter - 011: The CIC is split into 2 filters, and the main CIC (MCIC) is configured in Sinc3 filter - 100: The CIC is configured in single sinc4 filter others: The CIC is configured in single sinc5 filter This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t MCICD = (9 << 8);  ///< CIC decimation ratio selection Set and cleared by software. This bit is used to allow the application to select the decimation ratio of the CIC. Decimation ratio smaller than 2 is not allowed. The decimation ratio is given by (CICDEC+1). - 0: Decimation ratio is 2 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 511: Decimation ratio is 512 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCALE = (6 << 20);  ///< Scaling factor selection Set and cleared by software. This field is used to allow the application to select the gain to be applied at CIC output. Please refer to Table 13: Possible gain values for details. If the application attempts to write a new gain value while the previous one is not yet applied, this new gain value is ignored. Reading back the SCALE[5:0] field will inform the application on the current gain value. - 100000: - 48.2 dB, or shift right by 8 bits (default value) - 100001: - 44.6 dB, - 100010: - 42.1 dB, or shift right by 7 bits - 100011: - 38.6 dB, ... - 101110: -6 dB, or shift right by 1 bit - 101111: -2.5 dB, - 000000: 0 dB - 000001: + 3.5 dB, - 000010: + 6 dB, or shift left by 1 bit ... - 011000: + 72 dB, or shift left by 12 bits
    }

    /// MDF_DFLT0RSFR Register bits
    namespace mdf_dflt0rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT1RSFR Register bits
    namespace mdf_dflt1rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT2RSFR Register bits
    namespace mdf_dflt2rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT3RSFR Register bits
    namespace mdf_dflt3rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT4RSFR Register bits
    namespace mdf_dflt4rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT5RSFR Register bits
    namespace mdf_dflt5rsfr_bits {
        constexpr uint32_t RSFLTBYP = (1U << 0);  ///< Reshaper filter bypass Set and cleared by software. This bit is used to bypass the reshape filter and its decimation block. - 0: The reshape filter is not bypassed (Default value) - 1: The reshape filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t RSFLTD = (1U << 4);  ///< Reshaper filter decimation ratio Set and cleared by software. This bit is used to select the decimation ratio for the reshape filter - 0: Decimation ratio is 4 (Default value) - 1: Decimation ratio is 1 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFBYP = (1U << 7);  ///< High-Pass Filter bypass Set and cleared by software. This bit is used to bypass the high-pass filter. - 0: The high pass filter is not bypassed (Default value) - 1: The high pass filter is bypassed This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t HPFC = (2 << 8);  ///< High-pass filter cut-off frequency Set and cleared by software. This field is used to select the cut-off frequency of the high-pass filter. FPCM represents the sampling frequency at HPF input. - 00: Cut-off frequency = 0.000625 x FPCM - 01: Cut-off frequency = 0.00125 x FPCM - 10: Cut-off frequency = 0.00250 x FPCM - 11: Cut-off frequency = 0.00950 x FPCM This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT0INTR Register bits
    namespace mdf_dflt0intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT1INTR Register bits
    namespace mdf_dflt1intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT2INTR Register bits
    namespace mdf_dflt2intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT3INTR Register bits
    namespace mdf_dflt3intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT4INTR Register bits
    namespace mdf_dflt4intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_DFLT5INTR Register bits
    namespace mdf_dflt5intr_bits {
        constexpr uint32_t INTDIV = (2 << 0);  ///< Integrator output division Set and cleared by software. This bit is used to rescale the signal at the integrator output in order keep the data width lower than 24 bits. - 00: The integrator data outputs are divided by 128 (Default value) - 01: The integrator data outputs are divided by 32 - 10: The integrator data outputs are divided by 4 - 11: The integrator data outputs are not divided This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t INTVAL = (7 << 4);  ///< Integration value selection Set and cleared by software. This field is used to select the integration value. - 0: The integration value is 1, meaning bypass mode (default after reset) - 1: The integration value is 2 - 2: The integration value is 3 ... - 127: The integration value is 128 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD0CR Register bits
    namespace mdf_old0cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD1CR Register bits
    namespace mdf_old1cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD2CR Register bits
    namespace mdf_old2cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD3CR Register bits
    namespace mdf_old3cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD4CR Register bits
    namespace mdf_old4cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD5CR Register bits
    namespace mdf_old5cr_bits {
        constexpr uint32_t OLDEN = (1U << 0);  ///< Over-Current Detector Enable Set and cleared by software. - 0: The OLD is disabled (Default value) - 1: The OLD is enabled, including the ACIC filter working in continuous mode.
        constexpr uint32_t THINB = (1U << 1);  ///< Threshold In band Set and cleared by software. - 0: The OLD generates an event if the signal is lower than OLDTHL OR higher than OLDTHH (Default value) - 1: The OLD generates an event if the signal is lower than OLDTHH AND higher than OLDTHL This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t BKOLD = (4 << 4);  ///< Break signal assignment for out-of limit detector Set and cleared by software. BKOLD[i] = 0: Break signal (mdf_break[i]) is not assigned to threshold event BKOLD[i] = 1: Break signal (mdf_break[i]) is assigned to threshold event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICN = (2 << 12);  ///< OLD CIC order selection Set and cleared by software. This field allows the application to select the type, and the order of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . - 00: FastSinc filter type - 01: Sinc1 filter type - 10: Sinc2 filter type - 11: Sinc3 filter type This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t ACICD = (5 << 17);  ///< OLD CIC decimation ratio selection Set and cleared by software. This field is used to allow the application to select the decimation ratio of the ACIC. This field is only taken into account by the MDF when CICMOD[2:0] = 0xx . The decimation ratio is given by (ACICD+1). - 0: Decimation ratio is 1 - 1: Decimation ratio is 2 - 2: Decimation ratio is 3 - 3: Decimation ratio is 4 ... - 31: Decimation ratio is 32 This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t OLDACTIVE = (1U << 31);  ///< OLD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the OLD is effectively enabled (active) or not. The protected fields and registers of this function can only be updated when the OLDACTIVE is set to , please refer to Section 1.4.15: Register protection for details. The delay between a transition on OLDEN and a transition on OLDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The OLD is not active, and can be configured if needed - 1: The OLD is active, and protected fields cannot be configured.
    }

    /// MDF_OLD0THLR Register bits
    namespace mdf_old0thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD1THLR Register bits
    namespace mdf_old1thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD2THLR Register bits
    namespace mdf_old2thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD3THLR Register bits
    namespace mdf_old3thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD4THLR Register bits
    namespace mdf_old4thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD5THLR Register bits
    namespace mdf_old5thlr_bits {
        constexpr uint32_t OLDTHL = (26 << 0);  ///< OLD Low Threshold Value Set and cleared by software. OLDTHL represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHL. This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
    }

    /// MDF_OLD0THHR Register bits
    namespace mdf_old0thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD1THHR Register bits
    namespace mdf_old1thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD2THHR Register bits
    namespace mdf_old2thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD3THHR Register bits
    namespace mdf_old3thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD4THHR Register bits
    namespace mdf_old4thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_OLD5THHR Register bits
    namespace mdf_old5thhr_bits {
        constexpr uint32_t OLDTHH = (26 << 0);  ///< OLD High Threshold Value Set and cleared by software. OLDTHH represents a 26-bit signed value. The real threshold compared to the signal provided by the filter is OLDTHH. This field can be write-protected, please refer to Section 1.4.15: Register protection for details
    }

    /// MDF_DLY0CR Register bits
    namespace mdf_dly0cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY1CR Register bits
    namespace mdf_dly1cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY2CR Register bits
    namespace mdf_dly2cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY3CR Register bits
    namespace mdf_dly3cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY4CR Register bits
    namespace mdf_dly4cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_DLY5CR Register bits
    namespace mdf_dly5cr_bits {
        constexpr uint32_t SKPDLY = (7 << 0);  ///< Delay to apply to a bitstream Set and cleared by software. Defines the number of input samples that will be skipped. Skipping is applied immediately after writing to this field, if SKPBF = 0 , and the corresponding bit DFLTEN = 1 . If SKPBF = 1 the value written into the register is ignored by the delay state machine. - 0: No input sample skipped, - 1: 1 input sample skipped, ... - 127: 127 input sample skipped,
        constexpr uint32_t SKPBF = (1U << 31);  ///< Skip Busy flag Set and cleared by hardware. Shall be used in order to control if the delay sequence is completed. - 0: Reading 0 means that the MDF is ready to accept a new value into SKPDLY[6:0]. - 1: Reading 1 means that last valid SKPDLY[6:0] is still under precessing.
    }

    /// MDF_SCD0CR Register bits
    namespace mdf_scd0cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD1CR Register bits
    namespace mdf_scd1cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD2CR Register bits
    namespace mdf_scd2cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD3CR Register bits
    namespace mdf_scd3cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD4CR Register bits
    namespace mdf_scd4cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_SCD5CR Register bits
    namespace mdf_scd5cr_bits {
        constexpr uint32_t SCDEN = (1U << 0);  ///< Short circuit detector enable Set and cleared by software. - 0: The short circuit detector is disabled, - 1: The short circuit detector is enabled,
        constexpr uint32_t BKSCD = (4 << 4);  ///< Break signal assignment for short circuit detector Set and cleared by software. BKSCD[i] = 0: Break signal (mdf_break[i]) is not assigned to this SCD event BKSCD[i] = 1: Break signal (mdf_break[i]) is assigned to this SCD event This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDT = (8 << 12);  ///< Short-circuit detector threshold Set and cleared by software. These bits are written by software to define the threshold counter for the short-circuit detector. If this value is reached, then a short-circuit detector event occurs on a given input stream. - 0: 2 consecutive 1 s or 0 s will generate an event, - 1: 2 consecutive 1 s or 0 s will generate an event - 2: 3 consecutive 1 s or 0 s will generate an event, ... - 255: 256 consecutive 1 s or 0 s will generate an event, This field can be write-protected, please refer to Section 1.4.15: Register protection for details.
        constexpr uint32_t SCDACTIVE = (1U << 31);  ///< SCD Active flag Set and cleared by hardware. This flag must be used by the application in order to check if the SCD is effectively enabled (active) or not. The protected fields of this function can only be updated when the SCDACTIVE is set to a a , please refer to Section 1.4.15: Register protection for details. The delay between a transition on SCDEN and a transition on SCDACTIVE is 2 periods of AHB clock and 2 periods of mdf_proc_ck. - 0: The SCD is not active, and can be configured if needed - 1: The SCD is active, and protected fields cannot be configured.
    }

    /// MDF_DFLT0IER Register bits
    namespace mdf_dflt0ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT0ISR Register bits
    namespace mdf_dflt0isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< FTHF
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on , writing 0 has no effect. - 1: Reading 1 means that a new data is available on , writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing this bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was higher than OLDTHL when the last OLD event occurred. - 1: The signal was lower than OLDTHL when the last OLD event occurred.
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing this bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH when the last OLD event occurred. - 1: The signal was higher than OLDTHH when the last OLD event occurred.
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT1IER Register bits
    namespace mdf_dflt1ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT2IER Register bits
    namespace mdf_dflt2ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT3IER Register bits
    namespace mdf_dflt3ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT4IER Register bits
    namespace mdf_dflt4ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT5IER Register bits
    namespace mdf_dflt5ier_bits {
        constexpr uint32_t FTHIE = (1U << 0);  ///< RXFIFO threshold interrupt enable Set and cleared by software. - 0: RXFIFO threshold interrupt disabled - 1: RXFIFO threshold interrupt enabled
        constexpr uint32_t DOVRIE = (1U << 1);  ///< Data overflow interrupt enable Set and cleared by software. - 0: Data overflow interrupt disabled - 1: Data overflow interrupt enabled
        constexpr uint32_t SSDRIE = (1U << 2);  ///< Snapshot data ready interrupt enable Set and cleared by software. - 0: Snapshot data ready interrupt disabled - 1: Snapshot data ready interrupt enabled
        constexpr uint32_t OLDIE = (1U << 4);  ///< Out-of Limit interrupt enable Set and cleared by software. - 0: OLD event interrupt disabled - 1: OLD event interrupt enabled
        constexpr uint32_t SSOVRIE = (1U << 7);  ///< Snapshot overrun interrupt enable Set and cleared by software. - 0: Snapshot overrun interrupt disabled - 1: Snapshot overrun interrupt enabled
        constexpr uint32_t SCDIE = (1U << 8);  ///< Short-Circuit Detector interrupt enable Set and cleared by software. - 0: SCD interrupt disabled - 1: SCD interrupt enabled
        constexpr uint32_t SATIE = (1U << 9);  ///< Saturation detection interrupt enable Set and cleared by software. - 0: Saturation interrupt disabled - 1: Saturation interrupt enabled
        constexpr uint32_t CKABIE = (1U << 10);  ///< Clock absence detection interrupt enable Set and cleared by software. - 0: Clock absence interrupt disabled - 1: Clock absence interrupt enabled
        constexpr uint32_t RFOVRIE = (1U << 11);  ///< Reshape Filter Overrun interrupt enable Set and cleared by software. - 0: Reshape filter overrun interrupt disabled - 1: Reshape filter overrun interrupt enabled
    }

    /// MDF_DFLT1ISR Register bits
    namespace mdf_dflt1isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT2ISR Register bits
    namespace mdf_dflt2isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT3ISR Register bits
    namespace mdf_dflt3isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT4ISR Register bits
    namespace mdf_dflt4isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_DFLT5ISR Register bits
    namespace mdf_dflt5isr_bits {
        constexpr uint32_t FTHF = (1U << 0);  ///< RXFIFO threshold flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that the RXFIFO threshold is not reached, writing 0 has no effect. - 1: Reading 1 means that the RXFIFO reached the threshold, writing 1 clears this flag.
        constexpr uint32_t DOVRF = (1U << 1);  ///< Data overflow flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no overflow is detected, writing 0 has no effect. - 1: Reading 1 means that an overflow is detected, writing 1 clears this flag.
        constexpr uint32_t SSDRF = (1U << 2);  ///< Snapshot data ready flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no data is available on MDF_SNPSxDR, writing 0 has no effect. - 1: Reading 1 means that a new data is available on MDF_SNPSxDR, writing 1 clears this flag.
        constexpr uint32_t RXNEF = (1U << 3);  ///< RXFIFO Not Empty flag Set and cleared by hardware according to the RXFIFO level. - 0: Reading 0 means that the RXFIFO is empty. - 1: Reading 1 means that the RXFIFO is not empty.
        constexpr uint32_t OLDF = (1U << 4);  ///< Out-of Limit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no OLD event is detected, writing 0 has no effect. - 1: Reading 1 means that an OLD event is detected, writing 1 clears THHF, THLF and OLDF flags.
        constexpr uint32_t THLF = (1U << 5);  ///< Low threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the low threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHL, when the last OLD event occurred - 1: The signal was higher than OLDTHL, when the last OLD event occurred
        constexpr uint32_t THHF = (1U << 6);  ///< High threshold status flag Set by hardware, and cleared by software by writing OLDF bit to 1 . This flag indicates the status of the high threshold comparator when the last OLD event occurred. This bit gives additional information on the conditions triggering the last OLD event. It can be cleared by writing OLDF flag to a 1. - 0: The signal was lower than OLDTHH, when the last OLD event occurred - 1: The signal was higher than OLDTHH, when the last OLD event occurred
        constexpr uint32_t SSOVRF = (1U << 7);  ///< Snapshot overrun flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no snapshot overrun event is detected, writing 0 has no effect. - 1: Reading 1 means that a snapshot overrun event is detected, writing 1 clears this flag.
        constexpr uint32_t SCDF = (1U << 8);  ///< Short-Circuit Detector flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no SCD event is detected, writing 0 has no effect. - 1: Reading 1 means that a SCD event is detected, writing 1 clears this flag.
        constexpr uint32_t SATF = (1U << 9);  ///< Saturation detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no saturation is detected, writing 0 has no effect. - 1: Reading 1 means that a saturation is detected, writing 1 clears this flag.
        constexpr uint32_t CKABF = (1U << 10);  ///< Clock absence detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no clock absence is detected, writing 0 has no effect. - 1: Reading 1 means that a clock absence is detected, writing 1 clears this flag.
        constexpr uint32_t RFOVRF = (1U << 11);  ///< Reshape Filter Overrun detection flag Set by hardware, and cleared by software by writing this bit to 1 . - 0: Reading 0 means that no reshape filter overrun is detected, writing 0 has no effect. - 1: Reading 1 means that reshape filter overrun is detected, writing 1 clears this flag.
    }

    /// MDF_OEC0CR Register bits
    namespace mdf_oec0cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC1CR Register bits
    namespace mdf_oec1cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC2CR Register bits
    namespace mdf_oec2cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC3CR Register bits
    namespace mdf_oec3cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC4CR Register bits
    namespace mdf_oec4cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_OEC5CR Register bits
    namespace mdf_oec5cr_bits {
        constexpr uint32_t OFFSET = (26 << 0);  ///< Offset error compensation Set and cleared by software. If the application attempts to write a new offset value while the previous one is not yet applied, this new offset value is ignored. Reading back the OFFSET[25:0] field will inform the application on the current offset value. OFFSET[25:0] represents the value to be subtracted to the signal before going to the SCALE.
    }

    /// MDF_SNPS0DR Register bits
    namespace mdf_snps0dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS1DR Register bits
    namespace mdf_snps1dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS2DR Register bits
    namespace mdf_snps2dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS3DR Register bits
    namespace mdf_snps3dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS4DR Register bits
    namespace mdf_snps4dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_SNPS5DR Register bits
    namespace mdf_snps5dr_bits {
        constexpr uint32_t MCICDC = (9 << 0);  ///< Contains the MCIC decimation counter value at the moment of the last trigger event occurs (MCIC_CNT)
        constexpr uint32_t EXTSDR = (7 << 9);  ///< Extended data size If SNPSFMT = 0 , EXTSDR[6:0] contains the bit 7 to 1 of the last valid data processed by the digital filter, If SNPSFMT = 1 , this field contains the INT accumulator counter value at the moment of the last trigger event occurs (INT_CNT).
        constexpr uint32_t SDR = (16 << 16);  ///< Contains the 16 MSB of the last valid data processed by the digital filter.
    }

    /// MDF_DFLT0DR Register bits
    namespace mdf_dflt0dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT1DR Register bits
    namespace mdf_dflt1dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT2DR Register bits
    namespace mdf_dflt2dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT3DR Register bits
    namespace mdf_dflt3dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT4DR Register bits
    namespace mdf_dflt4dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

    /// MDF_DFLT5DR Register bits
    namespace mdf_dflt5dr_bits {
        constexpr uint32_t DR = (24 << 8);  ///< Data processed by digital filter.
    }

}

// ============================================================================
// OPAMP Peripheral
// ============================================================================

namespace opamp {
    /// Base addresses
    constexpr uint32_t OPAMP_BASE = 0x46005000;

    /// OPAMP Register structure
    struct Registers {
        volatile uint32_t OPAMP1_CSR;  ///< Offset: 0x00 - OPAMP1 control/status register
        volatile uint32_t OPAMP1_OTR;  ///< Offset: 0x04 - OPAMP1 offset trimming register in normal mode
        volatile uint32_t OPAMP1_LPOTR;  ///< Offset: 0x08 - OPAMP1 offset trimming register in low-power mode
        volatile uint32_t OPAMP2_CRS;  ///< Offset: 0x10 - OPAMP2 control/status register
        volatile uint32_t OPAMP2_OTR;  ///< Offset: 0x14 - OPAMP2 offset trimming register in normal mode
        volatile uint32_t OPAMP2_LPOTR;  ///< Offset: 0x18 - OPAMP2 offset trimming register in low-power mode
    };

    /// Peripheral instances
    inline Registers* OPAMP = reinterpret_cast<Registers*>(OPAMP_BASE);

    // Bit definitions
    /// OPAMP1_CSR Register bits
    namespace opamp1_csr_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< OPAMP enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< OPAMP low-power mode The OPAMP must be disabled to change this configuration.
        constexpr uint32_t OPAMODE = (2 << 2);  ///< OPAMP PGA mode 00 and 01: internal PGA disabled
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< OPAMP programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< Inverting input selection These bits are used only when OPAMODE = 00, 01 or 10. 1x: inverting input not externally connected
        constexpr uint32_t VP_SEL = (1U << 10);  ///< Non-inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< Calibration mode enable
        constexpr uint32_t CALSEL = (1U << 13);  ///< Calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< ‘factory’ or ‘user’ offset trimmed values selection This bit is active for normal and low-power modes.
        constexpr uint32_t CALOUT = (1U << 15);  ///< OPAMP calibration output During the calibration mode, the offset is trimmed when this signal toggles.
        constexpr uint32_t OPAHSM = (1U << 30);  ///< OPAMP high-speed mode This bit is effective for both normal and low-power modes.
        constexpr uint32_t OPA_RANGE = (1U << 31);  ///< OPAMP range setting This bit must be set before enabling the OPAMP and this bit affects all OPAMP instances.
    }

    /// OPAMP1_OTR Register bits
    namespace opamp1_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP1_LPOTR Register bits
    namespace opamp1_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Low-power mode trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Low-power mode trim for PMOS differential pairs
    }

    /// OPAMP2_CRS Register bits
    namespace opamp2_crs_bits {
        constexpr uint32_t OPAEN = (1U << 0);  ///< OPAMP enable
        constexpr uint32_t OPALPM = (1U << 1);  ///< OPAMP low-power mode The OPAMP must be disabled to change this configuration.
        constexpr uint32_t OPAMODE = (2 << 2);  ///< OPAMP PGA mode 00 and 01: internal PGA disabled
        constexpr uint32_t PGA_GAIN = (2 << 4);  ///< OPAMP programmable amplifier gain value
        constexpr uint32_t VM_SEL = (2 << 8);  ///< Inverting input selection These bits are used only when OPAMODE = 00, 01 or 10. in PGA mode for filtering) 1x: inverting input not externally connected
        constexpr uint32_t VP_SEL = (1U << 10);  ///< Non inverted input selection
        constexpr uint32_t CALON = (1U << 12);  ///< Calibration mode enable
        constexpr uint32_t CALSEL = (1U << 13);  ///< Calibration selection
        constexpr uint32_t USERTRIM = (1U << 14);  ///< ‘factory’ or ‘user’ offset trimmed values selection This bit is active for normal and low-power modes.
        constexpr uint32_t CALOUT = (1U << 15);  ///< OPAMP calibration output During calibration mode, the offset is trimmed when this signal toggles.
        constexpr uint32_t OPAHSM = (1U << 30);  ///< OPAMP high-speed mode This bit is effective for both normal and high-speed modes.
    }

    /// OPAMP2_OTR Register bits
    namespace opamp2_otr_bits {
        constexpr uint32_t TRIMOFFSETN = (5 << 0);  ///< Trim for NMOS differential pairs
        constexpr uint32_t TRIMOFFSETP = (5 << 8);  ///< Trim for PMOS differential pairs
    }

    /// OPAMP2_LPOTR Register bits
    namespace opamp2_lpotr_bits {
        constexpr uint32_t TRIMLPOFFSETN = (5 << 0);  ///< Low-power mode trim for NMOS differential pairs
        constexpr uint32_t TRIMLPOFFSETP = (5 << 8);  ///< Low-power mode trim for PMOS differential pairs
    }

}

// ============================================================================
// OTFDEC1 Peripheral
// ============================================================================

namespace otfdec1 {
    /// Base addresses
    constexpr uint32_t OTFDEC1_BASE = 0x420C5000;

    /// OTFDEC1 Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - OTFDEC control register
        volatile uint32_t PRIVCFGR;  ///< Offset: 0x10 - OTFDEC privileged access control configuration register
        volatile uint32_t R1CFGR;  ///< Offset: 0x20 - OTFDEC region x configuration register
        volatile uint32_t R2CFGR;  ///< Offset: 0x50 - OTFDEC region x configuration register
        volatile uint32_t R3CFGR;  ///< Offset: 0x80 - OTFDEC region x configuration register
        volatile uint32_t R4CFGR;  ///< Offset: 0xB0 - OTFDEC region x configuration register
        volatile uint32_t R1STARTADDR;  ///< Offset: 0x24 - OTFDEC region x start address register
        volatile uint32_t R2STARTADDR;  ///< Offset: 0x54 - OTFDEC region x start address register
        volatile uint32_t R3STARTADDR;  ///< Offset: 0x84 - OTFDEC region x start address register
        volatile uint32_t R4STARTADDR;  ///< Offset: 0xB4 - OTFDEC region x start address register
        volatile uint32_t R1ENDADDR;  ///< Offset: 0x28 - OTFDEC region x end address register
        volatile uint32_t R2ENDADDR;  ///< Offset: 0x58 - OTFDEC region x end address register
        volatile uint32_t R3ENDADDR;  ///< Offset: 0x88 - OTFDEC region x end address register
        volatile uint32_t R4ENDADDR;  ///< Offset: 0xB8 - OTFDEC region x end address register
        volatile uint32_t R1NONCER0;  ///< Offset: 0x2C - OTFDEC region x nonce register 0
        volatile uint32_t R2NONCER0;  ///< Offset: 0x5C - OTFDEC region x nonce register 0
        volatile uint32_t R3NONCER0;  ///< Offset: 0x8C - OTFDEC region x nonce register 0
        volatile uint32_t R4NONCER0;  ///< Offset: 0xBC - OTFDEC region x nonce register 0
        volatile uint32_t R1NONCER1;  ///< Offset: 0x30 - OTFDEC region x nonce register 1
        volatile uint32_t R2NONCER1;  ///< Offset: 0x60 - OTFDEC region x nonce register 1
        volatile uint32_t R3NONCER1;  ///< Offset: 0x90 - OTFDEC region x nonce register 1
        volatile uint32_t R4NONCER1;  ///< Offset: 0xC0 - OTFDEC region x nonce register 1
        volatile uint32_t R1KEYR0;  ///< Offset: 0x34 - OTFDEC region x key register 0
        volatile uint32_t R2KEYR0;  ///< Offset: 0x64 - OTFDEC region x key register 0
        volatile uint32_t R3KEYR0;  ///< Offset: 0x94 - OTFDEC region x key register 0
        volatile uint32_t R4KEYR0;  ///< Offset: 0xC4 - OTFDEC region x key register 0
        volatile uint32_t R1KEYR1;  ///< Offset: 0x38 - OTFDEC region x key register 1
        volatile uint32_t R2KEYR1;  ///< Offset: 0x68 - OTFDEC region x key register 1
        volatile uint32_t R3KEYR1;  ///< Offset: 0x98 - OTFDEC region x key register 1
        volatile uint32_t R4KEYR1;  ///< Offset: 0xC8 - OTFDEC region x key register 1
        volatile uint32_t R1KEYR2;  ///< Offset: 0x3C - OTFDEC region x key register 2
        volatile uint32_t R2KEYR2;  ///< Offset: 0x6C - OTFDEC region x key register 2
        volatile uint32_t R3KEYR2;  ///< Offset: 0x9C - OTFDEC region x key register 2
        volatile uint32_t R4KEYR2;  ///< Offset: 0xCC - OTFDEC region x key register 2
        volatile uint32_t R1KEYR3;  ///< Offset: 0x40 - OTFDEC region x key register 3
        volatile uint32_t R2KEYR3;  ///< Offset: 0x70 - OTFDEC region x key register 3
        volatile uint32_t R3KEYR3;  ///< Offset: 0xA0 - OTFDEC region x key register 3
        volatile uint32_t R4KEYR3;  ///< Offset: 0xD0 - OTFDEC region x key register 3
        volatile uint32_t ISR;  ///< Offset: 0x300 - OTFDEC interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x304 - OTFDEC interrupt clear register
        volatile uint32_t IER;  ///< Offset: 0x308 - OTFDEC interrupt enable register
    };

    /// Peripheral instances
    inline Registers* OTFDEC1 = reinterpret_cast<Registers*>(OTFDEC1_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t ENC = (1U << 0);  ///< Encryption mode bit
    }

    /// PRIVCFGR Register bits
    namespace privcfgr_bits {
        constexpr uint32_t PRIV = (1U << 0);  ///< Encryption mode bit
    }

    /// R1CFGR Register bits
    namespace r1cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REG1_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R2CFGR Register bits
    namespace r2cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REG2_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R3CFGR Register bits
    namespace r3cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REG3_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R4CFGR Register bits
    namespace r4cfgr_bits {
        constexpr uint32_t REG_EN = (1U << 0);  ///< region on-the-fly decryption enable
        constexpr uint32_t CONFIGLOCK = (1U << 1);  ///< region config lock
        constexpr uint32_t KEYLOCK = (1U << 2);  ///< region key lock
        constexpr uint32_t MODE = (2 << 4);  ///< operating mode
        constexpr uint32_t KEYCRC = (8 << 8);  ///< region key 8-bit CRC
        constexpr uint32_t REG4_VERSION = (16 << 16);  ///< region firmware version
    }

    /// R1STARTADDR Register bits
    namespace r1startaddr_bits {
        constexpr uint32_t REG1_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R2STARTADDR Register bits
    namespace r2startaddr_bits {
        constexpr uint32_t REG2_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R3STARTADDR Register bits
    namespace r3startaddr_bits {
        constexpr uint32_t REG3_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R4STARTADDR Register bits
    namespace r4startaddr_bits {
        constexpr uint32_t REG4_START_ADDR = (32 << 0);  ///< Region AXI start address
    }

    /// R1ENDADDR Register bits
    namespace r1endaddr_bits {
        constexpr uint32_t REG1_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R2ENDADDR Register bits
    namespace r2endaddr_bits {
        constexpr uint32_t REG2_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R3ENDADDR Register bits
    namespace r3endaddr_bits {
        constexpr uint32_t REG3_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R4ENDADDR Register bits
    namespace r4endaddr_bits {
        constexpr uint32_t REG4_END_ADDR = (32 << 0);  ///< Region AXI end address
    }

    /// R1NONCER0 Register bits
    namespace r1noncer0_bits {
        constexpr uint32_t REG1_NONCE = (32 << 0);  ///< REG1_NONCE
    }

    /// R2NONCER0 Register bits
    namespace r2noncer0_bits {
        constexpr uint32_t REG2_NONCE = (32 << 0);  ///< REG2_NONCE
    }

    /// R3NONCER0 Register bits
    namespace r3noncer0_bits {
        constexpr uint32_t REG3_NONCE = (32 << 0);  ///< REG3_NONCE
    }

    /// R4NONCER0 Register bits
    namespace r4noncer0_bits {
        constexpr uint32_t REG4_NONCE = (32 << 0);  ///< REG4_NONCE
    }

    /// R1NONCER1 Register bits
    namespace r1noncer1_bits {
        constexpr uint32_t REG1_NONCE = (32 << 0);  ///< Region nonce
    }

    /// R2NONCER1 Register bits
    namespace r2noncer1_bits {
        constexpr uint32_t REG2_NONCE = (32 << 0);  ///< Region nonce, bits [63:32]REGx_NONCE[63:32]
    }

    /// R3NONCER1 Register bits
    namespace r3noncer1_bits {
        constexpr uint32_t REG3_NONCE = (32 << 0);  ///< REG3_NONCE
    }

    /// R4NONCER1 Register bits
    namespace r4noncer1_bits {
        constexpr uint32_t REG4_NONCE = (32 << 0);  ///< REG4_NONCE
    }

    /// R1KEYR0 Register bits
    namespace r1keyr0_bits {
        constexpr uint32_t REG1_KEY = (32 << 0);  ///< REG1_KEY
    }

    /// R2KEYR0 Register bits
    namespace r2keyr0_bits {
        constexpr uint32_t REG2_KEY = (32 << 0);  ///< REG2_KEY
    }

    /// R3KEYR0 Register bits
    namespace r3keyr0_bits {
        constexpr uint32_t REG3_KEY = (32 << 0);  ///< REG3_KEY
    }

    /// R4KEYR0 Register bits
    namespace r4keyr0_bits {
        constexpr uint32_t REG4_KEY = (32 << 0);  ///< REG4_KEY
    }

    /// R1KEYR1 Register bits
    namespace r1keyr1_bits {
        constexpr uint32_t REG1_KEY = (32 << 0);  ///< REG1_KEY
    }

    /// R2KEYR1 Register bits
    namespace r2keyr1_bits {
        constexpr uint32_t REG2_KEY = (32 << 0);  ///< REG2_KEY
    }

    /// R3KEYR1 Register bits
    namespace r3keyr1_bits {
        constexpr uint32_t REG3_KEY = (32 << 0);  ///< REG3_KEY
    }

    /// R4KEYR1 Register bits
    namespace r4keyr1_bits {
        constexpr uint32_t REG4_KEY = (32 << 0);  ///< REG4_KEY
    }

    /// R1KEYR2 Register bits
    namespace r1keyr2_bits {
        constexpr uint32_t REG1_KEY = (32 << 0);  ///< REG1_KEY
    }

    /// R2KEYR2 Register bits
    namespace r2keyr2_bits {
        constexpr uint32_t REG2_KEY_ = (32 << 0);  ///< REG2_KEY_
    }

    /// R3KEYR2 Register bits
    namespace r3keyr2_bits {
        constexpr uint32_t REG3_KEY = (32 << 0);  ///< REG3_KEY
    }

    /// R4KEYR2 Register bits
    namespace r4keyr2_bits {
        constexpr uint32_t REG4_KEY = (32 << 0);  ///< REG4_KEY
    }

    /// R1KEYR3 Register bits
    namespace r1keyr3_bits {
        constexpr uint32_t REG1_KEY = (32 << 0);  ///< REG1_KEY
    }

    /// R2KEYR3 Register bits
    namespace r2keyr3_bits {
        constexpr uint32_t REG2_KEY = (32 << 0);  ///< REG2_KEY
    }

    /// R3KEYR3 Register bits
    namespace r3keyr3_bits {
        constexpr uint32_t REG3_KEY = (32 << 0);  ///< REG3_KEY
    }

    /// R4KEYR3 Register bits
    namespace r4keyr3_bits {
        constexpr uint32_t REG4_KEY = (32 << 0);  ///< REG4_KEY
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t SEIF = (1U << 0);  ///< Security Error Interrupt Flag status
        constexpr uint32_t XONEIF = (1U << 1);  ///< Execute-only execute-Never Error Interrupt Flag status
        constexpr uint32_t KEIF = (1U << 2);  ///< Key Error Interrupt Flag status
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t SEIF = (1U << 0);  ///< SEIF
        constexpr uint32_t XONEIF = (1U << 1);  ///< Execute-only execute-Never Error Interrupt Flag clear
        constexpr uint32_t KEIF = (1U << 2);  ///< KEIF
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< Security Error Interrupt Enable
        constexpr uint32_t XONEIE = (1U << 1);  ///< XONEIE
        constexpr uint32_t KEIE = (1U << 2);  ///< KEIE
    }

}

// ============================================================================
// OTFDEC2 Peripheral
// ============================================================================

namespace otfdec2 {
    /// Base addresses
    constexpr uint32_t OTFDEC2_BASE = 0x420C5400;

    /// OTFDEC2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* OTFDEC2 = reinterpret_cast<Registers*>(OTFDEC2_BASE);

}

// ============================================================================
// OTG Peripheral
// ============================================================================

namespace otg {
    /// Base addresses
    constexpr uint32_t OTG_HS_BASE = 0x42040000;

    /// OTG Register structure
    struct Registers {
        volatile uint32_t GOTGCTL;  ///< Offset: 0x00 - The GOTGCTL register controls the behavior and reflects...
        volatile uint32_t GOTGINT;  ///< Offset: 0x04 - The application reads this register whenever there is an...
        volatile uint32_t GAHBCFG;  ///< Offset: 0x08 - This register can be used to configure the core after...
        volatile uint32_t GUSBCFG;  ///< Offset: 0x0C - This register can be used to configure the core after...
        volatile uint32_t GRSTCTL;  ///< Offset: 0x10 - The application uses this register to reset various...
        volatile uint32_t GINTSTS;  ///< Offset: 0x14 - This register interrupts the application for...
        volatile uint32_t GINTMSK;  ///< Offset: 0x18 - This register works with the core interrupt register to...
        volatile uint32_t GRXSTSR_DEVICE;  ///< Offset: 0x1C - This description is for register GRXSTSR in Device mode....
        volatile uint32_t GRXSTSR_HOST;  ///< Offset: 0x1C - This description is for register GRXSTSR in Host mode
        volatile uint32_t GRXSTSP_DEVICE;  ///< Offset: 0x20 - This description is for register GRXSTSP in Device mode....
        volatile uint32_t GRXSTSP_HOST;  ///< Offset: 0x20 - This description is for register GRXSTSP in HOST mode
        volatile uint32_t GRXFSIZ;  ///< Offset: 0x24 - The application can program the RAM size that must be...
        volatile uint32_t HNPTXFSIZ;  ///< Offset: 0x28 - Host mode
        volatile uint32_t HNPTXSTS;  ///< Offset: 0x2C - In device mode, this register is not valid. This...
        volatile uint32_t GCCFG;  ///< Offset: 0x38 - OTG general core configuration register
        volatile uint32_t CID;  ///< Offset: 0x3C - This is a register containing the Product ID as reset value.
        volatile uint32_t GLPMCFG;  ///< Offset: 0x54 - OTG core LPM configuration register
        volatile uint32_t HPTXFSIZ;  ///< Offset: 0x100 - OTG host periodic transmit FIFO size register
        volatile uint32_t DIEPTXF1;  ///< Offset: 0x104 - OTG device IN endpoint transmit FIFO 1 size register
        volatile uint32_t DIEPTXF2;  ///< Offset: 0x108 - OTG device IN endpoint transmit FIFO 2 size register
        volatile uint32_t DIEPTXF3;  ///< Offset: 0x10C - OTG device IN endpoint transmit FIFO 3 size register
        volatile uint32_t DIEPTXF4;  ///< Offset: 0x110 - OTG device IN endpoint transmit FIFO 4 size register
        volatile uint32_t DIEPTXF5;  ///< Offset: 0x114 - OTG device IN endpoint transmit FIFO 5 size register
        volatile uint32_t DIEPTXF6;  ///< Offset: 0x118 - OTG device IN endpoint transmit FIFO 6 size register
        volatile uint32_t DIEPTXF7;  ///< Offset: 0x11C - OTG device IN endpoint transmit FIFO 7 size register
        volatile uint32_t DIEPTXF8;  ///< Offset: 0x120 - OTG device IN endpoint transmit FIFO 8 size register
        volatile uint32_t HCFG;  ///< Offset: 0x400 - This register configures the core after power-on. Do not...
        volatile uint32_t HFIR;  ///< Offset: 0x404 - This register stores the frame interval information for...
        volatile uint32_t HFNUM;  ///< Offset: 0x408 - This register indicates the current frame number. It...
        volatile uint32_t HPTXSTS;  ///< Offset: 0x410 - This read-only register contains the free space...
        volatile uint32_t HAINT;  ///< Offset: 0x414 - When a significant event occurs on a channel, the host...
        volatile uint32_t HAINTMSK;  ///< Offset: 0x418 - The host all channel interrupt mask register works with...
        volatile uint32_t HPRT;  ///< Offset: 0x440 - This register is available only in host mode. Currently,...
        volatile uint32_t HCCHAR0;  ///< Offset: 0x500 - OTG host channel 0 characteristics register
        volatile uint32_t HCSPLT0;  ///< Offset: 0x504 - OTG host channel 0 split control register
        volatile uint32_t HCSPLT1;  ///< Offset: 0x524 - OTG host channel 1 split control register
        volatile uint32_t HCSPLT2;  ///< Offset: 0x544 - OTG host channel 2 split control register
        volatile uint32_t HCSPLT3;  ///< Offset: 0x564 - OTG host channel 3 split control register
        volatile uint32_t HCSPLT4;  ///< Offset: 0x584 - OTG host channel 4 split control register
        volatile uint32_t HCSPLT5;  ///< Offset: 0x5A4 - OTG host channel 5 split control register
        volatile uint32_t HCSPLT6;  ///< Offset: 0x5C4 - OTG host channel 6 split control register
        volatile uint32_t HCSPLT7;  ///< Offset: 0x5E4 - OTG host channel 7 split control register
        volatile uint32_t HCSPLT8;  ///< Offset: 0x604 - OTG host channel 8 split control register
        volatile uint32_t HCSPLT9;  ///< Offset: 0x624 - OTG host channel 9 split control register
        volatile uint32_t HCSPLT10;  ///< Offset: 0x644 - OTG host channel 10 split control register
        volatile uint32_t HCSPLT11;  ///< Offset: 0x664 - OTG host channel 11 split control register
        volatile uint32_t HCSPLT12;  ///< Offset: 0x684 - OTG host channel 0 split control register
        volatile uint32_t HCSPLT13;  ///< Offset: 0x6A4 - OTG host channel 13 split control register
        volatile uint32_t HCSPLT14;  ///< Offset: 0x6C4 - OTG host channel 14 split control register
        volatile uint32_t HCSPLT15;  ///< Offset: 0x6E4 - OTG host channel 15 split control register
        volatile uint32_t HCINT0;  ///< Offset: 0x508 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK0;  ///< Offset: 0x50C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ0;  ///< Offset: 0x510 - OTG host channel 0 transfer size register
        volatile uint32_t HCDMA0;  ///< Offset: 0x514 - OTG host channel 0 DMA address register
        volatile uint32_t HCDMA1;  ///< Offset: 0x534 - OTG host channel 1 DMA address register
        volatile uint32_t HCDMA2;  ///< Offset: 0x554 - OTG host channel 2 DMA address register
        volatile uint32_t HCDMA3;  ///< Offset: 0x574 - OTG host channel 3 DMA address register
        volatile uint32_t HCDMA4;  ///< Offset: 0x594 - OTG host channel 4 DMA address register
        volatile uint32_t HCDMA5;  ///< Offset: 0x5B4 - OTG host channel 5 DMA address register
        volatile uint32_t HCDMA6;  ///< Offset: 0x5D4 - OTG host channel 6 DMA address register
        volatile uint32_t HCDMA7;  ///< Offset: 0x5F4 - OTG host channel 7 DMA address register
        volatile uint32_t HCDMA8;  ///< Offset: 0x614 - OTG host channel 8 DMA address register
        volatile uint32_t HCDMA9;  ///< Offset: 0x634 - OTG host channel 9 DMA address register
        volatile uint32_t HCDMA10;  ///< Offset: 0x654 - OTG host channel 10 DMA address register
        volatile uint32_t HCDMA11;  ///< Offset: 0x674 - OTG host channel 11 DMA address register
        volatile uint32_t HCDMA12;  ///< Offset: 0x694 - OTG host channel 12 DMA address register
        volatile uint32_t HCDMA13;  ///< Offset: 0x6B4 - OTG host channel 13 DMA address register
        volatile uint32_t HCDMA14;  ///< Offset: 0x6D4 - OTG host channel 14 DMA address register
        volatile uint32_t HCDMA15;  ///< Offset: 0x6F4 - OTG host channel 15 DMA address register
        volatile uint32_t HCCHAR1;  ///< Offset: 0x520 - OTG host channel 1 characteristics register
        volatile uint32_t HCINT1_DEVICE;  ///< Offset: 0x528 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK1;  ///< Offset: 0x52C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ1;  ///< Offset: 0x530 - OTG host channel 1 transfer size register
        volatile uint32_t HCCHAR2;  ///< Offset: 0x540 - OTG host channel 2 characteristics register
        volatile uint32_t HCINT2;  ///< Offset: 0x548 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK2;  ///< Offset: 0x54C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ2;  ///< Offset: 0x550 - OTG host channel 2 transfer size register
        volatile uint32_t HCCHAR3;  ///< Offset: 0x560 - OTG host channel 3 characteristics register
        volatile uint32_t HCINT3;  ///< Offset: 0x568 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK3;  ///< Offset: 0x56C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ3;  ///< Offset: 0x570 - OTG host channel 3 transfer size register
        volatile uint32_t HCCHAR4;  ///< Offset: 0x580 - OTG host channel 4 characteristics register
        volatile uint32_t HCINT4;  ///< Offset: 0x588 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK4;  ///< Offset: 0x58C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ4;  ///< Offset: 0x590 - OTG host channel 4 transfer size register
        volatile uint32_t HCCHAR5;  ///< Offset: 0x5A0 - OTG host channel 5 characteristics register
        volatile uint32_t HCINT5;  ///< Offset: 0x5A8 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK5;  ///< Offset: 0x5AC - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ5;  ///< Offset: 0x5B0 - OTG host channel 5 transfer size register
        volatile uint32_t HCCHAR6;  ///< Offset: 0x5C0 - OTG host channel 6 characteristics register
        volatile uint32_t HCINT6;  ///< Offset: 0x5C8 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK6;  ///< Offset: 0x5CC - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ6;  ///< Offset: 0x5D0 - OTG host channel 6 transfer size register
        volatile uint32_t HCCHAR7;  ///< Offset: 0x5E0 - OTG host channel 7 characteristics register
        volatile uint32_t HCINT7;  ///< Offset: 0x5E8 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK7;  ///< Offset: 0x5EC - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ7;  ///< Offset: 0x5F0 - OTG host channel 7 transfer size register
        volatile uint32_t HCCHAR8;  ///< Offset: 0x600 - OTG host channel 8 characteristics register
        volatile uint32_t HCINT8;  ///< Offset: 0x608 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK8;  ///< Offset: 0x60C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ8;  ///< Offset: 0x610 - OTG host channel 8 transfer size register
        volatile uint32_t HCCHAR9;  ///< Offset: 0x620 - OTG host channel 9 characteristics register
        volatile uint32_t HCINT9;  ///< Offset: 0x628 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK9;  ///< Offset: 0x62C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ9;  ///< Offset: 0x630 - OTG host channel 9 transfer size register
        volatile uint32_t HCCHAR10;  ///< Offset: 0x640 - OTG host channel 10 characteristics register
        volatile uint32_t HCINT10;  ///< Offset: 0x648 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK10;  ///< Offset: 0x64C - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ10;  ///< Offset: 0x650 - OTG host channel 10 transfer size register
        volatile uint32_t HCCHAR11;  ///< Offset: 0x660 - OTG host channel 11 characteristics register
        volatile uint32_t HCCHAR12;  ///< Offset: 0x680 - OTG host channel 12 characteristics register
        volatile uint32_t HCCHAR13;  ///< Offset: 0x6A0 - OTG host channel 13 characteristics register
        volatile uint32_t HCCHAR14;  ///< Offset: 0x6C0 - OTG host channel 14 characteristics register
        volatile uint32_t HCCHAR15;  ///< Offset: 0x6E0 - OTG host channel 15 characteristics register
        volatile uint32_t HCINT11;  ///< Offset: 0x668 - This register indicates the status of a channel with...
        volatile uint32_t HCINT12;  ///< Offset: 0x688 - This register indicates the status of a channel with...
        volatile uint32_t HCINT13;  ///< Offset: 0x6A8 - This register indicates the status of a channel with...
        volatile uint32_t HCINT14;  ///< Offset: 0x6C8 - This register indicates the status of a channel with...
        volatile uint32_t HCINT15;  ///< Offset: 0x6E8 - This register indicates the status of a channel with...
        volatile uint32_t HCINTMSK11;  ///< Offset: 0x66C - This register reflects the mask for each channel status...
        volatile uint32_t HCINTMSK12;  ///< Offset: 0x68C - This register reflects the mask for each channel status...
        volatile uint32_t HCINTMSK13;  ///< Offset: 0x6AC - This register reflects the mask for each channel status...
        volatile uint32_t HCINTMSK14;  ///< Offset: 0x6CC - This register reflects the mask for each channel status...
        volatile uint32_t HCINTMSK15;  ///< Offset: 0x6EC - This register reflects the mask for each channel status...
        volatile uint32_t HCTSIZ11;  ///< Offset: 0x670 - OTG host channel 11 transfer size register
        volatile uint32_t HCTSIZ12;  ///< Offset: 0x690 - OTG host channel 12 transfer size register
        volatile uint32_t HCTSIZ13;  ///< Offset: 0x6B0 - OTG host channel 13 transfer size register
        volatile uint32_t HCTSIZ14;  ///< Offset: 0x6D0 - OTG host channel 14 transfer size register
        volatile uint32_t HCTSIZ15;  ///< Offset: 0x6F0 - OTG host channel 15 transfer size register
        volatile uint32_t DCFG;  ///< Offset: 0x800 - This register configures the core in device mode after...
        volatile uint32_t DCTL;  ///< Offset: 0x804 - OTG device control register
        volatile uint32_t DSTS;  ///< Offset: 0x808 - This register indicates the status of the core with...
        volatile uint32_t DIEPMSK;  ///< Offset: 0x810 - This register works with each of the DIEPINTx registers...
        volatile uint32_t DOEPMSK;  ///< Offset: 0x814 - This register works with each of the DOEPINTx registers...
        volatile uint32_t DAINT;  ///< Offset: 0x818 - When a significant event occurs on an endpoint, a DAINT...
        volatile uint32_t DAINTMSK;  ///< Offset: 0x81C - The DAINTMSK register works with the device endpoint...
        volatile uint32_t DVBUSDIS;  ///< Offset: 0x828 - This register specifies the VBUS discharge time after...
        volatile uint32_t DVBUSPULSE;  ///< Offset: 0x82C - This register specifies the VBUS pulsing time during SRP.
        volatile uint32_t DTHRCTL;  ///< Offset: 0x830 - OTG device threshold control register
        volatile uint32_t DIEPEMPMSK;  ///< Offset: 0x834 - This register is used to control the IN endpoint FIFO...
        volatile uint32_t HS_DOEPEACHMSK1;  ///< Offset: 0x884 - OTG device each OUT endpoint-1 interrupt mask register
        volatile uint32_t DIEPCTL0;  ///< Offset: 0x900 - The application uses this register to control the...
        volatile uint32_t DIEPINT0;  ///< Offset: 0x908 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ0;  ///< Offset: 0x910 - The application must modify this register before...
        volatile uint32_t DTXFSTS0;  ///< Offset: 0x918 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL1;  ///< Offset: 0x920 - The application uses this register to control the...
        volatile uint32_t DIEPINT1;  ///< Offset: 0x928 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ1;  ///< Offset: 0x930 - The application must modify this register before...
        volatile uint32_t DIEPDMA1;  ///< Offset: 0x934 - OTG device IN endpoint 1 DMA address register
        volatile uint32_t DTXFSTS1;  ///< Offset: 0x938 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL2;  ///< Offset: 0x940 - The application uses this register to control the...
        volatile uint32_t DIEPINT2;  ///< Offset: 0x948 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ2;  ///< Offset: 0x950 - The application must modify this register before...
        volatile uint32_t DIEPDMA2;  ///< Offset: 0x954 - OTG device IN endpoint 2 DMA address register
        volatile uint32_t DTXFSTS2;  ///< Offset: 0x958 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL3;  ///< Offset: 0x960 - The application uses this register to control the...
        volatile uint32_t DIEPINT3;  ///< Offset: 0x968 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ3;  ///< Offset: 0x970 - The application must modify this register before...
        volatile uint32_t DIEPDMA3;  ///< Offset: 0x974 - OTG device IN endpoint 3 DMA address register
        volatile uint32_t DTXFSTS3;  ///< Offset: 0x978 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL4;  ///< Offset: 0x980 - The application uses this register to control the...
        volatile uint32_t DIEPINT4;  ///< Offset: 0x988 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ4;  ///< Offset: 0x990 - The application must modify this register before...
        volatile uint32_t DIEPDMA4;  ///< Offset: 0x994 - OTG device IN endpoint 4 DMA address register
        volatile uint32_t DTXFSTS4;  ///< Offset: 0x998 - This read-only register contains the free space...
        volatile uint32_t DIEPCTL5;  ///< Offset: 0x9A0 - The application uses this register to control the...
        volatile uint32_t DIEPINT5;  ///< Offset: 0x9A8 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ5;  ///< Offset: 0x9B0 - The application must modify this register before...
        volatile uint32_t DIEPDMA5;  ///< Offset: 0x9B4 - OTG device IN endpoint 5 DMA address register
        volatile uint32_t DTXFSTS5;  ///< Offset: 0x9B8 - This read-only register contains the free space...
        volatile uint32_t DIEPINT6;  ///< Offset: 0x9C8 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ6;  ///< Offset: 0x9D0 - The application must modify this register before...
        volatile uint32_t DIEPDMA6;  ///< Offset: 0x9D4 - OTG device IN endpoint 6 DMA address register
        volatile uint32_t DIEPINT7;  ///< Offset: 0x9E8 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ7;  ///< Offset: 0x9F0 - The application must modify this register before...
        volatile uint32_t DIEPDMA7;  ///< Offset: 0x9F4 - OTG device IN endpoint 7 DMA address register
        volatile uint32_t DIEPINT8;  ///< Offset: 0xA08 - This register indicates the status of an endpoint with...
        volatile uint32_t DIEPTSIZ8;  ///< Offset: 0xA10 - The application must modify this register before...
        volatile uint32_t DIEPDMA8;  ///< Offset: 0xA14 - OTG device IN endpoint 8 DMA address register
        volatile uint32_t DOEPCTL0;  ///< Offset: 0xB00 - This section describes the DOEPCTL0 register.
        volatile uint32_t DOEPINT0;  ///< Offset: 0xB08 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ0;  ///< Offset: 0xB10 - The application must modify this register before...
        volatile uint32_t DOEPDMA0;  ///< Offset: 0xB14 - OTG device OUT endpoint 0 DMA address register
        volatile uint32_t DOEPCTL1;  ///< Offset: 0xB20 - The application uses this register to control the...
        volatile uint32_t DOEPINT1;  ///< Offset: 0xB28 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ1;  ///< Offset: 0xB30 - The application must modify this register before...
        volatile uint32_t DOEPDMA1;  ///< Offset: 0xB34 - OTG device OUT endpoint 1 DMA address register
        volatile uint32_t DOEPCTL2;  ///< Offset: 0xB40 - The application uses this register to control the...
        volatile uint32_t DOEPINT2;  ///< Offset: 0xB48 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ2;  ///< Offset: 0xB50 - The application must modify this register before...
        volatile uint32_t DOEPDMA2;  ///< Offset: 0xB54 - OTG device OUT endpoint 2 DMA address register
        volatile uint32_t DOEPCTL3;  ///< Offset: 0xB60 - The application uses this register to control the...
        volatile uint32_t DOEPINT3;  ///< Offset: 0xB68 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ3;  ///< Offset: 0xB70 - The application must modify this register before...
        volatile uint32_t DOEPDMA3;  ///< Offset: 0xB74 - OTG device OUT endpoint 3 DMA address register
        volatile uint32_t DOEPCTL4;  ///< Offset: 0xB80 - The application uses this register to control the...
        volatile uint32_t DOEPINT4;  ///< Offset: 0xB88 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ4;  ///< Offset: 0xB90 - The application must modify this register before...
        volatile uint32_t DOEPDMA4;  ///< Offset: 0xB94 - OTG device OUT endpoint 4 DMA address register
        volatile uint32_t DOEPCTL5;  ///< Offset: 0xBA0 - The application uses this register to control the...
        volatile uint32_t DOEPINT5;  ///< Offset: 0xBA8 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ5;  ///< Offset: 0xBB0 - The application must modify this register before...
        volatile uint32_t DOEPDMA5;  ///< Offset: 0xBB4 - OTG device OUT endpoint 5 DMA address register
        volatile uint32_t DOEPCTL6;  ///< Offset: 0xBC0 - The application uses this register to control the...
        volatile uint32_t DOEPINT6;  ///< Offset: 0xBC8 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ6;  ///< Offset: 0xBD0 - The application must modify this register before...
        volatile uint32_t DOEPDMA6;  ///< Offset: 0xBD4 - OTG device OUT endpoint 6 DMA address register
        volatile uint32_t DOEPCTL7;  ///< Offset: 0xBE0 - The application uses this register to control the...
        volatile uint32_t DOEPINT7;  ///< Offset: 0xBE8 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ7;  ///< Offset: 0xBF0 - The application must modify this register before...
        volatile uint32_t DOEPDMA7;  ///< Offset: 0xBF4 - OTG device OUT endpoint 7 DMA address register
        volatile uint32_t DOEPCTL8;  ///< Offset: 0xC00 - The application uses this register to control the...
        volatile uint32_t DOEPINT8;  ///< Offset: 0xC08 - This register indicates the status of an endpoint with...
        volatile uint32_t DOEPTSIZ8;  ///< Offset: 0xC10 - The application must modify this register before...
        volatile uint32_t DOEPDMA8;  ///< Offset: 0xC14 - OTG device OUT endpoint 8 DMA address register
        volatile uint32_t PCGCCTL;  ///< Offset: 0xE00 - This register is available in host and device modes.
    };

    /// Peripheral instances
    inline Registers* OTG_HS = reinterpret_cast<Registers*>(OTG_HS_BASE);

    // Bit definitions
    /// GOTGCTL Register bits
    namespace gotgctl_bits {
        constexpr uint32_t SRQSCS = (1U << 0);  ///< SRQSCS
        constexpr uint32_t SRQ = (1U << 1);  ///< SRQ
        constexpr uint32_t VBVALOEN = (1U << 2);  ///< VBVALOEN
        constexpr uint32_t VBVALOVAL = (1U << 3);  ///< VBVALOVAL
        constexpr uint32_t AVALOEN = (1U << 4);  ///< AVALOEN
        constexpr uint32_t AVALOVAL = (1U << 5);  ///< AVALOVAL
        constexpr uint32_t BVALOEN = (1U << 6);  ///< BVALOEN
        constexpr uint32_t BVALOVAL = (1U << 7);  ///< BVALOVAL
        constexpr uint32_t HNGSCS = (1U << 8);  ///< HNGSCS
        constexpr uint32_t HNPRQ = (1U << 9);  ///< HNPRQ
        constexpr uint32_t HSHNPEN = (1U << 10);  ///< HSHNPEN
        constexpr uint32_t DHNPEN = (1U << 11);  ///< DHNPEN
        constexpr uint32_t EHEN = (1U << 12);  ///< EHEN
        constexpr uint32_t CIDSTS = (1U << 16);  ///< CIDSTS
        constexpr uint32_t DBCT = (1U << 17);  ///< DBCT
        constexpr uint32_t ASVLD = (1U << 18);  ///< ASVLD
        constexpr uint32_t BSVLD = (1U << 19);  ///< BSVLD
        constexpr uint32_t OTGVER = (1U << 20);  ///< OTGVER
        constexpr uint32_t CURMOD = (1U << 21);  ///< CURMOD
    }

    /// GOTGINT Register bits
    namespace gotgint_bits {
        constexpr uint32_t SEDET = (1U << 2);  ///< SEDET
        constexpr uint32_t SRSSCHG = (1U << 8);  ///< SRSSCHG
        constexpr uint32_t HNSSCHG = (1U << 9);  ///< HNSSCHG
        constexpr uint32_t HNGDET = (1U << 17);  ///< HNGDET
        constexpr uint32_t ADTOCHG = (1U << 18);  ///< ADTOCHG
        constexpr uint32_t DBCDNE = (1U << 19);  ///< DBCDNE
    }

    /// GAHBCFG Register bits
    namespace gahbcfg_bits {
        constexpr uint32_t GINTMSK = (1U << 0);  ///< GINTMSK
        constexpr uint32_t TXFELVL = (1U << 7);  ///< TXFELVL
        constexpr uint32_t PTXFELVL = (1U << 8);  ///< PTXFELVL
    }

    /// GUSBCFG Register bits
    namespace gusbcfg_bits {
        constexpr uint32_t TOCAL = (3 << 0);  ///< TOCAL
        constexpr uint32_t PHYSEL = (1U << 6);  ///< PHYSEL
        constexpr uint32_t SRPCAP = (1U << 8);  ///< SRPCAP
        constexpr uint32_t HNPCAP = (1U << 9);  ///< HNPCAP
        constexpr uint32_t TRDT = (4 << 10);  ///< TRDT
        constexpr uint32_t PHYLPC = (1U << 15);  ///< PHYLPC
        constexpr uint32_t TSDPS = (1U << 22);  ///< TSDPS
        constexpr uint32_t FHMOD = (1U << 29);  ///< FHMOD
        constexpr uint32_t FDMOD = (1U << 30);  ///< FDMOD
    }

    /// GRSTCTL Register bits
    namespace grstctl_bits {
        constexpr uint32_t CSRST = (1U << 0);  ///< CSRST
        constexpr uint32_t PSRST = (1U << 1);  ///< PSRST
        constexpr uint32_t FSRST = (1U << 2);  ///< FSRST
        constexpr uint32_t RXFFLSH = (1U << 4);  ///< RXFFLSH
        constexpr uint32_t TXFFLSH = (1U << 5);  ///< TXFFLSH
        constexpr uint32_t TXFNUM = (5 << 6);  ///< TXFNUM
        constexpr uint32_t DMAREQ = (1U << 30);  ///< DMAREQ
        constexpr uint32_t AHBIDL = (1U << 31);  ///< AHBIDL
    }

    /// GINTSTS Register bits
    namespace gintsts_bits {
        constexpr uint32_t CMOD = (1U << 0);  ///< CMOD
        constexpr uint32_t MMIS = (1U << 1);  ///< MMIS
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTGINT
        constexpr uint32_t SOF = (1U << 3);  ///< SOF
        constexpr uint32_t RXFLVL = (1U << 4);  ///< RXFLVL
        constexpr uint32_t NPTXFE = (1U << 5);  ///< NPTXFE
        constexpr uint32_t GINAKEFF = (1U << 6);  ///< GINAKEFF
        constexpr uint32_t GONAKEFF = (1U << 7);  ///< GONAKEFF
        constexpr uint32_t ESUSP = (1U << 10);  ///< ESUSP
        constexpr uint32_t USBSUSP = (1U << 11);  ///< USBSUSP
        constexpr uint32_t USBRST = (1U << 12);  ///< USBRST
        constexpr uint32_t ENUMDNE = (1U << 13);  ///< ENUMDNE
        constexpr uint32_t ISOODRP = (1U << 14);  ///< ISOODRP
        constexpr uint32_t EOPF = (1U << 15);  ///< EOPF
        constexpr uint32_t IEPINT = (1U << 18);  ///< IEPINT
        constexpr uint32_t OEPINT = (1U << 19);  ///< OEPINT
        constexpr uint32_t IISOIXFR = (1U << 20);  ///< IISOIXFR
        constexpr uint32_t IPXFR = (1U << 21);  ///< IPXFR
        constexpr uint32_t DATAFSUSP = (1U << 22);  ///< DATAFSUSP
        constexpr uint32_t RSTDET = (1U << 23);  ///< RSTDET
        constexpr uint32_t HPRTINT = (1U << 24);  ///< HPRTINT
        constexpr uint32_t HCINT = (1U << 25);  ///< HCINT
        constexpr uint32_t PTXFE = (1U << 26);  ///< PTXFE
        constexpr uint32_t LPMINT = (1U << 27);  ///< LPMINT
        constexpr uint32_t CIDSCHG = (1U << 28);  ///< CIDSCHG
        constexpr uint32_t DISCINT = (1U << 29);  ///< DISCINT
        constexpr uint32_t SRQINT = (1U << 30);  ///< SRQINT
        constexpr uint32_t WKUPINT = (1U << 31);  ///< WKUPINT
    }

    /// GINTMSK Register bits
    namespace gintmsk_bits {
        constexpr uint32_t MMISM = (1U << 1);  ///< MMISM
        constexpr uint32_t OTGINT = (1U << 2);  ///< OTGINT
        constexpr uint32_t SOFM = (1U << 3);  ///< SOFM
        constexpr uint32_t RXFLVLM = (1U << 4);  ///< RXFLVLM
        constexpr uint32_t NPTXFEM = (1U << 5);  ///< NPTXFEM
        constexpr uint32_t GINAKEFFM = (1U << 6);  ///< GINAKEFFM
        constexpr uint32_t GONAKEFFM = (1U << 7);  ///< GONAKEFFM
        constexpr uint32_t ESUSPM = (1U << 10);  ///< ESUSPM
        constexpr uint32_t USBSUSPM = (1U << 11);  ///< USBSUSPM
        constexpr uint32_t USBRST = (1U << 12);  ///< USBRST
        constexpr uint32_t ENUMDNEM = (1U << 13);  ///< ENUMDNEM
        constexpr uint32_t ISOODRPM = (1U << 14);  ///< ISOODRPM
        constexpr uint32_t EOPFM = (1U << 15);  ///< EOPFM
        constexpr uint32_t IEPINT = (1U << 18);  ///< IEPINT
        constexpr uint32_t OEPINT = (1U << 19);  ///< OEPINT
        constexpr uint32_t IISOIXFRM = (1U << 20);  ///< IISOIXFRM
        constexpr uint32_t IPXFRM = (1U << 21);  ///< IPXFRM
        constexpr uint32_t FSUSPM = (1U << 22);  ///< FSUSPM
        constexpr uint32_t RSTDETM = (1U << 23);  ///< RSTDETM
        constexpr uint32_t PRTIM = (1U << 24);  ///< PRTIM
        constexpr uint32_t HCIM = (1U << 25);  ///< HCIM
        constexpr uint32_t PTXFEM = (1U << 26);  ///< PTXFEM
        constexpr uint32_t LPMINTM = (1U << 27);  ///< LPMINTM
        constexpr uint32_t CIDSCHGM = (1U << 28);  ///< CIDSCHGM
        constexpr uint32_t DISCINT = (1U << 29);  ///< DISCINT
        constexpr uint32_t SRQIM = (1U << 30);  ///< SRQIM
        constexpr uint32_t WUIM = (1U << 31);  ///< WUIM
    }

    /// GRXSTSR_DEVICE Register bits
    namespace grxstsr_device_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< EPNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
        constexpr uint32_t FRMNUM = (4 << 21);  ///< FRMNUM
        constexpr uint32_t STSPHST = (1U << 27);  ///< STSPHST
    }

    /// GRXSTSR_HOST Register bits
    namespace grxstsr_host_bits {
        constexpr uint32_t CHNUM = (4 << 0);  ///< CHNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
    }

    /// GRXSTSP_DEVICE Register bits
    namespace grxstsp_device_bits {
        constexpr uint32_t EPNUM = (4 << 0);  ///< EPNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
        constexpr uint32_t FRMNUM = (4 << 21);  ///< FRMNUM
        constexpr uint32_t STSPHST = (1U << 27);  ///< STSPHST
    }

    /// GRXSTSP_HOST Register bits
    namespace grxstsp_host_bits {
        constexpr uint32_t CHNUM = (4 << 0);  ///< CHNUM
        constexpr uint32_t BCNT = (11 << 4);  ///< BCNT
        constexpr uint32_t DPID = (2 << 15);  ///< DPID
        constexpr uint32_t PKTSTS = (4 << 17);  ///< PKTSTS
    }

    /// GRXFSIZ Register bits
    namespace grxfsiz_bits {
        constexpr uint32_t RXFD = (16 << 0);  ///< RXFD
    }

    /// HNPTXFSIZ Register bits
    namespace hnptxfsiz_bits {
        constexpr uint32_t NPTXFSA = (16 << 0);  ///< NPTXFSA
        constexpr uint32_t NPTXFD = (16 << 16);  ///< NPTXFD
    }

    /// HNPTXSTS Register bits
    namespace hnptxsts_bits {
        constexpr uint32_t NPTXFSAV = (16 << 0);  ///< NPTXFSAV
        constexpr uint32_t NPTQXSAV = (8 << 16);  ///< NPTQXSAV
        constexpr uint32_t NPTXQTOP = (7 << 24);  ///< NPTXQTOP
    }

    /// GCCFG Register bits
    namespace gccfg_bits {
        constexpr uint32_t DCDET = (1U << 0);  ///< DCDET
        constexpr uint32_t PDET = (1U << 1);  ///< PDET
        constexpr uint32_t SDET = (1U << 2);  ///< SDET
        constexpr uint32_t PS2DET = (1U << 3);  ///< PS2DET
        constexpr uint32_t PWRDWN = (1U << 16);  ///< PWRDWN
        constexpr uint32_t BCDEN = (1U << 17);  ///< BCDEN
        constexpr uint32_t DCDEN = (1U << 18);  ///< DCDEN
        constexpr uint32_t PDEN = (1U << 19);  ///< PDEN
        constexpr uint32_t SDEN = (1U << 20);  ///< SDEN
        constexpr uint32_t VBDEN = (1U << 21);  ///< VBDEN
    }

    /// CID Register bits
    namespace cid_bits {
        constexpr uint32_t PRODUCT_ID = (32 << 0);  ///< PRODUCT_ID
    }

    /// GLPMCFG Register bits
    namespace glpmcfg_bits {
        constexpr uint32_t LPMEN = (1U << 0);  ///< LPMEN
        constexpr uint32_t LPMACK = (1U << 1);  ///< LPMACK
        constexpr uint32_t BESL = (4 << 2);  ///< BESL
        constexpr uint32_t REMWAKE = (1U << 6);  ///< REMWAKE
        constexpr uint32_t L1SSEN = (1U << 7);  ///< L1SSEN
        constexpr uint32_t BESLTHRS = (4 << 8);  ///< BESLTHRS
        constexpr uint32_t L1DSEN = (1U << 12);  ///< L1DSEN
        constexpr uint32_t LPMRSP = (2 << 13);  ///< LPMRSP
        constexpr uint32_t SLPSTS = (1U << 15);  ///< SLPSTS
        constexpr uint32_t L1RSMOK = (1U << 16);  ///< L1RSMOK
        constexpr uint32_t LPMCHIDX = (4 << 17);  ///< LPMCHIDX
        constexpr uint32_t LPMRCNT = (3 << 21);  ///< LPMRCNT
        constexpr uint32_t SNDLPM = (1U << 24);  ///< SNDLPM
        constexpr uint32_t LPMRCNTSTS = (3 << 25);  ///< LPMRCNTSTS
        constexpr uint32_t ENBESL = (1U << 28);  ///< ENBESL
    }

    /// HPTXFSIZ Register bits
    namespace hptxfsiz_bits {
        constexpr uint32_t PTXSA = (16 << 0);  ///< PTXSA
        constexpr uint32_t PTXFSIZ = (16 << 16);  ///< PTXFSIZ
    }

    /// DIEPTXF1 Register bits
    namespace dieptxf1_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF2 Register bits
    namespace dieptxf2_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF3 Register bits
    namespace dieptxf3_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF4 Register bits
    namespace dieptxf4_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF5 Register bits
    namespace dieptxf5_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF6 Register bits
    namespace dieptxf6_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF7 Register bits
    namespace dieptxf7_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// DIEPTXF8 Register bits
    namespace dieptxf8_bits {
        constexpr uint32_t INEPTXSA = (16 << 0);  ///< INEPTXSA
        constexpr uint32_t INEPTXFD = (16 << 16);  ///< INEPTXFD
    }

    /// HCFG Register bits
    namespace hcfg_bits {
        constexpr uint32_t FSLSPCS = (2 << 0);  ///< FSLSPCS
        constexpr uint32_t FSLSS = (1U << 2);  ///< FSLSS
    }

    /// HFIR Register bits
    namespace hfir_bits {
        constexpr uint32_t FRIVL = (16 << 0);  ///< FRIVL
        constexpr uint32_t RLDCTRL = (1U << 16);  ///< RLDCTRL
    }

    /// HFNUM Register bits
    namespace hfnum_bits {
        constexpr uint32_t FRNUM = (16 << 0);  ///< FRNUM
        constexpr uint32_t FTREM = (16 << 16);  ///< FTREM
    }

    /// HPTXSTS Register bits
    namespace hptxsts_bits {
        constexpr uint32_t PTXFSAVL = (16 << 0);  ///< PTXFSAVL
        constexpr uint32_t PTXQSAV = (8 << 16);  ///< PTXQSAV
        constexpr uint32_t PTXQTOP = (8 << 24);  ///< PTXQTOP
    }

    /// HAINT Register bits
    namespace haint_bits {
        constexpr uint32_t HAINT = (16 << 0);  ///< HAINT
    }

    /// HAINTMSK Register bits
    namespace haintmsk_bits {
        constexpr uint32_t HAINTM = (16 << 0);  ///< HAINTM
    }

    /// HPRT Register bits
    namespace hprt_bits {
        constexpr uint32_t PCSTS = (1U << 0);  ///< PCSTS
        constexpr uint32_t PCDET = (1U << 1);  ///< PCDET
        constexpr uint32_t PENA = (1U << 2);  ///< PENA
        constexpr uint32_t PENCHNG = (1U << 3);  ///< PENCHNG
        constexpr uint32_t POCA = (1U << 4);  ///< POCA
        constexpr uint32_t POCCHNG = (1U << 5);  ///< POCCHNG
        constexpr uint32_t PRES = (1U << 6);  ///< PRES
        constexpr uint32_t PSUSP = (1U << 7);  ///< PSUSP
        constexpr uint32_t PRST = (1U << 8);  ///< PRST
        constexpr uint32_t PLSTS = (2 << 10);  ///< PLSTS
        constexpr uint32_t PPWR = (1U << 12);  ///< PPWR
        constexpr uint32_t PTCTL = (4 << 13);  ///< PTCTL
        constexpr uint32_t PSPD = (2 << 17);  ///< PSPD
    }

    /// HCCHAR0 Register bits
    namespace hcchar0_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCSPLT0 Register bits
    namespace hcsplt0_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT1 Register bits
    namespace hcsplt1_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT2 Register bits
    namespace hcsplt2_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT3 Register bits
    namespace hcsplt3_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT4 Register bits
    namespace hcsplt4_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT5 Register bits
    namespace hcsplt5_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT6 Register bits
    namespace hcsplt6_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT7 Register bits
    namespace hcsplt7_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT8 Register bits
    namespace hcsplt8_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT9 Register bits
    namespace hcsplt9_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT10 Register bits
    namespace hcsplt10_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT11 Register bits
    namespace hcsplt11_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT12 Register bits
    namespace hcsplt12_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT13 Register bits
    namespace hcsplt13_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT14 Register bits
    namespace hcsplt14_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCSPLT15 Register bits
    namespace hcsplt15_bits {
        constexpr uint32_t PRTADDR = (7 << 0);  ///< Port address 			This field is the port number of the recipient transaction translator.
        constexpr uint32_t HUBADDR = (7 << 7);  ///< Hub address 			This field holds the device address of the transaction translatorâs hub.
        constexpr uint32_t XACTPOS = (2 << 14);  ///< Transaction position 			This field is used to determine whether to send all, first, middle, or last payloads with each OUT transaction.
        constexpr uint32_t COMPLSPLT = (1U << 16);  ///< Do complete split 			The application sets this bit to request the OTG host to perform a complete split transaction.
        constexpr uint32_t SPLITEN = (1U << 31);  ///< Split enable 			The application sets this bit to indicate that this channel is enabled to perform split transactions.
    }

    /// HCINT0 Register bits
    namespace hcint0_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK0 Register bits
    namespace hcintmsk0_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ0 Register bits
    namespace hctsiz0_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCDMA0 Register bits
    namespace hcdma0_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA1 Register bits
    namespace hcdma1_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA2 Register bits
    namespace hcdma2_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA3 Register bits
    namespace hcdma3_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA4 Register bits
    namespace hcdma4_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA5 Register bits
    namespace hcdma5_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA6 Register bits
    namespace hcdma6_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA7 Register bits
    namespace hcdma7_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA8 Register bits
    namespace hcdma8_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA9 Register bits
    namespace hcdma9_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA10 Register bits
    namespace hcdma10_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA11 Register bits
    namespace hcdma11_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA12 Register bits
    namespace hcdma12_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA13 Register bits
    namespace hcdma13_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA14 Register bits
    namespace hcdma14_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCDMA15 Register bits
    namespace hcdma15_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMA address 			This field holds the start address in the external memory from which the data for the endpoint must be fetched or to which it must be stored. This register is incremented on every AHB transaction.
    }

    /// HCCHAR1 Register bits
    namespace hcchar1_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT1_DEVICE Register bits
    namespace hcint1_device_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK1 Register bits
    namespace hcintmsk1_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ1 Register bits
    namespace hctsiz1_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR2 Register bits
    namespace hcchar2_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT2 Register bits
    namespace hcint2_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK2 Register bits
    namespace hcintmsk2_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ2 Register bits
    namespace hctsiz2_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR3 Register bits
    namespace hcchar3_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT3 Register bits
    namespace hcint3_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK3 Register bits
    namespace hcintmsk3_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ3 Register bits
    namespace hctsiz3_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR4 Register bits
    namespace hcchar4_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT4 Register bits
    namespace hcint4_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK4 Register bits
    namespace hcintmsk4_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ4 Register bits
    namespace hctsiz4_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR5 Register bits
    namespace hcchar5_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT5 Register bits
    namespace hcint5_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK5 Register bits
    namespace hcintmsk5_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ5 Register bits
    namespace hctsiz5_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR6 Register bits
    namespace hcchar6_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT6 Register bits
    namespace hcint6_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK6 Register bits
    namespace hcintmsk6_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ6 Register bits
    namespace hctsiz6_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR7 Register bits
    namespace hcchar7_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT7 Register bits
    namespace hcint7_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK7 Register bits
    namespace hcintmsk7_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ7 Register bits
    namespace hctsiz7_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR8 Register bits
    namespace hcchar8_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT8 Register bits
    namespace hcint8_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK8 Register bits
    namespace hcintmsk8_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ8 Register bits
    namespace hctsiz8_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR9 Register bits
    namespace hcchar9_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT9 Register bits
    namespace hcint9_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK9 Register bits
    namespace hcintmsk9_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ9 Register bits
    namespace hctsiz9_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR10 Register bits
    namespace hcchar10_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT10 Register bits
    namespace hcint10_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK10 Register bits
    namespace hcintmsk10_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ10 Register bits
    namespace hctsiz10_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCCHAR11 Register bits
    namespace hcchar11_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCCHAR12 Register bits
    namespace hcchar12_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCCHAR13 Register bits
    namespace hcchar13_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCCHAR14 Register bits
    namespace hcchar14_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCCHAR15 Register bits
    namespace hcchar15_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t EPNUM = (4 << 11);  ///< EPNUM
        constexpr uint32_t EPDIR = (1U << 15);  ///< EPDIR
        constexpr uint32_t LSDEV = (1U << 17);  ///< LSDEV
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t MCNT = (2 << 20);  ///< MCNT
        constexpr uint32_t DAD = (7 << 22);  ///< DAD
        constexpr uint32_t ODDFRM = (1U << 29);  ///< ODDFRM
        constexpr uint32_t CHDIS = (1U << 30);  ///< CHDIS
        constexpr uint32_t CHENA = (1U << 31);  ///< CHENA
    }

    /// HCINT11 Register bits
    namespace hcint11_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINT12 Register bits
    namespace hcint12_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINT13 Register bits
    namespace hcint13_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINT14 Register bits
    namespace hcint14_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINT15 Register bits
    namespace hcint15_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t CHH = (1U << 1);  ///< CHH
        constexpr uint32_t STALL = (1U << 3);  ///< STALL
        constexpr uint32_t NAK = (1U << 4);  ///< NAK
        constexpr uint32_t ACK = (1U << 5);  ///< ACK
        constexpr uint32_t TXERR = (1U << 7);  ///< TXERR
        constexpr uint32_t BBERR = (1U << 8);  ///< BBERR
        constexpr uint32_t FRMOR = (1U << 9);  ///< FRMOR
        constexpr uint32_t DTERR = (1U << 10);  ///< DTERR
    }

    /// HCINTMSK11 Register bits
    namespace hcintmsk11_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCINTMSK12 Register bits
    namespace hcintmsk12_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCINTMSK13 Register bits
    namespace hcintmsk13_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCINTMSK14 Register bits
    namespace hcintmsk14_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCINTMSK15 Register bits
    namespace hcintmsk15_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t CHHM = (1U << 1);  ///< CHHM
        constexpr uint32_t STALLM = (1U << 3);  ///< STALLM
        constexpr uint32_t NAKM = (1U << 4);  ///< NAKM
        constexpr uint32_t ACKM = (1U << 5);  ///< ACKM
        constexpr uint32_t TXERRM = (1U << 7);  ///< TXERRM
        constexpr uint32_t BBERRM = (1U << 8);  ///< BBERRM
        constexpr uint32_t FRMORM = (1U << 9);  ///< FRMORM
        constexpr uint32_t DTERRM = (1U << 10);  ///< DTERRM
    }

    /// HCTSIZ11 Register bits
    namespace hctsiz11_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCTSIZ12 Register bits
    namespace hctsiz12_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCTSIZ13 Register bits
    namespace hctsiz13_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCTSIZ14 Register bits
    namespace hctsiz14_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// HCTSIZ15 Register bits
    namespace hctsiz15_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t DPID = (2 << 29);  ///< DPID
        constexpr uint32_t DOPNG = (1U << 31);  ///< DOPNG
    }

    /// DCFG Register bits
    namespace dcfg_bits {
        constexpr uint32_t DSPD = (2 << 0);  ///< DSPD
        constexpr uint32_t NZLSOHSK = (1U << 2);  ///< NZLSOHSK
        constexpr uint32_t DAD = (7 << 4);  ///< DAD
        constexpr uint32_t PFIVL = (2 << 11);  ///< PFIVL
        constexpr uint32_t ERRATIM = (1U << 15);  ///< ERRATIM
    }

    /// DCTL Register bits
    namespace dctl_bits {
        constexpr uint32_t RWUSIG = (1U << 0);  ///< RWUSIG
        constexpr uint32_t SDIS = (1U << 1);  ///< SDIS
        constexpr uint32_t GINSTS = (1U << 2);  ///< GINSTS
        constexpr uint32_t GONSTS = (1U << 3);  ///< GONSTS
        constexpr uint32_t TCTL = (3 << 4);  ///< TCTL
        constexpr uint32_t SGINAK = (1U << 7);  ///< SGINAK
        constexpr uint32_t CGINAK = (1U << 8);  ///< CGINAK
        constexpr uint32_t SGONAK = (1U << 9);  ///< SGONAK
        constexpr uint32_t CGONAK = (1U << 10);  ///< CGONAK
        constexpr uint32_t POPRGDNE = (1U << 11);  ///< POPRGDNE
        constexpr uint32_t DSBESLRJCT = (1U << 18);  ///< DSBESLRJCT
    }

    /// DSTS Register bits
    namespace dsts_bits {
        constexpr uint32_t SUSPSTS = (1U << 0);  ///< SUSPSTS
        constexpr uint32_t ENUMSPD = (2 << 1);  ///< ENUMSPD
        constexpr uint32_t EERR = (1U << 3);  ///< EERR
        constexpr uint32_t FNSOF = (14 << 8);  ///< FNSOF
        constexpr uint32_t DEVLNSTS = (2 << 22);  ///< DEVLNSTS
    }

    /// DIEPMSK Register bits
    namespace diepmsk_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t EPDM = (1U << 1);  ///< EPDM
        constexpr uint32_t AHBERRM = (1U << 2);  ///< AHBERRM
        constexpr uint32_t TOM = (1U << 3);  ///< TOM
        constexpr uint32_t ITTXFEMSK = (1U << 4);  ///< ITTXFEMSK
        constexpr uint32_t INEPNMM = (1U << 5);  ///< INEPNMM
        constexpr uint32_t INEPNEM = (1U << 6);  ///< INEPNEM
        constexpr uint32_t TXFURM = (1U << 8);  ///< TXFURM
        constexpr uint32_t NAKM = (1U << 13);  ///< NAKM
    }

    /// DOEPMSK Register bits
    namespace doepmsk_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t EPDM = (1U << 1);  ///< EPDM
        constexpr uint32_t AHBERRM = (1U << 2);  ///< AHBERRM
        constexpr uint32_t STUPM = (1U << 3);  ///< STUPM
        constexpr uint32_t OTEPDM = (1U << 4);  ///< OTEPDM
        constexpr uint32_t STSPHSRXM = (1U << 5);  ///< STSPHSRXM
        constexpr uint32_t B2BSTUPM = (1U << 6);  ///< B2BSTUPM
        constexpr uint32_t OUTPKTERRM = (1U << 8);  ///< OUTPKTERRM
        constexpr uint32_t BERRM = (1U << 12);  ///< BERRM
        constexpr uint32_t NAKMSK = (1U << 13);  ///< NAKMSK
        constexpr uint32_t NYETMSK = (1U << 14);  ///< NYETMSK
    }

    /// DAINT Register bits
    namespace daint_bits {
        constexpr uint32_t IEPINT = (16 << 0);  ///< IEPINT
        constexpr uint32_t OEPINT = (16 << 16);  ///< OEPINT
    }

    /// DAINTMSK Register bits
    namespace daintmsk_bits {
        constexpr uint32_t IEPM = (16 << 0);  ///< IEPM
        constexpr uint32_t OEPM = (16 << 16);  ///< OEPM
    }

    /// DVBUSDIS Register bits
    namespace dvbusdis_bits {
        constexpr uint32_t VBUSDT = (16 << 0);  ///< VBUSDT
    }

    /// DVBUSPULSE Register bits
    namespace dvbuspulse_bits {
        constexpr uint32_t DVBUSP = (16 << 0);  ///< DVBUSP
    }

    /// DTHRCTL Register bits
    namespace dthrctl_bits {
        constexpr uint32_t NONISOTHREN = (1U << 0);  ///< Nonisochronous IN endpoints threshold enable 			When this bit is set, the core enables thresholding for nonisochronous IN endpoints.
        constexpr uint32_t ISOTHREN = (1U << 1);  ///< ISO IN endpoint threshold enable 			When this bit is set, the core enables thresholding for isochronous IN endpoints.
        constexpr uint32_t TXTHRLEN = (9 << 2);  ///< Transmit threshold length 			This field specifies the transmit thresholding size in 32-bit words. This field specifies the amount of data in bytes to be in the corresponding endpoint transmit FIFO, before the core can start transmitting on the USB. The threshold length has to be at least eight 32-bit words. This field controls both isochronous and nonisochronous IN endpoint thresholds. The recommended value for TXTHRLEN is to be the same as the programmed AHB burst length (HBSTLEN bit in OTG_GAHBCFG).
        constexpr uint32_t RXTHREN = (1U << 16);  ///< Receive threshold enable 			When this bit is set, the core enables thresholding in the receive direction.
        constexpr uint32_t RXTHRLEN = (9 << 17);  ///< Receive threshold length 			This field specifies the receive thresholding size in 32-bit words. This field also specifies the amount of data received on the USB before the core can start transmitting on the AHB. The threshold length has to be at least eight 32-bit words. The recommended value for RXTHRLEN is to be the same as the programmed AHB burst length (HBSTLEN bit in OTG_GAHBCFG).
        constexpr uint32_t ARPEN = (1U << 27);  ///< Arbiter parking enable 			This bit controls internal DMA arbiter parking for IN endpoints. When thresholding is enabled and this bit is set to one, then the arbiter parks on the IN endpoint for which there is a token received on the USB. This is done to avoid getting into underrun conditions. By default parking is enabled.
    }

    /// DIEPEMPMSK Register bits
    namespace diepempmsk_bits {
        constexpr uint32_t INEPTXFEM = (16 << 0);  ///< INEPTXFEM
    }

    /// HS_DOEPEACHMSK1 Register bits
    namespace hs_doepeachmsk1_bits {
        constexpr uint32_t XFRCM = (1U << 0);  ///< XFRCM
        constexpr uint32_t EPDM = (1U << 1);  ///< EPDM
        constexpr uint32_t AHBERRM = (1U << 2);  ///< AHBERRM
        constexpr uint32_t STUPM = (1U << 3);  ///< STUPM
        constexpr uint32_t OTEPDM = (1U << 4);  ///< OTEPDM
        constexpr uint32_t B2BSTUPM = (1U << 6);  ///< B2BSTUPM
        constexpr uint32_t OUTPKTERRM = (1U << 8);  ///< OUTPKTERRM
        constexpr uint32_t BNAM = (1U << 9);  ///< BNAM
        constexpr uint32_t BERRM = (1U << 12);  ///< BERRM
        constexpr uint32_t NAKMSK = (1U << 13);  ///< NAKMSK
        constexpr uint32_t NYETMSK = (1U << 14);  ///< NYETMSK
    }

    /// DIEPCTL0 Register bits
    namespace diepctl0_bits {
        constexpr uint32_t MPSIZ = (2 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT0 Register bits
    namespace diepint0_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ0 Register bits
    namespace dieptsiz0_bits {
        constexpr uint32_t XFRSIZ = (7 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (2 << 19);  ///< PKTCNT
    }

    /// DTXFSTS0 Register bits
    namespace dtxfsts0_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL1 Register bits
    namespace diepctl1_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT1 Register bits
    namespace diepint1_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ1 Register bits
    namespace dieptsiz1_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DIEPDMA1 Register bits
    namespace diepdma1_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DTXFSTS1 Register bits
    namespace dtxfsts1_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL2 Register bits
    namespace diepctl2_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT2 Register bits
    namespace diepint2_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ2 Register bits
    namespace dieptsiz2_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DIEPDMA2 Register bits
    namespace diepdma2_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DTXFSTS2 Register bits
    namespace dtxfsts2_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL3 Register bits
    namespace diepctl3_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT3 Register bits
    namespace diepint3_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ3 Register bits
    namespace dieptsiz3_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DIEPDMA3 Register bits
    namespace diepdma3_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DTXFSTS3 Register bits
    namespace dtxfsts3_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL4 Register bits
    namespace diepctl4_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT4 Register bits
    namespace diepint4_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ4 Register bits
    namespace dieptsiz4_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DIEPDMA4 Register bits
    namespace diepdma4_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DTXFSTS4 Register bits
    namespace dtxfsts4_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPCTL5 Register bits
    namespace diepctl5_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t TXFNUM = (4 << 22);  ///< TXFNUM
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SODDFRM = (1U << 29);  ///< SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DIEPINT5 Register bits
    namespace diepint5_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ5 Register bits
    namespace dieptsiz5_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DIEPDMA5 Register bits
    namespace diepdma5_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DTXFSTS5 Register bits
    namespace dtxfsts5_bits {
        constexpr uint32_t INEPTFSAV = (16 << 0);  ///< INEPTFSAV
    }

    /// DIEPINT6 Register bits
    namespace diepint6_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t TXFIFOUDRN = (1U << 8);  ///< TXFIFOUDRN
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ6 Register bits
    namespace dieptsiz6_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DIEPDMA6 Register bits
    namespace diepdma6_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DIEPINT7 Register bits
    namespace diepint7_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t TXFIFOUDRN = (1U << 8);  ///< TXFIFOUDRN
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ7 Register bits
    namespace dieptsiz7_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DIEPDMA7 Register bits
    namespace diepdma7_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DIEPINT8 Register bits
    namespace diepint8_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t TOC = (1U << 3);  ///< TOC
        constexpr uint32_t ITTXFE = (1U << 4);  ///< ITTXFE
        constexpr uint32_t INEPNM = (1U << 5);  ///< INEPNM
        constexpr uint32_t INEPNE = (1U << 6);  ///< INEPNE
        constexpr uint32_t TXFE = (1U << 7);  ///< TXFE
        constexpr uint32_t TXFIFOUDRN = (1U << 8);  ///< TXFIFOUDRN
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t PKTDRPSTS = (1U << 11);  ///< PKTDRPSTS
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
    }

    /// DIEPTSIZ8 Register bits
    namespace dieptsiz8_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t MCNT = (2 << 29);  ///< MCNT
    }

    /// DIEPDMA8 Register bits
    namespace diepdma8_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL0 Register bits
    namespace doepctl0_bits {
        constexpr uint32_t MPSIZ = (2 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT0 Register bits
    namespace doepint0_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ0 Register bits
    namespace doeptsiz0_bits {
        constexpr uint32_t XFRSIZ = (7 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (1U << 19);  ///< PKTCNT
        constexpr uint32_t STUPCNT = (2 << 29);  ///< STUPCNT
    }

    /// DOEPDMA0 Register bits
    namespace doepdma0_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL1 Register bits
    namespace doepctl1_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT1 Register bits
    namespace doepint1_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ1 Register bits
    namespace doeptsiz1_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPDMA1 Register bits
    namespace doepdma1_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL2 Register bits
    namespace doepctl2_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT2 Register bits
    namespace doepint2_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ2 Register bits
    namespace doeptsiz2_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPDMA2 Register bits
    namespace doepdma2_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL3 Register bits
    namespace doepctl3_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT3 Register bits
    namespace doepint3_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ3 Register bits
    namespace doeptsiz3_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPDMA3 Register bits
    namespace doepdma3_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL4 Register bits
    namespace doepctl4_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT4 Register bits
    namespace doepint4_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ4 Register bits
    namespace doeptsiz4_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPDMA4 Register bits
    namespace doepdma4_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL5 Register bits
    namespace doepctl5_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT5 Register bits
    namespace doepint5_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ5 Register bits
    namespace doeptsiz5_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPDMA5 Register bits
    namespace doepdma5_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL6 Register bits
    namespace doepctl6_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT6 Register bits
    namespace doepint6_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ6 Register bits
    namespace doeptsiz6_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPDMA6 Register bits
    namespace doepdma6_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL7 Register bits
    namespace doepctl7_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT7 Register bits
    namespace doepint7_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ7 Register bits
    namespace doeptsiz7_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPDMA7 Register bits
    namespace doepdma7_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// DOEPCTL8 Register bits
    namespace doepctl8_bits {
        constexpr uint32_t MPSIZ = (11 << 0);  ///< MPSIZ
        constexpr uint32_t USBAEP = (1U << 15);  ///< USBAEP
        constexpr uint32_t EONUM_DPIP = (1U << 16);  ///< EONUM_DPIP
        constexpr uint32_t NAKSTS = (1U << 17);  ///< NAKSTS
        constexpr uint32_t EPTYP = (2 << 18);  ///< EPTYP
        constexpr uint32_t SNPM = (1U << 20);  ///< SNPM
        constexpr uint32_t STALL = (1U << 21);  ///< STALL
        constexpr uint32_t CNAK = (1U << 26);  ///< CNAK
        constexpr uint32_t SNAK = (1U << 27);  ///< SNAK
        constexpr uint32_t SD0PID_SEVNFRM = (1U << 28);  ///< SD0PID_SEVNFRM
        constexpr uint32_t SD1PID_SODDFRM = (1U << 29);  ///< SD1PID_SODDFRM
        constexpr uint32_t EPDIS = (1U << 30);  ///< EPDIS
        constexpr uint32_t EPENA = (1U << 31);  ///< EPENA
    }

    /// DOEPINT8 Register bits
    namespace doepint8_bits {
        constexpr uint32_t XFRC = (1U << 0);  ///< XFRC
        constexpr uint32_t EPDISD = (1U << 1);  ///< EPDISD
        constexpr uint32_t AHBERR = (1U << 2);  ///< AHBERR
        constexpr uint32_t STUP = (1U << 3);  ///< STUP
        constexpr uint32_t OTEPDIS = (1U << 4);  ///< OTEPDIS
        constexpr uint32_t STSPHSRX = (1U << 5);  ///< STSPHSRX
        constexpr uint32_t B2BSTUP = (1U << 6);  ///< B2BSTUP
        constexpr uint32_t OUTPKTERR = (1U << 8);  ///< OUTPKTERR
        constexpr uint32_t BNA = (1U << 9);  ///< BNA
        constexpr uint32_t BERR = (1U << 12);  ///< BERR
        constexpr uint32_t NAK = (1U << 13);  ///< NAK
        constexpr uint32_t NYET = (1U << 14);  ///< NYET
        constexpr uint32_t STPKTRX = (1U << 15);  ///< STPKTRX
    }

    /// DOEPTSIZ8 Register bits
    namespace doeptsiz8_bits {
        constexpr uint32_t XFRSIZ = (19 << 0);  ///< XFRSIZ
        constexpr uint32_t PKTCNT = (10 << 19);  ///< PKTCNT
        constexpr uint32_t RXDPID_STUPCNT = (2 << 29);  ///< RXDPID_STUPCNT
    }

    /// DOEPDMA8 Register bits
    namespace doepdma8_bits {
        constexpr uint32_t DMAADDR = (32 << 0);  ///< DMAADDR
    }

    /// PCGCCTL Register bits
    namespace pcgcctl_bits {
        constexpr uint32_t STPPCLK = (1U << 0);  ///< STPPCLK
        constexpr uint32_t GATEHCLK = (1U << 1);  ///< GATEHCLK
        constexpr uint32_t PHYSUSP = (1U << 4);  ///< PHYSUSP
        constexpr uint32_t ENL1GTG = (1U << 5);  ///< ENL1GTG
        constexpr uint32_t PHYSLEEP = (1U << 6);  ///< PHYSLEEP
        constexpr uint32_t SUSP = (1U << 7);  ///< SUSP
    }

}

// ============================================================================
// PKA Peripheral
// ============================================================================

namespace pka {
    /// Base addresses
    constexpr uint32_t PKA_BASE = 0x420C2000;

    /// PKA Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - Control register
        volatile uint32_t SR;  ///< Offset: 0x04 - PKA status register
        volatile uint32_t CLRFR;  ///< Offset: 0x08 - PKA clear flag register
    };

    /// Peripheral instances
    inline Registers* PKA = reinterpret_cast<Registers*>(PKA_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t OPERRIE = (1U << 21);  ///< Operation error interrupt enable
        constexpr uint32_t ADDRERRIE = (1U << 20);  ///< Address error interrupt enable
        constexpr uint32_t RAMERRIE = (1U << 19);  ///< RAM error interrupt enable
        constexpr uint32_t PROCENDIE = (1U << 17);  ///< End of operation interrupt enable
        constexpr uint32_t MODE = (6 << 8);  ///< PKA Operation Mode
        constexpr uint32_t START = (1U << 1);  ///< Start the operation
        constexpr uint32_t EN = (1U << 0);  ///< Peripheral Enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t INITOK = (1U << 0);  ///< INITOK
        constexpr uint32_t BUSY = (1U << 16);  ///< PKA operation is in progress
        constexpr uint32_t PROCENDF = (1U << 17);  ///< PKA End of Operation flag
        constexpr uint32_t RAMERRF = (1U << 19);  ///< RAMERRF
        constexpr uint32_t ADDRERRF = (1U << 20);  ///< ADDRERRF
        constexpr uint32_t OPERRF = (1U << 21);  ///< OPERRF
    }

    /// CLRFR Register bits
    namespace clrfr_bits {
        constexpr uint32_t PROCENDFC = (1U << 17);  ///< Clear PKA End of Operation flag
        constexpr uint32_t RAMERRFC = (1U << 19);  ///< RAMERRFC
        constexpr uint32_t ADDRERRFC = (1U << 20);  ///< ADDRERRFC
        constexpr uint32_t OPERRFC = (1U << 21);  ///< OPERRFC
    }

}

// ============================================================================
// PSSI Peripheral
// ============================================================================

namespace pssi {
    /// Base addresses
    constexpr uint32_t PSSI_BASE = 0x4202C400;

    /// PSSI Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - PSSI control register
        volatile uint32_t SR;  ///< Offset: 0x04 - PSSI status register
        volatile uint32_t RIS;  ///< Offset: 0x08 - PSSI raw interrupt status register
        volatile uint32_t IER;  ///< Offset: 0x0C - PSSI interrupt enable register
        volatile uint32_t MIS;  ///< Offset: 0x10 - PSSI masked interrupt status register
        volatile uint32_t ICR;  ///< Offset: 0x14 - PSSI interrupt clear register
        volatile uint32_t DR;  ///< Offset: 0x28 - PSSI data register
    };

    /// Peripheral instances
    inline Registers* PSSI = reinterpret_cast<Registers*>(PSSI_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CKPOL = (1U << 5);  ///< Parallel data clock polarity 		This bit configures the capture edge of the parallel clock or the edge used for driving outputs, depending on OUTEN.
        constexpr uint32_t DEPOL = (1U << 6);  ///< Data enable (PSSI_DE) polarity 		This bit indicates the level on the PSSI_DE pin when the data are not valid on the parallel interface.
        constexpr uint32_t RDYPOL = (1U << 8);  ///< Ready (PSSI_RDY) polarity 		This bit indicates the level on the PSSI_RDY pin when the data are not valid on the parallel interface.
        constexpr uint32_t EDM = (2 << 10);  ///< Extended data mode
        constexpr uint32_t ENABLE = (1U << 14);  ///< PSSI enable 		The contents of the FIFO are flushed when ENABLE is cleared to 0. 		Note: When ENABLE=1, the content of PSSI_CR must not be changed, except for the ENABLE bit itself. All configuration bits can change as soon as ENABLE changes from 0 to 1. 		The DMA controller and all PSSI configuration registers must be programmed correctly before setting the ENABLE bit to 1. 		The ENABLE bit and the DCMI ENABLE bit (bit 15 of DCMI_CR) must not be set to 1 at the same time.
        constexpr uint32_t DERDYCFG = (3 << 18);  ///< Data enable and ready configuration 		When the PSSI_RDY function is mapped to the PSSI_DE pin (settings 101 or 111), it is still the RDYPOL bit which determines its polarity. Similarly, when the PSSI_DE function is mapped to the PSSI_RDY pin (settings 110 or 111), it is still the DEPOL bit which determines its polarity.
        constexpr uint32_t DMAEN = (1U << 30);  ///< DMA enable bit
        constexpr uint32_t OUTEN = (1U << 31);  ///< Data direction selection bit
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t RTT4B = (1U << 2);  ///< RTT4B
        constexpr uint32_t RTT1B = (1U << 3);  ///< RTT1B
    }

    /// RIS Register bits
    namespace ris_bits {
        constexpr uint32_t OVR_RIS = (1U << 1);  ///< OVR_RIS
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t OVR_IE = (1U << 1);  ///< OVR_IE
    }

    /// MIS Register bits
    namespace mis_bits {
        constexpr uint32_t OVR_MIS = (1U << 1);  ///< OVR_MIS
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t OVR_ISC = (1U << 1);  ///< OVR_ISC
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t BYTE0 = (8 << 0);  ///< Data byte 0
        constexpr uint32_t BYTE1 = (8 << 8);  ///< Data byte 1
        constexpr uint32_t BYTE2 = (8 << 16);  ///< Data byte 2
        constexpr uint32_t BYTE3 = (8 << 24);  ///< Data byte 3
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x46020800;
    constexpr uint32_t SEC_PWR_BASE = 0x56020800;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWR_CR1;  ///< Offset: 0x00 - PWR control register 1
        volatile uint32_t PWR_CR2;  ///< Offset: 0x04 - PWR control register 2
        volatile uint32_t PWR_CR3;  ///< Offset: 0x08 - PWR control register 3
        volatile uint32_t PWR_VOSR;  ///< Offset: 0x0C - PWR voltage scaling register
        volatile uint32_t PWR_SVMCR;  ///< Offset: 0x10 - PWR supply voltage monitoring control register
        volatile uint32_t PWR_WUCR1;  ///< Offset: 0x14 - PWR wakeup control register 1
        volatile uint32_t PWR_WUCR2;  ///< Offset: 0x18 - PWR wakeup control register 2
        volatile uint32_t PWR_WUCR3;  ///< Offset: 0x1C - PWR wakeup control register 3
        volatile uint32_t PWR_BDCR1;  ///< Offset: 0x20 - PWR Backup domain control register 1
        volatile uint32_t PWR_BDCR2;  ///< Offset: 0x24 - PWR Backup domain control register 2
        volatile uint32_t PWR_DBPR;  ///< Offset: 0x28 - PWR disable Backup domain register
        volatile uint32_t PWR_UCPDR;  ///< Offset: 0x2C - PWR USB Type-C™ and Power Delivery register
        volatile uint32_t PWR_SECCFGR;  ///< Offset: 0x30 - PWR security configuration register
        volatile uint32_t PWR_PRIVCFGR;  ///< Offset: 0x34 - PWR privilege control register
        volatile uint32_t PWR_SR;  ///< Offset: 0x38 - PWR status register
        volatile uint32_t PWR_SVMSR;  ///< Offset: 0x3C - PWR supply voltage monitoring status register
        volatile uint32_t PWR_BDSR;  ///< Offset: 0x40 - PWR Backup domain status register
        volatile uint32_t PWR_WUSR;  ///< Offset: 0x44 - PWR wakeup status register
        volatile uint32_t PWR_WUSCR;  ///< Offset: 0x48 - PWR wakeup status clear register
        volatile uint32_t PWR_APCR;  ///< Offset: 0x4C - PWR apply pull configuration register
        volatile uint32_t PWR_PUCRA;  ///< Offset: 0x50 - PWR port A pull-up control register
        volatile uint32_t PWR_PDCRA;  ///< Offset: 0x54 - PWR port A pull-down control register
        volatile uint32_t PWR_PUCRB;  ///< Offset: 0x58 - PWR port B pull-up control register
        volatile uint32_t PWR_PDCRB;  ///< Offset: 0x5C - PWR port B pull-down control register
        volatile uint32_t PWR_PUCRC;  ///< Offset: 0x60 - Power port C pull up control register
        volatile uint32_t PWR_PDCRC;  ///< Offset: 0x64 - PWR port C pull-down control register
        volatile uint32_t PWR_PUCRD;  ///< Offset: 0x68 - PWR port D pull-up control register
        volatile uint32_t PWR_PDCRD;  ///< Offset: 0x6C - PWR port D pull-down control register
        volatile uint32_t PWR_PUCRE;  ///< Offset: 0x70 - PWR port E pull-up control register
        volatile uint32_t PWR_PDCRE;  ///< Offset: 0x74 - PWR port E pull-down control register
        volatile uint32_t PWR_PUCRF;  ///< Offset: 0x78 - PWR port F pull-up control register
        volatile uint32_t PWR_PDCRF;  ///< Offset: 0x7C - PWR port F pull-down control register
        volatile uint32_t PWR_PUCRG;  ///< Offset: 0x80 - PWR port G pull-up control register
        volatile uint32_t PWR_PDCRG;  ///< Offset: 0x84 - PWR port G pull-down control register
        volatile uint32_t PWR_PUCRH;  ///< Offset: 0x88 - PWR port H pull-up control register
        volatile uint32_t PWR_PDCRH;  ///< Offset: 0x8C - PWR port H pull-down control register
        volatile uint32_t PWR_PUCRI;  ///< Offset: 0x90 - PWR port I pull-up control register
        volatile uint32_t PWR_PDCRI;  ///< Offset: 0x94 - PWR port I pull-down control register
        volatile uint32_t PWR_PUCRJ;  ///< Offset: 0x98 - PWR port J pull-up control register
        volatile uint32_t PWR_PDCRJ;  ///< Offset: 0x9C - PWR port J pull-down control register
        volatile uint32_t PWR_CR4;  ///< Offset: 0xA8 - PWR control register 4
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);
    inline Registers* SEC_PWR = reinterpret_cast<Registers*>(SEC_PWR_BASE);

    // Bit definitions
    /// PWR_CR1 Register bits
    namespace pwr_cr1_bits {
        constexpr uint32_t LPMS = (3 << 0);  ///< Low-power mode selection These bits select the low-power mode entered when the CPU enters the Deepsleep mode. 10x: Standby mode (Standby mode also entered if LPMS = 11X in PWR_CR1 with BREN = 1 in PWR_BDCR1) 11x: Shutdown mode if BREN = 0 in PWR_BDCR1
        constexpr uint32_t RRSB1 = (1U << 5);  ///< SRAM2 page 1 retention in Stop 3 and Standby modes This bit is used to keep the SRAM2 page 1 content in Stop 3 and Standby modes. The SRAM2 page 1 corresponds to the first 8 Kbytes of the SRAM2 (from SRAM2 base address to SRAM2 base address + 0x1FFF). Note: This bit has no effect in Shutdown mode.
        constexpr uint32_t RRSB2 = (1U << 6);  ///< SRAM2 page 2 retention in Stop 3 and Standby modes This bit is used to keep the SRAM2 page 2 content in Stop 3 and Standby modes. The SRAM2 page 2 corresponds to the last 56 Kbytes of the SRAM2 (from SRAM2 base address + 0x2000 to SRAM2 base address + 0xFFFF). Note: This bit has no effect in Shutdown mode.
        constexpr uint32_t ULPMEN = (1U << 7);  ///< BOR ultra-low power mode This bit is used to reduce the consumption by configuring the BOR in discontinuous mode. This bit must be set to reach the lowest power consumption in the low-power modes.
        constexpr uint32_t SRAM1PD = (1U << 8);  ///< SRAM1 power down This bit is used to reduce the consumption by powering off the SRAM1.
        constexpr uint32_t SRAM2PD = (1U << 9);  ///< SRAM2 power down This bit is used to reduce the consumption by powering off the SRAM2.
        constexpr uint32_t SRAM3PD = (1U << 10);  ///< SRAM3 power down This bit is used to reduce the consumption by powering off the SRAM3.
        constexpr uint32_t SRAM4PD = (1U << 11);  ///< SRAM4 power down This bit is used to reduce the consumption by powering off the SRAM4.
        constexpr uint32_t SRAM5PD = (1U << 12);  ///< SRAM5 power down This bit is used to reduce the consumption by powering off the SRAM5. Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
    }

    /// PWR_CR2 Register bits
    namespace pwr_cr2_bits {
        constexpr uint32_t SRAM1PDS1 = (1U << 0);  ///< SRAM1 page 1 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM1PDS2 = (1U << 1);  ///< SRAM1 page 2 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM1PDS3 = (1U << 2);  ///< SRAM1 page 3 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM2PDS1 = (1U << 4);  ///< SRAM2 page 1 (8 Kbytes) power-down in Stop modes (Stop 0, 1, 2) Note: The SRAM2 page 1 retention in Stop 3 is controlled by RRSB1 bit in PWR_CR1.
        constexpr uint32_t SRAM2PDS2 = (1U << 5);  ///< SRAM2 page 2 (56 Kbytes) power-down in Stop modes (Stop 0, 1, 2) Note: The SRAM2 page 2 retention in Stop 3 is controlled by RRSB2 bit in PWR_CR1.
        constexpr uint32_t SRAM4PDS = (1U << 6);  ///< SRAM4 power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t DC2RAMPDS = (1U << 7);  ///< DCACHE2 SRAM power-down in Stop modes (Stop 0, 1, 2, 3) Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
        constexpr uint32_t ICRAMPDS = (1U << 8);  ///< ICACHE SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t DC1RAMPDS = (1U << 9);  ///< DCACHE1 SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t DMA2DRAMPDS = (1U << 10);  ///< DMA2D SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t PRAMPDS = (1U << 11);  ///< FMAC, FDCAN and USB peripherals SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t PKARAMPDS = (1U << 12);  ///< PKA32 SRAM power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM4FWU = (1U << 13);  ///< SRAM4 fast wakeup from Stop 0, Stop 1 and Stop 2 modes This bit is used to obtain the best trade-off between low-power consumption and wakeup time. SRAM4 wakeup time increases the wakeup time when exiting Stop 0, 1 and 2 modes, and also increases the LPDMA access time to SRAM4 during Stop modes.
        constexpr uint32_t FLASHFWU = (1U << 14);  ///< Flash memory fast wakeup from Stop 0 and Stop 1 modes This bit is used to obtain the best trade-off between low-power consumption and wakeup time when exiting the Stop 0 or Stop 1 modes. When this bit is set, the Flash memory remains in normal mode in Stop 0 and Stop 1 modes, which offers a faster startup time with higher consumption.
        constexpr uint32_t SRAM3PDS1 = (1U << 16);  ///< SRAM3 page 1 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS2 = (1U << 17);  ///< SRAM3 page 2 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS3 = (1U << 18);  ///< SRAM3 page 3 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS4 = (1U << 19);  ///< SRAM3 page 4 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS5 = (1U << 20);  ///< SRAM3 page 5 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS6 = (1U << 21);  ///< SRAM3 page 6 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS7 = (1U << 22);  ///< SRAM3 page 7 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t SRAM3PDS8 = (1U << 23);  ///< SRAM3 page 8 (64 Kbytes) power-down in Stop modes (Stop 0, 1, 2, 3)
        constexpr uint32_t GPRAMPDS = (1U << 24);  ///< Graphic peripherals (LTDC, GFXMMU) SRAM power-down in Stop modes (Stop 0, 1, 2, 3) Note: LTDC SRAM content is always lost in Stop 2 and Stop 3 modes. It can be retained only in Stop 0 and Stop 1 modes. This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
        constexpr uint32_t DSIRAMPDS = (1U << 25);  ///< DSI SRAM power-down in Stop modes (Stop 0, 1) DSI SRAM content is always lost in Stop 2 and Stop 3 modes. Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
        constexpr uint32_t SRDRUN = (1U << 31);  ///< SmartRun domain in Run mode
    }

    /// PWR_CR3 Register bits
    namespace pwr_cr3_bits {
        constexpr uint32_t REGSEL = (1U << 1);  ///< Regulator selection Note: REGSEL is reserved and must be kept at reset value in packages without SMPS.
        constexpr uint32_t FSTEN = (1U << 2);  ///< Fast soft start
    }

    /// PWR_VOSR Register bits
    namespace pwr_vosr_bits {
        constexpr uint32_t USBBOOSTRDY = (1U << 13);  ///< USB EPOD booster ready This bit is set to 1 by hardware when the power booster startup time is reached. The USB clock can be provided only after this bit is set. Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
        constexpr uint32_t BOOSTRDY = (1U << 14);  ///< EPOD booster ready This bit is set to 1 by hardware when the power booster startup time is reached. The system clock frequency can be switched higher than 50 MHz only after this bit is set.
        constexpr uint32_t VOSRDY = (1U << 15);  ///< Ready bit for VCORE voltage scaling output selection
        constexpr uint32_t VOS = (2 << 16);  ///< Voltage scaling range selection This field is protected against non-secure access when SYSCLKSEC = 1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC = 1 in RCC_SECCFGR and SPRIV = 1 in PWR_PRIVCFGR, or when SYSCLKSEC = 0 and NSPRIV = 1.
        constexpr uint32_t BOOSTEN = (1U << 18);  ///< EPOD booster enable This bit is protected against non-secure access when SYSCLKSEC = 1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC = 1 in RCC_SECCFGR and SPRIV = 1 in PWR_PRIVCFGR, or when SYSCLKSEC = 0 and NSPRIV = 1. This bit must be set in range 1 and range 2 before increasing the system clock frequency above 50 MHz. This bit is reset when going into Stop modes (0, 1, 2, 3).
        constexpr uint32_t USBPWREN = (1U << 19);  ///< USB power enable This bit is protected against non-secure access when SYSCLKSEC = 1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC = 1 in RCC_SECCFGR and SPRIV = 1 in PWR_PRIVCFGR, or when SYSCLKSEC = 0 and NSPRIV = 1. Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
        constexpr uint32_t USBBOOSTEN = (1U << 20);  ///< USB EPOD booster enable This bit is protected against non-secure access when SYSCLKSEC = 1 in RCC_SECCFGR. It is protected against unprivileged access when SYSCLKSEC = 1 in RCC_SECCFGR and SPRIV = 1 in PWR_PRIVCFGR, or when SYSCLKSEC = 0 and NSPRIV = 1. This bit must be set in range 1 and range 2 before enabling the USB peripheral. This bit is reset when going into Stop modes (0, 1, 2, 3). Note: This bit is only available in STM32U59x/5Ax. It is reserved in STM32U575/585.
    }

    /// PWR_SVMCR Register bits
    namespace pwr_svmcr_bits {
        constexpr uint32_t PVDE = (1U << 4);  ///< Power voltage detector enable
        constexpr uint32_t PVDLS = (3 << 5);  ///< Power voltage detector level selection These bits select the voltage threshold detected by the power voltage detector:
        constexpr uint32_t UVMEN = (1U << 24);  ///< VDDUSB independent USB voltage monitor enable
        constexpr uint32_t IO2VMEN = (1U << 25);  ///< VDDIO2 independent I/Os voltage monitor enable
        constexpr uint32_t AVM1EN = (1U << 26);  ///< VDDA independent analog supply voltage monitor 1 enable (1.6 V threshold)
        constexpr uint32_t AVM2EN = (1U << 27);  ///< VDDA independent analog supply voltage monitor 2 enable (1.8 V threshold)
        constexpr uint32_t USV = (1U << 28);  ///< VDDUSB independent USB supply valid This bit is used to validate the VDDUSB supply for electrical and logical isolation purpose. Setting this bit is mandatory to use the USB OTG peripheral. If VDDUSB is not always present in the application, the VDDUSB voltage monitor can be used to determine whether this supply is ready or not.
        constexpr uint32_t IO2SV = (1U << 29);  ///< VDDIO2 independent I/Os supply valid This bit is used to validate the VDDIO2 supply for electrical and logical isolation purpose. Setting this bit is mandatory to use PG[15:2]. If VDDIO2 is not always present in the application, the VDDIO2 voltage monitor can be used to determine whether this supply is ready or not.
        constexpr uint32_t ASV = (1U << 30);  ///< VDDA independent analog supply valid This bit is used to validate the VDDA supply for electrical and logical isolation purpose. Setting this bit is mandatory to use the analog peripherals. If VDDA is not always present in the application, the VDDA voltage monitor can be used to determine whether this supply is ready or not.
    }

    /// PWR_WUCR1 Register bits
    namespace pwr_wucr1_bits {
        constexpr uint32_t WUPEN1 = (1U << 0);  ///< Wakeup pin WKUP1 enable
        constexpr uint32_t WUPEN2 = (1U << 1);  ///< Wakeup pin WKUP2 enable
        constexpr uint32_t WUPEN3 = (1U << 2);  ///< Wakeup pin WKUP3 enable
        constexpr uint32_t WUPEN4 = (1U << 3);  ///< Wakeup pin WKUP4 enable
        constexpr uint32_t WUPEN5 = (1U << 4);  ///< Wakeup pin WKUP5 enable
        constexpr uint32_t WUPEN6 = (1U << 5);  ///< Wakeup pin WKUP6 enable
        constexpr uint32_t WUPEN7 = (1U << 6);  ///< Wakeup pin WKUP7 enable
        constexpr uint32_t WUPEN8 = (1U << 7);  ///< Wakeup pin WKUP8 enable
    }

    /// PWR_WUCR2 Register bits
    namespace pwr_wucr2_bits {
        constexpr uint32_t WUPP1 = (1U << 0);  ///< Wakeup pin WKUP1 polarity. This bit must be configured when WUPEN1 = 0.
        constexpr uint32_t WUPP2 = (1U << 1);  ///< Wakeup pin WKUP2 polarity This bit must be configured when WUPEN2 = 0.
        constexpr uint32_t WUPP3 = (1U << 2);  ///< Wakeup pin WKUP3 polarity This bit must be configured when WUPEN3 = 0.
        constexpr uint32_t WUPP4 = (1U << 3);  ///< Wakeup pin WKUP4 polarity This bit must be configured when WUPEN4 = 0.
        constexpr uint32_t WUPP5 = (1U << 4);  ///< Wakeup pin WKUP5 polarity This bit must be configured when WUPEN5 = 0.
        constexpr uint32_t WUPP6 = (1U << 5);  ///< Wakeup pin WKUP6 polarity This bit must be configured when WUPEN6 = 0.
        constexpr uint32_t WUPP7 = (1U << 6);  ///< Wakeup pin WKUP7 polarity This bit must be configured when WUPEN7 = 0.
        constexpr uint32_t WUPP8 = (1U << 7);  ///< Wakeup pin WKUP8 polarity This bit must be configured when WUPEN8 = 0.
    }

    /// PWR_WUCR3 Register bits
    namespace pwr_wucr3_bits {
        constexpr uint32_t WUSEL1 = (2 << 0);  ///< Wakeup pin WKUP1 selection This field must be configured when WUPEN1 = 0.
        constexpr uint32_t WUSEL2 = (2 << 2);  ///< Wakeup pin WKUP2 selection This field must be configured when WUPEN2 = 0.
        constexpr uint32_t WUSEL3 = (2 << 4);  ///< Wakeup pin WKUP3 selection This field must be configured when WUPEN3 = 0.
        constexpr uint32_t WUSEL4 = (2 << 6);  ///< Wakeup pin WKUP4 selection This field must be configured when WUPEN4 = 0.
        constexpr uint32_t WUSEL5 = (2 << 8);  ///< Wakeup pin WKUP5 selection This field must be configured when WUPEN5 = 0.
        constexpr uint32_t WUSEL6 = (2 << 10);  ///< Wakeup pin WKUP6 selection This field must be configured when WUPEN6 = 0.
        constexpr uint32_t WUSEL7 = (2 << 12);  ///< Wakeup pin WKUP7 selection This field must be configured when WUPEN7 = 0.
        constexpr uint32_t WUSEL8 = (2 << 14);  ///< Wakeup pin WKUP8 selection This field must be configured when WUPEN8 = 0.
    }

    /// PWR_BDCR1 Register bits
    namespace pwr_bdcr1_bits {
        constexpr uint32_t BREN = (1U << 0);  ///< Backup RAM retention in Standby and VBAT modes When this bit is set, the backup RAM content is kept in Standby and VBAT modes. If BREN is reset, the backup RAM can still be used in Run, Sleep and Stop modes. However, its content is lost in Standby, Shutdown and VBAT modes. This bit can be written only when the regulator is LDO, which must be configured before switching to SMPS. Note: Backup RAM cannot be preserved in Shutdown mode.
        constexpr uint32_t MONEN = (1U << 4);  ///< Backup domain voltage and temperature monitoring enable
    }

    /// PWR_BDCR2 Register bits
    namespace pwr_bdcr2_bits {
        constexpr uint32_t VBE = (1U << 0);  ///< VBAT charging enable
        constexpr uint32_t VBRS = (1U << 1);  ///< VBAT charging resistor selection
    }

    /// PWR_DBPR Register bits
    namespace pwr_dbpr_bits {
        constexpr uint32_t DBP = (1U << 0);  ///< Disable Backup domain write protection In reset state, all registers and SRAM in Backup domain are protected against parasitic write access. This bit must be set to enable the write access to these registers.
    }

    /// PWR_UCPDR Register bits
    namespace pwr_ucpdr_bits {
        constexpr uint32_t UCPD_DBDIS = (1U << 0);  ///< UCPD dead battery disable After exiting reset, the USB Type-C “dead battery” behavior is enabled, which may have a pull-down effect on CC1 and CC2 pins. It is recommended to disable it in all cases, either to stop this pull-down or to handover control to the UCPD (the UCPD must be initialized before doing the disable).
        constexpr uint32_t UCPD_STBY = (1U << 1);  ///< UCPD Standby mode When set, this bit is used to memorize the UCPD configuration in Standby mode. This bit must be written to 1 just before entering Standby mode when using UCPD. It must be written to 0 after exiting the Standby mode and before writing any UCPD registers.
    }

    /// PWR_SECCFGR Register bits
    namespace pwr_seccfgr_bits {
        constexpr uint32_t WUP1SEC = (1U << 0);  ///< WUP1 secure protection
        constexpr uint32_t WUP2SEC = (1U << 1);  ///< WUP2 secure protection
        constexpr uint32_t WUP3SEC = (1U << 2);  ///< WUP3 secure protection
        constexpr uint32_t WUP4SEC = (1U << 3);  ///< WUP4 secure protection
        constexpr uint32_t WUP5SEC = (1U << 4);  ///< WUP5 secure protection
        constexpr uint32_t WUP6SEC = (1U << 5);  ///< WUP6 secure protection
        constexpr uint32_t WUP7SEC = (1U << 6);  ///< WUP7 secure protection
        constexpr uint32_t WUP8SEC = (1U << 7);  ///< WUP8 secure protection
        constexpr uint32_t LPMSEC = (1U << 12);  ///< Low-power modes secure protection
        constexpr uint32_t VDMSEC = (1U << 13);  ///< Voltage detection and monitoring secure protection
        constexpr uint32_t VBSEC = (1U << 14);  ///< Backup domain secure protection
        constexpr uint32_t APCSEC = (1U << 15);  ///< Pull-up/pull-down secure protection
    }

    /// PWR_PRIVCFGR Register bits
    namespace pwr_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< PWR secure functions privilege configuration This bit is set and reset by software. It can be written only by a secure privileged access.
        constexpr uint32_t NSPRIV = (1U << 1);  ///< PWR non-secure functions privilege configuration This bit is set and reset by software. It can be written only by privileged access, secure or non-secure.
    }

    /// PWR_SR Register bits
    namespace pwr_sr_bits {
        constexpr uint32_t CSSF = (1U << 0);  ///< Clear Stop and Standby flags This bit is protected against non-secure access when LPMSEC = 1 in PWR_SECCFGR. This bit is protected against unprivileged access when LPMSEC = 1 and SPRIV = 1 in PWR_PRIVCFGR, or when LPMSEC = 0 and NSPRIV = 1. Writing 1 to this bit clears the STOPF and SBF flags.
        constexpr uint32_t STOPF = (1U << 1);  ///< Stop flag This bit is set by hardware when the device enters a Stop mode, and is cleared by software by writing 1 to the CSSF bit.
        constexpr uint32_t SBF = (1U << 2);  ///< Standby flag This bit is set by hardware when the device enters the Standby mode, and is cleared by writing 1 to the CSSF bit, or by a power-on reset. It is not cleared by the system reset.
    }

    /// PWR_SVMSR Register bits
    namespace pwr_svmsr_bits {
        constexpr uint32_t REGS = (1U << 1);  ///< Regulator selection
        constexpr uint32_t PVDO = (1U << 4);  ///< VDD voltage detector output
        constexpr uint32_t ACTVOSRDY = (1U << 15);  ///< Voltage level ready for currently used VOS
        constexpr uint32_t ACTVOS = (2 << 16);  ///< VOS currently applied to VCORE This field provides the last VOS value.
        constexpr uint32_t VDDUSBRDY = (1U << 24);  ///< VDDUSB ready
        constexpr uint32_t VDDIO2RDY = (1U << 25);  ///< VDDIO2 ready
        constexpr uint32_t VDDA1RDY = (1U << 26);  ///< VDDA ready versus 1.6V voltage monitor
        constexpr uint32_t VDDA2RDY = (1U << 27);  ///< VDDA ready versus 1.8 V voltage monitor
    }

    /// PWR_BDSR Register bits
    namespace pwr_bdsr_bits {
        constexpr uint32_t VBATH = (1U << 1);  ///< Backup domain voltage level monitoring versus high threshold
        constexpr uint32_t TEMPL = (1U << 2);  ///< Temperature level monitoring versus low threshold
        constexpr uint32_t TEMPH = (1U << 3);  ///< Temperature level monitoring versus high threshold
    }

    /// PWR_WUSR Register bits
    namespace pwr_wusr_bits {
        constexpr uint32_t WUF1 = (1U << 0);  ///< Wakeup flag 1 This bit is set when a wakeup event is detected on WKUP1 pin. This bit is cleared by writing 1 in the CWUF1 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN1 = 0.
        constexpr uint32_t WUF2 = (1U << 1);  ///< Wakeup flag 2 This bit is set when a wakeup event is detected on WKUP2 pin. This bit is cleared by writing 1 in the CWUF2 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN2 = 0.
        constexpr uint32_t WUF3 = (1U << 2);  ///< Wakeup flag 3 This bit is set when a wakeup event is detected on WKUP3 pin. This bit is cleared by writing 1 in the CWUF3 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN3 = 0.
        constexpr uint32_t WUF4 = (1U << 3);  ///< Wakeup flag 4 This bit is set when a wakeup event is detected on WKUP4 pin. This bit is cleared by writing 1 in the CWUF4 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN4 = 0.
        constexpr uint32_t WUF5 = (1U << 4);  ///< Wakeup flag 5 This bit is set when a wakeup event is detected on WKUP5 pin. This bit is cleared by writing 1 in the CWUF5 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN5 = 0.
        constexpr uint32_t WUF6 = (1U << 5);  ///< Wakeup flag 6 This bit is set when a wakeup event is detected on WKUP6 pin. This bit is cleared by writing 1 in the CWUF6 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN6 = 0. If WUSEL = 11, this bit is cleared by hardware when all internal wakeup source are cleared.
        constexpr uint32_t WUF7 = (1U << 6);  ///< Wakeup flag 7 This bit is set when a wakeup event is detected on WKUP7 pin. This bit is cleared by writing 1 in the CWUF7 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN7 = 0. If WUSEL = 11, this bit is cleared by hardware when all internal wakeup source are cleared.
        constexpr uint32_t WUF8 = (1U << 7);  ///< Wakeup flag 8 This bit is set when a wakeup event is detected on WKUP8 pin. This bit is cleared by writing 1 in the CWUF8 bit of PWR_WUSCR when WUSEL ≠ 11, or by hardware when WUPEN8 = 0. If WUSEL = 11, this bit is cleared by hardware when all internal wakeup source are cleared.
    }

    /// PWR_WUSCR Register bits
    namespace pwr_wuscr_bits {
        constexpr uint32_t CWUF1 = (1U << 0);  ///< Wakeup flag 1 Writing 1 to this bit clears the WUF1 flag in PWR_WUSR.
        constexpr uint32_t CWUF2 = (1U << 1);  ///< Wakeup flag 2 Writing 1 to this bit clears the WUF2 flag in PWR_WUSR.
        constexpr uint32_t CWUF3 = (1U << 2);  ///< Wakeup flag 3 Writing 1 to this bit clears the WUF3 flag in PWR_WUSR.
        constexpr uint32_t CWUF4 = (1U << 3);  ///< Wakeup flag 4 Writing 1 to this bit clears the WUF4 flag in PWR_WUSR.
        constexpr uint32_t CWUF5 = (1U << 4);  ///< Wakeup flag 5 Writing 1 to this bit clears the WUF5 flag in PWR_WUSR.
        constexpr uint32_t CWUF6 = (1U << 5);  ///< Wakeup flag 6 Writing 1 to this bit clears the WUF6 flag in PWR_WUSR.
        constexpr uint32_t CWUF7 = (1U << 6);  ///< Wakeup flag 7 Writing 1 to this bit clears the WUF7 flag in PWR_WUSR.
        constexpr uint32_t CWUF8 = (1U << 7);  ///< Wakeup flag 8 Writing 1 to this bit clears the WUF8 flag in PWR_WUSR.
    }

    /// PWR_APCR Register bits
    namespace pwr_apcr_bits {
        constexpr uint32_t APC = (1U << 0);  ///< Apply pull-up and pull-down configuration When this bit is set, the I/O pull-up and pull-down configurations defined in PWR_PUCRx and PWR_PDCRx are applied. When this bit is cleared, PWR_PUCRx and PWR_PDCRx are not applied to the I/Os.
    }

    /// PWR_PUCRA Register bits
    namespace pwr_pucra_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU15 = (1U << 15);  ///< Port A pull-up bit 15 When set, this bit activates the pull-up on PA15 when the APC bit is set in PWR_APCR. The pull-up is not activated if the corresponding PD15 bit is also set.
    }

    /// PWR_PDCRA Register bits
    namespace pwr_pdcra_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD14 = (1U << 14);  ///< Port A pull-down bit 14 When set, this bit activates the pull-down on PA14 when the APC bit is set in PWR_APCR.
    }

    /// PWR_PUCRB Register bits
    namespace pwr_pucrb_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRB Register bits
    namespace pwr_pdcrb_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRC Register bits
    namespace pwr_pucrc_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRC Register bits
    namespace pwr_pdcrc_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRD Register bits
    namespace pwr_pucrd_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRD Register bits
    namespace pwr_pdcrd_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRE Register bits
    namespace pwr_pucre_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRE Register bits
    namespace pwr_pdcre_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRF Register bits
    namespace pwr_pucrf_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRF Register bits
    namespace pwr_pdcrf_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRG Register bits
    namespace pwr_pucrg_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRG Register bits
    namespace pwr_pdcrg_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRH Register bits
    namespace pwr_pucrh_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRH Register bits
    namespace pwr_pdcrh_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRI Register bits
    namespace pwr_pucri_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
        constexpr uint32_t PU12 = (1U << 12);  ///< PU12
        constexpr uint32_t PU13 = (1U << 13);  ///< PU13
        constexpr uint32_t PU14 = (1U << 14);  ///< PU14
        constexpr uint32_t PU15 = (1U << 15);  ///< PU15
    }

    /// PWR_PDCRI Register bits
    namespace pwr_pdcri_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
        constexpr uint32_t PD12 = (1U << 12);  ///< PD12
        constexpr uint32_t PD13 = (1U << 13);  ///< PD13
        constexpr uint32_t PD14 = (1U << 14);  ///< PD14
        constexpr uint32_t PD15 = (1U << 15);  ///< PD15
    }

    /// PWR_PUCRJ Register bits
    namespace pwr_pucrj_bits {
        constexpr uint32_t PU0 = (1U << 0);  ///< PU0
        constexpr uint32_t PU1 = (1U << 1);  ///< PU1
        constexpr uint32_t PU2 = (1U << 2);  ///< PU2
        constexpr uint32_t PU3 = (1U << 3);  ///< PU3
        constexpr uint32_t PU4 = (1U << 4);  ///< PU4
        constexpr uint32_t PU5 = (1U << 5);  ///< PU5
        constexpr uint32_t PU6 = (1U << 6);  ///< PU6
        constexpr uint32_t PU7 = (1U << 7);  ///< PU7
        constexpr uint32_t PU8 = (1U << 8);  ///< PU8
        constexpr uint32_t PU9 = (1U << 9);  ///< PU9
        constexpr uint32_t PU10 = (1U << 10);  ///< PU10
        constexpr uint32_t PU11 = (1U << 11);  ///< PU11
    }

    /// PWR_PDCRJ Register bits
    namespace pwr_pdcrj_bits {
        constexpr uint32_t PD0 = (1U << 0);  ///< PD0
        constexpr uint32_t PD1 = (1U << 1);  ///< PD1
        constexpr uint32_t PD2 = (1U << 2);  ///< PD2
        constexpr uint32_t PD3 = (1U << 3);  ///< PD3
        constexpr uint32_t PD4 = (1U << 4);  ///< PD4
        constexpr uint32_t PD5 = (1U << 5);  ///< PD5
        constexpr uint32_t PD6 = (1U << 6);  ///< PD6
        constexpr uint32_t PD7 = (1U << 7);  ///< PD7
        constexpr uint32_t PD8 = (1U << 8);  ///< PD8
        constexpr uint32_t PD9 = (1U << 9);  ///< PD9
        constexpr uint32_t PD10 = (1U << 10);  ///< PD10
        constexpr uint32_t PD11 = (1U << 11);  ///< PD11
    }

    /// PWR_CR4 Register bits
    namespace pwr_cr4_bits {
        constexpr uint32_t SRAM1PDS4 = (1U << 0);  ///< SRAM1PDS4
        constexpr uint32_t SRAM1PDS5 = (1U << 1);  ///< SRAM1PDS5
        constexpr uint32_t SRAM1PDS6 = (1U << 2);  ///< SRAM1PDS6
        constexpr uint32_t SRAM1PDS7 = (1U << 3);  ///< SRAM1PDS7
        constexpr uint32_t SRAM1PDS8 = (1U << 4);  ///< SRAM1PDS8
        constexpr uint32_t SRAM1PDS9 = (1U << 5);  ///< SRAM1PDS9
        constexpr uint32_t SRAM1PDS10 = (1U << 6);  ///< SRAM1PDS10
        constexpr uint32_t SRAM1PDS11 = (1U << 7);  ///< SRAM1PDS11
        constexpr uint32_t SRAM1PDS12 = (1U << 8);  ///< SRAM1PDS12
        constexpr uint32_t SRAM3PDS9 = (1U << 10);  ///< SRAM3PDS9
        constexpr uint32_t SRAM3PDS10 = (1U << 11);  ///< SRAM3PDS10
        constexpr uint32_t SRAM3PDS11 = (1U << 12);  ///< SRAM3PDS11
        constexpr uint32_t SRAM3PDS12 = (1U << 13);  ///< SRAM3PDS12
        constexpr uint32_t SRAM3PDS13 = (1U << 14);  ///< SRAM3PDS13
        constexpr uint32_t SRAM5PDS1 = (1U << 16);  ///< SRAM5PDS1
        constexpr uint32_t SRAM5PDS2 = (1U << 17);  ///< SRAM5PDS2
        constexpr uint32_t SRAM5PDS3 = (1U << 18);  ///< SRAM5PDS3
        constexpr uint32_t SRAM5PDS4 = (1U << 19);  ///< SRAM5PDS4
        constexpr uint32_t SRAM5PDS5 = (1U << 20);  ///< SRAM5PDS5
        constexpr uint32_t SRAM5PDS6 = (1U << 21);  ///< SRAM5PDS6
        constexpr uint32_t SRAM5PDS7 = (1U << 22);  ///< SRAM5PDS7
        constexpr uint32_t SRAM5PDS8 = (1U << 23);  ///< SRAM5PDS8
        constexpr uint32_t SRAM5PDS9 = (1U << 24);  ///< SRAM5PDS9
        constexpr uint32_t SRAM5PDS10 = (1U << 25);  ///< SRAM5PDS10
        constexpr uint32_t SRAM5PDS11 = (1U << 26);  ///< SRAM5PDS11
        constexpr uint32_t SRAM5PDS12 = (1U << 27);  ///< SRAM5PDS12
        constexpr uint32_t SRAM5PDS13 = (1U << 28);  ///< SRAM5PDS13
    }

}

// ============================================================================
// RAMCFG Peripheral
// ============================================================================

namespace ramcfg {
    /// Base addresses
    constexpr uint32_t RAMCFG_BASE = 0x40026000;

    /// RAMCFG Register structure
    struct Registers {
        volatile uint32_t M1CR;  ///< Offset: 0x00 - RAMCFG SRAM x control register
        volatile uint32_t M1ISR;  ///< Offset: 0x08 - RAMCFG RAMx interrupt status register
        volatile uint32_t RAM1ERKEYR;  ///< Offset: 0x28 - RAMCFG SRAM x erase key register
        volatile uint32_t M2CR;  ///< Offset: 0x40 - RAMCFG SRAM x control register
        volatile uint32_t M2IER;  ///< Offset: 0x44 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t M2ISR;  ///< Offset: 0x48 - RAMCFG RAMx interrupt status register
        volatile uint32_t M2SEAR;  ///< Offset: 0x4C - RAMCFG RAM x ECC single error address register
        volatile uint32_t M2DEAR;  ///< Offset: 0x50 - RAMCFG RAM x ECC double error address register
        volatile uint32_t M2ICR;  ///< Offset: 0x54 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t M2WPR1;  ///< Offset: 0x58 - RAMCFG SRAM2 write protection register 1
        volatile uint32_t M2WPR2;  ///< Offset: 0x5C - RAMCFG SRAM2 write protection register 2
        volatile uint32_t M2ECCKEYR;  ///< Offset: 0x64 - RAMCFG SRAM x ECC key register
        volatile uint32_t M2ERKEYR;  ///< Offset: 0x68 - RAMCFG SRAM x erase key register
        volatile uint32_t M3CR;  ///< Offset: 0x80 - RAMCFG SRAM x control register
        volatile uint32_t M3IER;  ///< Offset: 0x84 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t M3ISR;  ///< Offset: 0x88 - RAMCFG RAMx interrupt status register
        volatile uint32_t M3SEAR;  ///< Offset: 0x8C - RAMCFG RAM x ECC single error address register
        volatile uint32_t M3DEAR;  ///< Offset: 0x90 - RAMCFG RAM x ECC double error address register
        volatile uint32_t M3ICR;  ///< Offset: 0x94 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t M3ECCKEYR;  ///< Offset: 0xA4 - RAMCFG SRAM x ECC key register
        volatile uint32_t M3ERKEYR;  ///< Offset: 0xA8 - RAMCFG SRAM x erase key register
        volatile uint32_t M4CR;  ///< Offset: 0xC0 - RAMCFG SRAM x control register
        volatile uint32_t M4ISR;  ///< Offset: 0xC8 - RAMCFG RAMx interrupt status register
        volatile uint32_t M4ERKEYR;  ///< Offset: 0xE8 - RAMCFG SRAM x erase key register
        volatile uint32_t M5CR;  ///< Offset: 0x100 - RAMCFG SRAM x control register
        volatile uint32_t M5IER;  ///< Offset: 0x104 - RAMCFG SRAM x interrupt enable register
        volatile uint32_t M5ISR;  ///< Offset: 0x108 - RAMCFG RAMx interrupt status register
        volatile uint32_t M5SEAR;  ///< Offset: 0x10C - RAMCFG RAM x ECC single error address register
        volatile uint32_t M5DEAR;  ///< Offset: 0x110 - RAMCFG RAM x ECC double error address register
        volatile uint32_t M5ICR;  ///< Offset: 0x114 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t M5ECCKEYR;  ///< Offset: 0x124 - RAMCFG RAM x interrupt clear register x
        volatile uint32_t M5ERKEYR;  ///< Offset: 0x128 - Erase write protection key The following steps are...
        volatile uint32_t M6CR;  ///< Offset: 0x140 - memory x control register
        volatile uint32_t M6ISR;  ///< Offset: 0x148 - ECC single error detected and corrected Note: This bit...
        volatile uint32_t M6ERKEYR;  ///< Offset: 0x168 - Erase write protection key The following steps are...
    };

    /// Peripheral instances
    inline Registers* RAMCFG = reinterpret_cast<Registers*>(RAMCFG_BASE);

    // Bit definitions
    /// M1CR Register bits
    namespace m1cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M1ISR Register bits
    namespace m1isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// RAM1ERKEYR Register bits
    namespace ram1erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// M2CR Register bits
    namespace m2cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M2IER Register bits
    namespace m2ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// M2ISR Register bits
    namespace m2isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// M2SEAR Register bits
    namespace m2sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// M2DEAR Register bits
    namespace m2dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// M2ICR Register bits
    namespace m2icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

    /// M2WPR1 Register bits
    namespace m2wpr1_bits {
        constexpr uint32_t P0WP = (1U << 0);  ///< P0WP
        constexpr uint32_t P1WP = (1U << 1);  ///< P1WP
        constexpr uint32_t P2WP = (1U << 2);  ///< P2WP
        constexpr uint32_t P3WP = (1U << 3);  ///< P3WP
        constexpr uint32_t P4WP = (1U << 4);  ///< P4WP
        constexpr uint32_t P5WP = (1U << 5);  ///< P5WP
        constexpr uint32_t P6WP = (1U << 6);  ///< P6WP
        constexpr uint32_t P7WP = (1U << 7);  ///< P7WP
        constexpr uint32_t P8WP = (1U << 8);  ///< P8WP
        constexpr uint32_t P9WP = (1U << 9);  ///< P9WP
        constexpr uint32_t P10WP = (1U << 10);  ///< P10WP
        constexpr uint32_t P11WP = (1U << 11);  ///< P11WP
        constexpr uint32_t P12WP = (1U << 12);  ///< P12WP
        constexpr uint32_t P13WP = (1U << 13);  ///< P13WP
        constexpr uint32_t P14WP = (1U << 14);  ///< P14WP
        constexpr uint32_t P15WP = (1U << 15);  ///< P15WP
        constexpr uint32_t P16WP = (1U << 16);  ///< P16WP
        constexpr uint32_t P17WP = (1U << 17);  ///< P17WP
        constexpr uint32_t P18WP = (1U << 18);  ///< P18WP
        constexpr uint32_t P19WP = (1U << 19);  ///< P19WP
        constexpr uint32_t P20WP = (1U << 20);  ///< P20WP
        constexpr uint32_t P21WP = (1U << 21);  ///< P21WP
        constexpr uint32_t P22WP = (1U << 22);  ///< P22WP
        constexpr uint32_t P23WP = (1U << 23);  ///< P23WP
        constexpr uint32_t P24WP = (1U << 24);  ///< P24WP
        constexpr uint32_t P25WP = (1U << 25);  ///< P25WP
        constexpr uint32_t P26WP = (1U << 26);  ///< P26WP
        constexpr uint32_t P27WP = (1U << 27);  ///< P27WP
        constexpr uint32_t P28WP = (1U << 28);  ///< P28WP
        constexpr uint32_t P29WP = (1U << 29);  ///< P29WP
        constexpr uint32_t P30WP = (1U << 30);  ///< P30WP
        constexpr uint32_t P31WP = (1U << 31);  ///< P31WP
    }

    /// M2WPR2 Register bits
    namespace m2wpr2_bits {
        constexpr uint32_t P32WP = (1U << 0);  ///< P32WP
        constexpr uint32_t P33WP = (1U << 1);  ///< P33WP
        constexpr uint32_t P34WP = (1U << 2);  ///< P34WP
        constexpr uint32_t P35WP = (1U << 3);  ///< P35WP
        constexpr uint32_t P36WP = (1U << 4);  ///< P36WP
        constexpr uint32_t P37WP = (1U << 5);  ///< P37WP
        constexpr uint32_t P38WP = (1U << 6);  ///< P38WP
        constexpr uint32_t P39WP = (1U << 7);  ///< P39WP
        constexpr uint32_t P40WP = (1U << 8);  ///< P40WP
        constexpr uint32_t P41WP = (1U << 9);  ///< P41WP
        constexpr uint32_t P42WP = (1U << 10);  ///< P42WP
        constexpr uint32_t P43WP = (1U << 11);  ///< P43WP
        constexpr uint32_t P44WP = (1U << 12);  ///< P44WP
        constexpr uint32_t P45WP = (1U << 13);  ///< P45WP
        constexpr uint32_t P46WP = (1U << 14);  ///< P46WP
        constexpr uint32_t P47WP = (1U << 15);  ///< P47WP
        constexpr uint32_t P48WP = (1U << 16);  ///< P48WP
        constexpr uint32_t P49WP = (1U << 17);  ///< P49WP
        constexpr uint32_t P50WP = (1U << 18);  ///< P50WP
        constexpr uint32_t P51WP = (1U << 19);  ///< P51WP
        constexpr uint32_t P52WP = (1U << 20);  ///< P52WP
        constexpr uint32_t P53WP = (1U << 21);  ///< P53WP
        constexpr uint32_t P54WP = (1U << 22);  ///< P54WP
        constexpr uint32_t P55WP = (1U << 23);  ///< P55WP
        constexpr uint32_t P56WP = (1U << 24);  ///< P56WP
        constexpr uint32_t P57WP = (1U << 25);  ///< P57WP
        constexpr uint32_t P58WP = (1U << 26);  ///< P58WP
        constexpr uint32_t P59WP = (1U << 27);  ///< P59WP
        constexpr uint32_t P60WP = (1U << 28);  ///< P60WP
        constexpr uint32_t P61WP = (1U << 29);  ///< P61WP
        constexpr uint32_t P62WP = (1U << 30);  ///< P62WP
        constexpr uint32_t P63WP = (1U << 31);  ///< P63WP
    }

    /// M2ECCKEYR Register bits
    namespace m2ecckeyr_bits {
        constexpr uint32_t ECCKEY = (8 << 0);  ///< ECCKEY
    }

    /// M2ERKEYR Register bits
    namespace m2erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// M3CR Register bits
    namespace m3cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M3IER Register bits
    namespace m3ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// M3ISR Register bits
    namespace m3isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// M3SEAR Register bits
    namespace m3sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// M3DEAR Register bits
    namespace m3dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// M3ICR Register bits
    namespace m3icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

    /// M3ECCKEYR Register bits
    namespace m3ecckeyr_bits {
        constexpr uint32_t ECCKEY = (8 << 0);  ///< ECCKEY
    }

    /// M3ERKEYR Register bits
    namespace m3erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// M4CR Register bits
    namespace m4cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M4ISR Register bits
    namespace m4isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// M4ERKEYR Register bits
    namespace m4erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< ERASEKEY
    }

    /// M5CR Register bits
    namespace m5cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M5IER Register bits
    namespace m5ier_bits {
        constexpr uint32_t SEIE = (1U << 0);  ///< SEIE
        constexpr uint32_t DEIE = (1U << 1);  ///< DEIE
        constexpr uint32_t ECCNMI = (1U << 3);  ///< ECCNMI
    }

    /// M5ISR Register bits
    namespace m5isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< SEDC
        constexpr uint32_t DED = (1U << 1);  ///< DED
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAMBUSY
    }

    /// M5SEAR Register bits
    namespace m5sear_bits {
        constexpr uint32_t ESEA = (32 << 0);  ///< ESEA
    }

    /// M5DEAR Register bits
    namespace m5dear_bits {
        constexpr uint32_t EDEA = (32 << 0);  ///< EDEA
    }

    /// M5ICR Register bits
    namespace m5icr_bits {
        constexpr uint32_t CSEDC = (1U << 0);  ///< CSEDC
        constexpr uint32_t CDED = (1U << 1);  ///< CDED
    }

    /// M5ECCKEYR Register bits
    namespace m5ecckeyr_bits {
        constexpr uint32_t ECCKEY = (8 << 0);  ///< ECCKEY
    }

    /// M5ERKEYR Register bits
    namespace m5erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< Erase write protection key The following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register. 1) Write 0xCA into ERASEKEY[7:0]. 2) Write 0x53 into ERASEKEY[7:0]. Note: Writing a wrong key reactivates the write protection.
    }

    /// M6CR Register bits
    namespace m6cr_bits {
        constexpr uint32_t ECCE = (1U << 0);  ///< ECCE
        constexpr uint32_t ALE = (1U << 4);  ///< ALE
        constexpr uint32_t SRAMER = (1U << 8);  ///< SRAMER
        constexpr uint32_t WSC = (3 << 16);  ///< WSC
    }

    /// M6ISR Register bits
    namespace m6isr_bits {
        constexpr uint32_t SEDC = (1U << 0);  ///< ECC single error detected and corrected Note: This bit is reserved and must be kept at reset value in SRAM1, SRAM4 and SRAM5 interrupt status registers.
        constexpr uint32_t DED = (1U << 1);  ///< ECC double error detected Note: This bit is reserved and must be kept at reset value in SRAM1, SRAM4 and SRAM5 interrupt status registers.
        constexpr uint32_t SRAMBUSY = (1U << 8);  ///< SRAM busy with erase operation Note: Depending on the SRAM, the erase operation can be performed due to software request, system reset if the option bit is enabled, tamper detection or readout protection regression. Refer to .
    }

    /// M6ERKEYR Register bits
    namespace m6erkeyr_bits {
        constexpr uint32_t ERASEKEY = (8 << 0);  ///< Erase write protection key The following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register. 1) Write 0xCA into ERASEKEY[7:0]. 2) Write 0x53 into ERASEKEY[7:0]. Note: Writing a wrong key reactivates the write protection.
    }

}

// ============================================================================
// RCC Peripheral
// ============================================================================

namespace rcc {
    /// Base addresses
    constexpr uint32_t RCC_BASE = 0x46020C00;
    constexpr uint32_t SEC_RCC_BASE = 0x56020C00;

    /// RCC Register structure
    struct Registers {
        volatile uint32_t RCC_CR;  ///< Offset: 0x00 - RCC clock control register
        volatile uint32_t RCC_ICSCR1;  ///< Offset: 0x08 - RCC internal clock sources calibration register 1
        volatile uint32_t RCC_ICSCR2;  ///< Offset: 0x0C - RCC internal clock sources calibration register 2
        volatile uint32_t RCC_ICSCR3;  ///< Offset: 0x10 - RCC internal clock sources calibration register 3
        volatile uint32_t RCC_CRRCR;  ///< Offset: 0x14 - RCC clock recovery RC register
        volatile uint32_t RCC_CFGR1;  ///< Offset: 0x1C - RCC clock configuration register 1
        volatile uint32_t RCC_CFGR2;  ///< Offset: 0x20 - RCC clock configuration register 2
        volatile uint32_t RCC_CFGR3;  ///< Offset: 0x24 - RCC clock configuration register 3
        volatile uint32_t RCC_PLL1CFGR;  ///< Offset: 0x28 - RCC PLL1 configuration register
        volatile uint32_t RCC_PLL2CFGR;  ///< Offset: 0x2C - RCC PLL2 configuration register
        volatile uint32_t RCC_PLL3CFGR;  ///< Offset: 0x30 - RCC PLL3 configuration register
        volatile uint32_t RCC_PLL1DIVR;  ///< Offset: 0x34 - RCC PLL1 dividers register
        volatile uint32_t RCC_PLL1FRACR;  ///< Offset: 0x38 - RCC PLL1 fractional divider register
        volatile uint32_t RCC_PLL2DIVR;  ///< Offset: 0x3C - RCC PLL2 dividers configuration register
        volatile uint32_t RCC_PLL2FRACR;  ///< Offset: 0x40 - RCC PLL2 fractional divider register
        volatile uint32_t RCC_PLL3DIVR;  ///< Offset: 0x44 - RCC PLL3 dividers configuration register
        volatile uint32_t RCC_PLL3FRACR;  ///< Offset: 0x48 - RCC PLL3 fractional divider register
        volatile uint32_t RCC_CIER;  ///< Offset: 0x50 - RCC clock interrupt enable register
        volatile uint32_t RCC_CIFR;  ///< Offset: 0x54 - RCC clock interrupt flag register
        volatile uint32_t RCC_CICR;  ///< Offset: 0x58 - RCC clock interrupt clear register
        volatile uint32_t RCC_AHB1RSTR;  ///< Offset: 0x60 - RCC AHB1 peripheral reset register
        volatile uint32_t RCC_AHB2RSTR1;  ///< Offset: 0x64 - RCC AHB2 peripheral reset register 1
        volatile uint32_t RCC_AHB2RSTR2;  ///< Offset: 0x68 - RCC AHB2 peripheral reset register 2
        volatile uint32_t RCC_AHB3RSTR;  ///< Offset: 0x6C - RCC AHB3 peripheral reset register
        volatile uint32_t RCC_APB1RSTR1;  ///< Offset: 0x74 - RCC APB1 peripheral reset register 1
        volatile uint32_t RCC_APB1RSTR2;  ///< Offset: 0x78 - RCC APB1 peripheral reset register 2
        volatile uint32_t RCC_APB2RSTR;  ///< Offset: 0x7C - RCC APB2 peripheral reset register
        volatile uint32_t RCC_APB3RSTR;  ///< Offset: 0x80 - RCC APB3 peripheral reset register
        volatile uint32_t RCC_AHB1ENR;  ///< Offset: 0x88 - RCC AHB1 peripheral clock enable register
        volatile uint32_t RCC_AHB2ENR1;  ///< Offset: 0x8C - RCC AHB2 peripheral clock enable register 1
        volatile uint32_t RCC_AHB2ENR2;  ///< Offset: 0x90 - RCC AHB2 peripheral clock enable register 2
        volatile uint32_t RCC_AHB3ENR;  ///< Offset: 0x94 - RCC AHB3 peripheral clock enable register
        volatile uint32_t RCC_APB1ENR1;  ///< Offset: 0x9C - RCC APB1 peripheral clock enable register 1
        volatile uint32_t RCC_APB1ENR2;  ///< Offset: 0xA0 - RCC APB1 peripheral clock enable register 2
        volatile uint32_t RCC_APB2ENR;  ///< Offset: 0xA4 - RCC APB2 peripheral clock enable register
        volatile uint32_t RCC_APB3ENR;  ///< Offset: 0xA8 - RCC APB3 peripheral clock enable register
        volatile uint32_t RCC_AHB1SMENR;  ///< Offset: 0xB0 - RCC AHB1 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_AHB2SMENR1;  ///< Offset: 0xB4 - RCC AHB2 peripheral clock enable in Sleep and	Stop modes...
        volatile uint32_t RCC_AHB2SMENR2;  ///< Offset: 0xB8 - RCC AHB2 peripheral clock enable in Sleep and	Stop modes...
        volatile uint32_t RCC_AHB3SMENR;  ///< Offset: 0xBC - RCC AHB3 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_APB1SMENR1;  ///< Offset: 0xC4 - RCC APB1 peripheral clock enable in Sleep and Stop...
        volatile uint32_t RCC_APB1SMENR2;  ///< Offset: 0xC8 - RCC APB1 peripheral clocks enable in Sleep and	Stop...
        volatile uint32_t RCC_APB2SMENR;  ///< Offset: 0xCC - RCC APB2 peripheral clocks enable in Sleep and Stop...
        volatile uint32_t RCC_APB3SMENR;  ///< Offset: 0xD0 - RCC APB3 peripheral clock enable in Sleep and Stop modes register
        volatile uint32_t RCC_SRDAMR;  ///< Offset: 0xD8 - RCC SmartRun domain peripheral autonomous mode register
        volatile uint32_t RCC_CCIPR1;  ///< Offset: 0xE0 - RCC peripherals independent clock configuration register 1
        volatile uint32_t RCC_CCIPR2;  ///< Offset: 0xE4 - RCC peripherals independent clock configuration register 2
        volatile uint32_t RCC_CCIPR3;  ///< Offset: 0xE8 - RCC peripherals independent clock configuration register 3
        volatile uint32_t RCC_BDCR;  ///< Offset: 0xF0 - RCC backup domain control register
        volatile uint32_t RCC_CSR;  ///< Offset: 0xF4 - RCC control/status register
        volatile uint32_t RCC_SECCFGR;  ///< Offset: 0x110 - RCC secure configuration register
        volatile uint32_t RCC_PRIVCFGR;  ///< Offset: 0x114 - RCC privilege configuration register
    };

    /// Peripheral instances
    inline Registers* RCC = reinterpret_cast<Registers*>(RCC_BASE);
    inline Registers* SEC_RCC = reinterpret_cast<Registers*>(SEC_RCC_BASE);

    // Bit definitions
    /// RCC_CR Register bits
    namespace rcc_cr_bits {
        constexpr uint32_t MSISON = (1U << 0);  ///< MSIS clock enable This bit is set and cleared by software. It is cleared by hardware to stop the MSIS oscillator when entering Stop, Standby or Shutdown mode. This bit is set by hardware to force the�MSIS oscillator on when exiting Standby or Shutdown mode. It is set by hardware to force the MSIS oscillator ON when STOPWUCK = 0 when exiting Stop modes, or in case of a failure of the HSE oscillator. Set by hardware when used directly or indirectly as system clock.
        constexpr uint32_t MSIKERON = (1U << 1);  ///< MSI enable for some peripheral kernels This bit is set and cleared by software to force MSI ON even in Stop modes. Keeping the MSI on in Stop mode allows the communication speed not to be reduced by the MSI startup time. This bit has no effect on MSISON and MSIKON values (see Section�11.4.24 for more details). This bit must be configured at 0 before entering Stop 3 mode.
        constexpr uint32_t MSISRDY = (1U << 2);  ///< MSIS clock ready flag This bit is set by hardware to indicate that the MSIS oscillator is stable. It is set only when MSIS is enabled by software (by setting MSISON). Note: Once the MSISON bit is cleared, MSISRDY goes low after six MSIS clock cycles.
        constexpr uint32_t MSIPLLEN = (1U << 3);  ///< MSI clock PLL-mode enable This bit is set and cleared by software to enable/disable the PLL part of the MSI clock source. MSIPLLEN must be enabled after LSE is enabled (LSEON enabled) and ready (LSERDY set by hardware). A hardware protection prevents from enabling MSIPLLEN if LSE is not ready. This bit is cleared by hardware when LSE is disabled (LSEON = 0) or when the CSS on LSE detects a LSE failure (see RCC_CSR).
        constexpr uint32_t MSIKON = (1U << 4);  ///< MSIK clock enable This bit is set and cleared by software. It is cleared by hardware to stop the MSIK when entering Stop, Standby, or Shutdown mode. This bit is set by hardware to force the MSIK oscillator ON when exiting Standby or Shutdown mode. It is set by hardware to force the MSIK oscillator on when STOPWUCK = 0 or STOPKERWUCK�=�0 when exiting Stop modes, or in case of a failure of the HSE oscillator.
        constexpr uint32_t MSIKRDY = (1U << 5);  ///< MSIK clock ready flag This bit is set by hardware to indicate that the MSIK is stable. It is set only when MSI kernel oscillator is enabled by software by setting MSIKON. Note: Once MSIKON bit is cleared, MSIKRDY goes low after six MSIK oscillator clock cycles.
        constexpr uint32_t MSIPLLSEL = (1U << 6);  ///< MSI clock with PLL mode selection This bit is set and cleared by software to select which MSI output clock uses the PLL mode. It�can be written only when the MSI PLL mode is disabled (MSIPLLEN = 0). Note: If the MSI kernel clock output uses the same oscillator source than the MSI system clock output, then the PLL mode is applied to both clock outputs.
        constexpr uint32_t MSIPLLFAST = (1U << 7);  ///< MSI PLL mode fast startup This bit is set and reset by software to enable/disable the fast PLL mode start-up of the MSI clock source. This bit is used only if PLL mode is selected (MSIPLLEN = 1). The fast start-up feature is not active the first time the PLL mode is selected. The�fast start-up is active when the MSI in PLL mode returns from switch off.
        constexpr uint32_t HSION = (1U << 8);  ///< HSI16 clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSI16 oscillator when entering Stop, Standby, or Shutdown mode. This bit is set by hardware to force the�HSI16 oscillator on when STOPWUCK = 1 when leaving Stop modes, or in case of failure of the HSE crystal oscillator. This bit is set by hardware if the HSI16 is used directly or indirectly as system clock.
        constexpr uint32_t HSIKERON = (1U << 9);  ///< HSI16 enable for some peripheral kernels This bit is set and cleared by software to force HSI16 ON even in Stop modes. Keeping HSI16 on in Stop mode allows the communication speed not to be reduced by the HSI16 startup time. This bit has no effect on HSION value. Refer to Section�11.4.24 for more details. This bit must be configured at 0 before entering Stop 3 mode.
        constexpr uint32_t HSIRDY = (1U << 10);  ///< HSI16 clock ready flag This bit is set by hardware to indicate that HSI16 oscillator is stable. It is set only when HSI16 is enabled by software (by setting HSION). Note: Once the HSION bit is cleared, HSIRDY goes low after six HSI16 clock cycles.
        constexpr uint32_t HSI48ON = (1U << 12);  ///< HSI48 clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSI48 when entering in Stop, Standby, or Shutdown modes.
        constexpr uint32_t HSI48RDY = (1U << 13);  ///< HSI48 clock ready flag This bit is set by hardware to indicate that HSI48 oscillator is stable. Itis set only when HSI48 is enabled by software (by setting HSI48ON).
        constexpr uint32_t SHSION = (1U << 14);  ///< SHSI clock enable This bit is set and cleared by software. It is cleared by hardware to stop the SHSI when entering in Stop, Standby, or Shutdown modes.
        constexpr uint32_t SHSIRDY = (1U << 15);  ///< SHSI clock ready flag This bit is set by hardware to indicate that the SHSI oscillator is stable. It is set only when SHSI is enabled by software (by setting SHSION). Note: Once the SHSION bit is cleared, SHSIRDY goes low after six SHSI clock cycles.
        constexpr uint32_t HSEON = (1U << 16);  ///< HSE clock enable This bit is set and cleared by software. It is cleared by hardware to stop the HSE oscillator when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.
        constexpr uint32_t HSERDY = (1U << 17);  ///< HSE clock ready flag This bit is set by hardware to indicate that the HSE oscillator is stable. Note: Once the HSEON bit is cleared, HSERDY goes low after six HSE clock cycles.
        constexpr uint32_t HSEBYP = (1U << 18);  ///< HSE crystal oscillator bypass This bit is set and cleared by software to bypass the oscillator with an external clock. The�external clock must be enabled with the HSEON bit set, to be used by the device. This�bit can be written only if the HSE oscillator is disabled.
        constexpr uint32_t CSSON = (1U << 19);  ///< Clock security system enable This bit is set by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset.
        constexpr uint32_t HSEEXT = (1U << 20);  ///< HSE external clock bypass mode This bit is set and reset by software to select the external clock mode in bypass mode. External clock mode must be configured with HSEON bit to be used by the device. This bit can be written only if the HSE oscillator is disabled. This bit is active only if the HSE bypass mode is enabled.
        constexpr uint32_t PLL1ON = (1U << 24);  ///< PLL1 enable This bit is set and cleared by software to enable the main PLL. It is cleared by hardware when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the PLL1 clock is used as the system clock.
        constexpr uint32_t PLL1RDY = (1U << 25);  ///< PLL1 clock ready flag This bit is set by hardware to indicate that the PLL1 is locked.
        constexpr uint32_t PLL2ON = (1U << 26);  ///< PLL2 enable This bit is set and cleared by software to enable PLL2. It is cleared by hardware when entering Stop, Standby, or Shutdown mode.
        constexpr uint32_t PLL2RDY = (1U << 27);  ///< PLL2 clock ready flag This bit is set by hardware to indicate that the PLL2 is locked.
        constexpr uint32_t PLL3ON = (1U << 28);  ///< PLL3 enable This bit is set and cleared by software to enable PLL3. It is cleared by hardware when entering Stop, Standby, or Shutdown mode.
        constexpr uint32_t PLL3RDY = (1U << 29);  ///< PLL3 clock ready flag This bit is set by hardware to indicate that the PLL3 is locked.
    }

    /// RCC_ICSCR1 Register bits
    namespace rcc_icscr1_bits {
        constexpr uint32_t MSICAL3 = (5 << 0);  ///< MSIRC3 clock calibration for MSI ranges 12 to 15 These bits are initialized at startup with the factory-programmed MSIRC3 calibration trim value for ranges 12 to 15. When MSITRIM3 is written, MSICAL3 is updated with the sum of MSITRIM3[4:0] and the factory calibration trim value MSIRC2[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL2 = (5 << 5);  ///< MSIRC2 clock calibration for MSI ranges 8 to 11 These bits are initialized at startup with the factory-programmed MSIRC2 calibration trim value for ranges 8 to 11. When MSITRIM2 is written, MSICAL2 is updated with the sum of MSITRIM2[4:0] and the factory calibration trim value MSIRC2[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL1 = (5 << 10);  ///< MSIRC1 clock calibration for MSI ranges 4 to 7 These bits are initialized at startup with the factory-programmed MSIRC1 calibration trim value for ranges 4 to 7. When MSITRIM1 is written, MSICAL1 is updated with the sum of MSITRIM1[4:0] and the factory calibration trim value MSIRC1[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSICAL0 = (5 << 15);  ///< MSIRC0 clock calibration for MSI ranges 0 to 3 These bits are initialized at startup with the factory-programmed MSIRC0 calibration trim value for ranges 0 to 3. When MSITRIM0 is written, MSICAL0 is updated with the sum of MSITRIM0[4:0] and the factory-programmed calibration trim value MSIRC0[4:0]. There is no hardware protection to limit a potential overflow due to the addition of MSITRIM bitfield and factory program bitfield for this calibration value. Control must be managed by software at user level.
        constexpr uint32_t MSIBIAS = (1U << 22);  ///< MSI bias mode selection This bit is set by software to select the MSI bias mode. By default, the MSI bias is in�continuous mode in order to maintain the output clocks accuracy. Setting this bit reduces the MSI consumption when the regulator is in range 4, or when the device is in Stop 1 or Stop�2 mode, but it�decreases the MSI accuracy
        constexpr uint32_t MSIRGSEL = (1U << 23);  ///< MSI clock range selection This bit is set by software to select the MSIS and MSIK clocks range with MSISRANGE[3:0] and MSIKRANGE[3:0]. Write 0 has no effect. After exiting Standby or Shutdown mode, or after a reset, this bit is at 0 and the MSIS and MSIK ranges are provided by MSISSRANGE[3:0] and MSIKSRANGE[3:0] in RCC_CSR.
        constexpr uint32_t MSIKRANGE = (4 << 24);  ///< MSIK clock ranges These bits are configured by software to choose the frequency range of MSIK oscillator when MSIRGSEL is set. 16 frequency ranges are available: Note: MSIKRANGE can be modified when MSIK is off (MSISON = 0) or when MSIK is ready (MSIKRDY�=�1). MSIKRANGE must NOT be modified when MSIK is on and NOT ready (MSIKON = 1 and MSIKRDY = 0) Note: MSIKRANGE is kept when the device wakes up from Stop mode, except when the�MSIK range is above 24 MHz. In this case MSIKRANGE is changed by hardware into�range 2 (24 MHz).
        constexpr uint32_t MSISRANGE = (4 << 28);  ///< MSIS clock ranges These bits are configured by software to choose the frequency range of MSIS oscillator when MSIRGSEL is set. 16 frequency ranges are available: Note: MSISRANGE can be modified when MSIS is off (MSISON = 0) or when MSIS is ready (MSISRDY�=�1). MSISRANGE must NOT be modified when MSIS is on and NOT ready (MSISON�=�1 and MSISRDY�=�0) Note: MSISRANGE is kept when the device wakes up from Stop mode, except when the�MSIS range is above 24 MHz. In this case MSISRANGE is changed by hardware into range 2 (24 MHz).
    }

    /// RCC_ICSCR2 Register bits
    namespace rcc_icscr2_bits {
        constexpr uint32_t MSITRIM3 = (5 << 0);  ///< MSI clock trimming for ranges 12 to 15 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC3[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM2 = (5 << 5);  ///< MSI clock trimming for ranges 8 to 11 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC2[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM1 = (5 << 10);  ///< MSI clock trimming for ranges 4 to 7 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC1[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
        constexpr uint32_t MSITRIM0 = (5 << 15);  ///< MSI clock trimming for ranges 0 to 3 These bits provide an additional user-programmable trimming value that is added to the factory-programmed calibration trim value MSIRC0[4:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the MSI.
    }

    /// RCC_ICSCR3 Register bits
    namespace rcc_icscr3_bits {
        constexpr uint32_t HSICAL = (12 << 0);  ///< HSI clock calibration These bits are initialized at startup with the factory-programmed HSI calibration trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value.
        constexpr uint32_t HSITRIM = (5 << 16);  ///< HSI clock trimming These bits provide an additional user-programmable trimming value that is added to HSICAL[11:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the HSI.
    }

    /// RCC_CRRCR Register bits
    namespace rcc_crrcr_bits {
        constexpr uint32_t HSI48CAL = (9 << 0);  ///< HSI48 clock calibration These bits are initialized at startup with the factory-programmed HSI48 calibration trim value.
    }

    /// RCC_CFGR1 Register bits
    namespace rcc_cfgr1_bits {
        constexpr uint32_t SW = (2 << 0);  ///< system clock switch This bitfield is set and cleared by software to select system clock source (SYSCLK). It is configured by hardware to force MSIS oscillator selection when exiting Standby or Shutdown mode. This bitfield is configured by hardware to force MSIS or HSI16 oscillator selection when exiting Stop mode or in case of HSE oscillator failure, depending on STOPWUCK.
        constexpr uint32_t SWS = (2 << 2);  ///< system clock switch status This bitfield is set and cleared by hardware to indicate which clock source is used as system clock.
        constexpr uint32_t STOPWUCK = (1U << 4);  ///< wake-up from Stop and CSS backup clock selection This bit is set and cleared by software to select the system clock used when exiting Stop mode. The selected clock is also used as emergency clock for the clock security system on�HSE. STOPWUCK must not be modified when the CSS is enabled by HSECSSON in�RCC_CR, and the system clock is HSE (SWS = 10) or a switch on HSE is�requested (SW�=�10).
        constexpr uint32_t STOPKERWUCK = (1U << 5);  ///< wake-up from Stop kernel clock automatic enable selection This bit is set and cleared by software to enable automatically another oscillator when exiting Stop mode. This oscillator can be used as independent kernel clock by peripherals.
        constexpr uint32_t MCOSEL = (4 << 24);  ///< microcontroller clock output This bitfield is set and cleared by software. Others: reserved Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.
        constexpr uint32_t MCOPRE = (3 << 28);  ///< microcontroller clock output prescaler This bitfield is set and cleared by software. It is highly recommended to change this prescaler before MCO output is enabled. Others: not allowed
    }

    /// RCC_CFGR2 Register bits
    namespace rcc_cfgr2_bits {
        constexpr uint32_t HPRE = (4 << 0);  ///< AHB prescaler This bitfiled is set and cleared by software to control the division factor of the AHB clock (HCLK). Depending on the device voltage range, the software must set these bits correctly to ensure that the system frequency does not exceed the maximum allowed frequency (for more details, refer to Table�118). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account. 0xxx: SYSCLK not divided
        constexpr uint32_t PPRE1 = (3 << 4);  ///< APB1 prescaler This bitfiled is set and cleared by software to control the division factor of APB1 clock (PCLK1). 0xx: PCLK1 not divided
        constexpr uint32_t PPRE2 = (3 << 8);  ///< APB2 prescaler This bitfiled is set and cleared by software to control the division factor of APB2 clock (PCLK2). 0xx: PCLK2 not divided
        constexpr uint32_t DPRE = (3 << 12);  ///< DSI PHY prescaler This bitfiled is set and cleared by software to control the division factor of DSI PHY bus clock (DCLK). 0xx: DCLK not divided Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t AHB1DIS = (1U << 16);  ///< AHB1 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB1 peripherals (except those listed hereafter) are used and when their clocks are disabled in RCC_AHB1ENR. When this bit is set, all the AHB1 peripherals clocks are off, except for FLASH, BKPSRAM, ICACHE, DCACHE1 and SRAM1.
        constexpr uint32_t AHB2DIS1 = (1U << 17);  ///< AHB2_1 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB2 peripherals from RCC_AHB2ENR1 (except SRAM2 and SRAM3) are used and when their clocks are disabled in RCC_AHB2ENR1. When this bit is set, all the AHB2 peripherals clocks from RCC_AHB2ENR1 are off, except for SRAM2 and SRAM3.
        constexpr uint32_t AHB2DIS2 = (1U << 18);  ///< AHB2_2 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB2 peripherals from RCC_AHB2ENR2 are used and when their clocks are disabled in RCC_AHB2ENR2. When this bit is set, all the AHB2 peripherals clocks from RCC_AHB2ENR2 are off.
        constexpr uint32_t APB1DIS = (1U << 19);  ///< APB1 clock disable This bit can be set in order to further reduce power consumption, when none of the APB1 peripherals (except IWDG) are used and when their clocks are disabled in RCC_APB1ENR. When this bit is set, all the APB1 peripherals clocks are off, except for IWDG.
        constexpr uint32_t APB2DIS = (1U << 20);  ///< APB2 clock disable This bit can be set in order to further reduce power consumption, when none of the APB2 peripherals are used and when their clocks are disabled in RCC_APB2ENR. When this bit is set, all APB2 peripherals clocks are off.
    }

    /// RCC_CFGR3 Register bits
    namespace rcc_cfgr3_bits {
        constexpr uint32_t PPRE3 = (3 << 4);  ///< APB3 prescaler This bitfield is set and cleared by software to control the division factor of the APB3 clock (PCLK3). 0xx: HCLK not divided
        constexpr uint32_t AHB3DIS = (1U << 16);  ///< AHB3 clock disable This bit can be set in order to further reduce power consumption, when none of the AHB3 peripherals (except SRAM4) are used and when their clocks are disabled in RCC_AHB3ENR. When this bit is set, all the AHB3 peripherals clocks are off, except for SRAM4.
        constexpr uint32_t APB3DIS = (1U << 17);  ///< APB3 clock disable This bit can be set in order to further reduce power consumption, when none of the APB3 peripherals from RCC_APB3ENR are used and when their clocks are disabled in RCC_APB3ENR. When this bit is set, all the APB3 peripherals clocks are off.
    }

    /// RCC_PLL1CFGR Register bits
    namespace rcc_pll1cfgr_bits {
        constexpr uint32_t PLL1SRC = (2 << 0);  ///< PLL1 entry clock source This bitfield is set and cleared by software to select PLL1 clock source. It can be written only when the PLL1 is disabled. In order to save power, when no PLL1 is used, this bitfield value must be zero.
        constexpr uint32_t PLL1RGE = (2 << 2);  ///< PLL1 input frequency range This bit is set and reset by software to select the proper reference frequency range used for PLL1. It must be written before enabling the PLL1. 00-01-10: PLL1 input (ref1_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL1FRACEN = (1U << 4);  ///< PLL1 fractional latch enable This bit is set and reset by software to latch the content of PLL1FRACN in the ΣΔ modulator. In order to latch the PLL1FRACN value into the ΣΔ modulator, PLL1FRACEN must be set to 0, then set to 1: the transition 0 to 1 transfers the content of PLL1FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL1M = (4 << 8);  ///< Prescaler for PLL1 This bitfield is set and cleared by software to configure the prescaler of the PLL1. The VCO1 input frequency is PLL1 input clock frequency/PLL1M. This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1MBOOST = (4 << 12);  ///< Prescaler for EPOD booster input clock This bitfield is set and cleared by software to configure the prescaler of the PLL1, used for the EPOD booster. The EPOD booster input frequency is PLL1�input�clock�frequency/PLL1MBOOST. This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0) and EPODboost mode is disabled (see Section�10: Power control (PWR)). others: reserved
        constexpr uint32_t PLL1PEN = (1U << 16);  ///< PLL1 DIVP divider output enable This bit is set and reset by software to enable the pll1_p_ck output of the PLL1. To save power, PLL1PEN and PLL1P bits must be set to 0 when pll1_p_ck is not used.
        constexpr uint32_t PLL1QEN = (1U << 17);  ///< PLL1 DIVQ divider output enable This bit is set and reset by software to enable the pll1_q_ck output of the PLL1. To save power, PLL1QEN and PLL1Q bits must be set to 0 when pll1_q_ck is not used.
        constexpr uint32_t PLL1REN = (1U << 18);  ///< PLL1 DIVR divider output enable This bit is set and reset by software to enable the pll1_r_ck output of the PLL1. To save power, PLL1RENPLL2REN and PLL1R bits must be set to 0 when pll1_r_ck is not used. This bit can be cleared only when the PLL1 is not used as SYSCLK.
    }

    /// RCC_PLL2CFGR Register bits
    namespace rcc_pll2cfgr_bits {
        constexpr uint32_t PLL2SRC = (2 << 0);  ///< PLL2 entry clock source This bitfield is set and cleared by software to select PLL2 clock source. It can be written only when the PLL2 is disabled. To save power, when no PLL2 is used, this bitfield value must be�zero.
        constexpr uint32_t PLL2RGE = (2 << 2);  ///< PLL2 input frequency range This bitfield is set and reset by software to select the proper reference frequency range used for�PLL2. It must be written before enabling the PLL2. 00-01-10: PLL2 input (ref2_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL2FRACEN = (1U << 4);  ///< PLL2 fractional latch enable This bit is set and reset by software to latch the content of PLL2FRACN in the ΣΔ modulator. In order to latch the PLL2FRACN value into the ΣΔ modulator, PLL2FRACEN must be set to 0, then set to 1: the transition 0 to 1 transfers the content of PLL2FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL2M = (4 << 8);  ///< Prescaler for PLL2 This bitfield is set and cleared by software to configure the prescaler of the PLL2. The VCO2 input frequency is PLL2 input clock frequency/PLL2M. This bit can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2PEN = (1U << 16);  ///< PLL2 DIVP divider output enable This bit is set and reset by software to enable the pll2_p_ck output of the PLL2. To save power, PLL2PEN and PLL2P bits must be set to 0 when pll2_p_ck is not used.
        constexpr uint32_t PLL2QEN = (1U << 17);  ///< PLL2 DIVQ divider output enable This bit is set and reset by software to enable the pll2_q_ck output of the PLL2. To save power, PLL2QEN and PLL2Q bits must be set to 0 when pll2_q_ck is not used.
        constexpr uint32_t PLL2REN = (1U << 18);  ///< PLL2 DIVR divider output enable This bit is set and reset by software to enable the pll2_r_ck output of the PLL2. To save power, PLL2REN and PLL2R bits must be set to 0 when pll2_r_ck is not used.
    }

    /// RCC_PLL3CFGR Register bits
    namespace rcc_pll3cfgr_bits {
        constexpr uint32_t PLL3SRC = (2 << 0);  ///< PLL3 entry clock source This bitfield is set and cleared by software to select PLL3 clock source. It can be written only when the PLL3 is disabled. To save power, when no PLL3 is used, this bitfield value must be�zero.
        constexpr uint32_t PLL3RGE = (2 << 2);  ///< PLL3 input frequency range This bit is set and reset by software to select the proper reference frequency range used for�PLL3. It must be written before enabling the PLL3. 00-01-10: PLL3 input (ref3_ck) clock range frequency between 4 and 8 MHz
        constexpr uint32_t PLL3FRACEN = (1U << 4);  ///< PLL3 fractional latch enable This bit is set and reset by software to latch the content of PLL3FRACN in the ΣΔ modulator. In order to latch the PLL3FRACN value into the ΣΔ modulator, PLL3FRACEN must be set to 0, then set to 1: the transition 0 to 1 transfers the content of PLL3FRACN into the modulator (see PLL initialization phase for details).
        constexpr uint32_t PLL3M = (4 << 8);  ///< Prescaler for PLL3 This bitfield is set and cleared by software to configure the prescaler of the PLL3. The VCO3 input frequency is PLL3 input clock frequency/PLL3M. This bitfield can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3PEN = (1U << 16);  ///< PLL3 DIVP divider output enable This bit is set and reset by software to enable the pll3_p_ck output of the PLL3. To save power, PLL3PEN and PLL3P bits must be set to 0 when pll3_p_ck is not used.
        constexpr uint32_t PLL3QEN = (1U << 17);  ///< PLL3 DIVQ divider output enable This bit is set and reset by software to enable the pll3_q_ck output of the PLL3. To save power, PLL3QEN and PLL3Q bits must be set to 0 when pll3_q_ck is not used.
        constexpr uint32_t PLL3REN = (1U << 18);  ///< PLL3 DIVR divider output enable This bit is set and reset by software to enable the pll3_r_ck output of the PLL3. To save power, PLL3REN and PLL3R bits must be set to 0 when pll3_r_ck is not used.
    }

    /// RCC_PLL1DIVR Register bits
    namespace rcc_pll1divr_bits {
        constexpr uint32_t PLL1N = (9 << 0);  ///< Multiplication factor for PLL1 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL1ON = 0 and PLL1RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref1_ck</sub> x PLL1N, when fractional value 0 has been loaded in PLL1FRACN, with: PLL1N between 4 and 512 input frequency F<sub>ref1_ck</sub> between 4 and 16�MHz
        constexpr uint32_t PLL1P = (7 << 9);  ///< PLL1 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll1_p_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1Q = (7 << 16);  ///< PLL1 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll1_q_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). ...
        constexpr uint32_t PLL1R = (7 << 24);  ///< PLL1 DIVR division factor This bitfield is set and reset by software to control frequency of the pll1_r_ck clock. It can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0). Only division by one and even division factors are allowed. ...
    }

    /// RCC_PLL1FRACR Register bits
    namespace rcc_pll1fracr_bits {
        constexpr uint32_t PLL1FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL1 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL1 VCO. VCO output frequency = F<sub>ref1_ck</sub> x (PLL1N + (PLL1FRACN / 2<sup>13</sup>)), with: PLL1N must be between 4 and 512. PLL1FRACN can be between 0 and 2<sup>13</sup>- 1. The input frequency F<sub>ref1_ck</sub> must be between 4 and 16 MHz. To change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed as�follows: Set PLL1FRACEN = 0. Write the new fractional value into PLL1FRACN. Set PLL1FRACEN = 1.
    }

    /// RCC_PLL2DIVR Register bits
    namespace rcc_pll2divr_bits {
        constexpr uint32_t PLL2N = (9 << 0);  ///< Multiplication factor for PLL2 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL2ON = 0 and PLL2RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref2_ck</sub> x PLL2N, when fractional value 0 has been loaded in PLL2FRACN, with: PLL2N between 4 and 512 input frequency F<sub>ref2_ck</sub> between 1MHz and 16MHz
        constexpr uint32_t PLL2P = (7 << 9);  ///< PLL2 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll2_p_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2Q = (7 << 16);  ///< PLL2 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll2_q_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
        constexpr uint32_t PLL2R = (7 << 24);  ///< PLL2 DIVR division factor This bitfield is set and reset by software to control the frequency of the pll2_r_ck clock. It can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0). ...
    }

    /// RCC_PLL2FRACR Register bits
    namespace rcc_pll2fracr_bits {
        constexpr uint32_t PLL2FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL2 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL2 VCO. VCO output frequency = F<sub>ref2_ck</sub> x (PLL2N + (PLL2FRACN / 2<sup>13</sup>)), with PLL2N must be between 4 and 512. PLL2FRACN can be between 0 and 2<sup>13 </sup>- 1. The input frequency F<sub>ref2_ck</sub> must be between 4 and 16 MHz. In order to change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows: Set the bit PLL2FRACEN to 0. Write the new fractional value into PLL2FRACN. Set the bit PLL2FRACEN to 1.
    }

    /// RCC_PLL3DIVR Register bits
    namespace rcc_pll3divr_bits {
        constexpr uint32_t PLL3N = (9 << 0);  ///< Multiplication factor for PLL3 VCO This bitfield is set and reset by software to control the multiplication factor of the VCO. It can be written only when the PLL is disabled (PLL3ON = 0 and PLL3RDY = 0). ... ... Others: reserved VCO output frequency = F<sub>ref3_ck</sub> x PLL3N, when fractional value 0 has been loaded in PLL3FRACN, with: PLL3N between 4 and 512 input frequency F<sub>ref3_ck</sub> between 4 and 16MHz
        constexpr uint32_t PLL3P = (7 << 9);  ///< PLL3 DIVP division factor This bitfield is set and reset by software to control the frequency of the pll3_p_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3Q = (7 << 16);  ///< PLL3 DIVQ division factor This bitfield is set and reset by software to control the frequency of the pll3_q_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
        constexpr uint32_t PLL3R = (7 << 24);  ///< PLL3 DIVR division factor This bitfield is set and reset by software to control the frequency of the pll3_r_ck clock. It can be written only when the PLL3 is disabled (PLL3ON = 0 and PLL3RDY = 0). ...
    }

    /// RCC_PLL3FRACR Register bits
    namespace rcc_pll3fracr_bits {
        constexpr uint32_t PLL3FRACN = (13 << 3);  ///< Fractional part of the multiplication factor for PLL3 VCO This bitfield is set and reset by software to control the fractional part of the VCO multiplication factor. It can be written at any time, allowing dynamic fine-tuning of the PLL3 VCO. VCO output frequency = F<sub>ref3_ck</sub> x (PLL3N + (PLL3FRACN / 2<sup>13</sup>)), with: PLL3N must be between 4 and 512. PLL3FRACN can be between 0 and 2<sup>13 </sup>- 1. The input frequency F<sub>ref3_ck</sub> must be between 4 and 16 MHz. In order to change the FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows: Set the bit PLL3FRACEN to 0. Write the new fractional value into PLL3FRACN. Set the bit PLL3FRACEN to 1.
    }

    /// RCC_CIER Register bits
    namespace rcc_cier_bits {
        constexpr uint32_t LSIRDYIE = (1U << 0);  ///< LSI ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization.
        constexpr uint32_t LSERDYIE = (1U << 1);  ///< LSE ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization.
        constexpr uint32_t MSISRDYIE = (1U << 2);  ///< MSIS ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the MSIS oscillator stabilization.
        constexpr uint32_t HSIRDYIE = (1U << 3);  ///< HSI16 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization.
        constexpr uint32_t HSERDYIE = (1U << 4);  ///< HSE ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization.
        constexpr uint32_t HSI48RDYIE = (1U << 5);  ///< HSI48 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the HSI48 oscillator stabilization.
        constexpr uint32_t PLL1RDYIE = (1U << 6);  ///< PLL ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL1 lock.
        constexpr uint32_t PLL2RDYIE = (1U << 7);  ///< PLL2 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL2 lock.
        constexpr uint32_t PLL3RDYIE = (1U << 8);  ///< PLL3 ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by PLL3 lock.
        constexpr uint32_t MSIKRDYIE = (1U << 11);  ///< MSIK ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the MSIK oscillator stabilization.
        constexpr uint32_t SHSIRDYIE = (1U << 12);  ///< SHSI ready interrupt enable This bit is set and cleared by software to enable/disable interrupt caused by the SHSI oscillator stabilization.
    }

    /// RCC_CIFR Register bits
    namespace rcc_cifr_bits {
        constexpr uint32_t LSIRDYF = (1U << 0);  ///< LSI ready interrupt flag This bit is set by hardware when the LSI clock becomes stable and LSIRDYIE is set. It is cleared by software by�setting the LSIRDYC bit.
        constexpr uint32_t LSERDYF = (1U << 1);  ///< LSE ready interrupt flag This bit is set by hardware when the LSE clock becomes stable and LSERDYIE is set. It is cleared by software by setting the LSERDYC bit.
        constexpr uint32_t MSISRDYF = (1U << 2);  ///< MSIS ready interrupt flag This bit is set by hardware when the MSIS clock becomes stable and MSISRDYIE is set. It�is cleared by software by setting the MSISRDYC bit.
        constexpr uint32_t HSIRDYF = (1U << 3);  ///< HSI16 ready interrupt flag This bit is set by hardware when the HSI16 clock becomes stable and HSIRDYIE = 1 in�response to setting the HSION (see RCC_CR). When HSION = 0 but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated. This bit is cleared by software by setting the HSIRDYC bit.
        constexpr uint32_t HSERDYF = (1U << 4);  ///< HSE ready interrupt flag This bit is set by hardware when the HSE clock becomes stable and HSERDYIE is set. It is cleared by software by setting the HSERDYC bit.
        constexpr uint32_t HSI48RDYF = (1U << 5);  ///< HSI48 ready interrupt flag This bit is set by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set. it�is cleared by software by setting the HSI48RDYC bit.
        constexpr uint32_t PLL1RDYF = (1U << 6);  ///< PLL1 ready interrupt flag This bit is set by hardware when the PLL1 locks and PLL1RDYIE is set. It is cleared by software by setting the PLL1RDYC bit.
        constexpr uint32_t PLL2RDYF = (1U << 7);  ///< PLL2 ready interrupt flag This bit is set by hardware when the PLL2 locks and PLL2RDYIE is set. It is cleared by software by setting the PLL2RDYC bit.
        constexpr uint32_t PLL3RDYF = (1U << 8);  ///< PLL3 ready interrupt flag This bit is set by hardware when the PLL3 locks and PLL3RDYIE is set. It is cleared by software by setting the PLL3RDYC bit.
        constexpr uint32_t CSSF = (1U << 10);  ///< Clock security system interrupt flag This bit is set by hardware when a failure is detected in the HSE oscillator. It is cleared by software by setting the CSSC bit.
        constexpr uint32_t MSIKRDYF = (1U << 11);  ///< MSIK ready interrupt flag This bit is set by hardware when the MSIK clock becomes stable and MSIKRDYIE is set. It is cleared by software by setting the MSIKRDYC bit.
        constexpr uint32_t SHSIRDYF = (1U << 12);  ///< SHSI ready interrupt flag This bit is set by hardware when the SHSI clock becomes stable and SHSIRDYIE is set. It is cleared by software by setting the SHSIRDYC bit.
    }

    /// RCC_CICR Register bits
    namespace rcc_cicr_bits {
        constexpr uint32_t LSIRDYC = (1U << 0);  ///< LSI ready interrupt clear Writing this bit to 1 clears the LSIRDYF flag. Writing 0 has no effect.
        constexpr uint32_t LSERDYC = (1U << 1);  ///< LSE ready interrupt clear Writing this bit to 1 clears the LSERDYF flag. Writing 0 has no effect.
        constexpr uint32_t MSISRDYC = (1U << 2);  ///< MSIS ready interrupt clear Writing this bit to 1 clears the MSISRDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSIRDYC = (1U << 3);  ///< HSI16 ready interrupt clear Writing this bit to 1 clears the HSIRDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSERDYC = (1U << 4);  ///< HSE ready interrupt clear Writing this bit to 1 clears the HSERDYF flag. Writing 0 has no effect.
        constexpr uint32_t HSI48RDYC = (1U << 5);  ///< HSI48 ready interrupt clear Writing this bit to 1 clears the HSI48RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL1RDYC = (1U << 6);  ///< PLL1 ready interrupt clear Writing this bit to 1 clears the PLL1RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL2RDYC = (1U << 7);  ///< PLL2 ready interrupt clear Writing this bit to 1 clears the PLL2RDYF flag. Writing 0 has no effect.
        constexpr uint32_t PLL3RDYC = (1U << 8);  ///< PLL3 ready interrupt clear Writing this bit to 1 clears the PLL3RDYF flag. Writing 0 has no effect.
        constexpr uint32_t CSSC = (1U << 10);  ///< Clock security system interrupt clear Writing this bit to 1 clears the CSSF flag. Writing 0 has no effect.
        constexpr uint32_t MSIKRDYC = (1U << 11);  ///< MSIK oscillator ready interrupt clear Writing this bit to 1 clears the MSIKRDYF flag. Writing 0 has no effect.
        constexpr uint32_t SHSIRDYC = (1U << 12);  ///< SHSI oscillator ready interrupt clear Writing this bit to 1 clears the SHSIRDYF flag. Writing 0 has no effect.
    }

    /// RCC_AHB1RSTR Register bits
    namespace rcc_ahb1rstr_bits {
        constexpr uint32_t GPDMA1RST = (1U << 0);  ///< GPDMA1 reset This bit is set and cleared by software.
        constexpr uint32_t CORDICRST = (1U << 1);  ///< CORDIC reset This bit is set and cleared by software.
        constexpr uint32_t FMACRST = (1U << 2);  ///< FMAC reset This bit is set and cleared by software.
        constexpr uint32_t MDF1RST = (1U << 3);  ///< MDF1 reset This bit is set and cleared by software.
        constexpr uint32_t CRCRST = (1U << 12);  ///< CRC reset This bit is set and cleared by software.
        constexpr uint32_t JPEGRST = (1U << 15);  ///< JPEG reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCRST = (1U << 16);  ///< TSC reset This bit is set and cleared by software.
        constexpr uint32_t RAMCFGRST = (1U << 17);  ///< RAMCFG reset This bit is set and cleared by software.
        constexpr uint32_t DMA2DRST = (1U << 18);  ///< DMA2D reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMURST = (1U << 19);  ///< GFXMMU reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DRST = (1U << 20);  ///< GPU2D reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2RSTR1 Register bits
    namespace rcc_ahb2rstr1_bits {
        constexpr uint32_t GPIOARST = (1U << 0);  ///< I/O port A reset This bit is set and cleared by software.
        constexpr uint32_t GPIOBRST = (1U << 1);  ///< I/O port B reset This bit is set and cleared by software.
        constexpr uint32_t GPIOCRST = (1U << 2);  ///< I/O port C reset This bit is set and cleared by software.
        constexpr uint32_t GPIODRST = (1U << 3);  ///< I/O port D reset This bit is set and cleared by software.
        constexpr uint32_t GPIOERST = (1U << 4);  ///< I/O port E reset This bit is set and cleared by software.
        constexpr uint32_t GPIOFRST = (1U << 5);  ///< I/O port F reset This bit is set and cleared by software. This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. Note: If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGRST = (1U << 6);  ///< I/O port G reset This bit is set and cleared by software.
        constexpr uint32_t GPIOHRST = (1U << 7);  ///< I/O port H reset This bit is set and cleared by software.
        constexpr uint32_t GPIOIRST = (1U << 8);  ///< I/O port I reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJRST = (1U << 9);  ///< I/O port J reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12RST = (1U << 10);  ///< ADC1 and ADC2 reset This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585, and ADC1/ADC2 in�STM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSIRST = (1U << 12);  ///< DCMI and PSSI reset This bit is set and cleared by software.
        constexpr uint32_t OTGRST = (1U << 14);  ///< OTG_FS or OTG_HS reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESRST = (1U << 16);  ///< AES hardware accelerator reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHRST = (1U << 17);  ///< HASH reset This bit is set and cleared by software.
        constexpr uint32_t RNGRST = (1U << 18);  ///< RNG reset This bit is set and cleared by software.
        constexpr uint32_t PKARST = (1U << 19);  ///< PKA reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESRST = (1U << 20);  ///< SAES hardware accelerator reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMRST = (1U << 21);  ///< OCTOSPIM reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1RST = (1U << 23);  ///< OTFDEC1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2RST = (1U << 24);  ///< OTFDEC2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1RST = (1U << 27);  ///< SDMMC1 reset This bit is set and cleared by software.
        constexpr uint32_t SDMMC2RST = (1U << 28);  ///< SDMMC2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2RSTR2 Register bits
    namespace rcc_ahb2rstr2_bits {
        constexpr uint32_t FSMCRST = (1U << 0);  ///< Flexible memory controller reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1RST = (1U << 4);  ///< OCTOSPI1 reset This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2RST = (1U << 8);  ///< OCTOSPI2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1RST = (1U << 12);  ///< HSPI1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3RSTR Register bits
    namespace rcc_ahb3rstr_bits {
        constexpr uint32_t LPGPIO1RST = (1U << 0);  ///< LPGPIO1 reset This bit is set and cleared by software.
        constexpr uint32_t ADC4RST = (1U << 5);  ///< ADC4 reset This bit is set and cleared by software.
        constexpr uint32_t DAC1RST = (1U << 6);  ///< DAC1 reset This bit is set and cleared by software.
        constexpr uint32_t LPDMA1RST = (1U << 9);  ///< LPDMA1 reset This bit is set and cleared by software.
        constexpr uint32_t ADF1RST = (1U << 10);  ///< ADF1 reset This bit is set and cleared by software.
    }

    /// RCC_APB1RSTR1 Register bits
    namespace rcc_apb1rstr1_bits {
        constexpr uint32_t TIM2RST = (1U << 0);  ///< TIM2 reset This bit is set and cleared by software.
        constexpr uint32_t TIM3RST = (1U << 1);  ///< TIM3 reset This bit is set and cleared by software.
        constexpr uint32_t TIM4RST = (1U << 2);  ///< TIM4 reset This bit is set and cleared by software.
        constexpr uint32_t TIM5RST = (1U << 3);  ///< TIM5 reset This bit is set and cleared by software.
        constexpr uint32_t TIM6RST = (1U << 4);  ///< TIM6 reset This bit is set and cleared by software.
        constexpr uint32_t TIM7RST = (1U << 5);  ///< TIM7 reset This bit is set and cleared by software.
        constexpr uint32_t SPI2RST = (1U << 14);  ///< SPI2 reset This bit is set and cleared by software.
        constexpr uint32_t USART2RST = (1U << 17);  ///< USART2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series.Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3RST = (1U << 18);  ///< USART3 reset This bit is set and cleared by software.
        constexpr uint32_t UART4RST = (1U << 19);  ///< UART4 reset This bit is set and cleared by software.
        constexpr uint32_t UART5RST = (1U << 20);  ///< UART5 reset This bit is set and cleared by software.
        constexpr uint32_t I2C1RST = (1U << 21);  ///< I2C1 reset This bit is set and cleared by software.
        constexpr uint32_t I2C2RST = (1U << 22);  ///< I2C2 reset This bit is set and cleared by software.
        constexpr uint32_t CRSRST = (1U << 24);  ///< CRS reset This bit is set and cleared by software.
        constexpr uint32_t USART6RST = (1U << 25);  ///< USART6 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1RSTR2 Register bits
    namespace rcc_apb1rstr2_bits {
        constexpr uint32_t I2C4RST = (1U << 1);  ///< I2C4 reset This bit is set and cleared by software
        constexpr uint32_t LPTIM2RST = (1U << 5);  ///< LPTIM2 reset This bit is set and cleared by software.
        constexpr uint32_t I2C5RST = (1U << 6);  ///< I2C5 reset This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6RST = (1U << 7);  ///< I2C6 reset This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1RST = (1U << 9);  ///< FDCAN1 reset This bit is set and cleared by software.
        constexpr uint32_t UCPD1RST = (1U << 23);  ///< UCPD1 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2RSTR Register bits
    namespace rcc_apb2rstr_bits {
        constexpr uint32_t TIM1RST = (1U << 11);  ///< TIM1 reset This bit is set and cleared by software.
        constexpr uint32_t SPI1RST = (1U << 12);  ///< SPI1 reset This bit is set and cleared by software.
        constexpr uint32_t TIM8RST = (1U << 13);  ///< TIM8 reset This bit is set and cleared by software.
        constexpr uint32_t USART1RST = (1U << 14);  ///< USART1 reset This bit is set and cleared by software.
        constexpr uint32_t TIM15RST = (1U << 16);  ///< TIM15 reset This bit is set and cleared by software.
        constexpr uint32_t TIM16RST = (1U << 17);  ///< TIM16 reset This bit is set and cleared by software.
        constexpr uint32_t TIM17RST = (1U << 18);  ///< TIM17 reset This bit is set and cleared by software.
        constexpr uint32_t SAI1RST = (1U << 21);  ///< SAI1 reset This bit is set and cleared by software.
        constexpr uint32_t SAI2RST = (1U << 22);  ///< SAI2 reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBRST = (1U << 24);  ///< USB reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMRST = (1U << 25);  ///< GFXTIM reset This bit is set and cleared by software. Note: .This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCRST = (1U << 26);  ///< LTDC reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSIRST = (1U << 27);  ///< DSI reset This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3RSTR Register bits
    namespace rcc_apb3rstr_bits {
        constexpr uint32_t SYSCFGRST = (1U << 1);  ///< SYSCFG reset This bit is set and cleared by software.
        constexpr uint32_t SPI3RST = (1U << 5);  ///< SPI3 reset This bit is set and cleared by software.
        constexpr uint32_t LPUART1RST = (1U << 6);  ///< LPUART1 reset This bit is set and cleared by software.
        constexpr uint32_t I2C3RST = (1U << 7);  ///< I2C3 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM1RST = (1U << 11);  ///< LPTIM1 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM3RST = (1U << 12);  ///< LPTIM3 reset This bit is set and cleared by software.
        constexpr uint32_t LPTIM4RST = (1U << 13);  ///< LPTIM4 reset This bit is set and cleared by software.
        constexpr uint32_t OPAMPRST = (1U << 14);  ///< OPAMP reset This bit is set and cleared by software.
        constexpr uint32_t COMPRST = (1U << 15);  ///< COMP reset This bit is set and cleared by software.
        constexpr uint32_t VREFRST = (1U << 20);  ///< VREFBUF reset This bit is set and cleared by software.
    }

    /// RCC_AHB1ENR Register bits
    namespace rcc_ahb1enr_bits {
        constexpr uint32_t GPDMA1EN = (1U << 0);  ///< GPDMA1 clock enable This bit is set and cleared by software.
        constexpr uint32_t CORDICEN = (1U << 1);  ///< CORDIC clock enable This bit is set and cleared by software.
        constexpr uint32_t FMACEN = (1U << 2);  ///< FMAC clock enable This bit is set and reset by software.
        constexpr uint32_t MDF1EN = (1U << 3);  ///< MDF1 clock enable This bit is set and reset by software.
        constexpr uint32_t FLASHEN = (1U << 8);  ///< FLASH clock enable This bit is set and cleared by software. This bit can be disabled only when the flash memory is in power-down mode.
        constexpr uint32_t CRCEN = (1U << 12);  ///< CRC clock enable This bit is set and cleared by software.
        constexpr uint32_t JPEGEN = (1U << 15);  ///< JPEG clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCEN = (1U << 16);  ///< Touch sensing controller clock enable This bit is set and cleared by software.
        constexpr uint32_t RAMCFGEN = (1U << 17);  ///< RAMCFG clock enable This bit is set and cleared by software.
        constexpr uint32_t DMA2DEN = (1U << 18);  ///< DMA2D clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMUEN = (1U << 19);  ///< GFXMMU clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DEN = (1U << 20);  ///< GPU2D clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DCACHE2EN = (1U << 21);  ///< DCACHE2 clock enable This bit is set and reset by software. Note: DCACHE2 clock must be enabled to access memories, even if the DCACHE2 is bypassed. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GTZC1EN = (1U << 24);  ///< GTZC1 clock enable This bit is set and reset by software.
        constexpr uint32_t BKPSRAMEN = (1U << 28);  ///< BKPSRAM clock enable This bit is set and reset by software.
        constexpr uint32_t DCACHE1EN = (1U << 30);  ///< DCACHE1 clock enable This bit is set and reset by software. Note: DCACHE1 clock must be enabled when external memories are accessed through OCTOSPI1, OCTOSPI2, HSPI1 or FSMC, even if the DCACHE1 is bypassed.
        constexpr uint32_t SRAM1EN = (1U << 31);  ///< SRAM1 clock enable This bit is set and reset by software.
    }

    /// RCC_AHB2ENR1 Register bits
    namespace rcc_ahb2enr1_bits {
        constexpr uint32_t GPIOAEN = (1U << 0);  ///< I/O port A clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOBEN = (1U << 1);  ///< I/O port B clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOCEN = (1U << 2);  ///< I/O port C clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIODEN = (1U << 3);  ///< I/O port D clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOEEN = (1U << 4);  ///< I/O port E clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOFEN = (1U << 5);  ///< I/O port F clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGEN = (1U << 6);  ///< I/O port G clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOHEN = (1U << 7);  ///< I/O port H clock enable This bit is set and cleared by software.
        constexpr uint32_t GPIOIEN = (1U << 8);  ///< I/O port I clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJEN = (1U << 9);  ///< I/O port J clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12EN = (1U << 10);  ///< ADC1 and ADC2 clock enable This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585, and ADC1/ADC2 in�STM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSIEN = (1U << 12);  ///< DCMI and PSSI clock enable This bit is set and cleared by software.
        constexpr uint32_t OTGEN = (1U << 14);  ///< OTG_FS or OTG_HS clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTGHSPHYEN = (1U << 15);  ///< OTG_HS PHY clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESEN = (1U << 16);  ///< AES clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHEN = (1U << 17);  ///< HASH clock enable This bit is set and cleared by software
        constexpr uint32_t RNGEN = (1U << 18);  ///< RNG clock enable This bit is set and cleared by software.
        constexpr uint32_t PKAEN = (1U << 19);  ///< PKA clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESEN = (1U << 20);  ///< SAES clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMEN = (1U << 21);  ///< OCTOSPIM clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1EN = (1U << 23);  ///< OTFDEC1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2EN = (1U << 24);  ///< OTFDEC2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1EN = (1U << 27);  ///< SDMMC1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SDMMC2EN = (1U << 28);  ///< SDMMC2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM2EN = (1U << 30);  ///< SRAM2 clock enable This bit is set and reset by software.
        constexpr uint32_t SRAM3EN = (1U << 31);  ///< SRAM3 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2ENR2 Register bits
    namespace rcc_ahb2enr2_bits {
        constexpr uint32_t FSMCEN = (1U << 0);  ///< FSMC clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1EN = (1U << 4);  ///< OCTOSPI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2EN = (1U << 8);  ///< OCTOSPI2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1EN = (1U << 12);  ///< HSPI1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM6EN = (1U << 30);  ///< SRAM6 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM5EN = (1U << 31);  ///< SRAM5 clock enable This bit is set and reset by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3ENR Register bits
    namespace rcc_ahb3enr_bits {
        constexpr uint32_t LPGPIO1EN = (1U << 0);  ///< LPGPIO1 enable This bit is set and cleared by software.
        constexpr uint32_t PWREN = (1U << 2);  ///< PWR clock enable This bit is set and cleared by software.
        constexpr uint32_t ADC4EN = (1U << 5);  ///< ADC4 clock enable This bit is set and cleared by software.
        constexpr uint32_t DAC1EN = (1U << 6);  ///< DAC1 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPDMA1EN = (1U << 9);  ///< LPDMA1 clock enable This bit is set and cleared by software.
        constexpr uint32_t ADF1EN = (1U << 10);  ///< ADF1 clock enable This bit is set and cleared by software.
        constexpr uint32_t GTZC2EN = (1U << 12);  ///< GTZC2 clock enable This bit is set and cleared by software.
        constexpr uint32_t SRAM4EN = (1U << 31);  ///< SRAM4 clock enable This bit is set and reset by software.
    }

    /// RCC_APB1ENR1 Register bits
    namespace rcc_apb1enr1_bits {
        constexpr uint32_t TIM2EN = (1U << 0);  ///< TIM2 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM3EN = (1U << 1);  ///< TIM3 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM4EN = (1U << 2);  ///< TIM4 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM5EN = (1U << 3);  ///< TIM5 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM6EN = (1U << 4);  ///< TIM6 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM7EN = (1U << 5);  ///< TIM7 clock enable This bit is set and cleared by software.
        constexpr uint32_t WWDGEN = (1U << 11);  ///< WWDG clock enable This bit is set by software to enable the window watchdog clock. It is reset by hardware system reset. This bit can also be set by hardware if the WWDG_SW option bit is reset.
        constexpr uint32_t SPI2EN = (1U << 14);  ///< SPI2 clock enable This bit is set and cleared by software.
        constexpr uint32_t USART2EN = (1U << 17);  ///< USART2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3EN = (1U << 18);  ///< USART3 clock enable This bit is set and cleared by software.
        constexpr uint32_t UART4EN = (1U << 19);  ///< UART4 clock enable This bit is set and cleared by software.
        constexpr uint32_t UART5EN = (1U << 20);  ///< UART5 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C1EN = (1U << 21);  ///< I2C1 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C2EN = (1U << 22);  ///< I2C2 clock enable This bit is set and cleared by software.
        constexpr uint32_t CRSEN = (1U << 24);  ///< CRS clock enable This bit is set and cleared by software.
        constexpr uint32_t USART6EN = (1U << 25);  ///< USART6 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1ENR2 Register bits
    namespace rcc_apb1enr2_bits {
        constexpr uint32_t I2C4EN = (1U << 1);  ///< I2C4 clock enable This bit is set and cleared by software
        constexpr uint32_t LPTIM2EN = (1U << 5);  ///< LPTIM2 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C5EN = (1U << 6);  ///< I2C5 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6EN = (1U << 7);  ///< I2C6 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1EN = (1U << 9);  ///< FDCAN1 clock enable This bit is set and cleared by software.
        constexpr uint32_t UCPD1EN = (1U << 23);  ///< UCPD1 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2ENR Register bits
    namespace rcc_apb2enr_bits {
        constexpr uint32_t TIM1EN = (1U << 11);  ///< TIM1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SPI1EN = (1U << 12);  ///< SPI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM8EN = (1U << 13);  ///< TIM8 clock enable This bit is set and cleared by software.
        constexpr uint32_t USART1EN = (1U << 14);  ///< USART1clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM15EN = (1U << 16);  ///< TIM15 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM16EN = (1U << 17);  ///< TIM16 clock enable This bit is set and cleared by software.
        constexpr uint32_t TIM17EN = (1U << 18);  ///< TIM17 clock enable This bit is set and cleared by software.
        constexpr uint32_t SAI1EN = (1U << 21);  ///< SAI1 clock enable This bit is set and cleared by software.
        constexpr uint32_t SAI2EN = (1U << 22);  ///< SAI2 clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBEN = (1U << 24);  ///< USB clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMEN = (1U << 25);  ///< GFXTIM clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCEN = (1U << 26);  ///< LTDC clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSIEN = (1U << 27);  ///< DSI clock enable This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3ENR Register bits
    namespace rcc_apb3enr_bits {
        constexpr uint32_t SYSCFGEN = (1U << 1);  ///< SYSCFG clock enable This bit is set and cleared by software.
        constexpr uint32_t SPI3EN = (1U << 5);  ///< SPI3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPUART1EN = (1U << 6);  ///< LPUART1 clock enable This bit is set and cleared by software.
        constexpr uint32_t I2C3EN = (1U << 7);  ///< I2C3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM1EN = (1U << 11);  ///< LPTIM1 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM3EN = (1U << 12);  ///< LPTIM3 clock enable This bit is set and cleared by software.
        constexpr uint32_t LPTIM4EN = (1U << 13);  ///< LPTIM4 clock enable This bit is set and cleared by software.
        constexpr uint32_t OPAMPEN = (1U << 14);  ///< OPAMP clock enable This bit is set and cleared by software.
        constexpr uint32_t COMPEN = (1U << 15);  ///< COMP clock enable This bit is set and cleared by software.
        constexpr uint32_t VREFEN = (1U << 20);  ///< VREFBUF clock enable This bit is set and cleared by software.
        constexpr uint32_t RTCAPBEN = (1U << 21);  ///< RTC and TAMP APB clock enable This bit is set and cleared by software.
    }

    /// RCC_AHB1SMENR Register bits
    namespace rcc_ahb1smenr_bits {
        constexpr uint32_t GPDMA1SMEN = (1U << 0);  ///< GPDMA1 clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t CORDICSMEN = (1U << 1);  ///< CORDIC clocks enable during Sleep and Stop modes This bit is set and cleared by software during Sleep mode.
        constexpr uint32_t FMACSMEN = (1U << 2);  ///< FMAC clocks enable during Sleep and Stop modes. This bit is set and cleared by software.
        constexpr uint32_t MDF1SMEN = (1U << 3);  ///< MDF1 clocks enable during Sleep and Stop modes. This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t FLASHSMEN = (1U << 8);  ///< FLASH clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t CRCSMEN = (1U << 12);  ///< CRC clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t JPEGSMEN = (1U << 15);  ///< JPEG clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t TSCSMEN = (1U << 16);  ///< TSC clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t RAMCFGSMEN = (1U << 17);  ///< RAMCFG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t DMA2DSMEN = (1U << 18);  ///< DMA2D clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXMMUSMEN = (1U << 19);  ///< GFXMMU clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPU2DSMEN = (1U << 20);  ///< GPU2D clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DCACHE2SMEN = (1U << 21);  ///< DCACHE2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GTZC1SMEN = (1U << 24);  ///< GTZC1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t BKPSRAMSMEN = (1U << 28);  ///< BKPSRAM clock enable during Sleep and Stop modes This bit is set and cleared by software
        constexpr uint32_t ICACHESMEN = (1U << 29);  ///< ICACHE clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t DCACHE1SMEN = (1U << 30);  ///< DCACHE1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM1SMEN = (1U << 31);  ///< SRAM1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
    }

    /// RCC_AHB2SMENR1 Register bits
    namespace rcc_ahb2smenr1_bits {
        constexpr uint32_t GPIOASMEN = (1U << 0);  ///< I/O port A clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOBSMEN = (1U << 1);  ///< I/O port B clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOCSMEN = (1U << 2);  ///< I/O port C clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIODSMEN = (1U << 3);  ///< I/O port D clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOESMEN = (1U << 4);  ///< I/O port E clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOFSMEN = (1U << 5);  ///< I/O port F clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOGSMEN = (1U << 6);  ///< I/O port G clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOHSMEN = (1U << 7);  ///< I/O port H clocks enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t GPIOISMEN = (1U << 8);  ///< I/O port I clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GPIOJSMEN = (1U << 9);  ///< I/O port J clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t ADC12SMEN = (1U << 10);  ///< ADC1 and ADC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit impacts ADC1 in STM32U535/545/575/585 and ADC1/ADC2 in�STM32U59x/5Ax/5Fx/5Gx.
        constexpr uint32_t DCMI_PSSISMEN = (1U << 12);  ///< DCMI and PSSI clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t OTGSMEN = (1U << 14);  ///< OTG_FS and OTG_HS clocks enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTGHSPHYSMEN = (1U << 15);  ///< OTG_HS PHY clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t AESSMEN = (1U << 16);  ///< AES clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HASHSMEN = (1U << 17);  ///< HASH clock enable during Sleep and Stop modes This bit is set and cleared by software
        constexpr uint32_t RNGSMEN = (1U << 18);  ///< RNG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t PKASMEN = (1U << 19);  ///< PKA clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SAESSMEN = (1U << 20);  ///< SAES accelerator clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPIMSMEN = (1U << 21);  ///< OCTOSPIM clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC1SMEN = (1U << 23);  ///< OTFDEC1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OTFDEC2SMEN = (1U << 24);  ///< OTFDEC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SDMMC1SMEN = (1U << 27);  ///< SDMMC1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SDMMC2SMEN = (1U << 28);  ///< SDMMC2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM2SMEN = (1U << 30);  ///< SRAM2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM3SMEN = (1U << 31);  ///< SRAM3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB2SMENR2 Register bits
    namespace rcc_ahb2smenr2_bits {
        constexpr uint32_t FSMCSMEN = (1U << 0);  ///< FSMC clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPI1SMEN = (1U << 4);  ///< OCTOSPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t OCTOSPI2SMEN = (1U << 8);  ///< OCTOSPI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t HSPI1SMEN = (1U << 12);  ///< HSPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM6SMEN = (1U << 30);  ///< SRAM6 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t SRAM5SMEN = (1U << 31);  ///< SRAM5 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_AHB3SMENR Register bits
    namespace rcc_ahb3smenr_bits {
        constexpr uint32_t LPGPIO1SMEN = (1U << 0);  ///< LPGPIO1 enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t PWRSMEN = (1U << 2);  ///< PWR clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t ADC4SMEN = (1U << 5);  ///< ADC4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t DAC1SMEN = (1U << 6);  ///< DAC1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPDMA1SMEN = (1U << 9);  ///< LPDMA1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADF1SMEN = (1U << 10);  ///< ADF1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t GTZC2SMEN = (1U << 12);  ///< GTZC2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SRAM4SMEN = (1U << 31);  ///< SRAM4 clock enable during Sleep and Stop modes This bit is set and cleared by software.
    }

    /// RCC_APB1SMENR1 Register bits
    namespace rcc_apb1smenr1_bits {
        constexpr uint32_t TIM2SMEN = (1U << 0);  ///< TIM2 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM3SMEN = (1U << 1);  ///< TIM3 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM4SMEN = (1U << 2);  ///< TIM4 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM5SMEN = (1U << 3);  ///< TIM5 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM6SMEN = (1U << 4);  ///< TIM6 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM7SMEN = (1U << 5);  ///< TIM7 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t WWDGSMEN = (1U << 11);  ///< Window watchdog clock enable during Sleep and Stop modes This bit is set and cleared by software. It is forced to one by hardware when the hardware WWDG option is activated.
        constexpr uint32_t SPI2SMEN = (1U << 14);  ///< SPI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t USART2SMEN = (1U << 17);  ///< USART2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART3SMEN = (1U << 18);  ///< USART3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t UART4SMEN = (1U << 19);  ///< UART4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t UART5SMEN = (1U << 20);  ///< UART5 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C1SMEN = (1U << 21);  ///< I2C1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C2SMEN = (1U << 22);  ///< I2C2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t CRSSMEN = (1U << 24);  ///< CRS clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t USART6SMEN = (1U << 25);  ///< USART6 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB1SMENR2 Register bits
    namespace rcc_apb1smenr2_bits {
        constexpr uint32_t I2C4SMEN = (1U << 1);  ///< I2C4 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM2SMEN = (1U << 5);  ///< LPTIM2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C5SMEN = (1U << 6);  ///< I2C5 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t I2C6SMEN = (1U << 7);  ///< I2C6 clock enable during Sleep and Stop modes This bit is set and cleared by software Note: This bit must be set to allow the peripheral to wake up from Stop modes. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t FDCAN1SMEN = (1U << 9);  ///< FDCAN1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t UCPD1SMEN = (1U << 23);  ///< UCPD1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB2SMENR Register bits
    namespace rcc_apb2smenr_bits {
        constexpr uint32_t TIM1SMEN = (1U << 11);  ///< TIM1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SPI1SMEN = (1U << 12);  ///< SPI1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t TIM8SMEN = (1U << 13);  ///< TIM8 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t USART1SMEN = (1U << 14);  ///< USART1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t TIM15SMEN = (1U << 16);  ///< TIM15 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM16SMEN = (1U << 17);  ///< TIM16 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t TIM17SMEN = (1U << 18);  ///< TIM17 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SAI1SMEN = (1U << 21);  ///< SAI1 clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SAI2SMEN = (1U << 22);  ///< SAI2 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series.Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USBSMEN = (1U << 24);  ///< USB clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t GFXTIMSMEN = (1U << 25);  ///< GFXTIM clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t LTDCSMEN = (1U << 26);  ///< LTDC clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t DSISMEN = (1U << 27);  ///< DSI clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
    }

    /// RCC_APB3SMENR Register bits
    namespace rcc_apb3smenr_bits {
        constexpr uint32_t SYSCFGSMEN = (1U << 1);  ///< SYSCFG clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t SPI3SMEN = (1U << 5);  ///< SPI3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPUART1SMEN = (1U << 6);  ///< LPUART1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C3SMEN = (1U << 7);  ///< I2C3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM1SMEN = (1U << 11);  ///< LPTIM1 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM3SMEN = (1U << 12);  ///< LPTIM3 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM4SMEN = (1U << 13);  ///< LPTIM4 clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t OPAMPSMEN = (1U << 14);  ///< OPAMP clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t COMPSMEN = (1U << 15);  ///< COMP clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t VREFSMEN = (1U << 20);  ///< VREFBUF clock enable during Sleep and Stop modes This bit is set and cleared by software.
        constexpr uint32_t RTCAPBSMEN = (1U << 21);  ///< RTC and TAMP APB clock enable during Sleep and Stop modes This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
    }

    /// RCC_SRDAMR Register bits
    namespace rcc_srdamr_bits {
        constexpr uint32_t SPI3AMEN = (1U << 5);  ///< SPI3 autonomous mode enable in Stop 0,1, 2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPUART1AMEN = (1U << 6);  ///< LPUART1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t I2C3AMEN = (1U << 7);  ///< I2C3 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM1AMEN = (1U << 11);  ///< LPTIM1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM3AMEN = (1U << 12);  ///< LPTIM3 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPTIM4AMEN = (1U << 13);  ///< LPTIM4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t OPAMPAMEN = (1U << 14);  ///< OPAMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t COMPAMEN = (1U << 15);  ///< COMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t VREFAMEN = (1U << 20);  ///< VREFBUF autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t RTCAPBAMEN = (1U << 21);  ///< RTC and TAMP autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADC4AMEN = (1U << 25);  ///< ADC4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPGPIO1AMEN = (1U << 26);  ///< LPGPIO1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
        constexpr uint32_t DAC1AMEN = (1U << 27);  ///< DAC1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t LPDMA1AMEN = (1U << 28);  ///< LPDMA1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t ADF1AMEN = (1U << 29);  ///< ADF1 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software. Note: This bit must be set to allow the peripheral to wake up from Stop modes.
        constexpr uint32_t SRAM4AMEN = (1U << 31);  ///< SRAM4 autonomous mode enable in Stop 0/1/2 mode This bit is set and cleared by software.
    }

    /// RCC_CCIPR1 Register bits
    namespace rcc_ccipr1_bits {
        constexpr uint32_t USART1SEL = (2 << 0);  ///< USART1 kernel clock source selection These bits are used to select the USART1 kernel clock source. Note: The USART1 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t USART2SEL = (2 << 2);  ///< USART2 kernel clock source selection These bits are used to select the USART2 kernel clock source. The USART2 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t USART3SEL = (2 << 4);  ///< USART3 kernel clock source selection These bits are used to select the USART3 kernel clock source. Note: The USART3 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t UART4SEL = (2 << 6);  ///< UART4 kernel clock source selection These bits are used to select the UART4 kernel clock source. Note: The UART4 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t UART5SEL = (2 << 8);  ///< UART5 kernel clock source selection These bits are used to select the UART5 kernel clock source. Note: The UART5 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE.
        constexpr uint32_t I2C1SEL = (2 << 10);  ///< I2C1 kernel clock source selection These bits are used to select the I2C1 kernel clock source. Note: The I2C1 is functional in Stop 0 and Stop 1 mode sonly when the kernel clock is HSI16�or MSIK.
        constexpr uint32_t I2C2SEL = (2 << 12);  ///< I2C2 kernel clock source selection These bits are used to select the I2C2 kernel clock source. Note: The I2C2 is functional in Stop 0 and Stop 1 mode sonly when the kernel clock is HSI16�or MSIK.
        constexpr uint32_t I2C4SEL = (2 << 14);  ///< I2C4 kernel clock source selection These bits are used to select the I2C4 kernel clock source. Note: The I2C4 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16�or MSIK.
        constexpr uint32_t SPI2SEL = (2 << 16);  ///< SPI2 kernel clock source selection These bits are used to select the SPI2 kernel clock source. Note: The SPI2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t LPTIM2SEL = (2 << 18);  ///< Low-power timer 2 kernel clock source selection These bits are used to select the LPTIM2 kernel clock source. Note: The LPTIM2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is LSI, LSE or HSI16 if HSIKERON = 1.
        constexpr uint32_t SPI1SEL = (2 << 20);  ///< SPI1 kernel clock source selection These bits are used to select the SPI1 kernel clock source. Note: The SPI1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t SYSTICKSEL = (2 << 22);  ///< SysTick clock source selection These bits are used to select the SysTick clock source. Note: When LSE or LSI is selected, the AHB frequency must be at least four times higher than the LSI or LSE frequency. In addition, a jitter up to one HCLK cycle is introduced, due to the LSE or LSI sampling with HCLK in the SysTick circuitry.
        constexpr uint32_t FDCAN1SEL = (2 << 24);  ///< FDCAN1 kernel clock source selection These bits are used to select the FDCAN1 kernel clock source.
        constexpr uint32_t ICLKSEL = (2 << 26);  ///< Intermediate clock source selection These bits are used to select the clock source for the OTG_FS, the USB, and the SDMMC.
        constexpr uint32_t TIMICSEL = (3 << 29);  ///< Clock sources for TIM16,TIM17, and LPTIM2 internal input capture When TIMICSEL2 is set, the TIM16, TIM17, and LPTIM2 internal input capture can be connected either to HSI/256, MSI/4, or MSI/1024. Depending on TIMICSEL[1:0] value, MSI is either MSIK or MSIS. When TIMICSEL2 is cleared, the HSI, MSIK, and MSIS clock sources cannot be selected as�TIM16, TIM17, or LPTIM2 internal input capture. 0xx: HSI, MSIK and MSIS dividers disabled Note: The clock division must be disabled (TIMICSEL configured to 0xx) before selecting or changing a clock sources division.
    }

    /// RCC_CCIPR2 Register bits
    namespace rcc_ccipr2_bits {
        constexpr uint32_t MDF1SEL = (3 << 0);  ///< MDF1 kernel clock source selection These bits are used to select the MDF1 kernel clock source. others: reserved
        constexpr uint32_t SAI1SEL = (3 << 5);  ///< SAI1 kernel clock source selection These bits are used to select the SAI1 kernel clock source. others: reserved Note: If the selected clock is the external clock and this clock is stopped, a switch to another clock is impossible.
        constexpr uint32_t SAI2SEL = (3 << 8);  ///< SAI2 kernel clock source selection These bits are used to select the SAI2 kernel clock source. others: reserved If the selected clock is the external clock and this clock is stopped, a switch to another clock is impossible. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t SAESSEL = (1U << 11);  ///< SAES kernel clock source selection This bit is used to select the SAES kernel clock source. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t RNGSEL = (2 << 12);  ///< RNG kernel clock source selection These bits are used to select the RNG kernel clock source.
        constexpr uint32_t SDMMCSEL = (1U << 14);  ///< SDMMC1 and SDMMC2 kernel clock source selection This bit is used to select the SDMMC kernel clock source. It is recommended to change it only after reset and before enabling the SDMMC.
        constexpr uint32_t DSISEL = (1U << 15);  ///< DSI kernel clock source selection This bit is used to select the DSI kernel clock source. This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. Note: If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t USART6SEL = (2 << 16);  ///< USART6 kernel clock source selection These bits are used to select the USART6 kernel clock source. The USART6 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16 or LSE. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t LTDCSEL = (1U << 18);  ///< LTDC kernel clock source selection This bit is used to select the LTDC kernel clock source. Note: This bit is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bit as reserved and keep it at reset value.
        constexpr uint32_t OCTOSPISEL = (2 << 20);  ///< OCTOSPI1 and OCTOSPI2 kernel clock source selection These bits are used to select the OCTOSPI1 and OCTOSPI2 kernel clock source.
        constexpr uint32_t HSPI1SEL = (2 << 22);  ///< HSPI1 kernel clock source selection These bits are used to select the HSPI1 kernel clock source. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t I2C5SEL = (2 << 24);  ///< I2C5 kernel clock source selection These bits are used to select the I2C5 kernel clock source. The I2C5 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16�or MSIK. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t I2C6SEL = (2 << 26);  ///< I2C6 kernel clock source selection These bits are used to select the I2C6 kernel clock source. The I2C6 is functional in Stop 0 and Stop 1 modes only when the kernel clock is HSI16�or MSIK. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
        constexpr uint32_t OTGHSSEL = (2 << 30);  ///< OTG_HS PHY kernel clock source selection These bits are used to select the OTG_HS PHY kernel clock source. Note: This bitfield is only available on some devices in the STM32U5 Series. Refer to the device datasheet for availability of its associated peripheral. If not present, consider this bitfield as reserved and keep it at reset value.
    }

    /// RCC_CCIPR3 Register bits
    namespace rcc_ccipr3_bits {
        constexpr uint32_t LPUART1SEL = (3 << 0);  ///< LPUART1 kernel clock source selection These bits are used to select the LPUART1 kernel clock source. others: reserved Note: The LPUART1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16, LSE, or MSIK.
        constexpr uint32_t SPI3SEL = (2 << 3);  ///< SPI3 kernel clock source selection These bits are used to select the SPI3 kernel clock source. Note: The SPI3 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t I2C3SEL = (2 << 6);  ///< I2C3 kernel clock source selection These bits are used to select the I2C3 kernel clock source. Note: The I2C3 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK.
        constexpr uint32_t LPTIM34SEL = (2 << 8);  ///< LPTIM3 and LPTIM4 kernel clock source selection These bits are used to select the LPTIM3 and LPTIM4 kernel clock source. Note: The LPTIM3 and LPTIM4 are functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is LSI, LSE, HSI16 with HSIKERON = 1, or MSIK with MSIKERON�=�1.
        constexpr uint32_t LPTIM1SEL = (2 << 10);  ///< LPTIM1 kernel clock source selection These bits are used to select the LPTIM1 kernel clock source. Note: The LPTIM1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is LSI, LSE, HSI16 with HSIKERON = 1, or MSIK with MSIKERON = 1.
        constexpr uint32_t ADCDACSEL = (3 << 12);  ///< ADC1, ADC2, ADC4 and DAC1 kernel clock source selection These bits are used to select the ADC1, ADC2, ADC4, and DAC1 kernel clock source. others: reserved Note: The ADC1, ADC2, ADC4, and DAC1 are functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is HSI16 or MSIK (only ADC4 and DAC1 are functional in�Stop 2 mode).
        constexpr uint32_t DAC1SEL = (1U << 15);  ///< DAC1 sample-and-hold clock source selection This bit is used to select the DAC1 sample-and-hold clock source.
        constexpr uint32_t ADF1SEL = (3 << 16);  ///< ADF1 kernel clock source selection These bits are used to select the ADF1 kernel clock source. others: reserved Note: The ADF1 is functional in Stop 0, Stop 1, and Stop 2 modes only when the kernel clock is AUDIOCLK or MSIK.
    }

    /// RCC_BDCR Register bits
    namespace rcc_bdcr_bits {
        constexpr uint32_t LSEON = (1U << 0);  ///< LSE oscillator enable This bit is set and cleared by software.
        constexpr uint32_t LSERDY = (1U << 1);  ///< LSE oscillator ready This bit is set and cleared by hardware to indicate when the external 32�kHz oscillator is stable. After LSEON is cleared, this LSERDY bit goes low after six external low-speed oscillator clock cycles.
        constexpr uint32_t LSEBYP = (1U << 2);  ///< LSE oscillator bypass This bit is set and cleared by software to bypass oscillator in debug mode. It can be written only when the external 32�kHz oscillator is disabled (LSEON = 0 and LSERDY = 0).
        constexpr uint32_t LSEDRV = (2 << 3);  ///< LSE oscillator drive capability This bitfield is set by software to modulate the drive capability of the LSE oscillator. It can be written only when the external 32 kHz oscillator is disabled (LSEON = 0 and LSERDY = 0). Note: The oscillator is in ‘Xtal mode’ when it is not in bypass mode.
        constexpr uint32_t LSECSSON = (1U << 5);  ///< CSS on LSE enable This bit is set by software to enable the CSS on LSE. It must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected. Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD�=�1). In that case, the software must disable this LSECSSON bit.
        constexpr uint32_t LSECSSD = (1U << 6);  ///< CSS on LSE failure detection This bit is set by hardware to indicate when a failure is detected by the CCS on the external 32�kHz oscillator (LSE).
        constexpr uint32_t LSESYSEN = (1U << 7);  ///< LSE system clock (LSESYS) enable This bit is set by software to enable always the LSE system clock generated by RCC, which can be used by any peripheral when its source clock is the LSE, or at system level if one of LSCOSEL, MCO, or MSI PLL mode is needed.
        constexpr uint32_t RTCSEL = (2 << 8);  ///< RTC and TAMP clock source selection This bit is set by software to select the clock source for the RTC and TAMP. Once the RTC and TAMP clock source has been selected, it cannot be changed anymore unless the�backup domain is reset, or unless a failure is detected on LSE (LSECSSD is set). BDRST bit can be used to reset them.
        constexpr uint32_t LSESYSRDY = (1U << 11);  ///< LSE system clock (LSESYS) ready This bit is set and cleared by hardware to indicate when the LSE system clock is stable.When LSESYSEN is set, this LSESYSRDY flag is set after two LSE clock cycles. The LSE clock must be already enabled and stable (LSEON and LSERDY are set). When the LSEON bit is cleared, LSERDY goes low after six external low-speed oscillator clock cycles.
        constexpr uint32_t LSEGFON = (1U << 12);  ///< LSE clock glitch filter enable This bit is set and cleared by hardware to enable the LSE glitch filter. It can be written only when the LSE is disabled (LSEON = 0 and LSERDY = 0).
        constexpr uint32_t RTCEN = (1U << 15);  ///< RTC and TAMP clock enable This bit is set and cleared by software.
        constexpr uint32_t BDRST = (1U << 16);  ///< Backup domain software reset This bit is set and cleared by software.
        constexpr uint32_t LSCOEN = (1U << 24);  ///< Low-speed clock output (LSCO) enable This bit is set and cleared by software.
        constexpr uint32_t LSCOSEL = (1U << 25);  ///< Low-speed clock output selection This bit is set and cleared by software.
        constexpr uint32_t LSION = (1U << 26);  ///< LSI oscillator enable This bit is set and cleared by software. The LSI oscillator is disabled 60��s maximum after the LSION bit is cleared.
        constexpr uint32_t LSIRDY = (1U << 27);  ///< LSI oscillator ready This bit is set and cleared by hardware to indicate when the LSI oscillator is stable. After�LSION is cleared, LSIRDY goes low after three internal low-speed oscillator clock cycles. This bit is set when the LSI is used by IWDG or RTC, even if LSION = 0.
        constexpr uint32_t LSIPREDIV = (1U << 28);  ///< Low-speed clock divider configuration This bit is set and cleared by software to enable the LSI division. It can be written only when the LSI is disabled (LSION = 0 and LSIRDY = 0). If the LSI was previously enabled, it is necessary to wait for at least 60 μs after clearing LSION bit (synchronization time for LSI to be really disabled), before writing LSIPREDIV. The LSIPREDIV cannot be changed if the LSI is used by the IWDG or by the RTC.
    }

    /// RCC_CSR Register bits
    namespace rcc_csr_bits {
        constexpr uint32_t MSIKSRANGE = (4 << 8);  ///< MSIK range after Standby mode This bit is set by software to chose the MSIK frequency at startup. It is used after exiting Standby mode until MSIRGSEL is set. After a NRST pin or a power-on reset or when exiting Shutdown mode, the range is always 4�MHz. MSIKSRANGE can be written only when MSIRGSEL = 1. others: reserved Note: Changing this bitfield does not change the current MSIK frequency.
        constexpr uint32_t MSISSRANGE = (4 << 12);  ///< MSIS range after Standby mode This bitfield is set by software to chose the MSIS frequency at startup. It is used after exiting Standby mode until MSIRGSEL is set. After a NRST pin or a power-on reset or when exiting Shutdown mode, the range is always 4�MHz. MSISSRANGE can be written only when MSIRGSEL = 1. others: reserved Note: Changing this bitfield does not change the current MSIS frequency.
        constexpr uint32_t RMVF = (1U << 23);  ///< Remove reset flag This bit is set by software to clear the reset flags.
        constexpr uint32_t OBLRSTF = (1U << 25);  ///< Option-byte loader reset flag This bit is set by hardware when a reset from the option-byte loading occurs. It is cleared by�writing to the RMVF bit.
        constexpr uint32_t PINRSTF = (1U << 26);  ///< NRST pin reset flag This bit is set by hardware when a reset from the NRST pin occurs. It is cleared by writing to�the RMVF bit.
        constexpr uint32_t BORRSTF = (1U << 27);  ///< Brownout reset or an exit from Shutdown mode reset flag This bit is set by hardware when a brownout reset or an exit from Shutdown mode reset occurs. It is cleared by writing to the RMVF bit.
        constexpr uint32_t SFTRSTF = (1U << 28);  ///< Software reset flag This bit is set by hardware when a software reset occurs. It is cleared by writing to RMVF.
        constexpr uint32_t IWDGRSTF = (1U << 29);  ///< Independent watchdog reset flag This bit is set by hardware when an independent watchdog reset domain occurs. It is cleared by writing to the RMVF bit.
        constexpr uint32_t WWDGRSTF = (1U << 30);  ///< Window watchdog reset flag This bit is set by hardware when a window watchdog reset occurs. It is cleared by writing to�the RMVF bit.
        constexpr uint32_t LPWRRSTF = (1U << 31);  ///< Low-power reset flag This bit is set by hardware when a reset occurs due to a Stop, Standby, or Shutdown mode entry, whereas the corresponding NRST_STOP, NRST_STBY, or NRST_SHDW option bit is cleared. This bit is cleared by writing to the RMVF bit.
    }

    /// RCC_SECCFGR Register bits
    namespace rcc_seccfgr_bits {
        constexpr uint32_t HSISEC = (1U << 0);  ///< HSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t HSESEC = (1U << 1);  ///< HSE clock configuration bits, status bit and HSE_CSS security This bit is set and reset by software.
        constexpr uint32_t MSISEC = (1U << 2);  ///< MSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t LSISEC = (1U << 3);  ///< LSI clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t LSESEC = (1U << 4);  ///< LSE clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t SYSCLKSEC = (1U << 5);  ///< SYSCLK clock selection, STOPWUCK bit, clock output on MCO configuration security This bit is set and reset by software.
        constexpr uint32_t PRESCSEC = (1U << 6);  ///< AHBx/APBx prescaler configuration bits security This bit is set and reset by software.
        constexpr uint32_t PLL1SEC = (1U << 7);  ///< PLL1 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t PLL2SEC = (1U << 8);  ///< PLL2 clock configuration and status bit security Set and reset by software.
        constexpr uint32_t PLL3SEC = (1U << 9);  ///< PLL3 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t ICLKSEC = (1U << 10);  ///< Intermediate clock source selection security This bit is set and reset by software.
        constexpr uint32_t HSI48SEC = (1U << 11);  ///< HSI48 clock configuration and status bit security This bit is set and reset by software.
        constexpr uint32_t RMVFSEC = (1U << 12);  ///< Remove reset flag security This bit is set and reset by software.
    }

    /// RCC_PRIVCFGR Register bits
    namespace rcc_privcfgr_bits {
        constexpr uint32_t SPRIV = (1U << 0);  ///< RCC secure function privilege configuration This bit is set and reset by software. It can be written only by a secure privileged access.
        constexpr uint32_t NSPRIV = (1U << 1);  ///< RCC non-secure function privilege configuration This bit is set and reset by software. It can be written only by privileged access, secure or non-secure.
    }

}

// ============================================================================
// RNG Peripheral
// ============================================================================

namespace rng {
    /// Base addresses
    constexpr uint32_t RNG_BASE = 0x420C0800;
    constexpr uint32_t SEC_RNG_BASE = 0x520C0800;

    /// RNG Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t SR;  ///< Offset: 0x04 - status register
        volatile uint32_t DR;  ///< Offset: 0x08 - data register
        volatile uint32_t HTCR;  ///< Offset: 0x10 - health test control register
    };

    /// Peripheral instances
    inline Registers* RNG = reinterpret_cast<Registers*>(RNG_BASE);
    inline Registers* SEC_RNG = reinterpret_cast<Registers*>(SEC_RNG_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CONFIGLOCK = (1U << 31);  ///< RNG Config Lock
        constexpr uint32_t CONDRST = (1U << 30);  ///< Conditioning soft reset
        constexpr uint32_t RNG_CONFIG1 = (6 << 20);  ///< RNG configuration 1
        constexpr uint32_t CLKDIV = (4 << 16);  ///< Clock divider factor
        constexpr uint32_t RNG_CONFIG2 = (3 << 13);  ///< RNG configuration 2
        constexpr uint32_t NISTC = (1U << 12);  ///< Non NIST compliant
        constexpr uint32_t RNG_CONFIG3 = (4 << 8);  ///< RNG configuration 3
        constexpr uint32_t ARDIS = (1U << 7);  ///< Auto reset disable
        constexpr uint32_t CED = (1U << 5);  ///< Clock error detection
        constexpr uint32_t IE = (1U << 3);  ///< Interrupt Enable
        constexpr uint32_t RNGEN = (1U << 2);  ///< True random number generator enable
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t SEIS = (1U << 6);  ///< Seed error interrupt status
        constexpr uint32_t CEIS = (1U << 5);  ///< Clock error interrupt status
        constexpr uint32_t SECS = (1U << 2);  ///< Seed error current status
        constexpr uint32_t CECS = (1U << 1);  ///< Clock error current status
        constexpr uint32_t DRDY = (1U << 0);  ///< Data ready
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t RNDATA = (32 << 0);  ///< Random data
    }

    /// HTCR Register bits
    namespace htcr_bits {
        constexpr uint32_t HTCFG = (32 << 0);  ///< health test configuration
    }

}

// ============================================================================
// RTC Peripheral
// ============================================================================

namespace rtc {
    /// Base addresses
    constexpr uint32_t RTC_BASE = 0x46007800;
    constexpr uint32_t SEC_RTC_BASE = 0x56007800;

    /// RTC Register structure
    struct Registers {
        volatile uint32_t TR;  ///< Offset: 0x00 - time register
        volatile uint32_t DR;  ///< Offset: 0x04 - date register
        volatile uint32_t SSR;  ///< Offset: 0x08 - RTC sub second register
        volatile uint32_t ICSR;  ///< Offset: 0x0C - RTC initialization control and status register
        volatile uint32_t PRER;  ///< Offset: 0x10 - prescaler register
        volatile uint32_t WUTR;  ///< Offset: 0x14 - wakeup timer register
        volatile uint32_t CR;  ///< Offset: 0x18 - RTC control register
        volatile uint32_t PRIVCR;  ///< Offset: 0x1C - RTC privilege mode control register
        volatile uint32_t SECCFGR;  ///< Offset: 0x20 - RTC secure mode control register
        volatile uint32_t WPR;  ///< Offset: 0x24 - write protection register
        volatile uint32_t CALR;  ///< Offset: 0x28 - calibration register
        volatile uint32_t SHIFTR;  ///< Offset: 0x2C - shift control register
        volatile uint32_t TSTR;  ///< Offset: 0x30 - time stamp time register
        volatile uint32_t TSDR;  ///< Offset: 0x34 - time stamp date register
        volatile uint32_t TSSSR;  ///< Offset: 0x38 - timestamp sub second register
        volatile uint32_t ALRMAR;  ///< Offset: 0x40 - alarm A register
        volatile uint32_t ALRMASSR;  ///< Offset: 0x44 - alarm A sub second register
        volatile uint32_t ALRMBR;  ///< Offset: 0x48 - alarm B register
        volatile uint32_t ALRMBSSR;  ///< Offset: 0x4C - alarm B sub second register
        volatile uint32_t SR;  ///< Offset: 0x50 - RTC status register
        volatile uint32_t MISR;  ///< Offset: 0x54 - RTC non-secure masked interrupt status register
        volatile uint32_t SMISR;  ///< Offset: 0x58 - RTC secure masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x5C - RTC status clear register
        volatile uint32_t ALRABINR;  ///< Offset: 0x70 - RTC alarm A binary mode register
        volatile uint32_t ALRBBINR;  ///< Offset: 0x74 - RTC alarm B binary mode register
    };

    /// Peripheral instances
    inline Registers* RTC = reinterpret_cast<Registers*>(RTC_BASE);
    inline Registers* SEC_RTC = reinterpret_cast<Registers*>(SEC_RTC_BASE);

    // Bit definitions
    /// TR Register bits
    namespace tr_bits {
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// DR Register bits
    namespace dr_bits {
        constexpr uint32_t YT = (4 << 20);  ///< Year tens in BCD format
        constexpr uint32_t YU = (4 << 16);  ///< Year units in BCD format
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// SSR Register bits
    namespace ssr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< SS
    }

    /// ICSR Register bits
    namespace icsr_bits {
        constexpr uint32_t WUTWF = (1U << 2);  ///< Wakeup timer write flag
        constexpr uint32_t SHPF = (1U << 3);  ///< Shift operation pending
        constexpr uint32_t INITS = (1U << 4);  ///< Initialization status flag
        constexpr uint32_t RSF = (1U << 5);  ///< Registers synchronization flag
        constexpr uint32_t INITF = (1U << 6);  ///< Initialization flag
        constexpr uint32_t INIT = (1U << 7);  ///< Initialization mode
        constexpr uint32_t BIN = (2 << 8);  ///< BIN
        constexpr uint32_t BCDU = (3 << 10);  ///< BCDU
        constexpr uint32_t RECALPF = (1U << 16);  ///< Recalibration pending Flag
    }

    /// PRER Register bits
    namespace prer_bits {
        constexpr uint32_t PREDIV_A = (7 << 16);  ///< Asynchronous prescaler factor
        constexpr uint32_t PREDIV_S = (15 << 0);  ///< Synchronous prescaler factor
    }

    /// WUTR Register bits
    namespace wutr_bits {
        constexpr uint32_t WUT = (16 << 0);  ///< Wakeup auto-reload value bits
        constexpr uint32_t WUTOCLR = (16 << 16);  ///< WUTOCLR
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t WUCKSEL = (3 << 0);  ///< WUCKSEL
        constexpr uint32_t TSEDGE = (1U << 3);  ///< TSEDGE
        constexpr uint32_t REFCKON = (1U << 4);  ///< REFCKON
        constexpr uint32_t BYPSHAD = (1U << 5);  ///< BYPSHAD
        constexpr uint32_t FMT = (1U << 6);  ///< FMT
        constexpr uint32_t SSRUIE = (1U << 7);  ///< SSRUIE
        constexpr uint32_t ALRAE = (1U << 8);  ///< ALRAE
        constexpr uint32_t ALRBE = (1U << 9);  ///< ALRBE
        constexpr uint32_t WUTE = (1U << 10);  ///< WUTE
        constexpr uint32_t TSE = (1U << 11);  ///< TSE
        constexpr uint32_t ALRAIE = (1U << 12);  ///< ALRAIE
        constexpr uint32_t ALRBIE = (1U << 13);  ///< ALRBIE
        constexpr uint32_t WUTIE = (1U << 14);  ///< WUTIE
        constexpr uint32_t TSIE = (1U << 15);  ///< TSIE
        constexpr uint32_t ADD1H = (1U << 16);  ///< ADD1H
        constexpr uint32_t SUB1H = (1U << 17);  ///< SUB1H
        constexpr uint32_t BKP = (1U << 18);  ///< BKP
        constexpr uint32_t COSEL = (1U << 19);  ///< COSEL
        constexpr uint32_t POL = (1U << 20);  ///< POL
        constexpr uint32_t OSEL = (2 << 21);  ///< OSEL
        constexpr uint32_t COE = (1U << 23);  ///< COE
        constexpr uint32_t ITSE = (1U << 24);  ///< ITSE
        constexpr uint32_t TAMPTS = (1U << 25);  ///< TAMPTS
        constexpr uint32_t TAMPOE = (1U << 26);  ///< TAMPOE
        constexpr uint32_t ALRAFCLR = (1U << 27);  ///< ALRAFCLR
        constexpr uint32_t ALRBFCLR = (1U << 28);  ///< ALRBFCLR
        constexpr uint32_t TAMPALRM_PU = (1U << 29);  ///< TAMPALRM_PU
        constexpr uint32_t TAMPALRM_TYPE = (1U << 30);  ///< TAMPALRM_TYPE
        constexpr uint32_t OUT2EN = (1U << 31);  ///< OUT2EN
    }

    /// PRIVCR Register bits
    namespace privcr_bits {
        constexpr uint32_t PRIV = (1U << 15);  ///< PRIV
        constexpr uint32_t INITPRIV = (1U << 14);  ///< INITPRIV
        constexpr uint32_t CALPRIV = (1U << 13);  ///< CALPRIV
        constexpr uint32_t TSPRIV = (1U << 3);  ///< TSPRIV
        constexpr uint32_t WUTPRIV = (1U << 2);  ///< WUTPRIV
        constexpr uint32_t ALRBPRIV = (1U << 1);  ///< ALRBPRIV
        constexpr uint32_t ALRAPRIV = (1U << 0);  ///< ALRAPRIV
    }

    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t SEC = (1U << 15);  ///< SEC
        constexpr uint32_t INITSEC = (1U << 14);  ///< INITSEC
        constexpr uint32_t CALSEC = (1U << 13);  ///< CALSEC
        constexpr uint32_t TSSEC = (1U << 3);  ///< TSSEC
        constexpr uint32_t WUTSEC = (1U << 2);  ///< WUTSEC
        constexpr uint32_t ALRBSEC = (1U << 1);  ///< ALRBSEC
        constexpr uint32_t ALRASEC = (1U << 0);  ///< ALRASEC
    }

    /// WPR Register bits
    namespace wpr_bits {
        constexpr uint32_t KEY = (8 << 0);  ///< Write protection key
    }

    /// CALR Register bits
    namespace calr_bits {
        constexpr uint32_t CALP = (1U << 15);  ///< Increase frequency of RTC by 488.5 ppm
        constexpr uint32_t CALW8 = (1U << 14);  ///< Use an 8-second calibration cycle period
        constexpr uint32_t CALW16 = (1U << 13);  ///< Use a 16-second calibration cycle period
        constexpr uint32_t LPCAL = (1U << 12);  ///< LPCAL
        constexpr uint32_t CALM = (9 << 0);  ///< Calibration minus
    }

    /// SHIFTR Register bits
    namespace shiftr_bits {
        constexpr uint32_t ADD1S = (1U << 31);  ///< Add one second
        constexpr uint32_t SUBFS = (15 << 0);  ///< Subtract a fraction of a second
    }

    /// TSTR Register bits
    namespace tstr_bits {
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
    }

    /// TSDR Register bits
    namespace tsdr_bits {
        constexpr uint32_t WDU = (3 << 13);  ///< Week day units
        constexpr uint32_t MT = (1U << 12);  ///< Month tens in BCD format
        constexpr uint32_t MU = (4 << 8);  ///< Month units in BCD format
        constexpr uint32_t DT = (2 << 4);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 0);  ///< Date units in BCD format
    }

    /// TSSSR Register bits
    namespace tsssr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Sub second value
    }

    /// ALRMAR Register bits
    namespace alrmar_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm A date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm A hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm A minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm A seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMASSR Register bits
    namespace alrmassr_bits {
        constexpr uint32_t SSCLR = (1U << 31);  ///< SSCLR
        constexpr uint32_t MASKSS = (6 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// ALRMBR Register bits
    namespace alrmbr_bits {
        constexpr uint32_t MSK4 = (1U << 31);  ///< Alarm B date mask
        constexpr uint32_t WDSEL = (1U << 30);  ///< Week day selection
        constexpr uint32_t DT = (2 << 28);  ///< Date tens in BCD format
        constexpr uint32_t DU = (4 << 24);  ///< Date units or day in BCD format
        constexpr uint32_t MSK3 = (1U << 23);  ///< Alarm B hours mask
        constexpr uint32_t PM = (1U << 22);  ///< AM/PM notation
        constexpr uint32_t HT = (2 << 20);  ///< Hour tens in BCD format
        constexpr uint32_t HU = (4 << 16);  ///< Hour units in BCD format
        constexpr uint32_t MSK2 = (1U << 15);  ///< Alarm B minutes mask
        constexpr uint32_t MNT = (3 << 12);  ///< Minute tens in BCD format
        constexpr uint32_t MNU = (4 << 8);  ///< Minute units in BCD format
        constexpr uint32_t MSK1 = (1U << 7);  ///< Alarm B seconds mask
        constexpr uint32_t ST = (3 << 4);  ///< Second tens in BCD format
        constexpr uint32_t SU = (4 << 0);  ///< Second units in BCD format
    }

    /// ALRMBSSR Register bits
    namespace alrmbssr_bits {
        constexpr uint32_t SSCLR = (1U << 31);  ///< SSCLR
        constexpr uint32_t MASKSS = (6 << 24);  ///< Mask the most-significant bits starting at this bit
        constexpr uint32_t SS = (15 << 0);  ///< Sub seconds value
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t ALRAF = (1U << 0);  ///< ALRAF
        constexpr uint32_t ALRBF = (1U << 1);  ///< ALRBF
        constexpr uint32_t WUTF = (1U << 2);  ///< WUTF
        constexpr uint32_t TSF = (1U << 3);  ///< TSF
        constexpr uint32_t TSOVF = (1U << 4);  ///< TSOVF
        constexpr uint32_t ITSF = (1U << 5);  ///< ITSF
        constexpr uint32_t SSRUF = (1U << 6);  ///< SSRUF
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
        constexpr uint32_t SSRUMF = (1U << 6);  ///< SSRUMF
    }

    /// SMISR Register bits
    namespace smisr_bits {
        constexpr uint32_t ALRAMF = (1U << 0);  ///< ALRAMF
        constexpr uint32_t ALRBMF = (1U << 1);  ///< ALRBMF
        constexpr uint32_t WUTMF = (1U << 2);  ///< WUTMF
        constexpr uint32_t TSMF = (1U << 3);  ///< TSMF
        constexpr uint32_t TSOVMF = (1U << 4);  ///< TSOVMF
        constexpr uint32_t ITSMF = (1U << 5);  ///< ITSMF
        constexpr uint32_t SSRUMF = (1U << 6);  ///< SSRUMF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CALRAF = (1U << 0);  ///< CALRAF
        constexpr uint32_t CALRBF = (1U << 1);  ///< CALRBF
        constexpr uint32_t CWUTF = (1U << 2);  ///< CWUTF
        constexpr uint32_t CTSF = (1U << 3);  ///< CTSF
        constexpr uint32_t CTSOVF = (1U << 4);  ///< CTSOVF
        constexpr uint32_t CITSF = (1U << 5);  ///< CITSF
        constexpr uint32_t CSSRUF = (1U << 6);  ///< CSSRUF
    }

    /// ALRABINR Register bits
    namespace alrabinr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous counter alarm value in Binary mode
    }

    /// ALRBBINR Register bits
    namespace alrbbinr_bits {
        constexpr uint32_t SS = (32 << 0);  ///< Synchronous counter alarm value in Binary mode
    }

}

// ============================================================================
// SAI1 Peripheral
// ============================================================================

namespace sai1 {
    /// Base addresses
    constexpr uint32_t SAI1_BASE = 0x40015400;

    /// SAI1 Register structure
    struct Registers {
        volatile uint32_t GCR;  ///< Offset: 0x00 - Global configuration register
        volatile uint32_t ACR1;  ///< Offset: 0x04 - A Configuration register 1
        volatile uint32_t BCR1;  ///< Offset: 0x24 - B Configuration register 1
        volatile uint32_t ACR2;  ///< Offset: 0x08 - A Configuration register 2
        volatile uint32_t BCR2;  ///< Offset: 0x28 - B Configuration register 2
        volatile uint32_t AFRCR;  ///< Offset: 0x0C - A frame configuration register
        volatile uint32_t BFRCR;  ///< Offset: 0x2C - B frame configuration register
        volatile uint32_t ASLOTR;  ///< Offset: 0x10 - A Slot register
        volatile uint32_t BSLOTR;  ///< Offset: 0x30 - B Slot register
        volatile uint32_t AIM;  ///< Offset: 0x14 - A Interrupt mask register
        volatile uint32_t BIM;  ///< Offset: 0x34 - B Interrupt mask register
        volatile uint32_t ASR;  ///< Offset: 0x18 - A Status register
        volatile uint32_t BSR;  ///< Offset: 0x38 - B Status register
        volatile uint32_t ACLRFR;  ///< Offset: 0x1C - A Clear flag register
        volatile uint32_t BCLRFR;  ///< Offset: 0x3C - B Clear flag register
        volatile uint32_t ADR;  ///< Offset: 0x20 - A Data register
        volatile uint32_t BDR;  ///< Offset: 0x40 - B Data register
        volatile uint32_t PDMCR;  ///< Offset: 0x44 - PDM control register
        volatile uint32_t PDMDLY;  ///< Offset: 0x48 - PDM delay register
    };

    /// Peripheral instances
    inline Registers* SAI1 = reinterpret_cast<Registers*>(SAI1_BASE);

    // Bit definitions
    /// GCR Register bits
    namespace gcr_bits {
        constexpr uint32_t SYNCIN = (2 << 0);  ///< Synchronization inputs
        constexpr uint32_t SYNCOUT = (2 << 4);  ///< Synchronization outputs
    }

    /// ACR1 Register bits
    namespace acr1_bits {
        constexpr uint32_t MCKEN = (1U << 27);  ///< MCKEN
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
        constexpr uint32_t MCKDIV = (6 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OUTDRIV = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// BCR1 Register bits
    namespace bcr1_bits {
        constexpr uint32_t MCKEN = (1U << 27);  ///< MCKEN
        constexpr uint32_t OSR = (1U << 26);  ///< OSR
        constexpr uint32_t MCKDIV = (6 << 20);  ///< Master clock divider
        constexpr uint32_t NODIV = (1U << 19);  ///< No divider
        constexpr uint32_t DMAEN = (1U << 17);  ///< DMA enable
        constexpr uint32_t SAIAEN = (1U << 16);  ///< Audio block A enable
        constexpr uint32_t OUTDRIV = (1U << 13);  ///< Output drive
        constexpr uint32_t MONO = (1U << 12);  ///< Mono mode
        constexpr uint32_t SYNCEN = (2 << 10);  ///< Synchronization enable
        constexpr uint32_t CKSTR = (1U << 9);  ///< Clock strobing edge
        constexpr uint32_t LSBFIRST = (1U << 8);  ///< Least significant bit first
        constexpr uint32_t DS = (3 << 5);  ///< Data size
        constexpr uint32_t PRTCFG = (2 << 2);  ///< Protocol configuration
        constexpr uint32_t MODE = (2 << 0);  ///< Audio block mode
    }

    /// ACR2 Register bits
    namespace acr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUSH = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// BCR2 Register bits
    namespace bcr2_bits {
        constexpr uint32_t COMP = (2 << 14);  ///< Companding mode
        constexpr uint32_t CPL = (1U << 13);  ///< Complement bit
        constexpr uint32_t MUTECN = (6 << 7);  ///< Mute counter
        constexpr uint32_t MUTEVAL = (1U << 6);  ///< Mute value
        constexpr uint32_t MUTE = (1U << 5);  ///< Mute
        constexpr uint32_t TRIS = (1U << 4);  ///< Tristate management on data line
        constexpr uint32_t FFLUSH = (1U << 3);  ///< FIFO flush
        constexpr uint32_t FTH = (3 << 0);  ///< FIFO threshold
    }

    /// AFRCR Register bits
    namespace afrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// BFRCR Register bits
    namespace bfrcr_bits {
        constexpr uint32_t FSOFF = (1U << 18);  ///< Frame synchronization offset
        constexpr uint32_t FSPOL = (1U << 17);  ///< Frame synchronization polarity
        constexpr uint32_t FSDEF = (1U << 16);  ///< Frame synchronization definition
        constexpr uint32_t FSALL = (7 << 8);  ///< Frame synchronization active level length
        constexpr uint32_t FRL = (8 << 0);  ///< Frame length
    }

    /// ASLOTR Register bits
    namespace aslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// BSLOTR Register bits
    namespace bslotr_bits {
        constexpr uint32_t SLOTEN = (16 << 16);  ///< Slot enable
        constexpr uint32_t NBSLOT = (4 << 8);  ///< Number of slots in an audio frame
        constexpr uint32_t SLOTSZ = (2 << 6);  ///< Slot size
        constexpr uint32_t FBOFF = (5 << 0);  ///< First bit offset
    }

    /// AIM Register bits
    namespace aim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFGIE = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDETIE = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// BIM Register bits
    namespace bim_bits {
        constexpr uint32_t LFSDETIE = (1U << 6);  ///< Late frame synchronization detection interrupt enable
        constexpr uint32_t AFSDETIE = (1U << 5);  ///< Anticipated frame synchronization detection interrupt enable
        constexpr uint32_t CNRDYIE = (1U << 4);  ///< Codec not ready interrupt enable
        constexpr uint32_t FREQIE = (1U << 3);  ///< FIFO request interrupt enable
        constexpr uint32_t WCKCFGIE = (1U << 2);  ///< Wrong clock configuration interrupt enable
        constexpr uint32_t MUTEDETIE = (1U << 1);  ///< Mute detection interrupt enable
        constexpr uint32_t OVRUDRIE = (1U << 0);  ///< Overrun/underrun interrupt enable
    }

    /// ASR Register bits
    namespace asr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag. This bit is read only
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// BSR Register bits
    namespace bsr_bits {
        constexpr uint32_t FLVL = (3 << 16);  ///< FIFO level threshold
        constexpr uint32_t LFSDET = (1U << 6);  ///< Late frame synchronization detection
        constexpr uint32_t AFSDET = (1U << 5);  ///< Anticipated frame synchronization detection
        constexpr uint32_t CNRDY = (1U << 4);  ///< Codec not ready
        constexpr uint32_t FREQ = (1U << 3);  ///< FIFO request
        constexpr uint32_t WCKCFG = (1U << 2);  ///< Wrong clock configuration flag
        constexpr uint32_t MUTEDET = (1U << 1);  ///< Mute detection
        constexpr uint32_t OVRUDR = (1U << 0);  ///< Overrun / underrun
    }

    /// ACLRFR Register bits
    namespace aclrfr_bits {
        constexpr uint32_t CLFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CCNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t CWCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t CMUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t COVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// BCLRFR Register bits
    namespace bclrfr_bits {
        constexpr uint32_t CLFSDET = (1U << 6);  ///< Clear late frame synchronization detection flag
        constexpr uint32_t CAFSDET = (1U << 5);  ///< Clear anticipated frame synchronization detection flag
        constexpr uint32_t CCNRDY = (1U << 4);  ///< Clear codec not ready flag
        constexpr uint32_t CWCKCFG = (1U << 2);  ///< Clear wrong clock configuration flag
        constexpr uint32_t CMUTEDET = (1U << 1);  ///< Mute detection flag
        constexpr uint32_t COVRUDR = (1U << 0);  ///< Clear overrun / underrun
    }

    /// ADR Register bits
    namespace adr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// BDR Register bits
    namespace bdr_bits {
        constexpr uint32_t DATA = (32 << 0);  ///< Data
    }

    /// PDMCR Register bits
    namespace pdmcr_bits {
        constexpr uint32_t PDMEN = (1U << 0);  ///< PDM enable
        constexpr uint32_t MICNBR = (2 << 4);  ///< MICNBR
        constexpr uint32_t CKEN1 = (1U << 8);  ///< Clock enable of bitstream clock number 1
        constexpr uint32_t CKEN2 = (1U << 9);  ///< CKEN2
        constexpr uint32_t CKEN3 = (1U << 10);  ///< CKEN3
        constexpr uint32_t CKEN4 = (1U << 11);  ///< CKEN4
    }

    /// PDMDLY Register bits
    namespace pdmdly_bits {
        constexpr uint32_t DLYM1L = (3 << 0);  ///< Delay line adjust for first microphone of pair 1
        constexpr uint32_t DLYM1R = (3 << 4);  ///< Delay line adjust for second microphone of pair 1
        constexpr uint32_t DLYM2L = (3 << 8);  ///< Delay line for first microphone of pair 2
        constexpr uint32_t DLYM2R = (3 << 12);  ///< Delay line for second microphone of pair 2
        constexpr uint32_t DLYM3L = (3 << 16);  ///< DLYM3L
        constexpr uint32_t DLYM3R = (3 << 20);  ///< DLYM3R
        constexpr uint32_t DLYM4L = (3 << 24);  ///< DLYM4L
        constexpr uint32_t DLYM4R = (3 << 28);  ///< DLYM4R
    }

}

// ============================================================================
// SAI2 Peripheral
// ============================================================================

namespace sai2 {
    /// Base addresses
    constexpr uint32_t SAI2_BASE = 0x40015800;

    /// SAI2 Register structure
    struct Registers {
    };

    /// Peripheral instances
    inline Registers* SAI2 = reinterpret_cast<Registers*>(SAI2_BASE);

}

// ============================================================================
// SDIO Peripheral
// ============================================================================

namespace sdio {
    /// Base addresses
    constexpr uint32_t SDMMC1_BASE = 0x420C8000;
    constexpr uint32_t SEC_SDMMC1_BASE = 0x520C8000;
    constexpr uint32_t SDMMC2_BASE = 0x420C8C00;
    constexpr uint32_t SEC_SDMMC2_BASE = 0x520C8C00;

    /// SDIO Register structure
    struct Registers {
        volatile uint32_t POWER;  ///< Offset: 0x00 - power control register
        volatile uint32_t CLKCR;  ///< Offset: 0x04 - clock control register
        volatile uint32_t ARGR;  ///< Offset: 0x08 - argument register
        volatile uint32_t CMDR;  ///< Offset: 0x0C - command register
        volatile uint32_t RESPCMDR;  ///< Offset: 0x10 - command response register
        volatile uint32_t RESP1;  ///< Offset: 0x14 - response 1 register
        volatile uint32_t RESP2;  ///< Offset: 0x18 - response 2 register
        volatile uint32_t RESP3;  ///< Offset: 0x1C - response 3 register
        volatile uint32_t RESP4;  ///< Offset: 0x20 - response 4 register
        volatile uint32_t DTIMER;  ///< Offset: 0x24 - data timer register
        volatile uint32_t DLENR;  ///< Offset: 0x28 - data length register
        volatile uint32_t DCTRL;  ///< Offset: 0x2C - data control register
        volatile uint32_t DCNTR;  ///< Offset: 0x30 - data counter register
        volatile uint32_t STAR;  ///< Offset: 0x34 - status register
        volatile uint32_t ICR;  ///< Offset: 0x38 - interrupt clear register
        volatile uint32_t MASKR;  ///< Offset: 0x3C - mask register
        volatile uint32_t ACKTIMER;  ///< Offset: 0x40 - acknowledgment timer register
        volatile uint32_t FIFOR0;  ///< Offset: 0x80 - data FIFO register 0
        volatile uint32_t FIFOR1;  ///< Offset: 0x84 - data FIFO register 1
        volatile uint32_t FIFOR2;  ///< Offset: 0x88 - data FIFO register 2
        volatile uint32_t FIFOR3;  ///< Offset: 0x8C - data FIFO register 3
        volatile uint32_t FIFOR4;  ///< Offset: 0x90 - data FIFO register 4
        volatile uint32_t FIFOR5;  ///< Offset: 0x94 - data FIFO register 5
        volatile uint32_t FIFOR6;  ///< Offset: 0x98 - data FIFO register 6
        volatile uint32_t FIFOR7;  ///< Offset: 0x9C - data FIFO register 7
        volatile uint32_t FIFOR8;  ///< Offset: 0xA0 - data FIFO register 8
        volatile uint32_t FIFOR9;  ///< Offset: 0xA4 - data FIFO register 9
        volatile uint32_t FIFOR10;  ///< Offset: 0xA8 - data FIFO register 10
        volatile uint32_t FIFOR11;  ///< Offset: 0xAC - data FIFO register 11
        volatile uint32_t FIFOR12;  ///< Offset: 0xB0 - data FIFO register 12
        volatile uint32_t FIFOR13;  ///< Offset: 0xB4 - data FIFO register 13
        volatile uint32_t FIFOR14;  ///< Offset: 0xB8 - data FIFO register 14
        volatile uint32_t FIFOR15;  ///< Offset: 0xBC - data FIFO register 15
        volatile uint32_t SDMMC_IDMACTRLR;  ///< Offset: 0x50 - DMA control register
        volatile uint32_t SDMMC_IDMABSIZER;  ///< Offset: 0x54 - buffer size register
        volatile uint32_t SDMMC_IDMABASER;  ///< Offset: 0x58 - buffer base address register
        volatile uint32_t SDMMC_IDMALAR;  ///< Offset: 0x64 - linked list address register
        volatile uint32_t SDMMC_IDMABAR;  ///< Offset: 0x68 - linked list memory base register
    };

    /// Peripheral instances
    inline Registers* SDMMC1 = reinterpret_cast<Registers*>(SDMMC1_BASE);
    inline Registers* SEC_SDMMC1 = reinterpret_cast<Registers*>(SEC_SDMMC1_BASE);
    inline Registers* SDMMC2 = reinterpret_cast<Registers*>(SDMMC2_BASE);
    inline Registers* SEC_SDMMC2 = reinterpret_cast<Registers*>(SEC_SDMMC2_BASE);

    // Bit definitions
    /// POWER Register bits
    namespace power_bits {
        constexpr uint32_t PWRCTRL = (2 << 0);  ///< SDMMC state control bits
        constexpr uint32_t VSWITCH = (1U << 2);  ///< Voltage switch sequence start
        constexpr uint32_t VSWITCHEN = (1U << 3);  ///< Voltage switch procedure enable
        constexpr uint32_t DIRPOL = (1U << 4);  ///< Data and command direction signals polarity selection
    }

    /// CLKCR Register bits
    namespace clkcr_bits {
        constexpr uint32_t SELCLKRX = (2 << 20);  ///< Receive clock selection
        constexpr uint32_t BUSSPEED = (1U << 19);  ///< Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50,DDR50, SDR104
        constexpr uint32_t DDR = (1U << 18);  ///< Data rate signaling selection
        constexpr uint32_t HWFC_EN = (1U << 17);  ///< HW Flow Control enable
        constexpr uint32_t NEGEDGE = (1U << 16);  ///< SDIO_CK dephasing selection bit
        constexpr uint32_t WIDBUS = (2 << 14);  ///< Wide bus mode enable bit
        constexpr uint32_t PWRSAV = (1U << 12);  ///< Power saving configuration bit
        constexpr uint32_t CLKDIV = (10 << 0);  ///< Clock divide factor
    }

    /// ARGR Register bits
    namespace argr_bits {
        constexpr uint32_t CMDARG = (32 << 0);  ///< Command argument
    }

    /// CMDR Register bits
    namespace cmdr_bits {
        constexpr uint32_t CMDSUSPEND = (1U << 16);  ///< The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end
        constexpr uint32_t BOOTEN = (1U << 15);  ///< Enable boot mode procedure
        constexpr uint32_t BOOTMODE = (1U << 14);  ///< Select the boot mode procedure to be used
        constexpr uint32_t DTHOLD = (1U << 13);  ///< Hold new data block transmission and reception in the DPSM
        constexpr uint32_t CPSMEN = (1U << 12);  ///< Command path state machine (CPSM) Enable bit
        constexpr uint32_t WAITPEND = (1U << 11);  ///< CPSM Waits for ends of data transfer (CmdPend internal signal) from DPSM
        constexpr uint32_t WAITINT = (1U << 10);  ///< CPSM waits for interrupt request
        constexpr uint32_t WAITRESP = (2 << 8);  ///< Wait for response bits
        constexpr uint32_t CMDSTOP = (1U << 7);  ///< The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM
        constexpr uint32_t CMDTRANS = (1U << 6);  ///< The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM
        constexpr uint32_t CMDINDEX = (6 << 0);  ///< Command index
    }

    /// RESPCMDR Register bits
    namespace respcmdr_bits {
        constexpr uint32_t RESPCMD = (6 << 0);  ///< Response command index
    }

    /// RESP1 Register bits
    namespace resp1_bits {
        constexpr uint32_t CARDSTATUS1 = (32 << 0);  ///< CARDSTATUS1
    }

    /// RESP2 Register bits
    namespace resp2_bits {
        constexpr uint32_t CARDSTATUS2 = (32 << 0);  ///< CARDSTATUS2
    }

    /// RESP3 Register bits
    namespace resp3_bits {
        constexpr uint32_t CARDSTATUS3 = (32 << 0);  ///< CARDSTATUS3
    }

    /// RESP4 Register bits
    namespace resp4_bits {
        constexpr uint32_t CARDSTATUS4 = (32 << 0);  ///< CARDSTATUS4
    }

    /// DTIMER Register bits
    namespace dtimer_bits {
        constexpr uint32_t DATATIME = (32 << 0);  ///< Data and R1b busy timeout period
    }

    /// DLENR Register bits
    namespace dlenr_bits {
        constexpr uint32_t DATALENGTH = (25 << 0);  ///< Data length value
    }

    /// DCTRL Register bits
    namespace dctrl_bits {
        constexpr uint32_t FIFORST = (1U << 13);  ///< FIFO reset, will flush any remaining data
        constexpr uint32_t BOOTACKEN = (1U << 12);  ///< Enable the reception of the boot acknowledgment
        constexpr uint32_t SDIOEN = (1U << 11);  ///< SD I/O enable functions
        constexpr uint32_t RWMOD = (1U << 10);  ///< Read wait mode
        constexpr uint32_t RWSTOP = (1U << 9);  ///< Read wait stop
        constexpr uint32_t RWSTART = (1U << 8);  ///< Read wait start
        constexpr uint32_t DBLOCKSIZE = (4 << 4);  ///< Data block size
        constexpr uint32_t DTMODE = (2 << 2);  ///< Data transfer mode selection
        constexpr uint32_t DTDIR = (1U << 1);  ///< Data transfer direction selection
        constexpr uint32_t DTEN = (1U << 0);  ///< DTEN
    }

    /// DCNTR Register bits
    namespace dcntr_bits {
        constexpr uint32_t DATACOUNT = (25 << 0);  ///< Data count value
    }

    /// STAR Register bits
    namespace star_bits {
        constexpr uint32_t IDMABTC = (1U << 28);  ///< IDMA buffer transfer complete
        constexpr uint32_t IDMATE = (1U << 27);  ///< IDMA transfer error
        constexpr uint32_t CKSTOP = (1U << 26);  ///< SDMMC_CK stopped in Voltage switch procedure
        constexpr uint32_t VSWEND = (1U << 25);  ///< Voltage switch critical timing section completion
        constexpr uint32_t ACKTIMEOUT = (1U << 24);  ///< Boot acknowledgment timeout
        constexpr uint32_t ACKFAIL = (1U << 23);  ///< Boot acknowledgment received (boot acknowledgment check fail)
        constexpr uint32_t SDIOIT = (1U << 22);  ///< SDIO interrupt received
        constexpr uint32_t BUSYD0END = (1U << 21);  ///< end of SDMMC_D0 Busy following a CMD response detected
        constexpr uint32_t BUSYD0 = (1U << 20);  ///< Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response
        constexpr uint32_t RXFIFOE = (1U << 19);  ///< Receive FIFO empty
        constexpr uint32_t TXFIFOE = (1U << 18);  ///< Transmit FIFO empty
        constexpr uint32_t RXFIFOF = (1U << 17);  ///< Receive FIFO full
        constexpr uint32_t TXFIFOF = (1U << 16);  ///< Transmit FIFO full
        constexpr uint32_t RXFIFOHF = (1U << 15);  ///< Receive FIFO half full
        constexpr uint32_t TXFIFOHE = (1U << 14);  ///< Transmit FIFO half empty
        constexpr uint32_t CPSMACT = (1U << 13);  ///< Command path state machine active, i.e. not in Idle state
        constexpr uint32_t DPSMACT = (1U << 12);  ///< Data path state machine active, i.e. not in Idle state
        constexpr uint32_t DABORT = (1U << 11);  ///< Data transfer aborted by CMD12
        constexpr uint32_t DBCKEND = (1U << 10);  ///< Data block sent/received
        constexpr uint32_t DHOLD = (1U << 9);  ///< Data transfer Hold
        constexpr uint32_t DATAEND = (1U << 8);  ///< Data transfer ended correctly
        constexpr uint32_t CMDSENT = (1U << 7);  ///< Command sent (no response required)
        constexpr uint32_t CMDREND = (1U << 6);  ///< Command response received (CRC check passed, or no CRC)
        constexpr uint32_t RXOVERR = (1U << 5);  ///< Received FIFO overrun error (masked by hardware when IDMA is enabled)
        constexpr uint32_t TXUNDERR = (1U << 4);  ///< Transmit FIFO underrun error (masked by hardware when IDMA is enabled)
        constexpr uint32_t DTIMEOUT = (1U << 3);  ///< Data timeout
        constexpr uint32_t CTIMEOUT = (1U << 2);  ///< Command response timeout
        constexpr uint32_t DCRCFAIL = (1U << 1);  ///< Data block sent/received (CRC check failed)
        constexpr uint32_t CCRCFAIL = (1U << 0);  ///< Command response received (CRC check failed)
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t IDMABTCC = (1U << 28);  ///< IDMA buffer transfer complete clear bit
        constexpr uint32_t IDMATEC = (1U << 27);  ///< IDMA transfer error clear bit
        constexpr uint32_t CKSTOPC = (1U << 26);  ///< CKSTOP flag clear bit
        constexpr uint32_t VSWENDC = (1U << 25);  ///< VSWEND flag clear bit
        constexpr uint32_t ACKTIMEOUTC = (1U << 24);  ///< ACKTIMEOUT flag clear bit
        constexpr uint32_t ACKFAILC = (1U << 23);  ///< ACKFAIL flag clear bit
        constexpr uint32_t SDIOITC = (1U << 22);  ///< SDIOIT flag clear bit
        constexpr uint32_t BUSYD0ENDC = (1U << 21);  ///< BUSYD0END flag clear bit
        constexpr uint32_t DABORTC = (1U << 11);  ///< DABORT flag clear bit
        constexpr uint32_t DBCKENDC = (1U << 10);  ///< DBCKEND flag clear bit
        constexpr uint32_t DHOLDC = (1U << 9);  ///< DHOLD flag clear bit
        constexpr uint32_t DATAENDC = (1U << 8);  ///< DATAEND flag clear bit
        constexpr uint32_t CMDSENTC = (1U << 7);  ///< CMDSENT flag clear bit
        constexpr uint32_t CMDRENDC = (1U << 6);  ///< CMDREND flag clear bit
        constexpr uint32_t RXOVERRC = (1U << 5);  ///< RXOVERR flag clear bit
        constexpr uint32_t TXUNDERRC = (1U << 4);  ///< TXUNDERR flag clear bit
        constexpr uint32_t DTIMEOUTC = (1U << 3);  ///< DTIMEOUT flag clear bit
        constexpr uint32_t CTIMEOUTC = (1U << 2);  ///< CTIMEOUT flag clear bit
        constexpr uint32_t DCRCFAILC = (1U << 1);  ///< DCRCFAIL flag clear bit
        constexpr uint32_t CCRCFAILC = (1U << 0);  ///< CCRCFAIL flag clear bit
    }

    /// MASKR Register bits
    namespace maskr_bits {
        constexpr uint32_t IDMABTCIE = (1U << 28);  ///< IDMA buffer transfer complete interrupt enable
        constexpr uint32_t CKSTOPIE = (1U << 26);  ///< Voltage Switch clock stopped interrupt enable
        constexpr uint32_t VSWENDIE = (1U << 25);  ///< Voltage switch critical timing section completion interrupt enable
        constexpr uint32_t ACKTIMEOUTIE = (1U << 24);  ///< Acknowledgment timeout interrupt enable
        constexpr uint32_t ACKFAILIE = (1U << 23);  ///< Acknowledgment Fail interrupt enable
        constexpr uint32_t SDIOITIE = (1U << 22);  ///< SDIO mode interrupt received interrupt enable
        constexpr uint32_t BUSYD0ENDIE = (1U << 21);  ///< BUSYD0END interrupt enable
        constexpr uint32_t TXFIFOEIE = (1U << 18);  ///< Tx FIFO empty interrupt enable
        constexpr uint32_t RXFIFOFIE = (1U << 17);  ///< Rx FIFO full interrupt enable
        constexpr uint32_t RXFIFOHFIE = (1U << 15);  ///< Rx FIFO half full interrupt enable
        constexpr uint32_t TXFIFOHEIE = (1U << 14);  ///< Tx FIFO half empty interrupt enable
        constexpr uint32_t DABORTIE = (1U << 11);  ///< Data transfer aborted interrupt enable
        constexpr uint32_t DBCKENDIE = (1U << 10);  ///< Data block end interrupt enable
        constexpr uint32_t DHOLDIE = (1U << 9);  ///< Data hold interrupt enable
        constexpr uint32_t DATAENDIE = (1U << 8);  ///< Data end interrupt enable
        constexpr uint32_t CMDSENTIE = (1U << 7);  ///< Command sent interrupt enable
        constexpr uint32_t CMDRENDIE = (1U << 6);  ///< Command response received interrupt enable
        constexpr uint32_t RXOVERRIE = (1U << 5);  ///< Rx FIFO overrun error interrupt enable
        constexpr uint32_t TXUNDERRIE = (1U << 4);  ///< Tx FIFO underrun error interrupt enable
        constexpr uint32_t DTIMEOUTIE = (1U << 3);  ///< Data timeout interrupt enable
        constexpr uint32_t CTIMEOUTIE = (1U << 2);  ///< Command timeout interrupt enable
        constexpr uint32_t DCRCFAILIE = (1U << 1);  ///< Data CRC fail interrupt enable
        constexpr uint32_t CCRCFAILIE = (1U << 0);  ///< Command CRC fail interrupt enable
    }

    /// ACKTIMER Register bits
    namespace acktimer_bits {
        constexpr uint32_t ACKTIME = (25 << 0);  ///< Boot acknowledgment timeout period
    }

    /// FIFOR0 Register bits
    namespace fifor0_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR1 Register bits
    namespace fifor1_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR2 Register bits
    namespace fifor2_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR3 Register bits
    namespace fifor3_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR4 Register bits
    namespace fifor4_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR5 Register bits
    namespace fifor5_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR6 Register bits
    namespace fifor6_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR7 Register bits
    namespace fifor7_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR8 Register bits
    namespace fifor8_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR9 Register bits
    namespace fifor9_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR10 Register bits
    namespace fifor10_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR11 Register bits
    namespace fifor11_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR12 Register bits
    namespace fifor12_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR13 Register bits
    namespace fifor13_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR14 Register bits
    namespace fifor14_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// FIFOR15 Register bits
    namespace fifor15_bits {
        constexpr uint32_t FIFODATA = (32 << 0);  ///< Receive and transmit FIFO data
    }

    /// SDMMC_IDMACTRLR Register bits
    namespace sdmmc_idmactrlr_bits {
        constexpr uint32_t IDMAEN = (1U << 0);  ///< IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
        constexpr uint32_t IDMABMODE = (1U << 1);  ///< Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    }

    /// SDMMC_IDMABSIZER Register bits
    namespace sdmmc_idmabsizer_bits {
        constexpr uint32_t IDMABNDT = (12 << 5);  ///< Number of bytes per buffer
    }

    /// SDMMC_IDMABASER Register bits
    namespace sdmmc_idmabaser_bits {
        constexpr uint32_t IDMABASE = (32 << 0);  ///< Buffer memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only)
    }

    /// SDMMC_IDMALAR Register bits
    namespace sdmmc_idmalar_bits {
        constexpr uint32_t ULA = (1U << 31);  ///< Update SDMMC_IDMALAR from linked list when in linked list mode (SDMMC_IDMACTRLR.IDMABMODE select linked list mode)
        constexpr uint32_t ULS = (1U << 30);  ///< Update SDMMC_IDMABSIZE from the next linked list when in linked list mode (SDMMC_IDMACTRLR.IDMABMODE select linked list mode and ULA = 1)
        constexpr uint32_t ABR = (1U << 29);  ///< Acknowledge linked list buffer ready
        constexpr uint32_t IDMALA = (14 << 2);  ///< Acknowledge linked list buffer ready
    }

    /// SDMMC_IDMABAR Register bits
    namespace sdmmc_idmabar_bits {
        constexpr uint32_t IDMABA = (30 << 2);  ///< Word aligned Linked list memory base address
    }

}

// ============================================================================
// SYSCFG Peripheral
// ============================================================================

namespace syscfg {
    /// Base addresses
    constexpr uint32_t SYSCFG_BASE = 0x46000400;

    /// SYSCFG Register structure
    struct Registers {
        volatile uint32_t SECCFGR;  ///< Offset: 0x00 - SYSCFG secure configuration register
        volatile uint32_t CFGR1;  ///< Offset: 0x04 - configuration register 1
        volatile uint32_t FPUIMR;  ///< Offset: 0x08 - FPU interrupt mask register
        volatile uint32_t CNSLCKR;  ///< Offset: 0x0C - SYSCFG CPU non-secure lock register
        volatile uint32_t CSLOCKR;  ///< Offset: 0x10 - SYSCFG CPU secure lock register
        volatile uint32_t CFGR2;  ///< Offset: 0x14 - configuration register 2
        volatile uint32_t MESR;  ///< Offset: 0x18 - memory erase status register
        volatile uint32_t CCCSR;  ///< Offset: 0x1C - compensation cell control/status register
        volatile uint32_t CCVR;  ///< Offset: 0x20 - compensation cell value register
        volatile uint32_t CCCR;  ///< Offset: 0x24 - compensation cell code register
        volatile uint32_t RSSCMDR;  ///< Offset: 0x2C - RSS command register
        volatile uint32_t OTGHSPHYCR;  ///< Offset: 0x74 - SYSCFG USB OTG_HS PHY register
    };

    /// Peripheral instances
    inline Registers* SYSCFG = reinterpret_cast<Registers*>(SYSCFG_BASE);

    // Bit definitions
    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t SYSCFGSEC = (1U << 0);  ///< SYSCFG clock control security
        constexpr uint32_t CLASSBSEC = (1U << 1);  ///< CLASSBSEC
        constexpr uint32_t FPUSEC = (1U << 3);  ///< FPUSEC
    }

    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t ENDCAP = (2 << 24);  ///< ENDCAP
        constexpr uint32_t PB9_FMP = (1U << 19);  ///< PB9_FMP
        constexpr uint32_t PB8_FMP = (1U << 18);  ///< PB8_FMP
        constexpr uint32_t PB7_FMP = (1U << 17);  ///< PB7_FMP
        constexpr uint32_t PB6_FMP = (1U << 16);  ///< PB6_FMP
        constexpr uint32_t ANASWVDD = (1U << 9);  ///< GPIO analog switch control voltage selection
        constexpr uint32_t BOOSTEN = (1U << 8);  ///< I/O analog switch voltage booster enable
    }

    /// FPUIMR Register bits
    namespace fpuimr_bits {
        constexpr uint32_t FPU_IE = (6 << 0);  ///< Floating point unit interrupts enable bits
    }

    /// CNSLCKR Register bits
    namespace cnslckr_bits {
        constexpr uint32_t LOCKNSVTOR = (1U << 0);  ///< VTOR_NS register lock
        constexpr uint32_t LOCKNSMPU = (1U << 1);  ///< Non-secure MPU registers lock
    }

    /// CSLOCKR Register bits
    namespace cslockr_bits {
        constexpr uint32_t LOCKSVTAIRCR = (1U << 0);  ///< LOCKSVTAIRCR
        constexpr uint32_t LOCKSMPU = (1U << 1);  ///< LOCKSMPU
        constexpr uint32_t LOCKSAU = (1U << 2);  ///< LOCKSAU
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t ECCL = (1U << 3);  ///< ECC Lock
        constexpr uint32_t PVDL = (1U << 2);  ///< PVD lock enable bit
        constexpr uint32_t SPL = (1U << 1);  ///< SRAM ECC lock bit
        constexpr uint32_t CLL = (1U << 0);  ///< LOCKUP (hardfault) output enable bit
    }

    /// MESR Register bits
    namespace mesr_bits {
        constexpr uint32_t IPMEE = (1U << 16);  ///< IPMEE
        constexpr uint32_t MCLR = (1U << 0);  ///< MCLR
    }

    /// CCCSR Register bits
    namespace cccsr_bits {
        constexpr uint32_t EN1 = (1U << 0);  ///< EN1
        constexpr uint32_t CS1 = (1U << 1);  ///< CS1
        constexpr uint32_t EN2 = (1U << 2);  ///< EN2
        constexpr uint32_t CS2 = (1U << 3);  ///< CS2
        constexpr uint32_t EN3 = (1U << 4);  ///< EN3
        constexpr uint32_t CS3 = (1U << 5);  ///< CS3
        constexpr uint32_t RDY1 = (1U << 8);  ///< RDY1
        constexpr uint32_t RDY2 = (1U << 9);  ///< RDY2
        constexpr uint32_t RDY3 = (1U << 10);  ///< RDY3
    }

    /// CCVR Register bits
    namespace ccvr_bits {
        constexpr uint32_t NCV1 = (4 << 0);  ///< NCV1
        constexpr uint32_t PCV1 = (4 << 4);  ///< PCV1
        constexpr uint32_t NCV2 = (4 << 8);  ///< NCV2
        constexpr uint32_t PCV2 = (4 << 12);  ///< PCV2
        constexpr uint32_t NCV3 = (4 << 16);  ///< NCV3
        constexpr uint32_t PCV3 = (4 << 20);  ///< PCV3
    }

    /// CCCR Register bits
    namespace cccr_bits {
        constexpr uint32_t NCC1 = (4 << 0);  ///< NCC1
        constexpr uint32_t PCC1 = (4 << 4);  ///< PCC1
        constexpr uint32_t NCC2 = (4 << 8);  ///< NCC2
        constexpr uint32_t PCC2 = (4 << 12);  ///< PCC2
        constexpr uint32_t NCC3 = (4 << 16);  ///< NCC3
        constexpr uint32_t PCC3 = (4 << 20);  ///< PCC3
    }

    /// RSSCMDR Register bits
    namespace rsscmdr_bits {
        constexpr uint32_t RSSCMD = (16 << 0);  ///< RSS commands
    }

    /// OTGHSPHYCR Register bits
    namespace otghsphycr_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
        constexpr uint32_t PDCTRL = (1U << 1);  ///< PDCTRL
        constexpr uint32_t CLKSEL = (4 << 2);  ///< CLKSEL
    }

}

// ============================================================================
// TAMP Peripheral
// ============================================================================

namespace tamp {
    /// Base addresses
    constexpr uint32_t TAMP_BASE = 0x46007C00;

    /// TAMP Register structure
    struct Registers {
        volatile uint32_t CR1;  ///< Offset: 0x00 - control register 1
        volatile uint32_t CR2;  ///< Offset: 0x04 - control register 2
        volatile uint32_t CR3;  ///< Offset: 0x08 - control register 3
        volatile uint32_t FLTCR;  ///< Offset: 0x0C - TAMP filter control register
        volatile uint32_t ATCR1;  ///< Offset: 0x10 - TAMP active tamper control register
        volatile uint32_t ATSEEDR;  ///< Offset: 0x14 - TAMP active tamper seed register
        volatile uint32_t ATOR;  ///< Offset: 0x18 - TAMP active tamper output register
        volatile uint32_t ATCR2;  ///< Offset: 0x1C - TAMP active tamper control register 2
        volatile uint32_t SECCFGR;  ///< Offset: 0x20 - TAMP secure mode register
        volatile uint32_t PRIVCR;  ///< Offset: 0x24 - TAMP privilege mode control register
        volatile uint32_t IER;  ///< Offset: 0x2C - TAMP interrupt enable register
        volatile uint32_t SR;  ///< Offset: 0x30 - TAMP status register
        volatile uint32_t MISR;  ///< Offset: 0x34 - TAMP masked interrupt status register
        volatile uint32_t SMISR;  ///< Offset: 0x38 - TAMP secure masked interrupt status register
        volatile uint32_t SCR;  ///< Offset: 0x3C - TAMP status clear register
        volatile uint32_t COUNT1R;  ///< Offset: 0x40 - TAMP monotonic counter 1register
        volatile uint32_t ERCFGR;  ///< Offset: 0x54 - TAMP erase configuration register
        volatile uint32_t BKP0R;  ///< Offset: 0x100 - TAMP backup register
        volatile uint32_t BKP1R;  ///< Offset: 0x104 - TAMP backup register
        volatile uint32_t BKP2R;  ///< Offset: 0x108 - TAMP backup register
        volatile uint32_t BKP3R;  ///< Offset: 0x10C - TAMP backup register
        volatile uint32_t BKP4R;  ///< Offset: 0x110 - TAMP backup register
        volatile uint32_t BKP5R;  ///< Offset: 0x114 - TAMP backup register
        volatile uint32_t BKP6R;  ///< Offset: 0x118 - TAMP backup register
        volatile uint32_t BKP7R;  ///< Offset: 0x11C - TAMP backup register
        volatile uint32_t BKP8R;  ///< Offset: 0x120 - TAMP backup register
        volatile uint32_t BKP9R;  ///< Offset: 0x124 - TAMP backup register
        volatile uint32_t BKP10R;  ///< Offset: 0x128 - TAMP backup register
        volatile uint32_t BKP11R;  ///< Offset: 0x12C - TAMP backup register
        volatile uint32_t BKP12R;  ///< Offset: 0x130 - TAMP backup register
        volatile uint32_t BKP13R;  ///< Offset: 0x134 - TAMP backup register
        volatile uint32_t BKP14R;  ///< Offset: 0x138 - TAMP backup register
        volatile uint32_t BKP15R;  ///< Offset: 0x13C - TAMP backup register
        volatile uint32_t BKP16R;  ///< Offset: 0x140 - TAMP backup register
        volatile uint32_t BKP17R;  ///< Offset: 0x144 - TAMP backup register
        volatile uint32_t BKP18R;  ///< Offset: 0x148 - TAMP backup register
        volatile uint32_t BKP19R;  ///< Offset: 0x14C - TAMP backup register
        volatile uint32_t BKP20R;  ///< Offset: 0x150 - TAMP backup register
        volatile uint32_t BKP21R;  ///< Offset: 0x154 - TAMP backup register
        volatile uint32_t BKP22R;  ///< Offset: 0x158 - TAMP backup register
        volatile uint32_t BKP23R;  ///< Offset: 0x15C - TAMP backup register
        volatile uint32_t BKP24R;  ///< Offset: 0x160 - TAMP backup register
        volatile uint32_t BKP25R;  ///< Offset: 0x164 - TAMP backup register
        volatile uint32_t BKP26R;  ///< Offset: 0x168 - TAMP backup register
        volatile uint32_t BKP27R;  ///< Offset: 0x16C - TAMP backup register
        volatile uint32_t BKP28R;  ///< Offset: 0x170 - TAMP backup register
        volatile uint32_t BKP29R;  ///< Offset: 0x174 - TAMP backup register
        volatile uint32_t BKP30R;  ///< Offset: 0x178 - TAMP backup register
        volatile uint32_t BKP31R;  ///< Offset: 0x17C - TAMP backup register
    };

    /// Peripheral instances
    inline Registers* TAMP = reinterpret_cast<Registers*>(TAMP_BASE);

    // Bit definitions
    /// CR1 Register bits
    namespace cr1_bits {
        constexpr uint32_t ITAMP13E = (1U << 28);  ///< ITAMP13E
        constexpr uint32_t ITAMP12E = (1U << 27);  ///< ITAMP12E
        constexpr uint32_t ITAMP11E = (1U << 26);  ///< TAMP1E
        constexpr uint32_t ITAMP9E = (1U << 24);  ///< ITAMP9E
        constexpr uint32_t ITAMP8E = (1U << 23);  ///< ITAMP8E
        constexpr uint32_t ITAMP7E = (1U << 22);  ///< ITAMP7E
        constexpr uint32_t ITAMP6E = (1U << 21);  ///< ITAMP6E
        constexpr uint32_t ITAMP5E = (1U << 20);  ///< ITAMP5E
        constexpr uint32_t ITAMP3E = (1U << 18);  ///< ITAMP3E
        constexpr uint32_t ITAMP2E = (1U << 17);  ///< ITAMP2E
        constexpr uint32_t ITAMP1E = (1U << 16);  ///< ITAMP1E
        constexpr uint32_t TAMP8E = (1U << 7);  ///< TAMP8E
        constexpr uint32_t TAMP7E = (1U << 6);  ///< TAMP7E
        constexpr uint32_t TAMP6E = (1U << 5);  ///< TAMP6E
        constexpr uint32_t TAMP5E = (1U << 4);  ///< TAMP5E
        constexpr uint32_t TAMP4E = (1U << 3);  ///< TAMP4E
        constexpr uint32_t TAMP3E = (1U << 2);  ///< TAMP3E
        constexpr uint32_t TAMP2E = (1U << 1);  ///< TAMP2E
        constexpr uint32_t TAMP1E = (1U << 0);  ///< TAMP1E
    }

    /// CR2 Register bits
    namespace cr2_bits {
        constexpr uint32_t TAMP1NOER = (1U << 0);  ///< TAMP1NOER
        constexpr uint32_t TAMP2NOER = (1U << 1);  ///< TAMP2NOER
        constexpr uint32_t TAMP3NOER = (1U << 2);  ///< TAMP3NOER
        constexpr uint32_t TAMP4NOER = (1U << 3);  ///< TAMP4NOER
        constexpr uint32_t TAMP5NOER = (1U << 4);  ///< TAMP5NOER
        constexpr uint32_t TAMP6NOER = (1U << 5);  ///< TAMP6NOER
        constexpr uint32_t TAMP7NOER = (1U << 6);  ///< TAMP7NOER
        constexpr uint32_t TAMP8NOER = (1U << 7);  ///< TAMP8NOER
        constexpr uint32_t TAMP1MSK = (1U << 16);  ///< TAMP1MSK
        constexpr uint32_t TAMP2MSK = (1U << 17);  ///< TAMP2MSK
        constexpr uint32_t TAMP3MSK = (1U << 18);  ///< TAMP3MSK
        constexpr uint32_t BKBLOCK = (1U << 22);  ///< BKBLOCK
        constexpr uint32_t BKERASE = (1U << 23);  ///< BKERASE
        constexpr uint32_t TAMP1TRG = (1U << 24);  ///< TAMP1TRG
        constexpr uint32_t TAMP2TRG = (1U << 25);  ///< TAMP2TRG
        constexpr uint32_t TAMP3TRG = (1U << 26);  ///< TAMP3TRG
        constexpr uint32_t TAMP4TRG = (1U << 27);  ///< TAMP4TRG
        constexpr uint32_t TAMP5TRG = (1U << 28);  ///< TAMP5TRG
        constexpr uint32_t TAMP6TRG = (1U << 29);  ///< TAMP6TRG
        constexpr uint32_t TAMP7TRG = (1U << 30);  ///< TAMP7TRG
        constexpr uint32_t TAMP8TRG = (1U << 31);  ///< TAMP8TRG
    }

    /// CR3 Register bits
    namespace cr3_bits {
        constexpr uint32_t ITAMP1NOER = (1U << 0);  ///< ITAMP1NOER
        constexpr uint32_t ITAMP2NOER = (1U << 1);  ///< ITAMP2NOER
        constexpr uint32_t ITAMP3NOER = (1U << 2);  ///< ITAMP3NOER
        constexpr uint32_t TAMP5NOER = (1U << 4);  ///< TAMP5NOER
        constexpr uint32_t TAMP6NOER = (1U << 5);  ///< TAMP6NOER
        constexpr uint32_t TAMP7NOER = (1U << 6);  ///< TAMP7NOER
        constexpr uint32_t TAMP8NOER = (1U << 7);  ///< TAMP8NOER
        constexpr uint32_t ITAMP9NOER = (1U << 8);  ///< ITAMP9NOER
        constexpr uint32_t ITAMP11NOER = (1U << 10);  ///< ITAMP11NOER
        constexpr uint32_t ITAMP12NOER = (1U << 11);  ///< ITAMP12NOER
        constexpr uint32_t ITAMP13NOER = (1U << 12);  ///< ITAMP13NOER
    }

    /// FLTCR Register bits
    namespace fltcr_bits {
        constexpr uint32_t TAMPFREQ = (3 << 0);  ///< TAMPFREQ
        constexpr uint32_t TAMPFLT = (2 << 3);  ///< TAMPFLT
        constexpr uint32_t TAMPPRCH = (2 << 5);  ///< TAMPPRCH
        constexpr uint32_t TAMPPUDIS = (1U << 7);  ///< TAMPPUDIS
    }

    /// ATCR1 Register bits
    namespace atcr1_bits {
        constexpr uint32_t TAMP1AM = (1U << 0);  ///< TAMP1AM
        constexpr uint32_t TAMP2AM = (1U << 1);  ///< TAMP2AM
        constexpr uint32_t TAMP3AM = (1U << 2);  ///< TAMP3AM
        constexpr uint32_t TAMP4AM = (1U << 3);  ///< TAMP4AM
        constexpr uint32_t TAMP5AM = (1U << 4);  ///< TAMP5AM
        constexpr uint32_t TAMP6AM = (1U << 5);  ///< TAMP6AM
        constexpr uint32_t TAMP7AM = (1U << 6);  ///< TAMP7AM
        constexpr uint32_t TAMP8AM = (1U << 7);  ///< TAMP8AM
        constexpr uint32_t ATOSEL1 = (2 << 8);  ///< ATOSEL1
        constexpr uint32_t ATOSEL2 = (2 << 10);  ///< ATOSEL2
        constexpr uint32_t ATOSEL3 = (2 << 12);  ///< ATOSEL3
        constexpr uint32_t ATOSEL4 = (2 << 14);  ///< ATOSEL4
        constexpr uint32_t ATCKSEL = (3 << 16);  ///< ATCKSEL
        constexpr uint32_t ATPER = (3 << 24);  ///< ATPER
        constexpr uint32_t ATOSHARE = (1U << 30);  ///< ATOSHARE
        constexpr uint32_t FLTEN = (1U << 31);  ///< ATOSHARE
    }

    /// ATSEEDR Register bits
    namespace atseedr_bits {
        constexpr uint32_t SEED = (32 << 0);  ///< SEED
    }

    /// ATOR Register bits
    namespace ator_bits {
        constexpr uint32_t PRNG = (8 << 0);  ///< PRNG
        constexpr uint32_t SEEDF = (1U << 14);  ///< SEEDF
        constexpr uint32_t INITS = (1U << 15);  ///< INITS
    }

    /// ATCR2 Register bits
    namespace atcr2_bits {
        constexpr uint32_t ATOSEL1 = (3 << 8);  ///< ATOSEL1
        constexpr uint32_t ATOSEL2 = (3 << 11);  ///< ATOSEL2
        constexpr uint32_t ATOSEL3 = (3 << 14);  ///< ATOSEL3
        constexpr uint32_t ATOSEL4 = (2 << 17);  ///< ATOSEL4
        constexpr uint32_t ATOSEL5 = (3 << 20);  ///< ATOSEL5
        constexpr uint32_t ATOSEL6 = (3 << 23);  ///< ATOSEL6
        constexpr uint32_t ATOSEL7 = (3 << 26);  ///< ATOSEL7
        constexpr uint32_t ATOSEL8 = (3 << 29);  ///< ATOSEL8
    }

    /// SECCFGR Register bits
    namespace seccfgr_bits {
        constexpr uint32_t BKPRWSEC = (8 << 0);  ///< BKPRWSEC
        constexpr uint32_t CNT1SEC = (1U << 15);  ///< CNT1SEC
        constexpr uint32_t BKPWSEC = (8 << 16);  ///< BKPWSEC
        constexpr uint32_t BHKLOCK = (1U << 30);  ///< BHKLOCK
        constexpr uint32_t TAMPSEC = (1U << 31);  ///< TAMPSEC
    }

    /// PRIVCR Register bits
    namespace privcr_bits {
        constexpr uint32_t CNT1PRIV = (1U << 15);  ///< CNT1PRIV
        constexpr uint32_t BKPRWPRIV = (1U << 29);  ///< BKPRWPRIV
        constexpr uint32_t BKPWPRIV = (1U << 30);  ///< BKPWPRIV
        constexpr uint32_t TAMPPRIV = (1U << 31);  ///< TAMPPRIV
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t TAMP1IE = (1U << 0);  ///< TAMP1IE
        constexpr uint32_t TAMP2IE = (1U << 1);  ///< TAMP2IE
        constexpr uint32_t TAMP3IE = (1U << 2);  ///< TAMP3IE
        constexpr uint32_t TAMP4IE = (1U << 3);  ///< TAMP4IE
        constexpr uint32_t TAMP5IE = (1U << 4);  ///< TAMP5IE
        constexpr uint32_t TAMP6IE = (1U << 5);  ///< TAMP6IE
        constexpr uint32_t TAMP7IE = (1U << 6);  ///< TAMP7IE
        constexpr uint32_t TAMP8IE = (1U << 7);  ///< TAMP8IE
        constexpr uint32_t ITAMP1IE = (1U << 16);  ///< ITAMP1IE
        constexpr uint32_t ITAMP2IE = (1U << 17);  ///< ITAMP2IE
        constexpr uint32_t ITAMP3IE = (1U << 18);  ///< ITAMP3IE
        constexpr uint32_t ITAMP5IE = (1U << 20);  ///< ITAMP5IE
        constexpr uint32_t ITAMP6IE = (1U << 21);  ///< ITAMP6IE
        constexpr uint32_t ITAMP7IE = (1U << 22);  ///< ITAMP7IE
        constexpr uint32_t ITAMP8IE = (1U << 23);  ///< ITAMP8IE
        constexpr uint32_t ITAMP9IE = (1U << 24);  ///< ITAMP9IE
        constexpr uint32_t ITAMP11IE = (1U << 26);  ///< ITAMP11IE
        constexpr uint32_t ITAMP12IE = (1U << 27);  ///< ITAMP12IE
        constexpr uint32_t ITAMP13IE = (1U << 28);  ///< ITAMP13IE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TAMP1F = (1U << 0);  ///< TAMP1F
        constexpr uint32_t TAMP2F = (1U << 1);  ///< TAMP2F
        constexpr uint32_t TAMP3F = (1U << 2);  ///< TAMP3F
        constexpr uint32_t TAMP4F = (1U << 3);  ///< TAMP4F
        constexpr uint32_t TAMP5F = (1U << 4);  ///< TAMP5F
        constexpr uint32_t TAMP6F = (1U << 5);  ///< TAMP6F
        constexpr uint32_t TAMP7F = (1U << 6);  ///< TAMP7F
        constexpr uint32_t TAMP8F = (1U << 7);  ///< TAMP8F
        constexpr uint32_t CITAMP1F = (1U << 16);  ///< CITAMP1F
        constexpr uint32_t CITAMP2F = (1U << 17);  ///< CITAMP2F
        constexpr uint32_t ITAMP3F = (1U << 18);  ///< ITAMP3F
        constexpr uint32_t ITAMP5F = (1U << 20);  ///< ITAMP5F
        constexpr uint32_t ITAMP6F = (1U << 21);  ///< ITAMP6F
        constexpr uint32_t ITAMP7F = (1U << 22);  ///< ITAMP7F
        constexpr uint32_t ITAMP8F = (1U << 23);  ///< ITAMP8F
        constexpr uint32_t ITAMP9F = (1U << 24);  ///< ITAMP9F
        constexpr uint32_t CITAMP11F = (1U << 26);  ///< CITAMP11F
        constexpr uint32_t ITAMP12F = (1U << 27);  ///< ITAMP12F
        constexpr uint32_t ITAMP13IE = (1U << 28);  ///< ITAMP13IE
    }

    /// MISR Register bits
    namespace misr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3MF
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4MF
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5MF
        constexpr uint32_t TAMP6MF = (1U << 5);  ///< TAMP6MF
        constexpr uint32_t TAMP7MF = (1U << 6);  ///< TAMP7MF
        constexpr uint32_t TAMP8MF = (1U << 7);  ///< TAMP8MF
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< ITAMP1MF
        constexpr uint32_t ITAMP2MF = (1U << 17);  ///< ITAMP2MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ITAMP6MF
        constexpr uint32_t ITAMP7MF = (1U << 22);  ///< ITAMP7MF
        constexpr uint32_t ITAMP8MF = (1U << 23);  ///< ITAMP8MF
        constexpr uint32_t ITAMP9MF = (1U << 24);  ///< ITAMP9MF
        constexpr uint32_t ITAMP11MF = (1U << 26);  ///< ITAMP11MF
        constexpr uint32_t ITAMP12MF = (1U << 27);  ///< ITAMP12MF
        constexpr uint32_t ITAMP13MF = (1U << 28);  ///< ITAMP13MF
    }

    /// SMISR Register bits
    namespace smisr_bits {
        constexpr uint32_t TAMP1MF = (1U << 0);  ///< TAMP1MF
        constexpr uint32_t TAMP2MF = (1U << 1);  ///< TAMP2MF
        constexpr uint32_t TAMP3MF = (1U << 2);  ///< TAMP3MF
        constexpr uint32_t TAMP4MF = (1U << 3);  ///< TAMP4MF
        constexpr uint32_t TAMP5MF = (1U << 4);  ///< TAMP5MF
        constexpr uint32_t TAMP6MF = (1U << 5);  ///< TAMP6MF
        constexpr uint32_t TAMP7MF = (1U << 6);  ///< TAMP7MF
        constexpr uint32_t TAMP8MF = (1U << 7);  ///< TAMP8MF
        constexpr uint32_t ITAMP1MF = (1U << 16);  ///< ITAMP1MF
        constexpr uint32_t ITAMP2MF = (1U << 17);  ///< ITAMP2MF
        constexpr uint32_t ITAMP3MF = (1U << 18);  ///< ITAMP3MF
        constexpr uint32_t ITAMP5MF = (1U << 20);  ///< ITAMP5MF
        constexpr uint32_t ITAMP6MF = (1U << 21);  ///< ITAMP6MF
        constexpr uint32_t ITAMP7MF = (1U << 22);  ///< ITAMP7MF
        constexpr uint32_t ITAMP8MF = (1U << 23);  ///< ITAMP8MF
        constexpr uint32_t ITAMP9MF = (1U << 24);  ///< ITAMP9MF
        constexpr uint32_t ITAMP11MF = (1U << 26);  ///< ITAMP11MF
        constexpr uint32_t ITAMP12MF = (1U << 27);  ///< ITAMP12MF
        constexpr uint32_t ITAMP13MF = (1U << 28);  ///< ITAMP13MF
    }

    /// SCR Register bits
    namespace scr_bits {
        constexpr uint32_t CTAMP1F = (1U << 0);  ///< CTAMP1F
        constexpr uint32_t CTAMP2F = (1U << 1);  ///< CTAMP2F
        constexpr uint32_t CTAMP3F = (1U << 2);  ///< CTAMP3F
        constexpr uint32_t CTAMP4F = (1U << 3);  ///< CTAMP4F
        constexpr uint32_t CTAMP5F = (1U << 4);  ///< CTAMP5F
        constexpr uint32_t CTAMP6F = (1U << 5);  ///< CTAMP6F
        constexpr uint32_t CITAMP7F = (1U << 6);  ///< CITAMP3F
        constexpr uint32_t CITAMP8F = (1U << 7);  ///< CITAMP3F
        constexpr uint32_t CITAMP1F = (1U << 16);  ///< CITAMP1F
        constexpr uint32_t CITAMP2F = (1U << 17);  ///< CITAMP2F
        constexpr uint32_t CITAMP3F = (1U << 18);  ///< CITAMP3F
        constexpr uint32_t CITAMP5F = (1U << 20);  ///< CITAMP5F
        constexpr uint32_t CITAMP6F_bit21 = (1U << 21);  ///< CITAMP6F_bit21
        constexpr uint32_t CITAMP7F_bit22 = (1U << 22);  ///< CITAMP7F_bit22
        constexpr uint32_t CITAMP8F_bit23 = (1U << 23);  ///< CITAMP8F_bit23
        constexpr uint32_t CITAMP9F = (1U << 24);  ///< CITAMP9F
        constexpr uint32_t CITAMP11F = (1U << 26);  ///< CITAMP11F
        constexpr uint32_t CITAMP12F = (1U << 27);  ///< CITAMP12F
        constexpr uint32_t CITAMP13F = (1U << 28);  ///< CITAMP13F
    }

    /// COUNT1R Register bits
    namespace count1r_bits {
        constexpr uint32_t COUNT = (32 << 0);  ///< COUNT
    }

    /// ERCFGR Register bits
    namespace ercfgr_bits {
        constexpr uint32_t ERCFG0 = (1U << 0);  ///< ERCFG0
    }

    /// BKP0R Register bits
    namespace bkp0r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP1R Register bits
    namespace bkp1r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP2R Register bits
    namespace bkp2r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP3R Register bits
    namespace bkp3r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP4R Register bits
    namespace bkp4r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP5R Register bits
    namespace bkp5r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP6R Register bits
    namespace bkp6r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP7R Register bits
    namespace bkp7r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP8R Register bits
    namespace bkp8r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP9R Register bits
    namespace bkp9r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP10R Register bits
    namespace bkp10r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP11R Register bits
    namespace bkp11r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP12R Register bits
    namespace bkp12r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP13R Register bits
    namespace bkp13r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP14R Register bits
    namespace bkp14r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP15R Register bits
    namespace bkp15r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP16R Register bits
    namespace bkp16r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP17R Register bits
    namespace bkp17r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP18R Register bits
    namespace bkp18r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP19R Register bits
    namespace bkp19r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP20R Register bits
    namespace bkp20r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP21R Register bits
    namespace bkp21r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP22R Register bits
    namespace bkp22r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP23R Register bits
    namespace bkp23r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP24R Register bits
    namespace bkp24r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP25R Register bits
    namespace bkp25r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP26R Register bits
    namespace bkp26r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP27R Register bits
    namespace bkp27r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP28R Register bits
    namespace bkp28r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP29R Register bits
    namespace bkp29r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP30R Register bits
    namespace bkp30r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

    /// BKP31R Register bits
    namespace bkp31r_bits {
        constexpr uint32_t BKP = (32 << 0);  ///< BKP
    }

}

// ============================================================================
// TSC Peripheral
// ============================================================================

namespace tsc {
    /// Base addresses
    constexpr uint32_t TSC_BASE = 0x40024000;

    /// TSC Register structure
    struct Registers {
        volatile uint32_t CR;  ///< Offset: 0x00 - control register
        volatile uint32_t IER;  ///< Offset: 0x04 - interrupt enable register
        volatile uint32_t ICR;  ///< Offset: 0x08 - interrupt clear register
        volatile uint32_t ISR;  ///< Offset: 0x0C - interrupt status register
        volatile uint32_t IOHCR;  ///< Offset: 0x10 - I/O hysteresis control register
        volatile uint32_t IOASCR;  ///< Offset: 0x18 - I/O analog switch control register
        volatile uint32_t IOSCR;  ///< Offset: 0x20 - I/O sampling control register
        volatile uint32_t IOCCR;  ///< Offset: 0x28 - I/O channel control register
        volatile uint32_t IOGCSR;  ///< Offset: 0x30 - I/O group control status register
        volatile uint32_t IOG1CR;  ///< Offset: 0x34 - I/O group x counter register
        volatile uint32_t IOG2CR;  ///< Offset: 0x38 - I/O group x counter register
        volatile uint32_t IOG3CR;  ///< Offset: 0x3C - I/O group x counter register
        volatile uint32_t IOG4CR;  ///< Offset: 0x40 - I/O group x counter register
        volatile uint32_t IOG5CR;  ///< Offset: 0x44 - I/O group x counter register
        volatile uint32_t IOG6CR;  ///< Offset: 0x48 - I/O group x counter register
        volatile uint32_t IOG7CR;  ///< Offset: 0x4C - I/O group x counter register
        volatile uint32_t IOG8CR;  ///< Offset: 0x50 - I/O group x counter register
    };

    /// Peripheral instances
    inline Registers* TSC = reinterpret_cast<Registers*>(TSC_BASE);

    // Bit definitions
    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t CTPH = (4 << 28);  ///< Charge transfer pulse high
        constexpr uint32_t CTPL = (4 << 24);  ///< Charge transfer pulse low
        constexpr uint32_t SSD = (7 << 17);  ///< Spread spectrum deviation
        constexpr uint32_t SSE = (1U << 16);  ///< Spread spectrum enable
        constexpr uint32_t SSPSC = (1U << 15);  ///< Spread spectrum prescaler
        constexpr uint32_t PGPSC = (3 << 12);  ///< pulse generator prescaler
        constexpr uint32_t MCV = (3 << 5);  ///< Max count value
        constexpr uint32_t IODEF = (1U << 4);  ///< I/O Default mode
        constexpr uint32_t SYNCPOL = (1U << 3);  ///< Synchronization pin polarity
        constexpr uint32_t AM = (1U << 2);  ///< Acquisition mode
        constexpr uint32_t START = (1U << 1);  ///< Start a new acquisition
        constexpr uint32_t TSCE = (1U << 0);  ///< Touch sensing controller enable
    }

    /// IER Register bits
    namespace ier_bits {
        constexpr uint32_t MCEIE = (1U << 1);  ///< Max count error interrupt enable
        constexpr uint32_t EOAIE = (1U << 0);  ///< End of acquisition interrupt enable
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t MCEIC = (1U << 1);  ///< Max count error interrupt clear
        constexpr uint32_t EOAIC = (1U << 0);  ///< End of acquisition interrupt clear
    }

    /// ISR Register bits
    namespace isr_bits {
        constexpr uint32_t MCEF = (1U << 1);  ///< Max count error flag
        constexpr uint32_t EOAF = (1U << 0);  ///< End of acquisition flag
    }

    /// IOHCR Register bits
    namespace iohcr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOASCR Register bits
    namespace ioascr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOSCR Register bits
    namespace ioscr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOCCR Register bits
    namespace ioccr_bits {
        constexpr uint32_t G8_IO4 = (1U << 31);  ///< G8_IO4
        constexpr uint32_t G8_IO3 = (1U << 30);  ///< G8_IO3
        constexpr uint32_t G8_IO2 = (1U << 29);  ///< G8_IO2
        constexpr uint32_t G8_IO1 = (1U << 28);  ///< G8_IO1
        constexpr uint32_t G7_IO4 = (1U << 27);  ///< G7_IO4
        constexpr uint32_t G7_IO3 = (1U << 26);  ///< G7_IO3
        constexpr uint32_t G7_IO2 = (1U << 25);  ///< G7_IO2
        constexpr uint32_t G7_IO1 = (1U << 24);  ///< G7_IO1
        constexpr uint32_t G6_IO4 = (1U << 23);  ///< G6_IO4
        constexpr uint32_t G6_IO3 = (1U << 22);  ///< G6_IO3
        constexpr uint32_t G6_IO2 = (1U << 21);  ///< G6_IO2
        constexpr uint32_t G6_IO1 = (1U << 20);  ///< G6_IO1
        constexpr uint32_t G5_IO4 = (1U << 19);  ///< G5_IO4
        constexpr uint32_t G5_IO3 = (1U << 18);  ///< G5_IO3
        constexpr uint32_t G5_IO2 = (1U << 17);  ///< G5_IO2
        constexpr uint32_t G5_IO1 = (1U << 16);  ///< G5_IO1
        constexpr uint32_t G4_IO4 = (1U << 15);  ///< G4_IO4
        constexpr uint32_t G4_IO3 = (1U << 14);  ///< G4_IO3
        constexpr uint32_t G4_IO2 = (1U << 13);  ///< G4_IO2
        constexpr uint32_t G4_IO1 = (1U << 12);  ///< G4_IO1
        constexpr uint32_t G3_IO4 = (1U << 11);  ///< G3_IO4
        constexpr uint32_t G3_IO3 = (1U << 10);  ///< G3_IO3
        constexpr uint32_t G3_IO2 = (1U << 9);  ///< G3_IO2
        constexpr uint32_t G3_IO1 = (1U << 8);  ///< G3_IO1
        constexpr uint32_t G2_IO4 = (1U << 7);  ///< G2_IO4
        constexpr uint32_t G2_IO3 = (1U << 6);  ///< G2_IO3
        constexpr uint32_t G2_IO2 = (1U << 5);  ///< G2_IO2
        constexpr uint32_t G2_IO1 = (1U << 4);  ///< G2_IO1
        constexpr uint32_t G1_IO4 = (1U << 3);  ///< G1_IO4
        constexpr uint32_t G1_IO3 = (1U << 2);  ///< G1_IO3
        constexpr uint32_t G1_IO2 = (1U << 1);  ///< G1_IO2
        constexpr uint32_t G1_IO1 = (1U << 0);  ///< G1_IO1
    }

    /// IOGCSR Register bits
    namespace iogcsr_bits {
        constexpr uint32_t G8S = (1U << 23);  ///< Analog I/O group x status
        constexpr uint32_t G7S = (1U << 22);  ///< Analog I/O group x status
        constexpr uint32_t G6S = (1U << 21);  ///< Analog I/O group x status
        constexpr uint32_t G5S = (1U << 20);  ///< Analog I/O group x status
        constexpr uint32_t G4S = (1U << 19);  ///< Analog I/O group x status
        constexpr uint32_t G3S = (1U << 18);  ///< Analog I/O group x status
        constexpr uint32_t G2S = (1U << 17);  ///< Analog I/O group x status
        constexpr uint32_t G1S = (1U << 16);  ///< Analog I/O group x status
        constexpr uint32_t G8E = (1U << 7);  ///< Analog I/O group x enable
        constexpr uint32_t G7E = (1U << 6);  ///< Analog I/O group x enable
        constexpr uint32_t G6E = (1U << 5);  ///< Analog I/O group x enable
        constexpr uint32_t G5E = (1U << 4);  ///< Analog I/O group x enable
        constexpr uint32_t G4E = (1U << 3);  ///< Analog I/O group x enable
        constexpr uint32_t G3E = (1U << 2);  ///< Analog I/O group x enable
        constexpr uint32_t G2E = (1U << 1);  ///< Analog I/O group x enable
        constexpr uint32_t G1E = (1U << 0);  ///< Analog I/O group x enable
    }

    /// IOG1CR Register bits
    namespace iog1cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG2CR Register bits
    namespace iog2cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG3CR Register bits
    namespace iog3cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG4CR Register bits
    namespace iog4cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG5CR Register bits
    namespace iog5cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG6CR Register bits
    namespace iog6cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG7CR Register bits
    namespace iog7cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

    /// IOG8CR Register bits
    namespace iog8cr_bits {
        constexpr uint32_t CNT = (14 << 0);  ///< Counter value
    }

}

// ============================================================================
// UCPD1 Peripheral
// ============================================================================

namespace ucpd1 {
    /// Base addresses
    constexpr uint32_t UCPD1_BASE = 0x4000DC00;

    /// UCPD1 Register structure
    struct Registers {
        volatile uint32_t CFGR1;  ///< Offset: 0x00 - UCPD configuration register 1
        volatile uint32_t CFGR2;  ///< Offset: 0x04 - UCPD configuration register 2
        volatile uint32_t CFGR3;  ///< Offset: 0x08 - UCPD configuration register 3
        volatile uint32_t CR;  ///< Offset: 0x0C - UCPD control register
        volatile uint32_t IMR;  ///< Offset: 0x10 - UCPD Interrupt Mask Register
        volatile uint32_t SR;  ///< Offset: 0x14 - UCPD Status Register
        volatile uint32_t ICR;  ///< Offset: 0x18 - UCPD Interrupt Clear Register
        volatile uint32_t TX_ORDSET;  ///< Offset: 0x1C - UCPD Tx Ordered Set Type Register
        volatile uint32_t TX_PAYSZ;  ///< Offset: 0x20 - UCPD Tx payload size Register
        volatile uint32_t TXDR;  ///< Offset: 0x24 - UCPD Tx Data Register
        volatile uint32_t RX_ORDSET;  ///< Offset: 0x28 - UCPD Rx Ordered Set Register
        volatile uint32_t RX_PAYSZ;  ///< Offset: 0x2C - UCPD Rx payload size Register
        volatile uint32_t RXDR;  ///< Offset: 0x30 - UCPD Receive Data Register
        volatile uint32_t RX_ORDEXT1;  ///< Offset: 0x34 - UCPD Rx Ordered Set Extension Register 1
        volatile uint32_t RX_ORDEXT2;  ///< Offset: 0x38 - UCPD Rx Ordered Set Extension Register 2
    };

    /// Peripheral instances
    inline Registers* UCPD1 = reinterpret_cast<Registers*>(UCPD1_BASE);

    // Bit definitions
    /// CFGR1 Register bits
    namespace cfgr1_bits {
        constexpr uint32_t HBITCLKDIV = (6 << 0);  ///< HBITCLKDIV
        constexpr uint32_t IFRGAP = (5 << 6);  ///< IFRGAP
        constexpr uint32_t TRANSWIN = (5 << 11);  ///< TRANSWIN
        constexpr uint32_t PSC_USBPDCLK = (3 << 17);  ///< PSC_USBPDCLK
        constexpr uint32_t RXORDSETEN = (9 << 20);  ///< RXORDSETEN
        constexpr uint32_t TXDMAEN = (1U << 29);  ///< TXDMAEN
        constexpr uint32_t RXDMAEN = (1U << 30);  ///< RXDMAEN:
        constexpr uint32_t UCPDEN = (1U << 31);  ///< UCPDEN
    }

    /// CFGR2 Register bits
    namespace cfgr2_bits {
        constexpr uint32_t RXFILTDIS = (1U << 0);  ///< RXFILTDIS
        constexpr uint32_t RXFILT2N3 = (1U << 1);  ///< RXFILT2N3
        constexpr uint32_t FORCECLK = (1U << 2);  ///< FORCECLK
        constexpr uint32_t WUPEN = (1U << 3);  ///< WUPEN
    }

    /// CFGR3 Register bits
    namespace cfgr3_bits {
        constexpr uint32_t TRIM1_NG_CCRPD = (4 << 0);  ///< TRIM1_NG_CCRPD
        constexpr uint32_t TRIM1_NG_CC3A0 = (4 << 9);  ///< TRIM1_NG_CC3A0
        constexpr uint32_t TRIM2_NG_CCRPD = (4 << 16);  ///< TRIM2_NG_CCRPD
        constexpr uint32_t TRIM2_NG_CC3A0 = (4 << 25);  ///< TRIM2_NG_CC3A0
    }

    /// CR Register bits
    namespace cr_bits {
        constexpr uint32_t TXMODE = (2 << 0);  ///< TXMODE
        constexpr uint32_t TXSEND = (1U << 2);  ///< TXSEND
        constexpr uint32_t TXHRST = (1U << 3);  ///< TXHRST
        constexpr uint32_t RXMODE = (1U << 4);  ///< RXMODE
        constexpr uint32_t PHYRXEN = (1U << 5);  ///< PHYRXEN
        constexpr uint32_t PHYCCSEL = (1U << 6);  ///< PHYCCSEL
        constexpr uint32_t ANASUBMODE = (2 << 7);  ///< ANASUBMODE
        constexpr uint32_t ANAMODE = (1U << 9);  ///< ANAMODE
        constexpr uint32_t CCENABLE = (2 << 10);  ///< CCENABLE
        constexpr uint32_t FRSRXEN = (1U << 16);  ///< FRSRXEN
        constexpr uint32_t FRSTX = (1U << 17);  ///< FRSTX
        constexpr uint32_t RDCH = (1U << 18);  ///< RDCH
        constexpr uint32_t CC1TCDIS = (1U << 20);  ///< CC1TCDIS
        constexpr uint32_t CC2TCDIS = (1U << 21);  ///< CC2TCDIS
    }

    /// IMR Register bits
    namespace imr_bits {
        constexpr uint32_t TXISIE = (1U << 0);  ///< TXISIE
        constexpr uint32_t TXMSGDISCIE = (1U << 1);  ///< TXMSGDISCIE
        constexpr uint32_t TXMSGSENTIE = (1U << 2);  ///< TXMSGSENTIE
        constexpr uint32_t TXMSGABTIE = (1U << 3);  ///< TXMSGABTIE
        constexpr uint32_t HRSTDISCIE = (1U << 4);  ///< HRSTDISCIE
        constexpr uint32_t HRSTSENTIE = (1U << 5);  ///< HRSTSENTIE
        constexpr uint32_t TXUNDIE = (1U << 6);  ///< TXUNDIE
        constexpr uint32_t RXNEIE = (1U << 8);  ///< RXNEIE
        constexpr uint32_t RXORDDETIE = (1U << 9);  ///< RXORDDETIE
        constexpr uint32_t RXHRSTDETIE = (1U << 10);  ///< RXHRSTDETIE
        constexpr uint32_t RXOVRIE = (1U << 11);  ///< RXOVRIE
        constexpr uint32_t RXMSGENDIE = (1U << 12);  ///< RXMSGENDIE
        constexpr uint32_t TYPECEVT1IE = (1U << 14);  ///< TYPECEVT1IE
        constexpr uint32_t TYPECEVT2IE = (1U << 15);  ///< TYPECEVT2IE
        constexpr uint32_t FRSEVTIE = (1U << 20);  ///< FRSEVTIE
    }

    /// SR Register bits
    namespace sr_bits {
        constexpr uint32_t TXIS = (1U << 0);  ///< TXIS
        constexpr uint32_t TXMSGDISC = (1U << 1);  ///< TXMSGDISC
        constexpr uint32_t TXMSGSENT = (1U << 2);  ///< TXMSGSENT
        constexpr uint32_t TXMSGABT = (1U << 3);  ///< TXMSGABT
        constexpr uint32_t HRSTDISC = (1U << 4);  ///< HRSTDISC
        constexpr uint32_t HRSTSENT = (1U << 5);  ///< HRSTSENT
        constexpr uint32_t TXUND = (1U << 6);  ///< TXUND
        constexpr uint32_t RXNE = (1U << 8);  ///< RXNE
        constexpr uint32_t RXORDDET = (1U << 9);  ///< RXORDDET
        constexpr uint32_t RXHRSTDET = (1U << 10);  ///< RXHRSTDET
        constexpr uint32_t RXOVR = (1U << 11);  ///< RXOVR
        constexpr uint32_t RXMSGEND = (1U << 12);  ///< RXMSGEND
        constexpr uint32_t RXERR = (1U << 13);  ///< RXERR
        constexpr uint32_t TYPECEVT1 = (1U << 14);  ///< TYPECEVT1
        constexpr uint32_t TYPECEVT2 = (1U << 15);  ///< TYPECEVT2
        constexpr uint32_t TYPEC_VSTATE_CC1 = (2 << 16);  ///< TYPEC_VSTATE_CC1
        constexpr uint32_t TYPEC_VSTATE_CC2 = (2 << 18);  ///< TYPEC_VSTATE_CC2
        constexpr uint32_t FRSEVT = (1U << 20);  ///< FRSEVT
    }

    /// ICR Register bits
    namespace icr_bits {
        constexpr uint32_t TXMSGDISCCF = (1U << 1);  ///< TXMSGDISCCF
        constexpr uint32_t TXMSGSENTCF = (1U << 2);  ///< TXMSGSENTCF
        constexpr uint32_t TXMSGABTCF = (1U << 3);  ///< TXMSGABTCF
        constexpr uint32_t HRSTDISCCF = (1U << 4);  ///< HRSTDISCCF
        constexpr uint32_t HRSTSENTCF = (1U << 5);  ///< HRSTSENTCF
        constexpr uint32_t TXUNDCF = (1U << 6);  ///< TXUNDCF
        constexpr uint32_t RXORDDETCF = (1U << 9);  ///< RXORDDETCF
        constexpr uint32_t RXHRSTDETCF = (1U << 10);  ///< RXHRSTDETCF
        constexpr uint32_t RXOVRCF = (1U << 11);  ///< RXOVRCF
        constexpr uint32_t RXMSGENDCF = (1U << 12);  ///< RXMSGENDCF
        constexpr uint32_t TYPECEVT1CF = (1U << 14);  ///< TYPECEVT1CF
        constexpr uint32_t TYPECEVT2CF = (1U << 15);  ///< TYPECEVT2CF
        constexpr uint32_t FRSEVTCF = (1U << 20);  ///< FRSEVTCF
    }

    /// TX_ORDSET Register bits
    namespace tx_ordset_bits {
        constexpr uint32_t TXORDSET = (20 << 0);  ///< TXORDSET
    }

    /// TX_PAYSZ Register bits
    namespace tx_paysz_bits {
        constexpr uint32_t TXPAYSZ = (10 << 0);  ///< TXPAYSZ
    }

    /// TXDR Register bits
    namespace txdr_bits {
        constexpr uint32_t TXDATA = (8 << 0);  ///< TXDATA
    }

    /// RX_ORDSET Register bits
    namespace rx_ordset_bits {
        constexpr uint32_t RXORDSET = (3 << 0);  ///< RXORDSET
        constexpr uint32_t RXSOP3OF4 = (1U << 3);  ///< RXSOP3OF4
        constexpr uint32_t RXSOPKINVALID = (3 << 4);  ///< RXSOPKINVALID
    }

    /// RX_PAYSZ Register bits
    namespace rx_paysz_bits {
        constexpr uint32_t RXPAYSZ = (10 << 0);  ///< RXPAYSZ
    }

    /// RXDR Register bits
    namespace rxdr_bits {
        constexpr uint32_t RXDATA = (8 << 0);  ///< RXDATA
    }

    /// RX_ORDEXT1 Register bits
    namespace rx_ordext1_bits {
        constexpr uint32_t RXSOPX1 = (20 << 0);  ///< RXSOPX1
    }

    /// RX_ORDEXT2 Register bits
    namespace rx_ordext2_bits {
        constexpr uint32_t RXSOPX2 = (20 << 0);  ///< RXSOPX2
    }

}

// ============================================================================
// VREFBUF Peripheral
// ============================================================================

namespace vrefbuf {
    /// Base addresses
    constexpr uint32_t VREFBUF_BASE = 0x46007400;

    /// VREFBUF Register structure
    struct Registers {
        volatile uint32_t VREFBUF_CSR;  ///< Offset: 0x00 - VREFBUF control and status register
        volatile uint32_t VREFBUF_CCR;  ///< Offset: 0x04 - VREFBUF calibration control register
    };

    /// Peripheral instances
    inline Registers* VREFBUF = reinterpret_cast<Registers*>(VREFBUF_BASE);

    // Bit definitions
    /// VREFBUF_CSR Register bits
    namespace vrefbuf_csr_bits {
        constexpr uint32_t ENVR = (1U << 0);  ///< ENVR
        constexpr uint32_t HIZ = (1U << 1);  ///< HIZ
        constexpr uint32_t VRR = (1U << 3);  ///< VRR
        constexpr uint32_t VRS = (3 << 4);  ///< VRS
    }

    /// VREFBUF_CCR Register bits
    namespace vrefbuf_ccr_bits {
        constexpr uint32_t TRIM = (6 << 0);  ///< TRIM
    }

}

// ============================================================================
// DCB Peripheral
// ============================================================================

namespace dcb {
    /// Base addresses
    constexpr uint32_t DCB_BASE = 0xE000EE08;

    /// DCB Register structure
    struct Registers {
        volatile uint32_t DSCSR;  ///< Offset: 0x00 - Debug Security Control and Status Register
    };

    /// Peripheral instances
    inline Registers* DCB = reinterpret_cast<Registers*>(DCB_BASE);

    // Bit definitions
    /// DSCSR Register bits
    namespace dscsr_bits {
        constexpr uint32_t CDS = (1U << 16);  ///< Current domain Secure
    }

}


} // namespace alloy::generated::stm32u5gx

#endif // ALLOY_GENERATED_STM32U5GX_PERIPHERALS_HPP