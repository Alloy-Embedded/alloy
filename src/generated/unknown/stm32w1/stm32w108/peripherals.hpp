/// Auto-generated code for STM32W108
/// Generated by Alloy Code Generator
/// Source: st_stm32w108.json
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: 2025-10-31 17:45:01
#ifndef ALLOY_GENERATED_STM32W108_PERIPHERALS_HPP
#define ALLOY_GENERATED_STM32W108_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::stm32w108 {

/// Memory map
namespace memory {
    constexpr uint32_t FLASH_BASE = 0x08000000;
    constexpr uint32_t FLASH_SIZE = 64 * 1024;
    constexpr uint32_t RAM_BASE   = 0x20000000;
    constexpr uint32_t RAM_SIZE   = 20 * 1024;
}

// ============================================================================
// MCU Resource Metadata
// ============================================================================

/// MCU capabilities and resource availability
namespace traits {
    // Flash and RAM
    constexpr uint32_t flash_size_kb = 64;
    constexpr uint32_t ram_size_kb = 20;

    // Peripheral availability
    constexpr bool has_tim = true;
    constexpr uint32_t num_tim_instances = 4;
    constexpr bool has_sc1 = true;
    constexpr uint32_t num_sc1_instances = 1;
    constexpr bool has_sc2 = true;
    constexpr uint32_t num_sc2_instances = 1;
    constexpr bool has_adc = true;
    constexpr uint32_t num_adc_instances = 1;
    constexpr bool has_exti = true;
    constexpr uint32_t num_exti_instances = 1;
    constexpr bool has_gpio = true;
    constexpr uint32_t num_gpio_instances = 4;
    constexpr bool has_wdg = true;
    constexpr uint32_t num_wdg_instances = 1;
    constexpr bool has_clk = true;
    constexpr uint32_t num_clk_instances = 1;
    constexpr bool has_rst = true;
    constexpr uint32_t num_rst_instances = 1;
    constexpr bool has_flash = true;
    constexpr uint32_t num_flash_instances = 1;
    constexpr bool has_pwr = true;
    constexpr uint32_t num_pwr_instances = 1;
    constexpr bool has_nvic = true;
    constexpr uint32_t num_nvic_instances = 1;
    constexpr bool has_mem = true;
    constexpr uint32_t num_mem_instances = 1;
    constexpr bool has_dma = true;
    constexpr uint32_t num_dma_instances = 2;
    constexpr bool has_usart = true;
    constexpr uint32_t num_usart_instances = 1;
    constexpr bool has_i2c = true;
    constexpr uint32_t num_i2c_instances = 2;
    constexpr bool has_spi = true;
    constexpr uint32_t num_spi_instances = 2;

    // Helper templates for compile-time validation
    template<typename T>
    struct peripheral_count;

    template<>
    struct peripheral_count<struct tim_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct sc1_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct sc2_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct adc_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct exti_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct gpio_tag> {
        static constexpr uint32_t value = 4;
    };
    template<>
    struct peripheral_count<struct wdg_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct clk_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct rst_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct flash_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct pwr_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct nvic_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct mem_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct dma_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct usart_tag> {
        static constexpr uint32_t value = 1;
    };
    template<>
    struct peripheral_count<struct i2c_tag> {
        static constexpr uint32_t value = 2;
    };
    template<>
    struct peripheral_count<struct spi_tag> {
        static constexpr uint32_t value = 2;
    };

    // GPIO-specific traits
    constexpr uint32_t num_gpio_ports = 4;
    constexpr uint32_t max_gpio_pins = 64;  // 16 pins per port

    // USART-specific traits
    constexpr bool has_sc1_uart = true;
}

// ============================================================================
// TIM Peripheral
// ============================================================================

namespace tim {
    /// Base addresses
    constexpr uint32_t TIM1_BASE = 0x4000A800;
    constexpr uint32_t TIM2_BASE = 0x4000A804;
    constexpr uint32_t SLPTMR_BASE = 0x4000600C;
    constexpr uint32_t MAC_TIM_BASE = 0x40002038;

    /// TIM Register structure
    struct Registers {
        volatile uint32_t TIM1_ISR;  ///< Offset: 0x00 - TIM Interrupt Status Register
        volatile uint32_t TIM1_MISSR;  ///< Offset: 0x18 - TIM interrupt missed register
        volatile uint32_t TIM1_CR1;  ///< Offset: 0x3800 - control register 1
        volatile uint32_t TIM1_IER;  ///< Offset: 0x40 - TIM Interrupt Enable Register
        volatile uint32_t TIM1_CR2;  ///< Offset: 0x3804 - control register 2
        volatile uint32_t TIM1_SMCR;  ///< Offset: 0x3808 - slave Mode Control register
        volatile uint32_t TIM1_EGR;  ///< Offset: 0x3814 - TIM event generation register
        volatile uint32_t TIM1_CCMR1_Input;  ///< Offset: 0x3818 - capture/compare mode register 1 (Input mode)
        volatile uint32_t TIM1_CCMR1_Output;  ///< Offset: 0x3818 - capture/compare mode register 1 (output mode)
        volatile uint32_t TIM1_CCMR2_Input;  ///< Offset: 0x381C - capture/compare mode register 2 (input mode)
        volatile uint32_t TIM1_CCMR2_Output;  ///< Offset: 0x381C - capture/compare mode register 2 (output mode)
        volatile uint32_t TIM1_CCER;  ///< Offset: 0x3820 - TIM capture/compare enable register
        volatile uint32_t TIM1_CNT;  ///< Offset: 0x3824 - TIM counter register
        volatile uint32_t TIM1_PSC;  ///< Offset: 0x3828 - TIM prescaler register
        volatile uint32_t TIM1_ARR;  ///< Offset: 0x382C - TIM auto-reload register
        volatile uint32_t TIM1_CCR1;  ///< Offset: 0x3834 - IM capture/compare register 1
        volatile uint32_t TIM1_CCR2;  ///< Offset: 0x3838 - TIM capture/compare register 2
        volatile uint32_t TIM1_CCR3;  ///< Offset: 0x383C - TIM capture/compare register 3
        volatile uint32_t TIM1_CCR4;  ///< Offset: 0x3840 - TIM capture/compare register 4
        volatile uint32_t TIM1_OR;  ///< Offset: 0x3850 - TIM option register
    };

    /// Peripheral instances
    inline Registers* TIM1 = reinterpret_cast<Registers*>(TIM1_BASE);
    inline Registers* TIM2 = reinterpret_cast<Registers*>(TIM2_BASE);
    inline Registers* SLPTMR = reinterpret_cast<Registers*>(SLPTMR_BASE);
    inline Registers* MAC_TIM = reinterpret_cast<Registers*>(MAC_TIM_BASE);

    // Bit definitions
    /// TIM1_ISR Register bits
    namespace tim1_isr_bits {
        constexpr uint32_t RSVD = (5 << 8);  ///< RSVD
        constexpr uint32_t TIF = (1U << 6);  ///< TIF
        constexpr uint32_t CC4IF = (1U << 4);  ///< CC4IF
        constexpr uint32_t CC3IF = (1U << 3);  ///< CC3IF
        constexpr uint32_t CC2IF = (1U << 2);  ///< CC2IF
        constexpr uint32_t CC1IF = (1U << 1);  ///< CC1IF
        constexpr uint32_t UIF = (1U << 0);  ///< UIF
    }

    /// TIM1_MISSR Register bits
    namespace tim1_missr_bits {
        constexpr uint32_t CC4IM = (1U << 12);  ///< CC4IM
        constexpr uint32_t CC3IM = (1U << 11);  ///< CC3IM
        constexpr uint32_t CC2IM = (1U << 10);  ///< CC2IM
        constexpr uint32_t CC1IM = (1U << 9);  ///< CC1IM
        constexpr uint32_t RSVD = (7 << 0);  ///< RSVD
    }

    /// TIM1_CR1 Register bits
    namespace tim1_cr1_bits {
        constexpr uint32_t ARBE = (1U << 7);  ///< ARBE
        constexpr uint32_t CMS = (2 << 5);  ///< CMS
        constexpr uint32_t DIR = (1U << 4);  ///< DIR
        constexpr uint32_t OPM = (1U << 3);  ///< OPM
        constexpr uint32_t URS = (1U << 2);  ///< URS
        constexpr uint32_t UDIS = (1U << 1);  ///< UDIS
        constexpr uint32_t CEN = (1U << 0);  ///< CEN
    }

    /// TIM1_IER Register bits
    namespace tim1_ier_bits {
        constexpr uint32_t TIE = (1U << 6);  ///< TIE
        constexpr uint32_t CC4IE = (1U << 4);  ///< CC4IE
        constexpr uint32_t CC3IE = (1U << 3);  ///< CC3IE
        constexpr uint32_t CC2IE = (1U << 2);  ///< CC2IE
        constexpr uint32_t CC1IE = (1U << 1);  ///< CC1IE
        constexpr uint32_t UIE = (1U << 0);  ///< UIE
    }

    /// TIM1_CR2 Register bits
    namespace tim1_cr2_bits {
        constexpr uint32_t TI1S = (1U << 7);  ///< TI1S
        constexpr uint32_t MMS = (3 << 4);  ///< MMS
    }

    /// TIM1_SMCR Register bits
    namespace tim1_smcr_bits {
        constexpr uint32_t ETP = (1U << 15);  ///< ETP
        constexpr uint32_t ECE = (1U << 14);  ///< ECE
        constexpr uint32_t ETPS = (2 << 12);  ///< ETPS
        constexpr uint32_t ETF = (4 << 8);  ///< ETF
        constexpr uint32_t MSM = (1U << 7);  ///< MSM
        constexpr uint32_t TS = (3 << 4);  ///< TS
        constexpr uint32_t SMS = (3 << 0);  ///< SMS
    }

    /// TIM1_EGR Register bits
    namespace tim1_egr_bits {
        constexpr uint32_t TG = (1U << 6);  ///< TG
        constexpr uint32_t CC4G = (1U << 4);  ///< CC4G
        constexpr uint32_t CC3G = (1U << 3);  ///< CC3G
        constexpr uint32_t CC2G = (1U << 2);  ///< CC2G
        constexpr uint32_t CC1G = (1U << 1);  ///< CC1G
        constexpr uint32_t UG = (1U << 0);  ///< UG
    }

    /// TIM1_CCMR1_Input Register bits
    namespace tim1_ccmr1_input_bits {
        constexpr uint32_t CC1S = (2 << 0);  ///< CC1S
        constexpr uint32_t IC1PSC = (2 << 2);  ///< IC1PSC
        constexpr uint32_t IC1F = (4 << 4);  ///< IC1F
        constexpr uint32_t CC2S = (2 << 8);  ///< CC2S
        constexpr uint32_t IC2PSC = (2 << 10);  ///< IC2PSC
        constexpr uint32_t IC2F = (4 << 12);  ///< IC2F
    }

    /// TIM1_CCMR1_Output Register bits
    namespace tim1_ccmr1_output_bits {
        constexpr uint32_t OC2M = (3 << 12);  ///< OC2M
        constexpr uint32_t OC2PE = (1U << 11);  ///< OC2PE
        constexpr uint32_t OC2FE = (1U << 10);  ///< OC2FE
        constexpr uint32_t CC2S = (2 << 8);  ///< CC2S
        constexpr uint32_t OC1M = (3 << 4);  ///< OC1M
        constexpr uint32_t OC1PE = (1U << 3);  ///< OC1PE
        constexpr uint32_t OC1FE = (1U << 2);  ///< OC1FE
        constexpr uint32_t CC1S = (2 << 0);  ///< CC1S
    }

    /// TIM1_CCMR2_Input Register bits
    namespace tim1_ccmr2_input_bits {
        constexpr uint32_t CC3S = (2 << 0);  ///< CC3S
        constexpr uint32_t IC3PSC = (2 << 2);  ///< IC3PSC
        constexpr uint32_t IC3F = (4 << 4);  ///< IC3F
        constexpr uint32_t CC4S = (2 << 8);  ///< CC4S
        constexpr uint32_t IC4PSC = (2 << 10);  ///< IC4PSC
        constexpr uint32_t IC4F = (4 << 12);  ///< IC4F
    }

    /// TIM1_CCMR2_Output Register bits
    namespace tim1_ccmr2_output_bits {
        constexpr uint32_t OC4M = (3 << 12);  ///< OC4M
        constexpr uint32_t OC4PE = (1U << 11);  ///< OC4PE
        constexpr uint32_t OC4FE = (1U << 10);  ///< OC4FE
        constexpr uint32_t CC4S = (2 << 8);  ///< CC4S
        constexpr uint32_t OC3M = (3 << 4);  ///< OC3M
        constexpr uint32_t OC3PE = (1U << 3);  ///< OC3PE
        constexpr uint32_t OC3FE = (1U << 2);  ///< OC3FE
        constexpr uint32_t CC3S = (2 << 0);  ///< CC3S
    }

    /// TIM1_CCER Register bits
    namespace tim1_ccer_bits {
        constexpr uint32_t CC4P = (1U << 13);  ///< CC4P
        constexpr uint32_t CC4E = (1U << 12);  ///< CC4E
        constexpr uint32_t CC3P = (1U << 9);  ///< CC3P
        constexpr uint32_t CC3E = (1U << 8);  ///< CC3E
        constexpr uint32_t CC2P = (1U << 5);  ///< CC2P
        constexpr uint32_t CC2E = (1U << 4);  ///< CC2E
        constexpr uint32_t CC1P = (1U << 1);  ///< CC1P
        constexpr uint32_t CC1E = (1U << 0);  ///< CC1E
    }

    /// TIM1_CNT Register bits
    namespace tim1_cnt_bits {
        constexpr uint32_t CNT = (16 << 0);  ///< CNT
    }

    /// TIM1_PSC Register bits
    namespace tim1_psc_bits {
        constexpr uint32_t PSC = (16 << 0);  ///< PSC
    }

    /// TIM1_ARR Register bits
    namespace tim1_arr_bits {
        constexpr uint32_t ARR = (16 << 0);  ///< ARR
    }

    /// TIM1_CCR1 Register bits
    namespace tim1_ccr1_bits {
        constexpr uint32_t CCR = (16 << 0);  ///< CCR
    }

    /// TIM1_CCR2 Register bits
    namespace tim1_ccr2_bits {
        constexpr uint32_t CCR = (16 << 0);  ///< CCR
    }

    /// TIM1_CCR3 Register bits
    namespace tim1_ccr3_bits {
        constexpr uint32_t CCR = (16 << 0);  ///< CCR
    }

    /// TIM1_CCR4 Register bits
    namespace tim1_ccr4_bits {
        constexpr uint32_t CCR = (16 << 0);  ///< CCR
    }

    /// TIM1_OR Register bits
    namespace tim1_or_bits {
        constexpr uint32_t ORRSVD = (1U << 3);  ///< ORRSVD
        constexpr uint32_t CLKMSKEN = (1U << 2);  ///< CLKMSKEN
        constexpr uint32_t EXTRIGSEL = (2 << 0);  ///< EXTRIGSEL
    }

}

// ============================================================================
// SC1 Peripheral
// ============================================================================

namespace sc1 {
    /// Base addresses
    constexpr uint32_t SC1_BASE = 0x4000A808;

    /// SC1 Register structure
    struct Registers {
        volatile uint32_t SC1_ISR;  ///< Offset: 0x00 - Serial controller interrupt status register
        volatile uint32_t SC1_IER;  ///< Offset: 0x40 - Serial controller interrupt enable register
        volatile uint32_t SC1_ICR;  ///< Offset: 0x4C - Serial controller interrupt control register
        volatile uint32_t SC1_DR;  ///< Offset: 0x2034 - Serial control Data register
        volatile uint32_t SC1_CR;  ///< Offset: 0x204C - Serial controller control register
        volatile uint32_t SC1_CRR1;  ///< Offset: 0x2058 - Serial controller clock rate register
        volatile uint32_t SC1_CRR2;  ///< Offset: 0x205C - Serial controller clock rate register 2
    };

    /// Peripheral instances
    inline Registers* SC1 = reinterpret_cast<Registers*>(SC1_BASE);

    // Bit definitions
    /// SC1_ISR Register bits
    namespace sc1_isr_bits {
        constexpr uint32_t PE = (1U << 14);  ///< PE
        constexpr uint32_t FE = (1U << 13);  ///< FE
        constexpr uint32_t TXULODB = (1U << 12);  ///< TXULODB
        constexpr uint32_t TXULODA = (1U << 11);  ///< TXULODA
        constexpr uint32_t RXULODB = (1U << 10);  ///< RXULODB
        constexpr uint32_t RXULODA = (1U << 9);  ///< RXULODA
        constexpr uint32_t NACK = (1U << 8);  ///< NACK
        constexpr uint32_t CMDFIN = (1U << 7);  ///< CMDFIN
        constexpr uint32_t BTF = (1U << 6);  ///< BTF
        constexpr uint32_t BRF = (1U << 5);  ///< BRF
        constexpr uint32_t UDR = (1U << 4);  ///< UDR
        constexpr uint32_t OVR = (1U << 3);  ///< OVR
        constexpr uint32_t IDLE = (1U << 2);  ///< IDLE
        constexpr uint32_t TXE = (1U << 1);  ///< TXE
        constexpr uint32_t RXNE = (1U << 0);  ///< RXNE
    }

    /// SC1_IER Register bits
    namespace sc1_ier_bits {
        constexpr uint32_t PEIE = (1U << 14);  ///< PEIE
        constexpr uint32_t FEIE = (1U << 13);  ///< FEIE
        constexpr uint32_t TXULODBIE = (1U << 12);  ///< TXULODBIE
        constexpr uint32_t TXULODAIE = (1U << 11);  ///< TXULODAIE
        constexpr uint32_t RXULODBIE = (1U << 10);  ///< RXULODBIE
        constexpr uint32_t RXULODAIE = (1U << 9);  ///< RXULODAIE
        constexpr uint32_t NACKIE = (1U << 8);  ///< NACKIE
        constexpr uint32_t CMDFINIE = (1U << 7);  ///< CMDFINIE
        constexpr uint32_t BTFIE = (1U << 6);  ///< BTFIE
        constexpr uint32_t BRFIE = (1U << 5);  ///< BRFIE
        constexpr uint32_t UDRIE = (1U << 4);  ///< UDRIE
        constexpr uint32_t OVRIE = (1U << 3);  ///< OVRIE
        constexpr uint32_t IDLEIE = (1U << 2);  ///< IDLEIE
        constexpr uint32_t TXEIE = (1U << 1);  ///< TXEIE
        constexpr uint32_t RXNEIE = (1U << 0);  ///< RXNEIE
    }

    /// SC1_ICR Register bits
    namespace sc1_icr_bits {
        constexpr uint32_t IDLELEVEL = (1U << 2);  ///< IDLELEVEL
        constexpr uint32_t TXELEVEL = (1U << 1);  ///< TXELEVEL
        constexpr uint32_t RXNELEVEL = (1U << 0);  ///< RXNELEVEL
    }

    /// SC1_DR Register bits
    namespace sc1_dr_bits {
        constexpr uint32_t DR = (8 << 0);  ///< DR
    }

    /// SC1_CR Register bits
    namespace sc1_cr_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< MODE
    }

    /// SC1_CRR1 Register bits
    namespace sc1_crr1_bits {
        constexpr uint32_t LIN = (4 << 0);  ///< LIN
    }

    /// SC1_CRR2 Register bits
    namespace sc1_crr2_bits {
        constexpr uint32_t EXP = (4 << 0);  ///< EXP
    }

}

// ============================================================================
// SC2 Peripheral
// ============================================================================

namespace sc2 {
    /// Base addresses
    constexpr uint32_t SC2_BASE = 0x4000A80C;

    /// SC2 Register structure
    struct Registers {
        volatile uint32_t SC2_ISR;  ///< Offset: 0x00 - Serial controller interrupt status register
        volatile uint32_t SC2_IER;  ///< Offset: 0x40 - Serial controller interrupt enable register
        volatile uint32_t SC2_ICR;  ///< Offset: 0x4C - Serial controller interrupt control register
        volatile uint32_t SC2_DR;  ///< Offset: 0x1830 - Serial controller data register
        volatile uint32_t SC2_CR;  ///< Offset: 0x1848 - Serial controller control register
        volatile uint32_t SC2_CRR1;  ///< Offset: 0x1854 - Serial controller clock rate register 1
        volatile uint32_t SC2_CRR2;  ///< Offset: 0x1858 - Serial controller clock rate register 2
    };

    /// Peripheral instances
    inline Registers* SC2 = reinterpret_cast<Registers*>(SC2_BASE);

    // Bit definitions
    /// SC2_ISR Register bits
    namespace sc2_isr_bits {
        constexpr uint32_t PE = (1U << 14);  ///< PE
        constexpr uint32_t FE = (1U << 13);  ///< FE
        constexpr uint32_t TXULODB = (1U << 12);  ///< TXULODB
        constexpr uint32_t TXULODA = (1U << 11);  ///< TXULODA
        constexpr uint32_t RXULODB = (1U << 10);  ///< RXULODB
        constexpr uint32_t RXULODA = (1U << 9);  ///< RXULODA
        constexpr uint32_t NACK = (1U << 8);  ///< NACK
        constexpr uint32_t CMDFIN = (1U << 7);  ///< CMDFIN
        constexpr uint32_t BTF = (1U << 6);  ///< BTF
        constexpr uint32_t BRF = (1U << 5);  ///< BRF
        constexpr uint32_t UDR = (1U << 4);  ///< UDR
        constexpr uint32_t OVR = (1U << 3);  ///< OVR
        constexpr uint32_t IDLE = (1U << 2);  ///< IDLE
        constexpr uint32_t TXE = (1U << 1);  ///< TXE
        constexpr uint32_t RXNE = (1U << 0);  ///< RXNE
    }

    /// SC2_IER Register bits
    namespace sc2_ier_bits {
        constexpr uint32_t PEIE = (1U << 14);  ///< PEIE
        constexpr uint32_t FEIE = (1U << 13);  ///< FEIE
        constexpr uint32_t TXULODBIE = (1U << 12);  ///< TXULODBIE
        constexpr uint32_t TXULODAIE = (1U << 11);  ///< TXULODAIE
        constexpr uint32_t RXULODBIE = (1U << 10);  ///< RXULODBIE
        constexpr uint32_t RXULODAIE = (1U << 9);  ///< RXULODAIE
        constexpr uint32_t NACKIE = (1U << 8);  ///< NACKIE
        constexpr uint32_t CMDFINIE = (1U << 7);  ///< CMDFINIE
        constexpr uint32_t BTFIE = (1U << 6);  ///< BTFIE
        constexpr uint32_t BRFIE = (1U << 5);  ///< BRFIE
        constexpr uint32_t UDRIE = (1U << 4);  ///< UDRIE
        constexpr uint32_t OVRIE = (1U << 3);  ///< OVRIE
        constexpr uint32_t IDLEIE = (1U << 2);  ///< IDLEIE
        constexpr uint32_t TXEIE = (1U << 1);  ///< TXEIE
        constexpr uint32_t RXNEIE = (1U << 0);  ///< RXNEIE
    }

    /// SC2_ICR Register bits
    namespace sc2_icr_bits {
        constexpr uint32_t IDLELEVEL = (1U << 2);  ///< IDLELEVEL
        constexpr uint32_t TXELEVEL = (1U << 1);  ///< TXELEVEL
        constexpr uint32_t RXNELEVEL = (1U << 0);  ///< RXNELEVEL
    }

    /// SC2_DR Register bits
    namespace sc2_dr_bits {
        constexpr uint32_t DR = (8 << 0);  ///< DR
    }

    /// SC2_CR Register bits
    namespace sc2_cr_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< MODE
    }

    /// SC2_CRR1 Register bits
    namespace sc2_crr1_bits {
        constexpr uint32_t LIN = (4 << 0);  ///< LIN
    }

    /// SC2_CRR2 Register bits
    namespace sc2_crr2_bits {
        constexpr uint32_t EXP = (4 << 0);  ///< EXP
    }

}

// ============================================================================
// ADC Peripheral
// ============================================================================

namespace adc {
    /// Base addresses
    constexpr uint32_t ADC_BASE = 0x4000A810;

    /// ADC Register structure
    struct Registers {
        volatile uint32_t ADC_ISR;  ///< Offset: 0x00 - ADC interrupt status register
        volatile uint32_t ADC_IER;  ///< Offset: 0x40 - ADC interrupt enable register
        volatile uint32_t ADC_CR;  ///< Offset: 0x27F4 - ADC control register
        volatile uint32_t ADC_OFFSETR;  ///< Offset: 0x27F8 - ADC offset register
        volatile uint32_t ADC_GAINR;  ///< Offset: 0x27FC - ADC gain register
        volatile uint32_t ADC_DMACR;  ///< Offset: 0x2800 - ADC DMA control register
        volatile uint32_t ADC_DMASR;  ///< Offset: 0x2804 - ADC DMA status register
        volatile uint32_t ADC_DMAMSAR;  ///< Offset: 0x2808 - ADC DMA memory start address register
        volatile uint32_t ADC_DMANDTR;  ///< Offset: 0x280C - ADC DMA number of data to transfer register
        volatile uint32_t ADC_DMAMNAR;  ///< Offset: 0x2810 - ADC DMA memory next address register
        volatile uint32_t ADC_DMACNDTR;  ///< Offset: 0x2814 - ADC DMA count number of data transferred register
    };

    /// Peripheral instances
    inline Registers* ADC = reinterpret_cast<Registers*>(ADC_BASE);

    // Bit definitions
    /// ADC_ISR Register bits
    namespace adc_isr_bits {
        constexpr uint32_t DMAOVF = (1U << 4);  ///< DMAOVF
        constexpr uint32_t SAT = (1U << 3);  ///< SAT
        constexpr uint32_t DMABF = (1U << 2);  ///< DMABF
        constexpr uint32_t DMABHF = (1U << 1);  ///< DMABHF
    }

    /// ADC_IER Register bits
    namespace adc_ier_bits {
        constexpr uint32_t DMAOVFIE = (1U << 4);  ///< DMAOVFIE
        constexpr uint32_t SATIE = (1U << 3);  ///< SATIE
        constexpr uint32_t DMABFIE = (1U << 2);  ///< DMABFIE
        constexpr uint32_t DMABHFIE = (1U << 1);  ///< DMABHFIE
    }

    /// ADC_CR Register bits
    namespace adc_cr_bits {
        constexpr uint32_t SMP = (3 << 13);  ///< SMP
        constexpr uint32_t HVSELP = (1U << 12);  ///< HVSELP
        constexpr uint32_t HVSELN = (1U << 11);  ///< HVSELN
        constexpr uint32_t CHSELP = (4 << 7);  ///< CHSELP
        constexpr uint32_t CHSELN = (4 << 3);  ///< CHSELN
        constexpr uint32_t CLK = (1U << 2);  ///< CLK
        constexpr uint32_t ADON = (1U << 0);  ///< ADON
    }

    /// ADC_OFFSETR Register bits
    namespace adc_offsetr_bits {
        constexpr uint32_t OFFSET = (16 << 0);  ///< OFFSET
    }

    /// ADC_GAINR Register bits
    namespace adc_gainr_bits {
        constexpr uint32_t GAIN = (16 << 0);  ///< GAIN
    }

    /// ADC_DMACR Register bits
    namespace adc_dmacr_bits {
        constexpr uint32_t RST = (1U << 4);  ///< Write 1 to reset the ADC DMA
        constexpr uint32_t AUTOWRAP = (1U << 1);  ///< Selects DMA mode
        constexpr uint32_t LOAD = (1U << 0);  ///< Loads the DMA buffer
    }

    /// ADC_DMASR Register bits
    namespace adc_dmasr_bits {
        constexpr uint32_t AOVF = (1U << 1);  ///< AOVF
        constexpr uint32_t ACT = (1U << 0);  ///< ACT
    }

    /// ADC_DMAMSAR Register bits
    namespace adc_dmamsar_bits {
        constexpr uint32_t MSA = (13 << 0);  ///< MSA
    }

    /// ADC_DMANDTR Register bits
    namespace adc_dmandtr_bits {
        constexpr uint32_t NDT = (13 << 0);  ///< NDT
    }

    /// ADC_DMAMNAR Register bits
    namespace adc_dmamnar_bits {
        constexpr uint32_t MNA = (13 << 1);  ///< MNA
    }

    /// ADC_DMACNDTR Register bits
    namespace adc_dmacndtr_bits {
        constexpr uint32_t CNDT = (13 << 0);  ///< CNDT
    }

}

// ============================================================================
// EXTI Peripheral
// ============================================================================

namespace exti {
    /// Base addresses
    constexpr uint32_t EXTI_BASE = 0x4000A814;

    /// EXTI Register structure
    struct Registers {
        volatile uint32_t EXTI_PR;  ///< Offset: 0x00 - EXTI pending register
        volatile uint32_t EXTIA_TSR;  ///< Offset: 0x4C - EXTIA trigger source register
        volatile uint32_t EXTIB_TSR;  ///< Offset: 0x50 - EXTIB trigger source register
        volatile uint32_t EXTIC_TSR;  ///< Offset: 0x54 - EXTIC trigger source register
        volatile uint32_t EXTIC_CR;  ///< Offset: 0x1400 - EXTIC configuration register
        volatile uint32_t EXTID_TSR;  ///< Offset: 0x58 - EXTID trigger source register
        volatile uint32_t EXTID_CR;  ///< Offset: 0x1404 - EXTID configuration register
    };

    /// Peripheral instances
    inline Registers* EXTI = reinterpret_cast<Registers*>(EXTI_BASE);

    // Bit definitions
    /// EXTIA_TSR Register bits
    namespace extia_tsr_bits {
        constexpr uint32_t FILTEN = (1U << 8);  ///< FILTEN
        constexpr uint32_t INTMOD = (3 << 5);  ///< INTMOD
    }

    /// EXTIB_TSR Register bits
    namespace extib_tsr_bits {
        constexpr uint32_t FILTEN = (1U << 8);  ///< FILTEN
        constexpr uint32_t INTMOD = (3 << 5);  ///< INTMOD
    }

    /// EXTIC_TSR Register bits
    namespace extic_tsr_bits {
        constexpr uint32_t FILTEN = (1U << 8);  ///< FILTEN
        constexpr uint32_t INTMOD = (3 << 5);  ///< INTMOD
    }

    /// EXTIC_CR Register bits
    namespace extic_cr_bits {
        constexpr uint32_t GPIO_SEL = (5 << 0);  ///< GPIO_SEL
    }

    /// EXTID_TSR Register bits
    namespace extid_tsr_bits {
        constexpr uint32_t FILTEN = (1U << 8);  ///< FILTEN
        constexpr uint32_t INTMOD = (3 << 5);  ///< INTMOD
    }

    /// EXTID_CR Register bits
    namespace extid_cr_bits {
        constexpr uint32_t GPIO_SEL = (5 << 0);  ///< GPIO_SEL
    }

}

// ============================================================================
// GPIO Peripheral
// ============================================================================

namespace gpio {
    /// Base addresses
    constexpr uint32_t GPIOA_BASE = 0x4000B000;
    constexpr uint32_t GPIOB_BASE = 0x4000B400;
    constexpr uint32_t GPIOC_BASE = 0x4000B800;
    constexpr uint32_t GPIO_DBG_BASE = 0x40004028;

    /// GPIO Register structure
    struct Registers {
        volatile uint32_t GPIOA_CRL;  ///< Offset: 0x00 - Port A configuration register (Low)
        volatile uint32_t GPIOA_CRH;  ///< Offset: 0x04 - Port A configuration register (High)
        volatile uint32_t GPIOA_IDR;  ///< Offset: 0x08 - Port A input data register
        volatile uint32_t GPIOA_ODR;  ///< Offset: 0x0C - Port A output data register
        volatile uint32_t GPIOA_BSR;  ///< Offset: 0x10 - Port A bit set register
        volatile uint32_t GPIOA_BRR;  ///< Offset: 0x14 - Port A output clear register
    };

    /// Peripheral instances
    inline Registers* GPIOA = reinterpret_cast<Registers*>(GPIOA_BASE);
    inline Registers* GPIOB = reinterpret_cast<Registers*>(GPIOB_BASE);
    inline Registers* GPIOC = reinterpret_cast<Registers*>(GPIOC_BASE);
    inline Registers* GPIO_DBG = reinterpret_cast<Registers*>(GPIO_DBG_BASE);

    // Bit definitions
    /// GPIOA_CRL Register bits
    namespace gpioa_crl_bits {
        constexpr uint32_t CNFMODE3 = (4 << 12);  ///< CNFMODE3
        constexpr uint32_t CNFMODE2 = (4 << 8);  ///< CNFMODE2
        constexpr uint32_t CNFMODE1 = (4 << 4);  ///< CNFMODE1
        constexpr uint32_t CNFMODE0 = (4 << 0);  ///< CNFMODE0
    }

    /// GPIOA_CRH Register bits
    namespace gpioa_crh_bits {
        constexpr uint32_t CNFMODE7 = (4 << 12);  ///< CNFMODE7
        constexpr uint32_t CNFMODE6 = (4 << 8);  ///< CNFMODE6
        constexpr uint32_t CNFMODE5 = (4 << 4);  ///< CNFMODE5
        constexpr uint32_t CNFMODE4 = (4 << 0);  ///< CNFMODE4
    }

    /// GPIOA_IDR Register bits
    namespace gpioa_idr_bits {
        constexpr uint32_t IDR7 = (1U << 7);  ///< IDR7
        constexpr uint32_t IDR6 = (1U << 6);  ///< IDR6
        constexpr uint32_t IDR5 = (1U << 5);  ///< IDR5
        constexpr uint32_t IDR4 = (1U << 4);  ///< IDR4
        constexpr uint32_t IDR3 = (1U << 3);  ///< IDR3
        constexpr uint32_t IDR2 = (1U << 2);  ///< IDR2
        constexpr uint32_t IDR1 = (1U << 1);  ///< IDR1
        constexpr uint32_t IDR0 = (1U << 0);  ///< IDR0
    }

    /// GPIOA_ODR Register bits
    namespace gpioa_odr_bits {
        constexpr uint32_t ODR7 = (1U << 7);  ///< ODR7
        constexpr uint32_t ODR6 = (1U << 6);  ///< ODR6
        constexpr uint32_t ODR5 = (1U << 5);  ///< ODR5
        constexpr uint32_t ODR4 = (1U << 4);  ///< ODR4
        constexpr uint32_t ODR3 = (1U << 3);  ///< ODR3
        constexpr uint32_t ODR2 = (1U << 2);  ///< ODR2
        constexpr uint32_t ODR1 = (1U << 1);  ///< ODR1
        constexpr uint32_t ODR0 = (1U << 0);  ///< ODR0
    }

    /// GPIOA_BSR Register bits
    namespace gpioa_bsr_bits {
        constexpr uint32_t BS7 = (1U << 7);  ///< BS7
        constexpr uint32_t BS6 = (1U << 6);  ///< BS6
        constexpr uint32_t BS5 = (1U << 5);  ///< BS5
        constexpr uint32_t BS4 = (1U << 4);  ///< BS4
        constexpr uint32_t BS3 = (1U << 3);  ///< BS3
        constexpr uint32_t BS2 = (1U << 2);  ///< BS2
        constexpr uint32_t BS1 = (1U << 1);  ///< BS1
        constexpr uint32_t BS0 = (1U << 0);  ///< BS0
    }

    /// GPIOA_BRR Register bits
    namespace gpioa_brr_bits {
        constexpr uint32_t BR7 = (1U << 7);  ///< BR7
        constexpr uint32_t BR6 = (1U << 6);  ///< BR6
        constexpr uint32_t BR5 = (1U << 5);  ///< BR5
        constexpr uint32_t BR4 = (1U << 4);  ///< BR4
        constexpr uint32_t BR3 = (1U << 3);  ///< BR3
        constexpr uint32_t BR2 = (1U << 2);  ///< BR2
        constexpr uint32_t BR1 = (1U << 1);  ///< BR1
        constexpr uint32_t BR0 = (1U << 0);  ///< BR0
    }

}

// ============================================================================
// WDG Peripheral
// ============================================================================

namespace wdg {
    /// Base addresses
    constexpr uint32_t WDG_BASE = 0x40006000;

    /// WDG Register structure
    struct Registers {
        volatile uint32_t WDG_CR;  ///< Offset: 0x00 - WDG configuration register
        volatile uint32_t WDG_KR;  ///< Offset: 0x04 - WDG key register
        volatile uint32_t WDG_KICKSR;  ///< Offset: 0x08 - WDG kick-start register
    };

    /// Peripheral instances
    inline Registers* WDG = reinterpret_cast<Registers*>(WDG_BASE);

    // Bit definitions
    /// WDG_CR Register bits
    namespace wdg_cr_bits {
        constexpr uint32_t WDGDIS = (1U << 1);  ///< WDGDIS
        constexpr uint32_t WDGEN = (1U << 0);  ///< WDGEN
    }

    /// WDG_KR Register bits
    namespace wdg_kr_bits {
        constexpr uint32_t KEY = (16 << 0);  ///< KEY
    }

    /// WDG_KICKSR Register bits
    namespace wdg_kicksr_bits {
        constexpr uint32_t KS = (16 << 0);  ///< KS
    }

}

// ============================================================================
// CLK Peripheral
// ============================================================================

namespace clk {
    /// Base addresses
    constexpr uint32_t CLK_BASE = 0x40000008;

    /// CLK Register structure
    struct Registers {
        volatile uint32_t CLK_SLEEPCR;  ///< Offset: 0x00 - Sleep timer control register
        volatile uint32_t CLK_LSI10KCR;  ///< Offset: 0x04 - LSI Clock (10KHz) control register
        volatile uint32_t CLK_LSI1KCR;  ///< Offset: 0x08 - LSI Clock (1KHz) control register
        volatile uint32_t CLK_HSECR1;  ///< Offset: 0x3FFC - HSE Clock (24MHz) control register 1
        volatile uint32_t CLK_HSICR;  ///< Offset: 0x4000 - HSI Clock (12MHz) trim register
        volatile uint32_t CLK_PERIODCR;  ///< Offset: 0x4008 - Clock period control register
        volatile uint32_t CLK_PERIODSR;  ///< Offset: 0x400C - Clock period status register
        volatile uint32_t CLK_DITHERCR;  ///< Offset: 0x4010 - Clock dither control register
        volatile uint32_t CLK_HSECR2;  ///< Offset: 0x4014 - HSE Clock (24MHz) control register 2
        volatile uint32_t CLK_CPUCR;  ///< Offset: 0x4018 - Clock source select register
    };

    /// Peripheral instances
    inline Registers* CLK = reinterpret_cast<Registers*>(CLK_BASE);

    // Bit definitions
    /// CLK_SLEEPCR Register bits
    namespace clk_sleepcr_bits {
        constexpr uint32_t LSEEN = (1U << 0);  ///< Enables 32kHz external XTAL
        constexpr uint32_t LSI10KEN = (1U << 1);  ///< Enables 10kHz internal RC during deep
    }

    /// CLK_LSI10KCR Register bits
    namespace clk_lsi10kcr_bits {
        constexpr uint32_t TUNE = (4 << 0);  ///< Tune value for clkrc
    }

    /// CLK_LSI1KCR Register bits
    namespace clk_lsi1kcr_bits {
        constexpr uint32_t CLKFRAC = (11 << 0);  ///< Divider value fractional portion
        constexpr uint32_t CALINT = (15 << 11);  ///< Divider value integer portion
    }

    /// CLK_HSECR1 Register bits
    namespace clk_hsecr1_bits {
        constexpr uint32_t BIASTRIM = (4 << 0);  ///< Bias trim setting for 24MHz oscillator
    }

    /// CLK_HSICR Register bits
    namespace clk_hsicr_bits {
        constexpr uint32_t TUNE = (5 << 0);  ///< Frequency trim setting for HF RC oscillator
    }

    /// CLK_PERIODCR Register bits
    namespace clk_periodcr_bits {
        constexpr uint32_t MODE = (2 << 0);  ///< Sets clock to be measured by CLK_PERIOD
    }

    /// CLK_PERIODSR Register bits
    namespace clk_periodsr_bits {
        constexpr uint32_t PERIOD = (16 << 0);  ///< Clock period measurement
    }

    /// CLK_DITHERCR Register bits
    namespace clk_dithercr_bits {
        constexpr uint32_t DIS = (1U << 0);  ///< Dither disable
    }

    /// CLK_HSECR2 Register bits
    namespace clk_hsecr2_bits {
        constexpr uint32_t SW1 = (1U << 0);  ///< OSCHF/XTAL is selected
        constexpr uint32_t EN = (1U << 1);  ///< MHz crystal oscillator is main clock
    }

    /// CLK_CPUCR Register bits
    namespace clk_cpucr_bits {
        constexpr uint32_t SW2 = (1U << 0);  ///< 12MHz/24MHz is selected
    }

}

// ============================================================================
// RST Peripheral
// ============================================================================

namespace rst {
    /// Base addresses
    constexpr uint32_t RST_BASE = 0x4000002C;

    /// RST Register structure
    struct Registers {
        volatile uint32_t RST_SR;  ///< Offset: 0x00 - Reset Status Register
    };

    /// Peripheral instances
    inline Registers* RST = reinterpret_cast<Registers*>(RST_BASE);

    // Bit definitions
    /// RST_SR Register bits
    namespace rst_sr_bits {
        constexpr uint32_t LKUP = (1U << 7);  ///< LKUP
        constexpr uint32_t OBFAIL = (1U << 6);  ///< OBFAIL
        constexpr uint32_t WKUP = (1U << 5);  ///< WKUP
        constexpr uint32_t SWRST = (1U << 4);  ///< SWRST
        constexpr uint32_t WDG = (1U << 3);  ///< WDG
        constexpr uint32_t PIN = (1U << 2);  ///< PIN
        constexpr uint32_t PWRLV = (1U << 1);  ///< PWRLV
        constexpr uint32_t PWRHV = (1U << 0);  ///< PWRHV
    }

}

// ============================================================================
// FLASH Peripheral
// ============================================================================

namespace flash {
    /// Base addresses
    constexpr uint32_t FLASH_BASE = 0x4000402C;

    /// FLASH Register structure
    struct Registers {
        volatile uint32_t FLASH_ACR;  ///< Offset: 0x3FD4 - FLASH access control register
        volatile uint32_t FLASH_KEYR;  ///< Offset: 0x3FD8 - FLASH key register
        volatile uint32_t FLASH_OPTKEYR;  ///< Offset: 0x3FDC - FLASH OPT key register
        volatile uint32_t FLASH_SR;  ///< Offset: 0x3FE0 - FLASH status register
        volatile uint32_t FLASH_CR;  ///< Offset: 0x3FE4 - FLASH control register
        volatile uint32_t FLASH_AR;  ///< Offset: 0x3FE8 - FLASH address register
        volatile uint32_t FLASH_OBR;  ///< Offset: 0x3FF0 - FLASH option bytes register
        volatile uint32_t FLASH_WRPR;  ///< Offset: 0x3FF4 - FLASH write protection register
        volatile uint32_t FLASH_CLKER;  ///< Offset: 0x00 - FLASH controller clock enable register
        volatile uint32_t FLASH_CLKSR;  ///< Offset: 0x04 - FLASH controller clock status register
    };

    /// Peripheral instances
    inline Registers* FLASH = reinterpret_cast<Registers*>(FLASH_BASE);

    // Bit definitions
    /// FLASH_ACR Register bits
    namespace flash_acr_bits {
        constexpr uint32_t PRFTBS = (1U << 5);  ///< Prefetch Status
        constexpr uint32_t PRFTBE = (1U << 4);  ///< PRFTBE
        constexpr uint32_t HLFCYA = (1U << 3);  ///< HLFCYA
        constexpr uint32_t LATENCY = (3 << 0);  ///< LATENCY
    }

    /// FLASH_KEYR Register bits
    namespace flash_keyr_bits {
        constexpr uint32_t FKEYR = (32 << 0);  ///< FKEYR
    }

    /// FLASH_OPTKEYR Register bits
    namespace flash_optkeyr_bits {
        constexpr uint32_t OPTKEYR = (32 << 0);  ///< OPTKEYR
    }

    /// FLASH_SR Register bits
    namespace flash_sr_bits {
        constexpr uint32_t EOP = (1U << 5);  ///< EOP
        constexpr uint32_t WRPRTERR = (1U << 4);  ///< WRPRTERR
        constexpr uint32_t PGERR = (1U << 2);  ///< PGERR
        constexpr uint32_t BSY = (1U << 0);  ///< BSY
    }

    /// FLASH_CR Register bits
    namespace flash_cr_bits {
        constexpr uint32_t EOPIE = (1U << 12);  ///< EOPIE
        constexpr uint32_t ERRIE = (1U << 10);  ///< ERRIE
        constexpr uint32_t OPTWRE = (1U << 9);  ///< OPTWRE
        constexpr uint32_t LOCK = (1U << 7);  ///< LOCK
        constexpr uint32_t STRT = (1U << 6);  ///< STRT
        constexpr uint32_t OPTER = (1U << 5);  ///< OPTER
        constexpr uint32_t OPTPG = (1U << 4);  ///< OPTPG
        constexpr uint32_t MER = (1U << 2);  ///< MER
        constexpr uint32_t PER = (1U << 1);  ///< PER
        constexpr uint32_t PG = (1U << 0);  ///< PG
    }

    /// FLASH_AR Register bits
    namespace flash_ar_bits {
        constexpr uint32_t FAR = (32 << 0);  ///< FAR
    }

    /// FLASH_OBR Register bits
    namespace flash_obr_bits {
        constexpr uint32_t RDPRT = (1U << 1);  ///< RDPRT
        constexpr uint32_t OPTERR = (1U << 0);  ///< OPTERR
    }

    /// FLASH_WRPR Register bits
    namespace flash_wrpr_bits {
        constexpr uint32_t WRP = (32 << 0);  ///< WRP
    }

    /// FLASH_CLKER Register bits
    namespace flash_clker_bits {
        constexpr uint32_t EN = (1U << 0);  ///< EN
    }

    /// FLASH_CLKSR Register bits
    namespace flash_clksr_bits {
        constexpr uint32_t BSY = (1U << 1);  ///< BSY
        constexpr uint32_t ACK = (1U << 0);  ///< ACK
    }

}

// ============================================================================
// PWR Peripheral
// ============================================================================

namespace pwr {
    /// Base addresses
    constexpr uint32_t PWR_BASE = 0x40000004;

    /// PWR Register structure
    struct Registers {
        volatile uint32_t PWR_DSLEEPCR1;  ///< Offset: 0x00 - PWR_DSLEEPCR1
        volatile uint32_t PWR_DSLEEPCR2;  ///< Offset: 0x10 - PWR_DSLEEPCR2
        volatile uint32_t PWR_VREGCR;  ///< Offset: 0x14 - Voltage regulator Control register
        volatile uint32_t PWR_WAKECR1;  ///< Offset: 0x1C - PWR_WAKECR1
        volatile uint32_t PWR_WAKECR2;  ///< Offset: 0x20 - PWR_WAKECR2
        volatile uint32_t PWR_WAKESR;  ///< Offset: 0x24 - PWR_WAKESR
        volatile uint32_t PWR_CPWRUPREQSR;  ///< Offset: 0x30 - PWR_CPWRUPREQSR
        volatile uint32_t PWR_CSYSPWRUPREQSR;  ///< Offset: 0x34 - PWR_CSYSPWRUPREQSR
        volatile uint32_t PWR_CSYSPWRUPACKSR;  ///< Offset: 0x38 - PWR_CSYSPWRUPACKSR
        volatile uint32_t PWR_CSYSPWRUPACKCR;  ///< Offset: 0x3C - PWR_CSYSPWRUPACKCR
        volatile uint32_t PWR_WAKEPAR;  ///< Offset: 0xBC04 - Wake GPIO Port A register
        volatile uint32_t PWR_WAKEPBR;  ///< Offset: 0xBC08 - Wake GPIO Port B register
        volatile uint32_t PWR_WAKEPCR;  ///< Offset: 0xBC0C - Wake GPIO Port C register
        volatile uint32_t PWR_WAKEFILTR;  ///< Offset: 0xBC18 - Wake filter register
    };

    /// Peripheral instances
    inline Registers* PWR = reinterpret_cast<Registers*>(PWR_BASE);

    // Bit definitions
    /// PWR_DSLEEPCR1 Register bits
    namespace pwr_dsleepcr1_bits {
        constexpr uint32_t PWR_CSYSPWRUPACKCR = (1U << 1);  ///< PWR_CSYSPWRUPACKCR
    }

    /// PWR_DSLEEPCR2 Register bits
    namespace pwr_dsleepcr2_bits {
        constexpr uint32_t MODE = (1U << 0);  ///< MODE
    }

    /// PWR_VREGCR Register bits
    namespace pwr_vregcr_bits {
        constexpr uint32_t PWR_VREGCR_1V2TRIM = (3 << 0);  ///< 1V2 regulator trim value
        constexpr uint32_t PWR_VREGCR_1V2EN = (1U << 4);  ///< 1V2 direct controle of regulator on/off
        constexpr uint32_t PWR_VREGCR_1V8TRIM = (3 << 7);  ///< 1V8 regulator trim value
        constexpr uint32_t PWR_VREGCR_1V8EN = (1U << 11);  ///< 1V8 direct controle of regulator on/off
        constexpr uint32_t PWR_VREGCR_VREFEN = (1U << 15);  ///< VREF on/off
    }

    /// PWR_WAKECR1 Register bits
    namespace pwr_wakecr1_bits {
        constexpr uint32_t WAKEEN = (1U << 0);  ///< WAKEEN
        constexpr uint32_t SC1 = (1U << 1);  ///< SC1
        constexpr uint32_t SC2 = (1U << 2);  ///< SC2
        constexpr uint32_t IRQD = (1U << 3);  ///< IRQD
        constexpr uint32_t COMPA = (1U << 4);  ///< COMPA
        constexpr uint32_t COMPB = (1U << 5);  ///< COMPB
        constexpr uint32_t WRAP = (1U << 6);  ///< WRAP
        constexpr uint32_t CORE = (1U << 7);  ///< CORE
        constexpr uint32_t CPWRRUPREQ = (1U << 8);  ///< CPWRRUPREQ
        constexpr uint32_t CSYSPWRUPREQ = (1U << 9);  ///< CSYSPWRUPREQ
    }

    /// PWR_WAKECR2 Register bits
    namespace pwr_wakecr2_bits {
        constexpr uint32_t COREWAKE = (1U << 5);  ///< COREWAKE
    }

    /// PWR_WAKESR Register bits
    namespace pwr_wakesr_bits {
        constexpr uint32_t GPIOPIN = (1U << 0);  ///< GPIOPIN
        constexpr uint32_t SC1 = (1U << 1);  ///< SC1
        constexpr uint32_t SC2 = (1U << 2);  ///< SC2
        constexpr uint32_t IRQD = (1U << 3);  ///< IRQD
        constexpr uint32_t COMPA = (1U << 4);  ///< COMPA
        constexpr uint32_t COMPB = (1U << 5);  ///< COMPB
        constexpr uint32_t WRAP = (1U << 6);  ///< WRAP
        constexpr uint32_t CORE = (1U << 7);  ///< CORE
        constexpr uint32_t CPWRRUPREQ = (1U << 8);  ///< CPWRRUPREQ
        constexpr uint32_t CSYSPWRUPREQ = (1U << 9);  ///< CSYSPWRUPREQ
    }

    /// PWR_CPWRUPREQSR Register bits
    namespace pwr_cpwrupreqsr_bits {
        constexpr uint32_t REQ = (1U << 0);  ///< REQ
    }

    /// PWR_CSYSPWRUPREQSR Register bits
    namespace pwr_csyspwrupreqsr_bits {
        constexpr uint32_t REQ = (1U << 0);  ///< REQ
    }

    /// PWR_CSYSPWRUPACKSR Register bits
    namespace pwr_csyspwrupacksr_bits {
        constexpr uint32_t ACK = (1U << 0);  ///< ACK
    }

    /// PWR_CSYSPWRUPACKCR Register bits
    namespace pwr_csyspwrupackcr_bits {
        constexpr uint32_t INHIBIT = (1U << 0);  ///< INHIBIT
    }

    /// PWR_WAKEPAR Register bits
    namespace pwr_wakepar_bits {
        constexpr uint32_t PA0 = (1U << 0);  ///< PA0
        constexpr uint32_t PA1 = (1U << 1);  ///< PA1
        constexpr uint32_t PA2 = (1U << 2);  ///< PA2
        constexpr uint32_t PA3 = (1U << 3);  ///< PA3
        constexpr uint32_t PA4 = (1U << 4);  ///< PA4
        constexpr uint32_t PA5 = (1U << 5);  ///< PA5
        constexpr uint32_t PA6 = (1U << 6);  ///< PA6
        constexpr uint32_t PA7 = (1U << 7);  ///< PA7
    }

    /// PWR_WAKEPBR Register bits
    namespace pwr_wakepbr_bits {
        constexpr uint32_t PB0 = (1U << 0);  ///< PB0
        constexpr uint32_t PB1 = (1U << 1);  ///< PB1
        constexpr uint32_t PB2 = (1U << 2);  ///< PB2
        constexpr uint32_t PB3 = (1U << 3);  ///< PB3
        constexpr uint32_t PB4 = (1U << 4);  ///< PB4
        constexpr uint32_t PB5 = (1U << 5);  ///< PB5
        constexpr uint32_t PB6 = (1U << 6);  ///< PB6
        constexpr uint32_t PB7 = (1U << 7);  ///< PB7
    }

    /// PWR_WAKEPCR Register bits
    namespace pwr_wakepcr_bits {
        constexpr uint32_t PC0 = (1U << 0);  ///< PC0
        constexpr uint32_t PC1 = (1U << 1);  ///< PC1
        constexpr uint32_t PC2 = (1U << 2);  ///< PC2
        constexpr uint32_t PC3 = (1U << 3);  ///< PC3
        constexpr uint32_t PC4 = (1U << 4);  ///< PC4
        constexpr uint32_t PC5 = (1U << 5);  ///< PC5
        constexpr uint32_t PC6 = (1U << 6);  ///< PC6
        constexpr uint32_t PC7 = (1U << 7);  ///< PC7
    }

    /// PWR_WAKEFILTR Register bits
    namespace pwr_wakefiltr_bits {
        constexpr uint32_t GPIO = (1U << 0);  ///< Enable filter on GPIO wakeup sources enabled by the PWR_WAKEPxR registers
        constexpr uint32_t SC1 = (1U << 1);  ///< Enable filter on GPIO wakeup source SC1 (PB2)
        constexpr uint32_t SC2 = (1U << 2);  ///< Enable filter on GPIO wakeup source SC2 (PA2)
        constexpr uint32_t IRQD = (1U << 3);  ///< Enable filter on GPIO wakeup source EXTI D
    }

}

// ============================================================================
// NVIC Peripheral
// ============================================================================

namespace nvic {
    /// Base addresses
    constexpr uint32_t NVIC_BASE = 0xE000E000;

    /// NVIC Register structure
    struct Registers {
        volatile uint32_t ICTR;  ///< Offset: 0x04 - Interrupt Controller Type Register
        volatile uint32_t STIR;  ///< Offset: 0xF00 - Software Triggered Interrupt Register
        volatile uint32_t ISER0;  ///< Offset: 0x100 - Interrupt Set-Enable Register
        volatile uint32_t ICER0;  ///< Offset: 0x180 - Interrupt Clear-Enable Register
        volatile uint32_t ISPR0;  ///< Offset: 0x200 - Interrupt Set-Pending Register
        volatile uint32_t ICPR0;  ///< Offset: 0x280 - Interrupt Clear-Pending Register
        volatile uint32_t IABR0;  ///< Offset: 0x300 - Interrupt Active Bit Register
        volatile uint32_t IPR0;  ///< Offset: 0x400 - Interrupt Priority Register
        volatile uint32_t IPR1;  ///< Offset: 0x404 - Interrupt Priority Register
        volatile uint32_t IPR2;  ///< Offset: 0x408 - Interrupt Priority Register
        volatile uint32_t IPR3;  ///< Offset: 0x40C - Interrupt Priority Register
        volatile uint32_t IPR4;  ///< Offset: 0x410 - Interrupt Priority Register
    };

    /// Peripheral instances
    inline Registers* NVIC = reinterpret_cast<Registers*>(NVIC_BASE);

    // Bit definitions
    /// ICTR Register bits
    namespace ictr_bits {
        constexpr uint32_t INTLINESNUM = (4 << 0);  ///< Total number of interrupt lines in groups
    }

    /// STIR Register bits
    namespace stir_bits {
        constexpr uint32_t INTID = (9 << 0);  ///< interrupt to be triggered
    }

    /// ISER0 Register bits
    namespace iser0_bits {
        constexpr uint32_t SETENA = (32 << 0);  ///< SETENA
    }

    /// ICER0 Register bits
    namespace icer0_bits {
        constexpr uint32_t CLRENA = (32 << 0);  ///< CLRENA
    }

    /// ISPR0 Register bits
    namespace ispr0_bits {
        constexpr uint32_t SETPEND = (32 << 0);  ///< SETPEND
    }

    /// ICPR0 Register bits
    namespace icpr0_bits {
        constexpr uint32_t CLRPEND = (32 << 0);  ///< CLRPEND
    }

    /// IABR0 Register bits
    namespace iabr0_bits {
        constexpr uint32_t ACTIVE = (32 << 0);  ///< ACTIVE
    }

    /// IPR0 Register bits
    namespace ipr0_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR1 Register bits
    namespace ipr1_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR2 Register bits
    namespace ipr2_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR3 Register bits
    namespace ipr3_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

    /// IPR4 Register bits
    namespace ipr4_bits {
        constexpr uint32_t IPR_N0 = (8 << 0);  ///< IPR_N0
        constexpr uint32_t IPR_N1 = (8 << 8);  ///< IPR_N1
        constexpr uint32_t IPR_N2 = (8 << 16);  ///< IPR_N2
        constexpr uint32_t IPR_N3 = (8 << 24);  ///< IPR_N3
    }

}

// ============================================================================
// MEM Peripheral
// ============================================================================

namespace mem {
    /// Base addresses
    constexpr uint32_t MEM_BASE = 0x40005000;

    /// MEM Register structure
    struct Registers {
        volatile uint32_t RAMPROTR1;  ///< Offset: 0x00 - Memory protection register1
        volatile uint32_t RAMPROTR2;  ///< Offset: 0x04 - Memory protection register2
        volatile uint32_t RAMPROTR3;  ///< Offset: 0x08 - Memory protection register3
        volatile uint32_t RAMPROTR4;  ///< Offset: 0x0C - Memory protection register4
        volatile uint32_t RAMPROTR5;  ///< Offset: 0x10 - Memory protection register5
        volatile uint32_t RAMPROTR6;  ///< Offset: 0x14 - Memory protection register6
        volatile uint32_t RAMPROTR7;  ///< Offset: 0x18 - Memory protection register7
        volatile uint32_t RAMPROTR8;  ///< Offset: 0x1C - Memory protection register8
        volatile uint32_t DMAPROTR1;  ///< Offset: 0x20 - DMA protection register1
        volatile uint32_t DMAPROTR2;  ///< Offset: 0x24 - DMA protection register2
        volatile uint32_t RAMCR;  ///< Offset: 0x28 - Memory configuration register
    };

    /// Peripheral instances
    inline Registers* MEM = reinterpret_cast<Registers*>(MEM_BASE);

    // Bit definitions
    /// RAMPROTR1 Register bits
    namespace ramprotr1_bits {
        constexpr uint32_t RAMPROT1 = (32 << 0);  ///< RAMPROT1
    }

    /// RAMPROTR2 Register bits
    namespace ramprotr2_bits {
        constexpr uint32_t RAMPROT2 = (32 << 0);  ///< RAMPROT2
    }

    /// RAMPROTR3 Register bits
    namespace ramprotr3_bits {
        constexpr uint32_t RAMPROT3 = (32 << 0);  ///< RAMPROT1
    }

    /// RAMPROTR4 Register bits
    namespace ramprotr4_bits {
        constexpr uint32_t RAMPROT4 = (32 << 0);  ///< RAMPROT4
    }

    /// RAMPROTR5 Register bits
    namespace ramprotr5_bits {
        constexpr uint32_t RAMPROT5 = (32 << 0);  ///< RAMPROT5
    }

    /// RAMPROTR6 Register bits
    namespace ramprotr6_bits {
        constexpr uint32_t RAMPROT6 = (32 << 0);  ///< RAMPROT6
    }

    /// RAMPROTR7 Register bits
    namespace ramprotr7_bits {
        constexpr uint32_t RAMPROT7 = (32 << 0);  ///< RAMPROT7
    }

    /// RAMPROTR8 Register bits
    namespace ramprotr8_bits {
        constexpr uint32_t RAMPROT8 = (32 << 0);  ///< RAMPROT8
    }

    /// DMAPROTR1 Register bits
    namespace dmaprotr1_bits {
        constexpr uint32_t ADDRESS = (14 << 0);  ///< DMA protection fault, faulting address
        constexpr uint32_t OFFSET = (18 << 14);  ///< offset in RAM
    }

    /// DMAPROTR2 Register bits
    namespace dmaprotr2_bits {
        constexpr uint32_t CHANNEL = (3 << 0);  ///< DMA protection fault, faulting channel
    }

    /// RAMCR Register bits
    namespace ramcr_bits {
        constexpr uint32_t WEN = (1U << 2);  ///< Makes all RAM write access
    }

}

// ============================================================================
// DMA Peripheral
// ============================================================================

namespace dma {
    /// Base addresses
    constexpr uint32_t SC1_DMA_BASE = 0x4000C800;
    constexpr uint32_t SC2_DMA_BASE = 0x4000C000;

    /// DMA Register structure
    struct Registers {
        volatile uint32_t SC1_DMARXBEGADDAR;  ///< Offset: 0x00 - Serial controller receive DMA begin address channel A register
        volatile uint32_t SC1_DMARXENDADDAR;  ///< Offset: 0x04 - Serial controller receive DMA end address channel A register
        volatile uint32_t SC1_DMARXBEGADDBR;  ///< Offset: 0x08 - Serial controller receive DMA begin address channel B register
        volatile uint32_t SC1_DMARXENDADDBR;  ///< Offset: 0x0C - Serial controller receive DMA end address channel B register
        volatile uint32_t SC1_DMATXBEGADDAR;  ///< Offset: 0x10 - Serial controller transmit DMA begin address channel A register
        volatile uint32_t SC1_DMATXENDADDAR;  ///< Offset: 0x14 - Serial controller transmit DMA end address channel A register
        volatile uint32_t SC1_DMATXBEGADDBR;  ///< Offset: 0x18 - Serial controller transmit DMA begin address channel B register
        volatile uint32_t SC1_DMATXENDADDBR;  ///< Offset: 0x1C - Serial controller transmit DMA end address channel B
        volatile uint32_t SC1_DMARXCNTAR;  ///< Offset: 0x20 - Serial controller receive DMA counter channel A register
        volatile uint32_t SC1_DMARXCNTBR;  ///< Offset: 0x24 - Serial controller receive DMA count channel B register
        volatile uint32_t SC1_DMATXCNTR;  ///< Offset: 0x28 - Serial controller transmit DMA counter register
        volatile uint32_t SC1_DMASR;  ///< Offset: 0x2C - Serial controller DMA status register
        volatile uint32_t SC1_DMACR;  ///< Offset: 0x30 - Serial controller DMA control register
        volatile uint32_t SC1_DMARXERRAR;  ///< Offset: 0x34 - Serial controller receive DMA channel A first error register
        volatile uint32_t SC1_DMARXERRBR;  ///< Offset: 0x38 - Serial controller receive DMA channel B first error register
        volatile uint32_t SC1_DMARXCNTSAVEDR;  ///< Offset: 0x70 - Serial controller receive DMA saved counter channel B register
    };

    /// Peripheral instances
    inline Registers* SC1_DMA = reinterpret_cast<Registers*>(SC1_DMA_BASE);
    inline Registers* SC2_DMA = reinterpret_cast<Registers*>(SC2_DMA_BASE);

    // Bit definitions
    /// SC1_DMARXBEGADDAR Register bits
    namespace sc1_dmarxbegaddar_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMARXENDADDAR Register bits
    namespace sc1_dmarxendaddar_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMARXBEGADDBR Register bits
    namespace sc1_dmarxbegaddbr_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMARXENDADDBR Register bits
    namespace sc1_dmarxendaddbr_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMATXBEGADDAR Register bits
    namespace sc1_dmatxbegaddar_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMATXENDADDAR Register bits
    namespace sc1_dmatxendaddar_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMATXBEGADDBR Register bits
    namespace sc1_dmatxbegaddbr_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMATXENDADDBR Register bits
    namespace sc1_dmatxendaddbr_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMARXCNTAR Register bits
    namespace sc1_dmarxcntar_bits {
        constexpr uint32_t CNT = (13 << 0);  ///< CNT
    }

    /// SC1_DMARXCNTBR Register bits
    namespace sc1_dmarxcntbr_bits {
        constexpr uint32_t CNT = (13 << 0);  ///< CNT
    }

    /// SC1_DMATXCNTR Register bits
    namespace sc1_dmatxcntr_bits {
        constexpr uint32_t CNT = (13 << 0);  ///< CNT
    }

    /// SC1_DMASR Register bits
    namespace sc1_dmasr_bits {
        constexpr uint32_t NSSS = (3 << 10);  ///< NSSS
        constexpr uint32_t FEB = (1U << 9);  ///< FEB
        constexpr uint32_t FEA = (1U << 8);  ///< FEA
        constexpr uint32_t PEB = (1U << 7);  ///< PEB
        constexpr uint32_t PEA = (1U << 6);  ///< PEA
        constexpr uint32_t OVRB = (1U << 5);  ///< OVRB
        constexpr uint32_t OVRA = (1U << 4);  ///< OVRA
        constexpr uint32_t TXBACK = (1U << 3);  ///< TXBACK
        constexpr uint32_t TXAACK = (1U << 2);  ///< TXAACK
        constexpr uint32_t RXBACK = (1U << 1);  ///< RXBACK
        constexpr uint32_t RXAACK = (1U << 0);  ///< RXAACK
    }

    /// SC1_DMACR Register bits
    namespace sc1_dmacr_bits {
        constexpr uint32_t TXRST = (1U << 5);  ///< TXRST
        constexpr uint32_t RXRST = (1U << 4);  ///< RXRST
        constexpr uint32_t TXLODB = (1U << 3);  ///< TXLODB
        constexpr uint32_t TXLODA = (1U << 2);  ///< TXLODA
        constexpr uint32_t RXLODB = (1U << 1);  ///< RXLODB
        constexpr uint32_t RXLODA = (1U << 0);  ///< RXLODA
    }

    /// SC1_DMARXERRAR Register bits
    namespace sc1_dmarxerrar_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMARXERRBR Register bits
    namespace sc1_dmarxerrbr_bits {
        constexpr uint32_t ADD = (13 << 0);  ///< ADD
    }

    /// SC1_DMARXCNTSAVEDR Register bits
    namespace sc1_dmarxcntsavedr_bits {
        constexpr uint32_t CNT = (13 << 0);  ///< CNT
    }

}

// ============================================================================
// USART Peripheral
// ============================================================================

namespace usart {
    /// Base addresses
    constexpr uint32_t SC1_UART_BASE = 0x4000C848;

    /// USART Register structure
    struct Registers {
        volatile uint32_t SC1_UARTSR;  ///< Offset: 0x00 - Serial controller UART status register
        volatile uint32_t SC1_UARTCR;  ///< Offset: 0x14 - Serial controller UART control register
        volatile uint32_t SC1_UARTBRR1;  ///< Offset: 0x20 - Serial controller UART baud rate register 1
        volatile uint32_t SC1_UARTBRR2;  ///< Offset: 0x24 - Serial controller UART baud rate register 2
    };

    /// Peripheral instances
    inline Registers* SC1_UART = reinterpret_cast<Registers*>(SC1_UART_BASE);

    // Bit definitions
    /// SC1_UARTSR Register bits
    namespace sc1_uartsr_bits {
        constexpr uint32_t IDLE = (1U << 6);  ///< IDLE
        constexpr uint32_t PE = (1U << 5);  ///< PE
        constexpr uint32_t FE = (1U << 4);  ///< FE
        constexpr uint32_t OVR = (1U << 3);  ///< OVR
        constexpr uint32_t TXE = (1U << 2);  ///< TXE
        constexpr uint32_t RXNE = (1U << 1);  ///< RXNE
        constexpr uint32_t CTS = (1U << 0);  ///< CTS
    }

    /// SC1_UARTCR Register bits
    namespace sc1_uartcr_bits {
        constexpr uint32_t AHFCE = (1U << 6);  ///< AHFCE
        constexpr uint32_t HFCE = (1U << 5);  ///< HFCE
        constexpr uint32_t PS = (1U << 4);  ///< PS
        constexpr uint32_t PCE = (1U << 3);  ///< PCE
        constexpr uint32_t STOP = (1U << 2);  ///< STOP
        constexpr uint32_t M = (1U << 1);  ///< M
        constexpr uint32_t nRTS = (1U << 0);  ///< nRTS
    }

    /// SC1_UARTBRR1 Register bits
    namespace sc1_uartbrr1_bits {
        constexpr uint32_t N = (16 << 0);  ///< N
    }

    /// SC1_UARTBRR2 Register bits
    namespace sc1_uartbrr2_bits {
        constexpr uint32_t F = (1U << 0);  ///< F
    }

}

// ============================================================================
// I2C Peripheral
// ============================================================================

namespace i2c {
    /// Base addresses
    constexpr uint32_t SC1_I2C_BASE = 0x4000C844;
    constexpr uint32_t SC2_I2C_BASE = 0x4000C044;

    /// I2C Register structure
    struct Registers {
        volatile uint32_t SC1_I2CSR;  ///< Offset: 0x00 - Serial controller I2C status register
        volatile uint32_t SC1_I2CCR1;  ///< Offset: 0x08 - Serial controller I2C control register 1
        volatile uint32_t SC1_I2CCR2;  ///< Offset: 0x0C - Serial controller I2C control register 2
    };

    /// Peripheral instances
    inline Registers* SC1_I2C = reinterpret_cast<Registers*>(SC1_I2C_BASE);
    inline Registers* SC2_I2C = reinterpret_cast<Registers*>(SC2_I2C_BASE);

    // Bit definitions
    /// SC1_I2CSR Register bits
    namespace sc1_i2csr_bits {
        constexpr uint32_t CMDFIN = (1U << 3);  ///< CMDFIN
        constexpr uint32_t BRF = (1U << 2);  ///< BRF
        constexpr uint32_t BTF = (1U << 1);  ///< BTF
        constexpr uint32_t NACK = (1U << 0);  ///< NACK
    }

    /// SC1_I2CCR1 Register bits
    namespace sc1_i2ccr1_bits {
        constexpr uint32_t STOP = (1U << 3);  ///< STOP
        constexpr uint32_t START = (1U << 2);  ///< START
        constexpr uint32_t BTE = (1U << 1);  ///< BTE
        constexpr uint32_t BRE = (1U << 0);  ///< BRE
    }

    /// SC1_I2CCR2 Register bits
    namespace sc1_i2ccr2_bits {
        constexpr uint32_t ACK = (1U << 0);  ///< ACK
    }

}

// ============================================================================
// SPI Peripheral
// ============================================================================

namespace spi {
    /// Base addresses
    constexpr uint32_t SC1_SPI_BASE = 0x4000C840;
    constexpr uint32_t SC2_SPI_BASE = 0x4000C040;

    /// SPI Register structure
    struct Registers {
        volatile uint32_t SC1_SPISR;  ///< Offset: 0x00 - Serial controller SPI status register
        volatile uint32_t SC1_SPICR;  ///< Offset: 0x18 - Serial controller SPI control register
    };

    /// Peripheral instances
    inline Registers* SC1_SPI = reinterpret_cast<Registers*>(SC1_SPI_BASE);
    inline Registers* SC2_SPI = reinterpret_cast<Registers*>(SC2_SPI_BASE);

    // Bit definitions
    /// SC1_SPISR Register bits
    namespace sc1_spisr_bits {
        constexpr uint32_t IDLE = (1U << 3);  ///< IDLE
        constexpr uint32_t TXE = (1U << 2);  ///< TXE
        constexpr uint32_t RXNE = (1U << 1);  ///< RXNE
        constexpr uint32_t OVF = (1U << 0);  ///< OVF
    }

    /// SC1_SPICR Register bits
    namespace sc1_spicr_bits {
        constexpr uint32_t RXMODE = (1U << 5);  ///< RXMODE
        constexpr uint32_t MSTR = (1U << 4);  ///< MSTR
        constexpr uint32_t RPTEN = (1U << 3);  ///< RPTEN
        constexpr uint32_t LSBFIRST = (1U << 2);  ///< LSBFIRST
        constexpr uint32_t CPHA = (1U << 1);  ///< CPHA
        constexpr uint32_t CPOL = (1U << 0);  ///< CPOL
    }

}


} // namespace alloy::generated::stm32w108

#endif // ALLOY_GENERATED_STM32W108_PERIPHERALS_HPP