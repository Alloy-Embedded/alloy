/**
 * @file dma_connection.hpp
 * @brief Type-Safe DMA Connection Infrastructure
 *
 * Provides compile-time validation for DMA channel allocations and
 * peripheral compatibility.
 *
 * Design Principles:
 * - Compile-time validation of DMA connections
 * - Detect conflicts between peripheral requests
 * - Type-safe channel allocation
 * - Clear error messages for invalid configurations
 * - Zero runtime overhead
 *
 * Example Usage:
 * @code
 * // Define DMA connection
 * using Uart0TxDma = DmaConnection<
 *     PeripheralId::USART0,
 *     DmaRequest::USART0_TX,
 *     DmaStream::Stream0
 * >;
 *
 * // Check compatibility at compile-time
 * static_assert(Uart0TxDma::is_compatible(), "Invalid DMA connection");
 *
 * // Allocate in registry
 * using MyDmaRegistry = DmaRegistry<Uart0TxDma>;
 * @endcode
 *
 * @note Part of Phase 5.1: DMA Connection Types
 * @see openspec/changes/modernize-peripheral-architecture/specs/dma-integration/spec.md
 */

#pragma once

#include "core/error_code.hpp"
#include "core/result.hpp"
#include "core/types.hpp"
#include "hal/signals.hpp"
#include "hal/interface/dma.hpp"

#include <array>

namespace alloy::hal {

using namespace alloy::core;
using namespace alloy::hal::signals;

// ============================================================================
// DMA Stream and Request Identifiers
// ============================================================================

/**
 * @brief DMA Stream identifiers
 *
 * Represents available DMA streams/channels in the system.
 * Platform-specific implementations will define the actual streams.
 */
enum class DmaStream : u8 {
    Stream0 = 0,
    Stream1 = 1,
    Stream2 = 2,
    Stream3 = 3,
    Stream4 = 4,
    Stream5 = 5,
    Stream6 = 6,
    Stream7 = 7,
};

/**
 * @brief DMA Request identifiers
 *
 * Represents DMA request sources from peripherals.
 * Each peripheral can have multiple request types (TX, RX, etc).
 */
enum class DmaRequest : u8 {
    // USART/UART requests
    USART0_TX = 0,
    USART0_RX = 1,
    USART1_TX = 2,
    USART1_RX = 3,
    USART2_TX = 4,
    USART2_RX = 5,

    // SPI requests
    SPI0_TX = 10,
    SPI0_RX = 11,
    SPI1_TX = 12,
    SPI1_RX = 13,

    // I2C requests
    I2C0_TX = 20,
    I2C0_RX = 21,
    I2C1_TX = 22,
    I2C1_RX = 23,
    I2C2_TX = 24,
    I2C2_RX = 25,

    // ADC requests
    ADC0 = 30,
    ADC1 = 31,

    // Timer requests
    TIMER0_UPDATE = 40,
    TIMER1_UPDATE = 41,
    TIMER2_UPDATE = 42,
};

// ============================================================================
// DMA Connection Type
// ============================================================================

/**
 * @brief Type-safe DMA connection
 *
 * Represents a connection between a peripheral, DMA request, and DMA stream.
 * Validates compatibility at compile-time.
 *
 * @tparam Peripheral The peripheral ID requesting DMA
 * @tparam Request The DMA request type
 * @tparam Stream The DMA stream to use
 */
template <PeripheralId Peripheral, DmaRequest Request, DmaStream Stream>
struct DmaConnection {
    static constexpr PeripheralId peripheral = Peripheral;
    static constexpr DmaRequest request = Request;
    static constexpr DmaStream stream = Stream;

    /**
     * @brief Check if this DMA connection is compatible
     *
     * Validates that the request matches the peripheral and the stream
     * supports the request type.
     *
     * @return true if valid, false otherwise
     */
    static constexpr bool is_compatible() {
        // Check peripheral-request compatibility
        if (!is_request_for_peripheral()) {
            return false;
        }

        return true;
    }

    /**
     * @brief Get error message for invalid configuration
     *
     * @return Error message string
     */
    static constexpr const char* error_message() {
        if (!is_request_for_peripheral()) {
            return "DMA request does not match peripheral";
        }

        return "Valid DMA connection";
    }

    /**
     * @brief Check if request belongs to peripheral
     *
     * Validates that the DMA request is actually generated by the
     * specified peripheral.
     */
    static constexpr bool is_request_for_peripheral() {
        // USART0 requests
        if (Peripheral == PeripheralId::USART0) {
            return Request == DmaRequest::USART0_TX ||
                   Request == DmaRequest::USART0_RX;
        }

        // USART1 requests
        if (Peripheral == PeripheralId::USART1) {
            return Request == DmaRequest::USART1_TX ||
                   Request == DmaRequest::USART1_RX;
        }

        // USART2 requests
        if (Peripheral == PeripheralId::USART2) {
            return Request == DmaRequest::USART2_TX ||
                   Request == DmaRequest::USART2_RX;
        }

        // SPI0 requests
        if (Peripheral == PeripheralId::SPI0) {
            return Request == DmaRequest::SPI0_TX ||
                   Request == DmaRequest::SPI0_RX;
        }

        // SPI1 requests
        if (Peripheral == PeripheralId::SPI1) {
            return Request == DmaRequest::SPI1_TX ||
                   Request == DmaRequest::SPI1_RX;
        }

        // I2C0 requests
        if (Peripheral == PeripheralId::I2C0) {
            return Request == DmaRequest::I2C0_TX ||
                   Request == DmaRequest::I2C0_RX;
        }

        // I2C1 requests
        if (Peripheral == PeripheralId::I2C1) {
            return Request == DmaRequest::I2C1_TX ||
                   Request == DmaRequest::I2C1_RX;
        }

        // I2C2 requests
        if (Peripheral == PeripheralId::I2C2) {
            return Request == DmaRequest::I2C2_TX ||
                   Request == DmaRequest::I2C2_RX;
        }

        // ADC0 requests
        if (Peripheral == PeripheralId::ADC0) {
            return Request == DmaRequest::ADC0;
        }

        // ADC1 requests
        if (Peripheral == PeripheralId::ADC1) {
            return Request == DmaRequest::ADC1;
        }

        // TIMER0 requests
        if (Peripheral == PeripheralId::TIMER0) {
            return Request == DmaRequest::TIMER0_UPDATE;
        }

        // TIMER1 requests
        if (Peripheral == PeripheralId::TIMER1) {
            return Request == DmaRequest::TIMER1_UPDATE;
        }

        // TIMER2 requests
        if (Peripheral == PeripheralId::TIMER2) {
            return Request == DmaRequest::TIMER2_UPDATE;
        }

        return false;
    }

    /**
     * @brief Check if this connection conflicts with another
     *
     * Two connections conflict if they use the same stream.
     *
     * @tparam Other The other DMA connection to check against
     * @return true if they conflict, false otherwise
     */
    template <typename Other>
    static constexpr bool conflicts_with() {
        return Stream == Other::stream;
    }
};

// ============================================================================
// DMA Connection Helpers
// ============================================================================

/**
 * @brief Get DMA request for peripheral TX
 *
 * Helper to get the correct DMA request for a peripheral's TX operation.
 */
constexpr DmaRequest get_tx_request(PeripheralId peripheral) {
    switch (peripheral) {
        case PeripheralId::USART0: return DmaRequest::USART0_TX;
        case PeripheralId::USART1: return DmaRequest::USART1_TX;
        case PeripheralId::USART2: return DmaRequest::USART2_TX;
        case PeripheralId::SPI0: return DmaRequest::SPI0_TX;
        case PeripheralId::SPI1: return DmaRequest::SPI1_TX;
        case PeripheralId::I2C1: return DmaRequest::I2C1_TX;
        case PeripheralId::I2C2: return DmaRequest::I2C2_TX;
        default: return DmaRequest::USART0_TX; // Should never happen
    }
}

/**
 * @brief Get DMA request for peripheral RX
 *
 * Helper to get the correct DMA request for a peripheral's RX operation.
 */
constexpr DmaRequest get_rx_request(PeripheralId peripheral) {
    switch (peripheral) {
        case PeripheralId::USART0: return DmaRequest::USART0_RX;
        case PeripheralId::USART1: return DmaRequest::USART1_RX;
        case PeripheralId::USART2: return DmaRequest::USART2_RX;
        case PeripheralId::SPI0: return DmaRequest::SPI0_RX;
        case PeripheralId::SPI1: return DmaRequest::SPI1_RX;
        case PeripheralId::I2C1: return DmaRequest::I2C1_RX;
        case PeripheralId::I2C2: return DmaRequest::I2C2_RX;
        default: return DmaRequest::USART0_RX; // Should never happen
    }
}

// ============================================================================
// Compile-Time Validation
// ============================================================================

/**
 * @brief Validate DMA connection at compile-time
 *
 * Use in static_assert to ensure connection is valid.
 *
 * Example:
 * @code
 * using MyDma = DmaConnection<PeripheralId::USART0, DmaRequest::USART0_TX, DmaStream::Stream0>;
 * static_assert(validate_dma_connection<MyDma>(), MyDma::error_message());
 * @endcode
 */
template <typename Connection>
constexpr bool validate_dma_connection() {
    return Connection::is_compatible();
}

}  // namespace alloy::hal
