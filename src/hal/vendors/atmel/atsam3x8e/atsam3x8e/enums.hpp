/// Auto-generated enumeration definitions
/// Device: ATSAM3X8E
/// Vendor: Atmel
///
/// This file contains type-safe enum classes for all register field
/// enumerated values extracted from the CMSIS-SVD file.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::atmel::atsam3x8e::atsam3x8e::enums {

// ============================================================================
// ENUMERATED VALUE DEFINITIONS
// ============================================================================

// ----------------------------------------------------------------------------
// ADC - Analog-to-Digital Converter
// ----------------------------------------------------------------------------

/// Trigger Enable
/// Register: MR
/// Field: TRGEN [0:0]
enum class ADC_MR_TRGEN : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Trigger Selection
/// Register: MR
/// Field: TRGSEL [1:3]
enum class ADC_MR_TRGSEL : uint32_t {
    ADC_TRIG0 = 0x0,
    ADC_TRIG1 = 0x1,
    ADC_TRIG2 = 0x2,
    ADC_TRIG3 = 0x3,
    ADC_TRIG4 = 0x4,
    ADC_TRIG5 = 0x5,
};

/// Sleep Mode
/// Register: MR
/// Field: SLEEP [5:5]
enum class ADC_MR_SLEEP : uint32_t {
    NORMAL = 0x0,
    SLEEP = 0x1,
};

/// Fast Wake Up
/// Register: MR
/// Field: FWUP [6:6]
enum class ADC_MR_FWUP : uint32_t {
    OFF = 0x0,
    ON = 0x1,
};

/// Free Run Mode
/// Register: MR
/// Field: FREERUN [7:7]
enum class ADC_MR_FREERUN : uint32_t {
    OFF = 0x0,
    ON = 0x1,
};

/// Start Up Time
/// Register: MR
/// Field: STARTUP [16:19]
enum class ADC_MR_STARTUP : uint32_t {
    SUT0 = 0x0,
    SUT8 = 0x1,
    SUT16 = 0x2,
    SUT24 = 0x3,
    SUT64 = 0x4,
    SUT80 = 0x5,
    SUT96 = 0x6,
    SUT112 = 0x7,
    SUT512 = 0x8,
    SUT576 = 0x9,
    SUT640 = 0xA,
    SUT704 = 0xB,
    SUT768 = 0xC,
    SUT832 = 0xD,
    SUT896 = 0xE,
    SUT960 = 0xF,
};

/// Analog Settling Time
/// Register: MR
/// Field: SETTLING [20:21]
enum class ADC_MR_SETTLING : uint32_t {
    AST3 = 0x0,
    AST5 = 0x1,
    AST9 = 0x2,
    AST17 = 0x3,
};

/// Analog Change
/// Register: MR
/// Field: ANACH [23:23]
enum class ADC_MR_ANACH : uint32_t {
    NONE = 0x0,
    ALLOWED = 0x1,
};

/// Use Sequence Enable
/// Register: MR
/// Field: USEQ [31:31]
enum class ADC_MR_USEQ : uint32_t {
    NUM_ORDER = 0x0,
    REG_ORDER = 0x1,
};

/// Comparison Mode
/// Register: EMR
/// Field: CMPMODE [0:1]
enum class ADC_EMR_CMPMODE : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
    IN = 0x2,
    OUT = 0x3,
};

/// Write Protect KEY
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class ADC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x414443,
};

// ----------------------------------------------------------------------------
// CAN0 - Controller Area Network 0
// ----------------------------------------------------------------------------

/// Reception Synchronization Stage (not readable)
/// Register: MR
/// Field: RXSYNC [24:26]
enum class CAN0_MR_RXSYNC : uint32_t {
    DOUBLE_PP = 0x0,
    DOUBLE_PN = 0x1,
    SINGLE_P = 0x2,
    NONE = 0x3,
};

/// Sampling Mode
/// Register: BR
/// Field: SMP [24:24]
enum class CAN0_BR_SMP : uint32_t {
    ONCE = 0x0,
    THREE = 0x1,
};

/// Mailbox Object Type
/// Register: MMR0
/// Field: MOT [24:26]
enum class CAN0_MMR0_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR1
/// Field: MOT [24:26]
enum class CAN0_MMR1_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR2
/// Field: MOT [24:26]
enum class CAN0_MMR2_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR3
/// Field: MOT [24:26]
enum class CAN0_MMR3_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR4
/// Field: MOT [24:26]
enum class CAN0_MMR4_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR5
/// Field: MOT [24:26]
enum class CAN0_MMR5_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR6
/// Field: MOT [24:26]
enum class CAN0_MMR6_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR7
/// Field: MOT [24:26]
enum class CAN0_MMR7_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

// ----------------------------------------------------------------------------
// CAN1 - Controller Area Network 1
// ----------------------------------------------------------------------------

/// Reception Synchronization Stage (not readable)
/// Register: MR
/// Field: RXSYNC [24:26]
enum class CAN1_MR_RXSYNC : uint32_t {
    DOUBLE_PP = 0x0,
    DOUBLE_PN = 0x1,
    SINGLE_P = 0x2,
    NONE = 0x3,
};

/// Sampling Mode
/// Register: BR
/// Field: SMP [24:24]
enum class CAN1_BR_SMP : uint32_t {
    ONCE = 0x0,
    THREE = 0x1,
};

/// Mailbox Object Type
/// Register: MMR0
/// Field: MOT [24:26]
enum class CAN1_MMR0_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR1
/// Field: MOT [24:26]
enum class CAN1_MMR1_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR2
/// Field: MOT [24:26]
enum class CAN1_MMR2_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR3
/// Field: MOT [24:26]
enum class CAN1_MMR3_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR4
/// Field: MOT [24:26]
enum class CAN1_MMR4_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR5
/// Field: MOT [24:26]
enum class CAN1_MMR5_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR6
/// Field: MOT [24:26]
enum class CAN1_MMR6_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

/// Mailbox Object Type
/// Register: MMR7
/// Field: MOT [24:26]
enum class CAN1_MMR7_MOT : uint32_t {
    MB_DISABLED = 0x0,
    MB_RX = 0x1,
    MB_RX_OVERWRITE = 0x2,
    MB_TX = 0x3,
    MB_CONSUMER = 0x4,
    MB_PRODUCER = 0x5,
};

// ----------------------------------------------------------------------------
// CHIPID - Chip Identifier
// ----------------------------------------------------------------------------

/// Embedded Processor
/// Register: CIDR
/// Field: EPROC [5:7]
enum class CHIPID_CIDR_EPROC : uint32_t {
    ARM946ES = 0x1,
    ARM7TDMI = 0x2,
    CM3 = 0x3,
    ARM920T = 0x4,
    ARM926EJS = 0x5,
    CA5 = 0x6,
    CM4 = 0x7,
};

/// Nonvolatile Program Memory Size
/// Register: CIDR
/// Field: NVPSIZ [8:11]
enum class CHIPID_CIDR_NVPSIZ : uint32_t {
    NONE = 0x0,
    VAL_8K = 0x1,  // 8K
    VAL_16K = 0x2,  // 16K
    VAL_32K = 0x3,  // 32K
    VAL_64K = 0x5,  // 64K
    VAL_128K = 0x7,  // 128K
    VAL_256K = 0x9,  // 256K
    VAL_512K = 0xA,  // 512K
    VAL_1024K = 0xC,  // 1024K
    VAL_2048K = 0xE,  // 2048K
};

/// Second Nonvolatile Program Memory Size
/// Register: CIDR
/// Field: NVPSIZ2 [12:15]
enum class CHIPID_CIDR_NVPSIZ2 : uint32_t {
    NONE = 0x0,
    VAL_8K = 0x1,  // 8K
    VAL_16K = 0x2,  // 16K
    VAL_32K = 0x3,  // 32K
    VAL_64K = 0x5,  // 64K
    VAL_128K = 0x7,  // 128K
    VAL_256K = 0x9,  // 256K
    VAL_512K = 0xA,  // 512K
    VAL_1024K = 0xC,  // 1024K
    VAL_2048K = 0xE,  // 2048K
};

/// Internal SRAM Size
/// Register: CIDR
/// Field: SRAMSIZ [16:19]
enum class CHIPID_CIDR_SRAMSIZ : uint32_t {
    VAL_48K = 0x0,  // 48K
    VAL_192K = 0x1,  // 192K
    VAL_2K = 0x2,  // 2K
    VAL_6K = 0x3,  // 6K
    VAL_24K = 0x4,  // 24K
    VAL_4K = 0x5,  // 4K
    VAL_80K = 0x6,  // 80K
    VAL_160K = 0x7,  // 160K
    VAL_8K = 0x8,  // 8K
    VAL_16K = 0x9,  // 16K
    VAL_32K = 0xA,  // 32K
    VAL_64K = 0xB,  // 64K
    VAL_128K = 0xC,  // 128K
    VAL_256K = 0xD,  // 256K
    VAL_96K = 0xE,  // 96K
    VAL_512K = 0xF,  // 512K
};

/// Architecture Identifier
/// Register: CIDR
/// Field: ARCH [20:27]
enum class CHIPID_CIDR_ARCH : uint32_t {
    SAM3AxC = 0x83,
    SAM3XxC = 0x84,
    SAM3XxE = 0x85,
    SAM3XxG = 0x86,
};

/// Nonvolatile Program Memory Type
/// Register: CIDR
/// Field: NVPTYP [28:30]
enum class CHIPID_CIDR_NVPTYP : uint32_t {
    ROM = 0x0,
    ROMLESS = 0x1,
    FLASH = 0x2,
    ROM_FLASH = 0x3,
    SRAM = 0x4,
};

// ----------------------------------------------------------------------------
// DACC - Digital-to-Analog Converter Controller
// ----------------------------------------------------------------------------

/// Trigger Enable
/// Register: MR
/// Field: TRGEN [0:0]
enum class DACC_MR_TRGEN : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Word Transfer
/// Register: MR
/// Field: WORD [4:4]
enum class DACC_MR_WORD : uint32_t {
    HALF = 0x0,
    WORD = 0x1,
};

/// User Channel Selection
/// Register: MR
/// Field: USER_SEL [16:17]
enum class DACC_MR_USER_SEL : uint32_t {
    CHANNEL0 = 0x0,
    CHANNEL1 = 0x1,
};

/// Tag Selection Mode
/// Register: MR
/// Field: TAG [20:20]
enum class DACC_MR_TAG : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Max Speed Mode
/// Register: MR
/// Field: MAXS [21:21]
enum class DACC_MR_MAXS : uint32_t {
    NORMAL = 0x0,
    MAXIMUM = 0x1,
};

/// Startup Time Selection
/// Register: MR
/// Field: STARTUP [24:29]
enum class DACC_MR_STARTUP : uint32_t {
    VAL_0 = 0x0,  // 0
    VAL_8 = 0x1,  // 8
    VAL_16 = 0x2,  // 16
    VAL_24 = 0x3,  // 24
    VAL_64 = 0x4,  // 64
    VAL_80 = 0x5,  // 80
    VAL_96 = 0x6,  // 96
    VAL_112 = 0x7,  // 112
    VAL_512 = 0x8,  // 512
    VAL_576 = 0x9,  // 576
    VAL_640 = 0xA,  // 640
    VAL_704 = 0xB,  // 704
    VAL_768 = 0xC,  // 768
    VAL_832 = 0xD,  // 832
    VAL_896 = 0xE,  // 896
    VAL_960 = 0xF,  // 960
    VAL_1024 = 0x10,  // 1024
    VAL_1088 = 0x11,  // 1088
    VAL_1152 = 0x12,  // 1152
    VAL_1216 = 0x13,  // 1216
    VAL_1280 = 0x14,  // 1280
    VAL_1344 = 0x15,  // 1344
    VAL_1408 = 0x16,  // 1408
    VAL_1472 = 0x17,  // 1472
    VAL_1536 = 0x18,  // 1536
    VAL_1600 = 0x19,  // 1600
    VAL_1664 = 0x1A,  // 1664
    VAL_1728 = 0x1B,  // 1728
    VAL_1792 = 0x1C,  // 1792
    VAL_1856 = 0x1D,  // 1856
    VAL_1920 = 0x1E,  // 1920
    VAL_1984 = 0x1F,  // 1984
};

// ----------------------------------------------------------------------------
// DMAC - DMA Controller
// ----------------------------------------------------------------------------

/// Arbiter Configuration
/// Register: GCFG
/// Field: ARB_CFG [4:4]
enum class DMAC_GCFG_ARB_CFG : uint32_t {
    FIXED = 0x0,
    ROUND_ROBIN = 0x1,
};

/// Source Chunk Transfer Size.
/// Register: CTRLA0
/// Field: SCSIZE [16:18]
enum class DMAC_CTRLA0_SCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Destination Chunk Transfer Size
/// Register: CTRLA0
/// Field: DCSIZE [20:22]
enum class DMAC_CTRLA0_DCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Transfer Width for the Source
/// Register: CTRLA0
/// Field: SRC_WIDTH [24:25]
enum class DMAC_CTRLA0_SRC_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Transfer Width for the Destination
/// Register: CTRLA0
/// Field: DST_WIDTH [28:29]
enum class DMAC_CTRLA0_DST_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Source Address Descriptor
/// Register: CTRLB0
/// Field: SRC_DSCR [16:16]
enum class DMAC_CTRLB0_SRC_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Destination Address Descriptor
/// Register: CTRLB0
/// Field: DST_DSCR [20:20]
enum class DMAC_CTRLB0_DST_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Flow Control
/// Register: CTRLB0
/// Field: FC [21:22]
enum class DMAC_CTRLB0_FC : uint32_t {
    MEM2MEM_DMA_FC = 0x0,
    MEM2PER_DMA_FC = 0x1,
    PER2MEM_DMA_FC = 0x2,
    PER2PER_DMA_FC = 0x3,
};

/// Incrementing, Decrementing or Fixed Address for the Source
/// Register: CTRLB0
/// Field: SRC_INCR [24:25]
enum class DMAC_CTRLB0_SRC_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Incrementing, Decrementing or Fixed Address for the Destination
/// Register: CTRLB0
/// Field: DST_INCR [28:29]
enum class DMAC_CTRLB0_DST_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Software or Hardware Selection for the Source
/// Register: CFG0
/// Field: SRC_H2SEL [9:9]
enum class DMAC_CFG0_SRC_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Software or Hardware Selection for the Destination
/// Register: CFG0
/// Field: DST_H2SEL [13:13]
enum class DMAC_CFG0_DST_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Stop On Done
/// Register: CFG0
/// Field: SOD [16:16]
enum class DMAC_CFG0_SOD : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Interface Lock
/// Register: CFG0
/// Field: LOCK_IF [20:20]
enum class DMAC_CFG0_LOCK_IF : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Bus Lock
/// Register: CFG0
/// Field: LOCK_B [21:21]
enum class DMAC_CFG0_LOCK_B : uint32_t {
    DISABLE = 0x0,
};

/// Master Interface Arbiter Lock
/// Register: CFG0
/// Field: LOCK_IF_L [22:22]
enum class DMAC_CFG0_LOCK_IF_L : uint32_t {
    CHUNK = 0x0,
    BUFFER = 0x1,
};

/// FIFO Configuration
/// Register: CFG0
/// Field: FIFOCFG [28:29]
enum class DMAC_CFG0_FIFOCFG : uint32_t {
    ALAP_CFG = 0x0,
    HALF_CFG = 0x1,
    ASAP_CFG = 0x2,
};

/// Source Chunk Transfer Size.
/// Register: CTRLA1
/// Field: SCSIZE [16:18]
enum class DMAC_CTRLA1_SCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Destination Chunk Transfer Size
/// Register: CTRLA1
/// Field: DCSIZE [20:22]
enum class DMAC_CTRLA1_DCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Transfer Width for the Source
/// Register: CTRLA1
/// Field: SRC_WIDTH [24:25]
enum class DMAC_CTRLA1_SRC_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Transfer Width for the Destination
/// Register: CTRLA1
/// Field: DST_WIDTH [28:29]
enum class DMAC_CTRLA1_DST_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Source Address Descriptor
/// Register: CTRLB1
/// Field: SRC_DSCR [16:16]
enum class DMAC_CTRLB1_SRC_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Destination Address Descriptor
/// Register: CTRLB1
/// Field: DST_DSCR [20:20]
enum class DMAC_CTRLB1_DST_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Flow Control
/// Register: CTRLB1
/// Field: FC [21:22]
enum class DMAC_CTRLB1_FC : uint32_t {
    MEM2MEM_DMA_FC = 0x0,
    MEM2PER_DMA_FC = 0x1,
    PER2MEM_DMA_FC = 0x2,
    PER2PER_DMA_FC = 0x3,
};

/// Incrementing, Decrementing or Fixed Address for the Source
/// Register: CTRLB1
/// Field: SRC_INCR [24:25]
enum class DMAC_CTRLB1_SRC_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Incrementing, Decrementing or Fixed Address for the Destination
/// Register: CTRLB1
/// Field: DST_INCR [28:29]
enum class DMAC_CTRLB1_DST_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Software or Hardware Selection for the Source
/// Register: CFG1
/// Field: SRC_H2SEL [9:9]
enum class DMAC_CFG1_SRC_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Software or Hardware Selection for the Destination
/// Register: CFG1
/// Field: DST_H2SEL [13:13]
enum class DMAC_CFG1_DST_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Stop On Done
/// Register: CFG1
/// Field: SOD [16:16]
enum class DMAC_CFG1_SOD : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Interface Lock
/// Register: CFG1
/// Field: LOCK_IF [20:20]
enum class DMAC_CFG1_LOCK_IF : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Bus Lock
/// Register: CFG1
/// Field: LOCK_B [21:21]
enum class DMAC_CFG1_LOCK_B : uint32_t {
    DISABLE = 0x0,
};

/// Master Interface Arbiter Lock
/// Register: CFG1
/// Field: LOCK_IF_L [22:22]
enum class DMAC_CFG1_LOCK_IF_L : uint32_t {
    CHUNK = 0x0,
    BUFFER = 0x1,
};

/// FIFO Configuration
/// Register: CFG1
/// Field: FIFOCFG [28:29]
enum class DMAC_CFG1_FIFOCFG : uint32_t {
    ALAP_CFG = 0x0,
    HALF_CFG = 0x1,
    ASAP_CFG = 0x2,
};

/// Source Chunk Transfer Size.
/// Register: CTRLA2
/// Field: SCSIZE [16:18]
enum class DMAC_CTRLA2_SCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Destination Chunk Transfer Size
/// Register: CTRLA2
/// Field: DCSIZE [20:22]
enum class DMAC_CTRLA2_DCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Transfer Width for the Source
/// Register: CTRLA2
/// Field: SRC_WIDTH [24:25]
enum class DMAC_CTRLA2_SRC_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Transfer Width for the Destination
/// Register: CTRLA2
/// Field: DST_WIDTH [28:29]
enum class DMAC_CTRLA2_DST_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Source Address Descriptor
/// Register: CTRLB2
/// Field: SRC_DSCR [16:16]
enum class DMAC_CTRLB2_SRC_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Destination Address Descriptor
/// Register: CTRLB2
/// Field: DST_DSCR [20:20]
enum class DMAC_CTRLB2_DST_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Flow Control
/// Register: CTRLB2
/// Field: FC [21:22]
enum class DMAC_CTRLB2_FC : uint32_t {
    MEM2MEM_DMA_FC = 0x0,
    MEM2PER_DMA_FC = 0x1,
    PER2MEM_DMA_FC = 0x2,
    PER2PER_DMA_FC = 0x3,
};

/// Incrementing, Decrementing or Fixed Address for the Source
/// Register: CTRLB2
/// Field: SRC_INCR [24:25]
enum class DMAC_CTRLB2_SRC_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Incrementing, Decrementing or Fixed Address for the Destination
/// Register: CTRLB2
/// Field: DST_INCR [28:29]
enum class DMAC_CTRLB2_DST_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Software or Hardware Selection for the Source
/// Register: CFG2
/// Field: SRC_H2SEL [9:9]
enum class DMAC_CFG2_SRC_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Software or Hardware Selection for the Destination
/// Register: CFG2
/// Field: DST_H2SEL [13:13]
enum class DMAC_CFG2_DST_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Stop On Done
/// Register: CFG2
/// Field: SOD [16:16]
enum class DMAC_CFG2_SOD : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Interface Lock
/// Register: CFG2
/// Field: LOCK_IF [20:20]
enum class DMAC_CFG2_LOCK_IF : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Bus Lock
/// Register: CFG2
/// Field: LOCK_B [21:21]
enum class DMAC_CFG2_LOCK_B : uint32_t {
    DISABLE = 0x0,
};

/// Master Interface Arbiter Lock
/// Register: CFG2
/// Field: LOCK_IF_L [22:22]
enum class DMAC_CFG2_LOCK_IF_L : uint32_t {
    CHUNK = 0x0,
    BUFFER = 0x1,
};

/// FIFO Configuration
/// Register: CFG2
/// Field: FIFOCFG [28:29]
enum class DMAC_CFG2_FIFOCFG : uint32_t {
    ALAP_CFG = 0x0,
    HALF_CFG = 0x1,
    ASAP_CFG = 0x2,
};

/// Source Chunk Transfer Size.
/// Register: CTRLA3
/// Field: SCSIZE [16:18]
enum class DMAC_CTRLA3_SCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Destination Chunk Transfer Size
/// Register: CTRLA3
/// Field: DCSIZE [20:22]
enum class DMAC_CTRLA3_DCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Transfer Width for the Source
/// Register: CTRLA3
/// Field: SRC_WIDTH [24:25]
enum class DMAC_CTRLA3_SRC_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Transfer Width for the Destination
/// Register: CTRLA3
/// Field: DST_WIDTH [28:29]
enum class DMAC_CTRLA3_DST_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Source Address Descriptor
/// Register: CTRLB3
/// Field: SRC_DSCR [16:16]
enum class DMAC_CTRLB3_SRC_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Destination Address Descriptor
/// Register: CTRLB3
/// Field: DST_DSCR [20:20]
enum class DMAC_CTRLB3_DST_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Flow Control
/// Register: CTRLB3
/// Field: FC [21:22]
enum class DMAC_CTRLB3_FC : uint32_t {
    MEM2MEM_DMA_FC = 0x0,
    MEM2PER_DMA_FC = 0x1,
    PER2MEM_DMA_FC = 0x2,
    PER2PER_DMA_FC = 0x3,
};

/// Incrementing, Decrementing or Fixed Address for the Source
/// Register: CTRLB3
/// Field: SRC_INCR [24:25]
enum class DMAC_CTRLB3_SRC_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Incrementing, Decrementing or Fixed Address for the Destination
/// Register: CTRLB3
/// Field: DST_INCR [28:29]
enum class DMAC_CTRLB3_DST_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Software or Hardware Selection for the Source
/// Register: CFG3
/// Field: SRC_H2SEL [9:9]
enum class DMAC_CFG3_SRC_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Software or Hardware Selection for the Destination
/// Register: CFG3
/// Field: DST_H2SEL [13:13]
enum class DMAC_CFG3_DST_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Stop On Done
/// Register: CFG3
/// Field: SOD [16:16]
enum class DMAC_CFG3_SOD : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Interface Lock
/// Register: CFG3
/// Field: LOCK_IF [20:20]
enum class DMAC_CFG3_LOCK_IF : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Bus Lock
/// Register: CFG3
/// Field: LOCK_B [21:21]
enum class DMAC_CFG3_LOCK_B : uint32_t {
    DISABLE = 0x0,
};

/// Master Interface Arbiter Lock
/// Register: CFG3
/// Field: LOCK_IF_L [22:22]
enum class DMAC_CFG3_LOCK_IF_L : uint32_t {
    CHUNK = 0x0,
    BUFFER = 0x1,
};

/// FIFO Configuration
/// Register: CFG3
/// Field: FIFOCFG [28:29]
enum class DMAC_CFG3_FIFOCFG : uint32_t {
    ALAP_CFG = 0x0,
    HALF_CFG = 0x1,
    ASAP_CFG = 0x2,
};

/// Source Chunk Transfer Size.
/// Register: CTRLA4
/// Field: SCSIZE [16:18]
enum class DMAC_CTRLA4_SCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Destination Chunk Transfer Size
/// Register: CTRLA4
/// Field: DCSIZE [20:22]
enum class DMAC_CTRLA4_DCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Transfer Width for the Source
/// Register: CTRLA4
/// Field: SRC_WIDTH [24:25]
enum class DMAC_CTRLA4_SRC_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Transfer Width for the Destination
/// Register: CTRLA4
/// Field: DST_WIDTH [28:29]
enum class DMAC_CTRLA4_DST_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Source Address Descriptor
/// Register: CTRLB4
/// Field: SRC_DSCR [16:16]
enum class DMAC_CTRLB4_SRC_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Destination Address Descriptor
/// Register: CTRLB4
/// Field: DST_DSCR [20:20]
enum class DMAC_CTRLB4_DST_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Flow Control
/// Register: CTRLB4
/// Field: FC [21:22]
enum class DMAC_CTRLB4_FC : uint32_t {
    MEM2MEM_DMA_FC = 0x0,
    MEM2PER_DMA_FC = 0x1,
    PER2MEM_DMA_FC = 0x2,
    PER2PER_DMA_FC = 0x3,
};

/// Incrementing, Decrementing or Fixed Address for the Source
/// Register: CTRLB4
/// Field: SRC_INCR [24:25]
enum class DMAC_CTRLB4_SRC_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Incrementing, Decrementing or Fixed Address for the Destination
/// Register: CTRLB4
/// Field: DST_INCR [28:29]
enum class DMAC_CTRLB4_DST_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Software or Hardware Selection for the Source
/// Register: CFG4
/// Field: SRC_H2SEL [9:9]
enum class DMAC_CFG4_SRC_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Software or Hardware Selection for the Destination
/// Register: CFG4
/// Field: DST_H2SEL [13:13]
enum class DMAC_CFG4_DST_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Stop On Done
/// Register: CFG4
/// Field: SOD [16:16]
enum class DMAC_CFG4_SOD : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Interface Lock
/// Register: CFG4
/// Field: LOCK_IF [20:20]
enum class DMAC_CFG4_LOCK_IF : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Bus Lock
/// Register: CFG4
/// Field: LOCK_B [21:21]
enum class DMAC_CFG4_LOCK_B : uint32_t {
    DISABLE = 0x0,
};

/// Master Interface Arbiter Lock
/// Register: CFG4
/// Field: LOCK_IF_L [22:22]
enum class DMAC_CFG4_LOCK_IF_L : uint32_t {
    CHUNK = 0x0,
    BUFFER = 0x1,
};

/// FIFO Configuration
/// Register: CFG4
/// Field: FIFOCFG [28:29]
enum class DMAC_CFG4_FIFOCFG : uint32_t {
    ALAP_CFG = 0x0,
    HALF_CFG = 0x1,
    ASAP_CFG = 0x2,
};

/// Source Chunk Transfer Size.
/// Register: CTRLA5
/// Field: SCSIZE [16:18]
enum class DMAC_CTRLA5_SCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Destination Chunk Transfer Size
/// Register: CTRLA5
/// Field: DCSIZE [20:22]
enum class DMAC_CTRLA5_DCSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_4 = 0x1,
    CHK_8 = 0x2,
    CHK_16 = 0x3,
};

/// Transfer Width for the Source
/// Register: CTRLA5
/// Field: SRC_WIDTH [24:25]
enum class DMAC_CTRLA5_SRC_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Transfer Width for the Destination
/// Register: CTRLA5
/// Field: DST_WIDTH [28:29]
enum class DMAC_CTRLA5_DST_WIDTH : uint32_t {
    BYTE = 0x0,
    HALF_WORD = 0x1,
    WORD = 0x2,
};

/// Source Address Descriptor
/// Register: CTRLB5
/// Field: SRC_DSCR [16:16]
enum class DMAC_CTRLB5_SRC_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Destination Address Descriptor
/// Register: CTRLB5
/// Field: DST_DSCR [20:20]
enum class DMAC_CTRLB5_DST_DSCR : uint32_t {
    FETCH_FROM_MEM = 0x0,
    FETCH_DISABLE = 0x1,
};

/// Flow Control
/// Register: CTRLB5
/// Field: FC [21:22]
enum class DMAC_CTRLB5_FC : uint32_t {
    MEM2MEM_DMA_FC = 0x0,
    MEM2PER_DMA_FC = 0x1,
    PER2MEM_DMA_FC = 0x2,
    PER2PER_DMA_FC = 0x3,
};

/// Incrementing, Decrementing or Fixed Address for the Source
/// Register: CTRLB5
/// Field: SRC_INCR [24:25]
enum class DMAC_CTRLB5_SRC_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Incrementing, Decrementing or Fixed Address for the Destination
/// Register: CTRLB5
/// Field: DST_INCR [28:29]
enum class DMAC_CTRLB5_DST_INCR : uint32_t {
    INCREMENTING = 0x0,
    DECREMENTING = 0x1,
    FIXED = 0x2,
};

/// Software or Hardware Selection for the Source
/// Register: CFG5
/// Field: SRC_H2SEL [9:9]
enum class DMAC_CFG5_SRC_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Software or Hardware Selection for the Destination
/// Register: CFG5
/// Field: DST_H2SEL [13:13]
enum class DMAC_CFG5_DST_H2SEL : uint32_t {
    SW = 0x0,
    HW = 0x1,
};

/// Stop On Done
/// Register: CFG5
/// Field: SOD [16:16]
enum class DMAC_CFG5_SOD : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Interface Lock
/// Register: CFG5
/// Field: LOCK_IF [20:20]
enum class DMAC_CFG5_LOCK_IF : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Bus Lock
/// Register: CFG5
/// Field: LOCK_B [21:21]
enum class DMAC_CFG5_LOCK_B : uint32_t {
    DISABLE = 0x0,
};

/// Master Interface Arbiter Lock
/// Register: CFG5
/// Field: LOCK_IF_L [22:22]
enum class DMAC_CFG5_LOCK_IF_L : uint32_t {
    CHUNK = 0x0,
    BUFFER = 0x1,
};

/// FIFO Configuration
/// Register: CFG5
/// Field: FIFOCFG [28:29]
enum class DMAC_CFG5_FIFOCFG : uint32_t {
    ALAP_CFG = 0x0,
    HALF_CFG = 0x1,
    ASAP_CFG = 0x2,
};

/// Write Protect KEY
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class DMAC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x444D41,
};

// ----------------------------------------------------------------------------
// EFC0 - Embedded Flash Controller 0
// ----------------------------------------------------------------------------

/// Flash Command
/// Register: FCR
/// Field: FCMD [0:7]
enum class EFC0_FCR_FCMD : uint32_t {
    GETD = 0x0,
    WP = 0x1,
    WPL = 0x2,
    EWP = 0x3,
    EWPL = 0x4,
    EA = 0x5,
    SLB = 0x8,
    CLB = 0x9,
    GLB = 0xA,
    SGPB = 0xB,
    CGPB = 0xC,
    GGPB = 0xD,
    STUI = 0xE,
    SPUI = 0xF,
    GCALB = 0x10,
};

/// Flash Writing Protection Key
/// Register: FCR
/// Field: FKEY [24:31]
enum class EFC0_FCR_FKEY : uint32_t {
    PASSWD = 0x5A,
};

// ----------------------------------------------------------------------------
// EFC1 - Embedded Flash Controller 1
// ----------------------------------------------------------------------------

/// Flash Command
/// Register: FCR
/// Field: FCMD [0:7]
enum class EFC1_FCR_FCMD : uint32_t {
    GETD = 0x0,
    WP = 0x1,
    WPL = 0x2,
    EWP = 0x3,
    EWPL = 0x4,
    EA = 0x5,
    SLB = 0x8,
    CLB = 0x9,
    GLB = 0xA,
    SGPB = 0xB,
    CGPB = 0xC,
    GGPB = 0xD,
    STUI = 0xE,
    SPUI = 0xF,
    GCALB = 0x10,
};

/// Flash Writing Protection Key
/// Register: FCR
/// Field: FKEY [24:31]
enum class EFC1_FCR_FKEY : uint32_t {
    PASSWD = 0x5A,
};

// ----------------------------------------------------------------------------
// EMAC - Ethernet MAC 10/100
// ----------------------------------------------------------------------------

/// MDC clock divider
/// Register: NCFGR
/// Field: CLK [10:11]
enum class EMAC_NCFGR_CLK : uint32_t {
    MCK_8 = 0x0,
    MCK_16 = 0x1,
    MCK_32 = 0x2,
    MCK_64 = 0x3,
};

/// Receive Buffer Offset
/// Register: NCFGR
/// Field: RBOF [14:15]
enum class EMAC_NCFGR_RBOF : uint32_t {
    OFFSET_0 = 0x0,
    OFFSET_1 = 0x1,
    OFFSET_2 = 0x2,
    OFFSET_3 = 0x3,
};

// ----------------------------------------------------------------------------
// HSMCI - High Speed MultiMedia Card Interface
// ----------------------------------------------------------------------------

/// Data Timeout Multiplier
/// Register: DTOR
/// Field: DTOMUL [4:6]
enum class HSMCI_DTOR_DTOMUL : uint32_t {
    VAL_1 = 0x0,  // 1
    VAL_16 = 0x1,  // 16
    VAL_128 = 0x2,  // 128
    VAL_256 = 0x3,  // 256
    VAL_1024 = 0x4,  // 1024
    VAL_4096 = 0x5,  // 4096
    VAL_65536 = 0x6,  // 65536
    VAL_1048576 = 0x7,  // 1048576
};

/// SDCard/SDIO Slot
/// Register: SDCR
/// Field: SDCSEL [0:1]
enum class HSMCI_SDCR_SDCSEL : uint32_t {
    SLOTA = 0x0,
    SLOTB = 0x1,
    SLOTC = 0x2,
    SLOTD = 0x3,
};

/// SDCard/SDIO Bus Width
/// Register: SDCR
/// Field: SDCBUS [6:7]
enum class HSMCI_SDCR_SDCBUS : uint32_t {
    VAL_1 = 0x0,  // 1
    VAL_4 = 0x2,  // 4
    VAL_8 = 0x3,  // 8
};

/// Response Type
/// Register: CMDR
/// Field: RSPTYP [6:7]
enum class HSMCI_CMDR_RSPTYP : uint32_t {
    NORESP = 0x0,
    VAL_48_BIT = 0x1,  // 48_BIT
    VAL_136_BIT = 0x2,  // 136_BIT
    R1B = 0x3,
};

/// Special Command
/// Register: CMDR
/// Field: SPCMD [8:10]
enum class HSMCI_CMDR_SPCMD : uint32_t {
    STD = 0x0,
    INIT = 0x1,
    SYNC = 0x2,
    CE_ATA = 0x3,
    IT_CMD = 0x4,
    IT_RESP = 0x5,
    BOR = 0x6,
    EBO = 0x7,
};

/// Open Drain Command
/// Register: CMDR
/// Field: OPDCMD [11:11]
enum class HSMCI_CMDR_OPDCMD : uint32_t {
    PUSHPULL = 0x0,
    OPENDRAIN = 0x1,
};

/// Max Latency for Command to Response
/// Register: CMDR
/// Field: MAXLAT [12:12]
enum class HSMCI_CMDR_MAXLAT : uint32_t {
    VAL_5 = 0x0,  // 5
    VAL_64 = 0x1,  // 64
};

/// Transfer Command
/// Register: CMDR
/// Field: TRCMD [16:17]
enum class HSMCI_CMDR_TRCMD : uint32_t {
    NO_DATA = 0x0,
    START_DATA = 0x1,
    STOP_DATA = 0x2,
};

/// Transfer Direction
/// Register: CMDR
/// Field: TRDIR [18:18]
enum class HSMCI_CMDR_TRDIR : uint32_t {
    WRITE = 0x0,
    READ = 0x1,
};

/// Transfer Type
/// Register: CMDR
/// Field: TRTYP [19:21]
enum class HSMCI_CMDR_TRTYP : uint32_t {
    SINGLE = 0x0,
    MULTIPLE = 0x1,
    STREAM = 0x2,
    BYTE = 0x4,
    BLOCK = 0x5,
};

/// SDIO Special Command
/// Register: CMDR
/// Field: IOSPCMD [24:25]
enum class HSMCI_CMDR_IOSPCMD : uint32_t {
    STD = 0x0,
    SUSPEND = 0x1,
    RESUME = 0x2,
};

/// ATA with Command Completion Signal
/// Register: CMDR
/// Field: ATACS [26:26]
enum class HSMCI_CMDR_ATACS : uint32_t {
    NORMAL = 0x0,
    COMPLETION = 0x1,
};

/// Completion Signal Timeout Multiplier
/// Register: CSTOR
/// Field: CSTOMUL [4:6]
enum class HSMCI_CSTOR_CSTOMUL : uint32_t {
    VAL_1 = 0x0,  // 1
    VAL_16 = 0x1,  // 16
    VAL_128 = 0x2,  // 128
    VAL_256 = 0x3,  // 256
    VAL_1024 = 0x4,  // 1024
    VAL_4096 = 0x5,  // 4096
    VAL_65536 = 0x6,  // 65536
    VAL_1048576 = 0x7,  // 1048576
};

/// DMA Channel Read and Write Chunk Size
/// Register: DMA
/// Field: CHKSIZE [4:4]
enum class HSMCI_DMA_CHKSIZE : uint32_t {
    VAL_1 = 0x0,  // 1
    VAL_4 = 0x1,  // 4
};

/// Write Protect Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class HSMCI_WPMR_WPKEY : uint32_t {
    PASSWD = 0x4D4349,
};

// ----------------------------------------------------------------------------
// PMC - Power Management Controller
// ----------------------------------------------------------------------------

/// Main On-Chip RC Oscillator Frequency Selection
/// Register: CKGR_MOR
/// Field: MOSCRCF [4:6]
enum class PMC_CKGR_MOR_MOSCRCF : uint32_t {
    VAL_4_MHz = 0x0,  // 4_MHz
    VAL_8_MHz = 0x1,  // 8_MHz
    VAL_12_MHz = 0x2,  // 12_MHz
};

/// Write Access Password
/// Register: CKGR_MOR
/// Field: KEY [16:23]
enum class PMC_CKGR_MOR_KEY : uint32_t {
    PASSWD = 0x37,
};

/// Master Clock Source Selection
/// Register: PMC_MCKR
/// Field: CSS [0:1]
enum class PMC_PMC_MCKR_CSS : uint32_t {
    SLOW_CLK = 0x0,
    MAIN_CLK = 0x1,
    PLLA_CLK = 0x2,
    UPLL_CLK = 0x3,
};

/// Processor Clock Prescaler
/// Register: PMC_MCKR
/// Field: PRES [4:6]
enum class PMC_PMC_MCKR_PRES : uint32_t {
    CLK_1 = 0x0,
    CLK_2 = 0x1,
    CLK_4 = 0x2,
    CLK_8 = 0x3,
    CLK_16 = 0x4,
    CLK_32 = 0x5,
    CLK_64 = 0x6,
    CLK_3 = 0x7,
};

/// Master Clock Source Selection
/// Register: PMC_PCK[3]
/// Field: CSS [0:2]
enum class PMC_PMC_PCK_3_CSS : uint32_t {
    SLOW_CLK = 0x0,
    MAIN_CLK = 0x1,
    PLLA_CLK = 0x2,
    UPLL_CLK = 0x3,
    MCK = 0x4,
};

/// Programmable Clock Prescaler
/// Register: PMC_PCK[3]
/// Field: PRES [4:6]
enum class PMC_PMC_PCK_3_PRES : uint32_t {
    CLK_1 = 0x0,
    CLK_2 = 0x1,
    CLK_4 = 0x2,
    CLK_8 = 0x3,
    CLK_16 = 0x4,
    CLK_32 = 0x5,
    CLK_64 = 0x6,
};

/// Write Protect KEY
/// Register: PMC_WPMR
/// Field: WPKEY [8:31]
enum class PMC_PMC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x504D43,
};

/// Divisor Value
/// Register: PMC_PCR
/// Field: DIV [16:17]
enum class PMC_PMC_PCR_DIV : uint32_t {
    PERIPH_DIV_MCK = 0x0,
    PERIPH_DIV2_MCK = 0x1,
    PERIPH_DIV4_MCK = 0x2,
};

// ----------------------------------------------------------------------------
// PWM - Pulse Width Modulation Controller
// ----------------------------------------------------------------------------

/// Synchronous Channels Update Mode
/// Register: SCM
/// Field: UPDM [16:17]
enum class PWM_SCM_UPDM : uint32_t {
    MODE0 = 0x0,
    MODE1 = 0x1,
    MODE2 = 0x2,
};

/// Channel Pre-scaler
/// Register: CMR0
/// Field: CPRE [0:3]
enum class PWM_CMR0_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

/// Channel Pre-scaler
/// Register: CMR1
/// Field: CPRE [0:3]
enum class PWM_CMR1_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

/// Channel Pre-scaler
/// Register: CMR2
/// Field: CPRE [0:3]
enum class PWM_CMR2_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

/// Channel Pre-scaler
/// Register: CMR3
/// Field: CPRE [0:3]
enum class PWM_CMR3_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

/// Channel Pre-scaler
/// Register: CMR4
/// Field: CPRE [0:3]
enum class PWM_CMR4_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

/// Channel Pre-scaler
/// Register: CMR5
/// Field: CPRE [0:3]
enum class PWM_CMR5_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

/// Channel Pre-scaler
/// Register: CMR6
/// Field: CPRE [0:3]
enum class PWM_CMR6_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

/// Channel Pre-scaler
/// Register: CMR7
/// Field: CPRE [0:3]
enum class PWM_CMR7_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

// ----------------------------------------------------------------------------
// RSTC - Reset Controller
// ----------------------------------------------------------------------------

/// System Reset Key
/// Register: CR
/// Field: KEY [24:31]
enum class RSTC_CR_KEY : uint32_t {
    PASSWD = 0xA5,
};

/// Reset Type
/// Register: SR
/// Field: RSTTYP [8:10]
enum class RSTC_SR_RSTTYP : uint32_t {
    GeneralReset = 0x0,
    BackupReset = 0x1,
    WatchdogReset = 0x2,
    SoftwareReset = 0x3,
    UserReset = 0x4,
};

/// Write Access Password
/// Register: MR
/// Field: KEY [24:31]
enum class RSTC_MR_KEY : uint32_t {
    PASSWD = 0xA5,
};

// ----------------------------------------------------------------------------
// RTC - Real-time Clock
// ----------------------------------------------------------------------------

/// Time Event Selection
/// Register: CR
/// Field: TIMEVSEL [8:9]
enum class RTC_CR_TIMEVSEL : uint32_t {
    MINUTE = 0x0,
    HOUR = 0x1,
    MIDNIGHT = 0x2,
    NOON = 0x3,
};

/// Calendar Event Selection
/// Register: CR
/// Field: CALEVSEL [16:17]
enum class RTC_CR_CALEVSEL : uint32_t {
    WEEK = 0x0,
    MONTH = 0x1,
    YEAR = 0x2,
};

/// Acknowledge for Update
/// Register: SR
/// Field: ACKUPD [0:0]
enum class RTC_SR_ACKUPD : uint32_t {
    FREERUN = 0x0,
    UPDATE = 0x1,
};

/// Alarm Flag
/// Register: SR
/// Field: ALARM [1:1]
enum class RTC_SR_ALARM : uint32_t {
    NO_ALARMEVENT = 0x0,
    ALARMEVENT = 0x1,
};

/// Second Event
/// Register: SR
/// Field: SEC [2:2]
enum class RTC_SR_SEC : uint32_t {
    NO_SECEVENT = 0x0,
    SECEVENT = 0x1,
};

/// Time Event
/// Register: SR
/// Field: TIMEV [3:3]
enum class RTC_SR_TIMEV : uint32_t {
    NO_TIMEVENT = 0x0,
    TIMEVENT = 0x1,
};

/// Calendar Event
/// Register: SR
/// Field: CALEV [4:4]
enum class RTC_SR_CALEV : uint32_t {
    NO_CALEVENT = 0x0,
    CALEVENT = 0x1,
};

/// Write Protect KEY
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class RTC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x525443,
};

// ----------------------------------------------------------------------------
// SMC - Static Memory Controller
// ----------------------------------------------------------------------------

/// Page Size of the NAND Flash Device
/// Register: CFG
/// Field: PAGESIZE [0:1]
enum class SMC_CFG_PAGESIZE : uint32_t {
    PS512 = 0x0,
    PS1024 = 0x1,
    PS2048 = 0x2,
    PS4096 = 0x3,
};

/// Data Timeout Multiplier
/// Register: CFG
/// Field: DTOMUL [20:22]
enum class SMC_CFG_DTOMUL : uint32_t {
    X1 = 0x0,
    X16 = 0x1,
    X128 = 0x2,
    X256 = 0x3,
    X1024 = 0x4,
    X4096 = 0x5,
    X65536 = 0x6,
    X1048576 = 0x7,
};

/// ECC Page Size
/// Register: ECC_MD
/// Field: ECC_PAGESIZE [0:1]
enum class SMC_ECC_MD_ECC_PAGESIZE : uint32_t {
    PS512 = 0x0,
    PS1024 = 0x1,
    PS2048 = 0x2,
    PS4096 = 0x3,
};

/// Type of Correction
/// Register: ECC_MD
/// Field: TYPCORREC [4:5]
enum class SMC_ECC_MD_TYPCORREC : uint32_t {
    CPAGE = 0x0,
    C256B = 0x1,
    C512B = 0x2,
};

/// Selection of the Control Signal for Read Operation
/// Register: MODE0
/// Field: READ_MODE [0:0]
enum class SMC_MODE0_READ_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NRD_CTRL = 0x1,
};

/// Selection of the Control Signal for Write Operation
/// Register: MODE0
/// Field: WRITE_MODE [1:1]
enum class SMC_MODE0_WRITE_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NWE_CTRL = 0x1,
};

/// NWAIT Mode
/// Register: MODE0
/// Field: EXNW_MODE [4:5]
enum class SMC_MODE0_EXNW_MODE : uint32_t {
    DISABLED = 0x0,
    FROZEN = 0x2,
    READY = 0x3,
};

/// Data Bus Width
/// Register: MODE0
/// Field: DBW [12:12]
enum class SMC_MODE0_DBW : uint32_t {
    BIT_8 = 0x0,
    BIT_16 = 0x1,
};

/// Selection of the Control Signal for Read Operation
/// Register: MODE1
/// Field: READ_MODE [0:0]
enum class SMC_MODE1_READ_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NRD_CTRL = 0x1,
};

/// Selection of the Control Signal for Write Operation
/// Register: MODE1
/// Field: WRITE_MODE [1:1]
enum class SMC_MODE1_WRITE_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NWE_CTRL = 0x1,
};

/// NWAIT Mode
/// Register: MODE1
/// Field: EXNW_MODE [4:5]
enum class SMC_MODE1_EXNW_MODE : uint32_t {
    DISABLED = 0x0,
    FROZEN = 0x2,
    READY = 0x3,
};

/// Data Bus Width
/// Register: MODE1
/// Field: DBW [12:12]
enum class SMC_MODE1_DBW : uint32_t {
    BIT_8 = 0x0,
    BIT_16 = 0x1,
};

/// Selection of the Control Signal for Read Operation
/// Register: MODE2
/// Field: READ_MODE [0:0]
enum class SMC_MODE2_READ_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NRD_CTRL = 0x1,
};

/// Selection of the Control Signal for Write Operation
/// Register: MODE2
/// Field: WRITE_MODE [1:1]
enum class SMC_MODE2_WRITE_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NWE_CTRL = 0x1,
};

/// NWAIT Mode
/// Register: MODE2
/// Field: EXNW_MODE [4:5]
enum class SMC_MODE2_EXNW_MODE : uint32_t {
    DISABLED = 0x0,
    FROZEN = 0x2,
    READY = 0x3,
};

/// Data Bus Width
/// Register: MODE2
/// Field: DBW [12:12]
enum class SMC_MODE2_DBW : uint32_t {
    BIT_8 = 0x0,
    BIT_16 = 0x1,
};

/// Selection of the Control Signal for Read Operation
/// Register: MODE3
/// Field: READ_MODE [0:0]
enum class SMC_MODE3_READ_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NRD_CTRL = 0x1,
};

/// Selection of the Control Signal for Write Operation
/// Register: MODE3
/// Field: WRITE_MODE [1:1]
enum class SMC_MODE3_WRITE_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NWE_CTRL = 0x1,
};

/// NWAIT Mode
/// Register: MODE3
/// Field: EXNW_MODE [4:5]
enum class SMC_MODE3_EXNW_MODE : uint32_t {
    DISABLED = 0x0,
    FROZEN = 0x2,
    READY = 0x3,
};

/// Data Bus Width
/// Register: MODE3
/// Field: DBW [12:12]
enum class SMC_MODE3_DBW : uint32_t {
    BIT_8 = 0x0,
    BIT_16 = 0x1,
};

/// Selection of the Control Signal for Read Operation
/// Register: MODE4
/// Field: READ_MODE [0:0]
enum class SMC_MODE4_READ_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NRD_CTRL = 0x1,
};

/// Selection of the Control Signal for Write Operation
/// Register: MODE4
/// Field: WRITE_MODE [1:1]
enum class SMC_MODE4_WRITE_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NWE_CTRL = 0x1,
};

/// NWAIT Mode
/// Register: MODE4
/// Field: EXNW_MODE [4:5]
enum class SMC_MODE4_EXNW_MODE : uint32_t {
    DISABLED = 0x0,
    FROZEN = 0x2,
    READY = 0x3,
};

/// Data Bus Width
/// Register: MODE4
/// Field: DBW [12:12]
enum class SMC_MODE4_DBW : uint32_t {
    BIT_8 = 0x0,
    BIT_16 = 0x1,
};

/// Selection of the Control Signal for Read Operation
/// Register: MODE5
/// Field: READ_MODE [0:0]
enum class SMC_MODE5_READ_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NRD_CTRL = 0x1,
};

/// Selection of the Control Signal for Write Operation
/// Register: MODE5
/// Field: WRITE_MODE [1:1]
enum class SMC_MODE5_WRITE_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NWE_CTRL = 0x1,
};

/// NWAIT Mode
/// Register: MODE5
/// Field: EXNW_MODE [4:5]
enum class SMC_MODE5_EXNW_MODE : uint32_t {
    DISABLED = 0x0,
    FROZEN = 0x2,
    READY = 0x3,
};

/// Data Bus Width
/// Register: MODE5
/// Field: DBW [12:12]
enum class SMC_MODE5_DBW : uint32_t {
    BIT_8 = 0x0,
    BIT_16 = 0x1,
};

/// Selection of the Control Signal for Read Operation
/// Register: MODE6
/// Field: READ_MODE [0:0]
enum class SMC_MODE6_READ_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NRD_CTRL = 0x1,
};

/// Selection of the Control Signal for Write Operation
/// Register: MODE6
/// Field: WRITE_MODE [1:1]
enum class SMC_MODE6_WRITE_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NWE_CTRL = 0x1,
};

/// NWAIT Mode
/// Register: MODE6
/// Field: EXNW_MODE [4:5]
enum class SMC_MODE6_EXNW_MODE : uint32_t {
    DISABLED = 0x0,
    FROZEN = 0x2,
    READY = 0x3,
};

/// Data Bus Width
/// Register: MODE6
/// Field: DBW [12:12]
enum class SMC_MODE6_DBW : uint32_t {
    BIT_8 = 0x0,
    BIT_16 = 0x1,
};

/// Selection of the Control Signal for Read Operation
/// Register: MODE7
/// Field: READ_MODE [0:0]
enum class SMC_MODE7_READ_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NRD_CTRL = 0x1,
};

/// Selection of the Control Signal for Write Operation
/// Register: MODE7
/// Field: WRITE_MODE [1:1]
enum class SMC_MODE7_WRITE_MODE : uint32_t {
    NCS_CTRL = 0x0,
    NWE_CTRL = 0x1,
};

/// NWAIT Mode
/// Register: MODE7
/// Field: EXNW_MODE [4:5]
enum class SMC_MODE7_EXNW_MODE : uint32_t {
    DISABLED = 0x0,
    FROZEN = 0x2,
    READY = 0x3,
};

/// Data Bus Width
/// Register: MODE7
/// Field: DBW [12:12]
enum class SMC_MODE7_DBW : uint32_t {
    BIT_8 = 0x0,
    BIT_16 = 0x1,
};

/// Write Protection KEY Password
/// Register: WPCR
/// Field: WP_KEY [8:31]
enum class SMC_WPCR_WP_KEY : uint32_t {
    PASSWD = 0x534D43,
};

// ----------------------------------------------------------------------------
// SPI0 - Serial Peripheral Interface 0
// ----------------------------------------------------------------------------

/// Bits Per Transfer
/// Register: CSR[4]
/// Field: BITS [4:7]
enum class SPI0_CSR_4_BITS : uint32_t {
    VAL_8_BIT = 0x0,  // 8_BIT
    VAL_9_BIT = 0x1,  // 9_BIT
    VAL_10_BIT = 0x2,  // 10_BIT
    VAL_11_BIT = 0x3,  // 11_BIT
    VAL_12_BIT = 0x4,  // 12_BIT
    VAL_13_BIT = 0x5,  // 13_BIT
    VAL_14_BIT = 0x6,  // 14_BIT
    VAL_15_BIT = 0x7,  // 15_BIT
    VAL_16_BIT = 0x8,  // 16_BIT
};

/// Write Protect Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class SPI0_WPMR_WPKEY : uint32_t {
    PASSWD = 0x535049,
};

// ----------------------------------------------------------------------------
// SSC - Synchronous Serial Controller
// ----------------------------------------------------------------------------

/// Receive Clock Selection
/// Register: RCMR
/// Field: CKS [0:1]
enum class SSC_RCMR_CKS : uint32_t {
    MCK = 0x0,
    TK = 0x1,
    RK = 0x2,
};

/// Receive Clock Output Mode Selection
/// Register: RCMR
/// Field: CKO [2:4]
enum class SSC_RCMR_CKO : uint32_t {
    NONE = 0x0,
    CONTINUOUS = 0x1,
    TRANSFER = 0x2,
};

/// Receive Clock Gating Selection
/// Register: RCMR
/// Field: CKG [6:7]
enum class SSC_RCMR_CKG : uint32_t {
    CONTINUOUS = 0x0,
    EN_RF_LOW = 0x1,
    EN_RF_HIGH = 0x2,
};

/// Receive Start Selection
/// Register: RCMR
/// Field: START [8:11]
enum class SSC_RCMR_START : uint32_t {
    CONTINUOUS = 0x0,
    TRANSMIT = 0x1,
    RF_LOW = 0x2,
    RF_HIGH = 0x3,
    RF_FALLING = 0x4,
    RF_RISING = 0x5,
    RF_LEVEL = 0x6,
    RF_EDGE = 0x7,
    CMP_0 = 0x8,
};

/// Receive Frame Sync Output Selection
/// Register: RFMR
/// Field: FSOS [20:22]
enum class SSC_RFMR_FSOS : uint32_t {
    NONE = 0x0,
    NEGATIVE = 0x1,
    POSITIVE = 0x2,
    LOW = 0x3,
    HIGH = 0x4,
    TOGGLING = 0x5,
};

/// Frame Sync Edge Detection
/// Register: RFMR
/// Field: FSEDGE [24:24]
enum class SSC_RFMR_FSEDGE : uint32_t {
    POSITIVE = 0x0,
    NEGATIVE = 0x1,
};

/// Transmit Clock Selection
/// Register: TCMR
/// Field: CKS [0:1]
enum class SSC_TCMR_CKS : uint32_t {
    MCK = 0x0,
    RK = 0x1,
    TK = 0x2,
};

/// Transmit Clock Output Mode Selection
/// Register: TCMR
/// Field: CKO [2:4]
enum class SSC_TCMR_CKO : uint32_t {
    NONE = 0x0,
    CONTINUOUS = 0x1,
    TRANSFER = 0x2,
};

/// Transmit Clock Gating Selection
/// Register: TCMR
/// Field: CKG [6:7]
enum class SSC_TCMR_CKG : uint32_t {
    CONTINUOUS = 0x0,
    EN_TF_LOW = 0x1,
    EN_TF_HIGH = 0x2,
};

/// Transmit Start Selection
/// Register: TCMR
/// Field: START [8:11]
enum class SSC_TCMR_START : uint32_t {
    CONTINUOUS = 0x0,
    RECEIVE = 0x1,
    TF_LOW = 0x2,
    TF_HIGH = 0x3,
    TF_FALLING = 0x4,
    TF_RISING = 0x5,
    TF_LEVEL = 0x6,
    TF_EDGE = 0x7,
};

/// Transmit Frame Sync Output Selection
/// Register: TFMR
/// Field: FSOS [20:22]
enum class SSC_TFMR_FSOS : uint32_t {
    NONE = 0x0,
    NEGATIVE = 0x1,
    POSITIVE = 0x2,
    LOW = 0x3,
    HIGH = 0x4,
    TOGGLING = 0x5,
};

/// Frame Sync Edge Detection
/// Register: TFMR
/// Field: FSEDGE [24:24]
enum class SSC_TFMR_FSEDGE : uint32_t {
    POSITIVE = 0x0,
    NEGATIVE = 0x1,
};

/// Write Protect KEY
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class SSC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x535343,
};

// ----------------------------------------------------------------------------
// SUPC - Supply Controller
// ----------------------------------------------------------------------------

/// Voltage Regulator Off
/// Register: CR
/// Field: VROFF [2:2]
enum class SUPC_CR_VROFF : uint32_t {
    NO_EFFECT = 0x0,
    STOP_VREG = 0x1,
};

/// Crystal Oscillator Select
/// Register: CR
/// Field: XTALSEL [3:3]
enum class SUPC_CR_XTALSEL : uint32_t {
    NO_EFFECT = 0x0,
    CRYSTAL_SEL = 0x1,
};

/// Password
/// Register: CR
/// Field: KEY [24:31]
enum class SUPC_CR_KEY : uint32_t {
    PASSWD = 0xA5,
};

/// Supply Monitor Sampling Period
/// Register: SMMR
/// Field: SMSMPL [8:10]
enum class SUPC_SMMR_SMSMPL : uint32_t {
    SMD = 0x0,
    CSM = 0x1,
    VAL_32SLCK = 0x2,  // 32SLCK
    VAL_256SLCK = 0x3,  // 256SLCK
    VAL_2048SLCK = 0x4,  // 2048SLCK
};

/// Supply Monitor Reset Enable
/// Register: SMMR
/// Field: SMRSTEN [12:12]
enum class SUPC_SMMR_SMRSTEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Supply Monitor Interrupt Enable
/// Register: SMMR
/// Field: SMIEN [13:13]
enum class SUPC_SMMR_SMIEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Brownout Detector Reset Enable
/// Register: MR
/// Field: BODRSTEN [12:12]
enum class SUPC_MR_BODRSTEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Brownout Detector Disable
/// Register: MR
/// Field: BODDIS [13:13]
enum class SUPC_MR_BODDIS : uint32_t {
    ENABLE = 0x0,
    DISABLE = 0x1,
};

/// VDDIO Ready
/// Register: MR
/// Field: VDDIORDY [14:14]
enum class SUPC_MR_VDDIORDY : uint32_t {
    VDDIO_REMOVED = 0x0,
    VDDIO_PRESENT = 0x1,
};

/// Oscillator Bypass
/// Register: MR
/// Field: OSCBYPASS [20:20]
enum class SUPC_MR_OSCBYPASS : uint32_t {
    NO_EFFECT = 0x0,
    BYPASS = 0x1,
};

/// Password Key
/// Register: MR
/// Field: KEY [24:31]
enum class SUPC_MR_KEY : uint32_t {
    PASSWD = 0xA5,
};

/// Force Wake-up Enable
/// Register: WUMR
/// Field: FWUPEN [0:0]
enum class SUPC_WUMR_FWUPEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Supply Monitor Wake-up Enable
/// Register: WUMR
/// Field: SMEN [1:1]
enum class SUPC_WUMR_SMEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Real Time Timer Wake-up Enable
/// Register: WUMR
/// Field: RTTEN [2:2]
enum class SUPC_WUMR_RTTEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Real Time Clock Wake-up Enable
/// Register: WUMR
/// Field: RTCEN [3:3]
enum class SUPC_WUMR_RTCEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Force Wake-up Debouncer Period
/// Register: WUMR
/// Field: FWUPDBC [8:10]
enum class SUPC_WUMR_FWUPDBC : uint32_t {
    IMMEDIATE = 0x0,
    VAL_3_SCLK = 0x1,  // 3_SCLK
    VAL_32_SCLK = 0x2,  // 32_SCLK
    VAL_512_SCLK = 0x3,  // 512_SCLK
    VAL_4096_SCLK = 0x4,  // 4096_SCLK
    VAL_32768_SCLK = 0x5,  // 32768_SCLK
};

/// Wake-up Inputs Debouncer Period
/// Register: WUMR
/// Field: WKUPDBC [12:14]
enum class SUPC_WUMR_WKUPDBC : uint32_t {
    IMMEDIATE = 0x0,
    VAL_3_SCLK = 0x1,  // 3_SCLK
    VAL_32_SCLK = 0x2,  // 32_SCLK
    VAL_512_SCLK = 0x3,  // 512_SCLK
    VAL_4096_SCLK = 0x4,  // 4096_SCLK
    VAL_32768_SCLK = 0x5,  // 32768_SCLK
};

/// Wake-up Input Enable 0
/// Register: WUIR
/// Field: WKUPEN0 [0:0]
enum class SUPC_WUIR_WKUPEN0 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 1
/// Register: WUIR
/// Field: WKUPEN1 [1:1]
enum class SUPC_WUIR_WKUPEN1 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 2
/// Register: WUIR
/// Field: WKUPEN2 [2:2]
enum class SUPC_WUIR_WKUPEN2 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 3
/// Register: WUIR
/// Field: WKUPEN3 [3:3]
enum class SUPC_WUIR_WKUPEN3 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 4
/// Register: WUIR
/// Field: WKUPEN4 [4:4]
enum class SUPC_WUIR_WKUPEN4 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 5
/// Register: WUIR
/// Field: WKUPEN5 [5:5]
enum class SUPC_WUIR_WKUPEN5 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 6
/// Register: WUIR
/// Field: WKUPEN6 [6:6]
enum class SUPC_WUIR_WKUPEN6 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 7
/// Register: WUIR
/// Field: WKUPEN7 [7:7]
enum class SUPC_WUIR_WKUPEN7 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 8
/// Register: WUIR
/// Field: WKUPEN8 [8:8]
enum class SUPC_WUIR_WKUPEN8 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 9
/// Register: WUIR
/// Field: WKUPEN9 [9:9]
enum class SUPC_WUIR_WKUPEN9 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 10
/// Register: WUIR
/// Field: WKUPEN10 [10:10]
enum class SUPC_WUIR_WKUPEN10 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 11
/// Register: WUIR
/// Field: WKUPEN11 [11:11]
enum class SUPC_WUIR_WKUPEN11 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 12
/// Register: WUIR
/// Field: WKUPEN12 [12:12]
enum class SUPC_WUIR_WKUPEN12 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 13
/// Register: WUIR
/// Field: WKUPEN13 [13:13]
enum class SUPC_WUIR_WKUPEN13 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 14
/// Register: WUIR
/// Field: WKUPEN14 [14:14]
enum class SUPC_WUIR_WKUPEN14 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 15
/// Register: WUIR
/// Field: WKUPEN15 [15:15]
enum class SUPC_WUIR_WKUPEN15 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Type 0
/// Register: WUIR
/// Field: WKUPT0 [16:16]
enum class SUPC_WUIR_WKUPT0 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 1
/// Register: WUIR
/// Field: WKUPT1 [17:17]
enum class SUPC_WUIR_WKUPT1 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 2
/// Register: WUIR
/// Field: WKUPT2 [18:18]
enum class SUPC_WUIR_WKUPT2 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 3
/// Register: WUIR
/// Field: WKUPT3 [19:19]
enum class SUPC_WUIR_WKUPT3 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 4
/// Register: WUIR
/// Field: WKUPT4 [20:20]
enum class SUPC_WUIR_WKUPT4 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 5
/// Register: WUIR
/// Field: WKUPT5 [21:21]
enum class SUPC_WUIR_WKUPT5 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 6
/// Register: WUIR
/// Field: WKUPT6 [22:22]
enum class SUPC_WUIR_WKUPT6 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 7
/// Register: WUIR
/// Field: WKUPT7 [23:23]
enum class SUPC_WUIR_WKUPT7 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 8
/// Register: WUIR
/// Field: WKUPT8 [24:24]
enum class SUPC_WUIR_WKUPT8 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 9
/// Register: WUIR
/// Field: WKUPT9 [25:25]
enum class SUPC_WUIR_WKUPT9 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 10
/// Register: WUIR
/// Field: WKUPT10 [26:26]
enum class SUPC_WUIR_WKUPT10 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 11
/// Register: WUIR
/// Field: WKUPT11 [27:27]
enum class SUPC_WUIR_WKUPT11 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 12
/// Register: WUIR
/// Field: WKUPT12 [28:28]
enum class SUPC_WUIR_WKUPT12 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 13
/// Register: WUIR
/// Field: WKUPT13 [29:29]
enum class SUPC_WUIR_WKUPT13 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 14
/// Register: WUIR
/// Field: WKUPT14 [30:30]
enum class SUPC_WUIR_WKUPT14 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// Wake-up Input Type 15
/// Register: WUIR
/// Field: WKUPT15 [31:31]
enum class SUPC_WUIR_WKUPT15 : uint32_t {
    HIGH_TO_LOW = 0x0,
    LOW_TO_HIGH = 0x1,
};

/// FWUP Wake-up Status
/// Register: SR
/// Field: FWUPS [0:0]
enum class SUPC_SR_FWUPS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// WKUP Wake-up Status
/// Register: SR
/// Field: WKUPS [1:1]
enum class SUPC_SR_WKUPS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Supply Monitor Detection Wake-up Status
/// Register: SR
/// Field: SMWS [2:2]
enum class SUPC_SR_SMWS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Brownout Detector Reset Status
/// Register: SR
/// Field: BODRSTS [3:3]
enum class SUPC_SR_BODRSTS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Supply Monitor Reset Status
/// Register: SR
/// Field: SMRSTS [4:4]
enum class SUPC_SR_SMRSTS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Supply Monitor Status
/// Register: SR
/// Field: SMS [5:5]
enum class SUPC_SR_SMS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Supply Monitor Output Status
/// Register: SR
/// Field: SMOS [6:6]
enum class SUPC_SR_SMOS : uint32_t {
    HIGH = 0x0,
    LOW = 0x1,
};

/// 32-kHz Oscillator Selection Status
/// Register: SR
/// Field: OSCSEL [7:7]
enum class SUPC_SR_OSCSEL : uint32_t {
    RC = 0x0,
    CRYST = 0x1,
};

/// FWUP Input Status
/// Register: SR
/// Field: FWUPIS [12:12]
enum class SUPC_SR_FWUPIS : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// WKUP Input Status 0
/// Register: SR
/// Field: WKUPIS0 [16:16]
enum class SUPC_SR_WKUPIS0 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 1
/// Register: SR
/// Field: WKUPIS1 [17:17]
enum class SUPC_SR_WKUPIS1 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 2
/// Register: SR
/// Field: WKUPIS2 [18:18]
enum class SUPC_SR_WKUPIS2 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 3
/// Register: SR
/// Field: WKUPIS3 [19:19]
enum class SUPC_SR_WKUPIS3 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 4
/// Register: SR
/// Field: WKUPIS4 [20:20]
enum class SUPC_SR_WKUPIS4 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 5
/// Register: SR
/// Field: WKUPIS5 [21:21]
enum class SUPC_SR_WKUPIS5 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 6
/// Register: SR
/// Field: WKUPIS6 [22:22]
enum class SUPC_SR_WKUPIS6 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 7
/// Register: SR
/// Field: WKUPIS7 [23:23]
enum class SUPC_SR_WKUPIS7 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 8
/// Register: SR
/// Field: WKUPIS8 [24:24]
enum class SUPC_SR_WKUPIS8 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 9
/// Register: SR
/// Field: WKUPIS9 [25:25]
enum class SUPC_SR_WKUPIS9 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 10
/// Register: SR
/// Field: WKUPIS10 [26:26]
enum class SUPC_SR_WKUPIS10 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 11
/// Register: SR
/// Field: WKUPIS11 [27:27]
enum class SUPC_SR_WKUPIS11 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 12
/// Register: SR
/// Field: WKUPIS12 [28:28]
enum class SUPC_SR_WKUPIS12 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 13
/// Register: SR
/// Field: WKUPIS13 [29:29]
enum class SUPC_SR_WKUPIS13 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 14
/// Register: SR
/// Field: WKUPIS14 [30:30]
enum class SUPC_SR_WKUPIS14 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUP Input Status 15
/// Register: SR
/// Field: WKUPIS15 [31:31]
enum class SUPC_SR_WKUPIS15 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

// ----------------------------------------------------------------------------
// TC0 - Timer Counter 0
// ----------------------------------------------------------------------------

/// Clock Selection
/// Register: CMR0
/// Field: TCCLKS [0:2]
enum class TC0_CMR0_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR0
/// Field: BURST [4:5]
enum class TC0_CMR0_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR0
/// Field: ETRGEDG [8:9]
enum class TC0_CMR0_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR0
/// Field: LDRA [16:17]
enum class TC0_CMR0_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR0
/// Field: LDRB [18:19]
enum class TC0_CMR0_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC0_CMR0_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC0_CMR0_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC0_CMR0_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC0_CMR0_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC0_CMR0_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC0_CMR0_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC0_CMR0_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC0_CMR0_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC0_CMR0_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC0_CMR0_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC0_CMR0_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC0_CMR0_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC0_CMR0_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Clock Selection
/// Register: CMR1
/// Field: TCCLKS [0:2]
enum class TC0_CMR1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR1
/// Field: BURST [4:5]
enum class TC0_CMR1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR1
/// Field: ETRGEDG [8:9]
enum class TC0_CMR1_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR1
/// Field: LDRA [16:17]
enum class TC0_CMR1_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR1
/// Field: LDRB [18:19]
enum class TC0_CMR1_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC0_CMR1_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC0_CMR1_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC0_CMR1_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC0_CMR1_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC0_CMR1_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC0_CMR1_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC0_CMR1_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC0_CMR1_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC0_CMR1_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC0_CMR1_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC0_CMR1_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC0_CMR1_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC0_CMR1_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Clock Selection
/// Register: CMR2
/// Field: TCCLKS [0:2]
enum class TC0_CMR2_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR2
/// Field: BURST [4:5]
enum class TC0_CMR2_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR2
/// Field: ETRGEDG [8:9]
enum class TC0_CMR2_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR2
/// Field: LDRA [16:17]
enum class TC0_CMR2_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR2
/// Field: LDRB [18:19]
enum class TC0_CMR2_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC0_CMR2_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC0_CMR2_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC0_CMR2_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC0_CMR2_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC0_CMR2_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC0_CMR2_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC0_CMR2_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC0_CMR2_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC0_CMR2_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC0_CMR2_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC0_CMR2_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC0_CMR2_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC0_CMR2_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Clock Signal 0 Selection
/// Register: BMR
/// Field: TC0XC0S [0:1]
enum class TC0_BMR_TC0XC0S : uint32_t {
    TCLK0 = 0x0,
    TIOA1 = 0x2,
    TIOA2 = 0x3,
};

/// External Clock Signal 1 Selection
/// Register: BMR
/// Field: TC1XC1S [2:3]
enum class TC0_BMR_TC1XC1S : uint32_t {
    TCLK1 = 0x0,
    TIOA0 = 0x2,
    TIOA2 = 0x3,
};

/// External Clock Signal 2 Selection
/// Register: BMR
/// Field: TC2XC2S [4:5]
enum class TC0_BMR_TC2XC2S : uint32_t {
    TCLK2 = 0x0,
    TIOA1 = 0x2,
    TIOA2 = 0x3,
};

/// Write Protect KEY
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class TC0_WPMR_WPKEY : uint32_t {
    PASSWD = 0x54494D,
};

// ----------------------------------------------------------------------------
// TC1 - Timer Counter 1
// ----------------------------------------------------------------------------

/// Clock Selection
/// Register: CMR0
/// Field: TCCLKS [0:2]
enum class TC1_CMR0_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR0
/// Field: BURST [4:5]
enum class TC1_CMR0_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR0
/// Field: ETRGEDG [8:9]
enum class TC1_CMR0_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR0
/// Field: LDRA [16:17]
enum class TC1_CMR0_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR0
/// Field: LDRB [18:19]
enum class TC1_CMR0_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC1_CMR0_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC1_CMR0_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC1_CMR0_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC1_CMR0_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC1_CMR0_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC1_CMR0_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC1_CMR0_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC1_CMR0_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC1_CMR0_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC1_CMR0_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC1_CMR0_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC1_CMR0_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC1_CMR0_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Clock Selection
/// Register: CMR1
/// Field: TCCLKS [0:2]
enum class TC1_CMR1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR1
/// Field: BURST [4:5]
enum class TC1_CMR1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR1
/// Field: ETRGEDG [8:9]
enum class TC1_CMR1_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR1
/// Field: LDRA [16:17]
enum class TC1_CMR1_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR1
/// Field: LDRB [18:19]
enum class TC1_CMR1_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC1_CMR1_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC1_CMR1_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC1_CMR1_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC1_CMR1_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC1_CMR1_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC1_CMR1_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC1_CMR1_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC1_CMR1_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC1_CMR1_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC1_CMR1_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC1_CMR1_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC1_CMR1_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC1_CMR1_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Clock Selection
/// Register: CMR2
/// Field: TCCLKS [0:2]
enum class TC1_CMR2_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR2
/// Field: BURST [4:5]
enum class TC1_CMR2_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR2
/// Field: ETRGEDG [8:9]
enum class TC1_CMR2_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR2
/// Field: LDRA [16:17]
enum class TC1_CMR2_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR2
/// Field: LDRB [18:19]
enum class TC1_CMR2_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC1_CMR2_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC1_CMR2_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC1_CMR2_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC1_CMR2_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC1_CMR2_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC1_CMR2_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC1_CMR2_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC1_CMR2_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC1_CMR2_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC1_CMR2_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC1_CMR2_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC1_CMR2_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC1_CMR2_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Clock Signal 0 Selection
/// Register: BMR
/// Field: TC0XC0S [0:1]
enum class TC1_BMR_TC0XC0S : uint32_t {
    TCLK0 = 0x0,
    TIOA1 = 0x2,
    TIOA2 = 0x3,
};

/// External Clock Signal 1 Selection
/// Register: BMR
/// Field: TC1XC1S [2:3]
enum class TC1_BMR_TC1XC1S : uint32_t {
    TCLK1 = 0x0,
    TIOA0 = 0x2,
    TIOA2 = 0x3,
};

/// External Clock Signal 2 Selection
/// Register: BMR
/// Field: TC2XC2S [4:5]
enum class TC1_BMR_TC2XC2S : uint32_t {
    TCLK2 = 0x0,
    TIOA1 = 0x2,
    TIOA2 = 0x3,
};

/// Write Protect KEY
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class TC1_WPMR_WPKEY : uint32_t {
    PASSWD = 0x54494D,
};

// ----------------------------------------------------------------------------
// TC2 - Timer Counter 2
// ----------------------------------------------------------------------------

/// Clock Selection
/// Register: CMR0
/// Field: TCCLKS [0:2]
enum class TC2_CMR0_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR0
/// Field: BURST [4:5]
enum class TC2_CMR0_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR0
/// Field: ETRGEDG [8:9]
enum class TC2_CMR0_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR0
/// Field: LDRA [16:17]
enum class TC2_CMR0_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR0
/// Field: LDRB [18:19]
enum class TC2_CMR0_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC2_CMR0_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC2_CMR0_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC2_CMR0_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC2_CMR0_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR0_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC2_CMR0_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC2_CMR0_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC2_CMR0_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC2_CMR0_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR0_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC2_CMR0_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC2_CMR0_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC2_CMR0_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC2_CMR0_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR0_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC2_CMR0_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Clock Selection
/// Register: CMR1
/// Field: TCCLKS [0:2]
enum class TC2_CMR1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR1
/// Field: BURST [4:5]
enum class TC2_CMR1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR1
/// Field: ETRGEDG [8:9]
enum class TC2_CMR1_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR1
/// Field: LDRA [16:17]
enum class TC2_CMR1_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR1
/// Field: LDRB [18:19]
enum class TC2_CMR1_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC2_CMR1_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC2_CMR1_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC2_CMR1_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC2_CMR1_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR1_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC2_CMR1_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC2_CMR1_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC2_CMR1_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC2_CMR1_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR1_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC2_CMR1_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC2_CMR1_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC2_CMR1_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC2_CMR1_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR1_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC2_CMR1_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Clock Selection
/// Register: CMR2
/// Field: TCCLKS [0:2]
enum class TC2_CMR2_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR2
/// Field: BURST [4:5]
enum class TC2_CMR2_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR2
/// Field: ETRGEDG [8:9]
enum class TC2_CMR2_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR2
/// Field: LDRA [16:17]
enum class TC2_CMR2_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR2
/// Field: LDRB [18:19]
enum class TC2_CMR2_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Clock Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: TCCLKS [0:2]
enum class TC2_CMR2_WAVE_EQ_1_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: BURST [4:5]
enum class TC2_CMR2_WAVE_EQ_1_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: EEVTEDG [8:9]
enum class TC2_CMR2_WAVE_EQ_1_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: EEVT [10:11]
enum class TC2_CMR2_WAVE_EQ_1_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR2_WAVE_EQ_1
/// Field: WAVSEL [13:14]
enum class TC2_CMR2_WAVE_EQ_1_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ACPA [16:17]
enum class TC2_CMR2_WAVE_EQ_1_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ACPC [18:19]
enum class TC2_CMR2_WAVE_EQ_1_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: AEEVT [20:21]
enum class TC2_CMR2_WAVE_EQ_1_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOA
/// Register: CMR2_WAVE_EQ_1
/// Field: ASWTRG [22:23]
enum class TC2_CMR2_WAVE_EQ_1_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BCPB [24:25]
enum class TC2_CMR2_WAVE_EQ_1_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BCPC [26:27]
enum class TC2_CMR2_WAVE_EQ_1_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BEEVT [28:29]
enum class TC2_CMR2_WAVE_EQ_1_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOB
/// Register: CMR2_WAVE_EQ_1
/// Field: BSWTRG [30:31]
enum class TC2_CMR2_WAVE_EQ_1_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Clock Signal 0 Selection
/// Register: BMR
/// Field: TC0XC0S [0:1]
enum class TC2_BMR_TC0XC0S : uint32_t {
    TCLK0 = 0x0,
    TIOA1 = 0x2,
    TIOA2 = 0x3,
};

/// External Clock Signal 1 Selection
/// Register: BMR
/// Field: TC1XC1S [2:3]
enum class TC2_BMR_TC1XC1S : uint32_t {
    TCLK1 = 0x0,
    TIOA0 = 0x2,
    TIOA2 = 0x3,
};

/// External Clock Signal 2 Selection
/// Register: BMR
/// Field: TC2XC2S [4:5]
enum class TC2_BMR_TC2XC2S : uint32_t {
    TCLK2 = 0x0,
    TIOA1 = 0x2,
    TIOA2 = 0x3,
};

/// Write Protect KEY
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class TC2_WPMR_WPKEY : uint32_t {
    PASSWD = 0x54494D,
};

// ----------------------------------------------------------------------------
// TWI0 - Two-wire Interface 0
// ----------------------------------------------------------------------------

/// Internal Device Address Size
/// Register: MMR
/// Field: IADRSZ [8:9]
enum class TWI0_MMR_IADRSZ : uint32_t {
    NONE = 0x0,
    VAL_1_BYTE = 0x1,  // 1_BYTE
    VAL_2_BYTE = 0x2,  // 2_BYTE
    VAL_3_BYTE = 0x3,  // 3_BYTE
};

// ----------------------------------------------------------------------------
// TWI1 - Two-wire Interface 1
// ----------------------------------------------------------------------------

/// Internal Device Address Size
/// Register: MMR
/// Field: IADRSZ [8:9]
enum class TWI1_MMR_IADRSZ : uint32_t {
    NONE = 0x0,
    VAL_1_BYTE = 0x1,  // 1_BYTE
    VAL_2_BYTE = 0x2,  // 2_BYTE
    VAL_3_BYTE = 0x3,  // 3_BYTE
};

// ----------------------------------------------------------------------------
// UART - Universal Asynchronous Receiver Transmitter
// ----------------------------------------------------------------------------

/// Parity Type
/// Register: MR
/// Field: PAR [9:11]
enum class UART_MR_PAR : uint32_t {
    EVEN = 0x0,
    ODD = 0x1,
    SPACE = 0x2,
    MARK = 0x3,
    NO = 0x4,
};

/// Channel Mode
/// Register: MR
/// Field: CHMODE [14:15]
enum class UART_MR_CHMODE : uint32_t {
    NORMAL = 0x0,
    AUTOMATIC = 0x1,
    LOCAL_LOOPBACK = 0x2,
    REMOTE_LOOPBACK = 0x3,
};

// ----------------------------------------------------------------------------
// UOTGHS - USB On-The-Go Interface
// ----------------------------------------------------------------------------

/// Mode Configuration
/// Register: DEVCTRL
/// Field: SPDCONF [10:11]
enum class UOTGHS_DEVCTRL_SPDCONF : uint32_t {
    NORMAL = 0x0,
    LOW_POWER = 0x1,
    HIGH_SPEED = 0x2,
    FORCED_FS = 0x3,
};

/// Endpoint Banks
/// Register: DEVEPTCFG[10]
/// Field: EPBK [2:3]
enum class UOTGHS_DEVEPTCFG_10_EPBK : uint32_t {
    VAL_1_BANK = 0x0,  // 1_BANK
    VAL_2_BANK = 0x1,  // 2_BANK
    VAL_3_BANK = 0x2,  // 3_BANK
};

/// Endpoint Size
/// Register: DEVEPTCFG[10]
/// Field: EPSIZE [4:6]
enum class UOTGHS_DEVEPTCFG_10_EPSIZE : uint32_t {
    VAL_8_BYTE = 0x0,  // 8_BYTE
    VAL_16_BYTE = 0x1,  // 16_BYTE
    VAL_32_BYTE = 0x2,  // 32_BYTE
    VAL_64_BYTE = 0x3,  // 64_BYTE
    VAL_128_BYTE = 0x4,  // 128_BYTE
    VAL_256_BYTE = 0x5,  // 256_BYTE
    VAL_512_BYTE = 0x6,  // 512_BYTE
    VAL_1024_BYTE = 0x7,  // 1024_BYTE
};

/// Endpoint Direction
/// Register: DEVEPTCFG[10]
/// Field: EPDIR [8:8]
enum class UOTGHS_DEVEPTCFG_10_EPDIR : uint32_t {
    OUT = 0x0,
    IN = 0x1,
};

/// Endpoint Type
/// Register: DEVEPTCFG[10]
/// Field: EPTYPE [11:12]
enum class UOTGHS_DEVEPTCFG_10_EPTYPE : uint32_t {
    CTRL = 0x0,
    ISO = 0x1,
    BLK = 0x2,
    INTRPT = 0x3,
};

/// Number of transaction per microframe for isochronous endpoint
/// Register: DEVEPTCFG[10]
/// Field: NBTRANS [13:14]
enum class UOTGHS_DEVEPTCFG_10_NBTRANS : uint32_t {
    VAL_0_TRANS = 0x0,  // 0_TRANS
    VAL_1_TRANS = 0x1,  // 1_TRANS
    VAL_2_TRANS = 0x2,  // 2_TRANS
    VAL_3_TRANS = 0x3,  // 3_TRANS
};

/// Data Toggle Sequence
/// Register: DEVEPTISR[10]
/// Field: DTSEQ [8:9]
enum class UOTGHS_DEVEPTISR_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
    DATA2 = 0x2,
    MDATA = 0x3,
};

/// Number of Busy Banks
/// Register: DEVEPTISR[10]
/// Field: NBUSYBK [12:13]
enum class UOTGHS_DEVEPTISR_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // 0_BUSY
    VAL_1_BUSY = 0x1,  // 1_BUSY
    VAL_2_BUSY = 0x2,  // 2_BUSY
    VAL_3_BUSY = 0x3,  // 3_BUSY
};

/// Current Bank
/// Register: DEVEPTISR[10]
/// Field: CURRBK [14:15]
enum class UOTGHS_DEVEPTISR_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: DEVEPTISR0_ISOENPT
/// Field: DTSEQ [8:9]
enum class UOTGHS_DEVEPTISR0_ISOENPT_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
    DATA2 = 0x2,
    MDATA = 0x3,
};

/// Number of Busy Banks
/// Register: DEVEPTISR0_ISOENPT
/// Field: NBUSYBK [12:13]
enum class UOTGHS_DEVEPTISR0_ISOENPT_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // 0_BUSY
    VAL_1_BUSY = 0x1,  // 1_BUSY
    VAL_2_BUSY = 0x2,  // 2_BUSY
    VAL_3_BUSY = 0x3,  // 3_BUSY
};

/// Current Bank
/// Register: DEVEPTISR0_ISOENPT
/// Field: CURRBK [14:15]
enum class UOTGHS_DEVEPTISR0_ISOENPT_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Mode Configuration
/// Register: HSTCTRL
/// Field: SPDCONF [12:13]
enum class UOTGHS_HSTCTRL_SPDCONF : uint32_t {
    NORMAL = 0x0,
    LOW_POWER = 0x1,
    HIGH_SPEED = 0x2,
    FORCED_FS = 0x3,
};

/// Pipe Banks
/// Register: HSTPIPCFG[10]
/// Field: PBK [2:3]
enum class UOTGHS_HSTPIPCFG_10_PBK : uint32_t {
    VAL_1_BANK = 0x0,  // 1_BANK
    VAL_2_BANK = 0x1,  // 2_BANK
    VAL_3_BANK = 0x2,  // 3_BANK
};

/// Pipe Size
/// Register: HSTPIPCFG[10]
/// Field: PSIZE [4:6]
enum class UOTGHS_HSTPIPCFG_10_PSIZE : uint32_t {
    VAL_8_BYTE = 0x0,  // 8_BYTE
    VAL_16_BYTE = 0x1,  // 16_BYTE
    VAL_32_BYTE = 0x2,  // 32_BYTE
    VAL_64_BYTE = 0x3,  // 64_BYTE
    VAL_128_BYTE = 0x4,  // 128_BYTE
    VAL_256_BYTE = 0x5,  // 256_BYTE
    VAL_512_BYTE = 0x6,  // 512_BYTE
    VAL_1024_BYTE = 0x7,  // 1024_BYTE
};

/// Pipe Token
/// Register: HSTPIPCFG[10]
/// Field: PTOKEN [8:9]
enum class UOTGHS_HSTPIPCFG_10_PTOKEN : uint32_t {
    SETUP = 0x0,
    IN = 0x1,
    OUT = 0x2,
};

/// Pipe Type
/// Register: HSTPIPCFG[10]
/// Field: PTYPE [12:13]
enum class UOTGHS_HSTPIPCFG_10_PTYPE : uint32_t {
    CTRL = 0x0,
    ISO = 0x1,
    BLK = 0x2,
    INTRPT = 0x3,
};

/// Pipe Banks
/// Register: HSTPIPCFG0_HSBOHSCP
/// Field: PBK [2:3]
enum class UOTGHS_HSTPIPCFG0_HSBOHSCP_PBK : uint32_t {
    VAL_1_BANK = 0x0,  // 1_BANK
    VAL_2_BANK = 0x1,  // 2_BANK
    VAL_3_BANK = 0x2,  // 3_BANK
};

/// Pipe Size
/// Register: HSTPIPCFG0_HSBOHSCP
/// Field: PSIZE [4:6]
enum class UOTGHS_HSTPIPCFG0_HSBOHSCP_PSIZE : uint32_t {
    VAL_8_BYTE = 0x0,  // 8_BYTE
    VAL_16_BYTE = 0x1,  // 16_BYTE
    VAL_32_BYTE = 0x2,  // 32_BYTE
    VAL_64_BYTE = 0x3,  // 64_BYTE
    VAL_128_BYTE = 0x4,  // 128_BYTE
    VAL_256_BYTE = 0x5,  // 256_BYTE
    VAL_512_BYTE = 0x6,  // 512_BYTE
    VAL_1024_BYTE = 0x7,  // 1024_BYTE
};

/// Pipe Token
/// Register: HSTPIPCFG0_HSBOHSCP
/// Field: PTOKEN [8:9]
enum class UOTGHS_HSTPIPCFG0_HSBOHSCP_PTOKEN : uint32_t {
    SETUP = 0x0,
    IN = 0x1,
    OUT = 0x2,
};

/// Pipe Type
/// Register: HSTPIPCFG0_HSBOHSCP
/// Field: PTYPE [12:13]
enum class UOTGHS_HSTPIPCFG0_HSBOHSCP_PTYPE : uint32_t {
    CTRL = 0x0,
    BLK = 0x2,
};

/// Data Toggle Sequence
/// Register: HSTPIPISR[10]
/// Field: DTSEQ [8:9]
enum class UOTGHS_HSTPIPISR_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
};

/// Number of Busy Banks
/// Register: HSTPIPISR[10]
/// Field: NBUSYBK [12:13]
enum class UOTGHS_HSTPIPISR_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // 0_BUSY
    VAL_1_BUSY = 0x1,  // 1_BUSY
    VAL_2_BUSY = 0x2,  // 2_BUSY
    VAL_3_BUSY = 0x3,  // 3_BUSY
};

/// Current Bank
/// Register: HSTPIPISR[10]
/// Field: CURRBK [14:15]
enum class UOTGHS_HSTPIPISR_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: HSTPIPISR0_INTPIPES
/// Field: DTSEQ [8:9]
enum class UOTGHS_HSTPIPISR0_INTPIPES_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
};

/// Number of Busy Banks
/// Register: HSTPIPISR0_INTPIPES
/// Field: NBUSYBK [12:13]
enum class UOTGHS_HSTPIPISR0_INTPIPES_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // 0_BUSY
    VAL_1_BUSY = 0x1,  // 1_BUSY
    VAL_2_BUSY = 0x2,  // 2_BUSY
    VAL_3_BUSY = 0x3,  // 3_BUSY
};

/// Current Bank
/// Register: HSTPIPISR0_INTPIPES
/// Field: CURRBK [14:15]
enum class UOTGHS_HSTPIPISR0_INTPIPES_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: HSTPIPISR0_ISOPIPES
/// Field: DTSEQ [8:9]
enum class UOTGHS_HSTPIPISR0_ISOPIPES_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
};

/// Number of Busy Banks
/// Register: HSTPIPISR0_ISOPIPES
/// Field: NBUSYBK [12:13]
enum class UOTGHS_HSTPIPISR0_ISOPIPES_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // 0_BUSY
    VAL_1_BUSY = 0x1,  // 1_BUSY
    VAL_2_BUSY = 0x2,  // 2_BUSY
    VAL_3_BUSY = 0x3,  // 3_BUSY
};

/// Current Bank
/// Register: HSTPIPISR0_ISOPIPES
/// Field: CURRBK [14:15]
enum class UOTGHS_HSTPIPISR0_ISOPIPES_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// UOTGID Pin Enable
/// Register: CTRL
/// Field: UIDE [24:24]
enum class UOTGHS_CTRL_UIDE : uint32_t {
    UIMOD = 0x0,
    UOTGID = 0x1,
};

/// UOTGHS Mode
/// Register: CTRL
/// Field: UIMOD [25:25]
enum class UOTGHS_CTRL_UIMOD : uint32_t {
    HOST = 0x0,
    DEVICE = 0x1,
};

/// Speed Status
/// Register: SR
/// Field: SPEED [12:13]
enum class UOTGHS_SR_SPEED : uint32_t {
    FULL_SPEED = 0x0,
    HIGH_SPEED = 0x1,
    LOW_SPEED = 0x2,
};

/// Dual Role Device State
/// Register: FSM
/// Field: DRDSTATE [0:3]
enum class UOTGHS_FSM_DRDSTATE : uint32_t {
    A_IDLESTATE = 0x0,
    A_WAIT_VRISE = 0x1,
    A_WAIT_BCON = 0x2,
    A_HOST = 0x3,
    A_SUSPEND = 0x4,
    A_PERIPHERAL = 0x5,
    A_WAIT_VFALL = 0x6,
    A_VBUS_ERR = 0x7,
    A_WAIT_DISCHARGE = 0x8,
    B_IDLE = 0x9,
    B_PERIPHERAL = 0xA,
    B_WAIT_BEGIN_HNP = 0xB,
    B_WAIT_DISCHARGE = 0xC,
    B_WAIT_ACON = 0xD,
    B_HOST = 0xE,
    B_SRP_INIT = 0xF,
};

// ----------------------------------------------------------------------------
// USART0 - Universal Synchronous Asynchronous Receiver Transmitter 0
// ----------------------------------------------------------------------------

/// USART Mode of Operation
/// Register: MR
/// Field: USART_MODE [0:3]
enum class USART0_MR_USART_MODE : uint32_t {
    NORMAL = 0x0,
    RS485 = 0x1,
    HW_HANDSHAKING = 0x2,
    IS07816_T_0 = 0x4,
    IS07816_T_1 = 0x6,
    IRDA = 0x8,
    LIN_MASTER = 0xA,
    LIN_SLAVE = 0xB,
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: MR
/// Field: USCLKS [4:5]
enum class USART0_MR_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    SCK = 0x3,
};

/// Character Length
/// Register: MR
/// Field: CHRL [6:7]
enum class USART0_MR_CHRL : uint32_t {
    VAL_5_BIT = 0x0,  // 5_BIT
    VAL_6_BIT = 0x1,  // 6_BIT
    VAL_7_BIT = 0x2,  // 7_BIT
    VAL_8_BIT = 0x3,  // 8_BIT
};

/// Parity Type
/// Register: MR
/// Field: PAR [9:11]
enum class USART0_MR_PAR : uint32_t {
    EVEN = 0x0,
    ODD = 0x1,
    SPACE = 0x2,
    MARK = 0x3,
    NO = 0x4,
    MULTIDROP = 0x6,
};

/// Number of Stop Bits
/// Register: MR
/// Field: NBSTOP [12:13]
enum class USART0_MR_NBSTOP : uint32_t {
    VAL_1_BIT = 0x0,  // 1_BIT
    VAL_1_5_BIT = 0x1,  // 1_5_BIT
    VAL_2_BIT = 0x2,  // 2_BIT
};

/// Channel Mode
/// Register: MR
/// Field: CHMODE [14:15]
enum class USART0_MR_CHMODE : uint32_t {
    NORMAL = 0x0,
    AUTOMATIC = 0x1,
    LOCAL_LOOPBACK = 0x2,
    REMOTE_LOOPBACK = 0x3,
};

/// USART Mode of Operation
/// Register: MR_SPI_MODE
/// Field: USART_MODE [0:3]
enum class USART0_MR_SPI_MODE_USART_MODE : uint32_t {
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: MR_SPI_MODE
/// Field: USCLKS [4:5]
enum class USART0_MR_SPI_MODE_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    SCK = 0x3,
};

/// Character Length
/// Register: MR_SPI_MODE
/// Field: CHRL [6:7]
enum class USART0_MR_SPI_MODE_CHRL : uint32_t {
    VAL_8_BIT = 0x3,  // 8_BIT
};

/// Transmitter Preamble Pattern
/// Register: MAN
/// Field: TX_PP [8:9]
enum class USART0_MAN_TX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// Receiver Preamble Pattern detected
/// Register: MAN
/// Field: RX_PP [24:25]
enum class USART0_MAN_RX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// LIN Node Action
/// Register: LINMR
/// Field: NACT [0:1]
enum class USART0_LINMR_NACT : uint32_t {
    PUBLISH = 0x0,
    SUBSCRIBE = 0x1,
    IGNORE = 0x2,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class USART0_WPMR_WPKEY : uint32_t {
    PASSWD = 0x555341,
};

// ----------------------------------------------------------------------------
// USART1 - Universal Synchronous Asynchronous Receiver Transmitter 1
// ----------------------------------------------------------------------------

/// USART Mode of Operation
/// Register: MR
/// Field: USART_MODE [0:3]
enum class USART1_MR_USART_MODE : uint32_t {
    NORMAL = 0x0,
    RS485 = 0x1,
    HW_HANDSHAKING = 0x2,
    IS07816_T_0 = 0x4,
    IS07816_T_1 = 0x6,
    IRDA = 0x8,
    LIN_MASTER = 0xA,
    LIN_SLAVE = 0xB,
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: MR
/// Field: USCLKS [4:5]
enum class USART1_MR_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    SCK = 0x3,
};

/// Character Length
/// Register: MR
/// Field: CHRL [6:7]
enum class USART1_MR_CHRL : uint32_t {
    VAL_5_BIT = 0x0,  // 5_BIT
    VAL_6_BIT = 0x1,  // 6_BIT
    VAL_7_BIT = 0x2,  // 7_BIT
    VAL_8_BIT = 0x3,  // 8_BIT
};

/// Parity Type
/// Register: MR
/// Field: PAR [9:11]
enum class USART1_MR_PAR : uint32_t {
    EVEN = 0x0,
    ODD = 0x1,
    SPACE = 0x2,
    MARK = 0x3,
    NO = 0x4,
    MULTIDROP = 0x6,
};

/// Number of Stop Bits
/// Register: MR
/// Field: NBSTOP [12:13]
enum class USART1_MR_NBSTOP : uint32_t {
    VAL_1_BIT = 0x0,  // 1_BIT
    VAL_1_5_BIT = 0x1,  // 1_5_BIT
    VAL_2_BIT = 0x2,  // 2_BIT
};

/// Channel Mode
/// Register: MR
/// Field: CHMODE [14:15]
enum class USART1_MR_CHMODE : uint32_t {
    NORMAL = 0x0,
    AUTOMATIC = 0x1,
    LOCAL_LOOPBACK = 0x2,
    REMOTE_LOOPBACK = 0x3,
};

/// USART Mode of Operation
/// Register: MR_SPI_MODE
/// Field: USART_MODE [0:3]
enum class USART1_MR_SPI_MODE_USART_MODE : uint32_t {
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: MR_SPI_MODE
/// Field: USCLKS [4:5]
enum class USART1_MR_SPI_MODE_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    SCK = 0x3,
};

/// Character Length
/// Register: MR_SPI_MODE
/// Field: CHRL [6:7]
enum class USART1_MR_SPI_MODE_CHRL : uint32_t {
    VAL_8_BIT = 0x3,  // 8_BIT
};

/// Transmitter Preamble Pattern
/// Register: MAN
/// Field: TX_PP [8:9]
enum class USART1_MAN_TX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// Receiver Preamble Pattern detected
/// Register: MAN
/// Field: RX_PP [24:25]
enum class USART1_MAN_RX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// LIN Node Action
/// Register: LINMR
/// Field: NACT [0:1]
enum class USART1_LINMR_NACT : uint32_t {
    PUBLISH = 0x0,
    SUBSCRIBE = 0x1,
    IGNORE = 0x2,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class USART1_WPMR_WPKEY : uint32_t {
    PASSWD = 0x555341,
};

// ----------------------------------------------------------------------------
// USART2 - Universal Synchronous Asynchronous Receiver Transmitter 2
// ----------------------------------------------------------------------------

/// USART Mode of Operation
/// Register: MR
/// Field: USART_MODE [0:3]
enum class USART2_MR_USART_MODE : uint32_t {
    NORMAL = 0x0,
    RS485 = 0x1,
    HW_HANDSHAKING = 0x2,
    IS07816_T_0 = 0x4,
    IS07816_T_1 = 0x6,
    IRDA = 0x8,
    LIN_MASTER = 0xA,
    LIN_SLAVE = 0xB,
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: MR
/// Field: USCLKS [4:5]
enum class USART2_MR_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    SCK = 0x3,
};

/// Character Length
/// Register: MR
/// Field: CHRL [6:7]
enum class USART2_MR_CHRL : uint32_t {
    VAL_5_BIT = 0x0,  // 5_BIT
    VAL_6_BIT = 0x1,  // 6_BIT
    VAL_7_BIT = 0x2,  // 7_BIT
    VAL_8_BIT = 0x3,  // 8_BIT
};

/// Parity Type
/// Register: MR
/// Field: PAR [9:11]
enum class USART2_MR_PAR : uint32_t {
    EVEN = 0x0,
    ODD = 0x1,
    SPACE = 0x2,
    MARK = 0x3,
    NO = 0x4,
    MULTIDROP = 0x6,
};

/// Number of Stop Bits
/// Register: MR
/// Field: NBSTOP [12:13]
enum class USART2_MR_NBSTOP : uint32_t {
    VAL_1_BIT = 0x0,  // 1_BIT
    VAL_1_5_BIT = 0x1,  // 1_5_BIT
    VAL_2_BIT = 0x2,  // 2_BIT
};

/// Channel Mode
/// Register: MR
/// Field: CHMODE [14:15]
enum class USART2_MR_CHMODE : uint32_t {
    NORMAL = 0x0,
    AUTOMATIC = 0x1,
    LOCAL_LOOPBACK = 0x2,
    REMOTE_LOOPBACK = 0x3,
};

/// USART Mode of Operation
/// Register: MR_SPI_MODE
/// Field: USART_MODE [0:3]
enum class USART2_MR_SPI_MODE_USART_MODE : uint32_t {
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: MR_SPI_MODE
/// Field: USCLKS [4:5]
enum class USART2_MR_SPI_MODE_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    SCK = 0x3,
};

/// Character Length
/// Register: MR_SPI_MODE
/// Field: CHRL [6:7]
enum class USART2_MR_SPI_MODE_CHRL : uint32_t {
    VAL_8_BIT = 0x3,  // 8_BIT
};

/// Transmitter Preamble Pattern
/// Register: MAN
/// Field: TX_PP [8:9]
enum class USART2_MAN_TX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// Receiver Preamble Pattern detected
/// Register: MAN
/// Field: RX_PP [24:25]
enum class USART2_MAN_RX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// LIN Node Action
/// Register: LINMR
/// Field: NACT [0:1]
enum class USART2_LINMR_NACT : uint32_t {
    PUBLISH = 0x0,
    SUBSCRIBE = 0x1,
    IGNORE = 0x2,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class USART2_WPMR_WPKEY : uint32_t {
    PASSWD = 0x555341,
};

// ----------------------------------------------------------------------------
// USART3 - Universal Synchronous Asynchronous Receiver Transmitter 3
// ----------------------------------------------------------------------------

/// USART Mode of Operation
/// Register: MR
/// Field: USART_MODE [0:3]
enum class USART3_MR_USART_MODE : uint32_t {
    NORMAL = 0x0,
    RS485 = 0x1,
    HW_HANDSHAKING = 0x2,
    IS07816_T_0 = 0x4,
    IS07816_T_1 = 0x6,
    IRDA = 0x8,
    LIN_MASTER = 0xA,
    LIN_SLAVE = 0xB,
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: MR
/// Field: USCLKS [4:5]
enum class USART3_MR_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    SCK = 0x3,
};

/// Character Length
/// Register: MR
/// Field: CHRL [6:7]
enum class USART3_MR_CHRL : uint32_t {
    VAL_5_BIT = 0x0,  // 5_BIT
    VAL_6_BIT = 0x1,  // 6_BIT
    VAL_7_BIT = 0x2,  // 7_BIT
    VAL_8_BIT = 0x3,  // 8_BIT
};

/// Parity Type
/// Register: MR
/// Field: PAR [9:11]
enum class USART3_MR_PAR : uint32_t {
    EVEN = 0x0,
    ODD = 0x1,
    SPACE = 0x2,
    MARK = 0x3,
    NO = 0x4,
    MULTIDROP = 0x6,
};

/// Number of Stop Bits
/// Register: MR
/// Field: NBSTOP [12:13]
enum class USART3_MR_NBSTOP : uint32_t {
    VAL_1_BIT = 0x0,  // 1_BIT
    VAL_1_5_BIT = 0x1,  // 1_5_BIT
    VAL_2_BIT = 0x2,  // 2_BIT
};

/// Channel Mode
/// Register: MR
/// Field: CHMODE [14:15]
enum class USART3_MR_CHMODE : uint32_t {
    NORMAL = 0x0,
    AUTOMATIC = 0x1,
    LOCAL_LOOPBACK = 0x2,
    REMOTE_LOOPBACK = 0x3,
};

/// USART Mode of Operation
/// Register: MR_SPI_MODE
/// Field: USART_MODE [0:3]
enum class USART3_MR_SPI_MODE_USART_MODE : uint32_t {
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: MR_SPI_MODE
/// Field: USCLKS [4:5]
enum class USART3_MR_SPI_MODE_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    SCK = 0x3,
};

/// Character Length
/// Register: MR_SPI_MODE
/// Field: CHRL [6:7]
enum class USART3_MR_SPI_MODE_CHRL : uint32_t {
    VAL_8_BIT = 0x3,  // 8_BIT
};

/// Transmitter Preamble Pattern
/// Register: MAN
/// Field: TX_PP [8:9]
enum class USART3_MAN_TX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// Receiver Preamble Pattern detected
/// Register: MAN
/// Field: RX_PP [24:25]
enum class USART3_MAN_RX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// LIN Node Action
/// Register: LINMR
/// Field: NACT [0:1]
enum class USART3_LINMR_NACT : uint32_t {
    PUBLISH = 0x0,
    SUBSCRIBE = 0x1,
    IGNORE = 0x2,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class USART3_WPMR_WPKEY : uint32_t {
    PASSWD = 0x555341,
};

// ----------------------------------------------------------------------------
// WDT - Watchdog Timer
// ----------------------------------------------------------------------------

/// Password.
/// Register: CR
/// Field: KEY [24:31]
enum class WDT_CR_KEY : uint32_t {
    PASSWD = 0xA5,
};

/// Total enumerated types: 581

}  // namespace alloy::hal::atmel::atsam3x8e::atsam3x8e::enums
