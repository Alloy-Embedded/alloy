/// Auto-generated register definitions for EMAC
/// Device: ATSAM3X8E
/// Vendor: Atmel
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::atmel::atsam3x8e::atsam3x8e::emac {

// ============================================================================
// EMAC - Ethernet MAC 10/100
// Base Address: 0x400B0000
// ============================================================================

/// EMAC Register Structure
struct EMAC_Registers {

    /// Network Control Register
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t NCR;

    /// Network Configuration Register
    /// Offset: 0x0004
    /// Reset value: 0x00000800
    /// Access: read-write
    volatile uint32_t NCFGR;

    /// Network Status Register
    /// Offset: 0x0008
    /// Access: read-only
    volatile uint32_t NSR;
    uint8_t RESERVED_000C[8]; ///< Reserved

    /// Transmit Status Register
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t TSR;

    /// Receive Buffer Queue Pointer Register
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RBQP;

    /// Transmit Buffer Queue Pointer Register
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t TBQP;

    /// Receive Status Register
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RSR;

    /// Interrupt Status Register
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ISR;

    /// Interrupt Enable Register
    /// Offset: 0x0028
    /// Access: write-only
    volatile uint32_t IER;

    /// Interrupt Disable Register
    /// Offset: 0x002C
    /// Access: write-only
    volatile uint32_t IDR;

    /// Interrupt Mask Register
    /// Offset: 0x0030
    /// Reset value: 0x00003FFF
    /// Access: read-only
    volatile uint32_t IMR;

    /// Phy Maintenance Register
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t MAN;

    /// Pause Time Register
    /// Offset: 0x0038
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t PTR;

    /// Pause Frames Received Register
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t PFR;

    /// Frames Transmitted Ok Register
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t FTO;

    /// Single Collision Frames Register
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SCF;

    /// Multiple Collision Frames Register
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t MCF;

    /// Frames Received Ok Register
    /// Offset: 0x004C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t FRO;

    /// Frame Check Sequence Errors Register
    /// Offset: 0x0050
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t FCSE;

    /// Alignment Errors Register
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALE;

    /// Deferred Transmission Frames Register
    /// Offset: 0x0058
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DTF;

    /// Late Collisions Register
    /// Offset: 0x005C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t LCOL;

    /// Excessive Collisions Register
    /// Offset: 0x0060
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ECOL;

    /// Transmit Underrun Errors Register
    /// Offset: 0x0064
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t TUND;

    /// Carrier Sense Errors Register
    /// Offset: 0x0068
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSE;

    /// Receive Resource Errors Register
    /// Offset: 0x006C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RRE;

    /// Receive Overrun Errors Register
    /// Offset: 0x0070
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ROV;

    /// Receive Symbol Errors Register
    /// Offset: 0x0074
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RSE;

    /// Excessive Length Errors Register
    /// Offset: 0x0078
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ELE;

    /// Receive Jabbers Register
    /// Offset: 0x007C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RJA;

    /// Undersize Frames Register
    /// Offset: 0x0080
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t USF;

    /// SQE Test Errors Register
    /// Offset: 0x0084
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t STE;

    /// Received Length Field Mismatch Register
    /// Offset: 0x0088
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RLE;
    uint8_t RESERVED_008C[4]; ///< Reserved

    /// Hash Register Bottom [31:0] Register
    /// Offset: 0x0090
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t HRB;

    /// Hash Register Top [63:32] Register
    /// Offset: 0x0094
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t HRT;

    /// Specific Address 1 Bottom Register
    /// Offset: 0x0098
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SA1B;

    /// Specific Address 1 Top Register
    /// Offset: 0x009C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SA1T;

    /// Specific Address 2 Bottom Register
    /// Offset: 0x00A0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SA2B;

    /// Specific Address 2 Top Register
    /// Offset: 0x00A4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SA2T;

    /// Specific Address 3 Bottom Register
    /// Offset: 0x00A8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SA3B;

    /// Specific Address 3 Top Register
    /// Offset: 0x00AC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SA3T;

    /// Specific Address 4 Bottom Register
    /// Offset: 0x00B0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SA4B;

    /// Specific Address 4 Top Register
    /// Offset: 0x00B4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SA4T;

    /// Type ID Checking Register
    /// Offset: 0x00B8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t TID;
    uint8_t RESERVED_00BC[4]; ///< Reserved

    /// User Input/Output Register
    /// Offset: 0x00C0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t USRIO;
};

static_assert(sizeof(EMAC_Registers) >= 196, "EMAC_Registers size mismatch");

/// EMAC peripheral instance
constexpr EMAC_Registers* EMAC = 
    reinterpret_cast<EMAC_Registers*>(0x400B0000);

}  // namespace alloy::hal::atmel::atsam3x8e::atsam3x8e::emac
