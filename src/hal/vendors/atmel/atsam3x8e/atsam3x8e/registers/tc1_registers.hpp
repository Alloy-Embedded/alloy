/// Auto-generated register definitions for TC1
/// Device: ATSAM3X8E
/// Vendor: Atmel
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::atmel::atsam3x8e::atsam3x8e::tc1 {

// ============================================================================
// TC1 - Timer Counter 1
// Base Address: 0x40084000
// ============================================================================

/// TC1 Register Structure
struct TC1_Registers {

    /// Channel Control Register (channel = 0)
    /// Offset: 0x0000
    /// Access: write-only
    volatile uint32_t CCR0;

    /// Channel Mode Register (channel = 0)
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CMR0;

    /// Channel Mode Register (channel = 0)
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CMR0_WAVE_EQ_1;

    /// Stepper Motor Mode Register (channel = 0)
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SMMR0;
    uint8_t RESERVED_000C[4]; ///< Reserved

    /// Counter Value (channel = 0)
    /// Offset: 0x0010
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t CV0;

    /// Register A (channel = 0)
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RA0;

    /// Register B (channel = 0)
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RB0;

    /// Register C (channel = 0)
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RC0;

    /// Status Register (channel = 0)
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SR0;

    /// Interrupt Enable Register (channel = 0)
    /// Offset: 0x0024
    /// Access: write-only
    volatile uint32_t IER0;

    /// Interrupt Disable Register (channel = 0)
    /// Offset: 0x0028
    /// Access: write-only
    volatile uint32_t IDR0;

    /// Interrupt Mask Register (channel = 0)
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t IMR0;
    uint8_t RESERVED_0030[16]; ///< Reserved

    /// Channel Control Register (channel = 1)
    /// Offset: 0x0040
    /// Access: write-only
    volatile uint32_t CCR1;

    /// Channel Mode Register (channel = 1)
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CMR1;

    /// Channel Mode Register (channel = 1)
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CMR1_WAVE_EQ_1;

    /// Stepper Motor Mode Register (channel = 1)
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SMMR1;
    uint8_t RESERVED_004C[4]; ///< Reserved

    /// Counter Value (channel = 1)
    /// Offset: 0x0050
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t CV1;

    /// Register A (channel = 1)
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RA1;

    /// Register B (channel = 1)
    /// Offset: 0x0058
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RB1;

    /// Register C (channel = 1)
    /// Offset: 0x005C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RC1;

    /// Status Register (channel = 1)
    /// Offset: 0x0060
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SR1;

    /// Interrupt Enable Register (channel = 1)
    /// Offset: 0x0064
    /// Access: write-only
    volatile uint32_t IER1;

    /// Interrupt Disable Register (channel = 1)
    /// Offset: 0x0068
    /// Access: write-only
    volatile uint32_t IDR1;

    /// Interrupt Mask Register (channel = 1)
    /// Offset: 0x006C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t IMR1;
    uint8_t RESERVED_0070[16]; ///< Reserved

    /// Channel Control Register (channel = 2)
    /// Offset: 0x0080
    /// Access: write-only
    volatile uint32_t CCR2;

    /// Channel Mode Register (channel = 2)
    /// Offset: 0x0084
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CMR2;

    /// Channel Mode Register (channel = 2)
    /// Offset: 0x0084
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CMR2_WAVE_EQ_1;

    /// Stepper Motor Mode Register (channel = 2)
    /// Offset: 0x0088
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SMMR2;
    uint8_t RESERVED_008C[4]; ///< Reserved

    /// Counter Value (channel = 2)
    /// Offset: 0x0090
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t CV2;

    /// Register A (channel = 2)
    /// Offset: 0x0094
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RA2;

    /// Register B (channel = 2)
    /// Offset: 0x0098
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RB2;

    /// Register C (channel = 2)
    /// Offset: 0x009C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t RC2;

    /// Status Register (channel = 2)
    /// Offset: 0x00A0
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SR2;

    /// Interrupt Enable Register (channel = 2)
    /// Offset: 0x00A4
    /// Access: write-only
    volatile uint32_t IER2;

    /// Interrupt Disable Register (channel = 2)
    /// Offset: 0x00A8
    /// Access: write-only
    volatile uint32_t IDR2;

    /// Interrupt Mask Register (channel = 2)
    /// Offset: 0x00AC
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t IMR2;
    uint8_t RESERVED_00B0[16]; ///< Reserved

    /// Block Control Register
    /// Offset: 0x00C0
    /// Access: write-only
    volatile uint32_t BCR;

    /// Block Mode Register
    /// Offset: 0x00C4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BMR;

    /// QDEC Interrupt Enable Register
    /// Offset: 0x00C8
    /// Access: write-only
    volatile uint32_t QIER;

    /// QDEC Interrupt Disable Register
    /// Offset: 0x00CC
    /// Access: write-only
    volatile uint32_t QIDR;

    /// QDEC Interrupt Mask Register
    /// Offset: 0x00D0
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t QIMR;

    /// QDEC Interrupt Status Register
    /// Offset: 0x00D4
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t QISR;

    /// Fault Mode Register
    /// Offset: 0x00D8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t FMR;
    uint8_t RESERVED_00DC[8]; ///< Reserved

    /// Write Protect Mode Register
    /// Offset: 0x00E4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t WPMR;
};

static_assert(sizeof(TC1_Registers) >= 232, "TC1_Registers size mismatch");

/// TC1 peripheral instance
constexpr TC1_Registers* TC1 = 
    reinterpret_cast<TC1_Registers*>(0x40084000);

}  // namespace alloy::hal::atmel::atsam3x8e::atsam3x8e::tc1
