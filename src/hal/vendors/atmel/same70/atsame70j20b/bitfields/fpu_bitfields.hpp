/// Auto-generated bit field definitions for FPU
/// Device: ATSAME70J20B
/// Vendor: Microchip Technology
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::atmel::same70::atsame70j20b::fpu {

using namespace alloy::hal::bitfields;

// ============================================================================
// FPU Bit Field Definitions
// ============================================================================

/// FPCCR - Floating-point Context Control Register
namespace fpccr {
    /// Lazy state preservation is active. Floating-point stack frame has been allocated but saving state to it has been deferred.
    /// Position: 0, Width: 1
    using LSPACT = BitField<0, 1>;
    constexpr uint32_t LSPACT_Pos = 0;
    constexpr uint32_t LSPACT_Msk = LSPACT::mask;

    /// Privilege level was user when the floating-point stack frame was allocated.
    /// Position: 1, Width: 1
    using USER = BitField<1, 1>;
    constexpr uint32_t USER_Pos = 1;
    constexpr uint32_t USER_Msk = USER::mask;

    /// Mode was Thread Mode when the floating-point stack frame was allocated.
    /// Position: 3, Width: 1
    using THREAD = BitField<3, 1>;
    constexpr uint32_t THREAD_Pos = 3;
    constexpr uint32_t THREAD_Msk = THREAD::mask;

    /// Priority permitted setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
    /// Position: 4, Width: 1
    using HFRDY = BitField<4, 1>;
    constexpr uint32_t HFRDY_Pos = 4;
    constexpr uint32_t HFRDY_Msk = HFRDY::mask;

    /// MemManage is enabled and priority permitted setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
    /// Position: 5, Width: 1
    using MMRDY = BitField<5, 1>;
    constexpr uint32_t MMRDY_Pos = 5;
    constexpr uint32_t MMRDY_Msk = MMRDY::mask;

    /// BusFault is enabled and priority permitted setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
    /// Position: 6, Width: 1
    using BFRDY = BitField<6, 1>;
    constexpr uint32_t BFRDY_Pos = 6;
    constexpr uint32_t BFRDY_Msk = BFRDY::mask;

    /// DebugMonitor is enabled and priority permits setting MON_PEND when the floating-point stack frame was allocated.
    /// Position: 8, Width: 1
    using MONRDY = BitField<8, 1>;
    constexpr uint32_t MONRDY_Pos = 8;
    constexpr uint32_t MONRDY_Msk = MONRDY::mask;

    /// Enable automatic lazy state preservation for floating-point context.
    /// Position: 30, Width: 1
    using LSPEN = BitField<30, 1>;
    constexpr uint32_t LSPEN_Pos = 30;
    constexpr uint32_t LSPEN_Msk = LSPEN::mask;

    /// Enables CONTROL.FPCA setting on execution of a floating-point instruction. This results in automatic hardware state preservation and restoration, for floating-point context, on exception entry and exit.
    /// Position: 31, Width: 1
    using ASPEN = BitField<31, 1>;
    constexpr uint32_t ASPEN_Pos = 31;
    constexpr uint32_t ASPEN_Msk = ASPEN::mask;

}  // namespace fpccr

/// FPCAR - Floating-point Context Address Register
namespace fpcar {
    /// The location of the unpopulated floating-point register space allocated on an exception stack frame.
    /// Position: 3, Width: 29
    using ADDRESS = BitField<3, 29>;
    constexpr uint32_t ADDRESS_Pos = 3;
    constexpr uint32_t ADDRESS_Msk = ADDRESS::mask;

}  // namespace fpcar

/// FPDSCR - Floating-point Default Status Control Register
namespace fpdscr {
    /// Default value for FPSCR.RMode.
    /// Position: 22, Width: 2
    using RMode = BitField<22, 2>;
    constexpr uint32_t RMode_Pos = 22;
    constexpr uint32_t RMode_Msk = RMode::mask;

    /// Default value for FPSCR.FZ.
    /// Position: 24, Width: 1
    using FZ = BitField<24, 1>;
    constexpr uint32_t FZ_Pos = 24;
    constexpr uint32_t FZ_Msk = FZ::mask;

    /// Default value for FPSCR.DN.
    /// Position: 25, Width: 1
    using DN = BitField<25, 1>;
    constexpr uint32_t DN_Pos = 25;
    constexpr uint32_t DN_Msk = DN::mask;

    /// Default value for FPSCR.AHP.
    /// Position: 26, Width: 1
    using AHP = BitField<26, 1>;
    constexpr uint32_t AHP_Pos = 26;
    constexpr uint32_t AHP_Msk = AHP::mask;

}  // namespace fpdscr

/// MVFR0 - Media and VFP Feature Register 0
namespace mvfr0 {
    /// Indicates the size of the FP register bank
    /// Position: 0, Width: 4
    using A_SIMD_registers = BitField<0, 4>;
    constexpr uint32_t A_SIMD_registers_Pos = 0;
    constexpr uint32_t A_SIMD_registers_Msk = A_SIMD_registers::mask;

    /// Indicates the hardware support for FP single-precision operations
    /// Position: 4, Width: 4
    using Single_precision = BitField<4, 4>;
    constexpr uint32_t Single_precision_Pos = 4;
    constexpr uint32_t Single_precision_Msk = Single_precision::mask;

    /// Indicates the hardware support for FP double-precision operations
    /// Position: 8, Width: 4
    using Double_precision = BitField<8, 4>;
    constexpr uint32_t Double_precision_Pos = 8;
    constexpr uint32_t Double_precision_Msk = Double_precision::mask;

    /// Indicates whether the FP hardware implementation supports exception trapping
    /// Position: 12, Width: 4
    using FP_excep_trapping = BitField<12, 4>;
    constexpr uint32_t FP_excep_trapping_Pos = 12;
    constexpr uint32_t FP_excep_trapping_Msk = FP_excep_trapping::mask;

    /// Indicates the hardware support for FP divide operations
    /// Position: 16, Width: 4
    using Divide = BitField<16, 4>;
    constexpr uint32_t Divide_Pos = 16;
    constexpr uint32_t Divide_Msk = Divide::mask;

    /// Indicates the hardware support for FP square root operations
    /// Position: 20, Width: 4
    using Square_root = BitField<20, 4>;
    constexpr uint32_t Square_root_Pos = 20;
    constexpr uint32_t Square_root_Msk = Square_root::mask;

    /// Indicates the hardware support for FP short vectors
    /// Position: 24, Width: 4
    using Short_vectors = BitField<24, 4>;
    constexpr uint32_t Short_vectors_Pos = 24;
    constexpr uint32_t Short_vectors_Msk = Short_vectors::mask;

    /// Indicates the rounding modes supported by the FP floating-point hardware
    /// Position: 28, Width: 4
    using FP_rounding_modes = BitField<28, 4>;
    constexpr uint32_t FP_rounding_modes_Pos = 28;
    constexpr uint32_t FP_rounding_modes_Msk = FP_rounding_modes::mask;

}  // namespace mvfr0

/// MVFR1 - Media and VFP Feature Register 1
namespace mvfr1 {
    /// Indicates whether the FP hardware implementation supports only the Flush-to-Zero mode of operation
    /// Position: 0, Width: 4
    using FtZ_mode = BitField<0, 4>;
    constexpr uint32_t FtZ_mode_Pos = 0;
    constexpr uint32_t FtZ_mode_Msk = FtZ_mode::mask;

    /// Indicates whether the FP hardware implementation supports only the Default NaN mode
    /// Position: 4, Width: 4
    using D_NaN_mode = BitField<4, 4>;
    constexpr uint32_t D_NaN_mode_Pos = 4;
    constexpr uint32_t D_NaN_mode_Msk = D_NaN_mode::mask;

    /// Floating Point Half-Precision and double-precision
    /// Position: 24, Width: 4
    using FP_HPFP = BitField<24, 4>;
    constexpr uint32_t FP_HPFP_Pos = 24;
    constexpr uint32_t FP_HPFP_Msk = FP_HPFP::mask;

    /// Indicates whether the FP supports fused multiply accumulate operations
    /// Position: 28, Width: 4
    using FP_fused_MAC = BitField<28, 4>;
    constexpr uint32_t FP_fused_MAC_Pos = 28;
    constexpr uint32_t FP_fused_MAC_Msk = FP_fused_MAC::mask;

}  // namespace mvfr1

/// MVFR2 - Media and VFP Feature Register 2
namespace mvfr2 {
    /// Indicates the hardware support for FP miscellaneous features
    /// Position: 4, Width: 4
    using VFP_Misc = BitField<4, 4>;
    constexpr uint32_t VFP_Misc_Pos = 4;
    constexpr uint32_t VFP_Misc_Msk = VFP_Misc::mask;

}  // namespace mvfr2

}  // namespace alloy::hal::atmel::same70::atsame70j20b::fpu
