/// Auto-generated enumeration definitions
/// Device: ATSAME70J20B
/// Vendor: Microchip Technology
///
/// This file contains type-safe enum classes for all register field
/// enumerated values extracted from the CMSIS-SVD file.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::atmel::same70::atsame70j20b::enums {

// ============================================================================
// ENUMERATED VALUE DEFINITIONS
// ============================================================================

// ----------------------------------------------------------------------------
// ACC - Analog Comparator Controller
// ----------------------------------------------------------------------------

/// Selection for Minus Comparator Input
/// Register: MR
/// Field: SELMINUS [0:2]
enum class ACC_MR_SELMINUS : uint32_t {
    TS = 0x0,
    VREFP = 0x1,
    DAC0 = 0x2,
    DAC1 = 0x3,
    AFE0_AD0 = 0x4,
    AFE0_AD1 = 0x5,
    AFE0_AD2 = 0x6,
    AFE0_AD3 = 0x7,
};

/// Selection For Plus Comparator Input
/// Register: MR
/// Field: SELPLUS [4:6]
enum class ACC_MR_SELPLUS : uint32_t {
    AFE0_AD0 = 0x0,
    AFE0_AD1 = 0x1,
    AFE0_AD2 = 0x2,
    AFE0_AD3 = 0x3,
    AFE0_AD4 = 0x4,
    AFE0_AD5 = 0x5,
    AFE1_AD0 = 0x6,
    AFE1_AD1 = 0x7,
};

/// Analog Comparator Enable
/// Register: MR
/// Field: ACEN [8:8]
enum class ACC_MR_ACEN : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Edge Type
/// Register: MR
/// Field: EDGETYP [9:10]
enum class ACC_MR_EDGETYP : uint32_t {
    RISING = 0x0,
    FALLING = 0x1,
    ANY = 0x2,
};

/// Invert Comparator Output
/// Register: MR
/// Field: INV [12:12]
enum class ACC_MR_INV : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Selection Of Fault Source
/// Register: MR
/// Field: SELFS [13:13]
enum class ACC_MR_SELFS : uint32_t {
    CE = 0x0,
    OUTPUT = 0x1,
};

/// Fault Enable
/// Register: MR
/// Field: FE [14:14]
enum class ACC_MR_FE : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Current Selection
/// Register: ACR
/// Field: ISEL [0:0]
enum class ACC_ACR_ISEL : uint32_t {
    LOPW = 0x0,
    HISP = 0x1,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class ACC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x414343,
};

// ----------------------------------------------------------------------------
// AES - Advanced Encryption Standard
// ----------------------------------------------------------------------------

/// Dual Input Buffer
/// Register: MR
/// Field: DUALBUFF [3:3]
enum class AES_MR_DUALBUFF : uint32_t {
    INACTIVE = 0x0,
    ACTIVE = 0x1,
};

/// Start Mode
/// Register: MR
/// Field: SMOD [8:9]
enum class AES_MR_SMOD : uint32_t {
    MANUAL_START = 0x0,
    AUTO_START = 0x1,
    IDATAR0_START = 0x2,
};

/// Key Size
/// Register: MR
/// Field: KEYSIZE [10:11]
enum class AES_MR_KEYSIZE : uint32_t {
    AES128 = 0x0,
    AES192 = 0x1,
    AES256 = 0x2,
};

/// Operating Mode
/// Register: MR
/// Field: OPMOD [12:14]
enum class AES_MR_OPMOD : uint32_t {
    ECB = 0x0,
    CBC = 0x1,
    OFB = 0x2,
    CFB = 0x3,
    CTR = 0x4,
    GCM = 0x5,
};

/// Cipher Feedback Data Size
/// Register: MR
/// Field: CFBS [16:18]
enum class AES_MR_CFBS : uint32_t {
    SIZE_128BIT = 0x0,
    SIZE_64BIT = 0x1,
    SIZE_32BIT = 0x2,
    SIZE_16BIT = 0x3,
    SIZE_8BIT = 0x4,
};

/// Countermeasure Key
/// Register: MR
/// Field: CKEY [20:23]
enum class AES_MR_CKEY : uint32_t {
    PASSWD = 0xE,
};

/// Unspecified Register Access (cleared by writing SWRST in AES_CR)
/// Register: ISR
/// Field: URAT [12:15]
enum class AES_ISR_URAT : uint32_t {
    IDR_WR_PROCESSING = 0x0,
    ODR_RD_PROCESSING = 0x1,
    MR_WR_PROCESSING = 0x2,
    ODR_RD_SUBKGEN = 0x3,
    MR_WR_SUBKGEN = 0x4,
    WOR_RD_ACCESS = 0x5,
};

// ----------------------------------------------------------------------------
// AFEC0 - Analog Front-End Controller
// ----------------------------------------------------------------------------

/// Trigger Enable
/// Register: MR
/// Field: TRGEN [0:0]
enum class AFEC0_MR_TRGEN : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Trigger Selection
/// Register: MR
/// Field: TRGSEL [1:3]
enum class AFEC0_MR_TRGSEL : uint32_t {
    AFEC_TRIG0 = 0x0,
    AFEC_TRIG1 = 0x1,
    AFEC_TRIG2 = 0x2,
    AFEC_TRIG3 = 0x3,
    AFEC_TRIG4 = 0x4,
    AFEC_TRIG5 = 0x5,
    AFEC_TRIG6 = 0x6,
};

/// Sleep Mode
/// Register: MR
/// Field: SLEEP [5:5]
enum class AFEC0_MR_SLEEP : uint32_t {
    NORMAL = 0x0,
    SLEEP = 0x1,
};

/// Fast Wake-up
/// Register: MR
/// Field: FWUP [6:6]
enum class AFEC0_MR_FWUP : uint32_t {
    OFF = 0x0,
    ON = 0x1,
};

/// Free Run Mode
/// Register: MR
/// Field: FREERUN [7:7]
enum class AFEC0_MR_FREERUN : uint32_t {
    OFF = 0x0,
    ON = 0x1,
};

/// Start-up Time
/// Register: MR
/// Field: STARTUP [16:19]
enum class AFEC0_MR_STARTUP : uint32_t {
    SUT0 = 0x0,
    SUT8 = 0x1,
    SUT16 = 0x2,
    SUT24 = 0x3,
    SUT64 = 0x4,
    SUT80 = 0x5,
    SUT96 = 0x6,
    SUT112 = 0x7,
    SUT512 = 0x8,
    SUT576 = 0x9,
    SUT640 = 0xA,
    SUT704 = 0xB,
    SUT768 = 0xC,
    SUT832 = 0xD,
    SUT896 = 0xE,
    SUT960 = 0xF,
};

/// User Sequence Enable
/// Register: MR
/// Field: USEQ [31:31]
enum class AFEC0_MR_USEQ : uint32_t {
    NUM_ORDER = 0x0,
    REG_ORDER = 0x1,
};

/// Comparison Mode
/// Register: EMR
/// Field: CMPMODE [0:1]
enum class AFEC0_EMR_CMPMODE : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
    IN = 0x2,
    OUT = 0x3,
};

/// Resolution
/// Register: EMR
/// Field: RES [16:18]
enum class AFEC0_EMR_RES : uint32_t {
    NO_AVERAGE = 0x0,
    OSR4 = 0x2,
    OSR16 = 0x3,
    OSR64 = 0x4,
    OSR256 = 0x5,
};

/// Sign Mode
/// Register: EMR
/// Field: SIGNMODE [28:29]
enum class AFEC0_EMR_SIGNMODE : uint32_t {
    SE_UNSG_DF_SIGN = 0x0,
    SE_SIGN_DF_UNSG = 0x1,
    ALL_UNSIGNED = 0x2,
    ALL_SIGNED = 0x3,
};

/// Temperature Comparison Mode
/// Register: TEMPMR
/// Field: TEMPCMPMOD [4:5]
enum class AFEC0_TEMPMR_TEMPCMPMOD : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
    IN = 0x2,
    OUT = 0x3,
};

/// Write Protect KEY
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class AFEC0_WPMR_WPKEY : uint32_t {
    PASSWD = 0x414443,
};

// ----------------------------------------------------------------------------
// CHIPID - Chip Identifier
// ----------------------------------------------------------------------------

/// Embedded Processor
/// Register: CIDR
/// Field: EPROC [5:7]
enum class CHIPID_CIDR_EPROC : uint32_t {
    SAMx7 = 0x0,
    ARM946ES = 0x1,
    ARM7TDMI = 0x2,
    CM3 = 0x3,
    ARM920T = 0x4,
    ARM926EJS = 0x5,
    CA5 = 0x6,
    CM4 = 0x7,
};

/// Nonvolatile Program Memory Size
/// Register: CIDR
/// Field: NVPSIZ [8:11]
enum class CHIPID_CIDR_NVPSIZ : uint32_t {
    NONE = 0x0,
    VAL_8K = 0x1,  // _8K
    VAL_16K = 0x2,  // _16K
    VAL_32K = 0x3,  // _32K
    VAL_64K = 0x5,  // _64K
    VAL_128K = 0x7,  // _128K
    VAL_160K = 0x8,  // _160K
    VAL_256K = 0x9,  // _256K
    VAL_512K = 0xA,  // _512K
    VAL_1024K = 0xC,  // _1024K
    VAL_2048K = 0xE,  // _2048K
};

/// Second Nonvolatile Program Memory Size
/// Register: CIDR
/// Field: NVPSIZ2 [12:15]
enum class CHIPID_CIDR_NVPSIZ2 : uint32_t {
    NONE = 0x0,
    VAL_8K = 0x1,  // _8K
    VAL_16K = 0x2,  // _16K
    VAL_32K = 0x3,  // _32K
    VAL_64K = 0x5,  // _64K
    VAL_128K = 0x7,  // _128K
    VAL_256K = 0x9,  // _256K
    VAL_512K = 0xA,  // _512K
    VAL_1024K = 0xC,  // _1024K
    VAL_2048K = 0xE,  // _2048K
};

/// Internal SRAM Size
/// Register: CIDR
/// Field: SRAMSIZ [16:19]
enum class CHIPID_CIDR_SRAMSIZ : uint32_t {
    VAL_48K = 0x0,  // _48K
    VAL_192K = 0x1,  // _192K
    VAL_384K = 0x2,  // _384K
    VAL_6K = 0x3,  // _6K
    VAL_24K = 0x4,  // _24K
    VAL_4K = 0x5,  // _4K
    VAL_80K = 0x6,  // _80K
    VAL_160K = 0x7,  // _160K
    VAL_8K = 0x8,  // _8K
    VAL_16K = 0x9,  // _16K
    VAL_32K = 0xA,  // _32K
    VAL_64K = 0xB,  // _64K
    VAL_128K = 0xC,  // _128K
    VAL_256K = 0xD,  // _256K
    VAL_96K = 0xE,  // _96K
    VAL_512K = 0xF,  // _512K
};

/// Architecture Identifier
/// Register: CIDR
/// Field: ARCH [20:27]
enum class CHIPID_CIDR_ARCH : uint32_t {
    SAME70 = 0x10,
    SAMS70 = 0x11,
    SAMV71 = 0x12,
    SAMV70 = 0x13,
};

/// Nonvolatile Program Memory Type
/// Register: CIDR
/// Field: NVPTYP [28:30]
enum class CHIPID_CIDR_NVPTYP : uint32_t {
    ROM = 0x0,
    ROMLESS = 0x1,
    FLASH = 0x2,
    ROM_FLASH = 0x3,
    SRAM = 0x4,
};

// ----------------------------------------------------------------------------
// DACC - Digital-to-Analog Converter Controller
// ----------------------------------------------------------------------------

/// Max Speed Mode for Channel 0
/// Register: MR
/// Field: MAXS0 [0:0]
enum class DACC_MR_MAXS0 : uint32_t {
    TRIG_EVENT = 0x0,
    MAXIMUM = 0x1,
};

/// Max Speed Mode for Channel 1
/// Register: MR
/// Field: MAXS1 [1:1]
enum class DACC_MR_MAXS1 : uint32_t {
    TRIG_EVENT = 0x0,
    MAXIMUM = 0x1,
};

/// Word Transfer Mode
/// Register: MR
/// Field: WORD [4:4]
enum class DACC_MR_WORD : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Differential Mode
/// Register: MR
/// Field: DIFF [23:23]
enum class DACC_MR_DIFF : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Trigger Enable of Channel 0
/// Register: TRIGR
/// Field: TRGEN0 [0:0]
enum class DACC_TRIGR_TRGEN0 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Trigger Enable of Channel 1
/// Register: TRIGR
/// Field: TRGEN1 [1:1]
enum class DACC_TRIGR_TRGEN1 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Trigger Selection of Channel 0
/// Register: TRIGR
/// Field: TRGSEL0 [4:6]
enum class DACC_TRIGR_TRGSEL0 : uint32_t {
    TRGSEL0 = 0x0,
    TRGSEL1 = 0x1,
    TRGSEL2 = 0x2,
    TRGSEL3 = 0x3,
    TRGSEL4 = 0x4,
    TRGSEL5 = 0x5,
    TRGSEL6 = 0x6,
    TRGSEL7 = 0x7,
};

/// Trigger Selection of Channel 1
/// Register: TRIGR
/// Field: TRGSEL1 [8:10]
enum class DACC_TRIGR_TRGSEL1 : uint32_t {
    TRGSEL0 = 0x0,
    TRGSEL1 = 0x1,
    TRGSEL2 = 0x2,
    TRGSEL3 = 0x3,
    TRGSEL4 = 0x4,
    TRGSEL5 = 0x5,
    TRGSEL6 = 0x6,
    TRGSEL7 = 0x7,
};

/// Over Sampling Ratio of Channel 0
/// Register: TRIGR
/// Field: OSR0 [16:18]
enum class DACC_TRIGR_OSR0 : uint32_t {
    OSR_1 = 0x0,
    OSR_2 = 0x1,
    OSR_4 = 0x2,
    OSR_8 = 0x3,
    OSR_16 = 0x4,
    OSR_32 = 0x5,
};

/// Over Sampling Ratio of Channel 1
/// Register: TRIGR
/// Field: OSR1 [20:22]
enum class DACC_TRIGR_OSR1 : uint32_t {
    OSR_1 = 0x0,
    OSR_2 = 0x1,
    OSR_4 = 0x2,
    OSR_8 = 0x3,
    OSR_16 = 0x4,
    OSR_32 = 0x5,
};

/// Write Protect Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class DACC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x444143,
};

// ----------------------------------------------------------------------------
// EFC - Embedded Flash Controller
// ----------------------------------------------------------------------------

/// Flash Command
/// Register: EEFC_FCR
/// Field: FCMD [0:7]
enum class EFC_EEFC_FCR_FCMD : uint32_t {
    GETD = 0x0,
    WP = 0x1,
    WPL = 0x2,
    EWP = 0x3,
    EWPL = 0x4,
    EA = 0x5,
    EPA = 0x7,
    SLB = 0x8,
    CLB = 0x9,
    GLB = 0xA,
    SGPB = 0xB,
    CGPB = 0xC,
    GGPB = 0xD,
    STUI = 0xE,
    SPUI = 0xF,
    GCALB = 0x10,
    ES = 0x11,
    WUS = 0x12,
    EUS = 0x13,
    STUS = 0x14,
    SPUS = 0x15,
};

/// Flash Writing Protection Key
/// Register: EEFC_FCR
/// Field: FKEY [24:31]
enum class EFC_EEFC_FCR_FKEY : uint32_t {
    PASSWD = 0x5A,
};

/// Write Protection Key
/// Register: EEFC_WPMR
/// Field: WPKEY [8:31]
enum class EFC_EEFC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x454643,
};

// ----------------------------------------------------------------------------
// GMAC - Gigabit Ethernet MAC
// ----------------------------------------------------------------------------

/// MDC CLock Division
/// Register: NCFGR
/// Field: CLK [18:20]
enum class GMAC_NCFGR_CLK : uint32_t {
    MCK_8 = 0x0,
    MCK_16 = 0x1,
    MCK_32 = 0x2,
    MCK_48 = 0x3,
    MCK_64 = 0x4,
    MCK_96 = 0x5,
};

/// Fixed Burst Length for DMA Data Operations:
/// Register: DCFGR
/// Field: FBLDO [0:4]
enum class GMAC_DCFGR_FBLDO : uint32_t {
    SINGLE = 0x1,
    INCR4 = 0x4,
    INCR8 = 0x8,
    INCR16 = 0x10,
};

/// Receiver Packet Buffer Memory Size Select
/// Register: DCFGR
/// Field: RXBMS [8:9]
enum class GMAC_DCFGR_RXBMS : uint32_t {
    EIGHTH = 0x0,
    QUARTER = 0x1,
    HALF = 0x2,
    FULL = 0x3,
};

/// Ethernet Frame Offset Start
/// Register: ST2CW1
/// Field: OFFSSTRT [7:8]
enum class GMAC_ST2CW1_OFFSSTRT : uint32_t {
    FRAMESTART = 0x0,
    ETHERTYPE = 0x1,
    IP = 0x2,
    TCP_UDP = 0x3,
};

// ----------------------------------------------------------------------------
// ICM - Integrity Check Monitor
// ----------------------------------------------------------------------------

/// User SHA Algorithm
/// Register: CFG
/// Field: UALGO [13:15]
enum class ICM_CFG_UALGO : uint32_t {
    SHA1 = 0x0,
    SHA256 = 0x1,
    SHA224 = 0x4,
};

/// Undefined Register Access Trace
/// Register: UASR
/// Field: URAT [0:2]
enum class ICM_UASR_URAT : uint32_t {
    UNSPEC_STRUCT_MEMBER = 0x0,
    ICM_CFG_MODIFIED = 0x1,
    ICM_DSCR_MODIFIED = 0x2,
    ICM_HASH_MODIFIED = 0x3,
    READ_ACCESS = 0x4,
};

// ----------------------------------------------------------------------------
// ISI - Image Sensor Interface
// ----------------------------------------------------------------------------

/// Threshold Mask
/// Register: CFG1
/// Field: THMASK [13:14]
enum class ISI_CFG1_THMASK : uint32_t {
    BEATS_4 = 0x0,
    BEATS_8 = 0x1,
    BEATS_16 = 0x2,
};

/// YCrCb Format Swap Mode
/// Register: CFG2
/// Field: YCC_SWAP [28:29]
enum class ISI_CFG2_YCC_SWAP : uint32_t {
    DEFAULT = 0x0,
    MODE1 = 0x1,
    MODE2 = 0x2,
    MODE3 = 0x3,
};

/// RGB Pixel Mapping Configuration
/// Register: CFG2
/// Field: RGB_CFG [30:31]
enum class ISI_CFG2_RGB_CFG : uint32_t {
    DEFAULT = 0x0,
    MODE1 = 0x1,
    MODE2 = 0x2,
    MODE3 = 0x3,
};

/// Write Protection Key Password
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class ISI_WPMR_WPKEY : uint32_t {
    PASSWD = 0x495349,
};

// ----------------------------------------------------------------------------
// MATRIX - AHB Bus Matrix
// ----------------------------------------------------------------------------

/// Undefined Length Burst Type
/// Register: MCFG[13]
/// Field: ULBT [0:2]
enum class MATRIX_MCFG_13_ULBT : uint32_t {
    UNLTD_LENGTH = 0x0,
    SINGLE_ACCESS = 0x1,
    VAL_4BEAT_BURST = 0x2,  // _4BEAT_BURST
    VAL_8BEAT_BURST = 0x3,  // _8BEAT_BURST
    VAL_16BEAT_BURST = 0x4,  // _16BEAT_BURST
    VAL_32BEAT_BURST = 0x5,  // _32BEAT_BURST
    VAL_64BEAT_BURST = 0x6,  // _64BEAT_BURST
    VAL_128BEAT_BURST = 0x7,  // _128BEAT_BURST
};

/// Default Master Type
/// Register: SCFG[9]
/// Field: DEFMSTR_TYPE [16:17]
enum class MATRIX_SCFG_9_DEFMSTR_TYPE : uint32_t {
    NONE = 0x0,
    LAST = 0x1,
    FIXED = 0x2,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class MATRIX_WPMR_WPKEY : uint32_t {
    PASSWD = 0x4D4154,
};

// ----------------------------------------------------------------------------
// MCAN0 - Controller Area Network
// ----------------------------------------------------------------------------

/// Transmitter Delay Compensation
/// Register: DBTP
/// Field: TDC [23:23]
enum class MCAN0_DBTP_TDC : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Loop Back Mode (read/write)
/// Register: TEST
/// Field: LBCK [4:4]
enum class MCAN0_TEST_LBCK : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Control of Transmit Pin (read/write)
/// Register: TEST
/// Field: TX [5:6]
enum class MCAN0_TEST_TX : uint32_t {
    RESET = 0x0,
    SAMPLE_POINT_MONITORING = 0x1,
    DOMINANT = 0x2,
    RECESSIVE = 0x3,
};

/// Initialization (read/write)
/// Register: CCCR
/// Field: INIT [0:0]
enum class MCAN0_CCCR_INIT : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Configuration Change Enable (read/write, write protection)
/// Register: CCCR
/// Field: CCE [1:1]
enum class MCAN0_CCCR_CCE : uint32_t {
    PROTECTED = 0x0,
    CONFIGURABLE = 0x1,
};

/// Restricted Operation Mode (read/write, write protection against '1')
/// Register: CCCR
/// Field: ASM [2:2]
enum class MCAN0_CCCR_ASM : uint32_t {
    NORMAL = 0x0,
    RESTRICTED = 0x1,
};

/// Clock Stop Request (read/write)
/// Register: CCCR
/// Field: CSR [4:4]
enum class MCAN0_CCCR_CSR : uint32_t {
    NO_CLOCK_STOP = 0x0,
    CLOCK_STOP = 0x1,
};

/// Bus Monitoring Mode (read/write, write protection against '1')
/// Register: CCCR
/// Field: MON [5:5]
enum class MCAN0_CCCR_MON : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Disable Automatic Retransmission (read/write, write protection)
/// Register: CCCR
/// Field: DAR [6:6]
enum class MCAN0_CCCR_DAR : uint32_t {
    AUTO_RETX = 0x0,
    NO_AUTO_RETX = 0x1,
};

/// Test Mode Enable (read/write, write protection against '1')
/// Register: CCCR
/// Field: TEST [7:7]
enum class MCAN0_CCCR_TEST : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// CAN FD Operation Enable (read/write, write protection)
/// Register: CCCR
/// Field: FDOE [8:8]
enum class MCAN0_CCCR_FDOE : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Bit Rate Switching Enable (read/write, write protection)
/// Register: CCCR
/// Field: BRSE [9:9]
enum class MCAN0_CCCR_BRSE : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Timestamp Select
/// Register: TSCC
/// Field: TSS [0:1]
enum class MCAN0_TSCC_TSS : uint32_t {
    ALWAYS_0 = 0x0,
    TCP_INC = 0x1,
    EXT_TIMESTAMP = 0x2,
};

/// Enable Timeout Counter
/// Register: TOCC
/// Field: ETOC [0:0]
enum class MCAN0_TOCC_ETOC : uint32_t {
    NO_TIMEOUT = 0x0,
    TOS_CONTROLLED = 0x1,
};

/// Timeout Select
/// Register: TOCC
/// Field: TOS [1:2]
enum class MCAN0_TOCC_TOS : uint32_t {
    CONTINUOUS = 0x0,
    TX_EV_TIMEOUT = 0x1,
    RX0_EV_TIMEOUT = 0x2,
    RX1_EV_TIMEOUT = 0x3,
};

/// Last Error Code (set to 111 on read)
/// Register: PSR
/// Field: LEC [0:2]
enum class MCAN0_PSR_LEC : uint32_t {
    NO_ERROR = 0x0,
    STUFF_ERROR = 0x1,
    FORM_ERROR = 0x2,
    ACK_ERROR = 0x3,
    BIT1_ERROR = 0x4,
    BIT0_ERROR = 0x5,
    CRC_ERROR = 0x6,
    NO_CHANGE = 0x7,
};

/// Activity
/// Register: PSR
/// Field: ACT [3:4]
enum class MCAN0_PSR_ACT : uint32_t {
    SYNCHRONIZING = 0x0,
    IDLE = 0x1,
    RECEIVER = 0x2,
    TRANSMITTER = 0x3,
};

/// Reject Remote Frames Extended
/// Register: GFC
/// Field: RRFE [0:0]
enum class MCAN0_GFC_RRFE : uint32_t {
    FILTER = 0x0,
    REJECT = 0x1,
};

/// Reject Remote Frames Standard
/// Register: GFC
/// Field: RRFS [1:1]
enum class MCAN0_GFC_RRFS : uint32_t {
    FILTER = 0x0,
    REJECT = 0x1,
};

/// Accept Non-matching Frames Extended
/// Register: GFC
/// Field: ANFE [2:3]
enum class MCAN0_GFC_ANFE : uint32_t {
    RX_FIFO_0 = 0x0,
    RX_FIFO_1 = 0x1,
};

/// Accept Non-matching Frames Standard
/// Register: GFC
/// Field: ANFS [4:5]
enum class MCAN0_GFC_ANFS : uint32_t {
    RX_FIFO_0 = 0x0,
    RX_FIFO_1 = 0x1,
};

/// Message Storage Indicator
/// Register: HPMS
/// Field: MSI [6:7]
enum class MCAN0_HPMS_MSI : uint32_t {
    NO_FIFO_SEL = 0x0,
    LOST = 0x1,
    FIFO_0 = 0x2,
    FIFO_1 = 0x3,
};

/// Debug Message Status
/// Register: RXF1S
/// Field: DMS [30:31]
enum class MCAN0_RXF1S_DMS : uint32_t {
    IDLE = 0x0,
    MSG_A = 0x1,
    MSG_AB = 0x2,
    MSG_ABC = 0x3,
};

/// Receive FIFO 0 Data Field Size
/// Register: RXESC
/// Field: F0DS [0:2]
enum class MCAN0_RXESC_F0DS : uint32_t {
    VAL_8_BYTE = 0x0,  // _8_BYTE
    VAL_12_BYTE = 0x1,  // _12_BYTE
    VAL_16_BYTE = 0x2,  // _16_BYTE
    VAL_20_BYTE = 0x3,  // _20_BYTE
    VAL_24_BYTE = 0x4,  // _24_BYTE
    VAL_32_BYTE = 0x5,  // _32_BYTE
    VAL_48_BYTE = 0x6,  // _48_BYTE
    VAL_64_BYTE = 0x7,  // _64_BYTE
};

/// Receive FIFO 1 Data Field Size
/// Register: RXESC
/// Field: F1DS [4:6]
enum class MCAN0_RXESC_F1DS : uint32_t {
    VAL_8_BYTE = 0x0,  // _8_BYTE
    VAL_12_BYTE = 0x1,  // _12_BYTE
    VAL_16_BYTE = 0x2,  // _16_BYTE
    VAL_20_BYTE = 0x3,  // _20_BYTE
    VAL_24_BYTE = 0x4,  // _24_BYTE
    VAL_32_BYTE = 0x5,  // _32_BYTE
    VAL_48_BYTE = 0x6,  // _48_BYTE
    VAL_64_BYTE = 0x7,  // _64_BYTE
};

/// Receive Buffer Data Field Size
/// Register: RXESC
/// Field: RBDS [8:10]
enum class MCAN0_RXESC_RBDS : uint32_t {
    VAL_8_BYTE = 0x0,  // _8_BYTE
    VAL_12_BYTE = 0x1,  // _12_BYTE
    VAL_16_BYTE = 0x2,  // _16_BYTE
    VAL_20_BYTE = 0x3,  // _20_BYTE
    VAL_24_BYTE = 0x4,  // _24_BYTE
    VAL_32_BYTE = 0x5,  // _32_BYTE
    VAL_48_BYTE = 0x6,  // _48_BYTE
    VAL_64_BYTE = 0x7,  // _64_BYTE
};

/// Tx Buffer Data Field Size
/// Register: TXESC
/// Field: TBDS [0:2]
enum class MCAN0_TXESC_TBDS : uint32_t {
    VAL_8_BYTE = 0x0,  // _8_BYTE
    VAL_12_BYTE = 0x1,  // _12_BYTE
    VAL_16_BYTE = 0x2,  // _16_BYTE
    VAL_20_BYTE = 0x3,  // _20_BYTE
    VAL_24_BYTE = 0x4,  // _24_BYTE
    VAL_32_BYTE = 0x5,  // _32_BYTE
    VAL_48_BYTE = 0x6,  // _48_BYTE
    VAL_64_BYTE = 0x7,  // _64_BYTE
};

// ----------------------------------------------------------------------------
// PIOA - Parallel Input/Output Controller
// ----------------------------------------------------------------------------

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class PIOA_WPMR_WPKEY : uint32_t {
    PASSWD = 0x50494F,
};

/// Drive of PIO Line 0
/// Register: DRIVER
/// Field: LINE0 [0:0]
enum class PIOA_DRIVER_LINE0 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 1
/// Register: DRIVER
/// Field: LINE1 [1:1]
enum class PIOA_DRIVER_LINE1 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 2
/// Register: DRIVER
/// Field: LINE2 [2:2]
enum class PIOA_DRIVER_LINE2 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 3
/// Register: DRIVER
/// Field: LINE3 [3:3]
enum class PIOA_DRIVER_LINE3 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 4
/// Register: DRIVER
/// Field: LINE4 [4:4]
enum class PIOA_DRIVER_LINE4 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 5
/// Register: DRIVER
/// Field: LINE5 [5:5]
enum class PIOA_DRIVER_LINE5 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 6
/// Register: DRIVER
/// Field: LINE6 [6:6]
enum class PIOA_DRIVER_LINE6 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 7
/// Register: DRIVER
/// Field: LINE7 [7:7]
enum class PIOA_DRIVER_LINE7 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 8
/// Register: DRIVER
/// Field: LINE8 [8:8]
enum class PIOA_DRIVER_LINE8 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 9
/// Register: DRIVER
/// Field: LINE9 [9:9]
enum class PIOA_DRIVER_LINE9 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 10
/// Register: DRIVER
/// Field: LINE10 [10:10]
enum class PIOA_DRIVER_LINE10 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 11
/// Register: DRIVER
/// Field: LINE11 [11:11]
enum class PIOA_DRIVER_LINE11 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 12
/// Register: DRIVER
/// Field: LINE12 [12:12]
enum class PIOA_DRIVER_LINE12 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 13
/// Register: DRIVER
/// Field: LINE13 [13:13]
enum class PIOA_DRIVER_LINE13 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 14
/// Register: DRIVER
/// Field: LINE14 [14:14]
enum class PIOA_DRIVER_LINE14 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 15
/// Register: DRIVER
/// Field: LINE15 [15:15]
enum class PIOA_DRIVER_LINE15 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 16
/// Register: DRIVER
/// Field: LINE16 [16:16]
enum class PIOA_DRIVER_LINE16 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 17
/// Register: DRIVER
/// Field: LINE17 [17:17]
enum class PIOA_DRIVER_LINE17 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 18
/// Register: DRIVER
/// Field: LINE18 [18:18]
enum class PIOA_DRIVER_LINE18 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 19
/// Register: DRIVER
/// Field: LINE19 [19:19]
enum class PIOA_DRIVER_LINE19 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 20
/// Register: DRIVER
/// Field: LINE20 [20:20]
enum class PIOA_DRIVER_LINE20 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 21
/// Register: DRIVER
/// Field: LINE21 [21:21]
enum class PIOA_DRIVER_LINE21 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 22
/// Register: DRIVER
/// Field: LINE22 [22:22]
enum class PIOA_DRIVER_LINE22 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 23
/// Register: DRIVER
/// Field: LINE23 [23:23]
enum class PIOA_DRIVER_LINE23 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 24
/// Register: DRIVER
/// Field: LINE24 [24:24]
enum class PIOA_DRIVER_LINE24 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 25
/// Register: DRIVER
/// Field: LINE25 [25:25]
enum class PIOA_DRIVER_LINE25 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 26
/// Register: DRIVER
/// Field: LINE26 [26:26]
enum class PIOA_DRIVER_LINE26 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 27
/// Register: DRIVER
/// Field: LINE27 [27:27]
enum class PIOA_DRIVER_LINE27 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 28
/// Register: DRIVER
/// Field: LINE28 [28:28]
enum class PIOA_DRIVER_LINE28 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 29
/// Register: DRIVER
/// Field: LINE29 [29:29]
enum class PIOA_DRIVER_LINE29 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 30
/// Register: DRIVER
/// Field: LINE30 [30:30]
enum class PIOA_DRIVER_LINE30 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Drive of PIO Line 31
/// Register: DRIVER
/// Field: LINE31 [31:31]
enum class PIOA_DRIVER_LINE31 : uint32_t {
    LOW_DRIVE = 0x0,
    HIGH_DRIVE = 0x1,
};

/// Parallel Capture Mode Data Size
/// Register: PCMR
/// Field: DSIZE [4:5]
enum class PIOA_PCMR_DSIZE : uint32_t {
    BYTE = 0x0,
    HALFWORD = 0x1,
    WORD = 0x2,
};

// ----------------------------------------------------------------------------
// PMC - Power Management Controller
// ----------------------------------------------------------------------------

/// Main RC Oscillator Frequency Selection
/// Register: CKGR_MOR
/// Field: MOSCRCF [4:6]
enum class PMC_CKGR_MOR_MOSCRCF : uint32_t {
    VAL_4_MHz = 0x0,  // _4_MHz
    VAL_8_MHz = 0x1,  // _8_MHz
    VAL_12_MHz = 0x2,  // _12_MHz
};

/// Write Access Password
/// Register: CKGR_MOR
/// Field: KEY [16:23]
enum class PMC_CKGR_MOR_KEY : uint32_t {
    PASSWD = 0x37,
};

/// PLLA Front End Divider
/// Register: CKGR_PLLAR
/// Field: DIVA [0:7]
enum class PMC_CKGR_PLLAR_DIVA : uint32_t {
    VAL_0 = 0x0,  // _0
    BYPASS = 0x1,
};

/// Master Clock Source Selection
/// Register: MCKR
/// Field: CSS [0:1]
enum class PMC_MCKR_CSS : uint32_t {
    SLOW_CLK = 0x0,
    MAIN_CLK = 0x1,
    PLLA_CLK = 0x2,
    UPLL_CLK = 0x3,
};

/// Processor Clock Prescaler
/// Register: MCKR
/// Field: PRES [4:6]
enum class PMC_MCKR_PRES : uint32_t {
    CLK_1 = 0x0,
    CLK_2 = 0x1,
    CLK_4 = 0x2,
    CLK_8 = 0x3,
    CLK_16 = 0x4,
    CLK_32 = 0x5,
    CLK_64 = 0x6,
    CLK_3 = 0x7,
};

/// Master Clock Division
/// Register: MCKR
/// Field: MDIV [8:9]
enum class PMC_MCKR_MDIV : uint32_t {
    EQ_PCK = 0x0,
    PCK_DIV2 = 0x1,
    PCK_DIV4 = 0x2,
    PCK_DIV3 = 0x3,
};

/// Programmable Clock Source Selection
/// Register: PCK[8]
/// Field: CSS [0:2]
enum class PMC_PCK_8_CSS : uint32_t {
    SLOW_CLK = 0x0,
    MAIN_CLK = 0x1,
    PLLA_CLK = 0x2,
    UPLL_CLK = 0x3,
    MCK = 0x4,
};

/// Flash Low-power Mode
/// Register: FSMR
/// Field: FLPM [21:22]
enum class PMC_FSMR_FLPM : uint32_t {
    FLASH_STANDBY = 0x0,
    FLASH_DEEP_POWERDOWN = 0x1,
    FLASH_IDLE = 0x2,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class PMC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x504D43,
};

/// Generic Clock Source Selection
/// Register: PCR
/// Field: GCLKCSS [8:10]
enum class PMC_PCR_GCLKCSS : uint32_t {
    SLOW_CLK = 0x0,
    MAIN_CLK = 0x1,
    PLLA_CLK = 0x2,
    UPLL_CLK = 0x3,
    MCK_CLK = 0x4,
};

// ----------------------------------------------------------------------------
// PWM0 - Pulse Width Modulation Controller
// ----------------------------------------------------------------------------

/// CLKA Divide Factor
/// Register: CLK
/// Field: DIVA [0:7]
enum class PWM0_CLK_DIVA : uint32_t {
    CLKA_POFF = 0x0,
    PREA = 0x1,
};

/// CLKA Source Clock Selection
/// Register: CLK
/// Field: PREA [8:11]
enum class PWM0_CLK_PREA : uint32_t {
    CLK = 0x0,
    CLK_DIV2 = 0x1,
    CLK_DIV4 = 0x2,
    CLK_DIV8 = 0x3,
    CLK_DIV16 = 0x4,
    CLK_DIV32 = 0x5,
    CLK_DIV64 = 0x6,
    CLK_DIV128 = 0x7,
    CLK_DIV256 = 0x8,
    CLK_DIV512 = 0x9,
    CLK_DIV1024 = 0xA,
};

/// CLKB Divide Factor
/// Register: CLK
/// Field: DIVB [16:23]
enum class PWM0_CLK_DIVB : uint32_t {
    CLKB_POFF = 0x0,
    PREB = 0x1,
};

/// CLKB Source Clock Selection
/// Register: CLK
/// Field: PREB [24:27]
enum class PWM0_CLK_PREB : uint32_t {
    CLK = 0x0,
    CLK_DIV2 = 0x1,
    CLK_DIV4 = 0x2,
    CLK_DIV8 = 0x3,
    CLK_DIV16 = 0x4,
    CLK_DIV32 = 0x5,
    CLK_DIV64 = 0x6,
    CLK_DIV128 = 0x7,
    CLK_DIV256 = 0x8,
    CLK_DIV512 = 0x9,
    CLK_DIV1024 = 0xA,
};

/// Synchronous Channels Update Mode
/// Register: SCM
/// Field: UPDM [16:17]
enum class PWM0_SCM_UPDM : uint32_t {
    MODE0 = 0x0,
    MODE1 = 0x1,
    MODE2 = 0x2,
};

/// Write Protection Command
/// Register: WPCR
/// Field: WPCMD [0:1]
enum class PWM0_WPCR_WPCMD : uint32_t {
    DISABLE_SW_PROT = 0x0,
    ENABLE_SW_PROT = 0x1,
    ENABLE_HW_PROT = 0x2,
};

/// Write Protection Key
/// Register: WPCR
/// Field: WPKEY [8:31]
enum class PWM0_WPCR_WPKEY : uint32_t {
    PASSWD = 0x50574D,
};

/// Comparison x Value Mode
/// Register: CMPV
/// Field: CVM [24:24]
enum class PWM0_CMPV_CVM : uint32_t {
    COMPARE_AT_INCREMENT = 0x0,
    COMPARE_AT_DECREMENT = 0x1,
};

/// Channel Pre-scaler
/// Register: CMR
/// Field: CPRE [0:3]
enum class PWM0_CMR_CPRE : uint32_t {
    MCK = 0x0,
    MCK_DIV_2 = 0x1,
    MCK_DIV_4 = 0x2,
    MCK_DIV_8 = 0x3,
    MCK_DIV_16 = 0x4,
    MCK_DIV_32 = 0x5,
    MCK_DIV_64 = 0x6,
    MCK_DIV_128 = 0x7,
    MCK_DIV_256 = 0x8,
    MCK_DIV_512 = 0x9,
    MCK_DIV_1024 = 0xA,
    CLKA = 0xB,
    CLKB = 0xC,
};

/// Channel Alignment
/// Register: CMR
/// Field: CALG [8:8]
enum class PWM0_CMR_CALG : uint32_t {
    LEFT_ALIGNED = 0x0,
    CENTER_ALIGNED = 0x1,
};

/// Channel Polarity
/// Register: CMR
/// Field: CPOL [9:9]
enum class PWM0_CMR_CPOL : uint32_t {
    LOW_POLARITY = 0x0,
    HIGH_POLARITY = 0x1,
};

/// Counter Event Selection
/// Register: CMR
/// Field: CES [10:10]
enum class PWM0_CMR_CES : uint32_t {
    SINGLE_EVENT = 0x0,
    DOUBLE_EVENT = 0x1,
};

/// Update Selection
/// Register: CMR
/// Field: UPDS [11:11]
enum class PWM0_CMR_UPDS : uint32_t {
    UPDATE_AT_PERIOD = 0x0,
    UPDATE_AT_HALF_PERIOD = 0x1,
};

/// External Trigger Mode
/// Register: ETRG1
/// Field: TRGMODE [24:25]
enum class PWM0_ETRG1_TRGMODE : uint32_t {
    OFF = 0x0,
    MODE1 = 0x1,
    MODE2 = 0x2,
    MODE3 = 0x3,
};

/// Edge Selection
/// Register: ETRG1
/// Field: TRGEDGE [28:28]
enum class PWM0_ETRG1_TRGEDGE : uint32_t {
    FALLING_ZERO = 0x0,
    RISING_ONE = 0x1,
};

/// External Trigger Mode
/// Register: ETRG2
/// Field: TRGMODE [24:25]
enum class PWM0_ETRG2_TRGMODE : uint32_t {
    OFF = 0x0,
    MODE1 = 0x1,
    MODE2 = 0x2,
    MODE3 = 0x3,
};

/// Edge Selection
/// Register: ETRG2
/// Field: TRGEDGE [28:28]
enum class PWM0_ETRG2_TRGEDGE : uint32_t {
    FALLING_ZERO = 0x0,
    RISING_ONE = 0x1,
};

// ----------------------------------------------------------------------------
// QSPI - Quad Serial Peripheral Interface
// ----------------------------------------------------------------------------

/// Serial Memory Mode
/// Register: MR
/// Field: SMM [0:0]
enum class QSPI_MR_SMM : uint32_t {
    SPI = 0x0,
    MEMORY = 0x1,
};

/// Local Loopback Enable
/// Register: MR
/// Field: LLB [1:1]
enum class QSPI_MR_LLB : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Wait Data Read Before Transfer
/// Register: MR
/// Field: WDRBT [2:2]
enum class QSPI_MR_WDRBT : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Chip Select Mode
/// Register: MR
/// Field: CSMODE [4:5]
enum class QSPI_MR_CSMODE : uint32_t {
    NOT_RELOADED = 0x0,
    LASTXFER = 0x1,
    SYSTEMATICALLY = 0x2,
};

/// Number Of Bits Per Transfer
/// Register: MR
/// Field: NBBITS [8:11]
enum class QSPI_MR_NBBITS : uint32_t {
    VAL_8_BIT = 0x0,  // _8_BIT
    VAL_16_BIT = 0x8,  // _16_BIT
};

/// Width of Instruction Code, Address, Option Code and Data
/// Register: IFR
/// Field: WIDTH [0:2]
enum class QSPI_IFR_WIDTH : uint32_t {
    SINGLE_BIT_SPI = 0x0,
    DUAL_OUTPUT = 0x1,
    QUAD_OUTPUT = 0x2,
    DUAL_IO = 0x3,
    QUAD_IO = 0x4,
    DUAL_CMD = 0x5,
    QUAD_CMD = 0x6,
};

/// Option Code Length
/// Register: IFR
/// Field: OPTL [8:9]
enum class QSPI_IFR_OPTL : uint32_t {
    OPTION_1BIT = 0x0,
    OPTION_2BIT = 0x1,
    OPTION_4BIT = 0x2,
    OPTION_8BIT = 0x3,
};

/// Address Length
/// Register: IFR
/// Field: ADDRL [10:10]
enum class QSPI_IFR_ADDRL : uint32_t {
    VAL_24_BIT = 0x0,  // _24_BIT
    VAL_32_BIT = 0x1,  // _32_BIT
};

/// Data Transfer Type
/// Register: IFR
/// Field: TFRTYP [12:13]
enum class QSPI_IFR_TFRTYP : uint32_t {
    TRSFR_READ = 0x0,
    TRSFR_READ_MEMORY = 0x1,
    TRSFR_WRITE = 0x2,
    TRSFR_WRITE_MEMORY = 0x3,
};

/// Continuous Read Mode
/// Register: IFR
/// Field: CRM [14:14]
enum class QSPI_IFR_CRM : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Scrambling/Unscrambling Enable
/// Register: SMR
/// Field: SCREN [0:0]
enum class QSPI_SMR_SCREN : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class QSPI_WPMR_WPKEY : uint32_t {
    PASSWD = 0x515350,
};

// ----------------------------------------------------------------------------
// RSTC - Reset Controller
// ----------------------------------------------------------------------------

/// System Reset Key
/// Register: CR
/// Field: KEY [24:31]
enum class RSTC_CR_KEY : uint32_t {
    PASSWD = 0xA5,
};

/// Reset Type
/// Register: SR
/// Field: RSTTYP [8:10]
enum class RSTC_SR_RSTTYP : uint32_t {
    GENERAL_RST = 0x0,
    BACKUP_RST = 0x1,
    WDT_RST = 0x2,
    SOFT_RST = 0x3,
    USER_RST = 0x4,
};

/// Write Access Password
/// Register: MR
/// Field: KEY [24:31]
enum class RSTC_MR_KEY : uint32_t {
    PASSWD = 0xA5,
};

// ----------------------------------------------------------------------------
// RSWDT - Reinforced Safety Watchdog Timer
// ----------------------------------------------------------------------------

/// Password
/// Register: CR
/// Field: KEY [24:31]
enum class RSWDT_CR_KEY : uint32_t {
    PASSWD = 0xC4,
};

// ----------------------------------------------------------------------------
// RTC - Real-time Clock
// ----------------------------------------------------------------------------

/// Time Event Selection
/// Register: CR
/// Field: TIMEVSEL [8:9]
enum class RTC_CR_TIMEVSEL : uint32_t {
    MINUTE = 0x0,
    HOUR = 0x1,
    MIDNIGHT = 0x2,
    NOON = 0x3,
};

/// Calendar Event Selection
/// Register: CR
/// Field: CALEVSEL [16:17]
enum class RTC_CR_CALEVSEL : uint32_t {
    WEEK = 0x0,
    MONTH = 0x1,
    YEAR = 0x2,
};

/// RTCOUT0 OutputSource Selection
/// Register: MR
/// Field: OUT0 [16:18]
enum class RTC_MR_OUT0 : uint32_t {
    NO_WAVE = 0x0,
    FREQ1HZ = 0x1,
    FREQ32HZ = 0x2,
    FREQ64HZ = 0x3,
    FREQ512HZ = 0x4,
    ALARM_TOGGLE = 0x5,
    ALARM_FLAG = 0x6,
    PROG_PULSE = 0x7,
};

/// RTCOUT1 Output Source Selection
/// Register: MR
/// Field: OUT1 [20:22]
enum class RTC_MR_OUT1 : uint32_t {
    NO_WAVE = 0x0,
    FREQ1HZ = 0x1,
    FREQ32HZ = 0x2,
    FREQ64HZ = 0x3,
    FREQ512HZ = 0x4,
    ALARM_TOGGLE = 0x5,
    ALARM_FLAG = 0x6,
    PROG_PULSE = 0x7,
};

/// High Duration of the Output Pulse
/// Register: MR
/// Field: THIGH [24:26]
enum class RTC_MR_THIGH : uint32_t {
    H_31MS = 0x0,
    H_16MS = 0x1,
    H_4MS = 0x2,
    H_976US = 0x3,
    H_488US = 0x4,
    H_122US = 0x5,
    H_30US = 0x6,
    H_15US = 0x7,
};

/// Period of the Output Pulse
/// Register: MR
/// Field: TPERIOD [28:29]
enum class RTC_MR_TPERIOD : uint32_t {
    P_1S = 0x0,
    P_500MS = 0x1,
    P_250MS = 0x2,
    P_125MS = 0x3,
};

/// Acknowledge for Update
/// Register: SR
/// Field: ACKUPD [0:0]
enum class RTC_SR_ACKUPD : uint32_t {
    FREERUN = 0x0,
    UPDATE = 0x1,
};

/// Alarm Flag
/// Register: SR
/// Field: ALARM [1:1]
enum class RTC_SR_ALARM : uint32_t {
    NO_ALARMEVENT = 0x0,
    ALARMEVENT = 0x1,
};

/// Second Event
/// Register: SR
/// Field: SEC [2:2]
enum class RTC_SR_SEC : uint32_t {
    NO_SECEVENT = 0x0,
    SECEVENT = 0x1,
};

/// Time Event
/// Register: SR
/// Field: TIMEV [3:3]
enum class RTC_SR_TIMEV : uint32_t {
    NO_TIMEVENT = 0x0,
    TIMEVENT = 0x1,
};

/// Calendar Event
/// Register: SR
/// Field: CALEV [4:4]
enum class RTC_SR_CALEV : uint32_t {
    NO_CALEVENT = 0x0,
    CALEVENT = 0x1,
};

/// Time and/or Date Free Running Error
/// Register: SR
/// Field: TDERR [5:5]
enum class RTC_SR_TDERR : uint32_t {
    CORRECT = 0x0,
    ERR_TIMEDATE = 0x1,
};

// ----------------------------------------------------------------------------
// SCB - System Control Block
// ----------------------------------------------------------------------------

/// Indicates whether there is an active exception other than the exception indicated by the current value of the IPSR
/// Register: ICSR
/// Field: RETTOBASE [11:11]
enum class SCB_ICSR_RETTOBASE : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Indicates whether a pending exception will be serviced on exit from debug halt state
/// Register: ICSR
/// Field: ISRPREEMPT [23:23]
enum class SCB_ICSR_ISRPREEMPT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Removes the pending status of the SysTick exception
/// Register: ICSR
/// Field: PENDSTCLR [25:25]
enum class SCB_ICSR_PENDSTCLR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Sets the SysTick exception as pending, or reads the current state of the exception
/// Register: ICSR
/// Field: PENDSTSET [26:26]
enum class SCB_ICSR_PENDSTSET : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Removes the pending status of the PendSV exception
/// Register: ICSR
/// Field: PENDSVCLR [27:27]
enum class SCB_ICSR_PENDSVCLR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Sets the PendSV exception as pending, or reads the current state of the exception
/// Register: ICSR
/// Field: PENDSVSET [28:28]
enum class SCB_ICSR_PENDSVSET : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Makes the NMI exception active, or reads the state of the exception
/// Register: ICSR
/// Field: NMIPENDSET [31:31]
enum class SCB_ICSR_NMIPENDSET : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// System Reset Request
/// Register: AIRCR
/// Field: SYSRESETREQ [2:2]
enum class SCB_AIRCR_SYSRESETREQ : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Memory system endianness
/// Register: AIRCR
/// Field: ENDIANNESS [15:15]
enum class SCB_AIRCR_ENDIANNESS : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Determines whether, on an exit from an ISR that returns to the base level of execution priority, the processor enters a sleep state
/// Register: SCR
/// Field: SLEEPONEXIT [1:1]
enum class SCB_SCR_SLEEPONEXIT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Provides a qualifying hint indicating that waking from sleep might take longer
/// Register: SCR
/// Field: SLEEPDEEP [2:2]
enum class SCB_SCR_SLEEPDEEP : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Determines whether an interrupt transition from inactive state to pending state is a wakeup event
/// Register: SCR
/// Field: SEVONPEND [4:4]
enum class SCB_SCR_SEVONPEND : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Controls whether the processor can enter Thread mode with exceptions active
/// Register: CCR
/// Field: NONBASETHRDENA [0:0]
enum class SCB_CCR_NONBASETHRDENA : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Enables unprivileged software access to the STIR
/// Register: CCR
/// Field: USERSETMPEND [1:1]
enum class SCB_CCR_USERSETMPEND : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Enables unaligned access traps
/// Register: CCR
/// Field: UNALIGN_TRP [3:3]
enum class SCB_CCR_UNALIGN_TRP : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
/// Register: CCR
/// Field: DIV_0_TRP [4:4]
enum class SCB_CCR_DIV_0_TRP : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
/// Register: CCR
/// Field: BFHFNMIGN [8:8]
enum class SCB_CCR_BFHFNMIGN : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Indicates stack alignment on exception entry
/// Register: CCR
/// Field: STKALIGN [9:9]
enum class SCB_CCR_STKALIGN : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// MEMFAULTACT
/// Register: SHCSR
/// Field: MEMFAULTACT [0:0]
enum class SCB_SHCSR_MEMFAULTACT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// BUSFAULTACT
/// Register: SHCSR
/// Field: BUSFAULTACT [1:1]
enum class SCB_SHCSR_BUSFAULTACT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// USGFAULTACT
/// Register: SHCSR
/// Field: USGFAULTACT [3:3]
enum class SCB_SHCSR_USGFAULTACT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// SVCALLACT
/// Register: SHCSR
/// Field: SVCALLACT [7:7]
enum class SCB_SHCSR_SVCALLACT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// MONITORACT
/// Register: SHCSR
/// Field: MONITORACT [8:8]
enum class SCB_SHCSR_MONITORACT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// PENDSVACT
/// Register: SHCSR
/// Field: PENDSVACT [10:10]
enum class SCB_SHCSR_PENDSVACT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// SYSTICKACT
/// Register: SHCSR
/// Field: SYSTICKACT [11:11]
enum class SCB_SHCSR_SYSTICKACT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// USGFAULTPENDED
/// Register: SHCSR
/// Field: USGFAULTPENDED [12:12]
enum class SCB_SHCSR_USGFAULTPENDED : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// MEMFAULTPENDED
/// Register: SHCSR
/// Field: MEMFAULTPENDED [13:13]
enum class SCB_SHCSR_MEMFAULTPENDED : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// BUSFAULTPENDED
/// Register: SHCSR
/// Field: BUSFAULTPENDED [14:14]
enum class SCB_SHCSR_BUSFAULTPENDED : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// SVCALLPENDED
/// Register: SHCSR
/// Field: SVCALLPENDED [15:15]
enum class SCB_SHCSR_SVCALLPENDED : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// MEMFAULTENA
/// Register: SHCSR
/// Field: MEMFAULTENA [16:16]
enum class SCB_SHCSR_MEMFAULTENA : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// BUSFAULTENA
/// Register: SHCSR
/// Field: BUSFAULTENA [17:17]
enum class SCB_SHCSR_BUSFAULTENA : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// USGFAULTENA
/// Register: SHCSR
/// Field: USGFAULTENA [18:18]
enum class SCB_SHCSR_USGFAULTENA : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// IACCVIOL
/// Register: CFSR
/// Field: IACCVIOL [0:0]
enum class SCB_CFSR_IACCVIOL : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// DACCVIOL
/// Register: CFSR
/// Field: DACCVIOL [1:1]
enum class SCB_CFSR_DACCVIOL : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// MUNSTKERR
/// Register: CFSR
/// Field: MUNSTKERR [3:3]
enum class SCB_CFSR_MUNSTKERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// MSTKERR
/// Register: CFSR
/// Field: MSTKERR [4:4]
enum class SCB_CFSR_MSTKERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// MLSPERR
/// Register: CFSR
/// Field: MLSPERR [5:5]
enum class SCB_CFSR_MLSPERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// MMARVALID
/// Register: CFSR
/// Field: MMARVALID [7:7]
enum class SCB_CFSR_MMARVALID : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// IBUSERR
/// Register: CFSR
/// Field: IBUSERR [8:8]
enum class SCB_CFSR_IBUSERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// PRECISERR
/// Register: CFSR
/// Field: PRECISERR [9:9]
enum class SCB_CFSR_PRECISERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// IMPRECISERR
/// Register: CFSR
/// Field: IMPRECISERR [10:10]
enum class SCB_CFSR_IMPRECISERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// UNSTKERR
/// Register: CFSR
/// Field: UNSTKERR [11:11]
enum class SCB_CFSR_UNSTKERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// STKERR
/// Register: CFSR
/// Field: STKERR [12:12]
enum class SCB_CFSR_STKERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// LSPERR
/// Register: CFSR
/// Field: LSPERR [13:13]
enum class SCB_CFSR_LSPERR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// BFARVALID
/// Register: CFSR
/// Field: BFARVALID [15:15]
enum class SCB_CFSR_BFARVALID : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// UNDEFINSTR
/// Register: CFSR
/// Field: UNDEFINSTR [16:16]
enum class SCB_CFSR_UNDEFINSTR : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// INVSTATE
/// Register: CFSR
/// Field: INVSTATE [17:17]
enum class SCB_CFSR_INVSTATE : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// INVPC
/// Register: CFSR
/// Field: INVPC [18:18]
enum class SCB_CFSR_INVPC : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// NOCP
/// Register: CFSR
/// Field: NOCP [19:19]
enum class SCB_CFSR_NOCP : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// UNALIGNED
/// Register: CFSR
/// Field: UNALIGNED [24:24]
enum class SCB_CFSR_UNALIGNED : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// DIVBYZERO
/// Register: CFSR
/// Field: DIVBYZERO [25:25]
enum class SCB_CFSR_DIVBYZERO : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Indicates when a fault has occurred because of a vector table read error on exception processing
/// Register: HFSR
/// Field: VECTTBL [1:1]
enum class SCB_HFSR_VECTTBL : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Indicates that a fault with configurable priority has been escalated to a HardFault exception
/// Register: HFSR
/// Field: FORCED [30:30]
enum class SCB_HFSR_FORCED : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// debug event generated by
/// Register: DFSR
/// Field: HALTED [0:0]
enum class SCB_DFSR_HALTED : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// debug event generated by BKPT instruction execution or a breakpoint match in FPB
/// Register: DFSR
/// Field: BKPT [1:1]
enum class SCB_DFSR_BKPT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// debug event generated by the DWT
/// Register: DFSR
/// Field: DWTTRAP [2:2]
enum class SCB_DFSR_DWTTRAP : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// triggering of a Vector catch
/// Register: DFSR
/// Field: VCATCH [3:3]
enum class SCB_DFSR_VCATCH : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// debug event generated because of the assertion of an external debug request
/// Register: DFSR
/// Field: EXTERNAL [4:4]
enum class SCB_DFSR_EXTERNAL : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Level of Coherency
/// Register: CLIDR
/// Field: LoC [24:26]
enum class SCB_CLIDR_LOC : uint32_t {
    LEVEL_1 = 0x0,
    LEVEL_2 = 0x1,
};

/// Level of Unification
/// Register: CLIDR
/// Field: LoU [27:29]
enum class SCB_CLIDR_LOU : uint32_t {
    LEVEL_1 = 0x0,
    LEVEL_2 = 0x1,
};

/// selection of instruction or data cache
/// Register: CSSELR
/// Field: IND [0:0]
enum class SCB_CSSELR_IND : uint32_t {
    DATA = 0x0,
    INSTRUCTION = 0x1,
};

// ----------------------------------------------------------------------------
// SSC - Synchronous Serial Controller
// ----------------------------------------------------------------------------

/// Receive Clock Selection
/// Register: RCMR
/// Field: CKS [0:1]
enum class SSC_RCMR_CKS : uint32_t {
    MCK = 0x0,
    TK = 0x1,
    RK = 0x2,
};

/// Receive Clock Output Mode Selection
/// Register: RCMR
/// Field: CKO [2:4]
enum class SSC_RCMR_CKO : uint32_t {
    NONE = 0x0,
    CONTINUOUS = 0x1,
    TRANSFER = 0x2,
};

/// Receive Clock Gating Selection
/// Register: RCMR
/// Field: CKG [6:7]
enum class SSC_RCMR_CKG : uint32_t {
    CONTINUOUS = 0x0,
    EN_RF_LOW = 0x1,
    EN_RF_HIGH = 0x2,
};

/// Receive Start Selection
/// Register: RCMR
/// Field: START [8:11]
enum class SSC_RCMR_START : uint32_t {
    CONTINUOUS = 0x0,
    TRANSMIT = 0x1,
    RF_LOW = 0x2,
    RF_HIGH = 0x3,
    RF_FALLING = 0x4,
    RF_RISING = 0x5,
    RF_LEVEL = 0x6,
    RF_EDGE = 0x7,
    CMP_0 = 0x8,
};

/// Receive Frame Sync Output Selection
/// Register: RFMR
/// Field: FSOS [20:22]
enum class SSC_RFMR_FSOS : uint32_t {
    NONE = 0x0,
    NEGATIVE = 0x1,
    POSITIVE = 0x2,
    LOW = 0x3,
    HIGH = 0x4,
    TOGGLING = 0x5,
};

/// Frame Sync Edge Detection
/// Register: RFMR
/// Field: FSEDGE [24:24]
enum class SSC_RFMR_FSEDGE : uint32_t {
    POSITIVE = 0x0,
    NEGATIVE = 0x1,
};

/// Transmit Clock Selection
/// Register: TCMR
/// Field: CKS [0:1]
enum class SSC_TCMR_CKS : uint32_t {
    MCK = 0x0,
    RK = 0x1,
    TK = 0x2,
};

/// Transmit Clock Output Mode Selection
/// Register: TCMR
/// Field: CKO [2:4]
enum class SSC_TCMR_CKO : uint32_t {
    NONE = 0x0,
    CONTINUOUS = 0x1,
    TRANSFER = 0x2,
};

/// Transmit Clock Gating Selection
/// Register: TCMR
/// Field: CKG [6:7]
enum class SSC_TCMR_CKG : uint32_t {
    CONTINUOUS = 0x0,
    EN_TF_LOW = 0x1,
    EN_TF_HIGH = 0x2,
};

/// Transmit Start Selection
/// Register: TCMR
/// Field: START [8:11]
enum class SSC_TCMR_START : uint32_t {
    CONTINUOUS = 0x0,
    RECEIVE = 0x1,
    TF_LOW = 0x2,
    TF_HIGH = 0x3,
    TF_FALLING = 0x4,
    TF_RISING = 0x5,
    TF_LEVEL = 0x6,
    TF_EDGE = 0x7,
};

/// Transmit Frame Sync Output Selection
/// Register: TFMR
/// Field: FSOS [20:22]
enum class SSC_TFMR_FSOS : uint32_t {
    NONE = 0x0,
    NEGATIVE = 0x1,
    POSITIVE = 0x2,
    LOW = 0x3,
    HIGH = 0x4,
    TOGGLING = 0x5,
};

/// Frame Sync Edge Detection
/// Register: TFMR
/// Field: FSEDGE [24:24]
enum class SSC_TFMR_FSEDGE : uint32_t {
    POSITIVE = 0x0,
    NEGATIVE = 0x1,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class SSC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x535343,
};

// ----------------------------------------------------------------------------
// SUPC - Supply Controller
// ----------------------------------------------------------------------------

/// Voltage Regulator Off
/// Register: CR
/// Field: VROFF [2:2]
enum class SUPC_CR_VROFF : uint32_t {
    NO_EFFECT = 0x0,
    STOP_VREG = 0x1,
};

/// Crystal Oscillator Select
/// Register: CR
/// Field: XTALSEL [3:3]
enum class SUPC_CR_XTALSEL : uint32_t {
    NO_EFFECT = 0x0,
    CRYSTAL_SEL = 0x1,
};

/// Password
/// Register: CR
/// Field: KEY [24:31]
enum class SUPC_CR_KEY : uint32_t {
    PASSWD = 0xA5,
};

/// Supply Monitor Sampling Period
/// Register: SMMR
/// Field: SMSMPL [8:10]
enum class SUPC_SMMR_SMSMPL : uint32_t {
    SMD = 0x0,
    CSM = 0x1,
    VAL_32SLCK = 0x2,  // _32SLCK
    VAL_256SLCK = 0x3,  // _256SLCK
    VAL_2048SLCK = 0x4,  // _2048SLCK
};

/// Supply Monitor Reset Enable
/// Register: SMMR
/// Field: SMRSTEN [12:12]
enum class SUPC_SMMR_SMRSTEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Supply Monitor Interrupt Enable
/// Register: SMMR
/// Field: SMIEN [13:13]
enum class SUPC_SMMR_SMIEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Brownout Detector Reset Enable
/// Register: MR
/// Field: BODRSTEN [12:12]
enum class SUPC_MR_BODRSTEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Brownout Detector Disable
/// Register: MR
/// Field: BODDIS [13:13]
enum class SUPC_MR_BODDIS : uint32_t {
    ENABLE = 0x0,
    DISABLE = 0x1,
};

/// Voltage Regulator Enable
/// Register: MR
/// Field: ONREG [14:14]
enum class SUPC_MR_ONREG : uint32_t {
    ONREG_UNUSED = 0x0,
    ONREG_USED = 0x1,
};

/// Oscillator Bypass
/// Register: MR
/// Field: OSCBYPASS [20:20]
enum class SUPC_MR_OSCBYPASS : uint32_t {
    NO_EFFECT = 0x0,
    BYPASS = 0x1,
};

/// Password Key
/// Register: MR
/// Field: KEY [24:31]
enum class SUPC_MR_KEY : uint32_t {
    PASSWD = 0xA5,
};

/// Supply Monitor Wake-up Enable
/// Register: WUMR
/// Field: SMEN [1:1]
enum class SUPC_WUMR_SMEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Real-time Timer Wake-up Enable
/// Register: WUMR
/// Field: RTTEN [2:2]
enum class SUPC_WUMR_RTTEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Real-time Clock Wake-up Enable
/// Register: WUMR
/// Field: RTCEN [3:3]
enum class SUPC_WUMR_RTCEN : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Low-power Debouncer Enable WKUP0
/// Register: WUMR
/// Field: LPDBCEN0 [5:5]
enum class SUPC_WUMR_LPDBCEN0 : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Low-power Debouncer Enable WKUP1
/// Register: WUMR
/// Field: LPDBCEN1 [6:6]
enum class SUPC_WUMR_LPDBCEN1 : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Low-power Debouncer Clear
/// Register: WUMR
/// Field: LPDBCCLR [7:7]
enum class SUPC_WUMR_LPDBCCLR : uint32_t {
    NOT_ENABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Inputs Debouncer Period
/// Register: WUMR
/// Field: WKUPDBC [12:14]
enum class SUPC_WUMR_WKUPDBC : uint32_t {
    IMMEDIATE = 0x0,
    VAL_3_SLCK = 0x1,  // _3_SLCK
    VAL_32_SLCK = 0x2,  // _32_SLCK
    VAL_512_SLCK = 0x3,  // _512_SLCK
    VAL_4096_SLCK = 0x4,  // _4096_SLCK
    VAL_32768_SLCK = 0x5,  // _32768_SLCK
};

/// Low-power Debouncer Period
/// Register: WUMR
/// Field: LPDBC [16:18]
enum class SUPC_WUMR_LPDBC : uint32_t {
    DISABLE = 0x0,
    VAL_2_RTCOUT = 0x1,  // _2_RTCOUT
    VAL_3_RTCOUT = 0x2,  // _3_RTCOUT
    VAL_4_RTCOUT = 0x3,  // _4_RTCOUT
    VAL_5_RTCOUT = 0x4,  // _5_RTCOUT
    VAL_6_RTCOUT = 0x5,  // _6_RTCOUT
    VAL_7_RTCOUT = 0x6,  // _7_RTCOUT
    VAL_8_RTCOUT = 0x7,  // _8_RTCOUT
};

/// Wake-up Input Enable 0 to 0
/// Register: WUIR
/// Field: WKUPEN0 [0:0]
enum class SUPC_WUIR_WKUPEN0 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 1
/// Register: WUIR
/// Field: WKUPEN1 [1:1]
enum class SUPC_WUIR_WKUPEN1 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 2
/// Register: WUIR
/// Field: WKUPEN2 [2:2]
enum class SUPC_WUIR_WKUPEN2 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 3
/// Register: WUIR
/// Field: WKUPEN3 [3:3]
enum class SUPC_WUIR_WKUPEN3 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 4
/// Register: WUIR
/// Field: WKUPEN4 [4:4]
enum class SUPC_WUIR_WKUPEN4 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 5
/// Register: WUIR
/// Field: WKUPEN5 [5:5]
enum class SUPC_WUIR_WKUPEN5 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 6
/// Register: WUIR
/// Field: WKUPEN6 [6:6]
enum class SUPC_WUIR_WKUPEN6 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 7
/// Register: WUIR
/// Field: WKUPEN7 [7:7]
enum class SUPC_WUIR_WKUPEN7 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 8
/// Register: WUIR
/// Field: WKUPEN8 [8:8]
enum class SUPC_WUIR_WKUPEN8 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 9
/// Register: WUIR
/// Field: WKUPEN9 [9:9]
enum class SUPC_WUIR_WKUPEN9 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 10
/// Register: WUIR
/// Field: WKUPEN10 [10:10]
enum class SUPC_WUIR_WKUPEN10 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 11
/// Register: WUIR
/// Field: WKUPEN11 [11:11]
enum class SUPC_WUIR_WKUPEN11 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 12
/// Register: WUIR
/// Field: WKUPEN12 [12:12]
enum class SUPC_WUIR_WKUPEN12 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Enable 0 to 13
/// Register: WUIR
/// Field: WKUPEN13 [13:13]
enum class SUPC_WUIR_WKUPEN13 : uint32_t {
    DISABLE = 0x0,
    ENABLE = 0x1,
};

/// Wake-up Input Type 0 to 0
/// Register: WUIR
/// Field: WKUPT0 [16:16]
enum class SUPC_WUIR_WKUPT0 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 1
/// Register: WUIR
/// Field: WKUPT1 [17:17]
enum class SUPC_WUIR_WKUPT1 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 2
/// Register: WUIR
/// Field: WKUPT2 [18:18]
enum class SUPC_WUIR_WKUPT2 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 3
/// Register: WUIR
/// Field: WKUPT3 [19:19]
enum class SUPC_WUIR_WKUPT3 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 4
/// Register: WUIR
/// Field: WKUPT4 [20:20]
enum class SUPC_WUIR_WKUPT4 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 5
/// Register: WUIR
/// Field: WKUPT5 [21:21]
enum class SUPC_WUIR_WKUPT5 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 6
/// Register: WUIR
/// Field: WKUPT6 [22:22]
enum class SUPC_WUIR_WKUPT6 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 7
/// Register: WUIR
/// Field: WKUPT7 [23:23]
enum class SUPC_WUIR_WKUPT7 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 8
/// Register: WUIR
/// Field: WKUPT8 [24:24]
enum class SUPC_WUIR_WKUPT8 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 9
/// Register: WUIR
/// Field: WKUPT9 [25:25]
enum class SUPC_WUIR_WKUPT9 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 10
/// Register: WUIR
/// Field: WKUPT10 [26:26]
enum class SUPC_WUIR_WKUPT10 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 11
/// Register: WUIR
/// Field: WKUPT11 [27:27]
enum class SUPC_WUIR_WKUPT11 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 12
/// Register: WUIR
/// Field: WKUPT12 [28:28]
enum class SUPC_WUIR_WKUPT12 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// Wake-up Input Type 0 to 13
/// Register: WUIR
/// Field: WKUPT13 [29:29]
enum class SUPC_WUIR_WKUPT13 : uint32_t {
    LOW = 0x0,
    HIGH = 0x1,
};

/// WKUP Wake-up Status (cleared on read)
/// Register: SR
/// Field: WKUPS [1:1]
enum class SUPC_SR_WKUPS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Supply Monitor Detection Wake-up Status (cleared on read)
/// Register: SR
/// Field: SMWS [2:2]
enum class SUPC_SR_SMWS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Brownout Detector Reset Status (cleared on read)
/// Register: SR
/// Field: BODRSTS [3:3]
enum class SUPC_SR_BODRSTS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Supply Monitor Reset Status (cleared on read)
/// Register: SR
/// Field: SMRSTS [4:4]
enum class SUPC_SR_SMRSTS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Supply Monitor Status (cleared on read)
/// Register: SR
/// Field: SMS [5:5]
enum class SUPC_SR_SMS : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Supply Monitor Output Status
/// Register: SR
/// Field: SMOS [6:6]
enum class SUPC_SR_SMOS : uint32_t {
    HIGH = 0x0,
    LOW = 0x1,
};

/// 32-kHz Oscillator Selection Status
/// Register: SR
/// Field: OSCSEL [7:7]
enum class SUPC_SR_OSCSEL : uint32_t {
    RC = 0x0,
    CRYST = 0x1,
};

/// Low-power Debouncer Wake-up Status on WKUP0 (cleared on read)
/// Register: SR
/// Field: LPDBCS0 [13:13]
enum class SUPC_SR_LPDBCS0 : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// Low-power Debouncer Wake-up Status on WKUP1 (cleared on read)
/// Register: SR
/// Field: LPDBCS1 [14:14]
enum class SUPC_SR_LPDBCS1 : uint32_t {
    NO = 0x0,
    PRESENT = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS0 [16:16]
enum class SUPC_SR_WKUPIS0 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS1 [17:17]
enum class SUPC_SR_WKUPIS1 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS2 [18:18]
enum class SUPC_SR_WKUPIS2 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS3 [19:19]
enum class SUPC_SR_WKUPIS3 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS4 [20:20]
enum class SUPC_SR_WKUPIS4 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS5 [21:21]
enum class SUPC_SR_WKUPIS5 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS6 [22:22]
enum class SUPC_SR_WKUPIS6 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS7 [23:23]
enum class SUPC_SR_WKUPIS7 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS8 [24:24]
enum class SUPC_SR_WKUPIS8 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS9 [25:25]
enum class SUPC_SR_WKUPIS9 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS10 [26:26]
enum class SUPC_SR_WKUPIS10 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS11 [27:27]
enum class SUPC_SR_WKUPIS11 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS12 [28:28]
enum class SUPC_SR_WKUPIS12 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// WKUPx Input Status (cleared on read)
/// Register: SR
/// Field: WKUPIS13 [29:29]
enum class SUPC_SR_WKUPIS13 : uint32_t {
    DIS = 0x0,
    EN = 0x1,
};

/// Write Protection Key
/// Register: SYSC_WPMR
/// Field: WPKEY [8:31]
enum class SUPC_SYSC_WPMR_WPKEY : uint32_t {
    PASSWD = 0x525443,
};

// ----------------------------------------------------------------------------
// SysTick - System timer
// ----------------------------------------------------------------------------

/// Enables the counter
/// Register: CSR
/// Field: ENABLE [0:0]
enum class SYSTICK_CSR_ENABLE : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Enables SysTick exception request
/// Register: CSR
/// Field: TICKINT [1:1]
enum class SYSTICK_CSR_TICKINT : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Indicates the clock source
/// Register: CSR
/// Field: CLKSOURCE [2:2]
enum class SYSTICK_CSR_CLKSOURCE : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Indicates whether the TENMS value is exact
/// Register: CALIB
/// Field: SKEW [30:30]
enum class SYSTICK_CALIB_SKEW : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

/// Indicates whether the device provides a reference clock to the processor
/// Register: CALIB
/// Field: NOREF [31:31]
enum class SYSTICK_CALIB_NOREF : uint32_t {
    VALUE_0 = 0x0,
    VALUE_1 = 0x1,
};

// ----------------------------------------------------------------------------
// TC0 - Timer Counter
// ----------------------------------------------------------------------------

/// Clock Selection
/// Register: CMR_CAPTURE_MODE
/// Field: TCCLKS [0:2]
enum class TC0_CMR_CAPTURE_MODE_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR_CAPTURE_MODE
/// Field: BURST [4:5]
enum class TC0_CMR_CAPTURE_MODE_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Trigger Edge Selection
/// Register: CMR_CAPTURE_MODE
/// Field: ETRGEDG [8:9]
enum class TC0_CMR_CAPTURE_MODE_ETRGEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RA Loading Edge Selection
/// Register: CMR_CAPTURE_MODE
/// Field: LDRA [16:17]
enum class TC0_CMR_CAPTURE_MODE_LDRA : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// RB Loading Edge Selection
/// Register: CMR_CAPTURE_MODE
/// Field: LDRB [18:19]
enum class TC0_CMR_CAPTURE_MODE_LDRB : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// Loading Edge Subsampling Ratio
/// Register: CMR_CAPTURE_MODE
/// Field: SBSMPLR [20:22]
enum class TC0_CMR_CAPTURE_MODE_SBSMPLR : uint32_t {
    ONE = 0x0,
    HALF = 0x1,
    FOURTH = 0x2,
    EIGHTH = 0x3,
    SIXTEENTH = 0x4,
};

/// Clock Selection
/// Register: CMR_WAVEFORM_MODE
/// Field: TCCLKS [0:2]
enum class TC0_CMR_WAVEFORM_MODE_TCCLKS : uint32_t {
    TIMER_CLOCK1 = 0x0,
    TIMER_CLOCK2 = 0x1,
    TIMER_CLOCK3 = 0x2,
    TIMER_CLOCK4 = 0x3,
    TIMER_CLOCK5 = 0x4,
    XC0 = 0x5,
    XC1 = 0x6,
    XC2 = 0x7,
};

/// Burst Signal Selection
/// Register: CMR_WAVEFORM_MODE
/// Field: BURST [4:5]
enum class TC0_CMR_WAVEFORM_MODE_BURST : uint32_t {
    NONE = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// External Event Edge Selection
/// Register: CMR_WAVEFORM_MODE
/// Field: EEVTEDG [8:9]
enum class TC0_CMR_WAVEFORM_MODE_EEVTEDG : uint32_t {
    NONE = 0x0,
    RISING = 0x1,
    FALLING = 0x2,
    EDGE = 0x3,
};

/// External Event Selection
/// Register: CMR_WAVEFORM_MODE
/// Field: EEVT [10:11]
enum class TC0_CMR_WAVEFORM_MODE_EEVT : uint32_t {
    TIOB = 0x0,
    XC0 = 0x1,
    XC1 = 0x2,
    XC2 = 0x3,
};

/// Waveform Selection
/// Register: CMR_WAVEFORM_MODE
/// Field: WAVSEL [13:14]
enum class TC0_CMR_WAVEFORM_MODE_WAVSEL : uint32_t {
    UP = 0x0,
    UPDOWN = 0x1,
    UP_RC = 0x2,
    UPDOWN_RC = 0x3,
};

/// RA Compare Effect on TIOAx
/// Register: CMR_WAVEFORM_MODE
/// Field: ACPA [16:17]
enum class TC0_CMR_WAVEFORM_MODE_ACPA : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOAx
/// Register: CMR_WAVEFORM_MODE
/// Field: ACPC [18:19]
enum class TC0_CMR_WAVEFORM_MODE_ACPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOAx
/// Register: CMR_WAVEFORM_MODE
/// Field: AEEVT [20:21]
enum class TC0_CMR_WAVEFORM_MODE_AEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOAx
/// Register: CMR_WAVEFORM_MODE
/// Field: ASWTRG [22:23]
enum class TC0_CMR_WAVEFORM_MODE_ASWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RB Compare Effect on TIOBx
/// Register: CMR_WAVEFORM_MODE
/// Field: BCPB [24:25]
enum class TC0_CMR_WAVEFORM_MODE_BCPB : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// RC Compare Effect on TIOBx
/// Register: CMR_WAVEFORM_MODE
/// Field: BCPC [26:27]
enum class TC0_CMR_WAVEFORM_MODE_BCPC : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// External Event Effect on TIOBx
/// Register: CMR_WAVEFORM_MODE
/// Field: BEEVT [28:29]
enum class TC0_CMR_WAVEFORM_MODE_BEEVT : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Software Trigger Effect on TIOBx
/// Register: CMR_WAVEFORM_MODE
/// Field: BSWTRG [30:31]
enum class TC0_CMR_WAVEFORM_MODE_BSWTRG : uint32_t {
    NONE = 0x0,
    SET = 0x1,
    CLEAR = 0x2,
    TOGGLE = 0x3,
};

/// Trigger Source for Input A
/// Register: EMR
/// Field: TRIGSRCA [0:1]
enum class TC0_EMR_TRIGSRCA : uint32_t {
    EXTERNAL_TIOAx = 0x0,
    PWMx = 0x1,
};

/// Trigger Source for Input B
/// Register: EMR
/// Field: TRIGSRCB [4:5]
enum class TC0_EMR_TRIGSRCB : uint32_t {
    EXTERNAL_TIOBx = 0x0,
    PWMx = 0x1,
};

/// External Clock Signal 0 Selection
/// Register: BMR
/// Field: TC0XC0S [0:1]
enum class TC0_BMR_TC0XC0S : uint32_t {
    TCLK0 = 0x0,
    TIOA1 = 0x2,
    TIOA2 = 0x3,
};

/// External Clock Signal 1 Selection
/// Register: BMR
/// Field: TC1XC1S [2:3]
enum class TC0_BMR_TC1XC1S : uint32_t {
    TCLK1 = 0x0,
    TIOA0 = 0x2,
    TIOA2 = 0x3,
};

/// External Clock Signal 2 Selection
/// Register: BMR
/// Field: TC2XC2S [4:5]
enum class TC0_BMR_TC2XC2S : uint32_t {
    TCLK2 = 0x0,
    TIOA0 = 0x2,
    TIOA1 = 0x3,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class TC0_WPMR_WPKEY : uint32_t {
    PASSWD = 0x54494D,
};

// ----------------------------------------------------------------------------
// TRNG - True Random Number Generator
// ----------------------------------------------------------------------------

/// Security Key
/// Register: CR
/// Field: KEY [8:31]
enum class TRNG_CR_KEY : uint32_t {
    PASSWD = 0x524E47,
};

// ----------------------------------------------------------------------------
// TWIHS0 - Two-wire Interface High Speed
// ----------------------------------------------------------------------------

/// Internal Device Address Size
/// Register: MMR
/// Field: IADRSZ [8:9]
enum class TWIHS0_MMR_IADRSZ : uint32_t {
    NONE = 0x0,
    VAL_1_BYTE = 0x1,  // _1_BYTE
    VAL_2_BYTE = 0x2,  // _2_BYTE
    VAL_3_BYTE = 0x3,  // _3_BYTE
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class TWIHS0_WPMR_WPKEY : uint32_t {
    PASSWD = 0x545749,
};

// ----------------------------------------------------------------------------
// UART0 - Universal Asynchronous Receiver Transmitter
// ----------------------------------------------------------------------------

/// Receiver Digital Filter
/// Register: MR
/// Field: FILTER [4:4]
enum class UART0_MR_FILTER : uint32_t {
    DISABLED = 0x0,
    ENABLED = 0x1,
};

/// Parity Type
/// Register: MR
/// Field: PAR [9:11]
enum class UART0_MR_PAR : uint32_t {
    EVEN = 0x0,
    ODD = 0x1,
    SPACE = 0x2,
    MARK = 0x3,
    NO = 0x4,
};

/// Baud Rate Source Clock
/// Register: MR
/// Field: BRSRCCK [12:12]
enum class UART0_MR_BRSRCCK : uint32_t {
    PERIPH_CLK = 0x0,
    PMC_PCK = 0x1,
};

/// Channel Mode
/// Register: MR
/// Field: CHMODE [14:15]
enum class UART0_MR_CHMODE : uint32_t {
    NORMAL = 0x0,
    AUTOMATIC = 0x1,
    LOCAL_LOOPBACK = 0x2,
    REMOTE_LOOPBACK = 0x3,
};

/// Comparison Mode
/// Register: CMPR
/// Field: CMPMODE [12:12]
enum class UART0_CMPR_CMPMODE : uint32_t {
    FLAG_ONLY = 0x0,
    START_CONDITION = 0x1,
};

/// Write Protection Key
/// Register: WPMR
/// Field: WPKEY [8:31]
enum class UART0_WPMR_WPKEY : uint32_t {
    PASSWD = 0x554152,
};

// ----------------------------------------------------------------------------
// USART0 - Universal Synchronous Asynchronous Receiver Transmitter
// ----------------------------------------------------------------------------

/// USART Mode of Operation
/// Register: US_MR_USART_MODE
/// Field: USART_MODE [0:3]
enum class USART0_US_MR_USART_MODE_USART_MODE : uint32_t {
    NORMAL = 0x0,
    RS485 = 0x1,
    HW_HANDSHAKING = 0x2,
    MODEM = 0x3,
    IS07816_T_0 = 0x4,
    IS07816_T_1 = 0x6,
    IRDA = 0x8,
    LON = 0x9,
    LIN_MASTER = 0xA,
    LIN_SLAVE = 0xB,
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: US_MR_USART_MODE
/// Field: USCLKS [4:5]
enum class USART0_US_MR_USART_MODE_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    PCK = 0x2,
    SCK = 0x3,
};

/// Character Length
/// Register: US_MR_USART_MODE
/// Field: CHRL [6:7]
enum class USART0_US_MR_USART_MODE_CHRL : uint32_t {
    VAL_5_BIT = 0x0,  // _5_BIT
    VAL_6_BIT = 0x1,  // _6_BIT
    VAL_7_BIT = 0x2,  // _7_BIT
    VAL_8_BIT = 0x3,  // _8_BIT
};

/// Parity Type
/// Register: US_MR_USART_MODE
/// Field: PAR [9:11]
enum class USART0_US_MR_USART_MODE_PAR : uint32_t {
    EVEN = 0x0,
    ODD = 0x1,
    SPACE = 0x2,
    MARK = 0x3,
    NO = 0x4,
    MULTIDROP = 0x6,
};

/// Number of Stop Bits
/// Register: US_MR_USART_MODE
/// Field: NBSTOP [12:13]
enum class USART0_US_MR_USART_MODE_NBSTOP : uint32_t {
    VAL_1_BIT = 0x0,  // _1_BIT
    VAL_1_5_BIT = 0x1,  // _1_5_BIT
    VAL_2_BIT = 0x2,  // _2_BIT
};

/// Channel Mode
/// Register: US_MR_USART_MODE
/// Field: CHMODE [14:15]
enum class USART0_US_MR_USART_MODE_CHMODE : uint32_t {
    NORMAL = 0x0,
    AUTOMATIC = 0x1,
    LOCAL_LOOPBACK = 0x2,
    REMOTE_LOOPBACK = 0x3,
};

/// USART Mode of Operation
/// Register: US_MR_SPI_MODE
/// Field: USART_MODE [0:3]
enum class USART0_US_MR_SPI_MODE_USART_MODE : uint32_t {
    NORMAL = 0x0,
    RS485 = 0x1,
    HW_HANDSHAKING = 0x2,
    MODEM = 0x3,
    IS07816_T_0 = 0x4,
    IS07816_T_1 = 0x6,
    IRDA = 0x8,
    LON = 0x9,
    LIN_MASTER = 0xA,
    LIN_SLAVE = 0xB,
    SPI_MASTER = 0xE,
    SPI_SLAVE = 0xF,
};

/// Clock Selection
/// Register: US_MR_SPI_MODE
/// Field: USCLKS [4:5]
enum class USART0_US_MR_SPI_MODE_USCLKS : uint32_t {
    MCK = 0x0,
    DIV = 0x1,
    PCK = 0x2,
    SCK = 0x3,
};

/// Character Length
/// Register: US_MR_SPI_MODE
/// Field: CHRL [6:7]
enum class USART0_US_MR_SPI_MODE_CHRL : uint32_t {
    VAL_5_BIT = 0x0,  // _5_BIT
    VAL_6_BIT = 0x1,  // _6_BIT
    VAL_7_BIT = 0x2,  // _7_BIT
    VAL_8_BIT = 0x3,  // _8_BIT
};

/// Transmitter Preamble Pattern
/// Register: US_MAN
/// Field: TX_PP [8:9]
enum class USART0_US_MAN_TX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// Receiver Preamble Pattern detected
/// Register: US_MAN
/// Field: RX_PP [24:25]
enum class USART0_US_MAN_RX_PP : uint32_t {
    ALL_ONE = 0x0,
    ALL_ZERO = 0x1,
    ZERO_ONE = 0x2,
    ONE_ZERO = 0x3,
};

/// LIN Node Action
/// Register: US_LINMR
/// Field: NACT [0:1]
enum class USART0_US_LINMR_NACT : uint32_t {
    PUBLISH = 0x0,
    SUBSCRIBE = 0x1,
    IGNORE = 0x2,
};

/// Write Protection Key
/// Register: US_WPMR
/// Field: WPKEY [8:31]
enum class USART0_US_WPMR_WPKEY : uint32_t {
    PASSWD = 0x555341,
};

// ----------------------------------------------------------------------------
// USBHS - USB High-Speed Interface
// ----------------------------------------------------------------------------

/// Mode Configuration
/// Register: DEVCTRL
/// Field: SPDCONF [10:11]
enum class USBHS_DEVCTRL_SPDCONF : uint32_t {
    NORMAL = 0x0,
    LOW_POWER = 0x1,
    HIGH_SPEED = 0x2,
    FORCED_FS = 0x3,
};

/// Endpoint Banks
/// Register: DEVEPTCFG[10]
/// Field: EPBK [2:3]
enum class USBHS_DEVEPTCFG_10_EPBK : uint32_t {
    VAL_1_BANK = 0x0,  // 1_BANK
    VAL_2_BANK = 0x1,  // 2_BANK
    VAL_3_BANK = 0x2,  // 3_BANK
};

/// Endpoint Size
/// Register: DEVEPTCFG[10]
/// Field: EPSIZE [4:6]
enum class USBHS_DEVEPTCFG_10_EPSIZE : uint32_t {
    VAL_8_BYTE = 0x0,  // 8_BYTE
    VAL_16_BYTE = 0x1,  // 16_BYTE
    VAL_32_BYTE = 0x2,  // 32_BYTE
    VAL_64_BYTE = 0x3,  // 64_BYTE
    VAL_128_BYTE = 0x4,  // 128_BYTE
    VAL_256_BYTE = 0x5,  // 256_BYTE
    VAL_512_BYTE = 0x6,  // 512_BYTE
    VAL_1024_BYTE = 0x7,  // 1024_BYTE
};

/// Endpoint Direction
/// Register: DEVEPTCFG[10]
/// Field: EPDIR [8:8]
enum class USBHS_DEVEPTCFG_10_EPDIR : uint32_t {
    OUT = 0x0,
    IN = 0x1,
};

/// Endpoint Type
/// Register: DEVEPTCFG[10]
/// Field: EPTYPE [11:12]
enum class USBHS_DEVEPTCFG_10_EPTYPE : uint32_t {
    CTRL = 0x0,
    ISO = 0x1,
    BLK = 0x2,
    INTRPT = 0x3,
};

/// Number of transactions per microframe for isochronous endpoint
/// Register: DEVEPTCFG[10]
/// Field: NBTRANS [13:14]
enum class USBHS_DEVEPTCFG_10_NBTRANS : uint32_t {
    VAL_0_TRANS = 0x0,  // _0_TRANS
    VAL_1_TRANS = 0x1,  // _1_TRANS
    VAL_2_TRANS = 0x2,  // _2_TRANS
    VAL_3_TRANS = 0x3,  // _3_TRANS
};

/// Data Toggle Sequence
/// Register: DEVEPTISR_CTRL_MODE[10]
/// Field: DTSEQ [8:9]
enum class USBHS_DEVEPTISR_CTRL_MODE_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
    DATA2 = 0x2,
    MDATA = 0x3,
};

/// Number of Busy Banks
/// Register: DEVEPTISR_CTRL_MODE[10]
/// Field: NBUSYBK [12:13]
enum class USBHS_DEVEPTISR_CTRL_MODE_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // _0_BUSY
    VAL_1_BUSY = 0x1,  // _1_BUSY
    VAL_2_BUSY = 0x2,  // _2_BUSY
    VAL_3_BUSY = 0x3,  // _3_BUSY
};

/// Current Bank
/// Register: DEVEPTISR_CTRL_MODE[10]
/// Field: CURRBK [14:15]
enum class USBHS_DEVEPTISR_CTRL_MODE_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: DEVEPTISR_ISO_MODE[10]
/// Field: DTSEQ [8:9]
enum class USBHS_DEVEPTISR_ISO_MODE_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
    DATA2 = 0x2,
    MDATA = 0x3,
};

/// Number of Busy Banks
/// Register: DEVEPTISR_ISO_MODE[10]
/// Field: NBUSYBK [12:13]
enum class USBHS_DEVEPTISR_ISO_MODE_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // _0_BUSY
    VAL_1_BUSY = 0x1,  // _1_BUSY
    VAL_2_BUSY = 0x2,  // _2_BUSY
    VAL_3_BUSY = 0x3,  // _3_BUSY
};

/// Current Bank
/// Register: DEVEPTISR_ISO_MODE[10]
/// Field: CURRBK [14:15]
enum class USBHS_DEVEPTISR_ISO_MODE_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: DEVEPTISR_BLK_MODE[10]
/// Field: DTSEQ [8:9]
enum class USBHS_DEVEPTISR_BLK_MODE_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
    DATA2 = 0x2,
    MDATA = 0x3,
};

/// Number of Busy Banks
/// Register: DEVEPTISR_BLK_MODE[10]
/// Field: NBUSYBK [12:13]
enum class USBHS_DEVEPTISR_BLK_MODE_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // _0_BUSY
    VAL_1_BUSY = 0x1,  // _1_BUSY
    VAL_2_BUSY = 0x2,  // _2_BUSY
    VAL_3_BUSY = 0x3,  // _3_BUSY
};

/// Current Bank
/// Register: DEVEPTISR_BLK_MODE[10]
/// Field: CURRBK [14:15]
enum class USBHS_DEVEPTISR_BLK_MODE_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: DEVEPTISR_INTRPT_MODE[10]
/// Field: DTSEQ [8:9]
enum class USBHS_DEVEPTISR_INTRPT_MODE_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
    DATA2 = 0x2,
    MDATA = 0x3,
};

/// Number of Busy Banks
/// Register: DEVEPTISR_INTRPT_MODE[10]
/// Field: NBUSYBK [12:13]
enum class USBHS_DEVEPTISR_INTRPT_MODE_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // _0_BUSY
    VAL_1_BUSY = 0x1,  // _1_BUSY
    VAL_2_BUSY = 0x2,  // _2_BUSY
    VAL_3_BUSY = 0x3,  // _3_BUSY
};

/// Current Bank
/// Register: DEVEPTISR_INTRPT_MODE[10]
/// Field: CURRBK [14:15]
enum class USBHS_DEVEPTISR_INTRPT_MODE_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Mode Configuration
/// Register: HSTCTRL
/// Field: SPDCONF [12:13]
enum class USBHS_HSTCTRL_SPDCONF : uint32_t {
    NORMAL = 0x0,
    LOW_POWER = 0x1,
    HIGH_SPEED = 0x2,
    FORCED_FS = 0x3,
};

/// Pipe Banks
/// Register: HSTPIPCFG[10]
/// Field: PBK [2:3]
enum class USBHS_HSTPIPCFG_10_PBK : uint32_t {
    VAL_1_BANK = 0x0,  // _1_BANK
    VAL_2_BANK = 0x1,  // _2_BANK
    VAL_3_BANK = 0x2,  // _3_BANK
};

/// Pipe Size
/// Register: HSTPIPCFG[10]
/// Field: PSIZE [4:6]
enum class USBHS_HSTPIPCFG_10_PSIZE : uint32_t {
    VAL_8_BYTE = 0x0,  // _8_BYTE
    VAL_16_BYTE = 0x1,  // _16_BYTE
    VAL_32_BYTE = 0x2,  // _32_BYTE
    VAL_64_BYTE = 0x3,  // _64_BYTE
    VAL_128_BYTE = 0x4,  // _128_BYTE
    VAL_256_BYTE = 0x5,  // _256_BYTE
    VAL_512_BYTE = 0x6,  // _512_BYTE
    VAL_1024_BYTE = 0x7,  // _1024_BYTE
};

/// Pipe Token
/// Register: HSTPIPCFG[10]
/// Field: PTOKEN [8:9]
enum class USBHS_HSTPIPCFG_10_PTOKEN : uint32_t {
    SETUP = 0x0,
    IN = 0x1,
    OUT = 0x2,
};

/// Pipe Type
/// Register: HSTPIPCFG[10]
/// Field: PTYPE [12:13]
enum class USBHS_HSTPIPCFG_10_PTYPE : uint32_t {
    CTRL = 0x0,
    ISO = 0x1,
    BLK = 0x2,
    INTRPT = 0x3,
};

/// Pipe Banks
/// Register: HSTPIPCFG_CTRL_BULK_MODE[10]
/// Field: PBK [2:3]
enum class USBHS_HSTPIPCFG_CTRL_BULK_MODE_10_PBK : uint32_t {
    VAL_1_BANK = 0x0,  // _1_BANK
    VAL_2_BANK = 0x1,  // _2_BANK
    VAL_3_BANK = 0x2,  // _3_BANK
};

/// Pipe Size
/// Register: HSTPIPCFG_CTRL_BULK_MODE[10]
/// Field: PSIZE [4:6]
enum class USBHS_HSTPIPCFG_CTRL_BULK_MODE_10_PSIZE : uint32_t {
    VAL_8_BYTE = 0x0,  // _8_BYTE
    VAL_16_BYTE = 0x1,  // _16_BYTE
    VAL_32_BYTE = 0x2,  // _32_BYTE
    VAL_64_BYTE = 0x3,  // _64_BYTE
    VAL_128_BYTE = 0x4,  // _128_BYTE
    VAL_256_BYTE = 0x5,  // _256_BYTE
    VAL_512_BYTE = 0x6,  // _512_BYTE
    VAL_1024_BYTE = 0x7,  // _1024_BYTE
};

/// Pipe Token
/// Register: HSTPIPCFG_CTRL_BULK_MODE[10]
/// Field: PTOKEN [8:9]
enum class USBHS_HSTPIPCFG_CTRL_BULK_MODE_10_PTOKEN : uint32_t {
    SETUP = 0x0,
    IN = 0x1,
    OUT = 0x2,
};

/// Pipe Type
/// Register: HSTPIPCFG_CTRL_BULK_MODE[10]
/// Field: PTYPE [12:13]
enum class USBHS_HSTPIPCFG_CTRL_BULK_MODE_10_PTYPE : uint32_t {
    CTRL = 0x0,
    ISO = 0x1,
    BLK = 0x2,
    INTRPT = 0x3,
};

/// Data Toggle Sequence
/// Register: HSTPIPISR_CTRL_MODE[10]
/// Field: DTSEQ [8:9]
enum class USBHS_HSTPIPISR_CTRL_MODE_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
};

/// Number of Busy Banks
/// Register: HSTPIPISR_CTRL_MODE[10]
/// Field: NBUSYBK [12:13]
enum class USBHS_HSTPIPISR_CTRL_MODE_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // _0_BUSY
    VAL_1_BUSY = 0x1,  // _1_BUSY
    VAL_2_BUSY = 0x2,  // _2_BUSY
    VAL_3_BUSY = 0x3,  // _3_BUSY
};

/// Current Bank
/// Register: HSTPIPISR_CTRL_MODE[10]
/// Field: CURRBK [14:15]
enum class USBHS_HSTPIPISR_CTRL_MODE_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: HSTPIPISR_ISO_MODE[10]
/// Field: DTSEQ [8:9]
enum class USBHS_HSTPIPISR_ISO_MODE_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
};

/// Number of Busy Banks
/// Register: HSTPIPISR_ISO_MODE[10]
/// Field: NBUSYBK [12:13]
enum class USBHS_HSTPIPISR_ISO_MODE_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // _0_BUSY
    VAL_1_BUSY = 0x1,  // _1_BUSY
    VAL_2_BUSY = 0x2,  // _2_BUSY
    VAL_3_BUSY = 0x3,  // _3_BUSY
};

/// Current Bank
/// Register: HSTPIPISR_ISO_MODE[10]
/// Field: CURRBK [14:15]
enum class USBHS_HSTPIPISR_ISO_MODE_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: HSTPIPISR_BLK_MODE[10]
/// Field: DTSEQ [8:9]
enum class USBHS_HSTPIPISR_BLK_MODE_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
};

/// Number of Busy Banks
/// Register: HSTPIPISR_BLK_MODE[10]
/// Field: NBUSYBK [12:13]
enum class USBHS_HSTPIPISR_BLK_MODE_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // _0_BUSY
    VAL_1_BUSY = 0x1,  // _1_BUSY
    VAL_2_BUSY = 0x2,  // _2_BUSY
    VAL_3_BUSY = 0x3,  // _3_BUSY
};

/// Current Bank
/// Register: HSTPIPISR_BLK_MODE[10]
/// Field: CURRBK [14:15]
enum class USBHS_HSTPIPISR_BLK_MODE_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// Data Toggle Sequence
/// Register: HSTPIPISR_INTRPT_MODE[10]
/// Field: DTSEQ [8:9]
enum class USBHS_HSTPIPISR_INTRPT_MODE_10_DTSEQ : uint32_t {
    DATA0 = 0x0,
    DATA1 = 0x1,
};

/// Number of Busy Banks
/// Register: HSTPIPISR_INTRPT_MODE[10]
/// Field: NBUSYBK [12:13]
enum class USBHS_HSTPIPISR_INTRPT_MODE_10_NBUSYBK : uint32_t {
    VAL_0_BUSY = 0x0,  // _0_BUSY
    VAL_1_BUSY = 0x1,  // _1_BUSY
    VAL_2_BUSY = 0x2,  // _2_BUSY
    VAL_3_BUSY = 0x3,  // _3_BUSY
};

/// Current Bank
/// Register: HSTPIPISR_INTRPT_MODE[10]
/// Field: CURRBK [14:15]
enum class USBHS_HSTPIPISR_INTRPT_MODE_10_CURRBK : uint32_t {
    BANK0 = 0x0,
    BANK1 = 0x1,
    BANK2 = 0x2,
};

/// USBHS Mode
/// Register: CTRL
/// Field: UIMOD [25:25]
enum class USBHS_CTRL_UIMOD : uint32_t {
    HOST = 0x0,
    DEVICE = 0x1,
};

/// Speed Status (Device mode only)
/// Register: SR
/// Field: SPEED [12:13]
enum class USBHS_SR_SPEED : uint32_t {
    FULL_SPEED = 0x0,
    HIGH_SPEED = 0x1,
    LOW_SPEED = 0x2,
};

// ----------------------------------------------------------------------------
// UTMI - USB Transmitter Interface Macrocell
// ----------------------------------------------------------------------------

/// UTMI Reference Clock Frequency
/// Register: CKTRIM
/// Field: FREQ [0:1]
enum class UTMI_CKTRIM_FREQ : uint32_t {
    XTAL12 = 0x0,
    XTAL16 = 0x1,
};

// ----------------------------------------------------------------------------
// WDT - Watchdog Timer
// ----------------------------------------------------------------------------

/// Password
/// Register: CR
/// Field: KEY [24:31]
enum class WDT_CR_KEY : uint32_t {
    PASSWD = 0xA5,
};

// ----------------------------------------------------------------------------
// XDMAC - Extensible DMA Controller
// ----------------------------------------------------------------------------

/// Channel x Next Descriptor Enable
/// Register: CNDC
/// Field: NDE [0:0]
enum class XDMAC_CNDC_NDE : uint32_t {
    DSCR_FETCH_DIS = 0x0,
    DSCR_FETCH_EN = 0x1,
};

/// Channel x Next Descriptor Source Update
/// Register: CNDC
/// Field: NDSUP [1:1]
enum class XDMAC_CNDC_NDSUP : uint32_t {
    SRC_PARAMS_UNCHANGED = 0x0,
    SRC_PARAMS_UPDATED = 0x1,
};

/// Channel x Next Descriptor Destination Update
/// Register: CNDC
/// Field: NDDUP [2:2]
enum class XDMAC_CNDC_NDDUP : uint32_t {
    DST_PARAMS_UNCHANGED = 0x0,
    DST_PARAMS_UPDATED = 0x1,
};

/// Channel x Next Descriptor View
/// Register: CNDC
/// Field: NDVIEW [3:4]
enum class XDMAC_CNDC_NDVIEW : uint32_t {
    NDV0 = 0x0,
    NDV1 = 0x1,
    NDV2 = 0x2,
    NDV3 = 0x3,
};

/// Channel x Transfer Type
/// Register: CC
/// Field: TYPE [0:0]
enum class XDMAC_CC_TYPE : uint32_t {
    MEM_TRAN = 0x0,
    PER_TRAN = 0x1,
};

/// Channel x Memory Burst Size
/// Register: CC
/// Field: MBSIZE [1:2]
enum class XDMAC_CC_MBSIZE : uint32_t {
    SINGLE = 0x0,
    FOUR = 0x1,
    EIGHT = 0x2,
    SIXTEEN = 0x3,
};

/// Channel x Synchronization
/// Register: CC
/// Field: DSYNC [4:4]
enum class XDMAC_CC_DSYNC : uint32_t {
    PER2MEM = 0x0,
    MEM2PER = 0x1,
};

/// Channel x Software Request Trigger
/// Register: CC
/// Field: SWREQ [6:6]
enum class XDMAC_CC_SWREQ : uint32_t {
    HWR_CONNECTED = 0x0,
    SWR_CONNECTED = 0x1,
};

/// Channel x Fill Block of memory
/// Register: CC
/// Field: MEMSET [7:7]
enum class XDMAC_CC_MEMSET : uint32_t {
    NORMAL_MODE = 0x0,
    HW_MODE = 0x1,
};

/// Channel x Chunk Size
/// Register: CC
/// Field: CSIZE [8:10]
enum class XDMAC_CC_CSIZE : uint32_t {
    CHK_1 = 0x0,
    CHK_2 = 0x1,
    CHK_4 = 0x2,
    CHK_8 = 0x3,
    CHK_16 = 0x4,
};

/// Channel x Data Width
/// Register: CC
/// Field: DWIDTH [11:12]
enum class XDMAC_CC_DWIDTH : uint32_t {
    BYTE = 0x0,
    HALFWORD = 0x1,
    WORD = 0x2,
};

/// Channel x Source Interface Identifier
/// Register: CC
/// Field: SIF [13:13]
enum class XDMAC_CC_SIF : uint32_t {
    AHB_IF0 = 0x0,
    AHB_IF1 = 0x1,
};

/// Channel x Destination Interface Identifier
/// Register: CC
/// Field: DIF [14:14]
enum class XDMAC_CC_DIF : uint32_t {
    AHB_IF0 = 0x0,
    AHB_IF1 = 0x1,
};

/// Channel x Source Addressing Mode
/// Register: CC
/// Field: SAM [16:17]
enum class XDMAC_CC_SAM : uint32_t {
    FIXED_AM = 0x0,
    INCREMENTED_AM = 0x1,
    UBS_AM = 0x2,
    UBS_DS_AM = 0x3,
};

/// Channel x Destination Addressing Mode
/// Register: CC
/// Field: DAM [18:19]
enum class XDMAC_CC_DAM : uint32_t {
    FIXED_AM = 0x0,
    INCREMENTED_AM = 0x1,
    UBS_AM = 0x2,
    UBS_DS_AM = 0x3,
};

/// Channel Initialization Terminated (this bit is read-only)
/// Register: CC
/// Field: INITD [21:21]
enum class XDMAC_CC_INITD : uint32_t {
    IN_PROGRESS = 0x0,
    TERMINATED = 0x1,
};

/// Read in Progress (this bit is read-only)
/// Register: CC
/// Field: RDIP [22:22]
enum class XDMAC_CC_RDIP : uint32_t {
    DONE = 0x0,
    IN_PROGRESS = 0x1,
};

/// Write in Progress (this bit is read-only)
/// Register: CC
/// Field: WRIP [23:23]
enum class XDMAC_CC_WRIP : uint32_t {
    DONE = 0x0,
    IN_PROGRESS = 0x1,
};

/// Channel x Peripheral Hardware Request Line Identifier
/// Register: CC
/// Field: PERID [24:30]
enum class XDMAC_CC_PERID : uint32_t {
    QSPI_TX = 0x5,
    QSPI_RX = 0x6,
    USART0_TX = 0x7,
    USART0_RX = 0x8,
    USART1_TX = 0x9,
    USART1_RX = 0xA,
    PWM0 = 0xD,
    TWIHS0_TX = 0xE,
    TWIHS0_RX = 0xF,
    TWIHS1_TX = 0x10,
    TWIHS1_RX = 0x11,
    UART0_TX = 0x14,
    UART0_RX = 0x15,
    UART1_TX = 0x16,
    UART1_RX = 0x17,
    UART2_TX = 0x18,
    UART2_RX = 0x19,
    DACC0 = 0x1E,
    SSC_TX = 0x20,
    SSC_RX = 0x21,
    PIOA = 0x22,
    AFEC0 = 0x23,
    AFEC1 = 0x24,
    AES_TX = 0x25,
    AES_RX = 0x26,
    PWM1 = 0x27,
    TC0 = 0x28,
    TC3 = 0x29,
    TC6 = 0x2A,
    TC9 = 0x2B,
};

/// Total enumerated types: 436

}  // namespace alloy::hal::atmel::same70::atsame70j20b::enums
