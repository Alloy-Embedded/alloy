/// Auto-generated register definitions for XDMAC
/// Device: ATSAMV71N19
/// Vendor: Microchip Technology
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::atmel::samv71::atsamv71n19::xdmac {

// ============================================================================
// XDMAC - Extensible DMA Controller
// Base Address: 0x40078000
// ============================================================================

/// XDMAC Register Structure
struct XDMAC_Registers {

    /// Global Type Register
    /// Offset: 0x0000
    /// Access: read-only
    volatile uint32_t GTYPE;

    /// Channel Interrupt Enable Register (chid = 0)
    /// Offset: 0x0000
    /// Access: write-only
    volatile uint32_t CIE;

    /// Global Configuration Register
    /// Offset: 0x0004
    volatile uint32_t GCFG;

    /// Channel Interrupt Disable Register (chid = 0)
    /// Offset: 0x0004
    /// Access: write-only
    volatile uint32_t CID;

    /// Global Weighted Arbiter Configuration Register
    /// Offset: 0x0008
    volatile uint32_t GWAC;

    /// Channel Interrupt Mask Register (chid = 0)
    /// Offset: 0x0008
    /// Access: read-only
    volatile uint32_t CIM;

    /// Global Interrupt Enable Register
    /// Offset: 0x000C
    /// Access: write-only
    volatile uint32_t GIE;

    /// Channel Interrupt Status Register (chid = 0)
    /// Offset: 0x000C
    /// Access: read-only
    volatile uint32_t CIS;

    /// Global Interrupt Disable Register
    /// Offset: 0x0010
    /// Access: write-only
    volatile uint32_t GID;

    /// Channel Source Address Register (chid = 0)
    /// Offset: 0x0010
    volatile uint32_t CSA;

    /// Global Interrupt Mask Register
    /// Offset: 0x0014
    /// Access: read-only
    volatile uint32_t GIM;

    /// Channel Destination Address Register (chid = 0)
    /// Offset: 0x0014
    volatile uint32_t CDA;

    /// Global Interrupt Status Register
    /// Offset: 0x0018
    /// Access: read-only
    volatile uint32_t GIS;

    /// Channel Next Descriptor Address Register (chid = 0)
    /// Offset: 0x0018
    volatile uint32_t CNDA;

    /// Global Channel Enable Register
    /// Offset: 0x001C
    /// Access: write-only
    volatile uint32_t GE;

    /// Channel Next Descriptor Control Register (chid = 0)
    /// Offset: 0x001C
    volatile uint32_t CNDC;

    /// Global Channel Disable Register
    /// Offset: 0x0020
    /// Access: write-only
    volatile uint32_t GD;

    /// Channel Microblock Control Register (chid = 0)
    /// Offset: 0x0020
    volatile uint32_t CUBC;

    /// Global Channel Status Register
    /// Offset: 0x0024
    /// Access: read-only
    volatile uint32_t GS;

    /// Channel Block Control Register (chid = 0)
    /// Offset: 0x0024
    volatile uint32_t CBC;

    /// Global Channel Read Suspend Register
    /// Offset: 0x0028
    volatile uint32_t GRS;

    /// Channel Configuration Register (chid = 0)
    /// Offset: 0x0028
    volatile uint32_t CC;

    /// Global Channel Write Suspend Register
    /// Offset: 0x002C
    volatile uint32_t GWS;

    /// Channel Data Stride Memory Set Pattern (chid = 0)
    /// Offset: 0x002C
    volatile uint32_t CDS_MSP;

    /// Global Channel Read Write Suspend Register
    /// Offset: 0x0030
    /// Access: write-only
    volatile uint32_t GRWS;

    /// Channel Source Microblock Stride (chid = 0)
    /// Offset: 0x0030
    volatile uint32_t CSUS;

    /// Global Channel Read Write Resume Register
    /// Offset: 0x0034
    /// Access: write-only
    volatile uint32_t GRWR;

    /// Channel Destination Microblock Stride (chid = 0)
    /// Offset: 0x0034
    volatile uint32_t CDUS;

    /// Global Channel Software Request Register
    /// Offset: 0x0038
    /// Access: write-only
    volatile uint32_t GSWR;

    /// Global Channel Software Request Status Register
    /// Offset: 0x003C
    /// Access: read-only
    volatile uint32_t GSWS;

    /// Global Channel Software Flush Request Register
    /// Offset: 0x0040
    /// Access: write-only
    volatile uint32_t GSWF;
    uint8_t RESERVED_0044[4024]; ///< Reserved

    /// XDMAC Version Register
    /// Offset: 0x0FFC
    volatile uint32_t VERSION;
};

static_assert(sizeof(XDMAC_Registers) >= 4096, "XDMAC_Registers size mismatch");

/// XDMAC peripheral instance
constexpr XDMAC_Registers* XDMAC = 
    reinterpret_cast<XDMAC_Registers*>(0x40078000);

}  // namespace alloy::hal::atmel::samv71::atsamv71n19::xdmac
