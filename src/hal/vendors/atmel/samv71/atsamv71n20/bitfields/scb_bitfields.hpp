/// Auto-generated bit field definitions for SCB
/// Device: ATSAMV71N20
/// Vendor: Microchip Technology
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::atmel::samv71::atsamv71n20::scb {

using namespace alloy::hal::bitfields;

// ============================================================================
// SCB Bit Field Definitions
// ============================================================================

/// CPUID - CPUID Base Register
namespace cpuid {
    /// Indicates patch release: 0x0 = Patch 0
    /// Position: 0, Width: 4
    using REVISION = BitField<0, 4>;
    constexpr uint32_t REVISION_Pos = 0;
    constexpr uint32_t REVISION_Msk = REVISION::mask;

    /// Indicates part number
    /// Position: 4, Width: 12
    using PARTNO = BitField<4, 12>;
    constexpr uint32_t PARTNO_Pos = 4;
    constexpr uint32_t PARTNO_Msk = PARTNO::mask;

    /// Indicates architecture. Reads as 0xF
    /// Position: 16, Width: 4
    using ARCHITECTURE = BitField<16, 4>;
    constexpr uint32_t ARCHITECTURE_Pos = 16;
    constexpr uint32_t ARCHITECTURE_Msk = ARCHITECTURE::mask;

    /// Indicates processor revision: 0x2 = Revision 2
    /// Position: 20, Width: 4
    using VARIANT = BitField<20, 4>;
    constexpr uint32_t VARIANT_Pos = 20;
    constexpr uint32_t VARIANT_Msk = VARIANT::mask;

    /// Implementer code
    /// Position: 24, Width: 8
    using IMPLEMENTER = BitField<24, 8>;
    constexpr uint32_t IMPLEMENTER_Pos = 24;
    constexpr uint32_t IMPLEMENTER_Msk = IMPLEMENTER::mask;

}  // namespace cpuid

/// ICSR - Interrupt Control and State Register
namespace icsr {
    /// Active exception number
    /// Position: 0, Width: 9
    using VECTACTIVE = BitField<0, 9>;
    constexpr uint32_t VECTACTIVE_Pos = 0;
    constexpr uint32_t VECTACTIVE_Msk = VECTACTIVE::mask;

    /// Indicates whether there is an active exception other than the exception indicated by the current value of the IPSR
    /// Position: 11, Width: 1
    using RETTOBASE = BitField<11, 1>;
    constexpr uint32_t RETTOBASE_Pos = 11;
    constexpr uint32_t RETTOBASE_Msk = RETTOBASE::mask;
    /// Enumerated values for RETTOBASE
    namespace rettobase {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Exception number of the highest priority pending enabled exception
    /// Position: 12, Width: 6
    using VECTPENDING = BitField<12, 6>;
    constexpr uint32_t VECTPENDING_Pos = 12;
    constexpr uint32_t VECTPENDING_Msk = VECTPENDING::mask;

    /// Is external interrupt, generated by the NVIC, pending
    /// Position: 22, Width: 1
    using ISRPENDING = BitField<22, 1>;
    constexpr uint32_t ISRPENDING_Pos = 22;
    constexpr uint32_t ISRPENDING_Msk = ISRPENDING::mask;

    /// Indicates whether a pending exception will be serviced on exit from debug halt state
    /// Position: 23, Width: 1
    using ISRPREEMPT = BitField<23, 1>;
    constexpr uint32_t ISRPREEMPT_Pos = 23;
    constexpr uint32_t ISRPREEMPT_Msk = ISRPREEMPT::mask;
    /// Enumerated values for ISRPREEMPT
    namespace isrpreempt {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Removes the pending status of the SysTick exception
    /// Position: 25, Width: 1
    using PENDSTCLR = BitField<25, 1>;
    constexpr uint32_t PENDSTCLR_Pos = 25;
    constexpr uint32_t PENDSTCLR_Msk = PENDSTCLR::mask;
    /// Enumerated values for PENDSTCLR
    namespace pendstclr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Sets the SysTick exception as pending, or reads the current state of the exception
    /// Position: 26, Width: 1
    using PENDSTSET = BitField<26, 1>;
    constexpr uint32_t PENDSTSET_Pos = 26;
    constexpr uint32_t PENDSTSET_Msk = PENDSTSET::mask;
    /// Enumerated values for PENDSTSET
    namespace pendstset {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Removes the pending status of the PendSV exception
    /// Position: 27, Width: 1
    using PENDSVCLR = BitField<27, 1>;
    constexpr uint32_t PENDSVCLR_Pos = 27;
    constexpr uint32_t PENDSVCLR_Msk = PENDSVCLR::mask;
    /// Enumerated values for PENDSVCLR
    namespace pendsvclr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Sets the PendSV exception as pending, or reads the current state of the exception
    /// Position: 28, Width: 1
    using PENDSVSET = BitField<28, 1>;
    constexpr uint32_t PENDSVSET_Pos = 28;
    constexpr uint32_t PENDSVSET_Msk = PENDSVSET::mask;
    /// Enumerated values for PENDSVSET
    namespace pendsvset {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Makes the NMI exception active, or reads the state of the exception
    /// Position: 31, Width: 1
    using NMIPENDSET = BitField<31, 1>;
    constexpr uint32_t NMIPENDSET_Pos = 31;
    constexpr uint32_t NMIPENDSET_Msk = NMIPENDSET::mask;
    /// Enumerated values for NMIPENDSET
    namespace nmipendset {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

}  // namespace icsr

/// VTOR - Vector Table Offset Register
namespace vtor {
    /// Bits[31:7] of the vector table address
    /// Position: 7, Width: 25
    using TBLOFF = BitField<7, 25>;
    constexpr uint32_t TBLOFF_Pos = 7;
    constexpr uint32_t TBLOFF_Msk = TBLOFF::mask;

}  // namespace vtor

/// AIRCR - Application Interrupt and Reset Control Register
namespace aircr {
    /// Writing 1 to this bit causes a local system reset
    /// Position: 0, Width: 1
    using VECTRESET = BitField<0, 1>;
    constexpr uint32_t VECTRESET_Pos = 0;
    constexpr uint32_t VECTRESET_Msk = VECTRESET::mask;

    /// Clears all active state information for fixed and configurable exceptions
    /// Position: 1, Width: 1
    using VECTCLRACTIVE = BitField<1, 1>;
    constexpr uint32_t VECTCLRACTIVE_Pos = 1;
    constexpr uint32_t VECTCLRACTIVE_Msk = VECTCLRACTIVE::mask;

    /// System Reset Request
    /// Position: 2, Width: 1
    using SYSRESETREQ = BitField<2, 1>;
    constexpr uint32_t SYSRESETREQ_Pos = 2;
    constexpr uint32_t SYSRESETREQ_Msk = SYSRESETREQ::mask;
    /// Enumerated values for SYSRESETREQ
    namespace sysresetreq {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Interrupt priority grouping field. This field determines the split of group priority from subpriority.
    /// Position: 8, Width: 3
    using PRIGROUP = BitField<8, 3>;
    constexpr uint32_t PRIGROUP_Pos = 8;
    constexpr uint32_t PRIGROUP_Msk = PRIGROUP::mask;

    /// Memory system endianness
    /// Position: 15, Width: 1
    using ENDIANNESS = BitField<15, 1>;
    constexpr uint32_t ENDIANNESS_Pos = 15;
    constexpr uint32_t ENDIANNESS_Msk = ENDIANNESS::mask;
    /// Enumerated values for ENDIANNESS
    namespace endianness {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Vector key
    /// Position: 16, Width: 16
    using VECTKEY = BitField<16, 16>;
    constexpr uint32_t VECTKEY_Pos = 16;
    constexpr uint32_t VECTKEY_Msk = VECTKEY::mask;

}  // namespace aircr

/// SCR - System Control Register
namespace scr {
    /// Determines whether, on an exit from an ISR that returns to the base level of execution priority, the processor enters a sleep state
    /// Position: 1, Width: 1
    using SLEEPONEXIT = BitField<1, 1>;
    constexpr uint32_t SLEEPONEXIT_Pos = 1;
    constexpr uint32_t SLEEPONEXIT_Msk = SLEEPONEXIT::mask;
    /// Enumerated values for SLEEPONEXIT
    namespace sleeponexit {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Provides a qualifying hint indicating that waking from sleep might take longer
    /// Position: 2, Width: 1
    using SLEEPDEEP = BitField<2, 1>;
    constexpr uint32_t SLEEPDEEP_Pos = 2;
    constexpr uint32_t SLEEPDEEP_Msk = SLEEPDEEP::mask;
    /// Enumerated values for SLEEPDEEP
    namespace sleepdeep {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Determines whether an interrupt transition from inactive state to pending state is a wakeup event
    /// Position: 4, Width: 1
    using SEVONPEND = BitField<4, 1>;
    constexpr uint32_t SEVONPEND_Pos = 4;
    constexpr uint32_t SEVONPEND_Msk = SEVONPEND::mask;
    /// Enumerated values for SEVONPEND
    namespace sevonpend {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

}  // namespace scr

/// CCR - Configuration and Control Register
namespace ccr {
    /// Controls whether the processor can enter Thread mode with exceptions active
    /// Position: 0, Width: 1
    using NONBASETHRDENA = BitField<0, 1>;
    constexpr uint32_t NONBASETHRDENA_Pos = 0;
    constexpr uint32_t NONBASETHRDENA_Msk = NONBASETHRDENA::mask;
    /// Enumerated values for NONBASETHRDENA
    namespace nonbasethrdena {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Enables unprivileged software access to the STIR
    /// Position: 1, Width: 1
    using USERSETMPEND = BitField<1, 1>;
    constexpr uint32_t USERSETMPEND_Pos = 1;
    constexpr uint32_t USERSETMPEND_Msk = USERSETMPEND::mask;
    /// Enumerated values for USERSETMPEND
    namespace usersetmpend {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Enables unaligned access traps
    /// Position: 3, Width: 1
    using UNALIGN_TRP = BitField<3, 1>;
    constexpr uint32_t UNALIGN_TRP_Pos = 3;
    constexpr uint32_t UNALIGN_TRP_Msk = UNALIGN_TRP::mask;
    /// Enumerated values for UNALIGN_TRP
    namespace unalign_trp {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
    /// Position: 4, Width: 1
    using DIV_0_TRP = BitField<4, 1>;
    constexpr uint32_t DIV_0_TRP_Pos = 4;
    constexpr uint32_t DIV_0_TRP_Msk = DIV_0_TRP::mask;
    /// Enumerated values for DIV_0_TRP
    namespace div_0_trp {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
    /// Position: 8, Width: 1
    using BFHFNMIGN = BitField<8, 1>;
    constexpr uint32_t BFHFNMIGN_Pos = 8;
    constexpr uint32_t BFHFNMIGN_Msk = BFHFNMIGN::mask;
    /// Enumerated values for BFHFNMIGN
    namespace bfhfnmign {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Indicates stack alignment on exception entry
    /// Position: 9, Width: 1
    using STKALIGN = BitField<9, 1>;
    constexpr uint32_t STKALIGN_Pos = 9;
    constexpr uint32_t STKALIGN_Msk = STKALIGN::mask;
    /// Enumerated values for STKALIGN
    namespace stkalign {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Cache enable bit
    /// Position: 16, Width: 1
    using DC = BitField<16, 1>;
    constexpr uint32_t DC_Pos = 16;
    constexpr uint32_t DC_Msk = DC::mask;

    /// Instruction cache enable bi
    /// Position: 17, Width: 1
    using IC = BitField<17, 1>;
    constexpr uint32_t IC_Pos = 17;
    constexpr uint32_t IC_Msk = IC::mask;

    /// Branch prediction enable bi
    /// Position: 18, Width: 1
    using BP = BitField<18, 1>;
    constexpr uint32_t BP_Pos = 18;
    constexpr uint32_t BP_Msk = BP::mask;

}  // namespace ccr

/// SHPR1 - System Handler Priority Register 1
namespace shpr1 {
    /// Priority of system handler 4, MemManage
    /// Position: 0, Width: 8
    using PRI_4 = BitField<0, 8>;
    constexpr uint32_t PRI_4_Pos = 0;
    constexpr uint32_t PRI_4_Msk = PRI_4::mask;

    /// Priority of system handler 5, BusFault
    /// Position: 8, Width: 8
    using PRI_5 = BitField<8, 8>;
    constexpr uint32_t PRI_5_Pos = 8;
    constexpr uint32_t PRI_5_Msk = PRI_5::mask;

    /// Priority of system handler 6, UsageFault
    /// Position: 16, Width: 8
    using PRI_6 = BitField<16, 8>;
    constexpr uint32_t PRI_6_Pos = 16;
    constexpr uint32_t PRI_6_Msk = PRI_6::mask;

}  // namespace shpr1

/// SHPR2 - System Handler Priority Register 2
namespace shpr2 {
    /// Priority of system handler 11, SVCall
    /// Position: 24, Width: 8
    using PRI_11 = BitField<24, 8>;
    constexpr uint32_t PRI_11_Pos = 24;
    constexpr uint32_t PRI_11_Msk = PRI_11::mask;

}  // namespace shpr2

/// SHPR3 - System Handler Priority Register 3
namespace shpr3 {
    /// Priority of system handler 12, SysTick
    /// Position: 0, Width: 8
    using PRI_12 = BitField<0, 8>;
    constexpr uint32_t PRI_12_Pos = 0;
    constexpr uint32_t PRI_12_Msk = PRI_12::mask;

    /// Priority of system handler 14, PendSV
    /// Position: 16, Width: 8
    using PRI_14 = BitField<16, 8>;
    constexpr uint32_t PRI_14_Pos = 16;
    constexpr uint32_t PRI_14_Msk = PRI_14::mask;

    /// Priority of system handler 15, SysTick exception
    /// Position: 24, Width: 8
    using PRI_15 = BitField<24, 8>;
    constexpr uint32_t PRI_15_Pos = 24;
    constexpr uint32_t PRI_15_Msk = PRI_15::mask;

}  // namespace shpr3

/// SHCSR - System Handler Control and State Register
namespace shcsr {
    /// Position: 0, Width: 1
    using MEMFAULTACT = BitField<0, 1>;
    constexpr uint32_t MEMFAULTACT_Pos = 0;
    constexpr uint32_t MEMFAULTACT_Msk = MEMFAULTACT::mask;
    /// Enumerated values for MEMFAULTACT
    namespace memfaultact {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 1, Width: 1
    using BUSFAULTACT = BitField<1, 1>;
    constexpr uint32_t BUSFAULTACT_Pos = 1;
    constexpr uint32_t BUSFAULTACT_Msk = BUSFAULTACT::mask;
    /// Enumerated values for BUSFAULTACT
    namespace busfaultact {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 3, Width: 1
    using USGFAULTACT = BitField<3, 1>;
    constexpr uint32_t USGFAULTACT_Pos = 3;
    constexpr uint32_t USGFAULTACT_Msk = USGFAULTACT::mask;
    /// Enumerated values for USGFAULTACT
    namespace usgfaultact {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 7, Width: 1
    using SVCALLACT = BitField<7, 1>;
    constexpr uint32_t SVCALLACT_Pos = 7;
    constexpr uint32_t SVCALLACT_Msk = SVCALLACT::mask;
    /// Enumerated values for SVCALLACT
    namespace svcallact {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 8, Width: 1
    using MONITORACT = BitField<8, 1>;
    constexpr uint32_t MONITORACT_Pos = 8;
    constexpr uint32_t MONITORACT_Msk = MONITORACT::mask;
    /// Enumerated values for MONITORACT
    namespace monitoract {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 10, Width: 1
    using PENDSVACT = BitField<10, 1>;
    constexpr uint32_t PENDSVACT_Pos = 10;
    constexpr uint32_t PENDSVACT_Msk = PENDSVACT::mask;
    /// Enumerated values for PENDSVACT
    namespace pendsvact {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 11, Width: 1
    using SYSTICKACT = BitField<11, 1>;
    constexpr uint32_t SYSTICKACT_Pos = 11;
    constexpr uint32_t SYSTICKACT_Msk = SYSTICKACT::mask;
    /// Enumerated values for SYSTICKACT
    namespace systickact {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 12, Width: 1
    using USGFAULTPENDED = BitField<12, 1>;
    constexpr uint32_t USGFAULTPENDED_Pos = 12;
    constexpr uint32_t USGFAULTPENDED_Msk = USGFAULTPENDED::mask;
    /// Enumerated values for USGFAULTPENDED
    namespace usgfaultpended {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 13, Width: 1
    using MEMFAULTPENDED = BitField<13, 1>;
    constexpr uint32_t MEMFAULTPENDED_Pos = 13;
    constexpr uint32_t MEMFAULTPENDED_Msk = MEMFAULTPENDED::mask;
    /// Enumerated values for MEMFAULTPENDED
    namespace memfaultpended {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 14, Width: 1
    using BUSFAULTPENDED = BitField<14, 1>;
    constexpr uint32_t BUSFAULTPENDED_Pos = 14;
    constexpr uint32_t BUSFAULTPENDED_Msk = BUSFAULTPENDED::mask;
    /// Enumerated values for BUSFAULTPENDED
    namespace busfaultpended {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 15, Width: 1
    using SVCALLPENDED = BitField<15, 1>;
    constexpr uint32_t SVCALLPENDED_Pos = 15;
    constexpr uint32_t SVCALLPENDED_Msk = SVCALLPENDED::mask;
    /// Enumerated values for SVCALLPENDED
    namespace svcallpended {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 16, Width: 1
    using MEMFAULTENA = BitField<16, 1>;
    constexpr uint32_t MEMFAULTENA_Pos = 16;
    constexpr uint32_t MEMFAULTENA_Msk = MEMFAULTENA::mask;
    /// Enumerated values for MEMFAULTENA
    namespace memfaultena {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 17, Width: 1
    using BUSFAULTENA = BitField<17, 1>;
    constexpr uint32_t BUSFAULTENA_Pos = 17;
    constexpr uint32_t BUSFAULTENA_Msk = BUSFAULTENA::mask;
    /// Enumerated values for BUSFAULTENA
    namespace busfaultena {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 18, Width: 1
    using USGFAULTENA = BitField<18, 1>;
    constexpr uint32_t USGFAULTENA_Pos = 18;
    constexpr uint32_t USGFAULTENA_Msk = USGFAULTENA::mask;
    /// Enumerated values for USGFAULTENA
    namespace usgfaultena {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

}  // namespace shcsr

/// CFSR - Configurable Fault Status Registers
namespace cfsr {
    /// Position: 0, Width: 1
    using IACCVIOL = BitField<0, 1>;
    constexpr uint32_t IACCVIOL_Pos = 0;
    constexpr uint32_t IACCVIOL_Msk = IACCVIOL::mask;
    /// Enumerated values for IACCVIOL
    namespace iaccviol {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 1, Width: 1
    using DACCVIOL = BitField<1, 1>;
    constexpr uint32_t DACCVIOL_Pos = 1;
    constexpr uint32_t DACCVIOL_Msk = DACCVIOL::mask;
    /// Enumerated values for DACCVIOL
    namespace daccviol {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 3, Width: 1
    using MUNSTKERR = BitField<3, 1>;
    constexpr uint32_t MUNSTKERR_Pos = 3;
    constexpr uint32_t MUNSTKERR_Msk = MUNSTKERR::mask;
    /// Enumerated values for MUNSTKERR
    namespace munstkerr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 4, Width: 1
    using MSTKERR = BitField<4, 1>;
    constexpr uint32_t MSTKERR_Pos = 4;
    constexpr uint32_t MSTKERR_Msk = MSTKERR::mask;
    /// Enumerated values for MSTKERR
    namespace mstkerr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 5, Width: 1
    using MLSPERR = BitField<5, 1>;
    constexpr uint32_t MLSPERR_Pos = 5;
    constexpr uint32_t MLSPERR_Msk = MLSPERR::mask;
    /// Enumerated values for MLSPERR
    namespace mlsperr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 7, Width: 1
    using MMARVALID = BitField<7, 1>;
    constexpr uint32_t MMARVALID_Pos = 7;
    constexpr uint32_t MMARVALID_Msk = MMARVALID::mask;
    /// Enumerated values for MMARVALID
    namespace mmarvalid {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 8, Width: 1
    using IBUSERR = BitField<8, 1>;
    constexpr uint32_t IBUSERR_Pos = 8;
    constexpr uint32_t IBUSERR_Msk = IBUSERR::mask;
    /// Enumerated values for IBUSERR
    namespace ibuserr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 9, Width: 1
    using PRECISERR = BitField<9, 1>;
    constexpr uint32_t PRECISERR_Pos = 9;
    constexpr uint32_t PRECISERR_Msk = PRECISERR::mask;
    /// Enumerated values for PRECISERR
    namespace preciserr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 10, Width: 1
    using IMPRECISERR = BitField<10, 1>;
    constexpr uint32_t IMPRECISERR_Pos = 10;
    constexpr uint32_t IMPRECISERR_Msk = IMPRECISERR::mask;
    /// Enumerated values for IMPRECISERR
    namespace impreciserr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 11, Width: 1
    using UNSTKERR = BitField<11, 1>;
    constexpr uint32_t UNSTKERR_Pos = 11;
    constexpr uint32_t UNSTKERR_Msk = UNSTKERR::mask;
    /// Enumerated values for UNSTKERR
    namespace unstkerr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 12, Width: 1
    using STKERR = BitField<12, 1>;
    constexpr uint32_t STKERR_Pos = 12;
    constexpr uint32_t STKERR_Msk = STKERR::mask;
    /// Enumerated values for STKERR
    namespace stkerr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 13, Width: 1
    using LSPERR = BitField<13, 1>;
    constexpr uint32_t LSPERR_Pos = 13;
    constexpr uint32_t LSPERR_Msk = LSPERR::mask;
    /// Enumerated values for LSPERR
    namespace lsperr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 15, Width: 1
    using BFARVALID = BitField<15, 1>;
    constexpr uint32_t BFARVALID_Pos = 15;
    constexpr uint32_t BFARVALID_Msk = BFARVALID::mask;
    /// Enumerated values for BFARVALID
    namespace bfarvalid {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 16, Width: 1
    using UNDEFINSTR = BitField<16, 1>;
    constexpr uint32_t UNDEFINSTR_Pos = 16;
    constexpr uint32_t UNDEFINSTR_Msk = UNDEFINSTR::mask;
    /// Enumerated values for UNDEFINSTR
    namespace undefinstr {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 17, Width: 1
    using INVSTATE = BitField<17, 1>;
    constexpr uint32_t INVSTATE_Pos = 17;
    constexpr uint32_t INVSTATE_Msk = INVSTATE::mask;
    /// Enumerated values for INVSTATE
    namespace invstate {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 18, Width: 1
    using INVPC = BitField<18, 1>;
    constexpr uint32_t INVPC_Pos = 18;
    constexpr uint32_t INVPC_Msk = INVPC::mask;
    /// Enumerated values for INVPC
    namespace invpc {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 19, Width: 1
    using NOCP = BitField<19, 1>;
    constexpr uint32_t NOCP_Pos = 19;
    constexpr uint32_t NOCP_Msk = NOCP::mask;
    /// Enumerated values for NOCP
    namespace nocp {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 24, Width: 1
    using UNALIGNED = BitField<24, 1>;
    constexpr uint32_t UNALIGNED_Pos = 24;
    constexpr uint32_t UNALIGNED_Msk = UNALIGNED::mask;
    /// Enumerated values for UNALIGNED
    namespace unaligned {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Position: 25, Width: 1
    using DIVBYZERO = BitField<25, 1>;
    constexpr uint32_t DIVBYZERO_Pos = 25;
    constexpr uint32_t DIVBYZERO_Msk = DIVBYZERO::mask;
    /// Enumerated values for DIVBYZERO
    namespace divbyzero {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

}  // namespace cfsr

/// HFSR - HardFault Status register
namespace hfsr {
    /// Indicates when a fault has occurred because of a vector table read error on exception processing
    /// Position: 1, Width: 1
    using VECTTBL = BitField<1, 1>;
    constexpr uint32_t VECTTBL_Pos = 1;
    constexpr uint32_t VECTTBL_Msk = VECTTBL::mask;
    /// Enumerated values for VECTTBL
    namespace vecttbl {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Indicates that a fault with configurable priority has been escalated to a HardFault exception
    /// Position: 30, Width: 1
    using FORCED = BitField<30, 1>;
    constexpr uint32_t FORCED_Pos = 30;
    constexpr uint32_t FORCED_Msk = FORCED::mask;
    /// Enumerated values for FORCED
    namespace forced {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// Indicates when a Debug event has occurred
    /// Position: 31, Width: 1
    using DEBUGEVT = BitField<31, 1>;
    constexpr uint32_t DEBUGEVT_Pos = 31;
    constexpr uint32_t DEBUGEVT_Msk = DEBUGEVT::mask;

}  // namespace hfsr

/// DFSR - Debug Fault Status Register
namespace dfsr {
    /// debug event generated by
    /// Position: 0, Width: 1
    using HALTED = BitField<0, 1>;
    constexpr uint32_t HALTED_Pos = 0;
    constexpr uint32_t HALTED_Msk = HALTED::mask;
    /// Enumerated values for HALTED
    namespace halted {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// debug event generated by BKPT instruction execution or a breakpoint match in FPB
    /// Position: 1, Width: 1
    using BKPT = BitField<1, 1>;
    constexpr uint32_t BKPT_Pos = 1;
    constexpr uint32_t BKPT_Msk = BKPT::mask;
    /// Enumerated values for BKPT
    namespace bkpt {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// debug event generated by the DWT
    /// Position: 2, Width: 1
    using DWTTRAP = BitField<2, 1>;
    constexpr uint32_t DWTTRAP_Pos = 2;
    constexpr uint32_t DWTTRAP_Msk = DWTTRAP::mask;
    /// Enumerated values for DWTTRAP
    namespace dwttrap {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// triggering of a Vector catch
    /// Position: 3, Width: 1
    using VCATCH = BitField<3, 1>;
    constexpr uint32_t VCATCH_Pos = 3;
    constexpr uint32_t VCATCH_Msk = VCATCH::mask;
    /// Enumerated values for VCATCH
    namespace vcatch {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

    /// debug event generated because of the assertion of an external debug request
    /// Position: 4, Width: 1
    using EXTERNAL = BitField<4, 1>;
    constexpr uint32_t EXTERNAL_Pos = 4;
    constexpr uint32_t EXTERNAL_Msk = EXTERNAL::mask;
    /// Enumerated values for EXTERNAL
    namespace external {
        constexpr uint32_t VALUE_0 = 0;
        constexpr uint32_t VALUE_1 = 1;
    }

}  // namespace dfsr

/// MMFAR - MemManage Fault Address Register
namespace mmfar {
    /// Data address for an MPU fault
    /// Position: 0, Width: 32
    using ADDRESS = BitField<0, 32>;
    constexpr uint32_t ADDRESS_Pos = 0;
    constexpr uint32_t ADDRESS_Msk = ADDRESS::mask;

}  // namespace mmfar

/// BFAR - BusFault Address Register
namespace bfar {
    /// Data address for a precise bus fault
    /// Position: 0, Width: 32
    using ADDRESS = BitField<0, 32>;
    constexpr uint32_t ADDRESS_Pos = 0;
    constexpr uint32_t ADDRESS_Msk = ADDRESS::mask;

}  // namespace bfar

/// CLIDR - Cache Level ID Register
namespace clidr {
    /// Level of Coherency
    /// Position: 24, Width: 3
    using LoC = BitField<24, 3>;
    constexpr uint32_t LoC_Pos = 24;
    constexpr uint32_t LoC_Msk = LoC::mask;
    /// Enumerated values for LoC
    namespace loc {
        constexpr uint32_t LEVEL_1 = 0;
        constexpr uint32_t LEVEL_2 = 1;
    }

    /// Level of Unification
    /// Position: 27, Width: 3
    using LoU = BitField<27, 3>;
    constexpr uint32_t LoU_Pos = 27;
    constexpr uint32_t LoU_Msk = LoU::mask;
    /// Enumerated values for LoU
    namespace lou {
        constexpr uint32_t LEVEL_1 = 0;
        constexpr uint32_t LEVEL_2 = 1;
    }

}  // namespace clidr

/// CTR - Cache Type Register
namespace ctr {
    /// Smallest cache line of all the instruction caches under the control of the processor
    /// Position: 0, Width: 4
    using IMINLINE = BitField<0, 4>;
    constexpr uint32_t IMINLINE_Pos = 0;
    constexpr uint32_t IMINLINE_Msk = IMINLINE::mask;

    /// Smallest cache line of all the data and unified caches under the core control
    /// Position: 16, Width: 4
    using DMINLINE = BitField<16, 4>;
    constexpr uint32_t DMINLINE_Pos = 16;
    constexpr uint32_t DMINLINE_Msk = DMINLINE::mask;

    /// Exclusives Reservation Granule
    /// Position: 20, Width: 4
    using ERG = BitField<20, 4>;
    constexpr uint32_t ERG_Pos = 20;
    constexpr uint32_t ERG_Msk = ERG::mask;

    /// Cache Writeback Granule
    /// Position: 24, Width: 4
    using CWG = BitField<24, 4>;
    constexpr uint32_t CWG_Pos = 24;
    constexpr uint32_t CWG_Msk = CWG::mask;

    /// Register format
    /// Position: 29, Width: 3
    using FORMAT = BitField<29, 3>;
    constexpr uint32_t FORMAT_Pos = 29;
    constexpr uint32_t FORMAT_Msk = FORMAT::mask;

}  // namespace ctr

/// CCSIDR - Cache Size ID Register
namespace ccsidr {
    /// number of words in each cache line
    /// Position: 0, Width: 3
    using LineSize = BitField<0, 3>;
    constexpr uint32_t LineSize_Pos = 0;
    constexpr uint32_t LineSize_Msk = LineSize::mask;

    /// number of ways
    /// Position: 3, Width: 9
    using Associativity = BitField<3, 9>;
    constexpr uint32_t Associativity_Pos = 3;
    constexpr uint32_t Associativity_Msk = Associativity::mask;

    /// number of sets
    /// Position: 12, Width: 16
    using NumSets = BitField<12, 16>;
    constexpr uint32_t NumSets_Pos = 12;
    constexpr uint32_t NumSets_Msk = NumSets::mask;

    /// Write allocation support
    /// Position: 28, Width: 1
    using WA = BitField<28, 1>;
    constexpr uint32_t WA_Pos = 28;
    constexpr uint32_t WA_Msk = WA::mask;

    /// Read allocation support
    /// Position: 29, Width: 1
    using RA = BitField<29, 1>;
    constexpr uint32_t RA_Pos = 29;
    constexpr uint32_t RA_Msk = RA::mask;

    /// Write-Back support
    /// Position: 30, Width: 1
    using WB = BitField<30, 1>;
    constexpr uint32_t WB_Pos = 30;
    constexpr uint32_t WB_Msk = WB::mask;

    /// Write-Through support
    /// Position: 31, Width: 1
    using WT = BitField<31, 1>;
    constexpr uint32_t WT_Pos = 31;
    constexpr uint32_t WT_Msk = WT::mask;

}  // namespace ccsidr

/// CSSELR - Cache Size Selection Register
namespace csselr {
    /// selection of instruction or data cache
    /// Position: 0, Width: 1
    using IND = BitField<0, 1>;
    constexpr uint32_t IND_Pos = 0;
    constexpr uint32_t IND_Msk = IND::mask;
    /// Enumerated values for IND
    namespace ind {
        constexpr uint32_t DATA = 0;
        constexpr uint32_t INSTRUCTION = 1;
    }

    /// cache level selected
    /// Position: 1, Width: 3
    using LEVEL = BitField<1, 3>;
    constexpr uint32_t LEVEL_Pos = 1;
    constexpr uint32_t LEVEL_Msk = LEVEL::mask;

}  // namespace csselr

/// CPACR - Coprocessor Access Control Register
namespace cpacr {
    /// Access privileges for coprocessor 10.
    /// Position: 20, Width: 2
    using CP10 = BitField<20, 2>;
    constexpr uint32_t CP10_Pos = 20;
    constexpr uint32_t CP10_Msk = CP10::mask;

    /// Access privileges for coprocessor 11.
    /// Position: 22, Width: 2
    using CP11 = BitField<22, 2>;
    constexpr uint32_t CP11_Pos = 22;
    constexpr uint32_t CP11_Msk = CP11::mask;

}  // namespace cpacr

/// STIR - Software Trigger Interrupt Register
namespace stir {
    /// Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
    /// Position: 0, Width: 9
    using INTID = BitField<0, 9>;
    constexpr uint32_t INTID_Pos = 0;
    constexpr uint32_t INTID_Msk = INTID::mask;

}  // namespace stir

}  // namespace alloy::hal::atmel::samv71::atsamv71n20::scb
