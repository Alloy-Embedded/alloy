/// Auto-generated register definitions for SCB
/// Device: ATSAMV71N20B
/// Vendor: Microchip Technology
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

namespace alloy::hal::atmel::samv71::atsamv71n20b::scb {

// ============================================================================
// SCB - System Control Block
// Base Address: 0xE000ED00
// ============================================================================

/// SCB Register Structure
struct SCB_Registers {

    /// CPUID Base Register
    /// Offset: 0x0000
    /// Reset value: 0x411FC271
    /// Access: read-only
    volatile uint32_t CPUID;

    /// Interrupt Control and State Register
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    volatile uint32_t ICSR;

    /// Vector Table Offset Register
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    volatile uint32_t VTOR;

    /// Application Interrupt and Reset Control Register
    /// Offset: 0x000C
    /// Reset value: 0x00000000
    volatile uint32_t AIRCR;

    /// System Control Register
    /// Offset: 0x0010
    /// Reset value: 0x00000000
    volatile uint32_t SCR;

    /// Configuration and Control Register
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    volatile uint32_t CCR;

    /// System Handler Priority Register 1
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    volatile uint32_t SHPR1;

    /// System Handler Priority Register 2
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    volatile uint32_t SHPR2;

    /// System Handler Priority Register 3
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    volatile uint32_t SHPR3;

    /// System Handler Control and State Register
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    volatile uint32_t SHCSR;

    /// Configurable Fault Status Registers
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    volatile uint32_t CFSR;

    /// HardFault Status register
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    volatile uint32_t HFSR;

    /// Debug Fault Status Register
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    volatile uint32_t DFSR;

    /// MemManage Fault Address Register
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    volatile uint32_t MMFAR;

    /// BusFault Address Register
    /// Offset: 0x0038
    /// Reset value: 0x00000000
    volatile uint32_t BFAR;

    /// Auxiliary Fault Status Register
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    volatile uint32_t AFSR;
    uint8_t RESERVED_0040[56]; ///< Reserved

    /// Cache Level ID Register
    /// Offset: 0x0078
    /// Reset value: 0x09000003
    /// Access: read-only
    volatile uint32_t CLIDR;

    /// Cache Type Register
    /// Offset: 0x007C
    /// Reset value: 0x8303C003
    /// Access: read-only
    volatile uint32_t CTR;

    /// Cache Size ID Register
    /// Offset: 0x0080
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t CCSIDR;

    /// Cache Size Selection Register
    /// Offset: 0x0084
    /// Reset value: 0x00000000
    volatile uint32_t CSSELR;

    /// Coprocessor Access Control Register
    /// Offset: 0x0088
    /// Reset value: 0x00000000
    volatile uint32_t CPACR;
    uint8_t RESERVED_008C[196]; ///< Reserved

    /// I-cache invalidate all to PoU
    /// Offset: 0x0150
    /// Access: write-only
    volatile uint32_t ICIALLU;
    uint8_t RESERVED_0154[4]; ///< Reserved

    /// I-cache invalidate by MVA to PoU
    /// Offset: 0x0158
    /// Access: write-only
    volatile uint32_t ICIMVAU;

    /// D-cache invalidate by MVA to PoC
    /// Offset: 0x015C
    /// Access: write-only
    volatile uint32_t DCIMVAC;

    /// D-cache invalidate by set-way
    /// Offset: 0x0160
    /// Access: write-only
    volatile uint32_t DCISW;

    /// D-cache clean by MVA to PoU
    /// Offset: 0x0164
    /// Access: write-only
    volatile uint32_t DCCMVAU;

    /// D-cache clean by MVA to PoC
    /// Offset: 0x0168
    /// Access: write-only
    volatile uint32_t DCCMVAC;

    /// D-cache clean by set-way
    /// Offset: 0x016C
    /// Access: write-only
    volatile uint32_t DCCSW;

    /// D-cache clean and invalidate by MVA to PoC
    /// Offset: 0x0170
    /// Access: write-only
    volatile uint32_t DCCIMVAC;

    /// D-cache clean and invalidate by set-way
    /// Offset: 0x0174
    /// Access: write-only
    volatile uint32_t DCCISW;

    /// Branch predictor invalidate all
    /// Offset: 0x0178
    /// Access: write-only
    volatile uint32_t BPIALL;
    uint8_t RESERVED_017C[132]; ///< Reserved

    /// Software Trigger Interrupt Register
    /// Offset: 0x0200
    /// Reset value: 0x00000000
    /// Access: write-only
    volatile uint32_t STIR;
    uint8_t RESERVED_0204[60]; ///< Reserved

    /// Media and VFP Feature Register 0
    /// Offset: 0x0240
    /// Reset value: 0x10110021
    /// Access: read-only
    volatile uint32_t MVFR0;

    /// Media and VFP Feature Register 1
    /// Offset: 0x0244
    /// Reset value: 0x10110021
    /// Access: read-only
    volatile uint32_t MVFR1;

    /// Media and VFP Feature Register 2
    /// Offset: 0x0248
    /// Reset value: 0x10110021
    /// Access: read-only
    volatile uint32_t MVFR2;
};

static_assert(sizeof(SCB_Registers) >= 588, "SCB_Registers size mismatch");

/// SCB peripheral instance
inline SCB_Registers* SCB() {
    return reinterpret_cast<SCB_Registers*>(0xE000ED00);
}

}  // namespace alloy::hal::atmel::samv71::atsamv71n20b::scb
