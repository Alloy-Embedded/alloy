/// Auto-generated bit field definitions for RMT
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

#include "hal/utils/bitfield.hpp"

namespace alloy::hal::espressif::esp32::rmt {

using namespace alloy::hal::bitfields;

// ============================================================================
// RMT Bit Field Definitions
// ============================================================================

/// CH[8]CONF0 - CH[8]CONF0
namespace chconf0 {
/// This register is used to configure the frequency divider's factor in channel0.
/// Position: 0, Width: 8
/// Access: read-write
using DIV_CNT = BitField<0, 8>;
constexpr uint32_t DIV_CNT_Pos = 0;
constexpr uint32_t DIV_CNT_Msk = DIV_CNT::mask;

/// In receive mode when no edge is detected on the input signal for longer than reg_idle_thres_ch0
/// then the receive process is done. Position: 8, Width: 16 Access: read-write
using IDLE_THRES = BitField<8, 16>;
constexpr uint32_t IDLE_THRES_Pos = 8;
constexpr uint32_t IDLE_THRES_Msk = IDLE_THRES::mask;

/// This register is used to configure the the amount of memory blocks allocated to channel0.
/// Position: 24, Width: 4
/// Access: read-write
using MEM_SIZE = BitField<24, 4>;
constexpr uint32_t MEM_SIZE_Pos = 24;
constexpr uint32_t MEM_SIZE_Msk = MEM_SIZE::mask;

/// This is the carrier modulation enable control bit for channel0.
/// Position: 28, Width: 1
/// Access: read-write
using CARRIER_EN = BitField<28, 1>;
constexpr uint32_t CARRIER_EN_Pos = 28;
constexpr uint32_t CARRIER_EN_Msk = CARRIER_EN::mask;

/// This bit is used to configure the way carrier wave is modulated for channel0.1'b1:transmit on
/// low output level 1'b0:transmit on high output level. Position: 29, Width: 1 Access: read-write
using CARRIER_OUT_LV = BitField<29, 1>;
constexpr uint32_t CARRIER_OUT_LV_Pos = 29;
constexpr uint32_t CARRIER_OUT_LV_Msk = CARRIER_OUT_LV::mask;

/// This bit is used to reduce power consumed by mem. 1:mem is in low power state.
/// Position: 30, Width: 1
/// Access: read-write
using MEM_PD = BitField<30, 1>;
constexpr uint32_t MEM_PD_Pos = 30;
constexpr uint32_t MEM_PD_Msk = MEM_PD::mask;

/// This bit is used to control clock.when software config RMT internal registers it controls the
/// register clock. Position: 31, Width: 1 Access: read-write
using CLK_EN = BitField<31, 1>;
constexpr uint32_t CLK_EN_Pos = 31;
constexpr uint32_t CLK_EN_Msk = CLK_EN::mask;

}  // namespace chconf0

/// CH[8]CONF1 - CH[8]CONF1
namespace chconf1 {
/// Set this bit to start sending data for channel0.
/// Position: 0, Width: 1
/// Access: read-write
using TX_START = BitField<0, 1>;
constexpr uint32_t TX_START_Pos = 0;
constexpr uint32_t TX_START_Msk = TX_START::mask;

/// Set this bit to enbale receving data for channel0.
/// Position: 1, Width: 1
/// Access: read-write
using RX_EN = BitField<1, 1>;
constexpr uint32_t RX_EN_Pos = 1;
constexpr uint32_t RX_EN_Msk = RX_EN::mask;

/// Set this bit to reset write ram address for channel0 by receiver access.
/// Position: 2, Width: 1
/// Access: read-write
using MEM_WR_RST = BitField<2, 1>;
constexpr uint32_t MEM_WR_RST_Pos = 2;
constexpr uint32_t MEM_WR_RST_Msk = MEM_WR_RST::mask;

/// Set this bit to reset read ram address for channel0 by transmitter access.
/// Position: 3, Width: 1
/// Access: read-write
using MEM_RD_RST = BitField<3, 1>;
constexpr uint32_t MEM_RD_RST_Pos = 3;
constexpr uint32_t MEM_RD_RST_Msk = MEM_RD_RST::mask;

/// Set this bit to reset W/R ram address for channel0 by apb fifo access
/// Position: 4, Width: 1
/// Access: read-write
using APB_MEM_RST = BitField<4, 1>;
constexpr uint32_t APB_MEM_RST_Pos = 4;
constexpr uint32_t APB_MEM_RST_Msk = APB_MEM_RST::mask;

/// This is the mark of channel0's ram usage right.1'b1：receiver uses the ram 0：transmitter uses
/// the ram Position: 5, Width: 1 Access: read-write
using MEM_OWNER = BitField<5, 1>;
constexpr uint32_t MEM_OWNER_Pos = 5;
constexpr uint32_t MEM_OWNER_Msk = MEM_OWNER::mask;

/// Set this bit to continue sending from the first data to the last data in channel0 again and
/// again. Position: 6, Width: 1 Access: read-write
using TX_CONTI_MODE = BitField<6, 1>;
constexpr uint32_t TX_CONTI_MODE_Pos = 6;
constexpr uint32_t TX_CONTI_MODE_Msk = TX_CONTI_MODE::mask;

/// This is the receive filter enable bit for channel0.
/// Position: 7, Width: 1
/// Access: read-write
using RX_FILTER_EN = BitField<7, 1>;
constexpr uint32_t RX_FILTER_EN_Pos = 7;
constexpr uint32_t RX_FILTER_EN_Msk = RX_FILTER_EN::mask;

/// in receive mode channel0 ignore input pulse when the pulse width is smaller then this value.
/// Position: 8, Width: 8
/// Access: read-write
using RX_FILTER_THRES = BitField<8, 8>;
constexpr uint32_t RX_FILTER_THRES_Pos = 8;
constexpr uint32_t RX_FILTER_THRES_Msk = RX_FILTER_THRES::mask;

/// This bit is used to reset divider in channel0.
/// Position: 16, Width: 1
/// Access: read-write
using REF_CNT_RST = BitField<16, 1>;
constexpr uint32_t REF_CNT_RST_Pos = 16;
constexpr uint32_t REF_CNT_RST_Msk = REF_CNT_RST::mask;

/// This bit is used to select base clock. 1'b1:clk_apb 1'b0:clk_ref
/// Position: 17, Width: 1
/// Access: read-write
using REF_ALWAYS_ON = BitField<17, 1>;
constexpr uint32_t REF_ALWAYS_ON_Pos = 17;
constexpr uint32_t REF_ALWAYS_ON_Msk = REF_ALWAYS_ON::mask;

/// This bit configures the output signal's level for channel0 in IDLE state.
/// Position: 18, Width: 1
/// Access: read-write
using IDLE_OUT_LV = BitField<18, 1>;
constexpr uint32_t IDLE_OUT_LV_Pos = 18;
constexpr uint32_t IDLE_OUT_LV_Msk = IDLE_OUT_LV::mask;

/// This is the output enable control bit for channel0 in IDLE state.
/// Position: 19, Width: 1
/// Access: read-write
using IDLE_OUT_EN = BitField<19, 1>;
constexpr uint32_t IDLE_OUT_EN_Pos = 19;
constexpr uint32_t IDLE_OUT_EN_Msk = IDLE_OUT_EN::mask;

}  // namespace chconf1

/// CH[8]STATUS - CH[8]STATUS
namespace chstatus {
/// The status for channel0
/// Position: 0, Width: 32
/// Access: read-only
using STATUS = BitField<0, 32>;
constexpr uint32_t STATUS_Pos = 0;
constexpr uint32_t STATUS_Msk = STATUS::mask;

/// The current memory read address of channel0.
/// Position: 0, Width: 10
/// Access: read-only
using MEM_WADDR_EX = BitField<0, 10>;
constexpr uint32_t MEM_WADDR_EX_Pos = 0;
constexpr uint32_t MEM_WADDR_EX_Msk = MEM_WADDR_EX::mask;

/// The current memory write address of channel0.
/// Position: 12, Width: 10
/// Access: read-only
using MEM_RADDR_EX = BitField<12, 10>;
constexpr uint32_t MEM_RADDR_EX_Pos = 12;
constexpr uint32_t MEM_RADDR_EX_Msk = MEM_RADDR_EX::mask;

/// The channel0 state machine status register.3'h0 : idle, 3'h1 : send, 3'h2 : read memory, 3'h3 :
/// receive, 3'h4 : wait. Position: 24, Width: 3 Access: read-only
using STATE = BitField<24, 3>;
constexpr uint32_t STATE_Pos = 24;
constexpr uint32_t STATE_Msk = STATE::mask;

/// When channel0 is configured for receive mode, this bit will turn to high level if rmt_mem_owner
/// register is not set to 1. Position: 27, Width: 1 Access: read-only
using MEM_OWNER_ERR = BitField<27, 1>;
constexpr uint32_t MEM_OWNER_ERR_Pos = 27;
constexpr uint32_t MEM_OWNER_ERR_Msk = MEM_OWNER_ERR::mask;

/// The memory full status bit for channel0 turns to high level when mem_waddr_ex is greater than or
/// equal to the configuration range. Position: 28, Width: 1 Access: read-only
using MEM_FULL = BitField<28, 1>;
constexpr uint32_t MEM_FULL_Pos = 28;
constexpr uint32_t MEM_FULL_Msk = MEM_FULL::mask;

/// The memory empty status bit for channel0. in acyclic mode, this bit turns to high level when
/// mem_raddr_ex is greater than or equal to the configured range. Position: 29, Width: 1 Access:
/// read-only
using MEM_EMPTY = BitField<29, 1>;
constexpr uint32_t MEM_EMPTY_Pos = 29;
constexpr uint32_t MEM_EMPTY_Msk = MEM_EMPTY::mask;

/// The apb write memory status bit for channel0 turns to high level when the apb write address
/// exceeds the configuration range. Position: 30, Width: 1 Access: read-only
using APB_MEM_WR_ERR = BitField<30, 1>;
constexpr uint32_t APB_MEM_WR_ERR_Pos = 30;
constexpr uint32_t APB_MEM_WR_ERR_Msk = APB_MEM_WR_ERR::mask;

/// The apb read memory status bit for channel0 turns to high level when the apb read address
/// exceeds the configuration range. Position: 31, Width: 1 Access: read-only
using APB_MEM_RD_ERR = BitField<31, 1>;
constexpr uint32_t APB_MEM_RD_ERR_Pos = 31;
constexpr uint32_t APB_MEM_RD_ERR_Msk = APB_MEM_RD_ERR::mask;

}  // namespace chstatus

/// CH[8]ADDR - CH[8]ADDR
namespace chaddr {
/// The ram relative address in channel0 by apb fifo access
/// Position: 0, Width: 32
/// Access: read-only
using APB_MEM_ADDR = BitField<0, 32>;
constexpr uint32_t APB_MEM_ADDR_Pos = 0;
constexpr uint32_t APB_MEM_ADDR_Msk = APB_MEM_ADDR::mask;

}  // namespace chaddr

/// INT_RAW - INT_RAW
namespace int_raw {
/// The interrupt raw bit for channel %s turns to high level when the transmit process is done.
/// Position: 0, Width: 1
/// Access: read-only
using CH % s_TX_END = BitField<0, 1>;
constexpr uint32_t CH % s_TX_END_Pos = 0;
constexpr uint32_t CH % s_TX_END_Msk = CH % s_TX_END::mask;

/// The interrupt raw bit for channel %s turns to high level when the receive process is done.
/// Position: 1, Width: 1
/// Access: read-only
using CH % s_RX_END = BitField<1, 1>;
constexpr uint32_t CH % s_RX_END_Pos = 1;
constexpr uint32_t CH % s_RX_END_Msk = CH % s_RX_END::mask;

/// The interrupt raw bit for channel %s turns to high level when channle %s detects some errors.
/// Position: 2, Width: 1
/// Access: read-only
using CH % s_ERR = BitField<2, 1>;
constexpr uint32_t CH % s_ERR_Pos = 2;
constexpr uint32_t CH % s_ERR_Msk = CH % s_ERR::mask;

/// The interrupt raw bit for channel %s turns to high level when transmitter in channle%s have send
/// datas more than reg_rmt_tx_lim_ch%s after detecting this interrupt software can updata the old
/// datas with new datas. Position: 24, Width: 1 Access: read-only
using CH % s_TX_THR_EVENT = BitField<24, 1>;
constexpr uint32_t CH % s_TX_THR_EVENT_Pos = 24;
constexpr uint32_t CH % s_TX_THR_EVENT_Msk = CH % s_TX_THR_EVENT::mask;

}  // namespace int_raw

/// INT_ST - INT_ST
namespace int_st {
/// The interrupt state bit for channel %s's mt_ch%s_tx_end_int_raw when mt_ch%s_tx_end_int_ena is
/// set to %s. Position: 0, Width: 1 Access: read-only
using CH % s_TX_END = BitField<0, 1>;
constexpr uint32_t CH % s_TX_END_Pos = 0;
constexpr uint32_t CH % s_TX_END_Msk = CH % s_TX_END::mask;

/// The interrupt state bit for channel %s's rmt_ch%s_rx_end_int_raw when rmt_ch%s_rx_end_int_ena is
/// set to %s. Position: 1, Width: 1 Access: read-only
using CH % s_RX_END = BitField<1, 1>;
constexpr uint32_t CH % s_RX_END_Pos = 1;
constexpr uint32_t CH % s_RX_END_Msk = CH % s_RX_END::mask;

/// The interrupt state bit for channel %s's rmt_ch%s_err_int_raw when rmt_ch%s_err_int_ena is set
/// to %s. Position: 2, Width: 1 Access: read-only
using CH % s_ERR = BitField<2, 1>;
constexpr uint32_t CH % s_ERR_Pos = 2;
constexpr uint32_t CH % s_ERR_Msk = CH % s_ERR::mask;

/// The interrupt state bit for channel %s's rmt_ch%s_tx_thr_event_int_raw when
/// mt_ch%s_tx_thr_event_int_ena is set to 1. Position: 24, Width: 1 Access: read-only
using CH % s_TX_THR_EVENT = BitField<24, 1>;
constexpr uint32_t CH % s_TX_THR_EVENT_Pos = 24;
constexpr uint32_t CH % s_TX_THR_EVENT_Msk = CH % s_TX_THR_EVENT::mask;

}  // namespace int_st

/// INT_ENA - INT_ENA
namespace int_ena {
/// Set this bit to enable rmt_ch%s_tx_end_int_st.
/// Position: 0, Width: 1
/// Access: read-write
using CH % s_TX_END = BitField<0, 1>;
constexpr uint32_t CH % s_TX_END_Pos = 0;
constexpr uint32_t CH % s_TX_END_Msk = CH % s_TX_END::mask;

/// Set this bit to enable rmt_ch%s_rx_end_int_st.
/// Position: 1, Width: 1
/// Access: read-write
using CH % s_RX_END = BitField<1, 1>;
constexpr uint32_t CH % s_RX_END_Pos = 1;
constexpr uint32_t CH % s_RX_END_Msk = CH % s_RX_END::mask;

/// Set this bit to enable rmt_ch%s_err_int_st.
/// Position: 2, Width: 1
/// Access: read-write
using CH % s_ERR = BitField<2, 1>;
constexpr uint32_t CH % s_ERR_Pos = 2;
constexpr uint32_t CH % s_ERR_Msk = CH % s_ERR::mask;

/// Set this bit to enable rmt_ch%s_tx_thr_event_int_st.
/// Position: 24, Width: 1
/// Access: read-write
using CH % s_TX_THR_EVENT = BitField<24, 1>;
constexpr uint32_t CH % s_TX_THR_EVENT_Pos = 24;
constexpr uint32_t CH % s_TX_THR_EVENT_Msk = CH % s_TX_THR_EVENT::mask;

}  // namespace int_ena

/// INT_CLR - INT_CLR
namespace int_clr {
/// Set this bit to clear the rmt_ch%s_rx_end_int_raw..
/// Position: 0, Width: 1
/// Access: write-only
using CH % s_TX_END = BitField<0, 1>;
constexpr uint32_t CH % s_TX_END_Pos = 0;
constexpr uint32_t CH % s_TX_END_Msk = CH % s_TX_END::mask;

/// Set this bit to clear the rmt_ch%s_tx_end_int_raw.
/// Position: 1, Width: 1
/// Access: write-only
using CH % s_RX_END = BitField<1, 1>;
constexpr uint32_t CH % s_RX_END_Pos = 1;
constexpr uint32_t CH % s_RX_END_Msk = CH % s_RX_END::mask;

/// Set this bit to clear the rmt_ch%s_err_int_raw.
/// Position: 2, Width: 1
/// Access: write-only
using CH % s_ERR = BitField<2, 1>;
constexpr uint32_t CH % s_ERR_Pos = 2;
constexpr uint32_t CH % s_ERR_Msk = CH % s_ERR::mask;

/// Set this bit to clear the rmt_ch%s_tx_thr_event_int_raw interrupt.
/// Position: 24, Width: 1
/// Access: write-only
using CH % s_TX_THR_EVENT = BitField<24, 1>;
constexpr uint32_t CH % s_TX_THR_EVENT_Pos = 24;
constexpr uint32_t CH % s_TX_THR_EVENT_Msk = CH % s_TX_THR_EVENT::mask;

}  // namespace int_clr

/// CH[8]CARRIER_DUTY - CH[8]CARRIER_DUTY
namespace chcarrier_duty {
/// This register is used to configure carrier wave's low level value for channel0.
/// Position: 0, Width: 16
/// Access: read-write
using CARRIER_LOW = BitField<0, 16>;
constexpr uint32_t CARRIER_LOW_Pos = 0;
constexpr uint32_t CARRIER_LOW_Msk = CARRIER_LOW::mask;

/// This register is used to configure carrier wave's high level value for channel0.
/// Position: 16, Width: 16
/// Access: read-write
using CARRIER_HIGH = BitField<16, 16>;
constexpr uint32_t CARRIER_HIGH_Pos = 16;
constexpr uint32_t CARRIER_HIGH_Msk = CARRIER_HIGH::mask;

}  // namespace chcarrier_duty

/// CH[8]_TX_LIM - CH[8]_TX_LIM
namespace ch_tx_lim {
/// When channel0 sends more than reg_rmt_tx_lim_ch0 datas then channel0 produce the relative
/// interrupt. Position: 0, Width: 9 Access: read-write
using TX_LIM = BitField<0, 9>;
constexpr uint32_t TX_LIM_Pos = 0;
constexpr uint32_t TX_LIM_Msk = TX_LIM::mask;

}  // namespace ch_tx_lim

/// APB_CONF - APB_CONF
namespace apb_conf {
/// Set this bit to disable apb fifo access
/// Position: 0, Width: 1
/// Access: read-write
using APB_FIFO_MASK = BitField<0, 1>;
constexpr uint32_t APB_FIFO_MASK_Pos = 0;
constexpr uint32_t APB_FIFO_MASK_Msk = APB_FIFO_MASK::mask;

/// when datas need to be send is more than channel's mem can store then set this bit to enable
/// reusage of mem this bit is used together with reg_rmt_tx_lim_chn. Position: 1, Width: 1 Access:
/// read-write
using MEM_TX_WRAP_EN = BitField<1, 1>;
constexpr uint32_t MEM_TX_WRAP_EN_Pos = 1;
constexpr uint32_t MEM_TX_WRAP_EN_Msk = MEM_TX_WRAP_EN::mask;

}  // namespace apb_conf

/// DATE - DATE
namespace date {
/// This is the version register.
/// Position: 0, Width: 32
/// Access: read-write
using DATE = BitField<0, 32>;
constexpr uint32_t DATE_Pos = 0;
constexpr uint32_t DATE_Msk = DATE::mask;

}  // namespace date

}  // namespace alloy::hal::espressif::esp32::rmt
