/// Auto-generated bit field definitions for TIMG0
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::espressif::esp32::timg0 {

using namespace alloy::hal::bitfields;

// ============================================================================
// TIMG0 Bit Field Definitions
// ============================================================================

/// T0CONFIG - T0CONFIG
namespace t0config {
    /// When set alarm is enabled
    /// Position: 10, Width: 1
    /// Access: read-write
    using ALARM_EN = BitField<10, 1>;
    constexpr uint32_t ALARM_EN_Pos = 10;
    constexpr uint32_t ALARM_EN_Msk = ALARM_EN::mask;

    /// When set level type interrupt will be generated during alarm
    /// Position: 11, Width: 1
    /// Access: read-write
    using LEVEL_INT_EN = BitField<11, 1>;
    constexpr uint32_t LEVEL_INT_EN_Pos = 11;
    constexpr uint32_t LEVEL_INT_EN_Msk = LEVEL_INT_EN::mask;

    /// When set edge type interrupt will be generated during alarm
    /// Position: 12, Width: 1
    /// Access: read-write
    using EDGE_INT_EN = BitField<12, 1>;
    constexpr uint32_t EDGE_INT_EN_Pos = 12;
    constexpr uint32_t EDGE_INT_EN_Msk = EDGE_INT_EN::mask;

    /// Timer 0 clock (T0_clk) prescale value.
    /// Position: 13, Width: 16
    /// Access: read-write
    using DIVIDER = BitField<13, 16>;
    constexpr uint32_t DIVIDER_Pos = 13;
    constexpr uint32_t DIVIDER_Msk = DIVIDER::mask;

    /// When set timer 0 auto-reload at alarming is enabled
    /// Position: 29, Width: 1
    /// Access: read-write
    using AUTORELOAD = BitField<29, 1>;
    constexpr uint32_t AUTORELOAD_Pos = 29;
    constexpr uint32_t AUTORELOAD_Msk = AUTORELOAD::mask;

    /// When set timer 0 time-base counter increment. When cleared timer 0 time-base counter decrement.
    /// Position: 30, Width: 1
    /// Access: read-write
    using INCREASE = BitField<30, 1>;
    constexpr uint32_t INCREASE_Pos = 30;
    constexpr uint32_t INCREASE_Msk = INCREASE::mask;

    /// When set timer 0 time-base counter is enabled
    /// Position: 31, Width: 1
    /// Access: read-write
    using EN = BitField<31, 1>;
    constexpr uint32_t EN_Pos = 31;
    constexpr uint32_t EN_Msk = EN::mask;

}  // namespace t0config

/// T0LO - T0LO
namespace t0lo {
    /// Register to store timer 0 time-base counter current value lower 32 bits.
    /// Position: 0, Width: 32
    /// Access: read-only
    using LO = BitField<0, 32>;
    constexpr uint32_t LO_Pos = 0;
    constexpr uint32_t LO_Msk = LO::mask;

}  // namespace t0lo

/// T0HI - T0HI
namespace t0hi {
    /// Register to store timer 0 time-base counter current value higher 32 bits.
    /// Position: 0, Width: 32
    /// Access: read-only
    using HI = BitField<0, 32>;
    constexpr uint32_t HI_Pos = 0;
    constexpr uint32_t HI_Msk = HI::mask;

}  // namespace t0hi

/// T0UPDATE - T0UPDATE
namespace t0update {
    /// Write any value will trigger a timer 0 time-base counter value update (timer 0 current value will be stored in registers above)
    /// Position: 0, Width: 32
    /// Access: write-only
    using UPDATE = BitField<0, 32>;
    constexpr uint32_t UPDATE_Pos = 0;
    constexpr uint32_t UPDATE_Msk = UPDATE::mask;

}  // namespace t0update

/// T0ALARMLO - T0ALARMLO
namespace t0alarmlo {
    /// Timer 0 time-base counter value lower 32 bits that will trigger the alarm
    /// Position: 0, Width: 32
    /// Access: read-write
    using ALARM_LO = BitField<0, 32>;
    constexpr uint32_t ALARM_LO_Pos = 0;
    constexpr uint32_t ALARM_LO_Msk = ALARM_LO::mask;

}  // namespace t0alarmlo

/// T0ALARMHI - T0ALARMHI
namespace t0alarmhi {
    /// Timer 0 time-base counter value higher 32 bits that will trigger the alarm
    /// Position: 0, Width: 32
    /// Access: read-write
    using ALARM_HI = BitField<0, 32>;
    constexpr uint32_t ALARM_HI_Pos = 0;
    constexpr uint32_t ALARM_HI_Msk = ALARM_HI::mask;

}  // namespace t0alarmhi

/// T0LOADLO - T0LOADLO
namespace t0loadlo {
    /// Lower 32 bits of the value that will load into timer 0 time-base counter
    /// Position: 0, Width: 32
    /// Access: read-write
    using LOAD_LO = BitField<0, 32>;
    constexpr uint32_t LOAD_LO_Pos = 0;
    constexpr uint32_t LOAD_LO_Msk = LOAD_LO::mask;

}  // namespace t0loadlo

/// T0LOADHI - T0LOADHI
namespace t0loadhi {
    /// higher 32 bits of the value that will load into timer 0 time-base counter
    /// Position: 0, Width: 32
    /// Access: read-write
    using LOAD_HI = BitField<0, 32>;
    constexpr uint32_t LOAD_HI_Pos = 0;
    constexpr uint32_t LOAD_HI_Msk = LOAD_HI::mask;

}  // namespace t0loadhi

/// T0LOAD - T0LOAD
namespace t0load {
    /// Write any value will trigger timer 0 time-base counter reload
    /// Position: 0, Width: 32
    /// Access: write-only
    using LOAD = BitField<0, 32>;
    constexpr uint32_t LOAD_Pos = 0;
    constexpr uint32_t LOAD_Msk = LOAD::mask;

}  // namespace t0load

/// T1CONFIG - T1CONFIG
namespace t1config {
    /// When set alarm is enabled
    /// Position: 10, Width: 1
    /// Access: read-write
    using ALARM_EN = BitField<10, 1>;
    constexpr uint32_t ALARM_EN_Pos = 10;
    constexpr uint32_t ALARM_EN_Msk = ALARM_EN::mask;

    /// When set level type interrupt will be generated during alarm
    /// Position: 11, Width: 1
    /// Access: read-write
    using LEVEL_INT_EN = BitField<11, 1>;
    constexpr uint32_t LEVEL_INT_EN_Pos = 11;
    constexpr uint32_t LEVEL_INT_EN_Msk = LEVEL_INT_EN::mask;

    /// When set edge type interrupt will be generated during alarm
    /// Position: 12, Width: 1
    /// Access: read-write
    using EDGE_INT_EN = BitField<12, 1>;
    constexpr uint32_t EDGE_INT_EN_Pos = 12;
    constexpr uint32_t EDGE_INT_EN_Msk = EDGE_INT_EN::mask;

    /// Timer 1 clock (T1_clk) prescale value.
    /// Position: 13, Width: 16
    /// Access: read-write
    using DIVIDER = BitField<13, 16>;
    constexpr uint32_t DIVIDER_Pos = 13;
    constexpr uint32_t DIVIDER_Msk = DIVIDER::mask;

    /// When set timer 1 auto-reload at alarming is enabled
    /// Position: 29, Width: 1
    /// Access: read-write
    using AUTORELOAD = BitField<29, 1>;
    constexpr uint32_t AUTORELOAD_Pos = 29;
    constexpr uint32_t AUTORELOAD_Msk = AUTORELOAD::mask;

    /// When set timer 1 time-base counter increment. When cleared timer 1 time-base counter decrement.
    /// Position: 30, Width: 1
    /// Access: read-write
    using INCREASE = BitField<30, 1>;
    constexpr uint32_t INCREASE_Pos = 30;
    constexpr uint32_t INCREASE_Msk = INCREASE::mask;

    /// When set timer 1 time-base counter is enabled
    /// Position: 31, Width: 1
    /// Access: read-write
    using EN = BitField<31, 1>;
    constexpr uint32_t EN_Pos = 31;
    constexpr uint32_t EN_Msk = EN::mask;

}  // namespace t1config

/// T1LO - T1LO
namespace t1lo {
    /// Register to store timer 1 time-base counter current value lower 32 bits.
    /// Position: 0, Width: 32
    /// Access: read-only
    using LO = BitField<0, 32>;
    constexpr uint32_t LO_Pos = 0;
    constexpr uint32_t LO_Msk = LO::mask;

}  // namespace t1lo

/// T1HI - T1HI
namespace t1hi {
    /// Register to store timer 1 time-base counter current value higher 32 bits.
    /// Position: 0, Width: 32
    /// Access: read-only
    using HI = BitField<0, 32>;
    constexpr uint32_t HI_Pos = 0;
    constexpr uint32_t HI_Msk = HI::mask;

}  // namespace t1hi

/// T1UPDATE - T1UPDATE
namespace t1update {
    /// Write any value will trigger a timer 1 time-base counter value update (timer 1 current value will be stored in registers above)
    /// Position: 0, Width: 32
    /// Access: write-only
    using UPDATE = BitField<0, 32>;
    constexpr uint32_t UPDATE_Pos = 0;
    constexpr uint32_t UPDATE_Msk = UPDATE::mask;

}  // namespace t1update

/// T1ALARMLO - T1ALARMLO
namespace t1alarmlo {
    /// Timer 1 time-base counter value lower 32 bits that will trigger the alarm
    /// Position: 0, Width: 32
    /// Access: read-write
    using ALARM_LO = BitField<0, 32>;
    constexpr uint32_t ALARM_LO_Pos = 0;
    constexpr uint32_t ALARM_LO_Msk = ALARM_LO::mask;

}  // namespace t1alarmlo

/// T1ALARMHI - T1ALARMHI
namespace t1alarmhi {
    /// Timer 1 time-base counter value higher 32 bits that will trigger the alarm
    /// Position: 0, Width: 32
    /// Access: read-write
    using ALARM_HI = BitField<0, 32>;
    constexpr uint32_t ALARM_HI_Pos = 0;
    constexpr uint32_t ALARM_HI_Msk = ALARM_HI::mask;

}  // namespace t1alarmhi

/// T1LOADLO - T1LOADLO
namespace t1loadlo {
    /// Lower 32 bits of the value that will load into timer 1 time-base counter
    /// Position: 0, Width: 32
    /// Access: read-write
    using LOAD_LO = BitField<0, 32>;
    constexpr uint32_t LOAD_LO_Pos = 0;
    constexpr uint32_t LOAD_LO_Msk = LOAD_LO::mask;

}  // namespace t1loadlo

/// T1LOADHI - T1LOADHI
namespace t1loadhi {
    /// higher 32 bits of the value that will load into timer 1 time-base counter
    /// Position: 0, Width: 32
    /// Access: read-write
    using LOAD_HI = BitField<0, 32>;
    constexpr uint32_t LOAD_HI_Pos = 0;
    constexpr uint32_t LOAD_HI_Msk = LOAD_HI::mask;

}  // namespace t1loadhi

/// T1LOAD - T1LOAD
namespace t1load {
    /// Write any value will trigger timer 1 time-base counter reload
    /// Position: 0, Width: 32
    /// Access: write-only
    using LOAD = BitField<0, 32>;
    constexpr uint32_t LOAD_Pos = 0;
    constexpr uint32_t LOAD_Msk = LOAD::mask;

}  // namespace t1load

/// WDTCONFIG0 - WDTCONFIG0
namespace wdtconfig0 {
    /// When set flash boot protection is enabled
    /// Position: 14, Width: 1
    /// Access: read-write
    using WDT_FLASHBOOT_MOD_EN = BitField<14, 1>;
    constexpr uint32_t WDT_FLASHBOOT_MOD_EN_Pos = 14;
    constexpr uint32_t WDT_FLASHBOOT_MOD_EN_Msk = WDT_FLASHBOOT_MOD_EN::mask;

    /// length of system reset selection. 0: 100ns 1: 200ns 2: 300ns 3: 400ns 4: 500ns 5: 800ns 6: 1.6us 7: 3.2us
    /// Position: 15, Width: 3
    /// Access: read-write
    using WDT_SYS_RESET_LENGTH = BitField<15, 3>;
    constexpr uint32_t WDT_SYS_RESET_LENGTH_Pos = 15;
    constexpr uint32_t WDT_SYS_RESET_LENGTH_Msk = WDT_SYS_RESET_LENGTH::mask;
    /// Enumerated values for WDT_SYS_RESET_LENGTH
    namespace wdt_sys_reset_length {
        constexpr uint32_t NS100 = 0;
        constexpr uint32_t NS200 = 1;
        constexpr uint32_t NS300 = 2;
        constexpr uint32_t NS400 = 3;
        constexpr uint32_t NS500 = 4;
        constexpr uint32_t NS800 = 5;
        constexpr uint32_t NS1600 = 6;
        constexpr uint32_t NS3200 = 7;
    }

    /// length of CPU reset selection. 0: 100ns 1: 200ns 2: 300ns 3: 400ns 4: 500ns 5: 800ns 6: 1.6us 7: 3.2us
    /// Position: 18, Width: 3
    /// Access: read-write
    using WDT_CPU_RESET_LENGTH = BitField<18, 3>;
    constexpr uint32_t WDT_CPU_RESET_LENGTH_Pos = 18;
    constexpr uint32_t WDT_CPU_RESET_LENGTH_Msk = WDT_CPU_RESET_LENGTH::mask;
    /// Enumerated values for WDT_CPU_RESET_LENGTH
    namespace wdt_cpu_reset_length {
        constexpr uint32_t NS100 = 0;
        constexpr uint32_t NS200 = 1;
        constexpr uint32_t NS300 = 2;
        constexpr uint32_t NS400 = 3;
        constexpr uint32_t NS500 = 4;
        constexpr uint32_t NS800 = 5;
        constexpr uint32_t NS1600 = 6;
        constexpr uint32_t NS3200 = 7;
    }

    /// When set level type interrupt generation is enabled
    /// Position: 21, Width: 1
    /// Access: read-write
    using WDT_LEVEL_INT_EN = BitField<21, 1>;
    constexpr uint32_t WDT_LEVEL_INT_EN_Pos = 21;
    constexpr uint32_t WDT_LEVEL_INT_EN_Msk = WDT_LEVEL_INT_EN::mask;

    /// When set edge type interrupt generation is enabled
    /// Position: 22, Width: 1
    /// Access: read-write
    using WDT_EDGE_INT_EN = BitField<22, 1>;
    constexpr uint32_t WDT_EDGE_INT_EN_Pos = 22;
    constexpr uint32_t WDT_EDGE_INT_EN_Msk = WDT_EDGE_INT_EN::mask;

    /// Stage 3 configuration. 0: off 1: interrupt 2: reset CPU 3: reset system
    /// Position: 23, Width: 2
    /// Access: read-write
    using WDT_STG3 = BitField<23, 2>;
    constexpr uint32_t WDT_STG3_Pos = 23;
    constexpr uint32_t WDT_STG3_Msk = WDT_STG3::mask;
    /// Enumerated values for WDT_STG3
    namespace wdt_stg3 {
        constexpr uint32_t OFF = 0;
        constexpr uint32_t INTERRUPT = 1;
        constexpr uint32_t RESET = 2;
        constexpr uint32_t RESET_SYS = 3;
    }

    /// Stage 2 configuration. 0: off 1: interrupt 2: reset CPU 3: reset system
    /// Position: 25, Width: 2
    /// Access: read-write
    using WDT_STG2 = BitField<25, 2>;
    constexpr uint32_t WDT_STG2_Pos = 25;
    constexpr uint32_t WDT_STG2_Msk = WDT_STG2::mask;

    /// Stage 1 configuration. 0: off 1: interrupt 2: reset CPU 3: reset system
    /// Position: 27, Width: 2
    /// Access: read-write
    using WDT_STG1 = BitField<27, 2>;
    constexpr uint32_t WDT_STG1_Pos = 27;
    constexpr uint32_t WDT_STG1_Msk = WDT_STG1::mask;

    /// Stage 0 configuration. 0: off 1: interrupt 2: reset CPU 3: reset system
    /// Position: 29, Width: 2
    /// Access: read-write
    using WDT_STG0 = BitField<29, 2>;
    constexpr uint32_t WDT_STG0_Pos = 29;
    constexpr uint32_t WDT_STG0_Msk = WDT_STG0::mask;

    /// When set SWDT is enabled
    /// Position: 31, Width: 1
    /// Access: read-write
    using WDT_EN = BitField<31, 1>;
    constexpr uint32_t WDT_EN_Pos = 31;
    constexpr uint32_t WDT_EN_Msk = WDT_EN::mask;

}  // namespace wdtconfig0

/// WDTCONFIG1 - WDTCONFIG1
namespace wdtconfig1 {
    /// SWDT clock prescale value. Period = 12.5ns * value stored in this register
    /// Position: 16, Width: 16
    /// Access: read-write
    using WDT_CLK_PRESCALE = BitField<16, 16>;
    constexpr uint32_t WDT_CLK_PRESCALE_Pos = 16;
    constexpr uint32_t WDT_CLK_PRESCALE_Msk = WDT_CLK_PRESCALE::mask;

}  // namespace wdtconfig1

/// WDTCONFIG2 - WDTCONFIG2
namespace wdtconfig2 {
    /// Stage 0 timeout value in SWDT clock cycles
    /// Position: 0, Width: 32
    /// Access: read-write
    using WDT_STG0_HOLD = BitField<0, 32>;
    constexpr uint32_t WDT_STG0_HOLD_Pos = 0;
    constexpr uint32_t WDT_STG0_HOLD_Msk = WDT_STG0_HOLD::mask;

}  // namespace wdtconfig2

/// WDTCONFIG3 - WDTCONFIG3
namespace wdtconfig3 {
    /// Stage 1 timeout value in SWDT clock cycles
    /// Position: 0, Width: 32
    /// Access: read-write
    using WDT_STG1_HOLD = BitField<0, 32>;
    constexpr uint32_t WDT_STG1_HOLD_Pos = 0;
    constexpr uint32_t WDT_STG1_HOLD_Msk = WDT_STG1_HOLD::mask;

}  // namespace wdtconfig3

/// WDTCONFIG4 - WDTCONFIG4
namespace wdtconfig4 {
    /// Stage 2 timeout value in SWDT clock cycles
    /// Position: 0, Width: 32
    /// Access: read-write
    using WDT_STG2_HOLD = BitField<0, 32>;
    constexpr uint32_t WDT_STG2_HOLD_Pos = 0;
    constexpr uint32_t WDT_STG2_HOLD_Msk = WDT_STG2_HOLD::mask;

}  // namespace wdtconfig4

/// WDTCONFIG5 - WDTCONFIG5
namespace wdtconfig5 {
    /// Stage 3 timeout value in SWDT clock cycles
    /// Position: 0, Width: 32
    /// Access: read-write
    using WDT_STG3_HOLD = BitField<0, 32>;
    constexpr uint32_t WDT_STG3_HOLD_Pos = 0;
    constexpr uint32_t WDT_STG3_HOLD_Msk = WDT_STG3_HOLD::mask;

}  // namespace wdtconfig5

/// WDTFEED - WDTFEED
namespace wdtfeed {
    /// Write any value will feed SWDT
    /// Position: 0, Width: 32
    /// Access: write-only
    using WDT_FEED = BitField<0, 32>;
    constexpr uint32_t WDT_FEED_Pos = 0;
    constexpr uint32_t WDT_FEED_Msk = WDT_FEED::mask;

}  // namespace wdtfeed

/// WDTWPROTECT - WDTWPROTECT
namespace wdtwprotect {
    /// If change its value from default then write protection is on.
    /// Position: 0, Width: 32
    /// Access: read-write
    using WDT_WKEY = BitField<0, 32>;
    constexpr uint32_t WDT_WKEY_Pos = 0;
    constexpr uint32_t WDT_WKEY_Msk = WDT_WKEY::mask;

}  // namespace wdtwprotect

/// RTCCALICFG - RTCCALICFG
namespace rtccalicfg {
    /// Position: 12, Width: 1
    /// Access: read-write
    using RTC_CALI_START_CYCLING = BitField<12, 1>;
    constexpr uint32_t RTC_CALI_START_CYCLING_Pos = 12;
    constexpr uint32_t RTC_CALI_START_CYCLING_Msk = RTC_CALI_START_CYCLING::mask;

    /// Position: 13, Width: 2
    /// Access: read-write
    using RTC_CALI_CLK_SEL = BitField<13, 2>;
    constexpr uint32_t RTC_CALI_CLK_SEL_Pos = 13;
    constexpr uint32_t RTC_CALI_CLK_SEL_Msk = RTC_CALI_CLK_SEL::mask;

    /// Position: 15, Width: 1
    /// Access: read-only
    using RTC_CALI_RDY = BitField<15, 1>;
    constexpr uint32_t RTC_CALI_RDY_Pos = 15;
    constexpr uint32_t RTC_CALI_RDY_Msk = RTC_CALI_RDY::mask;

    /// Position: 16, Width: 15
    /// Access: read-write
    using RTC_CALI_MAX = BitField<16, 15>;
    constexpr uint32_t RTC_CALI_MAX_Pos = 16;
    constexpr uint32_t RTC_CALI_MAX_Msk = RTC_CALI_MAX::mask;

    /// Position: 31, Width: 1
    /// Access: read-write
    using RTC_CALI_START = BitField<31, 1>;
    constexpr uint32_t RTC_CALI_START_Pos = 31;
    constexpr uint32_t RTC_CALI_START_Msk = RTC_CALI_START::mask;

}  // namespace rtccalicfg

/// RTCCALICFG1 - RTCCALICFG1
namespace rtccalicfg1 {
    /// Position: 7, Width: 25
    /// Access: read-only
    using RTC_CALI_VALUE = BitField<7, 25>;
    constexpr uint32_t RTC_CALI_VALUE_Pos = 7;
    constexpr uint32_t RTC_CALI_VALUE_Msk = RTC_CALI_VALUE::mask;

}  // namespace rtccalicfg1

/// LACTCONFIG - LACTCONFIG
namespace lactconfig {
    /// Position: 7, Width: 1
    /// Access: read-write
    using LACT_RTC_ONLY = BitField<7, 1>;
    constexpr uint32_t LACT_RTC_ONLY_Pos = 7;
    constexpr uint32_t LACT_RTC_ONLY_Msk = LACT_RTC_ONLY::mask;

    /// Position: 8, Width: 1
    /// Access: read-write
    using LACT_CPST_EN = BitField<8, 1>;
    constexpr uint32_t LACT_CPST_EN_Pos = 8;
    constexpr uint32_t LACT_CPST_EN_Msk = LACT_CPST_EN::mask;

    /// Position: 9, Width: 1
    /// Access: read-write
    using LACT_LAC_EN = BitField<9, 1>;
    constexpr uint32_t LACT_LAC_EN_Pos = 9;
    constexpr uint32_t LACT_LAC_EN_Msk = LACT_LAC_EN::mask;

    /// Position: 10, Width: 1
    /// Access: read-write
    using LACT_ALARM_EN = BitField<10, 1>;
    constexpr uint32_t LACT_ALARM_EN_Pos = 10;
    constexpr uint32_t LACT_ALARM_EN_Msk = LACT_ALARM_EN::mask;

    /// Position: 11, Width: 1
    /// Access: read-write
    using LACT_LEVEL_INT_EN = BitField<11, 1>;
    constexpr uint32_t LACT_LEVEL_INT_EN_Pos = 11;
    constexpr uint32_t LACT_LEVEL_INT_EN_Msk = LACT_LEVEL_INT_EN::mask;

    /// Position: 12, Width: 1
    /// Access: read-write
    using LACT_EDGE_INT_EN = BitField<12, 1>;
    constexpr uint32_t LACT_EDGE_INT_EN_Pos = 12;
    constexpr uint32_t LACT_EDGE_INT_EN_Msk = LACT_EDGE_INT_EN::mask;

    /// Position: 13, Width: 16
    /// Access: read-write
    using LACT_DIVIDER = BitField<13, 16>;
    constexpr uint32_t LACT_DIVIDER_Pos = 13;
    constexpr uint32_t LACT_DIVIDER_Msk = LACT_DIVIDER::mask;

    /// Position: 29, Width: 1
    /// Access: read-write
    using LACT_AUTORELOAD = BitField<29, 1>;
    constexpr uint32_t LACT_AUTORELOAD_Pos = 29;
    constexpr uint32_t LACT_AUTORELOAD_Msk = LACT_AUTORELOAD::mask;

    /// Position: 30, Width: 1
    /// Access: read-write
    using LACT_INCREASE = BitField<30, 1>;
    constexpr uint32_t LACT_INCREASE_Pos = 30;
    constexpr uint32_t LACT_INCREASE_Msk = LACT_INCREASE::mask;

    /// Position: 31, Width: 1
    /// Access: read-write
    using LACT_EN = BitField<31, 1>;
    constexpr uint32_t LACT_EN_Pos = 31;
    constexpr uint32_t LACT_EN_Msk = LACT_EN::mask;

}  // namespace lactconfig

/// LACTRTC - LACTRTC
namespace lactrtc {
    /// Position: 6, Width: 26
    /// Access: read-write
    using LACT_RTC_STEP_LEN = BitField<6, 26>;
    constexpr uint32_t LACT_RTC_STEP_LEN_Pos = 6;
    constexpr uint32_t LACT_RTC_STEP_LEN_Msk = LACT_RTC_STEP_LEN::mask;

}  // namespace lactrtc

/// LACTLO - LACTLO
namespace lactlo {
    /// Position: 0, Width: 32
    /// Access: read-only
    using LACT_LO = BitField<0, 32>;
    constexpr uint32_t LACT_LO_Pos = 0;
    constexpr uint32_t LACT_LO_Msk = LACT_LO::mask;

}  // namespace lactlo

/// LACTHI - LACTHI
namespace lacthi {
    /// Position: 0, Width: 32
    /// Access: read-only
    using LACT_HI = BitField<0, 32>;
    constexpr uint32_t LACT_HI_Pos = 0;
    constexpr uint32_t LACT_HI_Msk = LACT_HI::mask;

}  // namespace lacthi

/// LACTUPDATE - LACTUPDATE
namespace lactupdate {
    /// Position: 0, Width: 32
    /// Access: write-only
    using LACT_UPDATE = BitField<0, 32>;
    constexpr uint32_t LACT_UPDATE_Pos = 0;
    constexpr uint32_t LACT_UPDATE_Msk = LACT_UPDATE::mask;

}  // namespace lactupdate

/// LACTALARMLO - LACTALARMLO
namespace lactalarmlo {
    /// Position: 0, Width: 32
    /// Access: read-write
    using LACT_ALARM_LO = BitField<0, 32>;
    constexpr uint32_t LACT_ALARM_LO_Pos = 0;
    constexpr uint32_t LACT_ALARM_LO_Msk = LACT_ALARM_LO::mask;

}  // namespace lactalarmlo

/// LACTALARMHI - LACTALARMHI
namespace lactalarmhi {
    /// Position: 0, Width: 32
    /// Access: read-write
    using LACT_ALARM_HI = BitField<0, 32>;
    constexpr uint32_t LACT_ALARM_HI_Pos = 0;
    constexpr uint32_t LACT_ALARM_HI_Msk = LACT_ALARM_HI::mask;

}  // namespace lactalarmhi

/// LACTLOADLO - LACTLOADLO
namespace lactloadlo {
    /// Position: 0, Width: 32
    /// Access: read-write
    using LACT_LOAD_LO = BitField<0, 32>;
    constexpr uint32_t LACT_LOAD_LO_Pos = 0;
    constexpr uint32_t LACT_LOAD_LO_Msk = LACT_LOAD_LO::mask;

}  // namespace lactloadlo

/// LACTLOADHI - LACTLOADHI
namespace lactloadhi {
    /// Position: 0, Width: 32
    /// Access: read-write
    using LACT_LOAD_HI = BitField<0, 32>;
    constexpr uint32_t LACT_LOAD_HI_Pos = 0;
    constexpr uint32_t LACT_LOAD_HI_Msk = LACT_LOAD_HI::mask;

}  // namespace lactloadhi

/// LACTLOAD - LACTLOAD
namespace lactload {
    /// Position: 0, Width: 32
    /// Access: write-only
    using LACT_LOAD = BitField<0, 32>;
    constexpr uint32_t LACT_LOAD_Pos = 0;
    constexpr uint32_t LACT_LOAD_Msk = LACT_LOAD::mask;

}  // namespace lactload

/// INT_ENA_TIMERS - INT_ENA_TIMERS
namespace int_ena_timers {
    /// interrupt when timer0 alarm
    /// Position: 0, Width: 1
    /// Access: read-write
    using T0_INT_ENA = BitField<0, 1>;
    constexpr uint32_t T0_INT_ENA_Pos = 0;
    constexpr uint32_t T0_INT_ENA_Msk = T0_INT_ENA::mask;

    /// interrupt when timer1 alarm
    /// Position: 1, Width: 1
    /// Access: read-write
    using T1_INT_ENA = BitField<1, 1>;
    constexpr uint32_t T1_INT_ENA_Pos = 1;
    constexpr uint32_t T1_INT_ENA_Msk = T1_INT_ENA::mask;

    /// Interrupt when an interrupt stage timeout
    /// Position: 2, Width: 1
    /// Access: read-write
    using WDT_INT_ENA = BitField<2, 1>;
    constexpr uint32_t WDT_INT_ENA_Pos = 2;
    constexpr uint32_t WDT_INT_ENA_Msk = WDT_INT_ENA::mask;

    /// Position: 3, Width: 1
    /// Access: read-write
    using LACT_INT_ENA = BitField<3, 1>;
    constexpr uint32_t LACT_INT_ENA_Pos = 3;
    constexpr uint32_t LACT_INT_ENA_Msk = LACT_INT_ENA::mask;

}  // namespace int_ena_timers

/// INT_RAW_TIMERS - INT_RAW_TIMERS
namespace int_raw_timers {
    /// interrupt when timer0 alarm
    /// Position: 0, Width: 1
    /// Access: read-only
    using T0_INT_RAW = BitField<0, 1>;
    constexpr uint32_t T0_INT_RAW_Pos = 0;
    constexpr uint32_t T0_INT_RAW_Msk = T0_INT_RAW::mask;

    /// interrupt when timer1 alarm
    /// Position: 1, Width: 1
    /// Access: read-only
    using T1_INT_RAW = BitField<1, 1>;
    constexpr uint32_t T1_INT_RAW_Pos = 1;
    constexpr uint32_t T1_INT_RAW_Msk = T1_INT_RAW::mask;

    /// Interrupt when an interrupt stage timeout
    /// Position: 2, Width: 1
    /// Access: read-only
    using WDT_INT_RAW = BitField<2, 1>;
    constexpr uint32_t WDT_INT_RAW_Pos = 2;
    constexpr uint32_t WDT_INT_RAW_Msk = WDT_INT_RAW::mask;

    /// Position: 3, Width: 1
    /// Access: read-only
    using LACT_INT_RAW = BitField<3, 1>;
    constexpr uint32_t LACT_INT_RAW_Pos = 3;
    constexpr uint32_t LACT_INT_RAW_Msk = LACT_INT_RAW::mask;

}  // namespace int_raw_timers

/// INT_ST_TIMERS - INT_ST_TIMERS
namespace int_st_timers {
    /// interrupt when timer0 alarm
    /// Position: 0, Width: 1
    /// Access: read-only
    using T0_INT_ST = BitField<0, 1>;
    constexpr uint32_t T0_INT_ST_Pos = 0;
    constexpr uint32_t T0_INT_ST_Msk = T0_INT_ST::mask;

    /// interrupt when timer1 alarm
    /// Position: 1, Width: 1
    /// Access: read-only
    using T1_INT_ST = BitField<1, 1>;
    constexpr uint32_t T1_INT_ST_Pos = 1;
    constexpr uint32_t T1_INT_ST_Msk = T1_INT_ST::mask;

    /// Interrupt when an interrupt stage timeout
    /// Position: 2, Width: 1
    /// Access: read-only
    using WDT_INT_ST = BitField<2, 1>;
    constexpr uint32_t WDT_INT_ST_Pos = 2;
    constexpr uint32_t WDT_INT_ST_Msk = WDT_INT_ST::mask;

    /// Position: 3, Width: 1
    /// Access: read-only
    using LACT_INT_ST = BitField<3, 1>;
    constexpr uint32_t LACT_INT_ST_Pos = 3;
    constexpr uint32_t LACT_INT_ST_Msk = LACT_INT_ST::mask;

}  // namespace int_st_timers

/// INT_CLR_TIMERS - INT_CLR_TIMERS
namespace int_clr_timers {
    /// interrupt when timer0 alarm
    /// Position: 0, Width: 1
    /// Access: write-only
    using T0_INT_CLR = BitField<0, 1>;
    constexpr uint32_t T0_INT_CLR_Pos = 0;
    constexpr uint32_t T0_INT_CLR_Msk = T0_INT_CLR::mask;

    /// interrupt when timer1 alarm
    /// Position: 1, Width: 1
    /// Access: write-only
    using T1_INT_CLR = BitField<1, 1>;
    constexpr uint32_t T1_INT_CLR_Pos = 1;
    constexpr uint32_t T1_INT_CLR_Msk = T1_INT_CLR::mask;

    /// Interrupt when an interrupt stage timeout
    /// Position: 2, Width: 1
    /// Access: write-only
    using WDT_INT_CLR = BitField<2, 1>;
    constexpr uint32_t WDT_INT_CLR_Pos = 2;
    constexpr uint32_t WDT_INT_CLR_Msk = WDT_INT_CLR::mask;

    /// Position: 3, Width: 1
    /// Access: write-only
    using LACT_INT_CLR = BitField<3, 1>;
    constexpr uint32_t LACT_INT_CLR_Pos = 3;
    constexpr uint32_t LACT_INT_CLR_Msk = LACT_INT_CLR::mask;

}  // namespace int_clr_timers

/// NTIMERS_DATE - NTIMERS_DATE
namespace ntimers_date {
    /// Version of this regfile
    /// Position: 0, Width: 28
    /// Access: read-write
    using NTIMERS_DATE = BitField<0, 28>;
    constexpr uint32_t NTIMERS_DATE_Pos = 0;
    constexpr uint32_t NTIMERS_DATE_Msk = NTIMERS_DATE::mask;

}  // namespace ntimers_date

/// TIMGCLK - TIMGCLK
namespace timgclk {
    /// Force clock enable for this regfile
    /// Position: 31, Width: 1
    /// Access: read-write
    using CLK_EN = BitField<31, 1>;
    constexpr uint32_t CLK_EN_Pos = 31;
    constexpr uint32_t CLK_EN_Msk = CLK_EN::mask;

}  // namespace timgclk

}  // namespace alloy::hal::espressif::esp32::timg0
