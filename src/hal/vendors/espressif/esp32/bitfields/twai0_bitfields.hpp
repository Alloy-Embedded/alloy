/// Auto-generated bit field definitions for TWAI0
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

#include "hal/utils/bitfield.hpp"

namespace alloy::hal::espressif::esp32::twai0 {

using namespace alloy::hal::bitfields;

// ============================================================================
// TWAI0 Bit Field Definitions
// ============================================================================

/// MODE - Mode Register
namespace mode {
/// This bit is used to configure the operating mode of the TWAI Controller. 1: Reset mode; 0:
/// Operating mode. Position: 0, Width: 1 Access: read-write
using RESET_MODE = BitField<0, 1>;
constexpr uint32_t RESET_MODE_Pos = 0;
constexpr uint32_t RESET_MODE_Msk = RESET_MODE::mask;

/// 1: Listen only mode. In this mode the nodes will only receive messages from the bus, without
/// generating the acknowledge signal nor updating the RX error counter. Position: 1, Width: 1
/// Access: read-write
using LISTEN_ONLY_MODE = BitField<1, 1>;
constexpr uint32_t LISTEN_ONLY_MODE_Pos = 1;
constexpr uint32_t LISTEN_ONLY_MODE_Msk = LISTEN_ONLY_MODE::mask;

/// 1: Self test mode. In this mode the TX nodes can perform a successful transmission without
/// receiving the acknowledge signal. This mode is often used to test a single node with the self
/// reception request command. Position: 2, Width: 1 Access: read-write
using SELF_TEST_MODE = BitField<2, 1>;
constexpr uint32_t SELF_TEST_MODE_Pos = 2;
constexpr uint32_t SELF_TEST_MODE_Msk = SELF_TEST_MODE::mask;

/// This bit is used to configure the filter mode. 0: Dual filter mode; 1: Single filter mode.
/// Position: 3, Width: 1
/// Access: read-write
using RX_FILTER_MODE = BitField<3, 1>;
constexpr uint32_t RX_FILTER_MODE_Pos = 3;
constexpr uint32_t RX_FILTER_MODE_Msk = RX_FILTER_MODE::mask;

}  // namespace mode

/// CMD - Command Register
namespace cmd {
/// Set the bit to 1 to allow the driving nodes start transmission.
/// Position: 0, Width: 1
/// Access: write-only
using TX_REQ = BitField<0, 1>;
constexpr uint32_t TX_REQ_Pos = 0;
constexpr uint32_t TX_REQ_Msk = TX_REQ::mask;

/// Set the bit to 1 to cancel a pending transmission request.
/// Position: 1, Width: 1
/// Access: write-only
using ABORT_TX = BitField<1, 1>;
constexpr uint32_t ABORT_TX_Pos = 1;
constexpr uint32_t ABORT_TX_Msk = ABORT_TX::mask;

/// Set the bit to 1 to release the RX buffer.
/// Position: 2, Width: 1
/// Access: write-only
using RELEASE_BUF = BitField<2, 1>;
constexpr uint32_t RELEASE_BUF_Pos = 2;
constexpr uint32_t RELEASE_BUF_Msk = RELEASE_BUF::mask;

/// Set the bit to 1 to clear the data overrun status bit.
/// Position: 3, Width: 1
/// Access: write-only
using CLR_OVERRUN = BitField<3, 1>;
constexpr uint32_t CLR_OVERRUN_Pos = 3;
constexpr uint32_t CLR_OVERRUN_Msk = CLR_OVERRUN::mask;

/// Self reception request command. Set the bit to 1 to allow a message be transmitted and received
/// simultaneously. Position: 4, Width: 1 Access: write-only
using SELF_RX_REQ = BitField<4, 1>;
constexpr uint32_t SELF_RX_REQ_Pos = 4;
constexpr uint32_t SELF_RX_REQ_Msk = SELF_RX_REQ::mask;

}  // namespace cmd

/// STATUS - Status register
namespace status {
/// 1: The data in the RX buffer is not empty, with at least one received data packet.
/// Position: 0, Width: 1
/// Access: read-only
using RX_BUF_ST = BitField<0, 1>;
constexpr uint32_t RX_BUF_ST_Pos = 0;
constexpr uint32_t RX_BUF_ST_Msk = RX_BUF_ST::mask;

/// 1: The RX FIFO is full and data overrun has occurred.
/// Position: 1, Width: 1
/// Access: read-only
using OVERRUN_ST = BitField<1, 1>;
constexpr uint32_t OVERRUN_ST_Pos = 1;
constexpr uint32_t OVERRUN_ST_Msk = OVERRUN_ST::mask;

/// 1: The TX buffer is empty, the CPU may write a message into it.
/// Position: 2, Width: 1
/// Access: read-only
using TX_BUF_ST = BitField<2, 1>;
constexpr uint32_t TX_BUF_ST_Pos = 2;
constexpr uint32_t TX_BUF_ST_Msk = TX_BUF_ST::mask;

/// 1: The TWAI controller has successfully received a packet from the bus.
/// Position: 3, Width: 1
/// Access: read-only
using TX_COMPLETE = BitField<3, 1>;
constexpr uint32_t TX_COMPLETE_Pos = 3;
constexpr uint32_t TX_COMPLETE_Msk = TX_COMPLETE::mask;

/// 1: The TWAI Controller is receiving a message from the bus.
/// Position: 4, Width: 1
/// Access: read-only
using RX_ST = BitField<4, 1>;
constexpr uint32_t RX_ST_Pos = 4;
constexpr uint32_t RX_ST_Msk = RX_ST::mask;

/// 1: The TWAI Controller is transmitting a message to the bus.
/// Position: 5, Width: 1
/// Access: read-only
using TX_ST = BitField<5, 1>;
constexpr uint32_t TX_ST_Pos = 5;
constexpr uint32_t TX_ST_Msk = TX_ST::mask;

/// 1: At least one of the RX/TX error counter has reached or exceeded the value set in register
/// TWAI_ERR_WARNING_LIMIT_REG. Position: 6, Width: 1 Access: read-only
using ERR_ST = BitField<6, 1>;
constexpr uint32_t ERR_ST_Pos = 6;
constexpr uint32_t ERR_ST_Msk = ERR_ST::mask;

/// 1: In bus-off status, the TWAI Controller is no longer involved in bus activities.
/// Position: 7, Width: 1
/// Access: read-only
using BUS_OFF_ST = BitField<7, 1>;
constexpr uint32_t BUS_OFF_ST_Pos = 7;
constexpr uint32_t BUS_OFF_ST_Msk = BUS_OFF_ST::mask;

/// This bit reflects whether the data packet in the RX FIFO is complete. 1: The current packet is
/// missing; 0: The current packet is complete Position: 8, Width: 1 Access: read-only
using MISS_ST = BitField<8, 1>;
constexpr uint32_t MISS_ST_Pos = 8;
constexpr uint32_t MISS_ST_Msk = MISS_ST::mask;

}  // namespace status

/// INT_RAW - Interrupt Register
namespace int_raw {
/// Receive interrupt. If this bit is set to 1, it indicates there are messages to be handled in the
/// RX FIFO. Position: 0, Width: 1 Access: read-only
using RX_INT_ST = BitField<0, 1>;
constexpr uint32_t RX_INT_ST_Pos = 0;
constexpr uint32_t RX_INT_ST_Msk = RX_INT_ST::mask;

/// Transmit interrupt. If this bit is set to 1, it indicates the message transmitting mis- sion is
/// finished and a new transmission is able to execute. Position: 1, Width: 1 Access: read-only
using TX_INT_ST = BitField<1, 1>;
constexpr uint32_t TX_INT_ST_Pos = 1;
constexpr uint32_t TX_INT_ST_Msk = TX_INT_ST::mask;

/// Error warning interrupt. If this bit is set to 1, it indicates the error status signal and the
/// bus-off status signal of Status register have changed (e.g., switched from 0 to 1 or from 1 to
/// 0). Position: 2, Width: 1 Access: read-only
using ERR_WARN_INT_ST = BitField<2, 1>;
constexpr uint32_t ERR_WARN_INT_ST_Pos = 2;
constexpr uint32_t ERR_WARN_INT_ST_Msk = ERR_WARN_INT_ST::mask;

/// Data overrun interrupt. If this bit is set to 1, it indicates a data overrun interrupt is
/// generated in the RX FIFO. Position: 3, Width: 1 Access: read-only
using OVERRUN_INT_ST = BitField<3, 1>;
constexpr uint32_t OVERRUN_INT_ST_Pos = 3;
constexpr uint32_t OVERRUN_INT_ST_Msk = OVERRUN_INT_ST::mask;

/// Error passive interrupt. If this bit is set to 1, it indicates the TWAI Controller is switched
/// between error active status and error passive status due to the change of error counters.
/// Position: 5, Width: 1
/// Access: read-only
using ERR_PASSIVE_INT_ST = BitField<5, 1>;
constexpr uint32_t ERR_PASSIVE_INT_ST_Pos = 5;
constexpr uint32_t ERR_PASSIVE_INT_ST_Msk = ERR_PASSIVE_INT_ST::mask;

/// Arbitration lost interrupt. If this bit is set to 1, it indicates an arbitration lost interrupt
/// is generated. Position: 6, Width: 1 Access: read-only
using ARB_LOST_INT_ST = BitField<6, 1>;
constexpr uint32_t ARB_LOST_INT_ST_Pos = 6;
constexpr uint32_t ARB_LOST_INT_ST_Msk = ARB_LOST_INT_ST::mask;

/// Error interrupt. If this bit is set to 1, it indicates an error is detected on the bus.
/// Position: 7, Width: 1
/// Access: read-only
using BUS_ERR_INT_ST = BitField<7, 1>;
constexpr uint32_t BUS_ERR_INT_ST_Pos = 7;
constexpr uint32_t BUS_ERR_INT_ST_Msk = BUS_ERR_INT_ST::mask;

}  // namespace int_raw

/// INT_ENA - Interrupt Enable Register
namespace int_ena {
/// Set this bit to 1 to enable receive interrupt.
/// Position: 0, Width: 1
/// Access: read-write
using RX_INT_ENA = BitField<0, 1>;
constexpr uint32_t RX_INT_ENA_Pos = 0;
constexpr uint32_t RX_INT_ENA_Msk = RX_INT_ENA::mask;

/// Set this bit to 1 to enable transmit interrupt.
/// Position: 1, Width: 1
/// Access: read-write
using TX_INT_ENA = BitField<1, 1>;
constexpr uint32_t TX_INT_ENA_Pos = 1;
constexpr uint32_t TX_INT_ENA_Msk = TX_INT_ENA::mask;

/// Set this bit to 1 to enable error warning interrupt.
/// Position: 2, Width: 1
/// Access: read-write
using ERR_WARN_INT_ENA = BitField<2, 1>;
constexpr uint32_t ERR_WARN_INT_ENA_Pos = 2;
constexpr uint32_t ERR_WARN_INT_ENA_Msk = ERR_WARN_INT_ENA::mask;

/// Set this bit to 1 to enable data overrun interrupt.
/// Position: 3, Width: 1
/// Access: read-write
using OVERRUN_INT_ENA = BitField<3, 1>;
constexpr uint32_t OVERRUN_INT_ENA_Pos = 3;
constexpr uint32_t OVERRUN_INT_ENA_Msk = OVERRUN_INT_ENA::mask;

/// Set this bit to 1 to enable error passive interrupt.
/// Position: 5, Width: 1
/// Access: read-write
using ERR_PASSIVE_INT_ENA = BitField<5, 1>;
constexpr uint32_t ERR_PASSIVE_INT_ENA_Pos = 5;
constexpr uint32_t ERR_PASSIVE_INT_ENA_Msk = ERR_PASSIVE_INT_ENA::mask;

/// Set this bit to 1 to enable arbitration lost interrupt.
/// Position: 6, Width: 1
/// Access: read-write
using ARB_LOST_INT_ENA = BitField<6, 1>;
constexpr uint32_t ARB_LOST_INT_ENA_Pos = 6;
constexpr uint32_t ARB_LOST_INT_ENA_Msk = ARB_LOST_INT_ENA::mask;

/// Set this bit to 1 to enable error interrupt.
/// Position: 7, Width: 1
/// Access: read-write
using BUS_ERR_INT_ENA = BitField<7, 1>;
constexpr uint32_t BUS_ERR_INT_ENA_Pos = 7;
constexpr uint32_t BUS_ERR_INT_ENA_Msk = BUS_ERR_INT_ENA::mask;

}  // namespace int_ena

/// BUS_TIMING_0 - Bus Timing Register 0
namespace bus_timing_0 {
/// Baud Rate Prescaler, determines the frequency dividing ratio.
/// Position: 0, Width: 6
/// Access: read-write
using BAUD_PRESC = BitField<0, 6>;
constexpr uint32_t BAUD_PRESC_Pos = 0;
constexpr uint32_t BAUD_PRESC_Msk = BAUD_PRESC::mask;

/// Synchronization Jump Width (SJW), 1 \verb+~+ 14 Tq wide.
/// Position: 6, Width: 2
/// Access: read-write
using SYNC_JUMP_WIDTH = BitField<6, 2>;
constexpr uint32_t SYNC_JUMP_WIDTH_Pos = 6;
constexpr uint32_t SYNC_JUMP_WIDTH_Msk = SYNC_JUMP_WIDTH::mask;

}  // namespace bus_timing_0

/// BUS_TIMING_1 - Bus Timing Register 1
namespace bus_timing_1 {
/// The width of PBS1.
/// Position: 0, Width: 4
/// Access: read-write
using TIME_SEG1 = BitField<0, 4>;
constexpr uint32_t TIME_SEG1_Pos = 0;
constexpr uint32_t TIME_SEG1_Msk = TIME_SEG1::mask;

/// The width of PBS2.
/// Position: 4, Width: 3
/// Access: read-write
using TIME_SEG2 = BitField<4, 3>;
constexpr uint32_t TIME_SEG2_Pos = 4;
constexpr uint32_t TIME_SEG2_Msk = TIME_SEG2::mask;

/// The number of sample points. 0: the bus is sampled once; 1: the bus is sampled three times
/// Position: 7, Width: 1
/// Access: read-write
using TIME_SAMP = BitField<7, 1>;
constexpr uint32_t TIME_SAMP_Pos = 7;
constexpr uint32_t TIME_SAMP_Msk = TIME_SAMP::mask;

}  // namespace bus_timing_1

/// ARB_LOST_CAP - Arbitration Lost Capture Register
namespace arb_lost_cap {
/// This register contains information about the bit position of lost arbitration.
/// Position: 0, Width: 5
/// Access: read-only
using ARB_LOST_CAP = BitField<0, 5>;
constexpr uint32_t ARB_LOST_CAP_Pos = 0;
constexpr uint32_t ARB_LOST_CAP_Msk = ARB_LOST_CAP::mask;

}  // namespace arb_lost_cap

/// ERR_CODE_CAP - Error Code Capture Register
namespace err_code_cap {
/// This register contains information about the location of errors, see Table 181 for details.
/// Position: 0, Width: 5
/// Access: read-only
using ECC_SEGMENT = BitField<0, 5>;
constexpr uint32_t ECC_SEGMENT_Pos = 0;
constexpr uint32_t ECC_SEGMENT_Msk = ECC_SEGMENT::mask;

/// This register contains information about transmission direction of the node when error occurs.
/// 1: Error occurs when receiving a message; 0: Error occurs when transmitting a message Position:
/// 5, Width: 1 Access: read-only
using ECC_DIRECTION = BitField<5, 1>;
constexpr uint32_t ECC_DIRECTION_Pos = 5;
constexpr uint32_t ECC_DIRECTION_Msk = ECC_DIRECTION::mask;

/// This register contains information about error types: 00: bit error; 01: form error; 10: stuff
/// error; 11: other type of error Position: 6, Width: 2 Access: read-only
using ECC_TYPE = BitField<6, 2>;
constexpr uint32_t ECC_TYPE_Pos = 6;
constexpr uint32_t ECC_TYPE_Msk = ECC_TYPE::mask;

}  // namespace err_code_cap

/// ERR_WARNING_LIMIT - Error Warning Limit Register
namespace err_warning_limit {
/// Error warning threshold. In the case when any of a error counter value exceeds the threshold, or
/// all the error counter values are below the threshold, an error warning interrupt will be
/// triggered (given the enable signal is valid). Position: 0, Width: 8 Access: read-write
using ERR_WARNING_LIMIT = BitField<0, 8>;
constexpr uint32_t ERR_WARNING_LIMIT_Pos = 0;
constexpr uint32_t ERR_WARNING_LIMIT_Msk = ERR_WARNING_LIMIT::mask;

}  // namespace err_warning_limit

/// RX_ERR_CNT - Receive Error Counter Register
namespace rx_err_cnt {
/// The RX error counter register, reflects value changes under reception status.
/// Position: 0, Width: 8
/// Access: read-write
using RX_ERR_CNT = BitField<0, 8>;
constexpr uint32_t RX_ERR_CNT_Pos = 0;
constexpr uint32_t RX_ERR_CNT_Msk = RX_ERR_CNT::mask;

}  // namespace rx_err_cnt

/// TX_ERR_CNT - Transmit Error Counter Register
namespace tx_err_cnt {
/// The TX error counter register, reflects value changes under transmission status.
/// Position: 0, Width: 8
/// Access: read-write
using TX_ERR_CNT = BitField<0, 8>;
constexpr uint32_t TX_ERR_CNT_Pos = 0;
constexpr uint32_t TX_ERR_CNT_Msk = TX_ERR_CNT::mask;

}  // namespace tx_err_cnt

/// DATA_0 - Data register 0
namespace data_0 {
/// In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, it
/// stores the 0th byte information of the data to be transmitted under operating mode. Position: 0,
/// Width: 8 Access: read-write
using TX_BYTE_0 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_0_Pos = 0;
constexpr uint32_t TX_BYTE_0_Msk = TX_BYTE_0::mask;

}  // namespace data_0

/// DATA_1 - Data register 1
namespace data_1 {
/// In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, it
/// stores the 1st byte information of the data to be transmitted under operating mode. Position: 0,
/// Width: 8 Access: read-write
using TX_BYTE_1 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_1_Pos = 0;
constexpr uint32_t TX_BYTE_1_Msk = TX_BYTE_1::mask;

}  // namespace data_1

/// DATA_2 - Data register 2
namespace data_2 {
/// In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, it
/// stores the 2nd byte information of the data to be transmitted under operating mode. Position: 0,
/// Width: 8 Access: read-write
using TX_BYTE_2 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_2_Pos = 0;
constexpr uint32_t TX_BYTE_2_Msk = TX_BYTE_2::mask;

}  // namespace data_2

/// DATA_3 - Data register 3
namespace data_3 {
/// In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, it
/// stores the 3rd byte information of the data to be transmitted under operating mode. Position: 0,
/// Width: 8 Access: read-write
using TX_BYTE_3 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_3_Pos = 0;
constexpr uint32_t TX_BYTE_3_Msk = TX_BYTE_3::mask;

}  // namespace data_3

/// DATA_4 - Data register 4
namespace data_4 {
/// In reset mode, it is acceptance mask register 0 with R/W Permission. In operation mode, it
/// stores the 4th byte information of the data to be transmitted under operating mode. Position: 0,
/// Width: 8 Access: read-write
using TX_BYTE_4 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_4_Pos = 0;
constexpr uint32_t TX_BYTE_4_Msk = TX_BYTE_4::mask;

}  // namespace data_4

/// DATA_5 - Data register 5
namespace data_5 {
/// In reset mode, it is acceptance mask register 1 with R/W Permission. In operation mode, it
/// stores the 5th byte information of the data to be transmitted under operating mode. Position: 0,
/// Width: 8 Access: read-write
using TX_BYTE_5 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_5_Pos = 0;
constexpr uint32_t TX_BYTE_5_Msk = TX_BYTE_5::mask;

}  // namespace data_5

/// DATA_6 - Data register 6
namespace data_6 {
/// In reset mode, it is acceptance mask register 2 with R/W Permission. In operation mode, it
/// stores the 6th byte information of the data to be transmitted under operating mode. Position: 0,
/// Width: 8 Access: read-write
using TX_BYTE_6 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_6_Pos = 0;
constexpr uint32_t TX_BYTE_6_Msk = TX_BYTE_6::mask;

}  // namespace data_6

/// DATA_7 - Data register 7
namespace data_7 {
/// In reset mode, it is acceptance mask register 3 with R/W Permission. In operation mode, it
/// stores the 7th byte information of the data to be transmitted under operating mode. Position: 0,
/// Width: 8 Access: read-write
using TX_BYTE_7 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_7_Pos = 0;
constexpr uint32_t TX_BYTE_7_Msk = TX_BYTE_7::mask;

}  // namespace data_7

/// DATA_8 - Data register 8
namespace data_8 {
/// Stored the 8th byte information of the data to be transmitted under operating mode.
/// Position: 0, Width: 8
/// Access: read-write
using TX_BYTE_8 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_8_Pos = 0;
constexpr uint32_t TX_BYTE_8_Msk = TX_BYTE_8::mask;

}  // namespace data_8

/// DATA_9 - Data register 9
namespace data_9 {
/// Stored the 9th byte information of the data to be transmitted under operating mode.
/// Position: 0, Width: 8
/// Access: read-write
using TX_BYTE_9 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_9_Pos = 0;
constexpr uint32_t TX_BYTE_9_Msk = TX_BYTE_9::mask;

}  // namespace data_9

/// DATA_10 - Data register 10
namespace data_10 {
/// Stored the 10th byte information of the data to be transmitted under operating mode.
/// Position: 0, Width: 8
/// Access: read-write
using TX_BYTE_10 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_10_Pos = 0;
constexpr uint32_t TX_BYTE_10_Msk = TX_BYTE_10::mask;

}  // namespace data_10

/// DATA_11 - Data register 11
namespace data_11 {
/// Stored the 11th byte information of the data to be transmitted under operating mode.
/// Position: 0, Width: 8
/// Access: read-write
using TX_BYTE_11 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_11_Pos = 0;
constexpr uint32_t TX_BYTE_11_Msk = TX_BYTE_11::mask;

}  // namespace data_11

/// DATA_12 - Data register 12
namespace data_12 {
/// Stored the 12th byte information of the data to be transmitted under operating mode.
/// Position: 0, Width: 8
/// Access: read-write
using TX_BYTE_12 = BitField<0, 8>;
constexpr uint32_t TX_BYTE_12_Pos = 0;
constexpr uint32_t TX_BYTE_12_Msk = TX_BYTE_12::mask;

}  // namespace data_12

/// RX_MESSAGE_CNT - Receive Message Counter Register
namespace rx_message_cnt {
/// This register reflects the number of messages available within the RX FIFO.
/// Position: 0, Width: 7
/// Access: read-only
using RX_MESSAGE_COUNTER = BitField<0, 7>;
constexpr uint32_t RX_MESSAGE_COUNTER_Pos = 0;
constexpr uint32_t RX_MESSAGE_COUNTER_Msk = RX_MESSAGE_COUNTER::mask;

}  // namespace rx_message_cnt

/// CLOCK_DIVIDER - Clock Divider register
namespace clock_divider {
/// These bits are used to configure frequency dividing coefficients of the external CLKOUT pin.
/// Position: 0, Width: 8
/// Access: read-write
using CD = BitField<0, 8>;
constexpr uint32_t CD_Pos = 0;
constexpr uint32_t CD_Msk = CD::mask;

/// This bit can be configured under reset mode. 1: Disable the external CLKOUT pin; 0: Enable the
/// external CLKOUT pin Position: 8, Width: 1 Access: read-write
using CLOCK_OFF = BitField<8, 1>;
constexpr uint32_t CLOCK_OFF_Pos = 8;
constexpr uint32_t CLOCK_OFF_Msk = CLOCK_OFF::mask;

}  // namespace clock_divider

}  // namespace alloy::hal::espressif::esp32::twai0
