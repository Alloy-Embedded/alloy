/// Auto-generated bit field definitions for I2C0
/// Device: ESP32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::espressif::esp32::esp32::i2c0 {

using namespace alloy::hal::bitfields;

// ============================================================================
// I2C0 Bit Field Definitions
// ============================================================================

/// SCL_LOW_PERIOD - SCL_LOW_PERIOD
namespace scl_low_period {
    /// This register is used to configure the  low level width of SCL clock.
    /// Position: 0, Width: 14
    /// Access: read-write
    using SCL_LOW_PERIOD = BitField<0, 14>;
    constexpr uint32_t SCL_LOW_PERIOD_Pos = 0;
    constexpr uint32_t SCL_LOW_PERIOD_Msk = SCL_LOW_PERIOD::mask;

}  // namespace scl_low_period

/// CTR - CTR
namespace ctr {
    /// 1: normally ouput sda data   0: exchange the function of sda_o and sda_oe (sda_o is the original internal output sda signal sda_oe is the enable bit for the internal output sda signal)
    /// Position: 0, Width: 1
    /// Access: read-write
    using SDA_FORCE_OUT = BitField<0, 1>;
    constexpr uint32_t SDA_FORCE_OUT_Pos = 0;
    constexpr uint32_t SDA_FORCE_OUT_Msk = SDA_FORCE_OUT::mask;

    /// 1: normally ouput scl clock  0: exchange the function of scl_o and scl_oe (scl_o is the original internal output scl signal  scl_oe is the enable bit for the internal output scl signal)
    /// Position: 1, Width: 1
    /// Access: read-write
    using SCL_FORCE_OUT = BitField<1, 1>;
    constexpr uint32_t SCL_FORCE_OUT_Pos = 1;
    constexpr uint32_t SCL_FORCE_OUT_Msk = SCL_FORCE_OUT::mask;

    /// Set this bit to sample data in SCL low level. clear this bit to sample data in SCL high level.
    /// Position: 2, Width: 1
    /// Access: read-write
    using SAMPLE_SCL_LEVEL = BitField<2, 1>;
    constexpr uint32_t SAMPLE_SCL_LEVEL_Pos = 2;
    constexpr uint32_t SAMPLE_SCL_LEVEL_Msk = SAMPLE_SCL_LEVEL::mask;

    /// Set this bit to configure the module as i2c master  clear this bit to configure the module as i2c slave.
    /// Position: 4, Width: 1
    /// Access: read-write
    using MS_MODE = BitField<4, 1>;
    constexpr uint32_t MS_MODE_Pos = 4;
    constexpr uint32_t MS_MODE_Msk = MS_MODE::mask;

    /// Set this bit to start sending data in txfifo.
    /// Position: 5, Width: 1
    /// Access: read-write
    using TRANS_START = BitField<5, 1>;
    constexpr uint32_t TRANS_START_Pos = 5;
    constexpr uint32_t TRANS_START_Msk = TRANS_START::mask;

    /// This bit is used to control the sending mode for  data need to be send. 1: receive data from most significant bit    0: receive data from least significant bit
    /// Position: 6, Width: 1
    /// Access: read-write
    using TX_LSB_FIRST = BitField<6, 1>;
    constexpr uint32_t TX_LSB_FIRST_Pos = 6;
    constexpr uint32_t TX_LSB_FIRST_Msk = TX_LSB_FIRST::mask;

    /// This bit is used to control the storage mode for received datas. 1: receive data from most significant bit    0: receive data from least significant bit
    /// Position: 7, Width: 1
    /// Access: read-write
    using RX_LSB_FIRST = BitField<7, 1>;
    constexpr uint32_t RX_LSB_FIRST_Pos = 7;
    constexpr uint32_t RX_LSB_FIRST_Msk = RX_LSB_FIRST::mask;

    /// This is the clock gating control bit for reading or writing registers.
    /// Position: 8, Width: 1
    /// Access: read-write
    using CLK_EN = BitField<8, 1>;
    constexpr uint32_t CLK_EN_Pos = 8;
    constexpr uint32_t CLK_EN_Msk = CLK_EN::mask;

}  // namespace ctr

/// SR - SR
namespace sr {
    /// This register stores the value of ACK bit.
    /// Position: 0, Width: 1
    /// Access: read-only
    using ACK_REC = BitField<0, 1>;
    constexpr uint32_t ACK_REC_Pos = 0;
    constexpr uint32_t ACK_REC_Msk = ACK_REC::mask;

    /// when in slave mode  1: master read slave  0: master write slave.
    /// Position: 1, Width: 1
    /// Access: read-only
    using SLAVE_RW = BitField<1, 1>;
    constexpr uint32_t SLAVE_RW_Pos = 1;
    constexpr uint32_t SLAVE_RW_Msk = SLAVE_RW::mask;

    /// when I2C takes more than time_out_reg clocks to receive a data then this register changes to high level.
    /// Position: 2, Width: 1
    /// Access: read-only
    using TIME_OUT = BitField<2, 1>;
    constexpr uint32_t TIME_OUT_Pos = 2;
    constexpr uint32_t TIME_OUT_Msk = TIME_OUT::mask;

    /// when I2C lost control of SDA line  this register changes to high level.
    /// Position: 3, Width: 1
    /// Access: read-only
    using ARB_LOST = BitField<3, 1>;
    constexpr uint32_t ARB_LOST_Pos = 3;
    constexpr uint32_t ARB_LOST_Msk = ARB_LOST::mask;

    /// 1:I2C bus is busy transferring data. 0:I2C bus is in idle state.
    /// Position: 4, Width: 1
    /// Access: read-only
    using BUS_BUSY = BitField<4, 1>;
    constexpr uint32_t BUS_BUSY_Pos = 4;
    constexpr uint32_t BUS_BUSY_Msk = BUS_BUSY::mask;

    /// when configured as i2c slave  and the address send by master is equal to slave's address  then this bit will be high level.
    /// Position: 5, Width: 1
    /// Access: read-only
    using SLAVE_ADDRESSED = BitField<5, 1>;
    constexpr uint32_t SLAVE_ADDRESSED_Pos = 5;
    constexpr uint32_t SLAVE_ADDRESSED_Msk = SLAVE_ADDRESSED::mask;

    /// This register changes to high level when one byte is transferred.
    /// Position: 6, Width: 1
    /// Access: read-only
    using BYTE_TRANS = BitField<6, 1>;
    constexpr uint32_t BYTE_TRANS_Pos = 6;
    constexpr uint32_t BYTE_TRANS_Msk = BYTE_TRANS::mask;

    /// This register represent the amount of data need to send.
    /// Position: 8, Width: 6
    /// Access: read-only
    using RXFIFO_CNT = BitField<8, 6>;
    constexpr uint32_t RXFIFO_CNT_Pos = 8;
    constexpr uint32_t RXFIFO_CNT_Msk = RXFIFO_CNT::mask;

    /// This register stores the amount of received data  in ram.
    /// Position: 18, Width: 6
    /// Access: read-only
    using TXFIFO_CNT = BitField<18, 6>;
    constexpr uint32_t TXFIFO_CNT_Pos = 18;
    constexpr uint32_t TXFIFO_CNT_Msk = TXFIFO_CNT::mask;

    /// This register stores the value of state machine for i2c module.  3'h0: SCL_MAIN_IDLE  3'h1: SCL_ADDRESS_SHIFT 3'h2: SCL_ACK_ADDRESS  3'h3: SCL_RX_DATA  3'h4 SCL_TX_DATA  3'h5:SCL_SEND_ACK 3'h6:SCL_WAIT_ACK
    /// Position: 24, Width: 3
    /// Access: read-only
    using SCL_MAIN_STATE_LAST = BitField<24, 3>;
    constexpr uint32_t SCL_MAIN_STATE_LAST_Pos = 24;
    constexpr uint32_t SCL_MAIN_STATE_LAST_Msk = SCL_MAIN_STATE_LAST::mask;

    /// This register stores the value of state machine to produce SCL. 3'h0: SCL_IDLE  3'h1:SCL_START   3'h2:SCL_LOW_EDGE  3'h3: SCL_LOW   3'h4:SCL_HIGH_EDGE   3'h5:SCL_HIGH  3'h6:SCL_STOP
    /// Position: 28, Width: 3
    /// Access: read-only
    using SCL_STATE_LAST = BitField<28, 3>;
    constexpr uint32_t SCL_STATE_LAST_Pos = 28;
    constexpr uint32_t SCL_STATE_LAST_Msk = SCL_STATE_LAST::mask;

}  // namespace sr

/// TO - TO
namespace to {
    /// This register is used to configure the max clock number of receiving  a data.
    /// Position: 0, Width: 20
    /// Access: read-write
    using TIME_OUT = BitField<0, 20>;
    constexpr uint32_t TIME_OUT_Pos = 0;
    constexpr uint32_t TIME_OUT_Msk = TIME_OUT::mask;

}  // namespace to

/// SLAVE_ADDR - SLAVE_ADDR
namespace slave_addr {
    /// when configured as i2c slave  this register is used to configure slave's address.
    /// Position: 0, Width: 15
    /// Access: read-write
    using SLAVE_ADDR = BitField<0, 15>;
    constexpr uint32_t SLAVE_ADDR_Pos = 0;
    constexpr uint32_t SLAVE_ADDR_Msk = SLAVE_ADDR::mask;

    /// This register is used to enable slave 10bit address mode.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDR_10BIT_EN = BitField<31, 1>;
    constexpr uint32_t ADDR_10BIT_EN_Pos = 31;
    constexpr uint32_t ADDR_10BIT_EN_Msk = ADDR_10BIT_EN::mask;

}  // namespace slave_addr

/// RXFIFO_ST - RXFIFO_ST
namespace rxfifo_st {
    /// This is the offset address of the last receiving data as described in nonfifo_rx_thres_register.
    /// Position: 0, Width: 5
    /// Access: read-only
    using RXFIFO_START_ADDR = BitField<0, 5>;
    constexpr uint32_t RXFIFO_START_ADDR_Pos = 0;
    constexpr uint32_t RXFIFO_START_ADDR_Msk = RXFIFO_START_ADDR::mask;

    /// This is the offset address of the first receiving data as described in nonfifo_rx_thres_register.
    /// Position: 5, Width: 5
    /// Access: read-only
    using RXFIFO_END_ADDR = BitField<5, 5>;
    constexpr uint32_t RXFIFO_END_ADDR_Pos = 5;
    constexpr uint32_t RXFIFO_END_ADDR_Msk = RXFIFO_END_ADDR::mask;

    /// This is the offset address of the first  sending data as described in nonfifo_tx_thres register.
    /// Position: 10, Width: 5
    /// Access: read-only
    using TXFIFO_START_ADDR = BitField<10, 5>;
    constexpr uint32_t TXFIFO_START_ADDR_Pos = 10;
    constexpr uint32_t TXFIFO_START_ADDR_Msk = TXFIFO_START_ADDR::mask;

    /// This is the offset address of the last  sending data as described in nonfifo_tx_thres register.
    /// Position: 15, Width: 5
    /// Access: read-only
    using TXFIFO_END_ADDR = BitField<15, 5>;
    constexpr uint32_t TXFIFO_END_ADDR_Pos = 15;
    constexpr uint32_t TXFIFO_END_ADDR_Msk = TXFIFO_END_ADDR::mask;

}  // namespace rxfifo_st

/// FIFO_CONF - FIFO_CONF
namespace fifo_conf {
    /// Position: 0, Width: 5
    /// Access: read-write
    using RXFIFO_FULL_THRHD = BitField<0, 5>;
    constexpr uint32_t RXFIFO_FULL_THRHD_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_THRHD_Msk = RXFIFO_FULL_THRHD::mask;

    /// Config txfifo empty threhd value when using apb fifo access
    /// Position: 5, Width: 5
    /// Access: read-write
    using TXFIFO_EMPTY_THRHD = BitField<5, 5>;
    constexpr uint32_t TXFIFO_EMPTY_THRHD_Pos = 5;
    constexpr uint32_t TXFIFO_EMPTY_THRHD_Msk = TXFIFO_EMPTY_THRHD::mask;

    /// Set this bit to enble apb nonfifo access.
    /// Position: 10, Width: 1
    /// Access: read-write
    using NONFIFO_EN = BitField<10, 1>;
    constexpr uint32_t NONFIFO_EN_Pos = 10;
    constexpr uint32_t NONFIFO_EN_Msk = NONFIFO_EN::mask;

    /// When this bit is set to 1 then the byte after address represent the offset address of I2C Slave's ram.
    /// Position: 11, Width: 1
    /// Access: read-write
    using FIFO_ADDR_CFG_EN = BitField<11, 1>;
    constexpr uint32_t FIFO_ADDR_CFG_EN_Pos = 11;
    constexpr uint32_t FIFO_ADDR_CFG_EN_Msk = FIFO_ADDR_CFG_EN::mask;

    /// Set this bit to reset rx fifo when using apb fifo access.
    /// Position: 12, Width: 1
    /// Access: read-write
    using RX_FIFO_RST = BitField<12, 1>;
    constexpr uint32_t RX_FIFO_RST_Pos = 12;
    constexpr uint32_t RX_FIFO_RST_Msk = RX_FIFO_RST::mask;

    /// Set this bit to reset tx fifo when using apb fifo access.
    /// Position: 13, Width: 1
    /// Access: read-write
    using TX_FIFO_RST = BitField<13, 1>;
    constexpr uint32_t TX_FIFO_RST_Pos = 13;
    constexpr uint32_t TX_FIFO_RST_Msk = TX_FIFO_RST::mask;

    /// when I2C receives more than nonfifo_rx_thres data  it will produce rx_send_full_int_raw interrupt and update the current offset address of the receiving data.
    /// Position: 14, Width: 6
    /// Access: read-write
    using NONFIFO_RX_THRES = BitField<14, 6>;
    constexpr uint32_t NONFIFO_RX_THRES_Pos = 14;
    constexpr uint32_t NONFIFO_RX_THRES_Msk = NONFIFO_RX_THRES::mask;

    /// when I2C sends more than nonfifo_tx_thres data  it will produce tx_send_empty_int_raw interrupt and update the current offset address of the sending data.
    /// Position: 20, Width: 6
    /// Access: read-write
    using NONFIFO_TX_THRES = BitField<20, 6>;
    constexpr uint32_t NONFIFO_TX_THRES_Pos = 20;
    constexpr uint32_t NONFIFO_TX_THRES_Msk = NONFIFO_TX_THRES::mask;

}  // namespace fifo_conf

/// DATA - DATA
namespace data {
    /// The register represent the byte  data read from rxfifo when use apb fifo access
    /// Position: 0, Width: 8
    /// Access: read-only
    using FIFO_RDATA = BitField<0, 8>;
    constexpr uint32_t FIFO_RDATA_Pos = 0;
    constexpr uint32_t FIFO_RDATA_Msk = FIFO_RDATA::mask;

}  // namespace data

/// INT_RAW - INT_RAW
namespace int_raw {
    /// The raw interrupt status bit for rxfifo full when use apb fifo access.
    /// Position: 0, Width: 1
    /// Access: read-only
    using RXFIFO_FULL_INT_RAW = BitField<0, 1>;
    constexpr uint32_t RXFIFO_FULL_INT_RAW_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_INT_RAW_Msk = RXFIFO_FULL_INT_RAW::mask;

    /// The raw interrupt status bit for txfifo empty when use apb fifo access.
    /// Position: 1, Width: 1
    /// Access: read-only
    using TXFIFO_EMPTY_INT_RAW = BitField<1, 1>;
    constexpr uint32_t TXFIFO_EMPTY_INT_RAW_Pos = 1;
    constexpr uint32_t TXFIFO_EMPTY_INT_RAW_Msk = TXFIFO_EMPTY_INT_RAW::mask;

    /// The raw interrupt status bit for receiving data overflow when use apb fifo access.
    /// Position: 2, Width: 1
    /// Access: read-only
    using RXFIFO_OVF_INT_RAW = BitField<2, 1>;
    constexpr uint32_t RXFIFO_OVF_INT_RAW_Pos = 2;
    constexpr uint32_t RXFIFO_OVF_INT_RAW_Msk = RXFIFO_OVF_INT_RAW::mask;

    /// The raw interrupt status bit for end_detect_int interrupt. when I2C deals with  the END command  it will produce end_detect_int interrupt.
    /// Position: 3, Width: 1
    /// Access: read-only
    using END_DETECT_INT_RAW = BitField<3, 1>;
    constexpr uint32_t END_DETECT_INT_RAW_Pos = 3;
    constexpr uint32_t END_DETECT_INT_RAW_Msk = END_DETECT_INT_RAW::mask;

    /// The raw interrupt status bit for slave_tran_comp_int interrupt. when I2C Slave detectsthe STOP bit  it will produce slave_tran_comp_int interrupt.
    /// Position: 4, Width: 1
    /// Access: read-only
    using SLAVE_TRAN_COMP_INT_RAW = BitField<4, 1>;
    constexpr uint32_t SLAVE_TRAN_COMP_INT_RAW_Pos = 4;
    constexpr uint32_t SLAVE_TRAN_COMP_INT_RAW_Msk = SLAVE_TRAN_COMP_INT_RAW::mask;

    /// The raw interrupt status bit for arbitration_lost_int interrupt.when I2C lost the usage right of I2C BUS it will produce arbitration_lost_int interrupt.
    /// Position: 5, Width: 1
    /// Access: read-only
    using ARBITRATION_LOST_INT_RAW = BitField<5, 1>;
    constexpr uint32_t ARBITRATION_LOST_INT_RAW_Pos = 5;
    constexpr uint32_t ARBITRATION_LOST_INT_RAW_Msk = ARBITRATION_LOST_INT_RAW::mask;

    /// The raw interrupt status bit for master_tra_comp_int interrupt. when I2C Master sends or receives a byte it will produce master_tran_comp_int interrupt.
    /// Position: 6, Width: 1
    /// Access: read-only
    using MASTER_TRAN_COMP_INT_RAW = BitField<6, 1>;
    constexpr uint32_t MASTER_TRAN_COMP_INT_RAW_Pos = 6;
    constexpr uint32_t MASTER_TRAN_COMP_INT_RAW_Msk = MASTER_TRAN_COMP_INT_RAW::mask;

    /// The raw interrupt status bit for trans_complete_int interrupt. when I2C Master finished STOP command  it will produce trans_complete_int interrupt.
    /// Position: 7, Width: 1
    /// Access: read-only
    using TRANS_COMPLETE_INT_RAW = BitField<7, 1>;
    constexpr uint32_t TRANS_COMPLETE_INT_RAW_Pos = 7;
    constexpr uint32_t TRANS_COMPLETE_INT_RAW_Msk = TRANS_COMPLETE_INT_RAW::mask;

    /// The raw interrupt status bit for time_out_int interrupt. when I2C takes a lot of time to receive a data  it will produce  time_out_int interrupt.
    /// Position: 8, Width: 1
    /// Access: read-only
    using TIME_OUT_INT_RAW = BitField<8, 1>;
    constexpr uint32_t TIME_OUT_INT_RAW_Pos = 8;
    constexpr uint32_t TIME_OUT_INT_RAW_Msk = TIME_OUT_INT_RAW::mask;

    /// The raw interrupt status bit for trans_start_int interrupt. when I2C sends the START bit it will produce trans_start_int interrupt.
    /// Position: 9, Width: 1
    /// Access: read-only
    using TRANS_START_INT_RAW = BitField<9, 1>;
    constexpr uint32_t TRANS_START_INT_RAW_Pos = 9;
    constexpr uint32_t TRANS_START_INT_RAW_Msk = TRANS_START_INT_RAW::mask;

    /// The raw interrupt status bit for ack_err_int interrupt. when I2C receives a wrong ACK bit  it will produce ack_err_int interrupt..
    /// Position: 10, Width: 1
    /// Access: read-only
    using ACK_ERR_INT_RAW = BitField<10, 1>;
    constexpr uint32_t ACK_ERR_INT_RAW_Pos = 10;
    constexpr uint32_t ACK_ERR_INT_RAW_Msk = ACK_ERR_INT_RAW::mask;

    /// The raw interrupt status bit for rx_rec_full_int interrupt. when I2C receives more data  than nonfifo_rx_thres  it will produce rx_rec_full_int interrupt.
    /// Position: 11, Width: 1
    /// Access: read-only
    using RX_REC_FULL_INT_RAW = BitField<11, 1>;
    constexpr uint32_t RX_REC_FULL_INT_RAW_Pos = 11;
    constexpr uint32_t RX_REC_FULL_INT_RAW_Msk = RX_REC_FULL_INT_RAW::mask;

    /// The raw interrupt status bit for tx_send_empty_int interrupt.when I2C sends more data than nonfifo_tx_thres  it will produce tx_send_empty_int interrupt..
    /// Position: 12, Width: 1
    /// Access: read-only
    using TX_SEND_EMPTY_INT_RAW = BitField<12, 1>;
    constexpr uint32_t TX_SEND_EMPTY_INT_RAW_Pos = 12;
    constexpr uint32_t TX_SEND_EMPTY_INT_RAW_Msk = TX_SEND_EMPTY_INT_RAW::mask;

}  // namespace int_raw

/// INT_CLR - INT_CLR
namespace int_clr {
    /// Set this bit to clear the rxfifo_full_int interrupt.
    /// Position: 0, Width: 1
    /// Access: write-only
    using RXFIFO_FULL_INT_CLR = BitField<0, 1>;
    constexpr uint32_t RXFIFO_FULL_INT_CLR_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_INT_CLR_Msk = RXFIFO_FULL_INT_CLR::mask;

    /// Set this bit to clear the txfifo_empty_int interrupt.
    /// Position: 1, Width: 1
    /// Access: write-only
    using TXFIFO_EMPTY_INT_CLR = BitField<1, 1>;
    constexpr uint32_t TXFIFO_EMPTY_INT_CLR_Pos = 1;
    constexpr uint32_t TXFIFO_EMPTY_INT_CLR_Msk = TXFIFO_EMPTY_INT_CLR::mask;

    /// Set this bit to clear the rxfifo_ovf_int interrupt.
    /// Position: 2, Width: 1
    /// Access: write-only
    using RXFIFO_OVF_INT_CLR = BitField<2, 1>;
    constexpr uint32_t RXFIFO_OVF_INT_CLR_Pos = 2;
    constexpr uint32_t RXFIFO_OVF_INT_CLR_Msk = RXFIFO_OVF_INT_CLR::mask;

    /// Set this bit to clear the end_detect_int interrupt.
    /// Position: 3, Width: 1
    /// Access: write-only
    using END_DETECT_INT_CLR = BitField<3, 1>;
    constexpr uint32_t END_DETECT_INT_CLR_Pos = 3;
    constexpr uint32_t END_DETECT_INT_CLR_Msk = END_DETECT_INT_CLR::mask;

    /// Set this bit to clear the slave_tran_comp_int interrupt.
    /// Position: 4, Width: 1
    /// Access: write-only
    using SLAVE_TRAN_COMP_INT_CLR = BitField<4, 1>;
    constexpr uint32_t SLAVE_TRAN_COMP_INT_CLR_Pos = 4;
    constexpr uint32_t SLAVE_TRAN_COMP_INT_CLR_Msk = SLAVE_TRAN_COMP_INT_CLR::mask;

    /// Set this bit to clear the arbitration_lost_int interrupt.
    /// Position: 5, Width: 1
    /// Access: write-only
    using ARBITRATION_LOST_INT_CLR = BitField<5, 1>;
    constexpr uint32_t ARBITRATION_LOST_INT_CLR_Pos = 5;
    constexpr uint32_t ARBITRATION_LOST_INT_CLR_Msk = ARBITRATION_LOST_INT_CLR::mask;

    /// Set this bit to clear the master_tran_comp interrupt.
    /// Position: 6, Width: 1
    /// Access: write-only
    using MASTER_TRAN_COMP_INT_CLR = BitField<6, 1>;
    constexpr uint32_t MASTER_TRAN_COMP_INT_CLR_Pos = 6;
    constexpr uint32_t MASTER_TRAN_COMP_INT_CLR_Msk = MASTER_TRAN_COMP_INT_CLR::mask;

    /// Set this bit to clear the trans_complete_int interrupt.
    /// Position: 7, Width: 1
    /// Access: write-only
    using TRANS_COMPLETE_INT_CLR = BitField<7, 1>;
    constexpr uint32_t TRANS_COMPLETE_INT_CLR_Pos = 7;
    constexpr uint32_t TRANS_COMPLETE_INT_CLR_Msk = TRANS_COMPLETE_INT_CLR::mask;

    /// Set this bit to clear the time_out_int interrupt.
    /// Position: 8, Width: 1
    /// Access: write-only
    using TIME_OUT_INT_CLR = BitField<8, 1>;
    constexpr uint32_t TIME_OUT_INT_CLR_Pos = 8;
    constexpr uint32_t TIME_OUT_INT_CLR_Msk = TIME_OUT_INT_CLR::mask;

    /// Set this bit to clear the trans_start_int interrupt.
    /// Position: 9, Width: 1
    /// Access: write-only
    using TRANS_START_INT_CLR = BitField<9, 1>;
    constexpr uint32_t TRANS_START_INT_CLR_Pos = 9;
    constexpr uint32_t TRANS_START_INT_CLR_Msk = TRANS_START_INT_CLR::mask;

    /// Set this bit to clear the ack_err_int interrupt.
    /// Position: 10, Width: 1
    /// Access: write-only
    using ACK_ERR_INT_CLR = BitField<10, 1>;
    constexpr uint32_t ACK_ERR_INT_CLR_Pos = 10;
    constexpr uint32_t ACK_ERR_INT_CLR_Msk = ACK_ERR_INT_CLR::mask;

    /// Set this bit to clear the rx_rec_full_int interrupt.
    /// Position: 11, Width: 1
    /// Access: write-only
    using RX_REC_FULL_INT_CLR = BitField<11, 1>;
    constexpr uint32_t RX_REC_FULL_INT_CLR_Pos = 11;
    constexpr uint32_t RX_REC_FULL_INT_CLR_Msk = RX_REC_FULL_INT_CLR::mask;

    /// Set this bit to clear the tx_send_empty_int interrupt.
    /// Position: 12, Width: 1
    /// Access: write-only
    using TX_SEND_EMPTY_INT_CLR = BitField<12, 1>;
    constexpr uint32_t TX_SEND_EMPTY_INT_CLR_Pos = 12;
    constexpr uint32_t TX_SEND_EMPTY_INT_CLR_Msk = TX_SEND_EMPTY_INT_CLR::mask;

}  // namespace int_clr

/// INT_ENA - INT_ENA
namespace int_ena {
    /// The enable bit for rxfifo_full_int interrupt.
    /// Position: 0, Width: 1
    /// Access: read-write
    using RXFIFO_FULL_INT_ENA = BitField<0, 1>;
    constexpr uint32_t RXFIFO_FULL_INT_ENA_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_INT_ENA_Msk = RXFIFO_FULL_INT_ENA::mask;

    /// The enable bit for txfifo_empty_int interrupt.
    /// Position: 1, Width: 1
    /// Access: read-write
    using TXFIFO_EMPTY_INT_ENA = BitField<1, 1>;
    constexpr uint32_t TXFIFO_EMPTY_INT_ENA_Pos = 1;
    constexpr uint32_t TXFIFO_EMPTY_INT_ENA_Msk = TXFIFO_EMPTY_INT_ENA::mask;

    /// The enable bit for rxfifo_ovf_int interrupt.
    /// Position: 2, Width: 1
    /// Access: read-write
    using RXFIFO_OVF_INT_ENA = BitField<2, 1>;
    constexpr uint32_t RXFIFO_OVF_INT_ENA_Pos = 2;
    constexpr uint32_t RXFIFO_OVF_INT_ENA_Msk = RXFIFO_OVF_INT_ENA::mask;

    /// The enable bit for end_detect_int interrupt.
    /// Position: 3, Width: 1
    /// Access: read-write
    using END_DETECT_INT_ENA = BitField<3, 1>;
    constexpr uint32_t END_DETECT_INT_ENA_Pos = 3;
    constexpr uint32_t END_DETECT_INT_ENA_Msk = END_DETECT_INT_ENA::mask;

    /// The enable bit for slave_tran_comp_int interrupt.
    /// Position: 4, Width: 1
    /// Access: read-write
    using SLAVE_TRAN_COMP_INT_ENA = BitField<4, 1>;
    constexpr uint32_t SLAVE_TRAN_COMP_INT_ENA_Pos = 4;
    constexpr uint32_t SLAVE_TRAN_COMP_INT_ENA_Msk = SLAVE_TRAN_COMP_INT_ENA::mask;

    /// The enable bit for arbitration_lost_int interrupt.
    /// Position: 5, Width: 1
    /// Access: read-write
    using ARBITRATION_LOST_INT_ENA = BitField<5, 1>;
    constexpr uint32_t ARBITRATION_LOST_INT_ENA_Pos = 5;
    constexpr uint32_t ARBITRATION_LOST_INT_ENA_Msk = ARBITRATION_LOST_INT_ENA::mask;

    /// The enable bit for master_tran_comp_int interrupt.
    /// Position: 6, Width: 1
    /// Access: read-write
    using MASTER_TRAN_COMP_INT_ENA = BitField<6, 1>;
    constexpr uint32_t MASTER_TRAN_COMP_INT_ENA_Pos = 6;
    constexpr uint32_t MASTER_TRAN_COMP_INT_ENA_Msk = MASTER_TRAN_COMP_INT_ENA::mask;

    /// The enable bit for trans_complete_int interrupt.
    /// Position: 7, Width: 1
    /// Access: read-write
    using TRANS_COMPLETE_INT_ENA = BitField<7, 1>;
    constexpr uint32_t TRANS_COMPLETE_INT_ENA_Pos = 7;
    constexpr uint32_t TRANS_COMPLETE_INT_ENA_Msk = TRANS_COMPLETE_INT_ENA::mask;

    /// The enable bit for time_out_int interrupt.
    /// Position: 8, Width: 1
    /// Access: read-write
    using TIME_OUT_INT_ENA = BitField<8, 1>;
    constexpr uint32_t TIME_OUT_INT_ENA_Pos = 8;
    constexpr uint32_t TIME_OUT_INT_ENA_Msk = TIME_OUT_INT_ENA::mask;

    /// The enable bit for trans_start_int interrupt.
    /// Position: 9, Width: 1
    /// Access: read-write
    using TRANS_START_INT_ENA = BitField<9, 1>;
    constexpr uint32_t TRANS_START_INT_ENA_Pos = 9;
    constexpr uint32_t TRANS_START_INT_ENA_Msk = TRANS_START_INT_ENA::mask;

    /// The enable bit for ack_err_int interrupt.
    /// Position: 10, Width: 1
    /// Access: read-write
    using ACK_ERR_INT_ENA = BitField<10, 1>;
    constexpr uint32_t ACK_ERR_INT_ENA_Pos = 10;
    constexpr uint32_t ACK_ERR_INT_ENA_Msk = ACK_ERR_INT_ENA::mask;

    /// The enable bit for rx_rec_full_int interrupt.
    /// Position: 11, Width: 1
    /// Access: read-write
    using RX_REC_FULL_INT_ENA = BitField<11, 1>;
    constexpr uint32_t RX_REC_FULL_INT_ENA_Pos = 11;
    constexpr uint32_t RX_REC_FULL_INT_ENA_Msk = RX_REC_FULL_INT_ENA::mask;

    /// The enable bit for tx_send_empty_int interrupt.
    /// Position: 12, Width: 1
    /// Access: read-write
    using TX_SEND_EMPTY_INT_ENA = BitField<12, 1>;
    constexpr uint32_t TX_SEND_EMPTY_INT_ENA_Pos = 12;
    constexpr uint32_t TX_SEND_EMPTY_INT_ENA_Msk = TX_SEND_EMPTY_INT_ENA::mask;

}  // namespace int_ena

/// INT_STATUS - INT_STATUS
namespace int_status {
    /// The masked interrupt status for rxfifo_full_int interrupt.
    /// Position: 0, Width: 1
    /// Access: read-only
    using RXFIFO_FULL_INT_ST = BitField<0, 1>;
    constexpr uint32_t RXFIFO_FULL_INT_ST_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_INT_ST_Msk = RXFIFO_FULL_INT_ST::mask;

    /// The masked interrupt status for txfifo_empty_int interrupt.
    /// Position: 1, Width: 1
    /// Access: read-only
    using TXFIFO_EMPTY_INT_ST = BitField<1, 1>;
    constexpr uint32_t TXFIFO_EMPTY_INT_ST_Pos = 1;
    constexpr uint32_t TXFIFO_EMPTY_INT_ST_Msk = TXFIFO_EMPTY_INT_ST::mask;

    /// The masked interrupt status for rxfifo_ovf_int interrupt.
    /// Position: 2, Width: 1
    /// Access: read-only
    using RXFIFO_OVF_INT_ST = BitField<2, 1>;
    constexpr uint32_t RXFIFO_OVF_INT_ST_Pos = 2;
    constexpr uint32_t RXFIFO_OVF_INT_ST_Msk = RXFIFO_OVF_INT_ST::mask;

    /// The masked interrupt status for end_detect_int interrupt.
    /// Position: 3, Width: 1
    /// Access: read-only
    using END_DETECT_INT_ST = BitField<3, 1>;
    constexpr uint32_t END_DETECT_INT_ST_Pos = 3;
    constexpr uint32_t END_DETECT_INT_ST_Msk = END_DETECT_INT_ST::mask;

    /// The masked interrupt status for slave_tran_comp_int interrupt.
    /// Position: 4, Width: 1
    /// Access: read-only
    using SLAVE_TRAN_COMP_INT_ST = BitField<4, 1>;
    constexpr uint32_t SLAVE_TRAN_COMP_INT_ST_Pos = 4;
    constexpr uint32_t SLAVE_TRAN_COMP_INT_ST_Msk = SLAVE_TRAN_COMP_INT_ST::mask;

    /// The masked interrupt status for arbitration_lost_int interrupt.
    /// Position: 5, Width: 1
    /// Access: read-only
    using ARBITRATION_LOST_INT_ST = BitField<5, 1>;
    constexpr uint32_t ARBITRATION_LOST_INT_ST_Pos = 5;
    constexpr uint32_t ARBITRATION_LOST_INT_ST_Msk = ARBITRATION_LOST_INT_ST::mask;

    /// The masked interrupt status for master_tran_comp_int interrupt.
    /// Position: 6, Width: 1
    /// Access: read-only
    using MASTER_TRAN_COMP_INT_ST = BitField<6, 1>;
    constexpr uint32_t MASTER_TRAN_COMP_INT_ST_Pos = 6;
    constexpr uint32_t MASTER_TRAN_COMP_INT_ST_Msk = MASTER_TRAN_COMP_INT_ST::mask;

    /// The masked interrupt status for trans_complete_int interrupt.
    /// Position: 7, Width: 1
    /// Access: read-only
    using TRANS_COMPLETE_INT_ST = BitField<7, 1>;
    constexpr uint32_t TRANS_COMPLETE_INT_ST_Pos = 7;
    constexpr uint32_t TRANS_COMPLETE_INT_ST_Msk = TRANS_COMPLETE_INT_ST::mask;

    /// The masked interrupt status for time_out_int interrupt.
    /// Position: 8, Width: 1
    /// Access: read-only
    using TIME_OUT_INT_ST = BitField<8, 1>;
    constexpr uint32_t TIME_OUT_INT_ST_Pos = 8;
    constexpr uint32_t TIME_OUT_INT_ST_Msk = TIME_OUT_INT_ST::mask;

    /// The masked interrupt status for trans_start_int interrupt.
    /// Position: 9, Width: 1
    /// Access: read-only
    using TRANS_START_INT_ST = BitField<9, 1>;
    constexpr uint32_t TRANS_START_INT_ST_Pos = 9;
    constexpr uint32_t TRANS_START_INT_ST_Msk = TRANS_START_INT_ST::mask;

    /// The masked interrupt status for ack_err_int interrupt.
    /// Position: 10, Width: 1
    /// Access: read-only
    using ACK_ERR_INT_ST = BitField<10, 1>;
    constexpr uint32_t ACK_ERR_INT_ST_Pos = 10;
    constexpr uint32_t ACK_ERR_INT_ST_Msk = ACK_ERR_INT_ST::mask;

    /// The masked interrupt status for rx_rec_full_int interrupt.
    /// Position: 11, Width: 1
    /// Access: read-only
    using RX_REC_FULL_INT_ST = BitField<11, 1>;
    constexpr uint32_t RX_REC_FULL_INT_ST_Pos = 11;
    constexpr uint32_t RX_REC_FULL_INT_ST_Msk = RX_REC_FULL_INT_ST::mask;

    /// The masked interrupt status for tx_send_empty_int interrupt.
    /// Position: 12, Width: 1
    /// Access: read-only
    using TX_SEND_EMPTY_INT_ST = BitField<12, 1>;
    constexpr uint32_t TX_SEND_EMPTY_INT_ST_Pos = 12;
    constexpr uint32_t TX_SEND_EMPTY_INT_ST_Msk = TX_SEND_EMPTY_INT_ST::mask;

}  // namespace int_status

/// SDA_HOLD - SDA_HOLD
namespace sda_hold {
    /// This register is used to configure the clock num I2C used to hold the data after the negedge of SCL.
    /// Position: 0, Width: 10
    /// Access: read-write
    using TIME = BitField<0, 10>;
    constexpr uint32_t TIME_Pos = 0;
    constexpr uint32_t TIME_Msk = TIME::mask;

}  // namespace sda_hold

/// SDA_SAMPLE - SDA_SAMPLE
namespace sda_sample {
    /// This register is used to configure the clock num I2C used to sample data on SDA after the posedge of SCL
    /// Position: 0, Width: 10
    /// Access: read-write
    using TIME = BitField<0, 10>;
    constexpr uint32_t TIME_Pos = 0;
    constexpr uint32_t TIME_Msk = TIME::mask;

}  // namespace sda_sample

/// SCL_HIGH_PERIOD - SCL_HIGH_PERIOD
namespace scl_high_period {
    /// This register is used to configure the clock num during SCL is low level.
    /// Position: 0, Width: 14
    /// Access: read-write
    using SCL_HIGH_PERIOD = BitField<0, 14>;
    constexpr uint32_t SCL_HIGH_PERIOD_Pos = 0;
    constexpr uint32_t SCL_HIGH_PERIOD_Msk = SCL_HIGH_PERIOD::mask;

}  // namespace scl_high_period

/// SCL_START_HOLD - SCL_START_HOLD
namespace scl_start_hold {
    /// This register is used to configure the clock num between the negedge of SDA and negedge of SCL for start mark.
    /// Position: 0, Width: 10
    /// Access: read-write
    using TIME = BitField<0, 10>;
    constexpr uint32_t TIME_Pos = 0;
    constexpr uint32_t TIME_Msk = TIME::mask;

}  // namespace scl_start_hold

/// SCL_RSTART_SETUP - SCL_RSTART_SETUP
namespace scl_rstart_setup {
    /// This register is used to configure the clock num between the posedge of SCL and the negedge of SDA for restart mark.
    /// Position: 0, Width: 10
    /// Access: read-write
    using TIME = BitField<0, 10>;
    constexpr uint32_t TIME_Pos = 0;
    constexpr uint32_t TIME_Msk = TIME::mask;

}  // namespace scl_rstart_setup

/// SCL_STOP_HOLD - SCL_STOP_HOLD
namespace scl_stop_hold {
    /// This register is used to configure the clock num after the STOP bit's posedge.
    /// Position: 0, Width: 14
    /// Access: read-write
    using TIME = BitField<0, 14>;
    constexpr uint32_t TIME_Pos = 0;
    constexpr uint32_t TIME_Msk = TIME::mask;

}  // namespace scl_stop_hold

/// SCL_STOP_SETUP - SCL_STOP_SETUP
namespace scl_stop_setup {
    /// This register is used to configure the clock num between the posedge of SCL and the posedge of SDA.
    /// Position: 0, Width: 10
    /// Access: read-write
    using TIME = BitField<0, 10>;
    constexpr uint32_t TIME_Pos = 0;
    constexpr uint32_t TIME_Msk = TIME::mask;

}  // namespace scl_stop_setup

/// SCL_FILTER_CFG - SCL_FILTER_CFG
namespace scl_filter_cfg {
    /// When input SCL's pulse width is smaller than this register value  I2C ignores this pulse.
    /// Position: 0, Width: 3
    /// Access: read-write
    using SCL_FILTER_THRES = BitField<0, 3>;
    constexpr uint32_t SCL_FILTER_THRES_Pos = 0;
    constexpr uint32_t SCL_FILTER_THRES_Msk = SCL_FILTER_THRES::mask;

    /// This is the filter enable bit for SCL.
    /// Position: 3, Width: 1
    /// Access: read-write
    using SCL_FILTER_EN = BitField<3, 1>;
    constexpr uint32_t SCL_FILTER_EN_Pos = 3;
    constexpr uint32_t SCL_FILTER_EN_Msk = SCL_FILTER_EN::mask;

}  // namespace scl_filter_cfg

/// SDA_FILTER_CFG - SDA_FILTER_CFG
namespace sda_filter_cfg {
    /// When input SCL's pulse width is smaller than this register value  I2C ignores this pulse.
    /// Position: 0, Width: 3
    /// Access: read-write
    using SDA_FILTER_THRES = BitField<0, 3>;
    constexpr uint32_t SDA_FILTER_THRES_Pos = 0;
    constexpr uint32_t SDA_FILTER_THRES_Msk = SDA_FILTER_THRES::mask;

    /// This is the filter enable bit for SDA.
    /// Position: 3, Width: 1
    /// Access: read-write
    using SDA_FILTER_EN = BitField<3, 1>;
    constexpr uint32_t SDA_FILTER_EN_Pos = 3;
    constexpr uint32_t SDA_FILTER_EN_Msk = SDA_FILTER_EN::mask;

}  // namespace sda_filter_cfg

/// COMD[16] - COMD[16]
namespace comd {
    /// This is the content of command0. It consists of three part. op_code is the command  0: RSTART   1: WRITE  2: READ  3: STOP . 4:END.  Byte_num represent the number of data need to be send or data need to be received. ack_check_en  ack_exp and ack value are used to control  the ack bit.
    /// Position: 0, Width: 14
    /// Access: read-write
    using COMMAND = BitField<0, 14>;
    constexpr uint32_t COMMAND_Pos = 0;
    constexpr uint32_t COMMAND_Msk = COMMAND::mask;

    /// When command0 is done in I2C Master mode  this bit changes to high level.
    /// Position: 31, Width: 1
    /// Access: read-write
    using COMMAND_DONE = BitField<31, 1>;
    constexpr uint32_t COMMAND_DONE_Pos = 31;
    constexpr uint32_t COMMAND_DONE_Msk = COMMAND_DONE::mask;

}  // namespace comd

/// DATE - DATE
namespace date {
    /// Position: 0, Width: 32
    /// Access: read-write
    using DATE = BitField<0, 32>;
    constexpr uint32_t DATE_Pos = 0;
    constexpr uint32_t DATE_Msk = DATE::mask;

}  // namespace date

}  // namespace alloy::hal::espressif::esp32::esp32::i2c0
