/// Auto-generated bit field definitions for SENS
/// Device: ESP32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "bitfield_utils.hpp"

namespace alloy::hal::espressif::esp32::esp32::sens {

using namespace alloy::hal::bitfields;

// ============================================================================
// SENS Bit Field Definitions
// ============================================================================

/// SAR_READ_CTRL - SAR_READ_CTRL
namespace sar_read_ctrl {
    /// clock divider
    /// Position: 0, Width: 8
    /// Access: read-write
    using SAR1_CLK_DIV = BitField<0, 8>;
    constexpr uint32_t SAR1_CLK_DIV_Pos = 0;
    constexpr uint32_t SAR1_CLK_DIV_Msk = SAR1_CLK_DIV::mask;

    /// sample cycles for SAR ADC1
    /// Position: 8, Width: 8
    /// Access: read-write
    using SAR1_SAMPLE_CYCLE = BitField<8, 8>;
    constexpr uint32_t SAR1_SAMPLE_CYCLE_Pos = 8;
    constexpr uint32_t SAR1_SAMPLE_CYCLE_Msk = SAR1_SAMPLE_CYCLE::mask;

    /// 00: for 9-bit width  01: for 10-bit width  10: for 11-bit width  11: for 12-bit width
    /// Position: 16, Width: 2
    /// Access: read-write
    using SAR1_SAMPLE_BIT = BitField<16, 2>;
    constexpr uint32_t SAR1_SAMPLE_BIT_Pos = 16;
    constexpr uint32_t SAR1_SAMPLE_BIT_Msk = SAR1_SAMPLE_BIT::mask;

    /// Position: 18, Width: 1
    /// Access: read-write
    using SAR1_CLK_GATED = BitField<18, 1>;
    constexpr uint32_t SAR1_CLK_GATED_Pos = 18;
    constexpr uint32_t SAR1_CLK_GATED_Msk = SAR1_CLK_GATED::mask;

    /// Position: 19, Width: 8
    /// Access: read-write
    using SAR1_SAMPLE_NUM = BitField<19, 8>;
    constexpr uint32_t SAR1_SAMPLE_NUM_Pos = 19;
    constexpr uint32_t SAR1_SAMPLE_NUM_Msk = SAR1_SAMPLE_NUM::mask;

    /// 1: SAR ADC1 controlled by DIG ADC1 CTRL  0: SAR ADC1 controlled by RTC ADC1 CTRL
    /// Position: 27, Width: 1
    /// Access: read-write
    using SAR1_DIG_FORCE = BitField<27, 1>;
    constexpr uint32_t SAR1_DIG_FORCE_Pos = 27;
    constexpr uint32_t SAR1_DIG_FORCE_Msk = SAR1_DIG_FORCE::mask;

    /// Invert SAR ADC1 data
    /// Position: 28, Width: 1
    /// Access: read-write
    using SAR1_DATA_INV = BitField<28, 1>;
    constexpr uint32_t SAR1_DATA_INV_Pos = 28;
    constexpr uint32_t SAR1_DATA_INV_Msk = SAR1_DATA_INV::mask;

}  // namespace sar_read_ctrl

/// SAR_READ_STATUS1 - SAR_READ_STATUS1
namespace sar_read_status1 {
    /// Position: 0, Width: 32
    /// Access: read-only
    using SAR1_READER_STATUS = BitField<0, 32>;
    constexpr uint32_t SAR1_READER_STATUS_Pos = 0;
    constexpr uint32_t SAR1_READER_STATUS_Msk = SAR1_READER_STATUS::mask;

}  // namespace sar_read_status1

/// SAR_MEAS_WAIT1 - SAR_MEAS_WAIT1
namespace sar_meas_wait1 {
    /// Position: 0, Width: 16
    /// Access: read-write
    using SAR_AMP_WAIT1 = BitField<0, 16>;
    constexpr uint32_t SAR_AMP_WAIT1_Pos = 0;
    constexpr uint32_t SAR_AMP_WAIT1_Msk = SAR_AMP_WAIT1::mask;

    /// Position: 16, Width: 16
    /// Access: read-write
    using SAR_AMP_WAIT2 = BitField<16, 16>;
    constexpr uint32_t SAR_AMP_WAIT2_Pos = 16;
    constexpr uint32_t SAR_AMP_WAIT2_Msk = SAR_AMP_WAIT2::mask;

}  // namespace sar_meas_wait1

/// SAR_MEAS_WAIT2 - SAR_MEAS_WAIT2
namespace sar_meas_wait2 {
    /// Position: 0, Width: 1
    /// Access: read-write
    using FORCE_XPD_SAR_SW = BitField<0, 1>;
    constexpr uint32_t FORCE_XPD_SAR_SW_Pos = 0;
    constexpr uint32_t FORCE_XPD_SAR_SW_Msk = FORCE_XPD_SAR_SW::mask;

    /// Position: 0, Width: 16
    /// Access: read-write
    using SAR_AMP_WAIT3 = BitField<0, 16>;
    constexpr uint32_t SAR_AMP_WAIT3_Pos = 0;
    constexpr uint32_t SAR_AMP_WAIT3_Msk = SAR_AMP_WAIT3::mask;

    /// Position: 16, Width: 2
    /// Access: read-write
    using FORCE_XPD_AMP = BitField<16, 2>;
    constexpr uint32_t FORCE_XPD_AMP_Pos = 16;
    constexpr uint32_t FORCE_XPD_AMP_Msk = FORCE_XPD_AMP::mask;

    /// Position: 18, Width: 2
    /// Access: read-write
    using FORCE_XPD_SAR = BitField<18, 2>;
    constexpr uint32_t FORCE_XPD_SAR_Pos = 18;
    constexpr uint32_t FORCE_XPD_SAR_Msk = FORCE_XPD_SAR::mask;

    /// Position: 20, Width: 8
    /// Access: read-write
    using SAR2_RSTB_WAIT = BitField<20, 8>;
    constexpr uint32_t SAR2_RSTB_WAIT_Pos = 20;
    constexpr uint32_t SAR2_RSTB_WAIT_Msk = SAR2_RSTB_WAIT::mask;

}  // namespace sar_meas_wait2

/// SAR_MEAS_CTRL - SAR_MEAS_CTRL
namespace sar_meas_ctrl {
    /// Position: 0, Width: 4
    /// Access: read-write
    using XPD_SAR_AMP_FSM = BitField<0, 4>;
    constexpr uint32_t XPD_SAR_AMP_FSM_Pos = 0;
    constexpr uint32_t XPD_SAR_AMP_FSM_Msk = XPD_SAR_AMP_FSM::mask;

    /// Position: 4, Width: 4
    /// Access: read-write
    using AMP_RST_FB_FSM = BitField<4, 4>;
    constexpr uint32_t AMP_RST_FB_FSM_Pos = 4;
    constexpr uint32_t AMP_RST_FB_FSM_Msk = AMP_RST_FB_FSM::mask;

    /// Position: 8, Width: 4
    /// Access: read-write
    using AMP_SHORT_REF_FSM = BitField<8, 4>;
    constexpr uint32_t AMP_SHORT_REF_FSM_Pos = 8;
    constexpr uint32_t AMP_SHORT_REF_FSM_Msk = AMP_SHORT_REF_FSM::mask;

    /// Position: 12, Width: 4
    /// Access: read-write
    using AMP_SHORT_REF_GND_FSM = BitField<12, 4>;
    constexpr uint32_t AMP_SHORT_REF_GND_FSM_Pos = 12;
    constexpr uint32_t AMP_SHORT_REF_GND_FSM_Msk = AMP_SHORT_REF_GND_FSM::mask;

    /// Position: 16, Width: 4
    /// Access: read-write
    using XPD_SAR_FSM = BitField<16, 4>;
    constexpr uint32_t XPD_SAR_FSM_Pos = 16;
    constexpr uint32_t XPD_SAR_FSM_Msk = XPD_SAR_FSM::mask;

    /// Position: 20, Width: 4
    /// Access: read-write
    using SAR_RSTB_FSM = BitField<20, 4>;
    constexpr uint32_t SAR_RSTB_FSM_Pos = 20;
    constexpr uint32_t SAR_RSTB_FSM_Msk = SAR_RSTB_FSM::mask;

    /// Position: 24, Width: 8
    /// Access: read-write
    using SAR2_XPD_WAIT = BitField<24, 8>;
    constexpr uint32_t SAR2_XPD_WAIT_Pos = 24;
    constexpr uint32_t SAR2_XPD_WAIT_Msk = SAR2_XPD_WAIT::mask;

}  // namespace sar_meas_ctrl

/// SAR_READ_STATUS2 - SAR_READ_STATUS2
namespace sar_read_status2 {
    /// Position: 0, Width: 32
    /// Access: read-only
    using SAR2_READER_STATUS = BitField<0, 32>;
    constexpr uint32_t SAR2_READER_STATUS_Pos = 0;
    constexpr uint32_t SAR2_READER_STATUS_Msk = SAR2_READER_STATUS::mask;

}  // namespace sar_read_status2

/// ULP_CP_SLEEP_CYC0 - ULP_CP_SLEEP_CYC0
namespace ulp_cp_sleep_cyc0 {
    /// sleep cycles for ULP-coprocessor timer
    /// Position: 0, Width: 32
    /// Access: read-write
    using SLEEP_CYCLES_S0 = BitField<0, 32>;
    constexpr uint32_t SLEEP_CYCLES_S0_Pos = 0;
    constexpr uint32_t SLEEP_CYCLES_S0_Msk = SLEEP_CYCLES_S0::mask;

}  // namespace ulp_cp_sleep_cyc0

/// ULP_CP_SLEEP_CYC1 - ULP_CP_SLEEP_CYC1
namespace ulp_cp_sleep_cyc1 {
    /// Position: 0, Width: 32
    /// Access: read-write
    using SLEEP_CYCLES_S1 = BitField<0, 32>;
    constexpr uint32_t SLEEP_CYCLES_S1_Pos = 0;
    constexpr uint32_t SLEEP_CYCLES_S1_Msk = SLEEP_CYCLES_S1::mask;

}  // namespace ulp_cp_sleep_cyc1

/// ULP_CP_SLEEP_CYC2 - ULP_CP_SLEEP_CYC2
namespace ulp_cp_sleep_cyc2 {
    /// Position: 0, Width: 32
    /// Access: read-write
    using SLEEP_CYCLES_S2 = BitField<0, 32>;
    constexpr uint32_t SLEEP_CYCLES_S2_Pos = 0;
    constexpr uint32_t SLEEP_CYCLES_S2_Msk = SLEEP_CYCLES_S2::mask;

}  // namespace ulp_cp_sleep_cyc2

/// ULP_CP_SLEEP_CYC3 - ULP_CP_SLEEP_CYC3
namespace ulp_cp_sleep_cyc3 {
    /// Position: 0, Width: 32
    /// Access: read-write
    using SLEEP_CYCLES_S3 = BitField<0, 32>;
    constexpr uint32_t SLEEP_CYCLES_S3_Pos = 0;
    constexpr uint32_t SLEEP_CYCLES_S3_Msk = SLEEP_CYCLES_S3::mask;

}  // namespace ulp_cp_sleep_cyc3

/// ULP_CP_SLEEP_CYC4 - ULP_CP_SLEEP_CYC4
namespace ulp_cp_sleep_cyc4 {
    /// Position: 0, Width: 32
    /// Access: read-write
    using SLEEP_CYCLES_S4 = BitField<0, 32>;
    constexpr uint32_t SLEEP_CYCLES_S4_Pos = 0;
    constexpr uint32_t SLEEP_CYCLES_S4_Msk = SLEEP_CYCLES_S4::mask;

}  // namespace ulp_cp_sleep_cyc4

/// SAR_START_FORCE - SAR_START_FORCE
namespace sar_start_force {
    /// 00: 9 bit  01: 10 bits  10: 11bits  11: 12bits
    /// Position: 0, Width: 2
    /// Access: read-write
    using SAR1_BIT_WIDTH = BitField<0, 2>;
    constexpr uint32_t SAR1_BIT_WIDTH_Pos = 0;
    constexpr uint32_t SAR1_BIT_WIDTH_Msk = SAR1_BIT_WIDTH::mask;

    /// 00: 9 bit  01: 10 bits  10: 11bits  11: 12bits
    /// Position: 2, Width: 2
    /// Access: read-write
    using SAR2_BIT_WIDTH = BitField<2, 2>;
    constexpr uint32_t SAR2_BIT_WIDTH_Pos = 2;
    constexpr uint32_t SAR2_BIT_WIDTH_Msk = SAR2_BIT_WIDTH::mask;

    /// SAR2_EN_TEST  only active when reg_sar2_dig_force = 0
    /// Position: 4, Width: 1
    /// Access: read-write
    using SAR2_EN_TEST = BitField<4, 1>;
    constexpr uint32_t SAR2_EN_TEST_Pos = 4;
    constexpr uint32_t SAR2_EN_TEST_Msk = SAR2_EN_TEST::mask;

    /// SAR2_PWDET_CCT  PA power detector capacitance tuning.
    /// Position: 5, Width: 3
    /// Access: read-write
    using SAR2_PWDET_CCT = BitField<5, 3>;
    constexpr uint32_t SAR2_PWDET_CCT_Pos = 5;
    constexpr uint32_t SAR2_PWDET_CCT_Msk = SAR2_PWDET_CCT::mask;

    /// 1: ULP-coprocessor is started by SW  0: ULP-coprocessor is started by timer
    /// Position: 8, Width: 1
    /// Access: read-write
    using ULP_CP_FORCE_START_TOP = BitField<8, 1>;
    constexpr uint32_t ULP_CP_FORCE_START_TOP_Pos = 8;
    constexpr uint32_t ULP_CP_FORCE_START_TOP_Msk = ULP_CP_FORCE_START_TOP::mask;

    /// Write 1 to start ULP-coprocessor  only active when reg_ulp_cp_force_start_top = 1
    /// Position: 9, Width: 1
    /// Access: read-write
    using ULP_CP_START_TOP = BitField<9, 1>;
    constexpr uint32_t ULP_CP_START_TOP_Pos = 9;
    constexpr uint32_t ULP_CP_START_TOP_Msk = ULP_CP_START_TOP::mask;

    /// Position: 10, Width: 1
    /// Access: read-write
    using SARCLK_EN = BitField<10, 1>;
    constexpr uint32_t SARCLK_EN_Pos = 10;
    constexpr uint32_t SARCLK_EN_Msk = SARCLK_EN::mask;

    /// initialized PC for ULP-coprocessor
    /// Position: 11, Width: 11
    /// Access: read-write
    using PC_INIT = BitField<11, 11>;
    constexpr uint32_t PC_INIT_Pos = 11;
    constexpr uint32_t PC_INIT_Msk = PC_INIT::mask;

    /// stop SAR ADC2 conversion
    /// Position: 22, Width: 1
    /// Access: read-write
    using SAR2_STOP = BitField<22, 1>;
    constexpr uint32_t SAR2_STOP_Pos = 22;
    constexpr uint32_t SAR2_STOP_Msk = SAR2_STOP::mask;

    /// stop SAR ADC1 conversion
    /// Position: 23, Width: 1
    /// Access: read-write
    using SAR1_STOP = BitField<23, 1>;
    constexpr uint32_t SAR1_STOP_Pos = 23;
    constexpr uint32_t SAR1_STOP_Msk = SAR1_STOP::mask;

    /// N/A
    /// Position: 24, Width: 1
    /// Access: read-write
    using SAR2_PWDET_EN = BitField<24, 1>;
    constexpr uint32_t SAR2_PWDET_EN_Pos = 24;
    constexpr uint32_t SAR2_PWDET_EN_Msk = SAR2_PWDET_EN::mask;

}  // namespace sar_start_force

/// SAR_MEM_WR_CTRL - SAR_MEM_WR_CTRL
namespace sar_mem_wr_ctrl {
    /// Position: 0, Width: 11
    /// Access: read-write
    using MEM_WR_ADDR_INIT = BitField<0, 11>;
    constexpr uint32_t MEM_WR_ADDR_INIT_Pos = 0;
    constexpr uint32_t MEM_WR_ADDR_INIT_Msk = MEM_WR_ADDR_INIT::mask;

    /// Position: 11, Width: 11
    /// Access: read-write
    using MEM_WR_ADDR_SIZE = BitField<11, 11>;
    constexpr uint32_t MEM_WR_ADDR_SIZE_Pos = 11;
    constexpr uint32_t MEM_WR_ADDR_SIZE_Msk = MEM_WR_ADDR_SIZE::mask;

    /// Position: 22, Width: 1
    /// Access: write-only
    using RTC_MEM_WR_OFFST_CLR = BitField<22, 1>;
    constexpr uint32_t RTC_MEM_WR_OFFST_CLR_Pos = 22;
    constexpr uint32_t RTC_MEM_WR_OFFST_CLR_Msk = RTC_MEM_WR_OFFST_CLR::mask;

}  // namespace sar_mem_wr_ctrl

/// SAR_ATTEN1 - SAR_ATTEN1
namespace sar_atten1 {
    /// 2-bit attenuation for each pad  11:1dB  10:6dB  01:3dB  00:0dB
    /// Position: 0, Width: 32
    /// Access: read-write
    using SAR1_ATTEN = BitField<0, 32>;
    constexpr uint32_t SAR1_ATTEN_Pos = 0;
    constexpr uint32_t SAR1_ATTEN_Msk = SAR1_ATTEN::mask;

}  // namespace sar_atten1

/// SAR_ATTEN2 - SAR_ATTEN2
namespace sar_atten2 {
    /// 2-bit attenuation for each pad  11:1dB  10:6dB  01:3dB  00:0dB
    /// Position: 0, Width: 32
    /// Access: read-write
    using SAR2_ATTEN = BitField<0, 32>;
    constexpr uint32_t SAR2_ATTEN_Pos = 0;
    constexpr uint32_t SAR2_ATTEN_Msk = SAR2_ATTEN::mask;

}  // namespace sar_atten2

/// SAR_SLAVE_ADDR1 - SAR_SLAVE_ADDR1
namespace sar_slave_addr1 {
    /// Position: 0, Width: 11
    /// Access: read-write
    using I2C_SLAVE_ADDR1 = BitField<0, 11>;
    constexpr uint32_t I2C_SLAVE_ADDR1_Pos = 0;
    constexpr uint32_t I2C_SLAVE_ADDR1_Msk = I2C_SLAVE_ADDR1::mask;

    /// Position: 11, Width: 11
    /// Access: read-write
    using I2C_SLAVE_ADDR0 = BitField<11, 11>;
    constexpr uint32_t I2C_SLAVE_ADDR0_Pos = 11;
    constexpr uint32_t I2C_SLAVE_ADDR0_Msk = I2C_SLAVE_ADDR0::mask;

    /// Position: 22, Width: 8
    /// Access: read-only
    using MEAS_STATUS = BitField<22, 8>;
    constexpr uint32_t MEAS_STATUS_Pos = 22;
    constexpr uint32_t MEAS_STATUS_Msk = MEAS_STATUS::mask;

}  // namespace sar_slave_addr1

/// SAR_SLAVE_ADDR2 - SAR_SLAVE_ADDR2
namespace sar_slave_addr2 {
    /// Position: 0, Width: 11
    /// Access: read-write
    using I2C_SLAVE_ADDR3 = BitField<0, 11>;
    constexpr uint32_t I2C_SLAVE_ADDR3_Pos = 0;
    constexpr uint32_t I2C_SLAVE_ADDR3_Msk = I2C_SLAVE_ADDR3::mask;

    /// Position: 11, Width: 11
    /// Access: read-write
    using I2C_SLAVE_ADDR2 = BitField<11, 11>;
    constexpr uint32_t I2C_SLAVE_ADDR2_Pos = 11;
    constexpr uint32_t I2C_SLAVE_ADDR2_Msk = I2C_SLAVE_ADDR2::mask;

}  // namespace sar_slave_addr2

/// SAR_SLAVE_ADDR3 - SAR_SLAVE_ADDR3
namespace sar_slave_addr3 {
    /// Position: 0, Width: 11
    /// Access: read-write
    using I2C_SLAVE_ADDR5 = BitField<0, 11>;
    constexpr uint32_t I2C_SLAVE_ADDR5_Pos = 0;
    constexpr uint32_t I2C_SLAVE_ADDR5_Msk = I2C_SLAVE_ADDR5::mask;

    /// Position: 11, Width: 11
    /// Access: read-write
    using I2C_SLAVE_ADDR4 = BitField<11, 11>;
    constexpr uint32_t I2C_SLAVE_ADDR4_Pos = 11;
    constexpr uint32_t I2C_SLAVE_ADDR4_Msk = I2C_SLAVE_ADDR4::mask;

    /// temperature sensor data out
    /// Position: 22, Width: 8
    /// Access: read-only
    using TSENS_OUT = BitField<22, 8>;
    constexpr uint32_t TSENS_OUT_Pos = 22;
    constexpr uint32_t TSENS_OUT_Msk = TSENS_OUT::mask;

    /// indicate temperature sensor out ready
    /// Position: 30, Width: 1
    /// Access: read-only
    using TSENS_RDY_OUT = BitField<30, 1>;
    constexpr uint32_t TSENS_RDY_OUT_Pos = 30;
    constexpr uint32_t TSENS_RDY_OUT_Msk = TSENS_RDY_OUT::mask;

}  // namespace sar_slave_addr3

/// SAR_SLAVE_ADDR4 - SAR_SLAVE_ADDR4
namespace sar_slave_addr4 {
    /// Position: 0, Width: 11
    /// Access: read-write
    using I2C_SLAVE_ADDR7 = BitField<0, 11>;
    constexpr uint32_t I2C_SLAVE_ADDR7_Pos = 0;
    constexpr uint32_t I2C_SLAVE_ADDR7_Msk = I2C_SLAVE_ADDR7::mask;

    /// Position: 11, Width: 11
    /// Access: read-write
    using I2C_SLAVE_ADDR6 = BitField<11, 11>;
    constexpr uint32_t I2C_SLAVE_ADDR6_Pos = 11;
    constexpr uint32_t I2C_SLAVE_ADDR6_Msk = I2C_SLAVE_ADDR6::mask;

    /// I2C read data
    /// Position: 22, Width: 8
    /// Access: read-only
    using I2C_RDATA = BitField<22, 8>;
    constexpr uint32_t I2C_RDATA_Pos = 22;
    constexpr uint32_t I2C_RDATA_Msk = I2C_RDATA::mask;

    /// indicate I2C done
    /// Position: 30, Width: 1
    /// Access: read-only
    using I2C_DONE = BitField<30, 1>;
    constexpr uint32_t I2C_DONE_Pos = 30;
    constexpr uint32_t I2C_DONE_Msk = I2C_DONE::mask;

}  // namespace sar_slave_addr4

/// SAR_TSENS_CTRL - SAR_TSENS_CTRL
namespace sar_tsens_ctrl {
    /// Position: 0, Width: 12
    /// Access: read-write
    using TSENS_XPD_WAIT = BitField<0, 12>;
    constexpr uint32_t TSENS_XPD_WAIT_Pos = 0;
    constexpr uint32_t TSENS_XPD_WAIT_Msk = TSENS_XPD_WAIT::mask;

    /// Position: 12, Width: 1
    /// Access: read-write
    using TSENS_XPD_FORCE = BitField<12, 1>;
    constexpr uint32_t TSENS_XPD_FORCE_Pos = 12;
    constexpr uint32_t TSENS_XPD_FORCE_Msk = TSENS_XPD_FORCE::mask;

    /// Position: 13, Width: 1
    /// Access: read-write
    using TSENS_CLK_INV = BitField<13, 1>;
    constexpr uint32_t TSENS_CLK_INV_Pos = 13;
    constexpr uint32_t TSENS_CLK_INV_Msk = TSENS_CLK_INV::mask;

    /// Position: 14, Width: 1
    /// Access: read-write
    using TSENS_CLK_GATED = BitField<14, 1>;
    constexpr uint32_t TSENS_CLK_GATED_Pos = 14;
    constexpr uint32_t TSENS_CLK_GATED_Msk = TSENS_CLK_GATED::mask;

    /// invert temperature sensor data
    /// Position: 15, Width: 1
    /// Access: read-write
    using TSENS_IN_INV = BitField<15, 1>;
    constexpr uint32_t TSENS_IN_INV_Pos = 15;
    constexpr uint32_t TSENS_IN_INV_Msk = TSENS_IN_INV::mask;

    /// temperature sensor clock divider
    /// Position: 16, Width: 8
    /// Access: read-write
    using TSENS_CLK_DIV = BitField<16, 8>;
    constexpr uint32_t TSENS_CLK_DIV_Pos = 16;
    constexpr uint32_t TSENS_CLK_DIV_Msk = TSENS_CLK_DIV::mask;

    /// temperature sensor power up
    /// Position: 24, Width: 1
    /// Access: read-write
    using TSENS_POWER_UP = BitField<24, 1>;
    constexpr uint32_t TSENS_POWER_UP_Pos = 24;
    constexpr uint32_t TSENS_POWER_UP_Msk = TSENS_POWER_UP::mask;

    /// 1: dump out & power up controlled by SW  0: by FSM
    /// Position: 25, Width: 1
    /// Access: read-write
    using TSENS_POWER_UP_FORCE = BitField<25, 1>;
    constexpr uint32_t TSENS_POWER_UP_FORCE_Pos = 25;
    constexpr uint32_t TSENS_POWER_UP_FORCE_Msk = TSENS_POWER_UP_FORCE::mask;

    /// temperature sensor dump out  only active when reg_tsens_power_up_force = 1
    /// Position: 26, Width: 1
    /// Access: read-write
    using TSENS_DUMP_OUT = BitField<26, 1>;
    constexpr uint32_t TSENS_DUMP_OUT_Pos = 26;
    constexpr uint32_t TSENS_DUMP_OUT_Msk = TSENS_DUMP_OUT::mask;

}  // namespace sar_tsens_ctrl

/// SAR_I2C_CTRL - SAR_I2C_CTRL
namespace sar_i2c_ctrl {
    /// I2C control data  only active when reg_sar_i2c_start_force = 1
    /// Position: 0, Width: 28
    /// Access: read-write
    using SAR_I2C_CTRL = BitField<0, 28>;
    constexpr uint32_t SAR_I2C_CTRL_Pos = 0;
    constexpr uint32_t SAR_I2C_CTRL_Msk = SAR_I2C_CTRL::mask;

    /// start I2C  only active when reg_sar_i2c_start_force = 1
    /// Position: 28, Width: 1
    /// Access: read-write
    using SAR_I2C_START = BitField<28, 1>;
    constexpr uint32_t SAR_I2C_START_Pos = 28;
    constexpr uint32_t SAR_I2C_START_Msk = SAR_I2C_START::mask;

    /// 1: I2C started by SW  0: I2C started by FSM
    /// Position: 29, Width: 1
    /// Access: read-write
    using SAR_I2C_START_FORCE = BitField<29, 1>;
    constexpr uint32_t SAR_I2C_START_FORCE_Pos = 29;
    constexpr uint32_t SAR_I2C_START_FORCE_Msk = SAR_I2C_START_FORCE::mask;

}  // namespace sar_i2c_ctrl

/// SAR_MEAS_START1 - SAR_MEAS_START1
namespace sar_meas_start1 {
    /// SAR ADC1 data
    /// Position: 0, Width: 16
    /// Access: read-only
    using MEAS1_DATA_SAR = BitField<0, 16>;
    constexpr uint32_t MEAS1_DATA_SAR_Pos = 0;
    constexpr uint32_t MEAS1_DATA_SAR_Msk = MEAS1_DATA_SAR::mask;

    /// SAR ADC1 conversion done indication
    /// Position: 16, Width: 1
    /// Access: read-only
    using MEAS1_DONE_SAR = BitField<16, 1>;
    constexpr uint32_t MEAS1_DONE_SAR_Pos = 16;
    constexpr uint32_t MEAS1_DONE_SAR_Msk = MEAS1_DONE_SAR::mask;

    /// SAR ADC1 controller (in RTC) starts conversion  only active when reg_meas1_start_force = 1
    /// Position: 17, Width: 1
    /// Access: read-write
    using MEAS1_START_SAR = BitField<17, 1>;
    constexpr uint32_t MEAS1_START_SAR_Pos = 17;
    constexpr uint32_t MEAS1_START_SAR_Msk = MEAS1_START_SAR::mask;

    /// 1: SAR ADC1 controller (in RTC) is started by SW  0: SAR ADC1 controller is started by ULP-coprocessor
    /// Position: 18, Width: 1
    /// Access: read-write
    using MEAS1_START_FORCE = BitField<18, 1>;
    constexpr uint32_t MEAS1_START_FORCE_Pos = 18;
    constexpr uint32_t MEAS1_START_FORCE_Msk = MEAS1_START_FORCE::mask;

    /// SAR ADC1 pad enable bitmap  only active when reg_sar1_en_pad_force = 1
    /// Position: 19, Width: 12
    /// Access: read-write
    using SAR1_EN_PAD = BitField<19, 12>;
    constexpr uint32_t SAR1_EN_PAD_Pos = 19;
    constexpr uint32_t SAR1_EN_PAD_Msk = SAR1_EN_PAD::mask;

    /// 1: SAR ADC1 pad enable bitmap is controlled by SW  0: SAR ADC1 pad enable bitmap is controlled by ULP-coprocessor
    /// Position: 31, Width: 1
    /// Access: read-write
    using SAR1_EN_PAD_FORCE = BitField<31, 1>;
    constexpr uint32_t SAR1_EN_PAD_FORCE_Pos = 31;
    constexpr uint32_t SAR1_EN_PAD_FORCE_Msk = SAR1_EN_PAD_FORCE::mask;

}  // namespace sar_meas_start1

/// SAR_TOUCH_CTRL1 - SAR_TOUCH_CTRL1
namespace sar_touch_ctrl1 {
    /// the meas length (in 8MHz)
    /// Position: 0, Width: 16
    /// Access: read-write
    using TOUCH_MEAS_DELAY = BitField<0, 16>;
    constexpr uint32_t TOUCH_MEAS_DELAY_Pos = 0;
    constexpr uint32_t TOUCH_MEAS_DELAY_Msk = TOUCH_MEAS_DELAY::mask;

    /// the waiting cycles (in 8MHz) between TOUCH_START and TOUCH_XPD
    /// Position: 16, Width: 8
    /// Access: read-write
    using TOUCH_XPD_WAIT = BitField<16, 8>;
    constexpr uint32_t TOUCH_XPD_WAIT_Pos = 16;
    constexpr uint32_t TOUCH_XPD_WAIT_Msk = TOUCH_XPD_WAIT::mask;

    /// 1: when the counter is greater then the threshold  the touch pad is considered as "touched"  0: when the counter is less than the threshold  the touch pad is considered as "touched"
    /// Position: 24, Width: 1
    /// Access: read-write
    using TOUCH_OUT_SEL = BitField<24, 1>;
    constexpr uint32_t TOUCH_OUT_SEL_Pos = 24;
    constexpr uint32_t TOUCH_OUT_SEL_Msk = TOUCH_OUT_SEL::mask;

    /// 1: wakeup interrupt is generated if SET1 is "touched"  0: wakeup interrupt is generated only if SET1 & SET2 is both "touched"
    /// Position: 25, Width: 1
    /// Access: read-write
    using TOUCH_OUT_1EN = BitField<25, 1>;
    constexpr uint32_t TOUCH_OUT_1EN_Pos = 25;
    constexpr uint32_t TOUCH_OUT_1EN_Msk = TOUCH_OUT_1EN::mask;

    /// 1: XPD HALL is controlled by SW. 0: XPD HALL is controlled by FSM in ULP-coprocessor
    /// Position: 26, Width: 1
    /// Access: read-write
    using XPD_HALL_FORCE = BitField<26, 1>;
    constexpr uint32_t XPD_HALL_FORCE_Pos = 26;
    constexpr uint32_t XPD_HALL_FORCE_Msk = XPD_HALL_FORCE::mask;

    /// 1: HALL PHASE is controlled by SW  0: HALL PHASE is controlled by FSM in ULP-coprocessor
    /// Position: 27, Width: 1
    /// Access: read-write
    using HALL_PHASE_FORCE = BitField<27, 1>;
    constexpr uint32_t HALL_PHASE_FORCE_Pos = 27;
    constexpr uint32_t HALL_PHASE_FORCE_Msk = HALL_PHASE_FORCE::mask;

}  // namespace sar_touch_ctrl1

/// SAR_TOUCH_THRES1 - SAR_TOUCH_THRES1
namespace sar_touch_thres1 {
    /// the threshold for touch pad 1
    /// Position: 0, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH1 = BitField<0, 16>;
    constexpr uint32_t TOUCH_OUT_TH1_Pos = 0;
    constexpr uint32_t TOUCH_OUT_TH1_Msk = TOUCH_OUT_TH1::mask;

    /// the threshold for touch pad 0
    /// Position: 16, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH0 = BitField<16, 16>;
    constexpr uint32_t TOUCH_OUT_TH0_Pos = 16;
    constexpr uint32_t TOUCH_OUT_TH0_Msk = TOUCH_OUT_TH0::mask;

}  // namespace sar_touch_thres1

/// SAR_TOUCH_THRES2 - SAR_TOUCH_THRES2
namespace sar_touch_thres2 {
    /// the threshold for touch pad 3
    /// Position: 0, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH3 = BitField<0, 16>;
    constexpr uint32_t TOUCH_OUT_TH3_Pos = 0;
    constexpr uint32_t TOUCH_OUT_TH3_Msk = TOUCH_OUT_TH3::mask;

    /// the threshold for touch pad 2
    /// Position: 16, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH2 = BitField<16, 16>;
    constexpr uint32_t TOUCH_OUT_TH2_Pos = 16;
    constexpr uint32_t TOUCH_OUT_TH2_Msk = TOUCH_OUT_TH2::mask;

}  // namespace sar_touch_thres2

/// SAR_TOUCH_THRES3 - SAR_TOUCH_THRES3
namespace sar_touch_thres3 {
    /// the threshold for touch pad 5
    /// Position: 0, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH5 = BitField<0, 16>;
    constexpr uint32_t TOUCH_OUT_TH5_Pos = 0;
    constexpr uint32_t TOUCH_OUT_TH5_Msk = TOUCH_OUT_TH5::mask;

    /// the threshold for touch pad 4
    /// Position: 16, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH4 = BitField<16, 16>;
    constexpr uint32_t TOUCH_OUT_TH4_Pos = 16;
    constexpr uint32_t TOUCH_OUT_TH4_Msk = TOUCH_OUT_TH4::mask;

}  // namespace sar_touch_thres3

/// SAR_TOUCH_THRES4 - SAR_TOUCH_THRES4
namespace sar_touch_thres4 {
    /// the threshold for touch pad 7
    /// Position: 0, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH7 = BitField<0, 16>;
    constexpr uint32_t TOUCH_OUT_TH7_Pos = 0;
    constexpr uint32_t TOUCH_OUT_TH7_Msk = TOUCH_OUT_TH7::mask;

    /// the threshold for touch pad 6
    /// Position: 16, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH6 = BitField<16, 16>;
    constexpr uint32_t TOUCH_OUT_TH6_Pos = 16;
    constexpr uint32_t TOUCH_OUT_TH6_Msk = TOUCH_OUT_TH6::mask;

}  // namespace sar_touch_thres4

/// SAR_TOUCH_THRES5 - SAR_TOUCH_THRES5
namespace sar_touch_thres5 {
    /// the threshold for touch pad 9
    /// Position: 0, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH9 = BitField<0, 16>;
    constexpr uint32_t TOUCH_OUT_TH9_Pos = 0;
    constexpr uint32_t TOUCH_OUT_TH9_Msk = TOUCH_OUT_TH9::mask;

    /// the threshold for touch pad 8
    /// Position: 16, Width: 16
    /// Access: read-write
    using TOUCH_OUT_TH8 = BitField<16, 16>;
    constexpr uint32_t TOUCH_OUT_TH8_Pos = 16;
    constexpr uint32_t TOUCH_OUT_TH8_Msk = TOUCH_OUT_TH8::mask;

}  // namespace sar_touch_thres5

/// SAR_TOUCH_OUT1 - SAR_TOUCH_OUT1
namespace sar_touch_out1 {
    /// the counter for touch pad 1
    /// Position: 0, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT1 = BitField<0, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT1_Pos = 0;
    constexpr uint32_t TOUCH_MEAS_OUT1_Msk = TOUCH_MEAS_OUT1::mask;

    /// the counter for touch pad 0
    /// Position: 16, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT0 = BitField<16, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT0_Pos = 16;
    constexpr uint32_t TOUCH_MEAS_OUT0_Msk = TOUCH_MEAS_OUT0::mask;

}  // namespace sar_touch_out1

/// SAR_TOUCH_OUT2 - SAR_TOUCH_OUT2
namespace sar_touch_out2 {
    /// the counter for touch pad 3
    /// Position: 0, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT3 = BitField<0, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT3_Pos = 0;
    constexpr uint32_t TOUCH_MEAS_OUT3_Msk = TOUCH_MEAS_OUT3::mask;

    /// the counter for touch pad 2
    /// Position: 16, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT2 = BitField<16, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT2_Pos = 16;
    constexpr uint32_t TOUCH_MEAS_OUT2_Msk = TOUCH_MEAS_OUT2::mask;

}  // namespace sar_touch_out2

/// SAR_TOUCH_OUT3 - SAR_TOUCH_OUT3
namespace sar_touch_out3 {
    /// the counter for touch pad 5
    /// Position: 0, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT5 = BitField<0, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT5_Pos = 0;
    constexpr uint32_t TOUCH_MEAS_OUT5_Msk = TOUCH_MEAS_OUT5::mask;

    /// the counter for touch pad 4
    /// Position: 16, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT4 = BitField<16, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT4_Pos = 16;
    constexpr uint32_t TOUCH_MEAS_OUT4_Msk = TOUCH_MEAS_OUT4::mask;

}  // namespace sar_touch_out3

/// SAR_TOUCH_OUT4 - SAR_TOUCH_OUT4
namespace sar_touch_out4 {
    /// the counter for touch pad 7
    /// Position: 0, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT7 = BitField<0, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT7_Pos = 0;
    constexpr uint32_t TOUCH_MEAS_OUT7_Msk = TOUCH_MEAS_OUT7::mask;

    /// the counter for touch pad 6
    /// Position: 16, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT6 = BitField<16, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT6_Pos = 16;
    constexpr uint32_t TOUCH_MEAS_OUT6_Msk = TOUCH_MEAS_OUT6::mask;

}  // namespace sar_touch_out4

/// SAR_TOUCH_OUT5 - SAR_TOUCH_OUT5
namespace sar_touch_out5 {
    /// the counter for touch pad 9
    /// Position: 0, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT9 = BitField<0, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT9_Pos = 0;
    constexpr uint32_t TOUCH_MEAS_OUT9_Msk = TOUCH_MEAS_OUT9::mask;

    /// the counter for touch pad 8
    /// Position: 16, Width: 16
    /// Access: read-only
    using TOUCH_MEAS_OUT8 = BitField<16, 16>;
    constexpr uint32_t TOUCH_MEAS_OUT8_Pos = 16;
    constexpr uint32_t TOUCH_MEAS_OUT8_Msk = TOUCH_MEAS_OUT8::mask;

}  // namespace sar_touch_out5

/// SAR_TOUCH_CTRL2 - SAR_TOUCH_CTRL2
namespace sar_touch_ctrl2 {
    /// 10-bit register to indicate which pads are "touched"
    /// Position: 0, Width: 10
    /// Access: read-only
    using TOUCH_MEAS_EN = BitField<0, 10>;
    constexpr uint32_t TOUCH_MEAS_EN_Pos = 0;
    constexpr uint32_t TOUCH_MEAS_EN_Msk = TOUCH_MEAS_EN::mask;

    /// fsm set 1 to indicate touch touch meas is done
    /// Position: 10, Width: 1
    /// Access: read-only
    using TOUCH_MEAS_DONE = BitField<10, 1>;
    constexpr uint32_t TOUCH_MEAS_DONE_Pos = 10;
    constexpr uint32_t TOUCH_MEAS_DONE_Msk = TOUCH_MEAS_DONE::mask;

    /// 1: TOUCH_START & TOUCH_XPD is controlled by touch fsm  0: TOUCH_START & TOUCH_XPD is controlled by registers
    /// Position: 11, Width: 1
    /// Access: read-write
    using TOUCH_START_FSM_EN = BitField<11, 1>;
    constexpr uint32_t TOUCH_START_FSM_EN_Pos = 11;
    constexpr uint32_t TOUCH_START_FSM_EN_Msk = TOUCH_START_FSM_EN::mask;

    /// 1: start touch fsm  valid when reg_touch_start_force is set
    /// Position: 12, Width: 1
    /// Access: read-write
    using TOUCH_START_EN = BitField<12, 1>;
    constexpr uint32_t TOUCH_START_EN_Pos = 12;
    constexpr uint32_t TOUCH_START_EN_Msk = TOUCH_START_EN::mask;

    /// 1: to start touch fsm by SW  0: to start touch fsm by timer
    /// Position: 13, Width: 1
    /// Access: read-write
    using TOUCH_START_FORCE = BitField<13, 1>;
    constexpr uint32_t TOUCH_START_FORCE_Pos = 13;
    constexpr uint32_t TOUCH_START_FORCE_Msk = TOUCH_START_FORCE::mask;

    /// sleep cycles for timer
    /// Position: 14, Width: 16
    /// Access: read-write
    using TOUCH_SLEEP_CYCLES = BitField<14, 16>;
    constexpr uint32_t TOUCH_SLEEP_CYCLES_Pos = 14;
    constexpr uint32_t TOUCH_SLEEP_CYCLES_Msk = TOUCH_SLEEP_CYCLES::mask;

    /// to clear reg_touch_meas_en
    /// Position: 30, Width: 1
    /// Access: write-only
    using TOUCH_MEAS_EN_CLR = BitField<30, 1>;
    constexpr uint32_t TOUCH_MEAS_EN_CLR_Pos = 30;
    constexpr uint32_t TOUCH_MEAS_EN_CLR_Msk = TOUCH_MEAS_EN_CLR::mask;

}  // namespace sar_touch_ctrl2

/// SAR_TOUCH_ENABLE - SAR_TOUCH_ENABLE
namespace sar_touch_enable {
    /// Bitmap defining the working set during the measurement.
    /// Position: 0, Width: 10
    /// Access: read-write
    using TOUCH_PAD_WORKEN = BitField<0, 10>;
    constexpr uint32_t TOUCH_PAD_WORKEN_Pos = 0;
    constexpr uint32_t TOUCH_PAD_WORKEN_Msk = TOUCH_PAD_WORKEN::mask;

    /// Bitmap defining SET2 for generating wakeup interrupt. SET2 is "touched" only if at least one of touch pad in SET2 is "touched".
    /// Position: 10, Width: 10
    /// Access: read-write
    using TOUCH_PAD_OUTEN2 = BitField<10, 10>;
    constexpr uint32_t TOUCH_PAD_OUTEN2_Pos = 10;
    constexpr uint32_t TOUCH_PAD_OUTEN2_Msk = TOUCH_PAD_OUTEN2::mask;

    /// Bitmap defining SET1 for generating wakeup interrupt. SET1 is "touched" only if at least one of touch pad in SET1 is "touched".
    /// Position: 20, Width: 10
    /// Access: read-write
    using TOUCH_PAD_OUTEN1 = BitField<20, 10>;
    constexpr uint32_t TOUCH_PAD_OUTEN1_Pos = 20;
    constexpr uint32_t TOUCH_PAD_OUTEN1_Msk = TOUCH_PAD_OUTEN1::mask;

}  // namespace sar_touch_enable

/// SAR_READ_CTRL2 - SAR_READ_CTRL2
namespace sar_read_ctrl2 {
    /// clock divider
    /// Position: 0, Width: 8
    /// Access: read-write
    using SAR2_CLK_DIV = BitField<0, 8>;
    constexpr uint32_t SAR2_CLK_DIV_Pos = 0;
    constexpr uint32_t SAR2_CLK_DIV_Msk = SAR2_CLK_DIV::mask;

    /// sample cycles for SAR ADC2
    /// Position: 8, Width: 8
    /// Access: read-write
    using SAR2_SAMPLE_CYCLE = BitField<8, 8>;
    constexpr uint32_t SAR2_SAMPLE_CYCLE_Pos = 8;
    constexpr uint32_t SAR2_SAMPLE_CYCLE_Msk = SAR2_SAMPLE_CYCLE::mask;

    /// 00: for 9-bit width  01: for 10-bit width  10: for 11-bit width  11: for 12-bit width
    /// Position: 16, Width: 2
    /// Access: read-write
    using SAR2_SAMPLE_BIT = BitField<16, 2>;
    constexpr uint32_t SAR2_SAMPLE_BIT_Pos = 16;
    constexpr uint32_t SAR2_SAMPLE_BIT_Msk = SAR2_SAMPLE_BIT::mask;

    /// Position: 18, Width: 1
    /// Access: read-write
    using SAR2_CLK_GATED = BitField<18, 1>;
    constexpr uint32_t SAR2_CLK_GATED_Pos = 18;
    constexpr uint32_t SAR2_CLK_GATED_Msk = SAR2_CLK_GATED::mask;

    /// Position: 19, Width: 8
    /// Access: read-write
    using SAR2_SAMPLE_NUM = BitField<19, 8>;
    constexpr uint32_t SAR2_SAMPLE_NUM_Pos = 19;
    constexpr uint32_t SAR2_SAMPLE_NUM_Msk = SAR2_SAMPLE_NUM::mask;

    /// Position: 27, Width: 1
    /// Access: read-write
    using SAR2_PWDET_FORCE = BitField<27, 1>;
    constexpr uint32_t SAR2_PWDET_FORCE_Pos = 27;
    constexpr uint32_t SAR2_PWDET_FORCE_Msk = SAR2_PWDET_FORCE::mask;

    /// 1: SAR ADC2 controlled by DIG ADC2 CTRL or PWDET CTRL  0: SAR ADC2 controlled by RTC ADC2 CTRL
    /// Position: 28, Width: 1
    /// Access: read-write
    using SAR2_DIG_FORCE = BitField<28, 1>;
    constexpr uint32_t SAR2_DIG_FORCE_Pos = 28;
    constexpr uint32_t SAR2_DIG_FORCE_Msk = SAR2_DIG_FORCE::mask;

    /// Invert SAR ADC2 data
    /// Position: 29, Width: 1
    /// Access: read-write
    using SAR2_DATA_INV = BitField<29, 1>;
    constexpr uint32_t SAR2_DATA_INV_Pos = 29;
    constexpr uint32_t SAR2_DATA_INV_Msk = SAR2_DATA_INV::mask;

}  // namespace sar_read_ctrl2

/// SAR_MEAS_START2 - SAR_MEAS_START2
namespace sar_meas_start2 {
    /// SAR ADC2 data
    /// Position: 0, Width: 16
    /// Access: read-only
    using MEAS2_DATA_SAR = BitField<0, 16>;
    constexpr uint32_t MEAS2_DATA_SAR_Pos = 0;
    constexpr uint32_t MEAS2_DATA_SAR_Msk = MEAS2_DATA_SAR::mask;

    /// SAR ADC2 conversion done indication
    /// Position: 16, Width: 1
    /// Access: read-only
    using MEAS2_DONE_SAR = BitField<16, 1>;
    constexpr uint32_t MEAS2_DONE_SAR_Pos = 16;
    constexpr uint32_t MEAS2_DONE_SAR_Msk = MEAS2_DONE_SAR::mask;

    /// SAR ADC2 controller (in RTC) starts conversion  only active when reg_meas2_start_force = 1
    /// Position: 17, Width: 1
    /// Access: read-write
    using MEAS2_START_SAR = BitField<17, 1>;
    constexpr uint32_t MEAS2_START_SAR_Pos = 17;
    constexpr uint32_t MEAS2_START_SAR_Msk = MEAS2_START_SAR::mask;

    /// 1: SAR ADC2 controller (in RTC) is started by SW  0: SAR ADC2 controller is started by ULP-coprocessor
    /// Position: 18, Width: 1
    /// Access: read-write
    using MEAS2_START_FORCE = BitField<18, 1>;
    constexpr uint32_t MEAS2_START_FORCE_Pos = 18;
    constexpr uint32_t MEAS2_START_FORCE_Msk = MEAS2_START_FORCE::mask;

    /// SAR ADC2 pad enable bitmap  only active when reg_sar2_en_pad_force = 1
    /// Position: 19, Width: 12
    /// Access: read-write
    using SAR2_EN_PAD = BitField<19, 12>;
    constexpr uint32_t SAR2_EN_PAD_Pos = 19;
    constexpr uint32_t SAR2_EN_PAD_Msk = SAR2_EN_PAD::mask;

    /// 1: SAR ADC2 pad enable bitmap is controlled by SW  0: SAR ADC2 pad enable bitmap is controlled by ULP-coprocessor
    /// Position: 31, Width: 1
    /// Access: read-write
    using SAR2_EN_PAD_FORCE = BitField<31, 1>;
    constexpr uint32_t SAR2_EN_PAD_FORCE_Pos = 31;
    constexpr uint32_t SAR2_EN_PAD_FORCE_Msk = SAR2_EN_PAD_FORCE::mask;

}  // namespace sar_meas_start2

/// SAR_DAC_CTRL1 - SAR_DAC_CTRL1
namespace sar_dac_ctrl1 {
    /// frequency step for CW generator  can be used to adjust the frequency
    /// Position: 0, Width: 16
    /// Access: read-write
    using SW_FSTEP = BitField<0, 16>;
    constexpr uint32_t SW_FSTEP_Pos = 0;
    constexpr uint32_t SW_FSTEP_Msk = SW_FSTEP::mask;

    /// 1: enable CW generator  0: disable CW generator
    /// Position: 16, Width: 1
    /// Access: read-write
    using SW_TONE_EN = BitField<16, 1>;
    constexpr uint32_t SW_TONE_EN_Pos = 16;
    constexpr uint32_t SW_TONE_EN_Msk = SW_TONE_EN::mask;

    /// Position: 17, Width: 5
    /// Access: read-write
    using DEBUG_BIT_SEL = BitField<17, 5>;
    constexpr uint32_t DEBUG_BIT_SEL_Pos = 17;
    constexpr uint32_t DEBUG_BIT_SEL_Msk = DEBUG_BIT_SEL::mask;

    /// 1: DAC1 & DAC2 use DMA  0: DAC1 & DAC2 do not use DMA
    /// Position: 22, Width: 1
    /// Access: read-write
    using DAC_DIG_FORCE = BitField<22, 1>;
    constexpr uint32_t DAC_DIG_FORCE_Pos = 22;
    constexpr uint32_t DAC_DIG_FORCE_Msk = DAC_DIG_FORCE::mask;

    /// 1: force PDAC_CLK to low
    /// Position: 23, Width: 1
    /// Access: read-write
    using DAC_CLK_FORCE_LOW = BitField<23, 1>;
    constexpr uint32_t DAC_CLK_FORCE_LOW_Pos = 23;
    constexpr uint32_t DAC_CLK_FORCE_LOW_Msk = DAC_CLK_FORCE_LOW::mask;

    /// 1: force PDAC_CLK to high
    /// Position: 24, Width: 1
    /// Access: read-write
    using DAC_CLK_FORCE_HIGH = BitField<24, 1>;
    constexpr uint32_t DAC_CLK_FORCE_HIGH_Pos = 24;
    constexpr uint32_t DAC_CLK_FORCE_HIGH_Msk = DAC_CLK_FORCE_HIGH::mask;

    /// 1: invert PDAC_CLK
    /// Position: 25, Width: 1
    /// Access: read-write
    using DAC_CLK_INV = BitField<25, 1>;
    constexpr uint32_t DAC_CLK_INV_Pos = 25;
    constexpr uint32_t DAC_CLK_INV_Msk = DAC_CLK_INV::mask;

}  // namespace sar_dac_ctrl1

/// SAR_DAC_CTRL2 - SAR_DAC_CTRL2
namespace sar_dac_ctrl2 {
    /// DC offset for DAC1 CW generator
    /// Position: 0, Width: 8
    /// Access: read-write
    using DAC_DC1 = BitField<0, 8>;
    constexpr uint32_t DAC_DC1_Pos = 0;
    constexpr uint32_t DAC_DC1_Msk = DAC_DC1::mask;

    /// DC offset for DAC2 CW generator
    /// Position: 8, Width: 8
    /// Access: read-write
    using DAC_DC2 = BitField<8, 8>;
    constexpr uint32_t DAC_DC2_Pos = 8;
    constexpr uint32_t DAC_DC2_Msk = DAC_DC2::mask;

    /// 00: no scale  01: scale to 1/2  10: scale to 1/4  scale to 1/8
    /// Position: 16, Width: 2
    /// Access: read-write
    using DAC_SCALE1 = BitField<16, 2>;
    constexpr uint32_t DAC_SCALE1_Pos = 16;
    constexpr uint32_t DAC_SCALE1_Msk = DAC_SCALE1::mask;

    /// 00: no scale  01: scale to 1/2  10: scale to 1/4  scale to 1/8
    /// Position: 18, Width: 2
    /// Access: read-write
    using DAC_SCALE2 = BitField<18, 2>;
    constexpr uint32_t DAC_SCALE2_Pos = 18;
    constexpr uint32_t DAC_SCALE2_Msk = DAC_SCALE2::mask;

    /// 00: do not invert any bits  01: invert all bits  10: invert MSB  11: invert all bits except MSB
    /// Position: 20, Width: 2
    /// Access: read-write
    using DAC_INV1 = BitField<20, 2>;
    constexpr uint32_t DAC_INV1_Pos = 20;
    constexpr uint32_t DAC_INV1_Msk = DAC_INV1::mask;

    /// 00: do not invert any bits  01: invert all bits  10: invert MSB  11: invert all bits except MSB
    /// Position: 22, Width: 2
    /// Access: read-write
    using DAC_INV2 = BitField<22, 2>;
    constexpr uint32_t DAC_INV2_Pos = 22;
    constexpr uint32_t DAC_INV2_Msk = DAC_INV2::mask;

    /// 1: to select CW generator as source to PDAC1_DAC[7:0]  0: to select register reg_pdac1_dac[7:0] as source to PDAC1_DAC[7:0]
    /// Position: 24, Width: 1
    /// Access: read-write
    using DAC_CW_EN1 = BitField<24, 1>;
    constexpr uint32_t DAC_CW_EN1_Pos = 24;
    constexpr uint32_t DAC_CW_EN1_Msk = DAC_CW_EN1::mask;

    /// 1: to select CW generator as source to PDAC2_DAC[7:0]  0: to select register reg_pdac2_dac[7:0] as source to PDAC2_DAC[7:0]
    /// Position: 25, Width: 1
    /// Access: read-write
    using DAC_CW_EN2 = BitField<25, 1>;
    constexpr uint32_t DAC_CW_EN2_Pos = 25;
    constexpr uint32_t DAC_CW_EN2_Msk = DAC_CW_EN2::mask;

}  // namespace sar_dac_ctrl2

/// SAR_MEAS_CTRL2 - SAR_MEAS_CTRL2
namespace sar_meas_ctrl2 {
    /// Position: 0, Width: 4
    /// Access: read-write
    using SAR1_DAC_XPD_FSM = BitField<0, 4>;
    constexpr uint32_t SAR1_DAC_XPD_FSM_Pos = 0;
    constexpr uint32_t SAR1_DAC_XPD_FSM_Msk = SAR1_DAC_XPD_FSM::mask;

    /// Position: 4, Width: 1
    /// Access: read-write
    using SAR1_DAC_XPD_FSM_IDLE = BitField<4, 1>;
    constexpr uint32_t SAR1_DAC_XPD_FSM_IDLE_Pos = 4;
    constexpr uint32_t SAR1_DAC_XPD_FSM_IDLE_Msk = SAR1_DAC_XPD_FSM_IDLE::mask;

    /// Position: 5, Width: 1
    /// Access: read-write
    using XPD_SAR_AMP_FSM_IDLE = BitField<5, 1>;
    constexpr uint32_t XPD_SAR_AMP_FSM_IDLE_Pos = 5;
    constexpr uint32_t XPD_SAR_AMP_FSM_IDLE_Msk = XPD_SAR_AMP_FSM_IDLE::mask;

    /// Position: 6, Width: 1
    /// Access: read-write
    using AMP_RST_FB_FSM_IDLE = BitField<6, 1>;
    constexpr uint32_t AMP_RST_FB_FSM_IDLE_Pos = 6;
    constexpr uint32_t AMP_RST_FB_FSM_IDLE_Msk = AMP_RST_FB_FSM_IDLE::mask;

    /// Position: 7, Width: 1
    /// Access: read-write
    using AMP_SHORT_REF_FSM_IDLE = BitField<7, 1>;
    constexpr uint32_t AMP_SHORT_REF_FSM_IDLE_Pos = 7;
    constexpr uint32_t AMP_SHORT_REF_FSM_IDLE_Msk = AMP_SHORT_REF_FSM_IDLE::mask;

    /// Position: 8, Width: 1
    /// Access: read-write
    using AMP_SHORT_REF_GND_FSM_IDLE = BitField<8, 1>;
    constexpr uint32_t AMP_SHORT_REF_GND_FSM_IDLE_Pos = 8;
    constexpr uint32_t AMP_SHORT_REF_GND_FSM_IDLE_Msk = AMP_SHORT_REF_GND_FSM_IDLE::mask;

    /// Position: 9, Width: 1
    /// Access: read-write
    using XPD_SAR_FSM_IDLE = BitField<9, 1>;
    constexpr uint32_t XPD_SAR_FSM_IDLE_Pos = 9;
    constexpr uint32_t XPD_SAR_FSM_IDLE_Msk = XPD_SAR_FSM_IDLE::mask;

    /// Position: 10, Width: 1
    /// Access: read-write
    using SAR_RSTB_FSM_IDLE = BitField<10, 1>;
    constexpr uint32_t SAR_RSTB_FSM_IDLE_Pos = 10;
    constexpr uint32_t SAR_RSTB_FSM_IDLE_Msk = SAR_RSTB_FSM_IDLE::mask;

    /// Position: 11, Width: 2
    /// Access: read-write
    using SAR2_RSTB_FORCE = BitField<11, 2>;
    constexpr uint32_t SAR2_RSTB_FORCE_Pos = 11;
    constexpr uint32_t SAR2_RSTB_FORCE_Msk = SAR2_RSTB_FORCE::mask;

    /// Position: 13, Width: 2
    /// Access: read-write
    using AMP_RST_FB_FORCE = BitField<13, 2>;
    constexpr uint32_t AMP_RST_FB_FORCE_Pos = 13;
    constexpr uint32_t AMP_RST_FB_FORCE_Msk = AMP_RST_FB_FORCE::mask;

    /// Position: 15, Width: 2
    /// Access: read-write
    using AMP_SHORT_REF_FORCE = BitField<15, 2>;
    constexpr uint32_t AMP_SHORT_REF_FORCE_Pos = 15;
    constexpr uint32_t AMP_SHORT_REF_FORCE_Msk = AMP_SHORT_REF_FORCE::mask;

    /// Position: 17, Width: 2
    /// Access: read-write
    using AMP_SHORT_REF_GND_FORCE = BitField<17, 2>;
    constexpr uint32_t AMP_SHORT_REF_GND_FORCE_Pos = 17;
    constexpr uint32_t AMP_SHORT_REF_GND_FORCE_Msk = AMP_SHORT_REF_GND_FORCE::mask;

}  // namespace sar_meas_ctrl2

/// SAR_NOUSE - SAR_NOUSE
namespace sar_nouse {
    /// Position: 0, Width: 32
    /// Access: read-write
    using SAR_NOUSE = BitField<0, 32>;
    constexpr uint32_t SAR_NOUSE_Pos = 0;
    constexpr uint32_t SAR_NOUSE_Msk = SAR_NOUSE::mask;

}  // namespace sar_nouse

/// SARDATE - SARDATE
namespace sardate {
    /// Position: 0, Width: 28
    /// Access: read-write
    using SAR_DATE = BitField<0, 28>;
    constexpr uint32_t SAR_DATE_Pos = 0;
    constexpr uint32_t SAR_DATE_Msk = SAR_DATE::mask;

}  // namespace sardate

}  // namespace alloy::hal::espressif::esp32::esp32::sens
