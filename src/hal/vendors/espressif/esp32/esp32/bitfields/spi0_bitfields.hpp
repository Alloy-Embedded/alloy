/// Auto-generated bit field definitions for SPI0
/// Device: ESP32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "bitfield_utils.hpp"

namespace alloy::hal::espressif::esp32::esp32::spi0 {

using namespace alloy::hal::bitfields;

// ============================================================================
// SPI0 Bit Field Definitions
// ============================================================================

/// CMD - CMD
namespace cmd {
    /// program erase resume bit  program erase suspend operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 16, Width: 1
    /// Access: read-write
    using FLASH_PER = BitField<16, 1>;
    constexpr uint32_t FLASH_PER_Pos = 16;
    constexpr uint32_t FLASH_PER_Msk = FLASH_PER::mask;

    /// program erase suspend bit  program erase suspend operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 17, Width: 1
    /// Access: read-write
    using FLASH_PES = BitField<17, 1>;
    constexpr uint32_t FLASH_PES_Pos = 17;
    constexpr uint32_t FLASH_PES_Msk = FLASH_PES::mask;

    /// User define command enable.  An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 18, Width: 1
    /// Access: read-write
    using USR = BitField<18, 1>;
    constexpr uint32_t USR_Pos = 18;
    constexpr uint32_t USR_Msk = USR::mask;

    /// Drive Flash into high performance mode.  The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 19, Width: 1
    /// Access: read-write
    using FLASH_HPM = BitField<19, 1>;
    constexpr uint32_t FLASH_HPM_Pos = 19;
    constexpr uint32_t FLASH_HPM_Msk = FLASH_HPM::mask;

    /// This bit combined with reg_resandres bit releases Flash from the power-down state or high performance mode and obtains the devices ID. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 20, Width: 1
    /// Access: read-write
    using FLASH_RES = BitField<20, 1>;
    constexpr uint32_t FLASH_RES_Pos = 20;
    constexpr uint32_t FLASH_RES_Msk = FLASH_RES::mask;

    /// Drive Flash into power down.  An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 21, Width: 1
    /// Access: read-write
    using FLASH_DP = BitField<21, 1>;
    constexpr uint32_t FLASH_DP_Pos = 21;
    constexpr uint32_t FLASH_DP_Msk = FLASH_DP::mask;

    /// Chip erase enable. Chip erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 22, Width: 1
    /// Access: read-write
    using FLASH_CE = BitField<22, 1>;
    constexpr uint32_t FLASH_CE_Pos = 22;
    constexpr uint32_t FLASH_CE_Msk = FLASH_CE::mask;

    /// Block erase enable. A 64KB block is erased via SPI command D8H.  Block erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 23, Width: 1
    /// Access: read-write
    using FLASH_BE = BitField<23, 1>;
    constexpr uint32_t FLASH_BE_Pos = 23;
    constexpr uint32_t FLASH_BE_Msk = FLASH_BE::mask;

    /// Sector erase enable. A 4KB sector is erased via SPI command 20H. Sector erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 24, Width: 1
    /// Access: read-write
    using FLASH_SE = BitField<24, 1>;
    constexpr uint32_t FLASH_SE_Pos = 24;
    constexpr uint32_t FLASH_SE_Msk = FLASH_SE::mask;

    /// Page program enable(1 byte ~256 bytes data to be programmed). Page program operation  will be triggered when the bit is set. The bit will be cleared once the operation done .1: enable 0: disable.
    /// Position: 25, Width: 1
    /// Access: read-write
    using FLASH_PP = BitField<25, 1>;
    constexpr uint32_t FLASH_PP_Pos = 25;
    constexpr uint32_t FLASH_PP_Msk = FLASH_PP::mask;

    /// Write status register enable.   Write status operation  will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 26, Width: 1
    /// Access: read-write
    using FLASH_WRSR = BitField<26, 1>;
    constexpr uint32_t FLASH_WRSR_Pos = 26;
    constexpr uint32_t FLASH_WRSR_Msk = FLASH_WRSR::mask;

    /// Read status register-1.  Read status operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
    /// Position: 27, Width: 1
    /// Access: read-write
    using FLASH_RDSR = BitField<27, 1>;
    constexpr uint32_t FLASH_RDSR_Pos = 27;
    constexpr uint32_t FLASH_RDSR_Msk = FLASH_RDSR::mask;

    /// Read JEDEC ID . Read ID command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
    /// Position: 28, Width: 1
    /// Access: read-write
    using FLASH_RDID = BitField<28, 1>;
    constexpr uint32_t FLASH_RDID_Pos = 28;
    constexpr uint32_t FLASH_RDID_Msk = FLASH_RDID::mask;

    /// Write flash disable. Write disable command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
    /// Position: 29, Width: 1
    /// Access: read-write
    using FLASH_WRDI = BitField<29, 1>;
    constexpr uint32_t FLASH_WRDI_Pos = 29;
    constexpr uint32_t FLASH_WRDI_Msk = FLASH_WRDI::mask;

    /// Write flash enable.  Write enable command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
    /// Position: 30, Width: 1
    /// Access: read-write
    using FLASH_WREN = BitField<30, 1>;
    constexpr uint32_t FLASH_WREN_Pos = 30;
    constexpr uint32_t FLASH_WREN_Msk = FLASH_WREN::mask;

    /// Read flash enable. Read flash operation will be triggered when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
    /// Position: 31, Width: 1
    /// Access: read-write
    using FLASH_READ = BitField<31, 1>;
    constexpr uint32_t FLASH_READ_Pos = 31;
    constexpr uint32_t FLASH_READ_Msk = FLASH_READ::mask;

}  // namespace cmd

/// CTRL - CTRL
namespace ctrl {
    /// For SPI1  initialize crc32 module before writing encrypted data to flash. Active low.
    /// Position: 10, Width: 1
    /// Access: read-write
    using FCS_CRC_EN = BitField<10, 1>;
    constexpr uint32_t FCS_CRC_EN_Pos = 10;
    constexpr uint32_t FCS_CRC_EN_Msk = FCS_CRC_EN::mask;

    /// For SPI1  enable crc32 when writing encrypted data to flash. 1: enable  0:disable
    /// Position: 11, Width: 1
    /// Access: read-write
    using TX_CRC_EN = BitField<11, 1>;
    constexpr uint32_t TX_CRC_EN_Pos = 11;
    constexpr uint32_t TX_CRC_EN_Msk = TX_CRC_EN::mask;

    /// wait flash idle when program flash or erase flash. 1: enable 0: disable.
    /// Position: 12, Width: 1
    /// Access: read-write
    using WAIT_FLASH_IDLE_EN = BitField<12, 1>;
    constexpr uint32_t WAIT_FLASH_IDLE_EN_Pos = 12;
    constexpr uint32_t WAIT_FLASH_IDLE_EN_Msk = WAIT_FLASH_IDLE_EN::mask;

    /// This bit enable the bits: spi_fread_qio  spi_fread_dio  spi_fread_qout and spi_fread_dout. 1: enable 0: disable.
    /// Position: 13, Width: 1
    /// Access: read-write
    using FASTRD_MODE = BitField<13, 1>;
    constexpr uint32_t FASTRD_MODE_Pos = 13;
    constexpr uint32_t FASTRD_MODE_Msk = FASTRD_MODE::mask;

    /// In the read operations  read-data phase apply 2 signals. 1: enable 0: disable.
    /// Position: 14, Width: 1
    /// Access: read-write
    using FREAD_DUAL = BitField<14, 1>;
    constexpr uint32_t FREAD_DUAL_Pos = 14;
    constexpr uint32_t FREAD_DUAL_Msk = FREAD_DUAL::mask;

    /// The Device ID is read out to SPI_RD_STATUS register, this bit combine with spi_flash_res bit. 1: enable 0: disable.
    /// Position: 15, Width: 1
    /// Access: read-write
    using RESANDRES = BitField<15, 1>;
    constexpr uint32_t RESANDRES_Pos = 15;
    constexpr uint32_t RESANDRES_Msk = RESANDRES::mask;

    /// In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
    /// Position: 20, Width: 1
    /// Access: read-write
    using FREAD_QUAD = BitField<20, 1>;
    constexpr uint32_t FREAD_QUAD_Pos = 20;
    constexpr uint32_t FREAD_QUAD_Msk = FREAD_QUAD::mask;

    /// Write protect signal output when SPI is idle.  1: output high  0: output low.
    /// Position: 21, Width: 1
    /// Access: read-write
    using WP = BitField<21, 1>;
    constexpr uint32_t WP_Pos = 21;
    constexpr uint32_t WP_Msk = WP::mask;

    /// two bytes data will be written to status register when it is set. 1: enable 0: disable.
    /// Position: 22, Width: 1
    /// Access: read-write
    using WRSR_2B = BitField<22, 1>;
    constexpr uint32_t WRSR_2B_Pos = 22;
    constexpr uint32_t WRSR_2B_Msk = WRSR_2B::mask;

    /// In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
    /// Position: 23, Width: 1
    /// Access: read-write
    using FREAD_DIO = BitField<23, 1>;
    constexpr uint32_t FREAD_DIO_Pos = 23;
    constexpr uint32_t FREAD_DIO_Msk = FREAD_DIO::mask;

    /// In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
    /// Position: 24, Width: 1
    /// Access: read-write
    using FREAD_QIO = BitField<24, 1>;
    constexpr uint32_t FREAD_QIO_Pos = 24;
    constexpr uint32_t FREAD_QIO_Msk = FREAD_QIO::mask;

    /// In read-data (MISO) phase 1: LSB first 0: MSB first
    /// Position: 25, Width: 1
    /// Access: read-write
    using RD_BIT_ORDER = BitField<25, 1>;
    constexpr uint32_t RD_BIT_ORDER_Pos = 25;
    constexpr uint32_t RD_BIT_ORDER_Msk = RD_BIT_ORDER::mask;

    /// In command address write-data (MOSI) phases 1: LSB firs 0: MSB first
    /// Position: 26, Width: 1
    /// Access: read-write
    using WR_BIT_ORDER = BitField<26, 1>;
    constexpr uint32_t WR_BIT_ORDER_Pos = 26;
    constexpr uint32_t WR_BIT_ORDER_Msk = WR_BIT_ORDER::mask;

}  // namespace ctrl

/// CTRL1 - CTRL1
namespace ctrl1 {
    /// Delay cycles of resume Flash when resume Flash is enable by spi clock.
    /// Position: 16, Width: 12
    /// Access: read-write
    using CS_HOLD_DELAY_RES = BitField<16, 12>;
    constexpr uint32_t CS_HOLD_DELAY_RES_Pos = 16;
    constexpr uint32_t CS_HOLD_DELAY_RES_Msk = CS_HOLD_DELAY_RES::mask;

    /// SPI cs signal is delayed by spi clock cycles
    /// Position: 28, Width: 4
    /// Access: read-write
    using CS_HOLD_DELAY = BitField<28, 4>;
    constexpr uint32_t CS_HOLD_DELAY_Pos = 28;
    constexpr uint32_t CS_HOLD_DELAY_Msk = CS_HOLD_DELAY::mask;

}  // namespace ctrl1

/// RD_STATUS - RD_STATUS
namespace rd_status {
    /// In the slave mode, it is the status for master to read out.
    /// Position: 0, Width: 16
    /// Access: read-write
    using STATUS = BitField<0, 16>;
    constexpr uint32_t STATUS_Pos = 0;
    constexpr uint32_t STATUS_Msk = STATUS::mask;

    /// Mode bits in the flash fast read mode, it is combined with spi_fastrd_mode bit.
    /// Position: 16, Width: 8
    /// Access: read-write
    using WB_MODE = BitField<16, 8>;
    constexpr uint32_t WB_MODE_Pos = 16;
    constexpr uint32_t WB_MODE_Msk = WB_MODE::mask;

    /// In the slave mode,it is the status for master to read out.
    /// Position: 24, Width: 8
    /// Access: read-write
    using STATUS_EXT = BitField<24, 8>;
    constexpr uint32_t STATUS_EXT_Pos = 24;
    constexpr uint32_t STATUS_EXT_Msk = STATUS_EXT::mask;

}  // namespace rd_status

/// CTRL2 - CTRL2
namespace ctrl2 {
    /// (cycles-1) of ¡°prepare¡± phase by spi clock, this bits combined with spi_cs_setup bit.
    /// Position: 0, Width: 4
    /// Access: read-write
    using SETUP_TIME = BitField<0, 4>;
    constexpr uint32_t SETUP_TIME_Pos = 0;
    constexpr uint32_t SETUP_TIME_Msk = SETUP_TIME::mask;

    /// delay cycles of cs pin by spi clock, this bits combined with spi_cs_hold bit.
    /// Position: 4, Width: 4
    /// Access: read-write
    using HOLD_TIME = BitField<4, 4>;
    constexpr uint32_t HOLD_TIME_Pos = 4;
    constexpr uint32_t HOLD_TIME_Msk = HOLD_TIME::mask;

    /// modify spi clock duty ratio when the value is lager than 8, the bits are combined with spi_clkcnt_N bits and spi_clkcnt_L bits.
    /// Position: 8, Width: 4
    /// Access: read-write
    using CK_OUT_LOW_MODE = BitField<8, 4>;
    constexpr uint32_t CK_OUT_LOW_MODE_Pos = 8;
    constexpr uint32_t CK_OUT_LOW_MODE_Msk = CK_OUT_LOW_MODE::mask;

    /// modify spi clock duty ratio when the value is lager than 8, the bits are combined with spi_clkcnt_N bits and spi_clkcnt_H bits.
    /// Position: 12, Width: 4
    /// Access: read-write
    using CK_OUT_HIGH_MODE = BitField<12, 4>;
    constexpr uint32_t CK_OUT_HIGH_MODE_Pos = 12;
    constexpr uint32_t CK_OUT_HIGH_MODE_Msk = CK_OUT_HIGH_MODE::mask;

    /// MISO signals are delayed by spi_clk. 0: zero  1: if spi_ck_out_edge or spi_ck_i_edge is set 1  delayed by half cycle    else delayed by one cycle  2: if spi_ck_out_edge or spi_ck_i_edge is set 1  delayed by one cycle  else delayed by half cycle  3: delayed one cycle
    /// Position: 16, Width: 2
    /// Access: read-write
    using MISO_DELAY_MODE = BitField<16, 2>;
    constexpr uint32_t MISO_DELAY_MODE_Pos = 16;
    constexpr uint32_t MISO_DELAY_MODE_Msk = MISO_DELAY_MODE::mask;

    /// MISO signals are delayed by system clock cycles
    /// Position: 18, Width: 3
    /// Access: read-write
    using MISO_DELAY_NUM = BitField<18, 3>;
    constexpr uint32_t MISO_DELAY_NUM_Pos = 18;
    constexpr uint32_t MISO_DELAY_NUM_Msk = MISO_DELAY_NUM::mask;

    /// MOSI signals are delayed by spi_clk. 0: zero  1: if spi_ck_out_edge or spi_ck_i_edge is set 1  delayed by half cycle    else delayed by one cycle  2: if spi_ck_out_edge or spi_ck_i_edge is set 1  delayed by one cycle  else delayed by half cycle  3: delayed one cycle
    /// Position: 21, Width: 2
    /// Access: read-write
    using MOSI_DELAY_MODE = BitField<21, 2>;
    constexpr uint32_t MOSI_DELAY_MODE_Pos = 21;
    constexpr uint32_t MOSI_DELAY_MODE_Msk = MOSI_DELAY_MODE::mask;

    /// MOSI signals are delayed by system clock cycles
    /// Position: 23, Width: 3
    /// Access: read-write
    using MOSI_DELAY_NUM = BitField<23, 3>;
    constexpr uint32_t MOSI_DELAY_NUM_Pos = 23;
    constexpr uint32_t MOSI_DELAY_NUM_Msk = MOSI_DELAY_NUM::mask;

    /// spi_cs signal is delayed by spi_clk . 0: zero  1: if spi_ck_out_edge or spi_ck_i_edge is set 1  delayed by half cycle    else delayed by one cycle  2: if spi_ck_out_edge or spi_ck_i_edge is set 1  delayed by one cycle   else delayed by half cycle  3: delayed one cycle
    /// Position: 26, Width: 2
    /// Access: read-write
    using CS_DELAY_MODE = BitField<26, 2>;
    constexpr uint32_t CS_DELAY_MODE_Pos = 26;
    constexpr uint32_t CS_DELAY_MODE_Msk = CS_DELAY_MODE::mask;

    /// spi_cs signal is delayed by system clock cycles
    /// Position: 28, Width: 4
    /// Access: read-write
    using CS_DELAY_NUM = BitField<28, 4>;
    constexpr uint32_t CS_DELAY_NUM_Pos = 28;
    constexpr uint32_t CS_DELAY_NUM_Msk = CS_DELAY_NUM::mask;

}  // namespace ctrl2

/// CLOCK - CLOCK
namespace clock {
    /// In the master mode it must be equal to spi_clkcnt_N. In the slave mode it must be 0.
    /// Position: 0, Width: 6
    /// Access: read-write
    using CLKCNT_L = BitField<0, 6>;
    constexpr uint32_t CLKCNT_L_Pos = 0;
    constexpr uint32_t CLKCNT_L_Msk = CLKCNT_L::mask;

    /// In the master mode it must be floor((spi_clkcnt_N+1)/2-1). In the slave mode it must be 0.
    /// Position: 6, Width: 6
    /// Access: read-write
    using CLKCNT_H = BitField<6, 6>;
    constexpr uint32_t CLKCNT_H_Pos = 6;
    constexpr uint32_t CLKCNT_H_Msk = CLKCNT_H::mask;

    /// In the master mode it is the divider of spi_clk. So spi_clk frequency is system/(spi_clkdiv_pre+1)/(spi_clkcnt_N+1)
    /// Position: 12, Width: 6
    /// Access: read-write
    using CLKCNT_N = BitField<12, 6>;
    constexpr uint32_t CLKCNT_N_Pos = 12;
    constexpr uint32_t CLKCNT_N_Msk = CLKCNT_N::mask;

    /// In the master mode it is pre-divider of spi_clk.
    /// Position: 18, Width: 13
    /// Access: read-write
    using CLKDIV_PRE = BitField<18, 13>;
    constexpr uint32_t CLKDIV_PRE_Pos = 18;
    constexpr uint32_t CLKDIV_PRE_Msk = CLKDIV_PRE::mask;

    /// In the master mode 1: spi_clk is eqaul to system 0: spi_clk is divided from system clock.
    /// Position: 31, Width: 1
    /// Access: read-write
    using CLK_EQU_SYSCLK = BitField<31, 1>;
    constexpr uint32_t CLK_EQU_SYSCLK_Pos = 31;
    constexpr uint32_t CLK_EQU_SYSCLK_Msk = CLK_EQU_SYSCLK::mask;

}  // namespace clock

/// USER - USER
namespace user {
    /// Set the bit to enable full duplex communication. 1: enable 0: disable.
    /// Position: 0, Width: 1
    /// Access: read-write
    using DOUTDIN = BitField<0, 1>;
    constexpr uint32_t DOUTDIN_Pos = 0;
    constexpr uint32_t DOUTDIN_Msk = DOUTDIN::mask;

    /// spi cs keep low when spi is in ¡°done¡± phase. 1: enable 0: disable.
    /// Position: 4, Width: 1
    /// Access: read-write
    using CS_HOLD = BitField<4, 1>;
    constexpr uint32_t CS_HOLD_Pos = 4;
    constexpr uint32_t CS_HOLD_Msk = CS_HOLD::mask;

    /// spi cs is enable when spi is in ¡°prepare¡± phase. 1: enable 0: disable.
    /// Position: 5, Width: 1
    /// Access: read-write
    using CS_SETUP = BitField<5, 1>;
    constexpr uint32_t CS_SETUP_Pos = 5;
    constexpr uint32_t CS_SETUP_Msk = CS_SETUP::mask;

    /// In the slave mode  the bit is same as spi_ck_out_edge in master mode. It is combined with  spi_miso_delay_mode bits.
    /// Position: 6, Width: 1
    /// Access: read-write
    using CK_I_EDGE = BitField<6, 1>;
    constexpr uint32_t CK_I_EDGE_Pos = 6;
    constexpr uint32_t CK_I_EDGE_Msk = CK_I_EDGE::mask;

    /// the bit combined with spi_mosi_delay_mode bits to set mosi signal delay mode.
    /// Position: 7, Width: 1
    /// Access: read-write
    using CK_OUT_EDGE = BitField<7, 1>;
    constexpr uint32_t CK_OUT_EDGE_Pos = 7;
    constexpr uint32_t CK_OUT_EDGE_Msk = CK_OUT_EDGE::mask;

    /// In read-data (MISO) phase 1: big-endian 0: little_endian
    /// Position: 10, Width: 1
    /// Access: read-write
    using RD_BYTE_ORDER = BitField<10, 1>;
    constexpr uint32_t RD_BYTE_ORDER_Pos = 10;
    constexpr uint32_t RD_BYTE_ORDER_Msk = RD_BYTE_ORDER::mask;

    /// In command address write-data (MOSI) phases 1: big-endian 0: litte_endian
    /// Position: 11, Width: 1
    /// Access: read-write
    using WR_BYTE_ORDER = BitField<11, 1>;
    constexpr uint32_t WR_BYTE_ORDER_Pos = 11;
    constexpr uint32_t WR_BYTE_ORDER_Msk = WR_BYTE_ORDER::mask;

    /// In the write operations read-data phase apply 2 signals
    /// Position: 12, Width: 1
    /// Access: read-write
    using FWRITE_DUAL = BitField<12, 1>;
    constexpr uint32_t FWRITE_DUAL_Pos = 12;
    constexpr uint32_t FWRITE_DUAL_Msk = FWRITE_DUAL::mask;

    /// In the write operations read-data phase apply 4 signals
    /// Position: 13, Width: 1
    /// Access: read-write
    using FWRITE_QUAD = BitField<13, 1>;
    constexpr uint32_t FWRITE_QUAD_Pos = 13;
    constexpr uint32_t FWRITE_QUAD_Msk = FWRITE_QUAD::mask;

    /// In the write operations address phase and read-data phase apply 2 signals.
    /// Position: 14, Width: 1
    /// Access: read-write
    using FWRITE_DIO = BitField<14, 1>;
    constexpr uint32_t FWRITE_DIO_Pos = 14;
    constexpr uint32_t FWRITE_DIO_Msk = FWRITE_DIO::mask;

    /// In the write operations address phase and read-data phase apply 4 signals.
    /// Position: 15, Width: 1
    /// Access: read-write
    using FWRITE_QIO = BitField<15, 1>;
    constexpr uint32_t FWRITE_QIO_Pos = 15;
    constexpr uint32_t FWRITE_QIO_Msk = FWRITE_QIO::mask;

    /// Set the bit to enable 3-line half duplex communication  mosi and miso signals share the same pin. 1: enable 0: disable.
    /// Position: 16, Width: 1
    /// Access: read-write
    using SIO = BitField<16, 1>;
    constexpr uint32_t SIO_Pos = 16;
    constexpr uint32_t SIO_Msk = SIO::mask;

    /// It is combined with hold bits to set the polarity of spi hold line  1: spi will be held when spi hold line is high  0: spi will be held when spi hold line is low
    /// Position: 17, Width: 1
    /// Access: read-write
    using USR_HOLD_POL = BitField<17, 1>;
    constexpr uint32_t USR_HOLD_POL_Pos = 17;
    constexpr uint32_t USR_HOLD_POL_Msk = USR_HOLD_POL::mask;

    /// spi is hold at data out state  the bit combined with spi_usr_hold_pol bit.
    /// Position: 18, Width: 1
    /// Access: read-write
    using USR_DOUT_HOLD = BitField<18, 1>;
    constexpr uint32_t USR_DOUT_HOLD_Pos = 18;
    constexpr uint32_t USR_DOUT_HOLD_Msk = USR_DOUT_HOLD::mask;

    /// spi is hold at data in state  the bit combined with spi_usr_hold_pol bit.
    /// Position: 19, Width: 1
    /// Access: read-write
    using USR_DIN_HOLD = BitField<19, 1>;
    constexpr uint32_t USR_DIN_HOLD_Pos = 19;
    constexpr uint32_t USR_DIN_HOLD_Msk = USR_DIN_HOLD::mask;

    /// spi is hold at dummy state  the bit combined with spi_usr_hold_pol bit.
    /// Position: 20, Width: 1
    /// Access: read-write
    using USR_DUMMY_HOLD = BitField<20, 1>;
    constexpr uint32_t USR_DUMMY_HOLD_Pos = 20;
    constexpr uint32_t USR_DUMMY_HOLD_Msk = USR_DUMMY_HOLD::mask;

    /// spi is hold at address state  the bit combined with spi_usr_hold_pol bit.
    /// Position: 21, Width: 1
    /// Access: read-write
    using USR_ADDR_HOLD = BitField<21, 1>;
    constexpr uint32_t USR_ADDR_HOLD_Pos = 21;
    constexpr uint32_t USR_ADDR_HOLD_Msk = USR_ADDR_HOLD::mask;

    /// spi is hold at command state  the bit combined with spi_usr_hold_pol bit.
    /// Position: 22, Width: 1
    /// Access: read-write
    using USR_CMD_HOLD = BitField<22, 1>;
    constexpr uint32_t USR_CMD_HOLD_Pos = 22;
    constexpr uint32_t USR_CMD_HOLD_Msk = USR_CMD_HOLD::mask;

    /// spi is hold at prepare state  the bit combined with spi_usr_hold_pol bit.
    /// Position: 23, Width: 1
    /// Access: read-write
    using USR_PREP_HOLD = BitField<23, 1>;
    constexpr uint32_t USR_PREP_HOLD_Pos = 23;
    constexpr uint32_t USR_PREP_HOLD_Msk = USR_PREP_HOLD::mask;

    /// read-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable 0: disable.
    /// Position: 24, Width: 1
    /// Access: read-write
    using USR_MISO_HIGHPART = BitField<24, 1>;
    constexpr uint32_t USR_MISO_HIGHPART_Pos = 24;
    constexpr uint32_t USR_MISO_HIGHPART_Msk = USR_MISO_HIGHPART::mask;

    /// write-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable 0: disable.
    /// Position: 25, Width: 1
    /// Access: read-write
    using USR_MOSI_HIGHPART = BitField<25, 1>;
    constexpr uint32_t USR_MOSI_HIGHPART_Pos = 25;
    constexpr uint32_t USR_MOSI_HIGHPART_Msk = USR_MOSI_HIGHPART::mask;

    /// spi clock is disable in dummy phase when the bit is enable.
    /// Position: 26, Width: 1
    /// Access: read-write
    using USR_DUMMY_IDLE = BitField<26, 1>;
    constexpr uint32_t USR_DUMMY_IDLE_Pos = 26;
    constexpr uint32_t USR_DUMMY_IDLE_Msk = USR_DUMMY_IDLE::mask;

    /// This bit enable the write-data phase of an operation.
    /// Position: 27, Width: 1
    /// Access: read-write
    using USR_MOSI = BitField<27, 1>;
    constexpr uint32_t USR_MOSI_Pos = 27;
    constexpr uint32_t USR_MOSI_Msk = USR_MOSI::mask;

    /// This bit enable the read-data phase of an operation.
    /// Position: 28, Width: 1
    /// Access: read-write
    using USR_MISO = BitField<28, 1>;
    constexpr uint32_t USR_MISO_Pos = 28;
    constexpr uint32_t USR_MISO_Msk = USR_MISO::mask;

    /// This bit enable the dummy phase of an operation.
    /// Position: 29, Width: 1
    /// Access: read-write
    using USR_DUMMY = BitField<29, 1>;
    constexpr uint32_t USR_DUMMY_Pos = 29;
    constexpr uint32_t USR_DUMMY_Msk = USR_DUMMY::mask;

    /// This bit enable the address phase of an operation.
    /// Position: 30, Width: 1
    /// Access: read-write
    using USR_ADDR = BitField<30, 1>;
    constexpr uint32_t USR_ADDR_Pos = 30;
    constexpr uint32_t USR_ADDR_Msk = USR_ADDR::mask;

    /// This bit enable the command phase of an operation.
    /// Position: 31, Width: 1
    /// Access: read-write
    using USR_COMMAND = BitField<31, 1>;
    constexpr uint32_t USR_COMMAND_Pos = 31;
    constexpr uint32_t USR_COMMAND_Msk = USR_COMMAND::mask;

}  // namespace user

/// USER1 - USER1
namespace user1 {
    /// The length in spi_clk cycles of dummy phase. The register value shall be (cycle_num-1).
    /// Position: 0, Width: 8
    /// Access: read-write
    using USR_DUMMY_CYCLELEN = BitField<0, 8>;
    constexpr uint32_t USR_DUMMY_CYCLELEN_Pos = 0;
    constexpr uint32_t USR_DUMMY_CYCLELEN_Msk = USR_DUMMY_CYCLELEN::mask;

    /// The length in bits of address phase. The register value shall be (bit_num-1).
    /// Position: 26, Width: 6
    /// Access: read-only
    using USR_ADDR_BITLEN = BitField<26, 6>;
    constexpr uint32_t USR_ADDR_BITLEN_Pos = 26;
    constexpr uint32_t USR_ADDR_BITLEN_Msk = USR_ADDR_BITLEN::mask;

}  // namespace user1

/// USER2 - USER2
namespace user2 {
    /// The value of  command.
    /// Position: 0, Width: 16
    /// Access: read-write
    using USR_COMMAND_VALUE = BitField<0, 16>;
    constexpr uint32_t USR_COMMAND_VALUE_Pos = 0;
    constexpr uint32_t USR_COMMAND_VALUE_Msk = USR_COMMAND_VALUE::mask;

    /// The length in bits of command phase. The register value shall be (bit_num-1)
    /// Position: 28, Width: 4
    /// Access: read-write
    using USR_COMMAND_BITLEN = BitField<28, 4>;
    constexpr uint32_t USR_COMMAND_BITLEN_Pos = 28;
    constexpr uint32_t USR_COMMAND_BITLEN_Msk = USR_COMMAND_BITLEN::mask;

}  // namespace user2

/// MOSI_DLEN - MOSI_DLEN
namespace mosi_dlen {
    /// The length in bits of write-data. The register value shall be (bit_num-1).
    /// Position: 0, Width: 24
    /// Access: read-write
    using USR_MOSI_DBITLEN = BitField<0, 24>;
    constexpr uint32_t USR_MOSI_DBITLEN_Pos = 0;
    constexpr uint32_t USR_MOSI_DBITLEN_Msk = USR_MOSI_DBITLEN::mask;

}  // namespace mosi_dlen

/// MISO_DLEN - MISO_DLEN
namespace miso_dlen {
    /// The length in bits of  read-data. The register value shall be (bit_num-1).
    /// Position: 0, Width: 24
    /// Access: read-write
    using USR_MISO_DBITLEN = BitField<0, 24>;
    constexpr uint32_t USR_MISO_DBITLEN_Pos = 0;
    constexpr uint32_t USR_MISO_DBITLEN_Msk = USR_MISO_DBITLEN::mask;

}  // namespace miso_dlen

/// SLV_WR_STATUS - SLV_WR_STATUS
namespace slv_wr_status {
    /// In the slave mode this register are the status register for the master to write into. In the master mode this register are the higher 32bits in the 64 bits address condition.
    /// Position: 0, Width: 32
    /// Access: read-write
    using SLV_WR_ST = BitField<0, 32>;
    constexpr uint32_t SLV_WR_ST_Pos = 0;
    constexpr uint32_t SLV_WR_ST_Msk = SLV_WR_ST::mask;

}  // namespace slv_wr_status

/// PIN - PIN
namespace pin {
    /// SPI CS0 pin enable, 1: disable CS0, 0: spi_cs0 signal is from/to CS0 pin
    /// Position: 0, Width: 1
    /// Access: read-write
    using CS0_DIS = BitField<0, 1>;
    constexpr uint32_t CS0_DIS_Pos = 0;
    constexpr uint32_t CS0_DIS_Msk = CS0_DIS::mask;

    /// SPI CS1 pin enable, 1: disable CS1, 0: spi_cs1 signal is from/to CS1 pin
    /// Position: 1, Width: 1
    /// Access: read-write
    using CS1_DIS = BitField<1, 1>;
    constexpr uint32_t CS1_DIS_Pos = 1;
    constexpr uint32_t CS1_DIS_Msk = CS1_DIS::mask;

    /// SPI CS2 pin enable, 1: disable CS2, 0: spi_cs2 signal is from/to CS2 pin
    /// Position: 2, Width: 1
    /// Access: read-write
    using CS2_DIS = BitField<2, 1>;
    constexpr uint32_t CS2_DIS_Pos = 2;
    constexpr uint32_t CS2_DIS_Msk = CS2_DIS::mask;

    /// 1: spi clk out disable  0: spi clk out enable
    /// Position: 5, Width: 1
    /// Access: read-write
    using CK_DIS = BitField<5, 1>;
    constexpr uint32_t CK_DIS_Pos = 5;
    constexpr uint32_t CK_DIS_Msk = CK_DIS::mask;

    /// In the master mode  the bits are the polarity of spi cs line  the value is equivalent to spi_cs ^ spi_master_cs_pol.
    /// Position: 6, Width: 3
    /// Access: read-write
    using MASTER_CS_POL = BitField<6, 3>;
    constexpr uint32_t MASTER_CS_POL_Pos = 6;
    constexpr uint32_t MASTER_CS_POL_Msk = MASTER_CS_POL::mask;

    /// In the master mode  spi cs line is enable as spi clk  it is combined with spi_cs0_dis spi_cs1_dis spi_cs2_dis.
    /// Position: 11, Width: 3
    /// Access: read-write
    using MASTER_CK_SEL = BitField<11, 3>;
    constexpr uint32_t MASTER_CK_SEL_Pos = 11;
    constexpr uint32_t MASTER_CK_SEL_Msk = MASTER_CK_SEL::mask;

    /// 1: spi clk line is high when idle     0: spi clk line is low when idle
    /// Position: 29, Width: 1
    /// Access: read-write
    using CK_IDLE_EDGE = BitField<29, 1>;
    constexpr uint32_t CK_IDLE_EDGE_Pos = 29;
    constexpr uint32_t CK_IDLE_EDGE_Msk = CK_IDLE_EDGE::mask;

    /// spi cs line keep low when the bit is set.
    /// Position: 30, Width: 1
    /// Access: read-write
    using CS_KEEP_ACTIVE = BitField<30, 1>;
    constexpr uint32_t CS_KEEP_ACTIVE_Pos = 30;
    constexpr uint32_t CS_KEEP_ACTIVE_Msk = CS_KEEP_ACTIVE::mask;

}  // namespace pin

/// SLAVE - SLAVE
namespace slave {
    /// The interrupt raw bit for the completion of read-buffer operation in the slave mode.
    /// Position: 0, Width: 1
    /// Access: read-write
    using SLV_RD_BUF_DONE = BitField<0, 1>;
    constexpr uint32_t SLV_RD_BUF_DONE_Pos = 0;
    constexpr uint32_t SLV_RD_BUF_DONE_Msk = SLV_RD_BUF_DONE::mask;

    /// The interrupt raw bit for the completion of write-buffer operation in the slave mode.
    /// Position: 1, Width: 1
    /// Access: read-write
    using SLV_WR_BUF_DONE = BitField<1, 1>;
    constexpr uint32_t SLV_WR_BUF_DONE_Pos = 1;
    constexpr uint32_t SLV_WR_BUF_DONE_Msk = SLV_WR_BUF_DONE::mask;

    /// The interrupt raw bit for the completion of read-status operation in the slave mode.
    /// Position: 2, Width: 1
    /// Access: read-write
    using SLV_RD_STA_DONE = BitField<2, 1>;
    constexpr uint32_t SLV_RD_STA_DONE_Pos = 2;
    constexpr uint32_t SLV_RD_STA_DONE_Msk = SLV_RD_STA_DONE::mask;

    /// The interrupt raw bit for the completion of write-status operation in the slave mode.
    /// Position: 3, Width: 1
    /// Access: read-write
    using SLV_WR_STA_DONE = BitField<3, 1>;
    constexpr uint32_t SLV_WR_STA_DONE_Pos = 3;
    constexpr uint32_t SLV_WR_STA_DONE_Msk = SLV_WR_STA_DONE::mask;

    /// The interrupt raw bit for the completion of any operation in both the master mode and the slave mode.
    /// Position: 4, Width: 1
    /// Access: read-write
    using TRANS_DONE = BitField<4, 1>;
    constexpr uint32_t TRANS_DONE_Pos = 4;
    constexpr uint32_t TRANS_DONE_Msk = TRANS_DONE::mask;

    /// Interrupt enable bits for the below 5 sources
    /// Position: 5, Width: 5
    /// Access: read-write
    using INT_EN = BitField<5, 5>;
    constexpr uint32_t INT_EN_Pos = 5;
    constexpr uint32_t INT_EN_Msk = INT_EN::mask;

    /// In the slave mode  this bits used to synchronize the input spi cs signal and eliminate spi cs  jitter.
    /// Position: 10, Width: 2
    /// Access: read-write
    using CS_I_MODE = BitField<10, 2>;
    constexpr uint32_t CS_I_MODE_Pos = 10;
    constexpr uint32_t CS_I_MODE_Msk = CS_I_MODE::mask;

    /// In the slave mode it is the value of command.
    /// Position: 17, Width: 3
    /// Access: read-only
    using SLV_LAST_COMMAND = BitField<17, 3>;
    constexpr uint32_t SLV_LAST_COMMAND_Pos = 17;
    constexpr uint32_t SLV_LAST_COMMAND_Msk = SLV_LAST_COMMAND::mask;

    /// In the slave mode it is the state of spi state machine.
    /// Position: 20, Width: 3
    /// Access: read-only
    using SLV_LAST_STATE = BitField<20, 3>;
    constexpr uint32_t SLV_LAST_STATE_Pos = 20;
    constexpr uint32_t SLV_LAST_STATE_Msk = SLV_LAST_STATE::mask;

    /// The operations counter in both the master mode and the slave mode. 4: read-status
    /// Position: 23, Width: 4
    /// Access: read-only
    using TRANS_CNT = BitField<23, 4>;
    constexpr uint32_t TRANS_CNT_Pos = 23;
    constexpr uint32_t TRANS_CNT_Msk = TRANS_CNT::mask;

    /// 1: slave mode commands are defined in SPI_SLAVE3.  0: slave mode commands are fixed as: 1: write-status 2: write-buffer and 3: read-buffer.
    /// Position: 27, Width: 1
    /// Access: read-write
    using SLV_CMD_DEFINE = BitField<27, 1>;
    constexpr uint32_t SLV_CMD_DEFINE_Pos = 27;
    constexpr uint32_t SLV_CMD_DEFINE_Msk = SLV_CMD_DEFINE::mask;

    /// write and read status enable  in the slave mode
    /// Position: 28, Width: 1
    /// Access: read-write
    using SLV_WR_RD_STA_EN = BitField<28, 1>;
    constexpr uint32_t SLV_WR_RD_STA_EN_Pos = 28;
    constexpr uint32_t SLV_WR_RD_STA_EN_Msk = SLV_WR_RD_STA_EN::mask;

    /// write and read buffer enable in the slave mode
    /// Position: 29, Width: 1
    /// Access: read-write
    using SLV_WR_RD_BUF_EN = BitField<29, 1>;
    constexpr uint32_t SLV_WR_RD_BUF_EN_Pos = 29;
    constexpr uint32_t SLV_WR_RD_BUF_EN_Msk = SLV_WR_RD_BUF_EN::mask;

    /// 1: slave mode 0: master mode.
    /// Position: 30, Width: 1
    /// Access: read-write
    using MODE = BitField<30, 1>;
    constexpr uint32_t MODE_Pos = 30;
    constexpr uint32_t MODE_Msk = MODE::mask;

    /// Software reset enable, reset the spi clock line cs line and data lines.
    /// Position: 31, Width: 1
    /// Access: read-write
    using SYNC_RESET = BitField<31, 1>;
    constexpr uint32_t SYNC_RESET_Pos = 31;
    constexpr uint32_t SYNC_RESET_Msk = SYNC_RESET::mask;

}  // namespace slave

/// SLAVE1 - SLAVE1
namespace slave1 {
    /// In the slave mode it is the enable bit of dummy phase for read-buffer operations.
    /// Position: 0, Width: 1
    /// Access: read-write
    using SLV_RDBUF_DUMMY_EN = BitField<0, 1>;
    constexpr uint32_t SLV_RDBUF_DUMMY_EN_Pos = 0;
    constexpr uint32_t SLV_RDBUF_DUMMY_EN_Msk = SLV_RDBUF_DUMMY_EN::mask;

    /// In the slave mode it is the enable bit of dummy phase for write-buffer operations.
    /// Position: 1, Width: 1
    /// Access: read-write
    using SLV_WRBUF_DUMMY_EN = BitField<1, 1>;
    constexpr uint32_t SLV_WRBUF_DUMMY_EN_Pos = 1;
    constexpr uint32_t SLV_WRBUF_DUMMY_EN_Msk = SLV_WRBUF_DUMMY_EN::mask;

    /// In the slave mode it is the enable bit of dummy phase for read-status operations.
    /// Position: 2, Width: 1
    /// Access: read-write
    using SLV_RDSTA_DUMMY_EN = BitField<2, 1>;
    constexpr uint32_t SLV_RDSTA_DUMMY_EN_Pos = 2;
    constexpr uint32_t SLV_RDSTA_DUMMY_EN_Msk = SLV_RDSTA_DUMMY_EN::mask;

    /// In the slave mode it is the enable bit of dummy phase for write-status operations.
    /// Position: 3, Width: 1
    /// Access: read-write
    using SLV_WRSTA_DUMMY_EN = BitField<3, 1>;
    constexpr uint32_t SLV_WRSTA_DUMMY_EN_Pos = 3;
    constexpr uint32_t SLV_WRSTA_DUMMY_EN_Msk = SLV_WRSTA_DUMMY_EN::mask;

    /// In the slave mode it is the address length in bits for write-buffer operation. The register value shall be (bit_num-1).
    /// Position: 4, Width: 6
    /// Access: read-write
    using SLV_WR_ADDR_BITLEN = BitField<4, 6>;
    constexpr uint32_t SLV_WR_ADDR_BITLEN_Pos = 4;
    constexpr uint32_t SLV_WR_ADDR_BITLEN_Msk = SLV_WR_ADDR_BITLEN::mask;

    /// In the slave mode it is the address length in bits for read-buffer operation. The register value shall be (bit_num-1).
    /// Position: 10, Width: 6
    /// Access: read-write
    using SLV_RD_ADDR_BITLEN = BitField<10, 6>;
    constexpr uint32_t SLV_RD_ADDR_BITLEN_Pos = 10;
    constexpr uint32_t SLV_RD_ADDR_BITLEN_Msk = SLV_RD_ADDR_BITLEN::mask;

    /// In the slave mode  1:read register of SPI_SLV_WR_STATUS  0: read register of SPI_RD_STATUS.
    /// Position: 25, Width: 1
    /// Access: read-write
    using SLV_STATUS_READBACK = BitField<25, 1>;
    constexpr uint32_t SLV_STATUS_READBACK_Pos = 25;
    constexpr uint32_t SLV_STATUS_READBACK_Msk = SLV_STATUS_READBACK::mask;

    /// In the slave mode enable fast read status.
    /// Position: 26, Width: 1
    /// Access: read-write
    using SLV_STATUS_FAST_EN = BitField<26, 1>;
    constexpr uint32_t SLV_STATUS_FAST_EN_Pos = 26;
    constexpr uint32_t SLV_STATUS_FAST_EN_Msk = SLV_STATUS_FAST_EN::mask;

    /// In the slave mode it is the length of status bit.
    /// Position: 27, Width: 5
    /// Access: read-write
    using SLV_STATUS_BITLEN = BitField<27, 5>;
    constexpr uint32_t SLV_STATUS_BITLEN_Pos = 27;
    constexpr uint32_t SLV_STATUS_BITLEN_Msk = SLV_STATUS_BITLEN::mask;

}  // namespace slave1

/// SLAVE2 - SLAVE2
namespace slave2 {
    /// In the slave mode it is the length in spi_clk cycles of dummy phase for read-status operations. The register value shall be (cycle_num-1).
    /// Position: 0, Width: 8
    /// Access: read-write
    using SLV_RDSTA_DUMMY_CYCLELEN = BitField<0, 8>;
    constexpr uint32_t SLV_RDSTA_DUMMY_CYCLELEN_Pos = 0;
    constexpr uint32_t SLV_RDSTA_DUMMY_CYCLELEN_Msk = SLV_RDSTA_DUMMY_CYCLELEN::mask;

    /// In the slave mode it is the length in spi_clk cycles of dummy phase for write-status operations. The register value shall be (cycle_num-1).
    /// Position: 8, Width: 8
    /// Access: read-write
    using SLV_WRSTA_DUMMY_CYCLELEN = BitField<8, 8>;
    constexpr uint32_t SLV_WRSTA_DUMMY_CYCLELEN_Pos = 8;
    constexpr uint32_t SLV_WRSTA_DUMMY_CYCLELEN_Msk = SLV_WRSTA_DUMMY_CYCLELEN::mask;

    /// In the slave mode it is the length in spi_clk cycles of dummy phase for read-buffer operations. The register value shall be (cycle_num-1).
    /// Position: 16, Width: 8
    /// Access: read-write
    using SLV_RDBUF_DUMMY_CYCLELEN = BitField<16, 8>;
    constexpr uint32_t SLV_RDBUF_DUMMY_CYCLELEN_Pos = 16;
    constexpr uint32_t SLV_RDBUF_DUMMY_CYCLELEN_Msk = SLV_RDBUF_DUMMY_CYCLELEN::mask;

    /// In the slave mode it is the length in spi_clk cycles of dummy phase for write-buffer operations. The register value shall be (cycle_num-1).
    /// Position: 24, Width: 8
    /// Access: read-write
    using SLV_WRBUF_DUMMY_CYCLELEN = BitField<24, 8>;
    constexpr uint32_t SLV_WRBUF_DUMMY_CYCLELEN_Pos = 24;
    constexpr uint32_t SLV_WRBUF_DUMMY_CYCLELEN_Msk = SLV_WRBUF_DUMMY_CYCLELEN::mask;

}  // namespace slave2

/// SLAVE3 - SLAVE3
namespace slave3 {
    /// In the slave mode it is the value of read-buffer command.
    /// Position: 0, Width: 8
    /// Access: read-write
    using SLV_RDBUF_CMD_VALUE = BitField<0, 8>;
    constexpr uint32_t SLV_RDBUF_CMD_VALUE_Pos = 0;
    constexpr uint32_t SLV_RDBUF_CMD_VALUE_Msk = SLV_RDBUF_CMD_VALUE::mask;

    /// In the slave mode it is the value of write-buffer command.
    /// Position: 8, Width: 8
    /// Access: read-write
    using SLV_WRBUF_CMD_VALUE = BitField<8, 8>;
    constexpr uint32_t SLV_WRBUF_CMD_VALUE_Pos = 8;
    constexpr uint32_t SLV_WRBUF_CMD_VALUE_Msk = SLV_WRBUF_CMD_VALUE::mask;

    /// In the slave mode it is the value of read-status command.
    /// Position: 16, Width: 8
    /// Access: read-write
    using SLV_RDSTA_CMD_VALUE = BitField<16, 8>;
    constexpr uint32_t SLV_RDSTA_CMD_VALUE_Pos = 16;
    constexpr uint32_t SLV_RDSTA_CMD_VALUE_Msk = SLV_RDSTA_CMD_VALUE::mask;

    /// In the slave mode it is the value of write-status command.
    /// Position: 24, Width: 8
    /// Access: read-write
    using SLV_WRSTA_CMD_VALUE = BitField<24, 8>;
    constexpr uint32_t SLV_WRSTA_CMD_VALUE_Pos = 24;
    constexpr uint32_t SLV_WRSTA_CMD_VALUE_Msk = SLV_WRSTA_CMD_VALUE::mask;

}  // namespace slave3

/// SLV_WRBUF_DLEN - SLV_WRBUF_DLEN
namespace slv_wrbuf_dlen {
    /// In the slave mode it is the length in bits for write-buffer operations. The register value shall be (bit_num-1).
    /// Position: 0, Width: 24
    /// Access: read-write
    using SLV_WRBUF_DBITLEN = BitField<0, 24>;
    constexpr uint32_t SLV_WRBUF_DBITLEN_Pos = 0;
    constexpr uint32_t SLV_WRBUF_DBITLEN_Msk = SLV_WRBUF_DBITLEN::mask;

}  // namespace slv_wrbuf_dlen

/// SLV_RDBUF_DLEN - SLV_RDBUF_DLEN
namespace slv_rdbuf_dlen {
    /// In the slave mode it is the length in bits for read-buffer operations. The register value shall be (bit_num-1).
    /// Position: 0, Width: 24
    /// Access: read-write
    using SLV_RDBUF_DBITLEN = BitField<0, 24>;
    constexpr uint32_t SLV_RDBUF_DBITLEN_Pos = 0;
    constexpr uint32_t SLV_RDBUF_DBITLEN_Msk = SLV_RDBUF_DBITLEN::mask;

}  // namespace slv_rdbuf_dlen

/// CACHE_FCTRL - CACHE_FCTRL
namespace cache_fctrl {
    /// For SPI0  Cache access enable  1: enable  0:disable.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CACHE_REQ_EN = BitField<0, 1>;
    constexpr uint32_t CACHE_REQ_EN_Pos = 0;
    constexpr uint32_t CACHE_REQ_EN_Msk = CACHE_REQ_EN::mask;

    /// For SPI0  cache  read flash with 4 bytes command  1: enable  0:disable.
    /// Position: 1, Width: 1
    /// Access: read-write
    using CACHE_USR_CMD_4BYTE = BitField<1, 1>;
    constexpr uint32_t CACHE_USR_CMD_4BYTE_Pos = 1;
    constexpr uint32_t CACHE_USR_CMD_4BYTE_Msk = CACHE_USR_CMD_4BYTE::mask;

    /// For SPI0  cache  read flash for user define command  1: enable  0:disable.
    /// Position: 2, Width: 1
    /// Access: read-write
    using CACHE_FLASH_USR_CMD = BitField<2, 1>;
    constexpr uint32_t CACHE_FLASH_USR_CMD_Pos = 2;
    constexpr uint32_t CACHE_FLASH_USR_CMD_Msk = CACHE_FLASH_USR_CMD::mask;

    /// For SPI0  spi1 send suspend command before cache read flash 1: enable  0:disable.
    /// Position: 3, Width: 1
    /// Access: read-write
    using CACHE_FLASH_PES_EN = BitField<3, 1>;
    constexpr uint32_t CACHE_FLASH_PES_EN_Pos = 3;
    constexpr uint32_t CACHE_FLASH_PES_EN_Msk = CACHE_FLASH_PES_EN::mask;

}  // namespace cache_fctrl

/// CACHE_SCTRL - CACHE_SCTRL
namespace cache_sctrl {
    /// For SPI0  In the spi sram mode  spi dual I/O mode enable  1: enable  0:disable
    /// Position: 1, Width: 1
    /// Access: read-write
    using USR_SRAM_DIO = BitField<1, 1>;
    constexpr uint32_t USR_SRAM_DIO_Pos = 1;
    constexpr uint32_t USR_SRAM_DIO_Msk = USR_SRAM_DIO::mask;

    /// For SPI0  In the spi sram mode  spi quad I/O mode enable  1: enable  0:disable
    /// Position: 2, Width: 1
    /// Access: read-write
    using USR_SRAM_QIO = BitField<2, 1>;
    constexpr uint32_t USR_SRAM_QIO_Pos = 2;
    constexpr uint32_t USR_SRAM_QIO_Msk = USR_SRAM_QIO::mask;

    /// For SPI0  In the spi sram mode  it is the enable bit of dummy phase for write operations.
    /// Position: 3, Width: 1
    /// Access: read-write
    using USR_WR_SRAM_DUMMY = BitField<3, 1>;
    constexpr uint32_t USR_WR_SRAM_DUMMY_Pos = 3;
    constexpr uint32_t USR_WR_SRAM_DUMMY_Msk = USR_WR_SRAM_DUMMY::mask;

    /// For SPI0  In the spi sram mode  it is the enable bit of dummy phase for read operations.
    /// Position: 4, Width: 1
    /// Access: read-write
    using USR_RD_SRAM_DUMMY = BitField<4, 1>;
    constexpr uint32_t USR_RD_SRAM_DUMMY_Pos = 4;
    constexpr uint32_t USR_RD_SRAM_DUMMY_Msk = USR_RD_SRAM_DUMMY::mask;

    /// For SPI0  In the spi sram mode cache read sram for user define command.
    /// Position: 5, Width: 1
    /// Access: read-write
    using CACHE_SRAM_USR_RCMD = BitField<5, 1>;
    constexpr uint32_t CACHE_SRAM_USR_RCMD_Pos = 5;
    constexpr uint32_t CACHE_SRAM_USR_RCMD_Msk = CACHE_SRAM_USR_RCMD::mask;

    /// For SPI0  In the sram mode  it is the byte length of spi read sram data.
    /// Position: 6, Width: 8
    /// Access: read-write
    using SRAM_BYTES_LEN = BitField<6, 8>;
    constexpr uint32_t SRAM_BYTES_LEN_Pos = 6;
    constexpr uint32_t SRAM_BYTES_LEN_Msk = SRAM_BYTES_LEN::mask;

    /// For SPI0  In the sram mode  it is the length in bits of address phase. The register value shall be (bit_num-1).
    /// Position: 14, Width: 8
    /// Access: read-write
    using SRAM_DUMMY_CYCLELEN = BitField<14, 8>;
    constexpr uint32_t SRAM_DUMMY_CYCLELEN_Pos = 14;
    constexpr uint32_t SRAM_DUMMY_CYCLELEN_Msk = SRAM_DUMMY_CYCLELEN::mask;

    /// For SPI0  In the sram mode  it is the length in bits of address phase. The register value shall be (bit_num-1).
    /// Position: 22, Width: 6
    /// Access: read-write
    using SRAM_ADDR_BITLEN = BitField<22, 6>;
    constexpr uint32_t SRAM_ADDR_BITLEN_Pos = 22;
    constexpr uint32_t SRAM_ADDR_BITLEN_Msk = SRAM_ADDR_BITLEN::mask;

    /// For SPI0  In the spi sram mode cache write sram for user define command
    /// Position: 28, Width: 1
    /// Access: read-write
    using CACHE_SRAM_USR_WCMD = BitField<28, 1>;
    constexpr uint32_t CACHE_SRAM_USR_WCMD_Pos = 28;
    constexpr uint32_t CACHE_SRAM_USR_WCMD_Msk = CACHE_SRAM_USR_WCMD::mask;

}  // namespace cache_sctrl

/// SRAM_CMD - SRAM_CMD
namespace sram_cmd {
    /// For SPI0 SRAM DIO mode enable .  SRAM DIO enable command will be send when the bit is set. The bit will be cleared once the operation done.
    /// Position: 0, Width: 1
    /// Access: read-write
    using SRAM_DIO = BitField<0, 1>;
    constexpr uint32_t SRAM_DIO_Pos = 0;
    constexpr uint32_t SRAM_DIO_Msk = SRAM_DIO::mask;

    /// For SPI0 SRAM QIO mode enable .  SRAM QIO enable command will be send when the bit is set. The bit will be cleared once the operation done.
    /// Position: 1, Width: 1
    /// Access: read-write
    using SRAM_QIO = BitField<1, 1>;
    constexpr uint32_t SRAM_QIO_Pos = 1;
    constexpr uint32_t SRAM_QIO_Msk = SRAM_QIO::mask;

    /// For SPI0 SRAM IO mode reset enable. SRAM IO mode reset operation will be triggered when the bit is set. The bit will be cleared once the operation done
    /// Position: 4, Width: 1
    /// Access: read-write
    using SRAM_RSTIO = BitField<4, 1>;
    constexpr uint32_t SRAM_RSTIO_Pos = 4;
    constexpr uint32_t SRAM_RSTIO_Msk = SRAM_RSTIO::mask;

}  // namespace sram_cmd

/// SRAM_DRD_CMD - SRAM_DRD_CMD
namespace sram_drd_cmd {
    /// For SPI0 When cache mode is enable it is the read command value of command phase for SRAM.
    /// Position: 0, Width: 16
    /// Access: read-write
    using CACHE_SRAM_USR_RD_CMD_VALUE = BitField<0, 16>;
    constexpr uint32_t CACHE_SRAM_USR_RD_CMD_VALUE_Pos = 0;
    constexpr uint32_t CACHE_SRAM_USR_RD_CMD_VALUE_Msk = CACHE_SRAM_USR_RD_CMD_VALUE::mask;

    /// For SPI0 When cache mode is enable it is the length in bits of command phase for SRAM. The register value shall be (bit_num-1).
    /// Position: 28, Width: 4
    /// Access: read-write
    using CACHE_SRAM_USR_RD_CMD_BITLEN = BitField<28, 4>;
    constexpr uint32_t CACHE_SRAM_USR_RD_CMD_BITLEN_Pos = 28;
    constexpr uint32_t CACHE_SRAM_USR_RD_CMD_BITLEN_Msk = CACHE_SRAM_USR_RD_CMD_BITLEN::mask;

}  // namespace sram_drd_cmd

/// SRAM_DWR_CMD - SRAM_DWR_CMD
namespace sram_dwr_cmd {
    /// For SPI0 When cache mode is enable it is the write command value of command phase for SRAM.
    /// Position: 0, Width: 16
    /// Access: read-write
    using CACHE_SRAM_USR_WR_CMD_VALUE = BitField<0, 16>;
    constexpr uint32_t CACHE_SRAM_USR_WR_CMD_VALUE_Pos = 0;
    constexpr uint32_t CACHE_SRAM_USR_WR_CMD_VALUE_Msk = CACHE_SRAM_USR_WR_CMD_VALUE::mask;

    /// For SPI0 When cache mode is enable it is the in bits of command phase  for SRAM. The register value shall be (bit_num-1).
    /// Position: 28, Width: 4
    /// Access: read-write
    using CACHE_SRAM_USR_WR_CMD_BITLEN = BitField<28, 4>;
    constexpr uint32_t CACHE_SRAM_USR_WR_CMD_BITLEN_Pos = 28;
    constexpr uint32_t CACHE_SRAM_USR_WR_CMD_BITLEN_Msk = CACHE_SRAM_USR_WR_CMD_BITLEN::mask;

}  // namespace sram_dwr_cmd

/// SLV_RD_BIT - SLV_RD_BIT
namespace slv_rd_bit {
    /// In the slave mode it is the bit length of read data. The value is the length - 1.
    /// Position: 0, Width: 24
    /// Access: read-write
    using SLV_RDATA_BIT = BitField<0, 24>;
    constexpr uint32_t SLV_RDATA_BIT_Pos = 0;
    constexpr uint32_t SLV_RDATA_BIT_Msk = SLV_RDATA_BIT::mask;

}  // namespace slv_rd_bit

/// W0 - W0
namespace w0 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF0 = BitField<0, 32>;
    constexpr uint32_t BUF0_Pos = 0;
    constexpr uint32_t BUF0_Msk = BUF0::mask;

}  // namespace w0

/// W1 - W1
namespace w1 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF1 = BitField<0, 32>;
    constexpr uint32_t BUF1_Pos = 0;
    constexpr uint32_t BUF1_Msk = BUF1::mask;

}  // namespace w1

/// W2 - W2
namespace w2 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF2 = BitField<0, 32>;
    constexpr uint32_t BUF2_Pos = 0;
    constexpr uint32_t BUF2_Msk = BUF2::mask;

}  // namespace w2

/// W3 - W3
namespace w3 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF3 = BitField<0, 32>;
    constexpr uint32_t BUF3_Pos = 0;
    constexpr uint32_t BUF3_Msk = BUF3::mask;

}  // namespace w3

/// W4 - W4
namespace w4 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF4 = BitField<0, 32>;
    constexpr uint32_t BUF4_Pos = 0;
    constexpr uint32_t BUF4_Msk = BUF4::mask;

}  // namespace w4

/// W5 - W5
namespace w5 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF5 = BitField<0, 32>;
    constexpr uint32_t BUF5_Pos = 0;
    constexpr uint32_t BUF5_Msk = BUF5::mask;

}  // namespace w5

/// W6 - W6
namespace w6 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF6 = BitField<0, 32>;
    constexpr uint32_t BUF6_Pos = 0;
    constexpr uint32_t BUF6_Msk = BUF6::mask;

}  // namespace w6

/// W7 - W7
namespace w7 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF7 = BitField<0, 32>;
    constexpr uint32_t BUF7_Pos = 0;
    constexpr uint32_t BUF7_Msk = BUF7::mask;

}  // namespace w7

/// W8 - W8
namespace w8 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF8 = BitField<0, 32>;
    constexpr uint32_t BUF8_Pos = 0;
    constexpr uint32_t BUF8_Msk = BUF8::mask;

}  // namespace w8

/// W9 - W9
namespace w9 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF9 = BitField<0, 32>;
    constexpr uint32_t BUF9_Pos = 0;
    constexpr uint32_t BUF9_Msk = BUF9::mask;

}  // namespace w9

/// W10 - W10
namespace w10 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF10 = BitField<0, 32>;
    constexpr uint32_t BUF10_Pos = 0;
    constexpr uint32_t BUF10_Msk = BUF10::mask;

}  // namespace w10

/// W11 - W11
namespace w11 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF11 = BitField<0, 32>;
    constexpr uint32_t BUF11_Pos = 0;
    constexpr uint32_t BUF11_Msk = BUF11::mask;

}  // namespace w11

/// W12 - W12
namespace w12 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF12 = BitField<0, 32>;
    constexpr uint32_t BUF12_Pos = 0;
    constexpr uint32_t BUF12_Msk = BUF12::mask;

}  // namespace w12

/// W13 - W13
namespace w13 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF13 = BitField<0, 32>;
    constexpr uint32_t BUF13_Pos = 0;
    constexpr uint32_t BUF13_Msk = BUF13::mask;

}  // namespace w13

/// W14 - W14
namespace w14 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF14 = BitField<0, 32>;
    constexpr uint32_t BUF14_Pos = 0;
    constexpr uint32_t BUF14_Msk = BUF14::mask;

}  // namespace w14

/// W15 - W15
namespace w15 {
    /// data buffer
    /// Position: 0, Width: 32
    /// Access: read-write
    using BUF15 = BitField<0, 32>;
    constexpr uint32_t BUF15_Pos = 0;
    constexpr uint32_t BUF15_Msk = BUF15::mask;

}  // namespace w15

/// TX_CRC - TX_CRC
namespace tx_crc {
    /// For SPI1  the value of crc32 for 256 bits data.
    /// Position: 0, Width: 32
    /// Access: read-write
    using DATA = BitField<0, 32>;
    constexpr uint32_t DATA_Pos = 0;
    constexpr uint32_t DATA_Msk = DATA::mask;

}  // namespace tx_crc

/// EXT0 - EXT0
namespace ext0 {
    /// page program delay time  by system clock.
    /// Position: 0, Width: 12
    /// Access: read-write
    using T_PP_TIME = BitField<0, 12>;
    constexpr uint32_t T_PP_TIME_Pos = 0;
    constexpr uint32_t T_PP_TIME_Msk = T_PP_TIME::mask;

    /// page program delay time shift .
    /// Position: 16, Width: 4
    /// Access: read-write
    using T_PP_SHIFT = BitField<16, 4>;
    constexpr uint32_t T_PP_SHIFT_Pos = 16;
    constexpr uint32_t T_PP_SHIFT_Msk = T_PP_SHIFT::mask;

    /// page program delay enable.
    /// Position: 31, Width: 1
    /// Access: read-write
    using T_PP_ENA = BitField<31, 1>;
    constexpr uint32_t T_PP_ENA_Pos = 31;
    constexpr uint32_t T_PP_ENA_Msk = T_PP_ENA::mask;

}  // namespace ext0

/// EXT1 - EXT1
namespace ext1 {
    /// erase flash delay time by system clock.
    /// Position: 0, Width: 12
    /// Access: read-write
    using T_ERASE_TIME = BitField<0, 12>;
    constexpr uint32_t T_ERASE_TIME_Pos = 0;
    constexpr uint32_t T_ERASE_TIME_Msk = T_ERASE_TIME::mask;

    /// erase flash delay time shift.
    /// Position: 16, Width: 4
    /// Access: read-write
    using T_ERASE_SHIFT = BitField<16, 4>;
    constexpr uint32_t T_ERASE_SHIFT_Pos = 16;
    constexpr uint32_t T_ERASE_SHIFT_Msk = T_ERASE_SHIFT::mask;

    /// erase flash delay enable.
    /// Position: 31, Width: 1
    /// Access: read-write
    using T_ERASE_ENA = BitField<31, 1>;
    constexpr uint32_t T_ERASE_ENA_Pos = 31;
    constexpr uint32_t T_ERASE_ENA_Msk = T_ERASE_ENA::mask;

}  // namespace ext1

/// EXT2 - EXT2
namespace ext2 {
    /// The status of spi state machine .
    /// Position: 0, Width: 3
    /// Access: read-only
    using ST = BitField<0, 3>;
    constexpr uint32_t ST_Pos = 0;
    constexpr uint32_t ST_Msk = ST::mask;

}  // namespace ext2

/// EXT3 - EXT3
namespace ext3 {
    /// This register is for two SPI masters to share the same cs clock and data signals. The bits of one SPI are set  if the other SPI is busy  the SPI will be hold. 1(3): hold at ¡°idle¡± phase 2: hold at ¡°prepare¡± phase.
    /// Position: 0, Width: 2
    /// Access: read-write
    using INT_HOLD_ENA = BitField<0, 2>;
    constexpr uint32_t INT_HOLD_ENA_Pos = 0;
    constexpr uint32_t INT_HOLD_ENA_Msk = INT_HOLD_ENA::mask;

}  // namespace ext3

/// DMA_CONF - DMA_CONF
namespace dma_conf {
    /// The bit is used to reset in dma fsm and in data fifo pointer.
    /// Position: 2, Width: 1
    /// Access: read-write
    using IN_RST = BitField<2, 1>;
    constexpr uint32_t IN_RST_Pos = 2;
    constexpr uint32_t IN_RST_Msk = IN_RST::mask;

    /// The bit is used to reset out dma fsm and out data fifo pointer.
    /// Position: 3, Width: 1
    /// Access: read-write
    using OUT_RST = BitField<3, 1>;
    constexpr uint32_t OUT_RST_Pos = 3;
    constexpr uint32_t OUT_RST_Msk = OUT_RST::mask;

    /// reset spi dma ahb master fifo pointer.
    /// Position: 4, Width: 1
    /// Access: read-write
    using AHBM_FIFO_RST = BitField<4, 1>;
    constexpr uint32_t AHBM_FIFO_RST_Pos = 4;
    constexpr uint32_t AHBM_FIFO_RST_Msk = AHBM_FIFO_RST::mask;

    /// reset spi dma ahb master.
    /// Position: 5, Width: 1
    /// Access: read-write
    using AHBM_RST = BitField<5, 1>;
    constexpr uint32_t AHBM_RST_Pos = 5;
    constexpr uint32_t AHBM_RST_Msk = AHBM_RST::mask;

    /// Set bit to test in link.
    /// Position: 6, Width: 1
    /// Access: read-write
    using IN_LOOP_TEST = BitField<6, 1>;
    constexpr uint32_t IN_LOOP_TEST_Pos = 6;
    constexpr uint32_t IN_LOOP_TEST_Msk = IN_LOOP_TEST::mask;

    /// Set bit to test out link.
    /// Position: 7, Width: 1
    /// Access: read-write
    using OUT_LOOP_TEST = BitField<7, 1>;
    constexpr uint32_t OUT_LOOP_TEST_Pos = 7;
    constexpr uint32_t OUT_LOOP_TEST_Msk = OUT_LOOP_TEST::mask;

    /// when the link is empty   jump to next automatically.
    /// Position: 8, Width: 1
    /// Access: read-write
    using OUT_AUTO_WRBACK = BitField<8, 1>;
    constexpr uint32_t OUT_AUTO_WRBACK_Pos = 8;
    constexpr uint32_t OUT_AUTO_WRBACK_Msk = OUT_AUTO_WRBACK::mask;

    /// out eof flag generation mode . 1: when dma pop all data from fifo  0:when ahb push all data to fifo.
    /// Position: 9, Width: 1
    /// Access: read-write
    using OUT_EOF_MODE = BitField<9, 1>;
    constexpr uint32_t OUT_EOF_MODE_Pos = 9;
    constexpr uint32_t OUT_EOF_MODE_Msk = OUT_EOF_MODE::mask;

    /// read descriptor use burst mode when read data for memory.
    /// Position: 10, Width: 1
    /// Access: read-write
    using OUTDSCR_BURST_EN = BitField<10, 1>;
    constexpr uint32_t OUTDSCR_BURST_EN_Pos = 10;
    constexpr uint32_t OUTDSCR_BURST_EN_Msk = OUTDSCR_BURST_EN::mask;

    /// read descriptor use burst mode when write data to memory.
    /// Position: 11, Width: 1
    /// Access: read-write
    using INDSCR_BURST_EN = BitField<11, 1>;
    constexpr uint32_t INDSCR_BURST_EN_Pos = 11;
    constexpr uint32_t INDSCR_BURST_EN_Msk = INDSCR_BURST_EN::mask;

    /// spi dma read data from memory in burst mode.
    /// Position: 12, Width: 1
    /// Access: read-write
    using OUT_DATA_BURST_EN = BitField<12, 1>;
    constexpr uint32_t OUT_DATA_BURST_EN_Pos = 12;
    constexpr uint32_t OUT_DATA_BURST_EN_Msk = OUT_DATA_BURST_EN::mask;

    /// spi dma read data stop  when in continue tx/rx mode.
    /// Position: 14, Width: 1
    /// Access: read-write
    using DMA_RX_STOP = BitField<14, 1>;
    constexpr uint32_t DMA_RX_STOP_Pos = 14;
    constexpr uint32_t DMA_RX_STOP_Msk = DMA_RX_STOP::mask;

    /// spi dma write data stop when in continue tx/rx mode.
    /// Position: 15, Width: 1
    /// Access: read-write
    using DMA_TX_STOP = BitField<15, 1>;
    constexpr uint32_t DMA_TX_STOP_Pos = 15;
    constexpr uint32_t DMA_TX_STOP_Msk = DMA_TX_STOP::mask;

    /// spi dma continue tx/rx data.
    /// Position: 16, Width: 1
    /// Access: read-write
    using DMA_CONTINUE = BitField<16, 1>;
    constexpr uint32_t DMA_CONTINUE_Pos = 16;
    constexpr uint32_t DMA_CONTINUE_Msk = DMA_CONTINUE::mask;

}  // namespace dma_conf

/// DMA_OUT_LINK - DMA_OUT_LINK
namespace dma_out_link {
    /// The address of the first outlink descriptor.
    /// Position: 0, Width: 20
    /// Access: read-write
    using OUTLINK_ADDR = BitField<0, 20>;
    constexpr uint32_t OUTLINK_ADDR_Pos = 0;
    constexpr uint32_t OUTLINK_ADDR_Msk = OUTLINK_ADDR::mask;

    /// Set the bit to stop to use outlink descriptor.
    /// Position: 28, Width: 1
    /// Access: read-write
    using OUTLINK_STOP = BitField<28, 1>;
    constexpr uint32_t OUTLINK_STOP_Pos = 28;
    constexpr uint32_t OUTLINK_STOP_Msk = OUTLINK_STOP::mask;

    /// Set the bit to start to use outlink descriptor.
    /// Position: 29, Width: 1
    /// Access: read-write
    using OUTLINK_START = BitField<29, 1>;
    constexpr uint32_t OUTLINK_START_Pos = 29;
    constexpr uint32_t OUTLINK_START_Msk = OUTLINK_START::mask;

    /// Set the bit to mount on new outlink descriptors.
    /// Position: 30, Width: 1
    /// Access: read-write
    using OUTLINK_RESTART = BitField<30, 1>;
    constexpr uint32_t OUTLINK_RESTART_Pos = 30;
    constexpr uint32_t OUTLINK_RESTART_Msk = OUTLINK_RESTART::mask;

}  // namespace dma_out_link

/// DMA_IN_LINK - DMA_IN_LINK
namespace dma_in_link {
    /// The address of the first inlink descriptor.
    /// Position: 0, Width: 20
    /// Access: read-write
    using INLINK_ADDR = BitField<0, 20>;
    constexpr uint32_t INLINK_ADDR_Pos = 0;
    constexpr uint32_t INLINK_ADDR_Msk = INLINK_ADDR::mask;

    /// when the bit is set  inlink descriptor returns to the next descriptor while a packet is wrong
    /// Position: 20, Width: 1
    /// Access: read-write
    using INLINK_AUTO_RET = BitField<20, 1>;
    constexpr uint32_t INLINK_AUTO_RET_Pos = 20;
    constexpr uint32_t INLINK_AUTO_RET_Msk = INLINK_AUTO_RET::mask;

    /// Set the bit to stop to use inlink descriptor.
    /// Position: 28, Width: 1
    /// Access: read-write
    using INLINK_STOP = BitField<28, 1>;
    constexpr uint32_t INLINK_STOP_Pos = 28;
    constexpr uint32_t INLINK_STOP_Msk = INLINK_STOP::mask;

    /// Set the bit to start to use inlink descriptor.
    /// Position: 29, Width: 1
    /// Access: read-write
    using INLINK_START = BitField<29, 1>;
    constexpr uint32_t INLINK_START_Pos = 29;
    constexpr uint32_t INLINK_START_Msk = INLINK_START::mask;

    /// Set the bit to mount on new inlink descriptors.
    /// Position: 30, Width: 1
    /// Access: read-write
    using INLINK_RESTART = BitField<30, 1>;
    constexpr uint32_t INLINK_RESTART_Pos = 30;
    constexpr uint32_t INLINK_RESTART_Msk = INLINK_RESTART::mask;

}  // namespace dma_in_link

/// DMA_STATUS - DMA_STATUS
namespace dma_status {
    /// spi dma read data status bit.
    /// Position: 0, Width: 1
    /// Access: read-only
    using DMA_RX_EN = BitField<0, 1>;
    constexpr uint32_t DMA_RX_EN_Pos = 0;
    constexpr uint32_t DMA_RX_EN_Msk = DMA_RX_EN::mask;

    /// spi dma write data status bit.
    /// Position: 1, Width: 1
    /// Access: read-only
    using DMA_TX_EN = BitField<1, 1>;
    constexpr uint32_t DMA_TX_EN_Pos = 1;
    constexpr uint32_t DMA_TX_EN_Msk = DMA_TX_EN::mask;

}  // namespace dma_status

/// DMA_INT_ENA - DMA_INT_ENA
namespace dma_int_ena {
    /// The enable bit for lack of enough inlink descriptors.
    /// Position: 0, Width: 1
    /// Access: read-write
    using INLINK_DSCR_EMPTY_INT_ENA = BitField<0, 1>;
    constexpr uint32_t INLINK_DSCR_EMPTY_INT_ENA_Pos = 0;
    constexpr uint32_t INLINK_DSCR_EMPTY_INT_ENA_Msk = INLINK_DSCR_EMPTY_INT_ENA::mask;

    /// The enable bit for outlink descriptor error.
    /// Position: 1, Width: 1
    /// Access: read-write
    using OUTLINK_DSCR_ERROR_INT_ENA = BitField<1, 1>;
    constexpr uint32_t OUTLINK_DSCR_ERROR_INT_ENA_Pos = 1;
    constexpr uint32_t OUTLINK_DSCR_ERROR_INT_ENA_Msk = OUTLINK_DSCR_ERROR_INT_ENA::mask;

    /// The enable bit for inlink descriptor error.
    /// Position: 2, Width: 1
    /// Access: read-write
    using INLINK_DSCR_ERROR_INT_ENA = BitField<2, 1>;
    constexpr uint32_t INLINK_DSCR_ERROR_INT_ENA_Pos = 2;
    constexpr uint32_t INLINK_DSCR_ERROR_INT_ENA_Msk = INLINK_DSCR_ERROR_INT_ENA::mask;

    /// The enable bit for completing usage of a inlink descriptor.
    /// Position: 3, Width: 1
    /// Access: read-write
    using IN_DONE_INT_ENA = BitField<3, 1>;
    constexpr uint32_t IN_DONE_INT_ENA_Pos = 3;
    constexpr uint32_t IN_DONE_INT_ENA_Msk = IN_DONE_INT_ENA::mask;

    /// The enable bit for receiving error.
    /// Position: 4, Width: 1
    /// Access: read-write
    using IN_ERR_EOF_INT_ENA = BitField<4, 1>;
    constexpr uint32_t IN_ERR_EOF_INT_ENA_Pos = 4;
    constexpr uint32_t IN_ERR_EOF_INT_ENA_Msk = IN_ERR_EOF_INT_ENA::mask;

    /// The enable bit for completing receiving all the packets from host.
    /// Position: 5, Width: 1
    /// Access: read-write
    using IN_SUC_EOF_INT_ENA = BitField<5, 1>;
    constexpr uint32_t IN_SUC_EOF_INT_ENA_Pos = 5;
    constexpr uint32_t IN_SUC_EOF_INT_ENA_Msk = IN_SUC_EOF_INT_ENA::mask;

    /// The enable bit for completing usage of a outlink descriptor .
    /// Position: 6, Width: 1
    /// Access: read-write
    using OUT_DONE_INT_ENA = BitField<6, 1>;
    constexpr uint32_t OUT_DONE_INT_ENA_Pos = 6;
    constexpr uint32_t OUT_DONE_INT_ENA_Msk = OUT_DONE_INT_ENA::mask;

    /// The enable bit for sending a packet to host done.
    /// Position: 7, Width: 1
    /// Access: read-write
    using OUT_EOF_INT_ENA = BitField<7, 1>;
    constexpr uint32_t OUT_EOF_INT_ENA_Pos = 7;
    constexpr uint32_t OUT_EOF_INT_ENA_Msk = OUT_EOF_INT_ENA::mask;

    /// The enable bit for sending all the packets to host done.
    /// Position: 8, Width: 1
    /// Access: read-write
    using OUT_TOTAL_EOF_INT_ENA = BitField<8, 1>;
    constexpr uint32_t OUT_TOTAL_EOF_INT_ENA_Pos = 8;
    constexpr uint32_t OUT_TOTAL_EOF_INT_ENA_Msk = OUT_TOTAL_EOF_INT_ENA::mask;

}  // namespace dma_int_ena

/// DMA_INT_RAW - DMA_INT_RAW
namespace dma_int_raw {
    /// The raw bit for lack of enough inlink descriptors.
    /// Position: 0, Width: 1
    /// Access: read-only
    using INLINK_DSCR_EMPTY_INT_RAW = BitField<0, 1>;
    constexpr uint32_t INLINK_DSCR_EMPTY_INT_RAW_Pos = 0;
    constexpr uint32_t INLINK_DSCR_EMPTY_INT_RAW_Msk = INLINK_DSCR_EMPTY_INT_RAW::mask;

    /// The raw bit for outlink descriptor error.
    /// Position: 1, Width: 1
    /// Access: read-only
    using OUTLINK_DSCR_ERROR_INT_RAW = BitField<1, 1>;
    constexpr uint32_t OUTLINK_DSCR_ERROR_INT_RAW_Pos = 1;
    constexpr uint32_t OUTLINK_DSCR_ERROR_INT_RAW_Msk = OUTLINK_DSCR_ERROR_INT_RAW::mask;

    /// The raw bit for inlink descriptor error.
    /// Position: 2, Width: 1
    /// Access: read-only
    using INLINK_DSCR_ERROR_INT_RAW = BitField<2, 1>;
    constexpr uint32_t INLINK_DSCR_ERROR_INT_RAW_Pos = 2;
    constexpr uint32_t INLINK_DSCR_ERROR_INT_RAW_Msk = INLINK_DSCR_ERROR_INT_RAW::mask;

    /// The raw bit for completing usage of a inlink descriptor.
    /// Position: 3, Width: 1
    /// Access: read-only
    using IN_DONE_INT_RAW = BitField<3, 1>;
    constexpr uint32_t IN_DONE_INT_RAW_Pos = 3;
    constexpr uint32_t IN_DONE_INT_RAW_Msk = IN_DONE_INT_RAW::mask;

    /// The raw bit for receiving error.
    /// Position: 4, Width: 1
    /// Access: read-only
    using IN_ERR_EOF_INT_RAW = BitField<4, 1>;
    constexpr uint32_t IN_ERR_EOF_INT_RAW_Pos = 4;
    constexpr uint32_t IN_ERR_EOF_INT_RAW_Msk = IN_ERR_EOF_INT_RAW::mask;

    /// The raw bit for completing receiving all the packets from host.
    /// Position: 5, Width: 1
    /// Access: read-only
    using IN_SUC_EOF_INT_RAW = BitField<5, 1>;
    constexpr uint32_t IN_SUC_EOF_INT_RAW_Pos = 5;
    constexpr uint32_t IN_SUC_EOF_INT_RAW_Msk = IN_SUC_EOF_INT_RAW::mask;

    /// The raw bit for completing usage of a outlink descriptor.
    /// Position: 6, Width: 1
    /// Access: read-only
    using OUT_DONE_INT_RAW = BitField<6, 1>;
    constexpr uint32_t OUT_DONE_INT_RAW_Pos = 6;
    constexpr uint32_t OUT_DONE_INT_RAW_Msk = OUT_DONE_INT_RAW::mask;

    /// The raw bit for sending a packet to host done.
    /// Position: 7, Width: 1
    /// Access: read-only
    using OUT_EOF_INT_RAW = BitField<7, 1>;
    constexpr uint32_t OUT_EOF_INT_RAW_Pos = 7;
    constexpr uint32_t OUT_EOF_INT_RAW_Msk = OUT_EOF_INT_RAW::mask;

    /// The raw bit for sending all the packets to host done.
    /// Position: 8, Width: 1
    /// Access: read-only
    using OUT_TOTAL_EOF_INT_RAW = BitField<8, 1>;
    constexpr uint32_t OUT_TOTAL_EOF_INT_RAW_Pos = 8;
    constexpr uint32_t OUT_TOTAL_EOF_INT_RAW_Msk = OUT_TOTAL_EOF_INT_RAW::mask;

}  // namespace dma_int_raw

/// DMA_INT_ST - DMA_INT_ST
namespace dma_int_st {
    /// The status bit for lack of enough inlink descriptors.
    /// Position: 0, Width: 1
    /// Access: read-only
    using INLINK_DSCR_EMPTY_INT_ST = BitField<0, 1>;
    constexpr uint32_t INLINK_DSCR_EMPTY_INT_ST_Pos = 0;
    constexpr uint32_t INLINK_DSCR_EMPTY_INT_ST_Msk = INLINK_DSCR_EMPTY_INT_ST::mask;

    /// The status bit for outlink descriptor error.
    /// Position: 1, Width: 1
    /// Access: read-only
    using OUTLINK_DSCR_ERROR_INT_ST = BitField<1, 1>;
    constexpr uint32_t OUTLINK_DSCR_ERROR_INT_ST_Pos = 1;
    constexpr uint32_t OUTLINK_DSCR_ERROR_INT_ST_Msk = OUTLINK_DSCR_ERROR_INT_ST::mask;

    /// The status bit for inlink descriptor error.
    /// Position: 2, Width: 1
    /// Access: read-only
    using INLINK_DSCR_ERROR_INT_ST = BitField<2, 1>;
    constexpr uint32_t INLINK_DSCR_ERROR_INT_ST_Pos = 2;
    constexpr uint32_t INLINK_DSCR_ERROR_INT_ST_Msk = INLINK_DSCR_ERROR_INT_ST::mask;

    /// The status bit for completing usage of a inlink descriptor.
    /// Position: 3, Width: 1
    /// Access: read-only
    using IN_DONE_INT_ST = BitField<3, 1>;
    constexpr uint32_t IN_DONE_INT_ST_Pos = 3;
    constexpr uint32_t IN_DONE_INT_ST_Msk = IN_DONE_INT_ST::mask;

    /// The status bit for receiving error.
    /// Position: 4, Width: 1
    /// Access: read-only
    using IN_ERR_EOF_INT_ST = BitField<4, 1>;
    constexpr uint32_t IN_ERR_EOF_INT_ST_Pos = 4;
    constexpr uint32_t IN_ERR_EOF_INT_ST_Msk = IN_ERR_EOF_INT_ST::mask;

    /// The status bit for completing receiving all the packets from host.
    /// Position: 5, Width: 1
    /// Access: read-only
    using IN_SUC_EOF_INT_ST = BitField<5, 1>;
    constexpr uint32_t IN_SUC_EOF_INT_ST_Pos = 5;
    constexpr uint32_t IN_SUC_EOF_INT_ST_Msk = IN_SUC_EOF_INT_ST::mask;

    /// The status bit for completing usage of a outlink descriptor.
    /// Position: 6, Width: 1
    /// Access: read-only
    using OUT_DONE_INT_ST = BitField<6, 1>;
    constexpr uint32_t OUT_DONE_INT_ST_Pos = 6;
    constexpr uint32_t OUT_DONE_INT_ST_Msk = OUT_DONE_INT_ST::mask;

    /// The status bit for sending a packet to host done.
    /// Position: 7, Width: 1
    /// Access: read-only
    using OUT_EOF_INT_ST = BitField<7, 1>;
    constexpr uint32_t OUT_EOF_INT_ST_Pos = 7;
    constexpr uint32_t OUT_EOF_INT_ST_Msk = OUT_EOF_INT_ST::mask;

    /// The status bit for sending all the packets to host done.
    /// Position: 8, Width: 1
    /// Access: read-only
    using OUT_TOTAL_EOF_INT_ST = BitField<8, 1>;
    constexpr uint32_t OUT_TOTAL_EOF_INT_ST_Pos = 8;
    constexpr uint32_t OUT_TOTAL_EOF_INT_ST_Msk = OUT_TOTAL_EOF_INT_ST::mask;

}  // namespace dma_int_st

/// DMA_INT_CLR - DMA_INT_CLR
namespace dma_int_clr {
    /// The clear bit for lack of enough inlink descriptors.
    /// Position: 0, Width: 1
    /// Access: read-write
    using INLINK_DSCR_EMPTY_INT_CLR = BitField<0, 1>;
    constexpr uint32_t INLINK_DSCR_EMPTY_INT_CLR_Pos = 0;
    constexpr uint32_t INLINK_DSCR_EMPTY_INT_CLR_Msk = INLINK_DSCR_EMPTY_INT_CLR::mask;

    /// The clear bit for outlink descriptor error.
    /// Position: 1, Width: 1
    /// Access: read-write
    using OUTLINK_DSCR_ERROR_INT_CLR = BitField<1, 1>;
    constexpr uint32_t OUTLINK_DSCR_ERROR_INT_CLR_Pos = 1;
    constexpr uint32_t OUTLINK_DSCR_ERROR_INT_CLR_Msk = OUTLINK_DSCR_ERROR_INT_CLR::mask;

    /// The clear bit for inlink descriptor error.
    /// Position: 2, Width: 1
    /// Access: read-write
    using INLINK_DSCR_ERROR_INT_CLR = BitField<2, 1>;
    constexpr uint32_t INLINK_DSCR_ERROR_INT_CLR_Pos = 2;
    constexpr uint32_t INLINK_DSCR_ERROR_INT_CLR_Msk = INLINK_DSCR_ERROR_INT_CLR::mask;

    /// The clear bit for completing usage of a inlink descriptor.
    /// Position: 3, Width: 1
    /// Access: read-write
    using IN_DONE_INT_CLR = BitField<3, 1>;
    constexpr uint32_t IN_DONE_INT_CLR_Pos = 3;
    constexpr uint32_t IN_DONE_INT_CLR_Msk = IN_DONE_INT_CLR::mask;

    /// The clear bit for receiving error.
    /// Position: 4, Width: 1
    /// Access: read-write
    using IN_ERR_EOF_INT_CLR = BitField<4, 1>;
    constexpr uint32_t IN_ERR_EOF_INT_CLR_Pos = 4;
    constexpr uint32_t IN_ERR_EOF_INT_CLR_Msk = IN_ERR_EOF_INT_CLR::mask;

    /// The clear bit for completing receiving all the packets from host.
    /// Position: 5, Width: 1
    /// Access: read-write
    using IN_SUC_EOF_INT_CLR = BitField<5, 1>;
    constexpr uint32_t IN_SUC_EOF_INT_CLR_Pos = 5;
    constexpr uint32_t IN_SUC_EOF_INT_CLR_Msk = IN_SUC_EOF_INT_CLR::mask;

    /// The clear bit for completing usage of a outlink descriptor.
    /// Position: 6, Width: 1
    /// Access: read-write
    using OUT_DONE_INT_CLR = BitField<6, 1>;
    constexpr uint32_t OUT_DONE_INT_CLR_Pos = 6;
    constexpr uint32_t OUT_DONE_INT_CLR_Msk = OUT_DONE_INT_CLR::mask;

    /// The clear bit for sending a packet to host done.
    /// Position: 7, Width: 1
    /// Access: read-write
    using OUT_EOF_INT_CLR = BitField<7, 1>;
    constexpr uint32_t OUT_EOF_INT_CLR_Pos = 7;
    constexpr uint32_t OUT_EOF_INT_CLR_Msk = OUT_EOF_INT_CLR::mask;

    /// The clear bit for sending all the packets to host done.
    /// Position: 8, Width: 1
    /// Access: read-write
    using OUT_TOTAL_EOF_INT_CLR = BitField<8, 1>;
    constexpr uint32_t OUT_TOTAL_EOF_INT_CLR_Pos = 8;
    constexpr uint32_t OUT_TOTAL_EOF_INT_CLR_Msk = OUT_TOTAL_EOF_INT_CLR::mask;

}  // namespace dma_int_clr

/// IN_ERR_EOF_DES_ADDR - IN_ERR_EOF_DES_ADDR
namespace in_err_eof_des_addr {
    /// The inlink descriptor address when spi dma produce receiving error.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_IN_ERR_EOF_DES_ADDR = BitField<0, 32>;
    constexpr uint32_t DMA_IN_ERR_EOF_DES_ADDR_Pos = 0;
    constexpr uint32_t DMA_IN_ERR_EOF_DES_ADDR_Msk = DMA_IN_ERR_EOF_DES_ADDR::mask;

}  // namespace in_err_eof_des_addr

/// IN_SUC_EOF_DES_ADDR - IN_SUC_EOF_DES_ADDR
namespace in_suc_eof_des_addr {
    /// The last inlink descriptor address when spi dma produce from_suc_eof.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_IN_SUC_EOF_DES_ADDR = BitField<0, 32>;
    constexpr uint32_t DMA_IN_SUC_EOF_DES_ADDR_Pos = 0;
    constexpr uint32_t DMA_IN_SUC_EOF_DES_ADDR_Msk = DMA_IN_SUC_EOF_DES_ADDR::mask;

}  // namespace in_suc_eof_des_addr

/// INLINK_DSCR - INLINK_DSCR
namespace inlink_dscr {
    /// The content of current in descriptor pointer.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_INLINK_DSCR = BitField<0, 32>;
    constexpr uint32_t DMA_INLINK_DSCR_Pos = 0;
    constexpr uint32_t DMA_INLINK_DSCR_Msk = DMA_INLINK_DSCR::mask;

}  // namespace inlink_dscr

/// INLINK_DSCR_BF0 - INLINK_DSCR_BF0
namespace inlink_dscr_bf0 {
    /// The content of next in descriptor pointer.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_INLINK_DSCR_BF0 = BitField<0, 32>;
    constexpr uint32_t DMA_INLINK_DSCR_BF0_Pos = 0;
    constexpr uint32_t DMA_INLINK_DSCR_BF0_Msk = DMA_INLINK_DSCR_BF0::mask;

}  // namespace inlink_dscr_bf0

/// INLINK_DSCR_BF1 - INLINK_DSCR_BF1
namespace inlink_dscr_bf1 {
    /// The content of current in descriptor data buffer pointer.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_INLINK_DSCR_BF1 = BitField<0, 32>;
    constexpr uint32_t DMA_INLINK_DSCR_BF1_Pos = 0;
    constexpr uint32_t DMA_INLINK_DSCR_BF1_Msk = DMA_INLINK_DSCR_BF1::mask;

}  // namespace inlink_dscr_bf1

/// OUT_EOF_BFR_DES_ADDR - OUT_EOF_BFR_DES_ADDR
namespace out_eof_bfr_des_addr {
    /// The address of buffer relative to the outlink descriptor that produce eof.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_OUT_EOF_BFR_DES_ADDR = BitField<0, 32>;
    constexpr uint32_t DMA_OUT_EOF_BFR_DES_ADDR_Pos = 0;
    constexpr uint32_t DMA_OUT_EOF_BFR_DES_ADDR_Msk = DMA_OUT_EOF_BFR_DES_ADDR::mask;

}  // namespace out_eof_bfr_des_addr

/// OUT_EOF_DES_ADDR - OUT_EOF_DES_ADDR
namespace out_eof_des_addr {
    /// The last outlink descriptor address when spi dma produce to_eof.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_OUT_EOF_DES_ADDR = BitField<0, 32>;
    constexpr uint32_t DMA_OUT_EOF_DES_ADDR_Pos = 0;
    constexpr uint32_t DMA_OUT_EOF_DES_ADDR_Msk = DMA_OUT_EOF_DES_ADDR::mask;

}  // namespace out_eof_des_addr

/// OUTLINK_DSCR - OUTLINK_DSCR
namespace outlink_dscr {
    /// The content of current out descriptor pointer.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_OUTLINK_DSCR = BitField<0, 32>;
    constexpr uint32_t DMA_OUTLINK_DSCR_Pos = 0;
    constexpr uint32_t DMA_OUTLINK_DSCR_Msk = DMA_OUTLINK_DSCR::mask;

}  // namespace outlink_dscr

/// OUTLINK_DSCR_BF0 - OUTLINK_DSCR_BF0
namespace outlink_dscr_bf0 {
    /// The content of next out descriptor pointer.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_OUTLINK_DSCR_BF0 = BitField<0, 32>;
    constexpr uint32_t DMA_OUTLINK_DSCR_BF0_Pos = 0;
    constexpr uint32_t DMA_OUTLINK_DSCR_BF0_Msk = DMA_OUTLINK_DSCR_BF0::mask;

}  // namespace outlink_dscr_bf0

/// OUTLINK_DSCR_BF1 - OUTLINK_DSCR_BF1
namespace outlink_dscr_bf1 {
    /// The content of current out descriptor data buffer pointer.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_OUTLINK_DSCR_BF1 = BitField<0, 32>;
    constexpr uint32_t DMA_OUTLINK_DSCR_BF1_Pos = 0;
    constexpr uint32_t DMA_OUTLINK_DSCR_BF1_Msk = DMA_OUTLINK_DSCR_BF1::mask;

}  // namespace outlink_dscr_bf1

/// DMA_RSTATUS - DMA_RSTATUS
namespace dma_rstatus {
    /// spi dma read data from memory status.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_OUT_STATUS = BitField<0, 32>;
    constexpr uint32_t DMA_OUT_STATUS_Pos = 0;
    constexpr uint32_t DMA_OUT_STATUS_Msk = DMA_OUT_STATUS::mask;

}  // namespace dma_rstatus

/// DMA_TSTATUS - DMA_TSTATUS
namespace dma_tstatus {
    /// spi dma write data to memory status.
    /// Position: 0, Width: 32
    /// Access: read-only
    using DMA_IN_STATUS = BitField<0, 32>;
    constexpr uint32_t DMA_IN_STATUS_Pos = 0;
    constexpr uint32_t DMA_IN_STATUS_Msk = DMA_IN_STATUS::mask;

}  // namespace dma_tstatus

/// DATE - DATE
namespace date {
    /// SPI register version.
    /// Position: 0, Width: 28
    /// Access: read-only
    using DATE = BitField<0, 28>;
    constexpr uint32_t DATE_Pos = 0;
    constexpr uint32_t DATE_Msk = DATE::mask;

}  // namespace date

}  // namespace alloy::hal::espressif::esp32::esp32::spi0
