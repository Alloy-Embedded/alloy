/// Auto-generated bit field definitions for UART0
/// Device: ESP32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::espressif::esp32::esp32::uart0 {

using namespace alloy::hal::bitfields;

// ============================================================================
// UART0 Bit Field Definitions
// ============================================================================

/// FIFO - FIFO
namespace fifo {
    /// This register stores one byte data  read by rx fifo.
    /// Position: 0, Width: 8
    /// Access: read-write
    using RXFIFO_RD_BYTE = BitField<0, 8>;
    constexpr uint32_t RXFIFO_RD_BYTE_Pos = 0;
    constexpr uint32_t RXFIFO_RD_BYTE_Msk = RXFIFO_RD_BYTE::mask;

}  // namespace fifo

/// INT_RAW - INT_RAW
namespace int_raw {
    /// This interrupt raw bit turns to high level when receiver receives more data than (rx_flow_thrhd_h3 rx_flow_thrhd).
    /// Position: 0, Width: 1
    /// Access: read-only
    using RXFIFO_FULL_INT_RAW = BitField<0, 1>;
    constexpr uint32_t RXFIFO_FULL_INT_RAW_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_INT_RAW_Msk = RXFIFO_FULL_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when the amount of data in transmitter's fifo is less than ((tx_mem_cnttxfifo_cnt) .
    /// Position: 1, Width: 1
    /// Access: read-only
    using TXFIFO_EMPTY_INT_RAW = BitField<1, 1>;
    constexpr uint32_t TXFIFO_EMPTY_INT_RAW_Pos = 1;
    constexpr uint32_t TXFIFO_EMPTY_INT_RAW_Msk = TXFIFO_EMPTY_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver detects the parity error of data.
    /// Position: 2, Width: 1
    /// Access: read-only
    using PARITY_ERR_INT_RAW = BitField<2, 1>;
    constexpr uint32_t PARITY_ERR_INT_RAW_Pos = 2;
    constexpr uint32_t PARITY_ERR_INT_RAW_Msk = PARITY_ERR_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver detects data's frame error .
    /// Position: 3, Width: 1
    /// Access: read-only
    using FRM_ERR_INT_RAW = BitField<3, 1>;
    constexpr uint32_t FRM_ERR_INT_RAW_Pos = 3;
    constexpr uint32_t FRM_ERR_INT_RAW_Msk = FRM_ERR_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver receives more data than the fifo can store.
    /// Position: 4, Width: 1
    /// Access: read-only
    using RXFIFO_OVF_INT_RAW = BitField<4, 1>;
    constexpr uint32_t RXFIFO_OVF_INT_RAW_Pos = 4;
    constexpr uint32_t RXFIFO_OVF_INT_RAW_Msk = RXFIFO_OVF_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver detects the edge change of dsrn signal.
    /// Position: 5, Width: 1
    /// Access: read-only
    using DSR_CHG_INT_RAW = BitField<5, 1>;
    constexpr uint32_t DSR_CHG_INT_RAW_Pos = 5;
    constexpr uint32_t DSR_CHG_INT_RAW_Msk = DSR_CHG_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver detects the edge change of ctsn signal.
    /// Position: 6, Width: 1
    /// Access: read-only
    using CTS_CHG_INT_RAW = BitField<6, 1>;
    constexpr uint32_t CTS_CHG_INT_RAW_Pos = 6;
    constexpr uint32_t CTS_CHG_INT_RAW_Msk = CTS_CHG_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver detects the 0 after the stop bit.
    /// Position: 7, Width: 1
    /// Access: read-only
    using BRK_DET_INT_RAW = BitField<7, 1>;
    constexpr uint32_t BRK_DET_INT_RAW_Pos = 7;
    constexpr uint32_t BRK_DET_INT_RAW_Msk = BRK_DET_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
    /// Position: 8, Width: 1
    /// Access: read-only
    using RXFIFO_TOUT_INT_RAW = BitField<8, 1>;
    constexpr uint32_t RXFIFO_TOUT_INT_RAW_Pos = 8;
    constexpr uint32_t RXFIFO_TOUT_INT_RAW_Msk = RXFIFO_TOUT_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver receives xoff char with uart_sw_flow_con_en is set to 1.
    /// Position: 9, Width: 1
    /// Access: read-only
    using SW_XON_INT_RAW = BitField<9, 1>;
    constexpr uint32_t SW_XON_INT_RAW_Pos = 9;
    constexpr uint32_t SW_XON_INT_RAW_Msk = SW_XON_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver receives xon char with uart_sw_flow_con_en is set to 1.
    /// Position: 10, Width: 1
    /// Access: read-only
    using SW_XOFF_INT_RAW = BitField<10, 1>;
    constexpr uint32_t SW_XOFF_INT_RAW_Pos = 10;
    constexpr uint32_t SW_XOFF_INT_RAW_Msk = SW_XOFF_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver detects the start bit.
    /// Position: 11, Width: 1
    /// Access: read-only
    using GLITCH_DET_INT_RAW = BitField<11, 1>;
    constexpr uint32_t GLITCH_DET_INT_RAW_Pos = 11;
    constexpr uint32_t GLITCH_DET_INT_RAW_Msk = GLITCH_DET_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when transmitter completes  sendding  0 after all the datas in transmitter's fifo are send.
    /// Position: 12, Width: 1
    /// Access: read-only
    using TX_BRK_DONE_INT_RAW = BitField<12, 1>;
    constexpr uint32_t TX_BRK_DONE_INT_RAW_Pos = 12;
    constexpr uint32_t TX_BRK_DONE_INT_RAW_Msk = TX_BRK_DONE_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when transmitter has kept the shortest duration after the  last data has been send.
    /// Position: 13, Width: 1
    /// Access: read-only
    using TX_BRK_IDLE_DONE_INT_RAW = BitField<13, 1>;
    constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW_Pos = 13;
    constexpr uint32_t TX_BRK_IDLE_DONE_INT_RAW_Msk = TX_BRK_IDLE_DONE_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when transmitter has send all the data in fifo.
    /// Position: 14, Width: 1
    /// Access: read-only
    using TX_DONE_INT_RAW = BitField<14, 1>;
    constexpr uint32_t TX_DONE_INT_RAW_Pos = 14;
    constexpr uint32_t TX_DONE_INT_RAW_Msk = TX_DONE_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when rs485 detects the parity error.
    /// Position: 15, Width: 1
    /// Access: read-only
    using RS485_PARITY_ERR_INT_RAW = BitField<15, 1>;
    constexpr uint32_t RS485_PARITY_ERR_INT_RAW_Pos = 15;
    constexpr uint32_t RS485_PARITY_ERR_INT_RAW_Msk = RS485_PARITY_ERR_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when rs485 detects the data frame error.
    /// Position: 16, Width: 1
    /// Access: read-only
    using RS485_FRM_ERR_INT_RAW = BitField<16, 1>;
    constexpr uint32_t RS485_FRM_ERR_INT_RAW_Pos = 16;
    constexpr uint32_t RS485_FRM_ERR_INT_RAW_Msk = RS485_FRM_ERR_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when rs485 detects the clash between transmitter and receiver.
    /// Position: 17, Width: 1
    /// Access: read-only
    using RS485_CLASH_INT_RAW = BitField<17, 1>;
    constexpr uint32_t RS485_CLASH_INT_RAW_Pos = 17;
    constexpr uint32_t RS485_CLASH_INT_RAW_Msk = RS485_CLASH_INT_RAW::mask;

    /// This interrupt raw bit turns to high level when receiver detects the configured at_cmd chars.
    /// Position: 18, Width: 1
    /// Access: read-only
    using AT_CMD_CHAR_DET_INT_RAW = BitField<18, 1>;
    constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW_Pos = 18;
    constexpr uint32_t AT_CMD_CHAR_DET_INT_RAW_Msk = AT_CMD_CHAR_DET_INT_RAW::mask;

}  // namespace int_raw

/// INT_ST - INT_ST
namespace int_st {
    /// This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
    /// Position: 0, Width: 1
    /// Access: read-only
    using RXFIFO_FULL_INT_ST = BitField<0, 1>;
    constexpr uint32_t RXFIFO_FULL_INT_ST_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_INT_ST_Msk = RXFIFO_FULL_INT_ST::mask;

    /// This is the status bit for  txfifo_empty_int_raw  when txfifo_empty_int_ena is set to 1.
    /// Position: 1, Width: 1
    /// Access: read-only
    using TXFIFO_EMPTY_INT_ST = BitField<1, 1>;
    constexpr uint32_t TXFIFO_EMPTY_INT_ST_Pos = 1;
    constexpr uint32_t TXFIFO_EMPTY_INT_ST_Msk = TXFIFO_EMPTY_INT_ST::mask;

    /// This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
    /// Position: 2, Width: 1
    /// Access: read-only
    using PARITY_ERR_INT_ST = BitField<2, 1>;
    constexpr uint32_t PARITY_ERR_INT_ST_Pos = 2;
    constexpr uint32_t PARITY_ERR_INT_ST_Msk = PARITY_ERR_INT_ST::mask;

    /// This is the status bit for frm_err_int_raw when fm_err_int_ena is set to 1.
    /// Position: 3, Width: 1
    /// Access: read-only
    using FRM_ERR_INT_ST = BitField<3, 1>;
    constexpr uint32_t FRM_ERR_INT_ST_Pos = 3;
    constexpr uint32_t FRM_ERR_INT_ST_Msk = FRM_ERR_INT_ST::mask;

    /// This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
    /// Position: 4, Width: 1
    /// Access: read-only
    using RXFIFO_OVF_INT_ST = BitField<4, 1>;
    constexpr uint32_t RXFIFO_OVF_INT_ST_Pos = 4;
    constexpr uint32_t RXFIFO_OVF_INT_ST_Msk = RXFIFO_OVF_INT_ST::mask;

    /// This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
    /// Position: 5, Width: 1
    /// Access: read-only
    using DSR_CHG_INT_ST = BitField<5, 1>;
    constexpr uint32_t DSR_CHG_INT_ST_Pos = 5;
    constexpr uint32_t DSR_CHG_INT_ST_Msk = DSR_CHG_INT_ST::mask;

    /// This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
    /// Position: 6, Width: 1
    /// Access: read-only
    using CTS_CHG_INT_ST = BitField<6, 1>;
    constexpr uint32_t CTS_CHG_INT_ST_Pos = 6;
    constexpr uint32_t CTS_CHG_INT_ST_Msk = CTS_CHG_INT_ST::mask;

    /// This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
    /// Position: 7, Width: 1
    /// Access: read-only
    using BRK_DET_INT_ST = BitField<7, 1>;
    constexpr uint32_t BRK_DET_INT_ST_Pos = 7;
    constexpr uint32_t BRK_DET_INT_ST_Msk = BRK_DET_INT_ST::mask;

    /// This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
    /// Position: 8, Width: 1
    /// Access: read-only
    using RXFIFO_TOUT_INT_ST = BitField<8, 1>;
    constexpr uint32_t RXFIFO_TOUT_INT_ST_Pos = 8;
    constexpr uint32_t RXFIFO_TOUT_INT_ST_Msk = RXFIFO_TOUT_INT_ST::mask;

    /// This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
    /// Position: 9, Width: 1
    /// Access: read-only
    using SW_XON_INT_ST = BitField<9, 1>;
    constexpr uint32_t SW_XON_INT_ST_Pos = 9;
    constexpr uint32_t SW_XON_INT_ST_Msk = SW_XON_INT_ST::mask;

    /// This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
    /// Position: 10, Width: 1
    /// Access: read-only
    using SW_XOFF_INT_ST = BitField<10, 1>;
    constexpr uint32_t SW_XOFF_INT_ST_Pos = 10;
    constexpr uint32_t SW_XOFF_INT_ST_Msk = SW_XOFF_INT_ST::mask;

    /// This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
    /// Position: 11, Width: 1
    /// Access: read-only
    using GLITCH_DET_INT_ST = BitField<11, 1>;
    constexpr uint32_t GLITCH_DET_INT_ST_Pos = 11;
    constexpr uint32_t GLITCH_DET_INT_ST_Msk = GLITCH_DET_INT_ST::mask;

    /// This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
    /// Position: 12, Width: 1
    /// Access: read-only
    using TX_BRK_DONE_INT_ST = BitField<12, 1>;
    constexpr uint32_t TX_BRK_DONE_INT_ST_Pos = 12;
    constexpr uint32_t TX_BRK_DONE_INT_ST_Msk = TX_BRK_DONE_INT_ST::mask;

    /// This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
    /// Position: 13, Width: 1
    /// Access: read-only
    using TX_BRK_IDLE_DONE_INT_ST = BitField<13, 1>;
    constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST_Pos = 13;
    constexpr uint32_t TX_BRK_IDLE_DONE_INT_ST_Msk = TX_BRK_IDLE_DONE_INT_ST::mask;

    /// This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
    /// Position: 14, Width: 1
    /// Access: read-only
    using TX_DONE_INT_ST = BitField<14, 1>;
    constexpr uint32_t TX_DONE_INT_ST_Pos = 14;
    constexpr uint32_t TX_DONE_INT_ST_Msk = TX_DONE_INT_ST::mask;

    /// This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
    /// Position: 15, Width: 1
    /// Access: read-only
    using RS485_PARITY_ERR_INT_ST = BitField<15, 1>;
    constexpr uint32_t RS485_PARITY_ERR_INT_ST_Pos = 15;
    constexpr uint32_t RS485_PARITY_ERR_INT_ST_Msk = RS485_PARITY_ERR_INT_ST::mask;

    /// This is the status bit for rs485_fm_err_int_raw when rs485_fm_err_int_ena is set to 1.
    /// Position: 16, Width: 1
    /// Access: read-only
    using RS485_FRM_ERR_INT_ST = BitField<16, 1>;
    constexpr uint32_t RS485_FRM_ERR_INT_ST_Pos = 16;
    constexpr uint32_t RS485_FRM_ERR_INT_ST_Msk = RS485_FRM_ERR_INT_ST::mask;

    /// This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
    /// Position: 17, Width: 1
    /// Access: read-only
    using RS485_CLASH_INT_ST = BitField<17, 1>;
    constexpr uint32_t RS485_CLASH_INT_ST_Pos = 17;
    constexpr uint32_t RS485_CLASH_INT_ST_Msk = RS485_CLASH_INT_ST::mask;

    /// This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
    /// Position: 18, Width: 1
    /// Access: read-only
    using AT_CMD_CHAR_DET_INT_ST = BitField<18, 1>;
    constexpr uint32_t AT_CMD_CHAR_DET_INT_ST_Pos = 18;
    constexpr uint32_t AT_CMD_CHAR_DET_INT_ST_Msk = AT_CMD_CHAR_DET_INT_ST::mask;

}  // namespace int_st

/// INT_ENA - INT_ENA
namespace int_ena {
    /// This is the enable bit for rxfifo_full_int_st register.
    /// Position: 0, Width: 1
    /// Access: read-write
    using RXFIFO_FULL_INT_ENA = BitField<0, 1>;
    constexpr uint32_t RXFIFO_FULL_INT_ENA_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_INT_ENA_Msk = RXFIFO_FULL_INT_ENA::mask;

    /// This is the enable bit for rxfifo_full_int_st register.
    /// Position: 1, Width: 1
    /// Access: read-write
    using TXFIFO_EMPTY_INT_ENA = BitField<1, 1>;
    constexpr uint32_t TXFIFO_EMPTY_INT_ENA_Pos = 1;
    constexpr uint32_t TXFIFO_EMPTY_INT_ENA_Msk = TXFIFO_EMPTY_INT_ENA::mask;

    /// This is the enable bit for parity_err_int_st register.
    /// Position: 2, Width: 1
    /// Access: read-write
    using PARITY_ERR_INT_ENA = BitField<2, 1>;
    constexpr uint32_t PARITY_ERR_INT_ENA_Pos = 2;
    constexpr uint32_t PARITY_ERR_INT_ENA_Msk = PARITY_ERR_INT_ENA::mask;

    /// This is the enable bit for frm_err_int_st register.
    /// Position: 3, Width: 1
    /// Access: read-write
    using FRM_ERR_INT_ENA = BitField<3, 1>;
    constexpr uint32_t FRM_ERR_INT_ENA_Pos = 3;
    constexpr uint32_t FRM_ERR_INT_ENA_Msk = FRM_ERR_INT_ENA::mask;

    /// This is the enable bit for rxfifo_ovf_int_st register.
    /// Position: 4, Width: 1
    /// Access: read-write
    using RXFIFO_OVF_INT_ENA = BitField<4, 1>;
    constexpr uint32_t RXFIFO_OVF_INT_ENA_Pos = 4;
    constexpr uint32_t RXFIFO_OVF_INT_ENA_Msk = RXFIFO_OVF_INT_ENA::mask;

    /// This is the enable bit for dsr_chg_int_st register.
    /// Position: 5, Width: 1
    /// Access: read-write
    using DSR_CHG_INT_ENA = BitField<5, 1>;
    constexpr uint32_t DSR_CHG_INT_ENA_Pos = 5;
    constexpr uint32_t DSR_CHG_INT_ENA_Msk = DSR_CHG_INT_ENA::mask;

    /// This is the enable bit for cts_chg_int_st register.
    /// Position: 6, Width: 1
    /// Access: read-write
    using CTS_CHG_INT_ENA = BitField<6, 1>;
    constexpr uint32_t CTS_CHG_INT_ENA_Pos = 6;
    constexpr uint32_t CTS_CHG_INT_ENA_Msk = CTS_CHG_INT_ENA::mask;

    /// This is the enable bit for brk_det_int_st register.
    /// Position: 7, Width: 1
    /// Access: read-write
    using BRK_DET_INT_ENA = BitField<7, 1>;
    constexpr uint32_t BRK_DET_INT_ENA_Pos = 7;
    constexpr uint32_t BRK_DET_INT_ENA_Msk = BRK_DET_INT_ENA::mask;

    /// This is the enable bit for rxfifo_tout_int_st register.
    /// Position: 8, Width: 1
    /// Access: read-write
    using RXFIFO_TOUT_INT_ENA = BitField<8, 1>;
    constexpr uint32_t RXFIFO_TOUT_INT_ENA_Pos = 8;
    constexpr uint32_t RXFIFO_TOUT_INT_ENA_Msk = RXFIFO_TOUT_INT_ENA::mask;

    /// This is the enable bit for sw_xon_int_st register.
    /// Position: 9, Width: 1
    /// Access: read-write
    using SW_XON_INT_ENA = BitField<9, 1>;
    constexpr uint32_t SW_XON_INT_ENA_Pos = 9;
    constexpr uint32_t SW_XON_INT_ENA_Msk = SW_XON_INT_ENA::mask;

    /// This is the enable bit for sw_xoff_int_st register.
    /// Position: 10, Width: 1
    /// Access: read-write
    using SW_XOFF_INT_ENA = BitField<10, 1>;
    constexpr uint32_t SW_XOFF_INT_ENA_Pos = 10;
    constexpr uint32_t SW_XOFF_INT_ENA_Msk = SW_XOFF_INT_ENA::mask;

    /// This is the enable bit for glitch_det_int_st register.
    /// Position: 11, Width: 1
    /// Access: read-write
    using GLITCH_DET_INT_ENA = BitField<11, 1>;
    constexpr uint32_t GLITCH_DET_INT_ENA_Pos = 11;
    constexpr uint32_t GLITCH_DET_INT_ENA_Msk = GLITCH_DET_INT_ENA::mask;

    /// This is the enable bit for tx_brk_done_int_st register.
    /// Position: 12, Width: 1
    /// Access: read-write
    using TX_BRK_DONE_INT_ENA = BitField<12, 1>;
    constexpr uint32_t TX_BRK_DONE_INT_ENA_Pos = 12;
    constexpr uint32_t TX_BRK_DONE_INT_ENA_Msk = TX_BRK_DONE_INT_ENA::mask;

    /// This is the enable bit for tx_brk_idle_done_int_st register.
    /// Position: 13, Width: 1
    /// Access: read-write
    using TX_BRK_IDLE_DONE_INT_ENA = BitField<13, 1>;
    constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA_Pos = 13;
    constexpr uint32_t TX_BRK_IDLE_DONE_INT_ENA_Msk = TX_BRK_IDLE_DONE_INT_ENA::mask;

    /// This is the enable bit for tx_done_int_st register.
    /// Position: 14, Width: 1
    /// Access: read-write
    using TX_DONE_INT_ENA = BitField<14, 1>;
    constexpr uint32_t TX_DONE_INT_ENA_Pos = 14;
    constexpr uint32_t TX_DONE_INT_ENA_Msk = TX_DONE_INT_ENA::mask;

    /// This is the enable bit for rs485_parity_err_int_st register.
    /// Position: 15, Width: 1
    /// Access: read-write
    using RS485_PARITY_ERR_INT_ENA = BitField<15, 1>;
    constexpr uint32_t RS485_PARITY_ERR_INT_ENA_Pos = 15;
    constexpr uint32_t RS485_PARITY_ERR_INT_ENA_Msk = RS485_PARITY_ERR_INT_ENA::mask;

    /// This is the enable bit for rs485_parity_err_int_st register.
    /// Position: 16, Width: 1
    /// Access: read-write
    using RS485_FRM_ERR_INT_ENA = BitField<16, 1>;
    constexpr uint32_t RS485_FRM_ERR_INT_ENA_Pos = 16;
    constexpr uint32_t RS485_FRM_ERR_INT_ENA_Msk = RS485_FRM_ERR_INT_ENA::mask;

    /// This is the enable bit for rs485_clash_int_st register.
    /// Position: 17, Width: 1
    /// Access: read-write
    using RS485_CLASH_INT_ENA = BitField<17, 1>;
    constexpr uint32_t RS485_CLASH_INT_ENA_Pos = 17;
    constexpr uint32_t RS485_CLASH_INT_ENA_Msk = RS485_CLASH_INT_ENA::mask;

    /// This is the enable bit for at_cmd_char_det_int_st register.
    /// Position: 18, Width: 1
    /// Access: read-write
    using AT_CMD_CHAR_DET_INT_ENA = BitField<18, 1>;
    constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA_Pos = 18;
    constexpr uint32_t AT_CMD_CHAR_DET_INT_ENA_Msk = AT_CMD_CHAR_DET_INT_ENA::mask;

}  // namespace int_ena

/// INT_CLR - INT_CLR
namespace int_clr {
    /// Set this bit to clear the rxfifo_full_int_raw interrupt.
    /// Position: 0, Width: 1
    /// Access: write-only
    using RXFIFO_FULL_INT_CLR = BitField<0, 1>;
    constexpr uint32_t RXFIFO_FULL_INT_CLR_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_INT_CLR_Msk = RXFIFO_FULL_INT_CLR::mask;

    /// Set this bit to clear txfifo_empty_int_raw interrupt.
    /// Position: 1, Width: 1
    /// Access: write-only
    using TXFIFO_EMPTY_INT_CLR = BitField<1, 1>;
    constexpr uint32_t TXFIFO_EMPTY_INT_CLR_Pos = 1;
    constexpr uint32_t TXFIFO_EMPTY_INT_CLR_Msk = TXFIFO_EMPTY_INT_CLR::mask;

    /// Set this bit to clear parity_err_int_raw interrupt.
    /// Position: 2, Width: 1
    /// Access: write-only
    using PARITY_ERR_INT_CLR = BitField<2, 1>;
    constexpr uint32_t PARITY_ERR_INT_CLR_Pos = 2;
    constexpr uint32_t PARITY_ERR_INT_CLR_Msk = PARITY_ERR_INT_CLR::mask;

    /// Set this bit to clear frm_err_int_raw interrupt.
    /// Position: 3, Width: 1
    /// Access: write-only
    using FRM_ERR_INT_CLR = BitField<3, 1>;
    constexpr uint32_t FRM_ERR_INT_CLR_Pos = 3;
    constexpr uint32_t FRM_ERR_INT_CLR_Msk = FRM_ERR_INT_CLR::mask;

    /// Set this bit to clear rxfifo_ovf_int_raw interrupt.
    /// Position: 4, Width: 1
    /// Access: write-only
    using RXFIFO_OVF_INT_CLR = BitField<4, 1>;
    constexpr uint32_t RXFIFO_OVF_INT_CLR_Pos = 4;
    constexpr uint32_t RXFIFO_OVF_INT_CLR_Msk = RXFIFO_OVF_INT_CLR::mask;

    /// Set this bit to clear the dsr_chg_int_raw interrupt.
    /// Position: 5, Width: 1
    /// Access: write-only
    using DSR_CHG_INT_CLR = BitField<5, 1>;
    constexpr uint32_t DSR_CHG_INT_CLR_Pos = 5;
    constexpr uint32_t DSR_CHG_INT_CLR_Msk = DSR_CHG_INT_CLR::mask;

    /// Set this bit to clear the cts_chg_int_raw interrupt.
    /// Position: 6, Width: 1
    /// Access: write-only
    using CTS_CHG_INT_CLR = BitField<6, 1>;
    constexpr uint32_t CTS_CHG_INT_CLR_Pos = 6;
    constexpr uint32_t CTS_CHG_INT_CLR_Msk = CTS_CHG_INT_CLR::mask;

    /// Set this bit to clear the brk_det_int_raw interrupt.
    /// Position: 7, Width: 1
    /// Access: write-only
    using BRK_DET_INT_CLR = BitField<7, 1>;
    constexpr uint32_t BRK_DET_INT_CLR_Pos = 7;
    constexpr uint32_t BRK_DET_INT_CLR_Msk = BRK_DET_INT_CLR::mask;

    /// Set this bit to clear the rxfifo_tout_int_raw interrupt.
    /// Position: 8, Width: 1
    /// Access: write-only
    using RXFIFO_TOUT_INT_CLR = BitField<8, 1>;
    constexpr uint32_t RXFIFO_TOUT_INT_CLR_Pos = 8;
    constexpr uint32_t RXFIFO_TOUT_INT_CLR_Msk = RXFIFO_TOUT_INT_CLR::mask;

    /// Set this bit to clear the sw_xon_int_raw interrupt.
    /// Position: 9, Width: 1
    /// Access: write-only
    using SW_XON_INT_CLR = BitField<9, 1>;
    constexpr uint32_t SW_XON_INT_CLR_Pos = 9;
    constexpr uint32_t SW_XON_INT_CLR_Msk = SW_XON_INT_CLR::mask;

    /// Set this bit to clear the sw_xon_int_raw interrupt.
    /// Position: 10, Width: 1
    /// Access: write-only
    using SW_XOFF_INT_CLR = BitField<10, 1>;
    constexpr uint32_t SW_XOFF_INT_CLR_Pos = 10;
    constexpr uint32_t SW_XOFF_INT_CLR_Msk = SW_XOFF_INT_CLR::mask;

    /// Set this bit to clear the glitch_det_int_raw interrupt.
    /// Position: 11, Width: 1
    /// Access: write-only
    using GLITCH_DET_INT_CLR = BitField<11, 1>;
    constexpr uint32_t GLITCH_DET_INT_CLR_Pos = 11;
    constexpr uint32_t GLITCH_DET_INT_CLR_Msk = GLITCH_DET_INT_CLR::mask;

    /// Set this bit to clear the tx_brk_done_int_raw interrupt..
    /// Position: 12, Width: 1
    /// Access: write-only
    using TX_BRK_DONE_INT_CLR = BitField<12, 1>;
    constexpr uint32_t TX_BRK_DONE_INT_CLR_Pos = 12;
    constexpr uint32_t TX_BRK_DONE_INT_CLR_Msk = TX_BRK_DONE_INT_CLR::mask;

    /// Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
    /// Position: 13, Width: 1
    /// Access: write-only
    using TX_BRK_IDLE_DONE_INT_CLR = BitField<13, 1>;
    constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR_Pos = 13;
    constexpr uint32_t TX_BRK_IDLE_DONE_INT_CLR_Msk = TX_BRK_IDLE_DONE_INT_CLR::mask;

    /// Set this bit to clear the tx_done_int_raw interrupt.
    /// Position: 14, Width: 1
    /// Access: write-only
    using TX_DONE_INT_CLR = BitField<14, 1>;
    constexpr uint32_t TX_DONE_INT_CLR_Pos = 14;
    constexpr uint32_t TX_DONE_INT_CLR_Msk = TX_DONE_INT_CLR::mask;

    /// Set this bit to clear the rs485_parity_err_int_raw interrupt.
    /// Position: 15, Width: 1
    /// Access: write-only
    using RS485_PARITY_ERR_INT_CLR = BitField<15, 1>;
    constexpr uint32_t RS485_PARITY_ERR_INT_CLR_Pos = 15;
    constexpr uint32_t RS485_PARITY_ERR_INT_CLR_Msk = RS485_PARITY_ERR_INT_CLR::mask;

    /// Set this bit to clear the rs485_frm_err_int_raw interrupt.
    /// Position: 16, Width: 1
    /// Access: write-only
    using RS485_FRM_ERR_INT_CLR = BitField<16, 1>;
    constexpr uint32_t RS485_FRM_ERR_INT_CLR_Pos = 16;
    constexpr uint32_t RS485_FRM_ERR_INT_CLR_Msk = RS485_FRM_ERR_INT_CLR::mask;

    /// Set this bit to clear the rs485_clash_int_raw interrupt.
    /// Position: 17, Width: 1
    /// Access: write-only
    using RS485_CLASH_INT_CLR = BitField<17, 1>;
    constexpr uint32_t RS485_CLASH_INT_CLR_Pos = 17;
    constexpr uint32_t RS485_CLASH_INT_CLR_Msk = RS485_CLASH_INT_CLR::mask;

    /// Set this bit to clear the at_cmd_char_det_int_raw interrupt.
    /// Position: 18, Width: 1
    /// Access: write-only
    using AT_CMD_CHAR_DET_INT_CLR = BitField<18, 1>;
    constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR_Pos = 18;
    constexpr uint32_t AT_CMD_CHAR_DET_INT_CLR_Msk = AT_CMD_CHAR_DET_INT_CLR::mask;

}  // namespace int_clr

/// CLKDIV - CLKDIV
namespace clkdiv {
    /// The register value is  the  integer part of the frequency divider's factor.
    /// Position: 0, Width: 20
    /// Access: read-write
    using CLKDIV = BitField<0, 20>;
    constexpr uint32_t CLKDIV_Pos = 0;
    constexpr uint32_t CLKDIV_Msk = CLKDIV::mask;

    /// The register  value is the decimal part of the frequency divider's factor.
    /// Position: 20, Width: 4
    /// Access: read-write
    using FRAG = BitField<20, 4>;
    constexpr uint32_t FRAG_Pos = 20;
    constexpr uint32_t FRAG_Msk = FRAG::mask;

}  // namespace clkdiv

/// AUTOBAUD - AUTOBAUD
namespace autobaud {
    /// This is the enable bit for detecting baudrate.
    /// Position: 0, Width: 1
    /// Access: read-write
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;

    /// when input pulse width is lower then this value igore this pulse.this register is used in autobaud detect process.
    /// Position: 8, Width: 8
    /// Access: read-write
    using GLITCH_FILT = BitField<8, 8>;
    constexpr uint32_t GLITCH_FILT_Pos = 8;
    constexpr uint32_t GLITCH_FILT_Msk = GLITCH_FILT::mask;

}  // namespace autobaud

/// STATUS - STATUS
namespace status {
    /// (rx_mem_cnt rxfifo_cnt) stores the byte num of valid datas in receiver's fifo. rx_mem_cnt register stores the 3 most significant bits  rxfifo_cnt stores the 8 least significant bits.
    /// Position: 0, Width: 8
    /// Access: read-only
    using RXFIFO_CNT = BitField<0, 8>;
    constexpr uint32_t RXFIFO_CNT_Pos = 0;
    constexpr uint32_t RXFIFO_CNT_Msk = RXFIFO_CNT::mask;

    /// This register stores the value of receiver's finite state machine. 0:RX_IDLE  1:RX_STRT  2:RX_DAT0  3:RX_DAT1  4:RX_DAT2  5:RX_DAT3  6:RX_DAT4  7:RX_DAT5  8:RX_DAT6  9:RX_DAT7   10:RX_PRTY   11:RX_STP1  12:RX_STP2 13:RX_DL1
    /// Position: 8, Width: 4
    /// Access: read-only
    using ST_URX_OUT = BitField<8, 4>;
    constexpr uint32_t ST_URX_OUT_Pos = 8;
    constexpr uint32_t ST_URX_OUT_Msk = ST_URX_OUT::mask;

    /// This register stores the level value of the internal uart dsr signal.
    /// Position: 13, Width: 1
    /// Access: read-only
    using DSRN = BitField<13, 1>;
    constexpr uint32_t DSRN_Pos = 13;
    constexpr uint32_t DSRN_Msk = DSRN::mask;

    /// This register stores the level value of the internal uart cts signal.
    /// Position: 14, Width: 1
    /// Access: read-only
    using CTSN = BitField<14, 1>;
    constexpr uint32_t CTSN_Pos = 14;
    constexpr uint32_t CTSN_Msk = CTSN::mask;

    /// This register stores the level value of the internal uart rxd signal.
    /// Position: 15, Width: 1
    /// Access: read-only
    using RXD = BitField<15, 1>;
    constexpr uint32_t RXD_Pos = 15;
    constexpr uint32_t RXD_Msk = RXD::mask;

    /// (tx_mem_cnt txfifo_cnt) stores the byte num of valid datas in transmitter's fifo.tx_mem_cnt stores the 3 most significant bits  txfifo_cnt stores the 8 least significant bits.
    /// Position: 16, Width: 8
    /// Access: read-only
    using TXFIFO_CNT = BitField<16, 8>;
    constexpr uint32_t TXFIFO_CNT_Pos = 16;
    constexpr uint32_t TXFIFO_CNT_Msk = TXFIFO_CNT::mask;

    /// This register stores the value of transmitter's finite state machine. 0:TX_IDLE  1:TX_STRT  2:TX_DAT0  3:TX_DAT1  4:TX_DAT2   5:TX_DAT3 6:TX_DAT4  7:TX_DAT5  8:TX_DAT6 9:TX_DAT7  10:TX_PRTY   11:TX_STP1  12:TX_STP2  13:TX_DL0   14:TX_DL1
    /// Position: 24, Width: 4
    /// Access: read-only
    using ST_UTX_OUT = BitField<24, 4>;
    constexpr uint32_t ST_UTX_OUT_Pos = 24;
    constexpr uint32_t ST_UTX_OUT_Msk = ST_UTX_OUT::mask;

    /// The register represent the level value of the internal uart dsr signal.
    /// Position: 29, Width: 1
    /// Access: read-only
    using DTRN = BitField<29, 1>;
    constexpr uint32_t DTRN_Pos = 29;
    constexpr uint32_t DTRN_Msk = DTRN::mask;

    /// This register represent the level value of the internal uart cts signal.
    /// Position: 30, Width: 1
    /// Access: read-only
    using RTSN = BitField<30, 1>;
    constexpr uint32_t RTSN_Pos = 30;
    constexpr uint32_t RTSN_Msk = RTSN::mask;

    /// This register represent the  level value of the internal uart rxd signal.
    /// Position: 31, Width: 1
    /// Access: read-only
    using TXD = BitField<31, 1>;
    constexpr uint32_t TXD_Pos = 31;
    constexpr uint32_t TXD_Msk = TXD::mask;

}  // namespace status

/// CONF0 - CONF0
namespace conf0 {
    /// This register is used to configure the parity check mode.  0:even 1:odd
    /// Position: 0, Width: 1
    /// Access: read-write
    using PARITY = BitField<0, 1>;
    constexpr uint32_t PARITY_Pos = 0;
    constexpr uint32_t PARITY_Msk = PARITY::mask;

    /// Set this bit to enable uart parity check.
    /// Position: 1, Width: 1
    /// Access: read-write
    using PARITY_EN = BitField<1, 1>;
    constexpr uint32_t PARITY_EN_Pos = 1;
    constexpr uint32_t PARITY_EN_Msk = PARITY_EN::mask;

    /// This registe is used to set the length of data:  0:5bits 1:6bits 2:7bits 3:8bits
    /// Position: 2, Width: 2
    /// Access: read-write
    using BIT_NUM = BitField<2, 2>;
    constexpr uint32_t BIT_NUM_Pos = 2;
    constexpr uint32_t BIT_NUM_Msk = BIT_NUM::mask;

    /// This register is used to set the length of  stop bit. 1:1bit  2:1.5bits  3:2bits
    /// Position: 4, Width: 2
    /// Access: read-write
    using STOP_BIT_NUM = BitField<4, 2>;
    constexpr uint32_t STOP_BIT_NUM_Pos = 4;
    constexpr uint32_t STOP_BIT_NUM_Msk = STOP_BIT_NUM::mask;

    /// This register is used to configure the software rts signal which is used in software flow control.
    /// Position: 6, Width: 1
    /// Access: read-write
    using SW_RTS = BitField<6, 1>;
    constexpr uint32_t SW_RTS_Pos = 6;
    constexpr uint32_t SW_RTS_Msk = SW_RTS::mask;

    /// This register is used to configure the software dtr signal which is used in software flow control..
    /// Position: 7, Width: 1
    /// Access: read-write
    using SW_DTR = BitField<7, 1>;
    constexpr uint32_t SW_DTR_Pos = 7;
    constexpr uint32_t SW_DTR_Msk = SW_DTR::mask;

    /// Set this bit to enbale transmitter to  send 0 when the process of sending data is done.
    /// Position: 8, Width: 1
    /// Access: read-write
    using TXD_BRK = BitField<8, 1>;
    constexpr uint32_t TXD_BRK_Pos = 8;
    constexpr uint32_t TXD_BRK_Msk = TXD_BRK::mask;

    /// Set this bit to enable irda loopback mode.
    /// Position: 9, Width: 1
    /// Access: read-write
    using IRDA_DPLX = BitField<9, 1>;
    constexpr uint32_t IRDA_DPLX_Pos = 9;
    constexpr uint32_t IRDA_DPLX_Msk = IRDA_DPLX::mask;

    /// This is the start enable bit for irda transmitter.
    /// Position: 10, Width: 1
    /// Access: read-write
    using IRDA_TX_EN = BitField<10, 1>;
    constexpr uint32_t IRDA_TX_EN_Pos = 10;
    constexpr uint32_t IRDA_TX_EN_Msk = IRDA_TX_EN::mask;

    /// 1.the irda transmitter's 11th bit is the same to the 10th bit. 0.set irda transmitter's 11th bit to 0.
    /// Position: 11, Width: 1
    /// Access: read-write
    using IRDA_WCTL = BitField<11, 1>;
    constexpr uint32_t IRDA_WCTL_Pos = 11;
    constexpr uint32_t IRDA_WCTL_Msk = IRDA_WCTL::mask;

    /// Set this bit to inverse the level value of  irda transmitter's level.
    /// Position: 12, Width: 1
    /// Access: read-write
    using IRDA_TX_INV = BitField<12, 1>;
    constexpr uint32_t IRDA_TX_INV_Pos = 12;
    constexpr uint32_t IRDA_TX_INV_Msk = IRDA_TX_INV::mask;

    /// Set this bit to inverse the level value of irda receiver's level.
    /// Position: 13, Width: 1
    /// Access: read-write
    using IRDA_RX_INV = BitField<13, 1>;
    constexpr uint32_t IRDA_RX_INV_Pos = 13;
    constexpr uint32_t IRDA_RX_INV_Msk = IRDA_RX_INV::mask;

    /// Set this bit to enable uart loopback test mode.
    /// Position: 14, Width: 1
    /// Access: read-write
    using LOOPBACK = BitField<14, 1>;
    constexpr uint32_t LOOPBACK_Pos = 14;
    constexpr uint32_t LOOPBACK_Msk = LOOPBACK::mask;

    /// Set this bit to enable transmitter's flow control function.
    /// Position: 15, Width: 1
    /// Access: read-write
    using TX_FLOW_EN = BitField<15, 1>;
    constexpr uint32_t TX_FLOW_EN_Pos = 15;
    constexpr uint32_t TX_FLOW_EN_Msk = TX_FLOW_EN::mask;

    /// Set this bit to enable irda protocol.
    /// Position: 16, Width: 1
    /// Access: read-write
    using IRDA_EN = BitField<16, 1>;
    constexpr uint32_t IRDA_EN_Pos = 16;
    constexpr uint32_t IRDA_EN_Msk = IRDA_EN::mask;

    /// Set this bit to reset uart receiver's fifo.
    /// Position: 17, Width: 1
    /// Access: read-write
    using RXFIFO_RST = BitField<17, 1>;
    constexpr uint32_t RXFIFO_RST_Pos = 17;
    constexpr uint32_t RXFIFO_RST_Msk = RXFIFO_RST::mask;

    /// Set this bit to reset uart transmitter's fifo.
    /// Position: 18, Width: 1
    /// Access: read-write
    using TXFIFO_RST = BitField<18, 1>;
    constexpr uint32_t TXFIFO_RST_Pos = 18;
    constexpr uint32_t TXFIFO_RST_Msk = TXFIFO_RST::mask;

    /// Set this bit to inverse the level value of uart rxd signal.
    /// Position: 19, Width: 1
    /// Access: read-write
    using RXD_INV = BitField<19, 1>;
    constexpr uint32_t RXD_INV_Pos = 19;
    constexpr uint32_t RXD_INV_Msk = RXD_INV::mask;

    /// Set this bit to inverse the level value of uart cts signal.
    /// Position: 20, Width: 1
    /// Access: read-write
    using CTS_INV = BitField<20, 1>;
    constexpr uint32_t CTS_INV_Pos = 20;
    constexpr uint32_t CTS_INV_Msk = CTS_INV::mask;

    /// Set this bit to inverse the level value of uart dsr signal.
    /// Position: 21, Width: 1
    /// Access: read-write
    using DSR_INV = BitField<21, 1>;
    constexpr uint32_t DSR_INV_Pos = 21;
    constexpr uint32_t DSR_INV_Msk = DSR_INV::mask;

    /// Set this bit to inverse the level value of uart txd signal.
    /// Position: 22, Width: 1
    /// Access: read-write
    using TXD_INV = BitField<22, 1>;
    constexpr uint32_t TXD_INV_Pos = 22;
    constexpr uint32_t TXD_INV_Msk = TXD_INV::mask;

    /// Set this bit to inverse the level value of uart rts signal.
    /// Position: 23, Width: 1
    /// Access: read-write
    using RTS_INV = BitField<23, 1>;
    constexpr uint32_t RTS_INV_Pos = 23;
    constexpr uint32_t RTS_INV_Msk = RTS_INV::mask;

    /// Set this bit to inverse the level value of uart dtr signal.
    /// Position: 24, Width: 1
    /// Access: read-write
    using DTR_INV = BitField<24, 1>;
    constexpr uint32_t DTR_INV_Pos = 24;
    constexpr uint32_t DTR_INV_Msk = DTR_INV::mask;

    /// 1.force clock on for registers.support clock only when write registers
    /// Position: 25, Width: 1
    /// Access: read-write
    using CLK_EN = BitField<25, 1>;
    constexpr uint32_t CLK_EN_Pos = 25;
    constexpr uint32_t CLK_EN_Msk = CLK_EN::mask;

    /// 1.receiver stops storing data int fifo when data is wrong. 0.receiver stores the data even if the  received data is wrong.
    /// Position: 26, Width: 1
    /// Access: read-write
    using ERR_WR_MASK = BitField<26, 1>;
    constexpr uint32_t ERR_WR_MASK_Pos = 26;
    constexpr uint32_t ERR_WR_MASK_Msk = ERR_WR_MASK::mask;

    /// This register is used to select the clock.1.apb clock 0:ref_tick
    /// Position: 27, Width: 1
    /// Access: read-write
    using TICK_REF_ALWAYS_ON = BitField<27, 1>;
    constexpr uint32_t TICK_REF_ALWAYS_ON_Pos = 27;
    constexpr uint32_t TICK_REF_ALWAYS_ON_Msk = TICK_REF_ALWAYS_ON::mask;

}  // namespace conf0

/// CONF1 - CONF1
namespace conf1 {
    /// When receiver receives more data than its threshold value.receiver will produce rxfifo_full_int_raw interrupt.the threshold value is (rx_flow_thrhd_h3 rxfifo_full_thrhd).
    /// Position: 0, Width: 7
    /// Access: read-write
    using RXFIFO_FULL_THRHD = BitField<0, 7>;
    constexpr uint32_t RXFIFO_FULL_THRHD_Pos = 0;
    constexpr uint32_t RXFIFO_FULL_THRHD_Msk = RXFIFO_FULL_THRHD::mask;

    /// when the data amount in transmitter fifo is less than its threshold value. it will produce txfifo_empty_int_raw interrupt. the threshold value is (tx_mem_empty_thrhd txfifo_empty_thrhd)
    /// Position: 8, Width: 7
    /// Access: read-write
    using TXFIFO_EMPTY_THRHD = BitField<8, 7>;
    constexpr uint32_t TXFIFO_EMPTY_THRHD_Pos = 8;
    constexpr uint32_t TXFIFO_EMPTY_THRHD_Msk = TXFIFO_EMPTY_THRHD::mask;

    /// when receiver receives more data than its threshold value. receiver produce signal to tell the transmitter stop transferring data. the threshold value is (rx_flow_thrhd_h3 rx_flow_thrhd).
    /// Position: 16, Width: 7
    /// Access: read-write
    using RX_FLOW_THRHD = BitField<16, 7>;
    constexpr uint32_t RX_FLOW_THRHD_Pos = 16;
    constexpr uint32_t RX_FLOW_THRHD_Msk = RX_FLOW_THRHD::mask;

    /// This is the flow enable bit for uart receiver. 1:choose software flow control with configuring sw_rts signal
    /// Position: 23, Width: 1
    /// Access: read-write
    using RX_FLOW_EN = BitField<23, 1>;
    constexpr uint32_t RX_FLOW_EN_Pos = 23;
    constexpr uint32_t RX_FLOW_EN_Msk = RX_FLOW_EN::mask;

    /// This register is used to configure the timeout value for uart receiver receiving a byte.
    /// Position: 24, Width: 7
    /// Access: read-write
    using RX_TOUT_THRHD = BitField<24, 7>;
    constexpr uint32_t RX_TOUT_THRHD_Pos = 24;
    constexpr uint32_t RX_TOUT_THRHD_Msk = RX_TOUT_THRHD::mask;

    /// This is the enble bit for uart receiver's timeout function.
    /// Position: 31, Width: 1
    /// Access: read-write
    using RX_TOUT_EN = BitField<31, 1>;
    constexpr uint32_t RX_TOUT_EN_Pos = 31;
    constexpr uint32_t RX_TOUT_EN_Msk = RX_TOUT_EN::mask;

}  // namespace conf1

/// LOWPULSE - LOWPULSE
namespace lowpulse {
    /// This register stores the value of the minimum duration time for the low level pulse. it is used in baudrate-detect process.
    /// Position: 0, Width: 20
    /// Access: read-only
    using MIN_CNT = BitField<0, 20>;
    constexpr uint32_t MIN_CNT_Pos = 0;
    constexpr uint32_t MIN_CNT_Msk = MIN_CNT::mask;

}  // namespace lowpulse

/// HIGHPULSE - HIGHPULSE
namespace highpulse {
    /// This register stores  the value of the maxinum duration time for the high level pulse. it is used in baudrate-detect process.
    /// Position: 0, Width: 20
    /// Access: read-only
    using MIN_CNT = BitField<0, 20>;
    constexpr uint32_t MIN_CNT_Pos = 0;
    constexpr uint32_t MIN_CNT_Msk = MIN_CNT::mask;

}  // namespace highpulse

/// RXD_CNT - RXD_CNT
namespace rxd_cnt {
    /// This register stores the count of rxd edge change. it is used in baudrate-detect process.
    /// Position: 0, Width: 10
    /// Access: read-only
    using RXD_EDGE_CNT = BitField<0, 10>;
    constexpr uint32_t RXD_EDGE_CNT_Pos = 0;
    constexpr uint32_t RXD_EDGE_CNT_Msk = RXD_EDGE_CNT::mask;

}  // namespace rxd_cnt

/// FLOW_CONF - FLOW_CONF
namespace flow_conf {
    /// Set this bit to enable software  flow control. it is used with register sw_xon or sw_xoff .
    /// Position: 0, Width: 1
    /// Access: read-write
    using SW_FLOW_CON_EN = BitField<0, 1>;
    constexpr uint32_t SW_FLOW_CON_EN_Pos = 0;
    constexpr uint32_t SW_FLOW_CON_EN_Msk = SW_FLOW_CON_EN::mask;

    /// Set this bit to remove flow control char from the received data.
    /// Position: 1, Width: 1
    /// Access: read-write
    using XONOFF_DEL = BitField<1, 1>;
    constexpr uint32_t XONOFF_DEL_Pos = 1;
    constexpr uint32_t XONOFF_DEL_Msk = XONOFF_DEL::mask;

    /// Set this bit to clear ctsn to stop the  transmitter from sending data.
    /// Position: 2, Width: 1
    /// Access: read-write
    using FORCE_XON = BitField<2, 1>;
    constexpr uint32_t FORCE_XON_Pos = 2;
    constexpr uint32_t FORCE_XON_Msk = FORCE_XON::mask;

    /// Set this bit to set ctsn to enable the transmitter to go on sending data.
    /// Position: 3, Width: 1
    /// Access: read-write
    using FORCE_XOFF = BitField<3, 1>;
    constexpr uint32_t FORCE_XOFF_Pos = 3;
    constexpr uint32_t FORCE_XOFF_Msk = FORCE_XOFF::mask;

    /// Set this bit to send xon char. it is cleared by hardware automatically.
    /// Position: 4, Width: 1
    /// Access: read-write
    using SEND_XON = BitField<4, 1>;
    constexpr uint32_t SEND_XON_Pos = 4;
    constexpr uint32_t SEND_XON_Msk = SEND_XON::mask;

    /// Set this bit to send xoff char. it is cleared by hardware automatically.
    /// Position: 5, Width: 1
    /// Access: read-write
    using SEND_XOFF = BitField<5, 1>;
    constexpr uint32_t SEND_XOFF_Pos = 5;
    constexpr uint32_t SEND_XOFF_Msk = SEND_XOFF::mask;

}  // namespace flow_conf

/// SLEEP_CONF - SLEEP_CONF
namespace sleep_conf {
    /// When the input rxd edge changes more than this register value. the uart is active from light sleeping mode.
    /// Position: 0, Width: 10
    /// Access: read-write
    using ACTIVE_THRESHOLD = BitField<0, 10>;
    constexpr uint32_t ACTIVE_THRESHOLD_Pos = 0;
    constexpr uint32_t ACTIVE_THRESHOLD_Msk = ACTIVE_THRESHOLD::mask;

}  // namespace sleep_conf

/// SWFC_CONF - SWFC_CONF
namespace swfc_conf {
    /// when the data amount in receiver's fifo is more than this register value. it will send a xoff char with uart_sw_flow_con_en set to 1.
    /// Position: 0, Width: 8
    /// Access: read-write
    using XON_THRESHOLD = BitField<0, 8>;
    constexpr uint32_t XON_THRESHOLD_Pos = 0;
    constexpr uint32_t XON_THRESHOLD_Msk = XON_THRESHOLD::mask;

    /// When the data amount in receiver's fifo is less than this register value. it will send a xon char with uart_sw_flow_con_en set to 1.
    /// Position: 8, Width: 8
    /// Access: read-write
    using XOFF_THRESHOLD = BitField<8, 8>;
    constexpr uint32_t XOFF_THRESHOLD_Pos = 8;
    constexpr uint32_t XOFF_THRESHOLD_Msk = XOFF_THRESHOLD::mask;

    /// This register stores the xon flow control char.
    /// Position: 16, Width: 8
    /// Access: read-write
    using XON_CHAR = BitField<16, 8>;
    constexpr uint32_t XON_CHAR_Pos = 16;
    constexpr uint32_t XON_CHAR_Msk = XON_CHAR::mask;

    /// This register stores the xoff flow control char.
    /// Position: 24, Width: 8
    /// Access: read-write
    using XOFF_CHAR = BitField<24, 8>;
    constexpr uint32_t XOFF_CHAR_Pos = 24;
    constexpr uint32_t XOFF_CHAR_Msk = XOFF_CHAR::mask;

}  // namespace swfc_conf

/// IDLE_CONF - IDLE_CONF
namespace idle_conf {
    /// when receiver takes more time than this register value to receive a byte data. it will produce frame end signal for uhci to stop receiving data.
    /// Position: 0, Width: 10
    /// Access: read-write
    using RX_IDLE_THRHD = BitField<0, 10>;
    constexpr uint32_t RX_IDLE_THRHD_Pos = 0;
    constexpr uint32_t RX_IDLE_THRHD_Msk = RX_IDLE_THRHD::mask;

    /// This register is used to configure the duration time between transfers.
    /// Position: 10, Width: 10
    /// Access: read-write
    using TX_IDLE_NUM = BitField<10, 10>;
    constexpr uint32_t TX_IDLE_NUM_Pos = 10;
    constexpr uint32_t TX_IDLE_NUM_Msk = TX_IDLE_NUM::mask;

    /// This register is used to configure the num of 0 send after the process of sending data is done. it is active when txd_brk is set to 1.
    /// Position: 20, Width: 8
    /// Access: read-write
    using TX_BRK_NUM = BitField<20, 8>;
    constexpr uint32_t TX_BRK_NUM_Pos = 20;
    constexpr uint32_t TX_BRK_NUM_Msk = TX_BRK_NUM::mask;

}  // namespace idle_conf

/// RS485_CONF - RS485_CONF
namespace rs485_conf {
    /// Set this bit to choose rs485 mode.
    /// Position: 0, Width: 1
    /// Access: read-write
    using RS485_EN = BitField<0, 1>;
    constexpr uint32_t RS485_EN_Pos = 0;
    constexpr uint32_t RS485_EN_Msk = RS485_EN::mask;

    /// Set this bit to delay the stop bit by 1 bit.
    /// Position: 1, Width: 1
    /// Access: read-write
    using DL0_EN = BitField<1, 1>;
    constexpr uint32_t DL0_EN_Pos = 1;
    constexpr uint32_t DL0_EN_Msk = DL0_EN::mask;

    /// Set this bit to delay the stop bit by 1 bit.
    /// Position: 2, Width: 1
    /// Access: read-write
    using DL1_EN = BitField<2, 1>;
    constexpr uint32_t DL1_EN_Pos = 2;
    constexpr uint32_t DL1_EN_Msk = DL1_EN::mask;

    /// Set this bit to enable loopback transmitter's output data signal to receiver's input data signal.
    /// Position: 3, Width: 1
    /// Access: read-write
    using RS485TX_RX_EN = BitField<3, 1>;
    constexpr uint32_t RS485TX_RX_EN_Pos = 3;
    constexpr uint32_t RS485TX_RX_EN_Msk = RS485TX_RX_EN::mask;

    /// 1: enable rs485's transmitter to send data when rs485's receiver is busy. 0:rs485's transmitter should not send data when its receiver is busy.
    /// Position: 4, Width: 1
    /// Access: read-write
    using RS485RXBY_TX_EN = BitField<4, 1>;
    constexpr uint32_t RS485RXBY_TX_EN_Pos = 4;
    constexpr uint32_t RS485RXBY_TX_EN_Msk = RS485RXBY_TX_EN::mask;

    /// This register is used to delay the receiver's internal data signal.
    /// Position: 5, Width: 1
    /// Access: read-write
    using RS485_RX_DLY_NUM = BitField<5, 1>;
    constexpr uint32_t RS485_RX_DLY_NUM_Pos = 5;
    constexpr uint32_t RS485_RX_DLY_NUM_Msk = RS485_RX_DLY_NUM::mask;

    /// This register is used to delay the transmitter's internal data signal.
    /// Position: 6, Width: 4
    /// Access: read-write
    using RS485_TX_DLY_NUM = BitField<6, 4>;
    constexpr uint32_t RS485_TX_DLY_NUM_Pos = 6;
    constexpr uint32_t RS485_TX_DLY_NUM_Msk = RS485_TX_DLY_NUM::mask;

}  // namespace rs485_conf

/// AT_CMD_PRECNT - AT_CMD_PRECNT
namespace at_cmd_precnt {
    /// This register is used to configure the idle duration time before the first at_cmd is received by receiver. when the the duration is less than this register value it will not take the next data received as at_cmd char.
    /// Position: 0, Width: 24
    /// Access: read-write
    using PRE_IDLE_NUM = BitField<0, 24>;
    constexpr uint32_t PRE_IDLE_NUM_Pos = 0;
    constexpr uint32_t PRE_IDLE_NUM_Msk = PRE_IDLE_NUM::mask;

}  // namespace at_cmd_precnt

/// AT_CMD_POSTCNT - AT_CMD_POSTCNT
namespace at_cmd_postcnt {
    /// This register is used to configure the duration time between the last at_cmd and the next data. when the duration is less than this register value  it will not take the previous data as at_cmd char.
    /// Position: 0, Width: 24
    /// Access: read-write
    using POST_IDLE_NUM = BitField<0, 24>;
    constexpr uint32_t POST_IDLE_NUM_Pos = 0;
    constexpr uint32_t POST_IDLE_NUM_Msk = POST_IDLE_NUM::mask;

}  // namespace at_cmd_postcnt

/// AT_CMD_GAPTOUT - AT_CMD_GAPTOUT
namespace at_cmd_gaptout {
    /// This register is used to configure the duration time between the at_cmd chars. when the duration time is less than this register value it will not take the datas as continous at_cmd chars.
    /// Position: 0, Width: 24
    /// Access: read-write
    using RX_GAP_TOUT = BitField<0, 24>;
    constexpr uint32_t RX_GAP_TOUT_Pos = 0;
    constexpr uint32_t RX_GAP_TOUT_Msk = RX_GAP_TOUT::mask;

}  // namespace at_cmd_gaptout

/// AT_CMD_CHAR - AT_CMD_CHAR
namespace at_cmd_char {
    /// This register is used to configure the content of at_cmd char.
    /// Position: 0, Width: 8
    /// Access: read-write
    using AT_CMD_CHAR = BitField<0, 8>;
    constexpr uint32_t AT_CMD_CHAR_Pos = 0;
    constexpr uint32_t AT_CMD_CHAR_Msk = AT_CMD_CHAR::mask;

    /// This register is used to configure the num of continous at_cmd chars received by receiver.
    /// Position: 8, Width: 8
    /// Access: read-write
    using CHAR_NUM = BitField<8, 8>;
    constexpr uint32_t CHAR_NUM_Pos = 8;
    constexpr uint32_t CHAR_NUM_Msk = CHAR_NUM::mask;

}  // namespace at_cmd_char

/// MEM_CONF - MEM_CONF
namespace mem_conf {
    /// Set this bit to power down mem.when reg_mem_pd registers in the 3 uarts are all set to 1  mem will enter low power mode.
    /// Position: 0, Width: 1
    /// Access: read-write
    using MEM_PD = BitField<0, 1>;
    constexpr uint32_t MEM_PD_Pos = 0;
    constexpr uint32_t MEM_PD_Msk = MEM_PD::mask;

    /// This register is used to configure the amount of mem allocated to receiver's fifo. the default byte num is 128.
    /// Position: 3, Width: 4
    /// Access: read-write
    using RX_SIZE = BitField<3, 4>;
    constexpr uint32_t RX_SIZE_Pos = 3;
    constexpr uint32_t RX_SIZE_Msk = RX_SIZE::mask;

    /// This register is used to configure the amount of mem allocated to transmitter's fifo.the default byte num is 128.
    /// Position: 7, Width: 4
    /// Access: read-write
    using TX_SIZE = BitField<7, 4>;
    constexpr uint32_t TX_SIZE_Pos = 7;
    constexpr uint32_t TX_SIZE_Msk = TX_SIZE::mask;

    /// refer to the rx_flow_thrhd's describtion.
    /// Position: 15, Width: 3
    /// Access: read-write
    using RX_FLOW_THRHD_H3 = BitField<15, 3>;
    constexpr uint32_t RX_FLOW_THRHD_H3_Pos = 15;
    constexpr uint32_t RX_FLOW_THRHD_H3_Msk = RX_FLOW_THRHD_H3::mask;

    /// refer to the rx_tout_thrhd's describtion.
    /// Position: 18, Width: 3
    /// Access: read-write
    using RX_TOUT_THRHD_H3 = BitField<18, 3>;
    constexpr uint32_t RX_TOUT_THRHD_H3_Pos = 18;
    constexpr uint32_t RX_TOUT_THRHD_H3_Msk = RX_TOUT_THRHD_H3::mask;

    /// refer to the uart_xon_threshold's describtion.
    /// Position: 21, Width: 2
    /// Access: read-write
    using XON_THRESHOLD_H2 = BitField<21, 2>;
    constexpr uint32_t XON_THRESHOLD_H2_Pos = 21;
    constexpr uint32_t XON_THRESHOLD_H2_Msk = XON_THRESHOLD_H2::mask;

    /// refer to the uart_xoff_threshold's describtion.
    /// Position: 23, Width: 2
    /// Access: read-write
    using XOFF_THRESHOLD_H2 = BitField<23, 2>;
    constexpr uint32_t XOFF_THRESHOLD_H2_Pos = 23;
    constexpr uint32_t XOFF_THRESHOLD_H2_Msk = XOFF_THRESHOLD_H2::mask;

    /// refer to the rxfifo_full_thrhd's describtion.
    /// Position: 25, Width: 3
    /// Access: read-write
    using RX_MEM_FULL_THRHD = BitField<25, 3>;
    constexpr uint32_t RX_MEM_FULL_THRHD_Pos = 25;
    constexpr uint32_t RX_MEM_FULL_THRHD_Msk = RX_MEM_FULL_THRHD::mask;

    /// refer to txfifo_empty_thrhd 's describtion.
    /// Position: 28, Width: 3
    /// Access: read-write
    using TX_MEM_EMPTY_THRHD = BitField<28, 3>;
    constexpr uint32_t TX_MEM_EMPTY_THRHD_Pos = 28;
    constexpr uint32_t TX_MEM_EMPTY_THRHD_Msk = TX_MEM_EMPTY_THRHD::mask;

}  // namespace mem_conf

/// MEM_TX_STATUS - MEM_TX_STATUS
namespace mem_tx_status {
    /// Position: 0, Width: 24
    /// Access: read-only
    using MEM_TX_STATUS = BitField<0, 24>;
    constexpr uint32_t MEM_TX_STATUS_Pos = 0;
    constexpr uint32_t MEM_TX_STATUS_Msk = MEM_TX_STATUS::mask;

}  // namespace mem_tx_status

/// MEM_RX_STATUS - MEM_RX_STATUS
namespace mem_rx_status {
    /// This register stores the current uart rx mem read address  and rx mem write address
    /// Position: 0, Width: 24
    /// Access: read-only
    using MEM_RX_STATUS = BitField<0, 24>;
    constexpr uint32_t MEM_RX_STATUS_Pos = 0;
    constexpr uint32_t MEM_RX_STATUS_Msk = MEM_RX_STATUS::mask;

    /// This register stores the rx mem read address
    /// Position: 2, Width: 11
    /// Access: read-only
    using MEM_RX_RD_ADDR = BitField<2, 11>;
    constexpr uint32_t MEM_RX_RD_ADDR_Pos = 2;
    constexpr uint32_t MEM_RX_RD_ADDR_Msk = MEM_RX_RD_ADDR::mask;

    /// This register stores the rx mem write address
    /// Position: 13, Width: 11
    /// Access: read-only
    using MEM_RX_WR_ADDR = BitField<13, 11>;
    constexpr uint32_t MEM_RX_WR_ADDR_Pos = 13;
    constexpr uint32_t MEM_RX_WR_ADDR_Msk = MEM_RX_WR_ADDR::mask;

}  // namespace mem_rx_status

/// MEM_CNT_STATUS - MEM_CNT_STATUS
namespace mem_cnt_status {
    /// refer to the rxfifo_cnt's describtion.
    /// Position: 0, Width: 3
    /// Access: read-only
    using RX_MEM_CNT = BitField<0, 3>;
    constexpr uint32_t RX_MEM_CNT_Pos = 0;
    constexpr uint32_t RX_MEM_CNT_Msk = RX_MEM_CNT::mask;

    /// refer to the txfifo_cnt's describtion.
    /// Position: 3, Width: 3
    /// Access: read-only
    using TX_MEM_CNT = BitField<3, 3>;
    constexpr uint32_t TX_MEM_CNT_Pos = 3;
    constexpr uint32_t TX_MEM_CNT_Msk = TX_MEM_CNT::mask;

}  // namespace mem_cnt_status

/// POSPULSE - POSPULSE
namespace pospulse {
    /// This register stores the count of rxd posedge edge. it is used in boudrate-detect process.
    /// Position: 0, Width: 20
    /// Access: read-only
    using POSEDGE_MIN_CNT = BitField<0, 20>;
    constexpr uint32_t POSEDGE_MIN_CNT_Pos = 0;
    constexpr uint32_t POSEDGE_MIN_CNT_Msk = POSEDGE_MIN_CNT::mask;

}  // namespace pospulse

/// NEGPULSE - NEGPULSE
namespace negpulse {
    /// This register stores the count of rxd negedge edge. it is used in boudrate-detect process.
    /// Position: 0, Width: 20
    /// Access: read-only
    using NEGEDGE_MIN_CNT = BitField<0, 20>;
    constexpr uint32_t NEGEDGE_MIN_CNT_Pos = 0;
    constexpr uint32_t NEGEDGE_MIN_CNT_Msk = NEGEDGE_MIN_CNT::mask;

}  // namespace negpulse

/// DATE - DATE
namespace date {
    /// Position: 0, Width: 32
    /// Access: read-write
    using DATE = BitField<0, 32>;
    constexpr uint32_t DATE_Pos = 0;
    constexpr uint32_t DATE_Msk = DATE::mask;

}  // namespace date

/// ID - ID
namespace id {
    /// Position: 0, Width: 32
    /// Access: read-write
    using ID = BitField<0, 32>;
    constexpr uint32_t ID_Pos = 0;
    constexpr uint32_t ID_Msk = ID::mask;

}  // namespace id

}  // namespace alloy::hal::espressif::esp32::esp32::uart0
