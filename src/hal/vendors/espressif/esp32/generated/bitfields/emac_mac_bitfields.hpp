/// Auto-generated bit field definitions for EMAC_MAC
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::espressif::esp32::emac_mac {

using namespace alloy::hal::bitfields;

// ============================================================================
// EMAC_MAC Bit Field Definitions
// ============================================================================

/// EMACCONFIG - MAC configuration
namespace emacconfig {
    /// These bits control the number of preamble bytes that are added to the beginning of every Transmit frame. The preamble reduction occurs only when the MAC is operating in the full-duplex mode.2'b00: 7 bytes of preamble. 2'b01: 5 bytes of preamble. 2'b10: 3 bytes of preamble.
    /// Position: 0, Width: 2
    /// Access: read-write
    using PLTF = BitField<0, 2>;
    constexpr uint32_t PLTF_Pos = 0;
    constexpr uint32_t PLTF_Msk = PLTF::mask;

    /// When this bit is set the receiver state machine of the MAC is enabled for receiving frames from the MII. When this bit is reset the MAC receive state machine is disabled after the completion of the reception of the current frame and does not receive any further frames from the MII.
    /// Position: 2, Width: 1
    /// Access: read-write
    using RX = BitField<2, 1>;
    constexpr uint32_t RX_Pos = 2;
    constexpr uint32_t RX_Msk = RX::mask;

    /// When this bit is set the transmit state machine of the MAC is enabled for transmission on the MII. When this bit is reset the MAC transmit state machine is disabled after the completion of the transmission of the current frame and does not transmit any further frames.
    /// Position: 3, Width: 1
    /// Access: read-write
    using TX = BitField<3, 1>;
    constexpr uint32_t TX_Pos = 3;
    constexpr uint32_t TX_Msk = TX::mask;

    /// Deferral Check.
    /// Position: 4, Width: 1
    /// Access: read-write
    using DEFERRALCHECK = BitField<4, 1>;
    constexpr uint32_t DEFERRALCHECK_Pos = 4;
    constexpr uint32_t DEFERRALCHECK_Msk = DEFERRALCHECK::mask;

    /// The Back-Off limit determines the random integer number (r) of slot time delays (512 bit times for 10/100 Mbps) for which the MAC waits before rescheduling a transmission attempt during retries after a collision. This bit is applicable only in the half-duplex mode. 00: k= min (n 10). 01: k = min (n 8). 10: k = min (n 4). 11: k = min (n 1) n = retransmission attempt. The random integer r takes the value in the Range 0 ~ 2000.
    /// Position: 5, Width: 2
    /// Access: read-write
    using BACKOFFLIMIT = BitField<5, 2>;
    constexpr uint32_t BACKOFFLIMIT_Pos = 5;
    constexpr uint32_t BACKOFFLIMIT_Msk = BACKOFFLIMIT::mask;

    /// When this bit is set the MAC strips the Pad or FCS field on the incoming frames only if the value of the length field is less than 1 536 bytes. All received frames with length field greater than or equal to 1 536 bytes are passed to the application without stripping the Pad or FCS field. When this bit is reset the MAC passes all incoming frames without modifying them to the Host.
    /// Position: 7, Width: 1
    /// Access: read-write
    using PADCRCSTRIP = BitField<7, 1>;
    constexpr uint32_t PADCRCSTRIP_Pos = 7;
    constexpr uint32_t PADCRCSTRIP_Msk = PADCRCSTRIP::mask;

    /// When this bit is set the MAC attempts only one transmission. When a collision occurs on the MII interface the MAC ignores the current frame transmission and reports a Frame Abort with excessive collision error in the transmit frame status. When this bit is reset the MAC attempts retries based on the settings of the BL field (Bits [6:5]). This bit is applicable only in the half-duplex Mode.
    /// Position: 9, Width: 1
    /// Access: read-write
    using RETRY = BitField<9, 1>;
    constexpr uint32_t RETRY_Pos = 9;
    constexpr uint32_t RETRY_Msk = RETRY::mask;

    /// When this bit is set the MAC calculates the 16-bit one's complement of the one's complement sum of all received Ethernet frame payloads. It also checks whether the IPv4 Header checksum (assumed to be bytes 25/26 or 29/30 (VLAN-tagged) of the received Ethernet frame) is correct for the received frame and gives the status in the receive status word. The MAC also appends the 16-bit checksum calculated for the IP header datagram payload (bytes after the IPv4 header) and appends it to the Ethernet frame transferred to the application (when Type 2 COE is deselected). When this bit is reset this function is disabled.
    /// Position: 10, Width: 1
    /// Access: read-write
    using RXIPCOFFLOAD = BitField<10, 1>;
    constexpr uint32_t RXIPCOFFLOAD_Pos = 10;
    constexpr uint32_t RXIPCOFFLOAD_Msk = RXIPCOFFLOAD::mask;

    /// When this bit is set the MAC operates in the full-duplex mode where it can transmit and receive simultaneously. This bit is read only with default value of 1'b1 in the full-duplex-mode.
    /// Position: 11, Width: 1
    /// Access: read-write
    using DUPLEX = BitField<11, 1>;
    constexpr uint32_t DUPLEX_Pos = 11;
    constexpr uint32_t DUPLEX_Msk = DUPLEX::mask;

    /// When this bit is set the MAC operates in the loopback mode MII. The MII Receive clock input (CLK_RX) is required for the loopback to work properly because the transmit clock is not looped-back internally.
    /// Position: 12, Width: 1
    /// Access: read-write
    using LOOPBACK = BitField<12, 1>;
    constexpr uint32_t LOOPBACK_Pos = 12;
    constexpr uint32_t LOOPBACK_Msk = LOOPBACK::mask;

    /// When this bit is set the MAC disables the reception of frames when the TX_EN is asserted in the half-duplex mode. When this bit is reset the MAC receives all packets that are given by the PHY while transmitting. This bit is not applicable if the MAC is operating in the full duplex mode.
    /// Position: 13, Width: 1
    /// Access: read-write
    using RXOWN = BitField<13, 1>;
    constexpr uint32_t RXOWN_Pos = 13;
    constexpr uint32_t RXOWN_Msk = RXOWN::mask;

    /// This bit selects the speed in the MII RMII interface. 0: 10 Mbps. 1: 100 Mbps.
    /// Position: 14, Width: 1
    /// Access: read-write
    using FESPEED = BitField<14, 1>;
    constexpr uint32_t FESPEED_Pos = 14;
    constexpr uint32_t FESPEED_Msk = FESPEED::mask;

    /// This bit selects the Ethernet line speed. It should be set to 1 for 10 or 100 Mbps operations.In 10 or 100 Mbps operations this bit along with FES(EMACFESPEED) bit it selects the exact linespeed. In the 10/100 Mbps-only operations the bit is always 1.
    /// Position: 15, Width: 1
    /// Access: read-write
    using MII = BitField<15, 1>;
    constexpr uint32_t MII_Pos = 15;
    constexpr uint32_t MII_Msk = MII::mask;

    /// When set high this bit makes the MAC transmitter ignore the MII CRS signal during frame transmission in the half-duplex mode. This request results in no errors generated because of Loss of Carrier or No Carrier during such transmission. When this bit is low the MAC transmitter generates such errors because of Carrier Sense and can even abort the transmissions.
    /// Position: 16, Width: 1
    /// Access: read-write
    using DISABLECRS = BitField<16, 1>;
    constexpr uint32_t DISABLECRS_Pos = 16;
    constexpr uint32_t DISABLECRS_Msk = DISABLECRS::mask;

    /// These bits control the minimum IFG between frames during transmission. 3'b000: 96 bit times. 3'b001: 88 bit times. 3'b010: 80 bit times. 3'b111: 40 bit times. In the half-duplex mode the minimum IFG can be configured only for 64 bit times (IFG = 100). Lower values are not considered.
    /// Position: 17, Width: 3
    /// Access: read-write
    using INTERFRAMEGAP = BitField<17, 3>;
    constexpr uint32_t INTERFRAMEGAP_Pos = 17;
    constexpr uint32_t INTERFRAMEGAP_Msk = INTERFRAMEGAP::mask;

    /// When this bit is set the MAC allows Jumbo frames of 9 018 bytes (9 022 bytes for VLAN tagged frames) without reporting a giant frame error in the receive frame status.
    /// Position: 20, Width: 1
    /// Access: read-write
    using JUMBOFRAME = BitField<20, 1>;
    constexpr uint32_t JUMBOFRAME_Pos = 20;
    constexpr uint32_t JUMBOFRAME_Msk = JUMBOFRAME::mask;

    /// When this bit is set the MAC disables the jabber timer on the transmitter. The MAC can transfer frames of up to 16 383 bytes. When this bit is reset the MAC cuts off the transmitter if the application sends out more than 2 048 bytes of data (10 240 if JE is set high) during Transmission.
    /// Position: 22, Width: 1
    /// Access: read-write
    using JABBER = BitField<22, 1>;
    constexpr uint32_t JABBER_Pos = 22;
    constexpr uint32_t JABBER_Msk = JABBER::mask;

    /// When this bit is set the MAC disables the watchdog timer on the receiver. The MAC can receive frames of up to 16 383 bytes. When this bit is reset the MAC does not allow a receive frame which more than 2 048 bytes (10 240 if JE is set high) or the value programmed in Register (Watchdog Timeout Register). The MAC cuts off any bytes received after the watchdog limit number of bytes.
    /// Position: 23, Width: 1
    /// Access: read-write
    using WATCHDOG = BitField<23, 1>;
    constexpr uint32_t WATCHDOG_Pos = 23;
    constexpr uint32_t WATCHDOG_Msk = WATCHDOG::mask;

    /// When set the MAC considers all frames with up to 2 000 bytes length as normal packets.When Bit[20] (JE) is not set the MAC considers all received frames of size more than 2K bytes as Giant frames. When this bit is reset and Bit[20] (JE) is not set the MAC considers all received frames of size more than 1 518 bytes (1 522 bytes for tagged) as Giant frames. When Bit[20] is set setting this bit has no effect on Giant Frame status.
    /// Position: 27, Width: 1
    /// Access: read-write
    using ASS2KP = BitField<27, 1>;
    constexpr uint32_t ASS2KP_Pos = 27;
    constexpr uint32_t ASS2KP_Msk = ASS2KP::mask;

    /// This field controls the source address insertion or replacement for all transmitted frames.Bit[30] specifies which MAC Address register (0 or 1) is used for source address insertion or replacement based on the values of Bits [29:28]: 2'b0x: The input signals mti_sa_ctrl_i and ati_sa_ctrl_i control the SA field generation. 2'b10: If Bit[30] is set to 0 the MAC inserts the content of the MAC Address 0 registers in the SA field of all transmitted frames. If Bit[30] is set to 1 the MAC inserts the content of the MAC Address 1 registers in the SA field of all transmitted frames. 2'b11: If Bit[30] is set to 0 the MAC replaces the content of the MAC Address 0 registers in the SA field of all transmitted frames. If Bit[30] is set to 1 the MAC replaces the content of the MAC Address 1 registers in the SA field of all transmitted frames.
    /// Position: 28, Width: 3
    /// Access: read-write
    using SAIRC = BitField<28, 3>;
    constexpr uint32_t SAIRC_Pos = 28;
    constexpr uint32_t SAIRC_Msk = SAIRC::mask;

}  // namespace emacconfig

/// EMACFF - Frame filter settings
namespace emacff {
    /// When this bit is set the Address Filter module passes all incoming frames irrespective of the destination or source address. The SA or DA Filter Fails status bits of the Receive Status Word are always cleared when PR(PRI_RATIO) is set.
    /// Position: 0, Width: 1
    /// Access: read-write
    using PMODE = BitField<0, 1>;
    constexpr uint32_t PMODE_Pos = 0;
    constexpr uint32_t PMODE_Msk = PMODE::mask;

    /// When this bit is set the Address Check block operates in inverse filtering mode for the DA address comparison for both unicast and multicast frames. When reset normal filtering of frames is performed.
    /// Position: 3, Width: 1
    /// Access: read-write
    using DAIF = BitField<3, 1>;
    constexpr uint32_t DAIF_Pos = 3;
    constexpr uint32_t DAIF_Msk = DAIF::mask;

    /// When set this bit indicates that all received frames with a multicast destination address (first bit in the destination address field is '1') are passed.
    /// Position: 4, Width: 1
    /// Access: read-write
    using PAM = BitField<4, 1>;
    constexpr uint32_t PAM_Pos = 4;
    constexpr uint32_t PAM_Msk = PAM::mask;

    /// When this bit is set the AFM(Address Filtering Module) module blocks all incoming broadcast frames. In addition it overrides all other filter settings. When this bit is reset the AFM module passes all received broadcast Frames.
    /// Position: 5, Width: 1
    /// Access: read-write
    using DBF = BitField<5, 1>;
    constexpr uint32_t DBF_Pos = 5;
    constexpr uint32_t DBF_Msk = DBF::mask;

    /// These bits control the forwarding of all control frames (including unicast and multicast Pause frames). 2'b00: MAC filters all control frames from reaching the application. 2'b01: MAC forwards all control frames except Pause frames to application even if they fail the Address filter. 2'b10: MAC forwards all control frames to application even if they fail the Address Filter. 2'b11: MAC forwards control frames that pass the Address Filter.The following conditions should be true for the Pause frames processing: Condition 1: The MAC is in the full-duplex mode and flow control is enabled by setting Bit 2 (RFE) of Register (Flow Control Register) to 1. Condition 2: The destination address (DA) of the received frame matches the special multicast address or the MAC Address 0 when Bit 3 (UP) of the Register(Flow Control Register) is set. Condition 3: The Type field of the received frame is 0x8808 and the OPCODE field is 0x0001.
    /// Position: 6, Width: 2
    /// Access: read-write
    using PCF = BitField<6, 2>;
    constexpr uint32_t PCF_Pos = 6;
    constexpr uint32_t PCF_Msk = PCF::mask;

    /// When this bit is set the Address Check block operates in inverse filtering mode for the SA address comparison. The frames whose SA matches the SA registers are marked as failing the SA Address filter. When this bit is reset frames whose SA does not match the SA registers are marked as failing the SA Address filter.
    /// Position: 8, Width: 1
    /// Access: read-write
    using SAIF = BitField<8, 1>;
    constexpr uint32_t SAIF_Pos = 8;
    constexpr uint32_t SAIF_Msk = SAIF::mask;

    /// When this bit is set the MAC compares the SA field of the received frames with the values programmed in the enabled SA registers. If the comparison fails the MAC drops the frame. When this bit is reset the MAC forwards the received frame to the application with updated SAF bit of the Rx Status depending on the SA address comparison.
    /// Position: 9, Width: 1
    /// Access: read-write
    using SAFE = BitField<9, 1>;
    constexpr uint32_t SAFE_Pos = 9;
    constexpr uint32_t SAFE_Msk = SAFE::mask;

    /// When this bit is set the MAC Receiver module passes all received frames irrespective of whether they pass the address filter or not to the Application. The result of the SA or DA filtering is updated (pass or fail) in the corresponding bits in the Receive Status Word. When this bit is reset the Receiver module passes only those frames to the Application that pass the SA or DA address Filter.
    /// Position: 31, Width: 1
    /// Access: read-write
    using RECEIVE_ALL = BitField<31, 1>;
    constexpr uint32_t RECEIVE_ALL_Pos = 31;
    constexpr uint32_t RECEIVE_ALL_Msk = RECEIVE_ALL::mask;

}  // namespace emacff

/// EMACGMIIADDR - PHY configuration access
namespace emacgmiiaddr {
    /// This bit should read logic 0 before writing to PHY Addr Register and PHY data Register.During a PHY register access the software sets this bit to 1'b1 to indicate that a Read or Write access is in progress. PHY data Register is invalid until this bit is cleared by the MAC. Therefore PHY data Register (MII Data) should be kept valid until the MAC clears this bit during a PHY Write operation. Similarly for a read operation the contents of Register 5 are not valid until this bit is cleared. The subsequent read or write operation should happen only after the previous operation is complete. Because there is no acknowledgment from the PHY to MAC after a read or write operation is completed there is no change in the functionality of this bit even when the PHY is not Present.
    /// Position: 0, Width: 1
    /// Access: read-write
    using MIIBUSY = BitField<0, 1>;
    constexpr uint32_t MIIBUSY_Pos = 0;
    constexpr uint32_t MIIBUSY_Msk = MIIBUSY::mask;

    /// When set this bit indicates to the PHY that this is a Write operation using the MII Data register. If this bit is not set it indicates that this is a Read operation that is placing the data in the MII Data register.
    /// Position: 1, Width: 1
    /// Access: read-write
    using MIIWRITE = BitField<1, 1>;
    constexpr uint32_t MIIWRITE_Pos = 1;
    constexpr uint32_t MIIWRITE_Msk = MIIWRITE::mask;

    /// CSR clock range: 1.0 MHz ~ 2.5 MHz. 4'b0000: When the APB clock frequency is 80 MHz the MDC clock frequency is APB CLK/42 4'b0011: When the APB clock frequency is 40 MHz the MDC clock frequency is APB CLK/26.
    /// Position: 2, Width: 4
    /// Access: read-write
    using MIICSRCLK = BitField<2, 4>;
    constexpr uint32_t MIICSRCLK_Pos = 2;
    constexpr uint32_t MIICSRCLK_Msk = MIICSRCLK::mask;

    /// These bits select the desired MII register in the selected PHY device.
    /// Position: 6, Width: 5
    /// Access: read-write
    using MIIREG = BitField<6, 5>;
    constexpr uint32_t MIIREG_Pos = 6;
    constexpr uint32_t MIIREG_Msk = MIIREG::mask;

    /// This field indicates which of the 32 possible PHY devices are being accessed.
    /// Position: 11, Width: 5
    /// Access: read-write
    using MIIDEV = BitField<11, 5>;
    constexpr uint32_t MIIDEV_Pos = 11;
    constexpr uint32_t MIIDEV_Msk = MIIDEV::mask;

}  // namespace emacgmiiaddr

/// EMACMIIDATA - PHY data read write
namespace emacmiidata {
    /// This field contains the 16-bit data value read from the PHY after a Management Read operation or the 16-bit data value to be written to the PHY before a Management Write operation.
    /// Position: 0, Width: 16
    /// Access: read-write
    using MII_DATA = BitField<0, 16>;
    constexpr uint32_t MII_DATA_Pos = 0;
    constexpr uint32_t MII_DATA_Msk = MII_DATA::mask;

}  // namespace emacmiidata

/// EMACFC - Frame flow control
namespace emacfc {
    /// This bit initiates a Pause frame in the full-duplex mode and activates the backpressure function in the half-duplex mode if the TFCE bit is set. In the full-duplex mode this bit should be read as 1'b0 before writing to the Flow Control register. To initiate a Pause frame the Application must set this bit to 1'b1. During a transfer of the Control Frame this bit continues to be set to signify that a frame transmission is in progress. After the completion of Pause frame transmission the MAC resets this bit to 1'b0. The Flow Control register should not be written to until this bit is cleared. In the half-duplex mode when this bit is set (and TFCE is set) then backpressure is asserted by the MAC. During backpressure when the MAC receives a new frame the transmitter starts sending a JAM pattern resulting in a collision. When the MAC is configured for the full-duplex mode the BPA(backpressure activate) is automatically disabled.
    /// Position: 0, Width: 1
    /// Access: read-write
    using FCBBA = BitField<0, 1>;
    constexpr uint32_t FCBBA_Pos = 0;
    constexpr uint32_t FCBBA_Msk = FCBBA::mask;

    /// In the full-duplex mode when this bit is set the MAC enables the flow control operation to transmit Pause frames. When this bit is reset the flow control operation in the MAC is disabled and the MAC does not transmit any Pause frames. In the half-duplex mode when this bit is set the MAC enables the backpressure operation. When this bit is reset the backpressure feature is Disabled.
    /// Position: 1, Width: 1
    /// Access: read-write
    using TFCE = BitField<1, 1>;
    constexpr uint32_t TFCE_Pos = 1;
    constexpr uint32_t TFCE_Msk = TFCE::mask;

    /// When this bit is set the MAC decodes the received Pause frame and disables its transmitter for a specified (Pause) time. When this bit is reset the decode function of the Pause frame is disabled.
    /// Position: 2, Width: 1
    /// Access: read-write
    using RFCE = BitField<2, 1>;
    constexpr uint32_t RFCE_Pos = 2;
    constexpr uint32_t RFCE_Msk = RFCE::mask;

    /// A pause frame is processed when it has the unique multicast address specified in the IEEE Std 802.3. When this bit is set the MAC can also detect Pause frames with unicast address of the station. This unicast address should be as specified in the EMACADDR0 High Register and EMACADDR0 Low Register. When this bit is reset the MAC only detects Pause frames with unique multicast address.
    /// Position: 3, Width: 1
    /// Access: read-write
    using UPFD = BitField<3, 1>;
    constexpr uint32_t UPFD_Pos = 3;
    constexpr uint32_t UPFD_Msk = UPFD::mask;

    /// This field configures the threshold of the Pause timer automatic retransmission of the Pause frame.The threshold values should be always less than the Pause Time configured in Bits[31:16]. For example if PT = 100H (256 slot-times) and PLT = 01 then a second Pause frame is automatically transmitted at 228 (256-28) slot times after the first Pause frame is transmitted. The following list provides the threshold values for different values: 2'b00: The threshold is Pause time minus 4 slot times (PT-4 slot times). 2'b01: The threshold is Pause time minus 28 slot times (PT-28 slot times). 2'b10: The threshold is Pause time minus 144 slot times (PT-144 slot times). 2'b11: The threshold is Pause time minus 256 slot times (PT-256 slot times). The slot time is defined as the time taken to transmit 512 bits (64 bytes) on the MII interface.
    /// Position: 4, Width: 2
    /// Access: read-write
    using PLT = BitField<4, 2>;
    constexpr uint32_t PLT_Pos = 4;
    constexpr uint32_t PLT_Msk = PLT::mask;

    /// When this bit is set it disables the automatic generation of the Zero-Quanta Pause frames on the de-assertion of the flow-control signal from the FIFO layer. When this bit is reset normal operation with automatic Zero-Quanta Pause frame generation is enabled.
    /// Position: 7, Width: 1
    /// Access: read-write
    using DZPQ = BitField<7, 1>;
    constexpr uint32_t DZPQ_Pos = 7;
    constexpr uint32_t DZPQ_Msk = DZPQ::mask;

    /// This field holds the value to be used in the Pause Time field in the transmit control frame. If the Pause Time bits is configured to be double-synchronized to the MII clock domain then consecutive writes to this register should be performed only after at least four clock cycles in the destination clock domain.
    /// Position: 16, Width: 16
    /// Access: read-write
    using PAUSE_TIME = BitField<16, 16>;
    constexpr uint32_t PAUSE_TIME_Pos = 16;
    constexpr uint32_t PAUSE_TIME_Msk = PAUSE_TIME::mask;

}  // namespace emacfc

/// EMACDEBUG - Status debugging bits
namespace emacdebug {
    /// When high this bit indicates that the MAC MII receive protocol engine is actively receiving data and not in IDLE state.
    /// Position: 0, Width: 1
    /// Access: read-write
    using MACRPES = BitField<0, 1>;
    constexpr uint32_t MACRPES_Pos = 0;
    constexpr uint32_t MACRPES_Msk = MACRPES::mask;

    /// When high this field indicates the active state of the FIFO Read and Write controllers of the MAC Receive Frame Controller Module. MACRFFCS[1] represents the status of FIFO Read controller. MACRFFCS[0] represents the status of small FIFO Write controller.
    /// Position: 1, Width: 2
    /// Access: read-write
    using MACRFFCS = BitField<1, 2>;
    constexpr uint32_t MACRFFCS_Pos = 1;
    constexpr uint32_t MACRFFCS_Msk = MACRFFCS::mask;

    /// When high this bit indicates that the MTL Rx FIFO Write Controller is active and is transferring a received frame to the FIFO.
    /// Position: 4, Width: 1
    /// Access: read-write
    using MTLRFWCAS = BitField<4, 1>;
    constexpr uint32_t MTLRFWCAS_Pos = 4;
    constexpr uint32_t MTLRFWCAS_Msk = MTLRFWCAS::mask;

    /// This field gives the state of the Rx FIFO read Controller: 2'b00: IDLE state.2'b01: Reading frame data.2'b10: Reading frame status (or timestamp).2'b11: Flushing the frame data and status.
    /// Position: 5, Width: 2
    /// Access: read-write
    using MTLRFRCS = BitField<5, 2>;
    constexpr uint32_t MTLRFRCS_Pos = 5;
    constexpr uint32_t MTLRFRCS_Msk = MTLRFRCS::mask;

    /// This field gives the status of the fill-level of the Rx FIFO: 2'b00: Rx FIFO Empty. 2'b01: Rx FIFO fill-level below flow-control deactivate threshold. 2'b10: Rx FIFO fill-level above flow-control activate threshold. 2'b11: Rx FIFO Full.
    /// Position: 8, Width: 2
    /// Access: read-write
    using MTLRFFLS = BitField<8, 2>;
    constexpr uint32_t MTLRFFLS_Pos = 8;
    constexpr uint32_t MTLRFFLS_Msk = MTLRFFLS::mask;

    /// When high this bit indicates that the MAC MII transmit protocol engine is actively transmitting data and is not in the IDLE state.
    /// Position: 16, Width: 1
    /// Access: read-write
    using MACTPES = BitField<16, 1>;
    constexpr uint32_t MACTPES_Pos = 16;
    constexpr uint32_t MACTPES_Msk = MACTPES::mask;

    /// This field indicates the state of the MAC Transmit Frame Controller module: 2'b00: IDLE state. 2'b01: Waiting for status of previous frame or IFG or backoff period to be over. 2'b10: Generating and transmitting a Pause frame (in the full-duplex mode). 2'b11: Transferring input frame for transmission.
    /// Position: 17, Width: 2
    /// Access: read-write
    using MACTFCS = BitField<17, 2>;
    constexpr uint32_t MACTFCS_Pos = 17;
    constexpr uint32_t MACTFCS_Msk = MACTFCS::mask;

    /// When high this bit indicates that the MAC transmitter is in the Pause condition (in the full-duplex-mode) and hence does not schedule any frame for transmission.
    /// Position: 19, Width: 1
    /// Access: read-write
    using MACTP = BitField<19, 1>;
    constexpr uint32_t MACTP_Pos = 19;
    constexpr uint32_t MACTP_Msk = MACTP::mask;

    /// This field indicates the state of the Tx FIFO Read Controller: 2'b00: IDLE state. 2'b01: READ state (transferring data to the MAC transmitter). 2'b10: Waiting for TxStatus from the MAC transmitter. 2'b11: Writing the received TxStatus or flushing the Tx FIFO.
    /// Position: 20, Width: 2
    /// Access: read-write
    using MTLTFRCS = BitField<20, 2>;
    constexpr uint32_t MTLTFRCS_Pos = 20;
    constexpr uint32_t MTLTFRCS_Msk = MTLTFRCS::mask;

    /// When high this bit indicates that the MTL Tx FIFO Write Controller is active and is transferring data to the Tx FIFO.
    /// Position: 22, Width: 1
    /// Access: read-write
    using MTLTFWCS = BitField<22, 1>;
    constexpr uint32_t MTLTFWCS_Pos = 22;
    constexpr uint32_t MTLTFWCS_Msk = MTLTFWCS::mask;

    /// When high this bit indicates that the MTL Tx FIFO is not empty and some data is left for Transmission.
    /// Position: 24, Width: 1
    /// Access: read-write
    using MTLTFNES = BitField<24, 1>;
    constexpr uint32_t MTLTFNES_Pos = 24;
    constexpr uint32_t MTLTFNES_Msk = MTLTFNES::mask;

    /// When high this bit indicates that the MTL TxStatus FIFO is full. Therefore the MTL cannot accept any more frames for transmission.
    /// Position: 25, Width: 1
    /// Access: read-write
    using MTLTSFFS = BitField<25, 1>;
    constexpr uint32_t MTLTSFFS_Pos = 25;
    constexpr uint32_t MTLTSFFS_Msk = MTLTSFFS::mask;

}  // namespace emacdebug

/// PMT_CSR - PMT Control and Status
namespace pmt_csr {
    /// When set the MAC receiver drops all received frames until it receives the expected magic packet or remote wake-up frame.This bit must only be set when MGKPKTEN GLBLUCAST or RWKPKTEN bit is set high.
    /// Position: 0, Width: 1
    /// Access: read-write
    using PWRDWN = BitField<0, 1>;
    constexpr uint32_t PWRDWN_Pos = 0;
    constexpr uint32_t PWRDWN_Msk = PWRDWN::mask;

    /// When set enables generation of a power management event because of magic packet reception.
    /// Position: 1, Width: 1
    /// Access: read-write
    using MGKPKTEN = BitField<1, 1>;
    constexpr uint32_t MGKPKTEN_Pos = 1;
    constexpr uint32_t MGKPKTEN_Msk = MGKPKTEN::mask;

    /// When set enables generation of a power management event because of remote wake-up frame reception
    /// Position: 2, Width: 1
    /// Access: read-write
    using RWKPKTEN = BitField<2, 1>;
    constexpr uint32_t RWKPKTEN_Pos = 2;
    constexpr uint32_t RWKPKTEN_Msk = RWKPKTEN::mask;

    /// When set this bit indicates that the power management event is generated because of the reception of a magic packet. This bit is cleared by a Read into this register.
    /// Position: 5, Width: 1
    /// Access: read-write
    using MGKPRCVD = BitField<5, 1>;
    constexpr uint32_t MGKPRCVD_Pos = 5;
    constexpr uint32_t MGKPRCVD_Msk = MGKPRCVD::mask;

    /// When set this bit indicates the power management event is generated because of the reception of a remote wake-up frame. This bit is cleared by a Read into this register.
    /// Position: 6, Width: 1
    /// Access: read-write
    using RWKPRCVD = BitField<6, 1>;
    constexpr uint32_t RWKPRCVD_Pos = 6;
    constexpr uint32_t RWKPRCVD_Msk = RWKPRCVD::mask;

    /// When set enables any unicast packet filtered by the MAC (DAFilter) address recognition to be a remote wake-up frame.
    /// Position: 9, Width: 1
    /// Access: read-write
    using GLBLUCAST = BitField<9, 1>;
    constexpr uint32_t GLBLUCAST_Pos = 9;
    constexpr uint32_t GLBLUCAST_Msk = GLBLUCAST::mask;

    /// The maximum value of the pointer is 7 the detail information please refer to PMT_RWUFFR.
    /// Position: 24, Width: 5
    /// Access: read-write
    using RWKPTR = BitField<24, 5>;
    constexpr uint32_t RWKPTR_Pos = 24;
    constexpr uint32_t RWKPTR_Msk = RWKPTR::mask;

    /// When this bit is set it resets the RWKPTR register to 3â€™b000.
    /// Position: 31, Width: 1
    /// Access: read-write
    using RWKFILTRST = BitField<31, 1>;
    constexpr uint32_t RWKFILTRST_Pos = 31;
    constexpr uint32_t RWKFILTRST_Msk = RWKFILTRST::mask;

}  // namespace pmt_csr

/// EMACLPI_CRS - LPI Control and Status
namespace emaclpi_crs {
    /// When set this bit indicates that the MAC Transmitter has entered the LPI state because of the setting of the LPIEN bit. This bit is cleared by a read into this register.
    /// Position: 0, Width: 1
    /// Access: read-write
    using TLPIEN = BitField<0, 1>;
    constexpr uint32_t TLPIEN_Pos = 0;
    constexpr uint32_t TLPIEN_Msk = TLPIEN::mask;

    /// When set this bit indicates that the MAC transmitter has exited the LPI state after the user has cleared the LPIEN bit and the LPI_TW_Timer has expired.This bit is cleared by a read into this register.
    /// Position: 1, Width: 1
    /// Access: read-write
    using TLPIEX = BitField<1, 1>;
    constexpr uint32_t TLPIEX_Pos = 1;
    constexpr uint32_t TLPIEX_Msk = TLPIEX::mask;

    /// When set this bit indicates that the MAC Receiver has received an LPI pattern and entered the LPI state. This bit is cleared by a read into this register.
    /// Position: 2, Width: 1
    /// Access: read-write
    using RLPIEN = BitField<2, 1>;
    constexpr uint32_t RLPIEN_Pos = 2;
    constexpr uint32_t RLPIEN_Msk = RLPIEN::mask;

    /// When set this bit indicates that the MAC Receiver has stopped receiving the LPI pattern on the MII interface exited the LPI state and resumed the normal reception. This bit is cleared by a read into this register.
    /// Position: 3, Width: 1
    /// Access: read-write
    using RLPIEX = BitField<3, 1>;
    constexpr uint32_t RLPIEX_Pos = 3;
    constexpr uint32_t RLPIEX_Msk = RLPIEX::mask;

    /// When set this bit indicates that the MAC is transmitting the LPI pattern on the MII interface.
    /// Position: 8, Width: 1
    /// Access: read-write
    using TLPIST = BitField<8, 1>;
    constexpr uint32_t TLPIST_Pos = 8;
    constexpr uint32_t TLPIST_Msk = TLPIST::mask;

    /// When set this bit indicates that the MAC is receiving the LPI pattern on the MII interface.
    /// Position: 9, Width: 1
    /// Access: read-write
    using RLPIST = BitField<9, 1>;
    constexpr uint32_t RLPIST_Pos = 9;
    constexpr uint32_t RLPIST_Msk = RLPIST::mask;

    /// When set this bit instructs the MAC Transmitter to enter the LPI state. When reset this bit instructs the MAC to exit the LPI state and resume normal transmission.This bit is cleared when the LPITXA bit is set and the MAC exits the LPI state because of the arrival of a new packet for transmission.
    /// Position: 16, Width: 1
    /// Access: read-write
    using LPIEN = BitField<16, 1>;
    constexpr uint32_t LPIEN_Pos = 16;
    constexpr uint32_t LPIEN_Msk = LPIEN::mask;

    /// This bit indicates the link status of the PHY.When set the link is considered to be okay (up) and when reset the link is considered to be down.
    /// Position: 17, Width: 1
    /// Access: read-write
    using PLS = BitField<17, 1>;
    constexpr uint32_t PLS_Pos = 17;
    constexpr uint32_t PLS_Msk = PLS::mask;

    /// This bit controls the behavior of the MAC when it is entering or coming out of the LPI mode on the transmit side.If the LPITXA and LPIEN bits are set to 1 the MAC enters the LPI mode only after all outstanding frames and pending frames have been transmitted. The MAC comes out of the LPI mode when the application sends any frame.When this bit is 0 the LPIEN bit directly controls behavior of the MAC when it is entering or coming out of the LPI mode.
    /// Position: 19, Width: 1
    /// Access: read-write
    using LPITXA = BitField<19, 1>;
    constexpr uint32_t LPITXA_Pos = 19;
    constexpr uint32_t LPITXA_Msk = LPITXA::mask;

}  // namespace emaclpi_crs

/// EMACLPITIMERSCONTROL - LPI Timers Control
namespace emaclpitimerscontrol {
    /// This field specifies the minimum time (in microseconds) for which the MAC waits after it stops transmitting the LPI pattern to the PHY and before it resumes the normal transmission. The TLPIEX status bit is set after the expiry of this timer.
    /// Position: 0, Width: 16
    /// Access: read-write
    using LPI_TW_TIMER = BitField<0, 16>;
    constexpr uint32_t LPI_TW_TIMER_Pos = 0;
    constexpr uint32_t LPI_TW_TIMER_Msk = LPI_TW_TIMER::mask;

    /// This field specifies the minimum time (in milliseconds) for which the link status from the PHY should be up (OKAY) before the LPI pattern can be transmitted to the PHY. The MAC does not transmit the LPI pattern even when the LPIEN bit is set unless the LPI_LS_Timer reaches the programmed terminal count. The default value of the LPI_LS_Timer is 1000 (1 sec) as defined in the IEEE standard.
    /// Position: 16, Width: 10
    /// Access: read-write
    using LPI_LS_TIMER = BitField<16, 10>;
    constexpr uint32_t LPI_LS_TIMER_Pos = 16;
    constexpr uint32_t LPI_LS_TIMER_Msk = LPI_LS_TIMER::mask;

}  // namespace emaclpitimerscontrol

/// EMACINTS - Interrupt status
namespace emacints {
    /// This bit is set when a magic packet or remote wake-up frame is received in the power-down mode (see Bit[5] and Bit[6] in the PMT Control and Status Register). This bit is cleared when both Bits[6:5] are cleared because of a read operation to the PMT Control and Status register. This bit is valid only when you select the optional PMT module during core configuration.
    /// Position: 3, Width: 1
    /// Access: read-write
    using PMTINTS = BitField<3, 1>;
    constexpr uint32_t PMTINTS_Pos = 3;
    constexpr uint32_t PMTINTS_Msk = PMTINTS::mask;

    /// When the Energy Efficient Ethernet feature is enabled this bit is set for any LPI state entry or exit in the MAC Transmitter or Receiver. This bit is cleared on reading Bit[0] of Register (LPI Control and Status Register).
    /// Position: 10, Width: 1
    /// Access: read-write
    using LPIIS = BitField<10, 1>;
    constexpr uint32_t LPIIS_Pos = 10;
    constexpr uint32_t LPIIS_Msk = LPIIS::mask;

}  // namespace emacints

/// EMACINTMASK - Interrupt mask
namespace emacintmask {
    /// When set this bit disables the assertion of the interrupt signal because of the setting of PMT Interrupt Status bit in Register (Interrupt Status Register).
    /// Position: 3, Width: 1
    /// Access: read-write
    using PMTINTMASK = BitField<3, 1>;
    constexpr uint32_t PMTINTMASK_Pos = 3;
    constexpr uint32_t PMTINTMASK_Msk = PMTINTMASK::mask;

    /// When set this bit disables the assertion of the interrupt signal because of the setting of the LPI Interrupt Status bit in Register (Interrupt Status Register).
    /// Position: 10, Width: 1
    /// Access: read-write
    using LPIINTMASK = BitField<10, 1>;
    constexpr uint32_t LPIINTMASK_Pos = 10;
    constexpr uint32_t LPIINTMASK_Msk = LPIINTMASK::mask;

}  // namespace emacintmask

/// EMACADDR0HIGH - Upper 16 bits of the first 6-byte MAC address
namespace emacaddr0high {
    /// This field contains the upper 16 bits (47:32) of the first 6-byte MAC address.The MAC uses this field for filtering the received frames and inserting the MAC address in the Transmit Flow Control (Pause) Frames.
    /// Position: 0, Width: 16
    /// Access: read-write
    using ADDRESS0_HI = BitField<0, 16>;
    constexpr uint32_t ADDRESS0_HI_Pos = 0;
    constexpr uint32_t ADDRESS0_HI_Msk = ADDRESS0_HI::mask;

    /// This bit is always set to 1.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDRESS_ENABLE0 = BitField<31, 1>;
    constexpr uint32_t ADDRESS_ENABLE0_Pos = 31;
    constexpr uint32_t ADDRESS_ENABLE0_Msk = ADDRESS_ENABLE0::mask;

}  // namespace emacaddr0high

/// EMACADDR1HIGH - Upper 16 bits of the second 6-byte MAC address
namespace emacaddr1high {
    /// This field contains the upper 16 bits Bits[47:32] of the second 6-byte MAC Address.
    /// Position: 0, Width: 16
    /// Access: read-write
    using MAC_ADDRESS1_HI = BitField<0, 16>;
    constexpr uint32_t MAC_ADDRESS1_HI_Pos = 0;
    constexpr uint32_t MAC_ADDRESS1_HI_Msk = MAC_ADDRESS1_HI::mask;

    /// These bits are mask control bits for comparison of each of the EMACADDR1 bytes. When set high the MAC does not compare the corresponding byte of received DA or SA with the contents of EMACADDR1 registers. Each bit controls the masking of the bytes as follows: Bit[29]: EMACADDR1 High [15:8]. Bit[28]: EMACADDR1 High [7:0]. Bit[27]: EMACADDR1 Low [31:24]. Bit[24]: EMACADDR1 Low [7:0].You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.
    /// Position: 24, Width: 6
    /// Access: read-write
    using MASK_BYTE_CONTROL = BitField<24, 6>;
    constexpr uint32_t MASK_BYTE_CONTROL_Pos = 24;
    constexpr uint32_t MASK_BYTE_CONTROL_Msk = MASK_BYTE_CONTROL::mask;

    /// When this bit is set the EMACADDR1[47:0] is used to compare with the SA fields of the received frame. When this bit is reset the EMACADDR1[47:0] is used to compare with the DA fields of the received frame.
    /// Position: 30, Width: 1
    /// Access: read-write
    using SOURCE_ADDRESS = BitField<30, 1>;
    constexpr uint32_t SOURCE_ADDRESS_Pos = 30;
    constexpr uint32_t SOURCE_ADDRESS_Msk = SOURCE_ADDRESS::mask;

    /// When this bit is set the address filter module uses the second MAC address for perfect filtering. When this bit is reset the address filter module ignores the address for filtering.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDRESS_ENABLE1 = BitField<31, 1>;
    constexpr uint32_t ADDRESS_ENABLE1_Pos = 31;
    constexpr uint32_t ADDRESS_ENABLE1_Msk = ADDRESS_ENABLE1::mask;

}  // namespace emacaddr1high

/// EMACADDR2HIGH - Upper 16 bits of the third 6-byte MAC address
namespace emacaddr2high {
    /// This field contains the upper 16 bits Bits[47:32] of the third 6-byte MAC address.
    /// Position: 0, Width: 16
    /// Access: read-write
    using MAC_ADDRESS2_HI = BitField<0, 16>;
    constexpr uint32_t MAC_ADDRESS2_HI_Pos = 0;
    constexpr uint32_t MAC_ADDRESS2_HI_Msk = MAC_ADDRESS2_HI::mask;

    /// These bits are mask control bits for comparison of each of the EMACADDR2 bytes. When set high the MAC does not compare the corresponding byte of received DA or SA with the contents of EMACADDR2 registers. Each bit controls the masking of the bytes as follows: Bit[29]: EMACADDR2 High [15:8]. Bit[28]: EMACADDR2 High [7:0]. Bit[27]: EMACADDR2 Low [31:24]. Bit[24]: EMACADDR2 Low [7:0].You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.
    /// Position: 24, Width: 6
    /// Access: read-write
    using MASK_BYTE_CONTROL2 = BitField<24, 6>;
    constexpr uint32_t MASK_BYTE_CONTROL2_Pos = 24;
    constexpr uint32_t MASK_BYTE_CONTROL2_Msk = MASK_BYTE_CONTROL2::mask;

    /// When this bit is set the EMACADDR2[47:0] is used to compare with the SA fields of the received frame. When this bit is reset the EMACADDR2[47:0] is used to compare with the DA fields of the received frame.
    /// Position: 30, Width: 1
    /// Access: read-write
    using SOURCE_ADDRESS2 = BitField<30, 1>;
    constexpr uint32_t SOURCE_ADDRESS2_Pos = 30;
    constexpr uint32_t SOURCE_ADDRESS2_Msk = SOURCE_ADDRESS2::mask;

    /// When this bit is set the address filter module uses the third MAC address for perfect filtering. When this bit is reset the address filter module ignores the address for filtering.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDRESS_ENABLE2 = BitField<31, 1>;
    constexpr uint32_t ADDRESS_ENABLE2_Pos = 31;
    constexpr uint32_t ADDRESS_ENABLE2_Msk = ADDRESS_ENABLE2::mask;

}  // namespace emacaddr2high

/// EMACADDR3HIGH - Upper 16 bits of the fourth 6-byte MAC address
namespace emacaddr3high {
    /// This field contains the upper 16 bits Bits[47:32] of the fourth 6-byte MAC address.
    /// Position: 0, Width: 16
    /// Access: read-write
    using MAC_ADDRESS3_HI = BitField<0, 16>;
    constexpr uint32_t MAC_ADDRESS3_HI_Pos = 0;
    constexpr uint32_t MAC_ADDRESS3_HI_Msk = MAC_ADDRESS3_HI::mask;

    /// These bits are mask control bits for comparison of each of the EMACADDR3 bytes. When set high the MAC does not compare the corresponding byte of received DA or SA with the contents of EMACADDR3 registers. Each bit controls the masking of the bytes as follows: Bit[29]: EMACADDR3 High [15:8]. Bit[28]: EMACADDR3 High [7:0]. Bit[27]: EMACADDR3 Low [31:24]. Bit[24]: EMACADDR3 Low [7:0].You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.
    /// Position: 24, Width: 6
    /// Access: read-write
    using MASK_BYTE_CONTROL3 = BitField<24, 6>;
    constexpr uint32_t MASK_BYTE_CONTROL3_Pos = 24;
    constexpr uint32_t MASK_BYTE_CONTROL3_Msk = MASK_BYTE_CONTROL3::mask;

    /// When this bit is set the EMACADDR3[47:0] is used to compare with the SA fields of the received frame. When this bit is reset the EMACADDR3[47:0] is used to compare with the DA fields of the received frame.
    /// Position: 30, Width: 1
    /// Access: read-write
    using SOURCE_ADDRESS3 = BitField<30, 1>;
    constexpr uint32_t SOURCE_ADDRESS3_Pos = 30;
    constexpr uint32_t SOURCE_ADDRESS3_Msk = SOURCE_ADDRESS3::mask;

    /// When this bit is set the address filter module uses the fourth MAC address for perfect filtering. When this bit is reset the address filter module ignores the address for filtering.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDRESS_ENABLE3 = BitField<31, 1>;
    constexpr uint32_t ADDRESS_ENABLE3_Pos = 31;
    constexpr uint32_t ADDRESS_ENABLE3_Msk = ADDRESS_ENABLE3::mask;

}  // namespace emacaddr3high

/// EMACADDR4HIGH - Upper 16 bits of the fifth 6-byte MAC address
namespace emacaddr4high {
    /// This field contains the upper 16 bits Bits[47:32] of the fifth 6-byte MAC address.
    /// Position: 0, Width: 16
    /// Access: read-write
    using MAC_ADDRESS4_HI = BitField<0, 16>;
    constexpr uint32_t MAC_ADDRESS4_HI_Pos = 0;
    constexpr uint32_t MAC_ADDRESS4_HI_Msk = MAC_ADDRESS4_HI::mask;

    /// These bits are mask control bits for comparison of each of the EMACADDR4 bytes. When set high the MAC does not compare the corresponding byte of received DA or SA with the contents of EMACADDR4 registers. Each bit controls the masking of the bytes as follows: Bit[29]: EMACADDR4 High [15:8]. Bit[28]: EMACADDR4 High [7:0]. Bit[27]: EMACADDR4 Low [31:24]. Bit[24]: EMACADDR4 Low [7:0].You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.
    /// Position: 24, Width: 6
    /// Access: read-write
    using MASK_BYTE_CONTROL4 = BitField<24, 6>;
    constexpr uint32_t MASK_BYTE_CONTROL4_Pos = 24;
    constexpr uint32_t MASK_BYTE_CONTROL4_Msk = MASK_BYTE_CONTROL4::mask;

    /// When this bit is set the EMACADDR4[47:0] is used to compare with the SA fields of the received frame. When this bit is reset the EMACADDR4[47:0] is used to compare with the DA fields of the received frame.
    /// Position: 30, Width: 1
    /// Access: read-write
    using SOURCE_ADDRESS4 = BitField<30, 1>;
    constexpr uint32_t SOURCE_ADDRESS4_Pos = 30;
    constexpr uint32_t SOURCE_ADDRESS4_Msk = SOURCE_ADDRESS4::mask;

    /// When this bit is set the address filter module uses the fifth MAC address for perfect filtering. When this bit is reset the address filter module ignores the address for filtering.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDRESS_ENABLE4 = BitField<31, 1>;
    constexpr uint32_t ADDRESS_ENABLE4_Pos = 31;
    constexpr uint32_t ADDRESS_ENABLE4_Msk = ADDRESS_ENABLE4::mask;

}  // namespace emacaddr4high

/// EMACADDR5HIGH - Upper 16 bits of the sixth 6-byte MAC address
namespace emacaddr5high {
    /// This field contains the upper 16 bits Bits[47:32] of the sixth 6-byte MAC address.
    /// Position: 0, Width: 16
    /// Access: read-write
    using MAC_ADDRESS5_HI = BitField<0, 16>;
    constexpr uint32_t MAC_ADDRESS5_HI_Pos = 0;
    constexpr uint32_t MAC_ADDRESS5_HI_Msk = MAC_ADDRESS5_HI::mask;

    /// These bits are mask control bits for comparison of each of the EMACADDR5 bytes. When set high the MAC does not compare the corresponding byte of received DA or SA with the contents of EMACADDR5 registers. Each bit controls the masking of the bytes as follows: Bit[29]: EMACADDR5 High [15:8]. Bit[28]: EMACADDR5 High [7:0]. Bit[27]: EMACADDR5 Low [31:24]. Bit[24]: EMACADDR5 Low [7:0].You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.
    /// Position: 24, Width: 6
    /// Access: read-write
    using MASK_BYTE_CONTROL5 = BitField<24, 6>;
    constexpr uint32_t MASK_BYTE_CONTROL5_Pos = 24;
    constexpr uint32_t MASK_BYTE_CONTROL5_Msk = MASK_BYTE_CONTROL5::mask;

    /// When this bit is set the EMACADDR5[47:0] is used to compare with the SA fields of the received frame. When this bit is reset the EMACADDR5[47:0] is used to compare with the DA fields of the received frame.
    /// Position: 30, Width: 1
    /// Access: read-write
    using SOURCE_ADDRESS5 = BitField<30, 1>;
    constexpr uint32_t SOURCE_ADDRESS5_Pos = 30;
    constexpr uint32_t SOURCE_ADDRESS5_Msk = SOURCE_ADDRESS5::mask;

    /// When this bit is set the address filter module uses the sixth MAC address for perfect filtering. When this bit is reset the address filter module ignores the address for filtering.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDRESS_ENABLE5 = BitField<31, 1>;
    constexpr uint32_t ADDRESS_ENABLE5_Pos = 31;
    constexpr uint32_t ADDRESS_ENABLE5_Msk = ADDRESS_ENABLE5::mask;

}  // namespace emacaddr5high

/// EMACADDR6HIGH - Upper 16 bits of the seventh 6-byte MAC address
namespace emacaddr6high {
    /// This field contains the upper 16 bits Bits[47:32] of the seventh 6-byte MAC Address.
    /// Position: 0, Width: 16
    /// Access: read-write
    using MAC_ADDRESS6_HI = BitField<0, 16>;
    constexpr uint32_t MAC_ADDRESS6_HI_Pos = 0;
    constexpr uint32_t MAC_ADDRESS6_HI_Msk = MAC_ADDRESS6_HI::mask;

    /// These bits are mask control bits for comparison of each of the EMACADDR6 bytes. When set high the MAC does not compare the corresponding byte of received DA or SA with the contents of EMACADDR6 registers. Each bit controls the masking of the bytes as follows: Bit[29]: EMACADDR6 High [15:8]. Bit[28]: EMACADDR6 High [7:0]. Bit[27]: EMACADDR6 Low [31:24]. Bit[24]: EMACADDR6 Low [7:0].You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.
    /// Position: 24, Width: 6
    /// Access: read-write
    using MASK_BYTE_CONTROL6 = BitField<24, 6>;
    constexpr uint32_t MASK_BYTE_CONTROL6_Pos = 24;
    constexpr uint32_t MASK_BYTE_CONTROL6_Msk = MASK_BYTE_CONTROL6::mask;

    /// When this bit is set the EMACADDR6[47:0] is used to compare with the SA fields of the received frame. When this bit is reset the EMACADDR6[47:0] is used to compare with the DA fields of the received frame.
    /// Position: 30, Width: 1
    /// Access: read-write
    using SOURCE_ADDRESS6 = BitField<30, 1>;
    constexpr uint32_t SOURCE_ADDRESS6_Pos = 30;
    constexpr uint32_t SOURCE_ADDRESS6_Msk = SOURCE_ADDRESS6::mask;

    /// When this bit is set the address filter module uses the seventh MAC address for perfect filtering. When this bit is reset the address filter module ignores the address for filtering.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDRESS_ENABLE6 = BitField<31, 1>;
    constexpr uint32_t ADDRESS_ENABLE6_Pos = 31;
    constexpr uint32_t ADDRESS_ENABLE6_Msk = ADDRESS_ENABLE6::mask;

}  // namespace emacaddr6high

/// EMACADDR7HIGH - Upper 16 bits of the eighth 6-byte MAC address
namespace emacaddr7high {
    /// This field contains the upper 16 bits Bits[47:32] of the eighth 6-byte MAC Address.
    /// Position: 0, Width: 16
    /// Access: read-write
    using MAC_ADDRESS7_HI = BitField<0, 16>;
    constexpr uint32_t MAC_ADDRESS7_HI_Pos = 0;
    constexpr uint32_t MAC_ADDRESS7_HI_Msk = MAC_ADDRESS7_HI::mask;

    /// These bits are mask control bits for comparison of each of the EMACADDR7 bytes. When set high the MAC does not compare the corresponding byte of received DA or SA with the contents of EMACADDR7 registers. Each bit controls the masking of the bytes as follows: Bit[29]: EMACADDR7 High [15:8]. Bit[28]: EMACADDR7 High [7:0]. Bit[27]: EMACADDR7 Low [31:24]. Bit[24]: EMACADDR7 Low [7:0].You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.
    /// Position: 24, Width: 6
    /// Access: read-write
    using MASK_BYTE_CONTROL7 = BitField<24, 6>;
    constexpr uint32_t MASK_BYTE_CONTROL7_Pos = 24;
    constexpr uint32_t MASK_BYTE_CONTROL7_Msk = MASK_BYTE_CONTROL7::mask;

    /// When this bit is set the EMACADDR7[47:0] is used to compare with the SA fields of the received frame. When this bit is reset the EMACADDR7[47:0] is used to compare with the DA fields of the received frame.
    /// Position: 30, Width: 1
    /// Access: read-write
    using SOURCE_ADDRESS7 = BitField<30, 1>;
    constexpr uint32_t SOURCE_ADDRESS7_Pos = 30;
    constexpr uint32_t SOURCE_ADDRESS7_Msk = SOURCE_ADDRESS7::mask;

    /// When this bit is set the address filter module uses the eighth MAC address for perfect filtering. When this bit is reset the address filter module ignores the address for filtering.
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADDRESS_ENABLE7 = BitField<31, 1>;
    constexpr uint32_t ADDRESS_ENABLE7_Pos = 31;
    constexpr uint32_t ADDRESS_ENABLE7_Msk = ADDRESS_ENABLE7::mask;

}  // namespace emacaddr7high

/// EMACCSTATUS - Link communication status
namespace emaccstatus {
    /// This bit indicates the current mode of operation of the link: 1'b0: Half-duplex mode. 1'b1: Full-duplex mode.
    /// Position: 0, Width: 1
    /// Access: read-write
    using LINK_MODE = BitField<0, 1>;
    constexpr uint32_t LINK_MODE_Pos = 0;
    constexpr uint32_t LINK_MODE_Msk = LINK_MODE::mask;

    /// This bit indicates the current speed of the link: 2'b00: 2.5 MHz. 2'b01: 25 MHz. 2'b10: 125 MHz.
    /// Position: 1, Width: 2
    /// Access: read-write
    using LINK_SPEED = BitField<1, 2>;
    constexpr uint32_t LINK_SPEED_Pos = 1;
    constexpr uint32_t LINK_SPEED_Msk = LINK_SPEED::mask;

    /// This bit indicates whether there is jabber timeout error (1'b1) in the received Frame.
    /// Position: 4, Width: 1
    /// Access: read-write
    using JABBER_TIMEOUT = BitField<4, 1>;
    constexpr uint32_t JABBER_TIMEOUT_Pos = 4;
    constexpr uint32_t JABBER_TIMEOUT_Msk = JABBER_TIMEOUT::mask;

}  // namespace emaccstatus

/// EMACWDOGTO - Watchdog timeout control
namespace emacwdogto {
    /// When Bit[16] (PWE) is set and Bit[23] (WD) of EMACCONFIG_REG is reset this field is used as watchdog timeout for a received frame. If the length of a received frame exceeds the value of this field such frame is terminated and declared as an error frame.
    /// Position: 0, Width: 14
    /// Access: read-write
    using WDOGTO = BitField<0, 14>;
    constexpr uint32_t WDOGTO_Pos = 0;
    constexpr uint32_t WDOGTO_Msk = WDOGTO::mask;

    /// When this bit is set and Bit[23] (WD) of EMACCONFIG_REG is reset the WTO field (Bits[13:0]) is used as watchdog timeout for a received frame. When this bit is cleared the watchdog timeout for a received frame is controlled by the setting of Bit[23] (WD) and Bit[20] (JE) in EMACCONFIG_REG.
    /// Position: 16, Width: 1
    /// Access: read-write
    using PWDOGEN = BitField<16, 1>;
    constexpr uint32_t PWDOGEN_Pos = 16;
    constexpr uint32_t PWDOGEN_Msk = PWDOGEN::mask;

}  // namespace emacwdogto

}  // namespace alloy::hal::espressif::esp32::emac_mac
