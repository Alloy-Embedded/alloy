/// Auto-generated bit field definitions for SHA
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

#include "hal/utils/bitfield.hpp"

namespace alloy::hal::espressif::esp32::sha {

using namespace alloy::hal::bitfields;

// ============================================================================
// SHA Bit Field Definitions
// ============================================================================

/// TEXT[32] - TEXT[32]
namespace text {
/// SHA Message block and hash result register.
/// Position: 0, Width: 32
/// Access: read-write
using TEXT = BitField<0, 32>;
constexpr uint32_t TEXT_Pos = 0;
constexpr uint32_t TEXT_Msk = TEXT::mask;

}  // namespace text

/// SHA1_START - SHA1_START
namespace sha1_start {
/// Write 1 to start an SHA-1 operation on the first message block.
/// Position: 0, Width: 1
/// Access: write-only
using SHA1_START = BitField<0, 1>;
constexpr uint32_t SHA1_START_Pos = 0;
constexpr uint32_t SHA1_START_Msk = SHA1_START::mask;

}  // namespace sha1_start

/// SHA1_CONTINUE - SHA1_CONTINUE
namespace sha1_continue {
/// Write 1 to continue the SHA-1 operation with subsequent blocks.
/// Position: 0, Width: 1
/// Access: write-only
using SHA1_CONTINUE = BitField<0, 1>;
constexpr uint32_t SHA1_CONTINUE_Pos = 0;
constexpr uint32_t SHA1_CONTINUE_Msk = SHA1_CONTINUE::mask;

}  // namespace sha1_continue

/// SHA1_LOAD - SHA1_LOAD
namespace sha1_load {
/// Write 1 to finish the SHA-1 operation to calculate the final message hash.
/// Position: 0, Width: 1
/// Access: write-only
using SHA1_LOAD = BitField<0, 1>;
constexpr uint32_t SHA1_LOAD_Pos = 0;
constexpr uint32_t SHA1_LOAD_Msk = SHA1_LOAD::mask;

}  // namespace sha1_load

/// SHA1_BUSY - SHA1_BUSY
namespace sha1_busy {
/// SHA-1 operation status: 1 if the SHA accelerator is processing data, 0 if it is idle.
/// Position: 0, Width: 1
/// Access: read-only
using SHA1_BUSY = BitField<0, 1>;
constexpr uint32_t SHA1_BUSY_Pos = 0;
constexpr uint32_t SHA1_BUSY_Msk = SHA1_BUSY::mask;

}  // namespace sha1_busy

/// SHA256_START - SHA256_START
namespace sha256_start {
/// Write 1 to start an SHA-256 operation on the first message block.
/// Position: 0, Width: 1
/// Access: write-only
using SHA256_START = BitField<0, 1>;
constexpr uint32_t SHA256_START_Pos = 0;
constexpr uint32_t SHA256_START_Msk = SHA256_START::mask;

}  // namespace sha256_start

/// SHA256_CONTINUE - SHA256_CONTINUE
namespace sha256_continue {
/// Write 1 to continue the SHA-256 operation with subsequent blocks.
/// Position: 0, Width: 1
/// Access: write-only
using SHA256_CONTINUE = BitField<0, 1>;
constexpr uint32_t SHA256_CONTINUE_Pos = 0;
constexpr uint32_t SHA256_CONTINUE_Msk = SHA256_CONTINUE::mask;

}  // namespace sha256_continue

/// SHA256_LOAD - SHA256_LOAD
namespace sha256_load {
/// Write 1 to finish the SHA-256 operation to calculate the final message hash.
/// Position: 0, Width: 1
/// Access: write-only
using SHA256_LOAD = BitField<0, 1>;
constexpr uint32_t SHA256_LOAD_Pos = 0;
constexpr uint32_t SHA256_LOAD_Msk = SHA256_LOAD::mask;

}  // namespace sha256_load

/// SHA256_BUSY - SHA256_BUSY
namespace sha256_busy {
/// SHA-256 operation status: 1 if the SHA accelerator is processing data, 0 if it is idle.
/// Position: 0, Width: 1
/// Access: read-only
using SHA256_BUSY = BitField<0, 1>;
constexpr uint32_t SHA256_BUSY_Pos = 0;
constexpr uint32_t SHA256_BUSY_Msk = SHA256_BUSY::mask;

}  // namespace sha256_busy

/// SHA384_START - SHA384_START
namespace sha384_start {
/// Write 1 to start an SHA-384 operation on the first message block.
/// Position: 0, Width: 1
/// Access: write-only
using SHA384_START = BitField<0, 1>;
constexpr uint32_t SHA384_START_Pos = 0;
constexpr uint32_t SHA384_START_Msk = SHA384_START::mask;

}  // namespace sha384_start

/// SHA384_CONTINUE - SHA384_CONTINUE
namespace sha384_continue {
/// Write 1 to continue the SHA-384 operation with subsequent blocks.
/// Position: 0, Width: 1
/// Access: write-only
using SHA384_CONTINUE = BitField<0, 1>;
constexpr uint32_t SHA384_CONTINUE_Pos = 0;
constexpr uint32_t SHA384_CONTINUE_Msk = SHA384_CONTINUE::mask;

}  // namespace sha384_continue

/// SHA384_LOAD - SHA384_LOAD
namespace sha384_load {
/// Write 1 to finish the SHA-384 operation to calculate the final message hash.
/// Position: 0, Width: 1
/// Access: write-only
using SHA384_LOAD = BitField<0, 1>;
constexpr uint32_t SHA384_LOAD_Pos = 0;
constexpr uint32_t SHA384_LOAD_Msk = SHA384_LOAD::mask;

}  // namespace sha384_load

/// SHA384_BUSY - SHA384_BUSY
namespace sha384_busy {
/// SHA-384 operation status: 1 if the SHA accelerator is processing data, 0 if it is idle.
/// Position: 0, Width: 1
/// Access: read-only
using SHA384_BUSY = BitField<0, 1>;
constexpr uint32_t SHA384_BUSY_Pos = 0;
constexpr uint32_t SHA384_BUSY_Msk = SHA384_BUSY::mask;

}  // namespace sha384_busy

/// SHA512_START - SHA512_START
namespace sha512_start {
/// Write 1 to start an SHA-512 operation on the first message block.
/// Position: 0, Width: 1
/// Access: write-only
using SHA512_START = BitField<0, 1>;
constexpr uint32_t SHA512_START_Pos = 0;
constexpr uint32_t SHA512_START_Msk = SHA512_START::mask;

}  // namespace sha512_start

/// SHA512_CONTINUE - SHA512_CONTINUE
namespace sha512_continue {
/// Write 1 to continue the SHA-512 operation with subsequent blocks.
/// Position: 0, Width: 1
/// Access: write-only
using SHA512_CONTINUE = BitField<0, 1>;
constexpr uint32_t SHA512_CONTINUE_Pos = 0;
constexpr uint32_t SHA512_CONTINUE_Msk = SHA512_CONTINUE::mask;

}  // namespace sha512_continue

/// SHA512_LOAD - SHA512_LOAD
namespace sha512_load {
/// Write 1 to finish the SHA-512 operation to calculate the final message hash.
/// Position: 0, Width: 1
/// Access: write-only
using SHA512_LOAD = BitField<0, 1>;
constexpr uint32_t SHA512_LOAD_Pos = 0;
constexpr uint32_t SHA512_LOAD_Msk = SHA512_LOAD::mask;

}  // namespace sha512_load

/// SHA512_BUSY - SHA512_BUSY
namespace sha512_busy {
/// SHA-512 operation status: 1 if the SHA accelerator is processing data, 0 if it is idle.
/// Position: 0, Width: 1
/// Access: read-only
using SHA512_BUSY = BitField<0, 1>;
constexpr uint32_t SHA512_BUSY_Pos = 0;
constexpr uint32_t SHA512_BUSY_Msk = SHA512_BUSY::mask;

}  // namespace sha512_busy

}  // namespace alloy::hal::espressif::esp32::sha
