/// Auto-generated bit field definitions for UHCI0
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

#include "hal/utils/bitfield.hpp"

namespace alloy::hal::espressif::esp32::uhci0 {

using namespace alloy::hal::bitfields;

// ============================================================================
// UHCI0 Bit Field Definitions
// ============================================================================

/// CONF0 - CONF0
namespace conf0 {
/// Set this bit to reset in link operations.
/// Position: 0, Width: 1
/// Access: read-write
using IN_RST = BitField<0, 1>;
constexpr uint32_t IN_RST_Pos = 0;
constexpr uint32_t IN_RST_Msk = IN_RST::mask;

/// Set this bit to reset out link operations.
/// Position: 1, Width: 1
/// Access: read-write
using OUT_RST = BitField<1, 1>;
constexpr uint32_t OUT_RST_Pos = 1;
constexpr uint32_t OUT_RST_Msk = OUT_RST::mask;

/// Set this bit to reset dma ahb fifo.
/// Position: 2, Width: 1
/// Access: read-write
using AHBM_FIFO_RST = BitField<2, 1>;
constexpr uint32_t AHBM_FIFO_RST_Pos = 2;
constexpr uint32_t AHBM_FIFO_RST_Msk = AHBM_FIFO_RST::mask;

/// Set this bit to reset dma ahb interface.
/// Position: 3, Width: 1
/// Access: read-write
using AHBM_RST = BitField<3, 1>;
constexpr uint32_t AHBM_RST_Pos = 3;
constexpr uint32_t AHBM_RST_Msk = AHBM_RST::mask;

/// Set this bit to enable loop test for in links.
/// Position: 4, Width: 1
/// Access: read-write
using IN_LOOP_TEST = BitField<4, 1>;
constexpr uint32_t IN_LOOP_TEST_Pos = 4;
constexpr uint32_t IN_LOOP_TEST_Msk = IN_LOOP_TEST::mask;

/// Set this bit to enable loop test for out links.
/// Position: 5, Width: 1
/// Access: read-write
using OUT_LOOP_TEST = BitField<5, 1>;
constexpr uint32_t OUT_LOOP_TEST_Pos = 5;
constexpr uint32_t OUT_LOOP_TEST_Msk = OUT_LOOP_TEST::mask;

/// when in link's length is 0 go on to use the next in link automatically.
/// Position: 6, Width: 1
/// Access: read-write
using OUT_AUTO_WRBACK = BitField<6, 1>;
constexpr uint32_t OUT_AUTO_WRBACK_Pos = 6;
constexpr uint32_t OUT_AUTO_WRBACK_Msk = OUT_AUTO_WRBACK::mask;

/// don't use
/// Position: 7, Width: 1
/// Access: read-write
using OUT_NO_RESTART_CLR = BitField<7, 1>;
constexpr uint32_t OUT_NO_RESTART_CLR_Pos = 7;
constexpr uint32_t OUT_NO_RESTART_CLR_Msk = OUT_NO_RESTART_CLR::mask;

/// Set this bit to produce eof after DMA pops all data clear this bit to produce eof after DMA
/// pushes all data Position: 8, Width: 1 Access: read-write
using OUT_EOF_MODE = BitField<8, 1>;
constexpr uint32_t OUT_EOF_MODE_Pos = 8;
constexpr uint32_t OUT_EOF_MODE_Msk = OUT_EOF_MODE::mask;

/// Set this bit to use UART to transmit or receive data.
/// Position: 9, Width: 1
/// Access: read-write
using UART0_CE = BitField<9, 1>;
constexpr uint32_t UART0_CE_Pos = 9;
constexpr uint32_t UART0_CE_Msk = UART0_CE::mask;

/// Set this bit to use UART1 to transmit or receive data.
/// Position: 10, Width: 1
/// Access: read-write
using UART1_CE = BitField<10, 1>;
constexpr uint32_t UART1_CE_Pos = 10;
constexpr uint32_t UART1_CE_Msk = UART1_CE::mask;

/// Set this bit to use UART2 to transmit or receive data.
/// Position: 11, Width: 1
/// Access: read-write
using UART2_CE = BitField<11, 1>;
constexpr uint32_t UART2_CE_Pos = 11;
constexpr uint32_t UART2_CE_Msk = UART2_CE::mask;

/// Set this bit to enable DMA in links to use burst mode.
/// Position: 12, Width: 1
/// Access: read-write
using OUTDSCR_BURST_EN = BitField<12, 1>;
constexpr uint32_t OUTDSCR_BURST_EN_Pos = 12;
constexpr uint32_t OUTDSCR_BURST_EN_Msk = OUTDSCR_BURST_EN::mask;

/// Set this bit to enable DMA out links to use burst mode.
/// Position: 13, Width: 1
/// Access: read-write
using INDSCR_BURST_EN = BitField<13, 1>;
constexpr uint32_t INDSCR_BURST_EN_Pos = 13;
constexpr uint32_t INDSCR_BURST_EN_Msk = INDSCR_BURST_EN::mask;

/// Set this bit to enable DMA burst MODE
/// Position: 14, Width: 1
/// Access: read-write
using OUT_DATA_BURST_EN = BitField<14, 1>;
constexpr uint32_t OUT_DATA_BURST_EN_Pos = 14;
constexpr uint32_t OUT_DATA_BURST_EN_Msk = OUT_DATA_BURST_EN::mask;

/// Position: 15, Width: 1
/// Access: read-write
using MEM_TRANS_EN = BitField<15, 1>;
constexpr uint32_t MEM_TRANS_EN_Pos = 15;
constexpr uint32_t MEM_TRANS_EN_Msk = MEM_TRANS_EN::mask;

/// Set this bit to use special char to separate the data frame.
/// Position: 16, Width: 1
/// Access: read-write
using SEPER_EN = BitField<16, 1>;
constexpr uint32_t SEPER_EN_Pos = 16;
constexpr uint32_t SEPER_EN_Msk = SEPER_EN::mask;

/// Set this bit to enable to use head packet before the data frame.
/// Position: 17, Width: 1
/// Access: read-write
using HEAD_EN = BitField<17, 1>;
constexpr uint32_t HEAD_EN_Pos = 17;
constexpr uint32_t HEAD_EN_Msk = HEAD_EN::mask;

/// Set this bit to enable receiver''s ability of crc calculation when crc_en bit in head packet is
/// 1 then there will be crc bytes after data_frame Position: 18, Width: 1 Access: read-write
using CRC_REC_EN = BitField<18, 1>;
constexpr uint32_t CRC_REC_EN_Pos = 18;
constexpr uint32_t CRC_REC_EN_Msk = CRC_REC_EN::mask;

/// Set this bit to enable to use idle time when the idle time after data frame is satisfied this
/// means the end of a data frame. Position: 19, Width: 1 Access: read-write
using UART_IDLE_EOF_EN = BitField<19, 1>;
constexpr uint32_t UART_IDLE_EOF_EN_Pos = 19;
constexpr uint32_t UART_IDLE_EOF_EN_Msk = UART_IDLE_EOF_EN::mask;

/// Set this bit to enable to use packet_len in packet head when the received data is equal to
/// packet_len this means the end of a data frame. Position: 20, Width: 1 Access: read-write
using LEN_EOF_EN = BitField<20, 1>;
constexpr uint32_t LEN_EOF_EN_Pos = 20;
constexpr uint32_t LEN_EOF_EN_Msk = LEN_EOF_EN::mask;

/// Set this bit to enable crc calculation for data frame when bit6 in the head packet is 1.
/// Position: 21, Width: 1
/// Access: read-write
using ENCODE_CRC_EN = BitField<21, 1>;
constexpr uint32_t ENCODE_CRC_EN_Pos = 21;
constexpr uint32_t ENCODE_CRC_EN_Msk = ENCODE_CRC_EN::mask;

/// Set this bit to enable clock-gating for read or write registers.
/// Position: 22, Width: 1
/// Access: read-write
using CLK_EN = BitField<22, 1>;
constexpr uint32_t CLK_EN_Pos = 22;
constexpr uint32_t CLK_EN_Msk = CLK_EN::mask;

/// Set this bit to enable to use brk char as the end of a data frame.
/// Position: 23, Width: 1
/// Access: read-write
using UART_RX_BRK_EOF_EN = BitField<23, 1>;
constexpr uint32_t UART_RX_BRK_EOF_EN_Pos = 23;
constexpr uint32_t UART_RX_BRK_EOF_EN_Msk = UART_RX_BRK_EOF_EN::mask;

}  // namespace conf0

/// INT_RAW - INT_RAW
namespace int_raw {
/// when a separator char has been send it will produce uhci_rx_start_int interrupt.
/// Position: 0, Width: 1
/// Access: read-only
using RX_START_INT_RAW = BitField<0, 1>;
constexpr uint32_t RX_START_INT_RAW_Pos = 0;
constexpr uint32_t RX_START_INT_RAW_Msk = RX_START_INT_RAW::mask;

/// when DMA detects a separator char it will produce uhci_tx_start_int interrupt.
/// Position: 1, Width: 1
/// Access: read-only
using TX_START_INT_RAW = BitField<1, 1>;
constexpr uint32_t TX_START_INT_RAW_Pos = 1;
constexpr uint32_t TX_START_INT_RAW_Msk = TX_START_INT_RAW::mask;

/// when DMA takes a lot of time to receive a data it will produce uhci_rx_hung_int interrupt.
/// Position: 2, Width: 1
/// Access: read-only
using RX_HUNG_INT_RAW = BitField<2, 1>;
constexpr uint32_t RX_HUNG_INT_RAW_Pos = 2;
constexpr uint32_t RX_HUNG_INT_RAW_Msk = RX_HUNG_INT_RAW::mask;

/// when DMA takes a lot of time to read a data from RAM it will produce uhci_tx_hung_int interrupt.
/// Position: 3, Width: 1
/// Access: read-only
using TX_HUNG_INT_RAW = BitField<3, 1>;
constexpr uint32_t TX_HUNG_INT_RAW_Pos = 3;
constexpr uint32_t TX_HUNG_INT_RAW_Msk = TX_HUNG_INT_RAW::mask;

/// when a in link descriptor has been completed it will produce uhci_in_done_int interrupt.
/// Position: 4, Width: 1
/// Access: read-only
using IN_DONE_INT_RAW = BitField<4, 1>;
constexpr uint32_t IN_DONE_INT_RAW_Pos = 4;
constexpr uint32_t IN_DONE_INT_RAW_Msk = IN_DONE_INT_RAW::mask;

/// when a data packet has been received it will produce uhci_in_suc_eof_int interrupt.
/// Position: 5, Width: 1
/// Access: read-only
using IN_SUC_EOF_INT_RAW = BitField<5, 1>;
constexpr uint32_t IN_SUC_EOF_INT_RAW_Pos = 5;
constexpr uint32_t IN_SUC_EOF_INT_RAW_Msk = IN_SUC_EOF_INT_RAW::mask;

/// when there are some errors about eof in in link descriptor it will produce uhci_in_err_eof_int
/// interrupt. Position: 6, Width: 1 Access: read-only
using IN_ERR_EOF_INT_RAW = BitField<6, 1>;
constexpr uint32_t IN_ERR_EOF_INT_RAW_Pos = 6;
constexpr uint32_t IN_ERR_EOF_INT_RAW_Msk = IN_ERR_EOF_INT_RAW::mask;

/// when a out link descriptor is completed it will produce uhci_out_done_int interrupt.
/// Position: 7, Width: 1
/// Access: read-only
using OUT_DONE_INT_RAW = BitField<7, 1>;
constexpr uint32_t OUT_DONE_INT_RAW_Pos = 7;
constexpr uint32_t OUT_DONE_INT_RAW_Msk = OUT_DONE_INT_RAW::mask;

/// when the current descriptor's eof bit is 1 it will produce uhci_out_eof_int interrupt.
/// Position: 8, Width: 1
/// Access: read-only
using OUT_EOF_INT_RAW = BitField<8, 1>;
constexpr uint32_t OUT_EOF_INT_RAW_Pos = 8;
constexpr uint32_t OUT_EOF_INT_RAW_Msk = OUT_EOF_INT_RAW::mask;

/// when there are some errors about the out link descriptor it will produce uhci_in_dscr_err_int
/// interrupt. Position: 9, Width: 1 Access: read-only
using IN_DSCR_ERR_INT_RAW = BitField<9, 1>;
constexpr uint32_t IN_DSCR_ERR_INT_RAW_Pos = 9;
constexpr uint32_t IN_DSCR_ERR_INT_RAW_Msk = IN_DSCR_ERR_INT_RAW::mask;

/// when there are some errors about the in link descriptor it will produce uhci_out_dscr_err_int
/// interrupt. Position: 10, Width: 1 Access: read-only
using OUT_DSCR_ERR_INT_RAW = BitField<10, 1>;
constexpr uint32_t OUT_DSCR_ERR_INT_RAW_Pos = 10;
constexpr uint32_t OUT_DSCR_ERR_INT_RAW_Msk = OUT_DSCR_ERR_INT_RAW::mask;

/// when there are not enough in links for DMA it will produce uhci_in_dscr_err_int interrupt.
/// Position: 11, Width: 1
/// Access: read-only
using IN_DSCR_EMPTY_INT_RAW = BitField<11, 1>;
constexpr uint32_t IN_DSCR_EMPTY_INT_RAW_Pos = 11;
constexpr uint32_t IN_DSCR_EMPTY_INT_RAW_Msk = IN_DSCR_EMPTY_INT_RAW::mask;

/// when there are some errors about eof in outlink descriptor it will produce
/// uhci_outlink_eof_err_int interrupt. Position: 12, Width: 1 Access: read-only
using OUTLINK_EOF_ERR_INT_RAW = BitField<12, 1>;
constexpr uint32_t OUTLINK_EOF_ERR_INT_RAW_Pos = 12;
constexpr uint32_t OUTLINK_EOF_ERR_INT_RAW_Msk = OUTLINK_EOF_ERR_INT_RAW::mask;

/// When all data have been send it will produce uhci_out_total_eof_int interrupt.
/// Position: 13, Width: 1
/// Access: read-only
using OUT_TOTAL_EOF_INT_RAW = BitField<13, 1>;
constexpr uint32_t OUT_TOTAL_EOF_INT_RAW_Pos = 13;
constexpr uint32_t OUT_TOTAL_EOF_INT_RAW_Msk = OUT_TOTAL_EOF_INT_RAW::mask;

/// When use single send registers to send a short packets it will produce this interrupt when dma
/// has send the short packet. Position: 14, Width: 1 Access: read-only
using SEND_S_Q_INT_RAW = BitField<14, 1>;
constexpr uint32_t SEND_S_Q_INT_RAW_Pos = 14;
constexpr uint32_t SEND_S_Q_INT_RAW_Msk = SEND_S_Q_INT_RAW::mask;

/// When use always_send registers to send a series of short packets it will produce this interrupt
/// when dma has send the short packet. Position: 15, Width: 1 Access: read-only
using SEND_A_Q_INT_RAW = BitField<15, 1>;
constexpr uint32_t SEND_A_Q_INT_RAW_Pos = 15;
constexpr uint32_t SEND_A_Q_INT_RAW_Msk = SEND_A_Q_INT_RAW::mask;

/// Position: 16, Width: 1
/// Access: read-only
using DMA_INFIFO_FULL_WM_INT_RAW = BitField<16, 1>;
constexpr uint32_t DMA_INFIFO_FULL_WM_INT_RAW_Pos = 16;
constexpr uint32_t DMA_INFIFO_FULL_WM_INT_RAW_Msk = DMA_INFIFO_FULL_WM_INT_RAW::mask;

}  // namespace int_raw

/// INT_ST - INT_ST
namespace int_st {
/// Position: 0, Width: 1
/// Access: read-only
using RX_START_INT_ST = BitField<0, 1>;
constexpr uint32_t RX_START_INT_ST_Pos = 0;
constexpr uint32_t RX_START_INT_ST_Msk = RX_START_INT_ST::mask;

/// Position: 1, Width: 1
/// Access: read-only
using TX_START_INT_ST = BitField<1, 1>;
constexpr uint32_t TX_START_INT_ST_Pos = 1;
constexpr uint32_t TX_START_INT_ST_Msk = TX_START_INT_ST::mask;

/// Position: 2, Width: 1
/// Access: read-only
using RX_HUNG_INT_ST = BitField<2, 1>;
constexpr uint32_t RX_HUNG_INT_ST_Pos = 2;
constexpr uint32_t RX_HUNG_INT_ST_Msk = RX_HUNG_INT_ST::mask;

/// Position: 3, Width: 1
/// Access: read-only
using TX_HUNG_INT_ST = BitField<3, 1>;
constexpr uint32_t TX_HUNG_INT_ST_Pos = 3;
constexpr uint32_t TX_HUNG_INT_ST_Msk = TX_HUNG_INT_ST::mask;

/// Position: 4, Width: 1
/// Access: read-only
using IN_DONE_INT_ST = BitField<4, 1>;
constexpr uint32_t IN_DONE_INT_ST_Pos = 4;
constexpr uint32_t IN_DONE_INT_ST_Msk = IN_DONE_INT_ST::mask;

/// Position: 5, Width: 1
/// Access: read-only
using IN_SUC_EOF_INT_ST = BitField<5, 1>;
constexpr uint32_t IN_SUC_EOF_INT_ST_Pos = 5;
constexpr uint32_t IN_SUC_EOF_INT_ST_Msk = IN_SUC_EOF_INT_ST::mask;

/// Position: 6, Width: 1
/// Access: read-only
using IN_ERR_EOF_INT_ST = BitField<6, 1>;
constexpr uint32_t IN_ERR_EOF_INT_ST_Pos = 6;
constexpr uint32_t IN_ERR_EOF_INT_ST_Msk = IN_ERR_EOF_INT_ST::mask;

/// Position: 7, Width: 1
/// Access: read-only
using OUT_DONE_INT_ST = BitField<7, 1>;
constexpr uint32_t OUT_DONE_INT_ST_Pos = 7;
constexpr uint32_t OUT_DONE_INT_ST_Msk = OUT_DONE_INT_ST::mask;

/// Position: 8, Width: 1
/// Access: read-only
using OUT_EOF_INT_ST = BitField<8, 1>;
constexpr uint32_t OUT_EOF_INT_ST_Pos = 8;
constexpr uint32_t OUT_EOF_INT_ST_Msk = OUT_EOF_INT_ST::mask;

/// Position: 9, Width: 1
/// Access: read-only
using IN_DSCR_ERR_INT_ST = BitField<9, 1>;
constexpr uint32_t IN_DSCR_ERR_INT_ST_Pos = 9;
constexpr uint32_t IN_DSCR_ERR_INT_ST_Msk = IN_DSCR_ERR_INT_ST::mask;

/// Position: 10, Width: 1
/// Access: read-only
using OUT_DSCR_ERR_INT_ST = BitField<10, 1>;
constexpr uint32_t OUT_DSCR_ERR_INT_ST_Pos = 10;
constexpr uint32_t OUT_DSCR_ERR_INT_ST_Msk = OUT_DSCR_ERR_INT_ST::mask;

/// Position: 11, Width: 1
/// Access: read-only
using IN_DSCR_EMPTY_INT_ST = BitField<11, 1>;
constexpr uint32_t IN_DSCR_EMPTY_INT_ST_Pos = 11;
constexpr uint32_t IN_DSCR_EMPTY_INT_ST_Msk = IN_DSCR_EMPTY_INT_ST::mask;

/// Position: 12, Width: 1
/// Access: read-only
using OUTLINK_EOF_ERR_INT_ST = BitField<12, 1>;
constexpr uint32_t OUTLINK_EOF_ERR_INT_ST_Pos = 12;
constexpr uint32_t OUTLINK_EOF_ERR_INT_ST_Msk = OUTLINK_EOF_ERR_INT_ST::mask;

/// Position: 13, Width: 1
/// Access: read-only
using OUT_TOTAL_EOF_INT_ST = BitField<13, 1>;
constexpr uint32_t OUT_TOTAL_EOF_INT_ST_Pos = 13;
constexpr uint32_t OUT_TOTAL_EOF_INT_ST_Msk = OUT_TOTAL_EOF_INT_ST::mask;

/// Position: 14, Width: 1
/// Access: read-only
using SEND_S_Q_INT_ST = BitField<14, 1>;
constexpr uint32_t SEND_S_Q_INT_ST_Pos = 14;
constexpr uint32_t SEND_S_Q_INT_ST_Msk = SEND_S_Q_INT_ST::mask;

/// Position: 15, Width: 1
/// Access: read-only
using SEND_A_Q_INT_ST = BitField<15, 1>;
constexpr uint32_t SEND_A_Q_INT_ST_Pos = 15;
constexpr uint32_t SEND_A_Q_INT_ST_Msk = SEND_A_Q_INT_ST::mask;

/// Position: 16, Width: 1
/// Access: read-only
using DMA_INFIFO_FULL_WM_INT_ST = BitField<16, 1>;
constexpr uint32_t DMA_INFIFO_FULL_WM_INT_ST_Pos = 16;
constexpr uint32_t DMA_INFIFO_FULL_WM_INT_ST_Msk = DMA_INFIFO_FULL_WM_INT_ST::mask;

}  // namespace int_st

/// INT_ENA - INT_ENA
namespace int_ena {
/// Position: 0, Width: 1
/// Access: read-write
using RX_START_INT_ENA = BitField<0, 1>;
constexpr uint32_t RX_START_INT_ENA_Pos = 0;
constexpr uint32_t RX_START_INT_ENA_Msk = RX_START_INT_ENA::mask;

/// Position: 1, Width: 1
/// Access: read-write
using TX_START_INT_ENA = BitField<1, 1>;
constexpr uint32_t TX_START_INT_ENA_Pos = 1;
constexpr uint32_t TX_START_INT_ENA_Msk = TX_START_INT_ENA::mask;

/// Position: 2, Width: 1
/// Access: read-write
using RX_HUNG_INT_ENA = BitField<2, 1>;
constexpr uint32_t RX_HUNG_INT_ENA_Pos = 2;
constexpr uint32_t RX_HUNG_INT_ENA_Msk = RX_HUNG_INT_ENA::mask;

/// Position: 3, Width: 1
/// Access: read-write
using TX_HUNG_INT_ENA = BitField<3, 1>;
constexpr uint32_t TX_HUNG_INT_ENA_Pos = 3;
constexpr uint32_t TX_HUNG_INT_ENA_Msk = TX_HUNG_INT_ENA::mask;

/// Position: 4, Width: 1
/// Access: read-write
using IN_DONE_INT_ENA = BitField<4, 1>;
constexpr uint32_t IN_DONE_INT_ENA_Pos = 4;
constexpr uint32_t IN_DONE_INT_ENA_Msk = IN_DONE_INT_ENA::mask;

/// Position: 5, Width: 1
/// Access: read-write
using IN_SUC_EOF_INT_ENA = BitField<5, 1>;
constexpr uint32_t IN_SUC_EOF_INT_ENA_Pos = 5;
constexpr uint32_t IN_SUC_EOF_INT_ENA_Msk = IN_SUC_EOF_INT_ENA::mask;

/// Position: 6, Width: 1
/// Access: read-write
using IN_ERR_EOF_INT_ENA = BitField<6, 1>;
constexpr uint32_t IN_ERR_EOF_INT_ENA_Pos = 6;
constexpr uint32_t IN_ERR_EOF_INT_ENA_Msk = IN_ERR_EOF_INT_ENA::mask;

/// Position: 7, Width: 1
/// Access: read-write
using OUT_DONE_INT_ENA = BitField<7, 1>;
constexpr uint32_t OUT_DONE_INT_ENA_Pos = 7;
constexpr uint32_t OUT_DONE_INT_ENA_Msk = OUT_DONE_INT_ENA::mask;

/// Position: 8, Width: 1
/// Access: read-write
using OUT_EOF_INT_ENA = BitField<8, 1>;
constexpr uint32_t OUT_EOF_INT_ENA_Pos = 8;
constexpr uint32_t OUT_EOF_INT_ENA_Msk = OUT_EOF_INT_ENA::mask;

/// Position: 9, Width: 1
/// Access: read-write
using IN_DSCR_ERR_INT_ENA = BitField<9, 1>;
constexpr uint32_t IN_DSCR_ERR_INT_ENA_Pos = 9;
constexpr uint32_t IN_DSCR_ERR_INT_ENA_Msk = IN_DSCR_ERR_INT_ENA::mask;

/// Position: 10, Width: 1
/// Access: read-write
using OUT_DSCR_ERR_INT_ENA = BitField<10, 1>;
constexpr uint32_t OUT_DSCR_ERR_INT_ENA_Pos = 10;
constexpr uint32_t OUT_DSCR_ERR_INT_ENA_Msk = OUT_DSCR_ERR_INT_ENA::mask;

/// Position: 11, Width: 1
/// Access: read-write
using IN_DSCR_EMPTY_INT_ENA = BitField<11, 1>;
constexpr uint32_t IN_DSCR_EMPTY_INT_ENA_Pos = 11;
constexpr uint32_t IN_DSCR_EMPTY_INT_ENA_Msk = IN_DSCR_EMPTY_INT_ENA::mask;

/// Position: 12, Width: 1
/// Access: read-write
using OUTLINK_EOF_ERR_INT_ENA = BitField<12, 1>;
constexpr uint32_t OUTLINK_EOF_ERR_INT_ENA_Pos = 12;
constexpr uint32_t OUTLINK_EOF_ERR_INT_ENA_Msk = OUTLINK_EOF_ERR_INT_ENA::mask;

/// Position: 13, Width: 1
/// Access: read-write
using OUT_TOTAL_EOF_INT_ENA = BitField<13, 1>;
constexpr uint32_t OUT_TOTAL_EOF_INT_ENA_Pos = 13;
constexpr uint32_t OUT_TOTAL_EOF_INT_ENA_Msk = OUT_TOTAL_EOF_INT_ENA::mask;

/// Position: 14, Width: 1
/// Access: read-write
using SEND_S_Q_INT_ENA = BitField<14, 1>;
constexpr uint32_t SEND_S_Q_INT_ENA_Pos = 14;
constexpr uint32_t SEND_S_Q_INT_ENA_Msk = SEND_S_Q_INT_ENA::mask;

/// Position: 15, Width: 1
/// Access: read-write
using SEND_A_Q_INT_ENA = BitField<15, 1>;
constexpr uint32_t SEND_A_Q_INT_ENA_Pos = 15;
constexpr uint32_t SEND_A_Q_INT_ENA_Msk = SEND_A_Q_INT_ENA::mask;

/// Position: 16, Width: 1
/// Access: read-write
using DMA_INFIFO_FULL_WM_INT_ENA = BitField<16, 1>;
constexpr uint32_t DMA_INFIFO_FULL_WM_INT_ENA_Pos = 16;
constexpr uint32_t DMA_INFIFO_FULL_WM_INT_ENA_Msk = DMA_INFIFO_FULL_WM_INT_ENA::mask;

}  // namespace int_ena

/// INT_CLR - INT_CLR
namespace int_clr {
/// Position: 0, Width: 1
/// Access: write-only
using RX_START_INT_CLR = BitField<0, 1>;
constexpr uint32_t RX_START_INT_CLR_Pos = 0;
constexpr uint32_t RX_START_INT_CLR_Msk = RX_START_INT_CLR::mask;

/// Position: 1, Width: 1
/// Access: write-only
using TX_START_INT_CLR = BitField<1, 1>;
constexpr uint32_t TX_START_INT_CLR_Pos = 1;
constexpr uint32_t TX_START_INT_CLR_Msk = TX_START_INT_CLR::mask;

/// Position: 2, Width: 1
/// Access: write-only
using RX_HUNG_INT_CLR = BitField<2, 1>;
constexpr uint32_t RX_HUNG_INT_CLR_Pos = 2;
constexpr uint32_t RX_HUNG_INT_CLR_Msk = RX_HUNG_INT_CLR::mask;

/// Position: 3, Width: 1
/// Access: write-only
using TX_HUNG_INT_CLR = BitField<3, 1>;
constexpr uint32_t TX_HUNG_INT_CLR_Pos = 3;
constexpr uint32_t TX_HUNG_INT_CLR_Msk = TX_HUNG_INT_CLR::mask;

/// Position: 4, Width: 1
/// Access: write-only
using IN_DONE_INT_CLR = BitField<4, 1>;
constexpr uint32_t IN_DONE_INT_CLR_Pos = 4;
constexpr uint32_t IN_DONE_INT_CLR_Msk = IN_DONE_INT_CLR::mask;

/// Position: 5, Width: 1
/// Access: write-only
using IN_SUC_EOF_INT_CLR = BitField<5, 1>;
constexpr uint32_t IN_SUC_EOF_INT_CLR_Pos = 5;
constexpr uint32_t IN_SUC_EOF_INT_CLR_Msk = IN_SUC_EOF_INT_CLR::mask;

/// Position: 6, Width: 1
/// Access: write-only
using IN_ERR_EOF_INT_CLR = BitField<6, 1>;
constexpr uint32_t IN_ERR_EOF_INT_CLR_Pos = 6;
constexpr uint32_t IN_ERR_EOF_INT_CLR_Msk = IN_ERR_EOF_INT_CLR::mask;

/// Position: 7, Width: 1
/// Access: write-only
using OUT_DONE_INT_CLR = BitField<7, 1>;
constexpr uint32_t OUT_DONE_INT_CLR_Pos = 7;
constexpr uint32_t OUT_DONE_INT_CLR_Msk = OUT_DONE_INT_CLR::mask;

/// Position: 8, Width: 1
/// Access: write-only
using OUT_EOF_INT_CLR = BitField<8, 1>;
constexpr uint32_t OUT_EOF_INT_CLR_Pos = 8;
constexpr uint32_t OUT_EOF_INT_CLR_Msk = OUT_EOF_INT_CLR::mask;

/// Position: 9, Width: 1
/// Access: write-only
using IN_DSCR_ERR_INT_CLR = BitField<9, 1>;
constexpr uint32_t IN_DSCR_ERR_INT_CLR_Pos = 9;
constexpr uint32_t IN_DSCR_ERR_INT_CLR_Msk = IN_DSCR_ERR_INT_CLR::mask;

/// Position: 10, Width: 1
/// Access: write-only
using OUT_DSCR_ERR_INT_CLR = BitField<10, 1>;
constexpr uint32_t OUT_DSCR_ERR_INT_CLR_Pos = 10;
constexpr uint32_t OUT_DSCR_ERR_INT_CLR_Msk = OUT_DSCR_ERR_INT_CLR::mask;

/// Position: 11, Width: 1
/// Access: write-only
using IN_DSCR_EMPTY_INT_CLR = BitField<11, 1>;
constexpr uint32_t IN_DSCR_EMPTY_INT_CLR_Pos = 11;
constexpr uint32_t IN_DSCR_EMPTY_INT_CLR_Msk = IN_DSCR_EMPTY_INT_CLR::mask;

/// Position: 12, Width: 1
/// Access: write-only
using OUTLINK_EOF_ERR_INT_CLR = BitField<12, 1>;
constexpr uint32_t OUTLINK_EOF_ERR_INT_CLR_Pos = 12;
constexpr uint32_t OUTLINK_EOF_ERR_INT_CLR_Msk = OUTLINK_EOF_ERR_INT_CLR::mask;

/// Position: 13, Width: 1
/// Access: write-only
using OUT_TOTAL_EOF_INT_CLR = BitField<13, 1>;
constexpr uint32_t OUT_TOTAL_EOF_INT_CLR_Pos = 13;
constexpr uint32_t OUT_TOTAL_EOF_INT_CLR_Msk = OUT_TOTAL_EOF_INT_CLR::mask;

/// Position: 14, Width: 1
/// Access: write-only
using SEND_S_Q_INT_CLR = BitField<14, 1>;
constexpr uint32_t SEND_S_Q_INT_CLR_Pos = 14;
constexpr uint32_t SEND_S_Q_INT_CLR_Msk = SEND_S_Q_INT_CLR::mask;

/// Position: 15, Width: 1
/// Access: write-only
using SEND_A_Q_INT_CLR = BitField<15, 1>;
constexpr uint32_t SEND_A_Q_INT_CLR_Pos = 15;
constexpr uint32_t SEND_A_Q_INT_CLR_Msk = SEND_A_Q_INT_CLR::mask;

/// Position: 16, Width: 1
/// Access: write-only
using DMA_INFIFO_FULL_WM_INT_CLR = BitField<16, 1>;
constexpr uint32_t DMA_INFIFO_FULL_WM_INT_CLR_Pos = 16;
constexpr uint32_t DMA_INFIFO_FULL_WM_INT_CLR_Msk = DMA_INFIFO_FULL_WM_INT_CLR::mask;

}  // namespace int_clr

/// DMA_OUT_STATUS - DMA_OUT_STATUS
namespace dma_out_status {
/// 1:DMA out link descriptor's fifo is full.
/// Position: 0, Width: 1
/// Access: read-only
using OUT_FULL = BitField<0, 1>;
constexpr uint32_t OUT_FULL_Pos = 0;
constexpr uint32_t OUT_FULL_Msk = OUT_FULL::mask;

/// 1:DMA in link descriptor's fifo is empty.
/// Position: 1, Width: 1
/// Access: read-only
using OUT_EMPTY = BitField<1, 1>;
constexpr uint32_t OUT_EMPTY_Pos = 1;
constexpr uint32_t OUT_EMPTY_Msk = OUT_EMPTY::mask;

}  // namespace dma_out_status

/// DMA_OUT_PUSH - DMA_OUT_PUSH
namespace dma_out_push {
/// This is the data need to be pushed into out link descriptor's fifo.
/// Position: 0, Width: 9
/// Access: read-write
using OUTFIFO_WDATA = BitField<0, 9>;
constexpr uint32_t OUTFIFO_WDATA_Pos = 0;
constexpr uint32_t OUTFIFO_WDATA_Msk = OUTFIFO_WDATA::mask;

/// Set this bit to push data in out link descriptor's fifo.
/// Position: 16, Width: 1
/// Access: read-write
using OUTFIFO_PUSH = BitField<16, 1>;
constexpr uint32_t OUTFIFO_PUSH_Pos = 16;
constexpr uint32_t OUTFIFO_PUSH_Msk = OUTFIFO_PUSH::mask;

}  // namespace dma_out_push

/// DMA_IN_STATUS - DMA_IN_STATUS
namespace dma_in_status {
/// Position: 0, Width: 1
/// Access: read-only
using IN_FULL = BitField<0, 1>;
constexpr uint32_t IN_FULL_Pos = 0;
constexpr uint32_t IN_FULL_Msk = IN_FULL::mask;

/// Position: 1, Width: 1
/// Access: read-only
using IN_EMPTY = BitField<1, 1>;
constexpr uint32_t IN_EMPTY_Pos = 1;
constexpr uint32_t IN_EMPTY_Msk = IN_EMPTY::mask;

/// This register stores the errors caused in out link descriptor's data packet.
/// Position: 4, Width: 3
/// Access: read-only
using RX_ERR_CAUSE = BitField<4, 3>;
constexpr uint32_t RX_ERR_CAUSE_Pos = 4;
constexpr uint32_t RX_ERR_CAUSE_Msk = RX_ERR_CAUSE::mask;

}  // namespace dma_in_status

/// DMA_IN_POP - DMA_IN_POP
namespace dma_in_pop {
/// This register stores the data pop from in link descriptor's fifo.
/// Position: 0, Width: 12
/// Access: read-only
using INFIFO_RDATA = BitField<0, 12>;
constexpr uint32_t INFIFO_RDATA_Pos = 0;
constexpr uint32_t INFIFO_RDATA_Msk = INFIFO_RDATA::mask;

/// Set this bit to pop data in in link descriptor's fifo.
/// Position: 16, Width: 1
/// Access: read-write
using INFIFO_POP = BitField<16, 1>;
constexpr uint32_t INFIFO_POP_Pos = 16;
constexpr uint32_t INFIFO_POP_Msk = INFIFO_POP::mask;

}  // namespace dma_in_pop

/// DMA_OUT_LINK - DMA_OUT_LINK
namespace dma_out_link {
/// This register stores the least 20 bits of the first out link descriptor's address.
/// Position: 0, Width: 20
/// Access: read-write
using OUTLINK_ADDR = BitField<0, 20>;
constexpr uint32_t OUTLINK_ADDR_Pos = 0;
constexpr uint32_t OUTLINK_ADDR_Msk = OUTLINK_ADDR::mask;

/// Set this bit to stop dealing with the out link descriptors.
/// Position: 28, Width: 1
/// Access: read-write
using OUTLINK_STOP = BitField<28, 1>;
constexpr uint32_t OUTLINK_STOP_Pos = 28;
constexpr uint32_t OUTLINK_STOP_Msk = OUTLINK_STOP::mask;

/// Set this bit to start dealing with the out link descriptors.
/// Position: 29, Width: 1
/// Access: read-write
using OUTLINK_START = BitField<29, 1>;
constexpr uint32_t OUTLINK_START_Pos = 29;
constexpr uint32_t OUTLINK_START_Msk = OUTLINK_START::mask;

/// Set this bit to mount on new out link descriptors
/// Position: 30, Width: 1
/// Access: read-write
using OUTLINK_RESTART = BitField<30, 1>;
constexpr uint32_t OUTLINK_RESTART_Pos = 30;
constexpr uint32_t OUTLINK_RESTART_Msk = OUTLINK_RESTART::mask;

/// 1ยฃยบ the out link descriptor's fsm is in idle state. 0:the out link descriptor's fsm is working.
/// Position: 31, Width: 1
/// Access: read-only
using OUTLINK_PARK = BitField<31, 1>;
constexpr uint32_t OUTLINK_PARK_Pos = 31;
constexpr uint32_t OUTLINK_PARK_Msk = OUTLINK_PARK::mask;

}  // namespace dma_out_link

/// DMA_IN_LINK - DMA_IN_LINK
namespace dma_in_link {
/// This register stores the least 20 bits of the first in link descriptor's address.
/// Position: 0, Width: 20
/// Access: read-write
using INLINK_ADDR = BitField<0, 20>;
constexpr uint32_t INLINK_ADDR_Pos = 0;
constexpr uint32_t INLINK_ADDR_Msk = INLINK_ADDR::mask;

/// 1:when a packet is wrong in link descriptor returns to the descriptor which is lately used.
/// Position: 20, Width: 1
/// Access: read-write
using INLINK_AUTO_RET = BitField<20, 1>;
constexpr uint32_t INLINK_AUTO_RET_Pos = 20;
constexpr uint32_t INLINK_AUTO_RET_Msk = INLINK_AUTO_RET::mask;

/// Set this bit to stop dealing with the in link descriptors.
/// Position: 28, Width: 1
/// Access: read-write
using INLINK_STOP = BitField<28, 1>;
constexpr uint32_t INLINK_STOP_Pos = 28;
constexpr uint32_t INLINK_STOP_Msk = INLINK_STOP::mask;

/// Set this bit to start dealing with the in link descriptors.
/// Position: 29, Width: 1
/// Access: read-write
using INLINK_START = BitField<29, 1>;
constexpr uint32_t INLINK_START_Pos = 29;
constexpr uint32_t INLINK_START_Msk = INLINK_START::mask;

/// Set this bit to mount on new in link descriptors
/// Position: 30, Width: 1
/// Access: read-write
using INLINK_RESTART = BitField<30, 1>;
constexpr uint32_t INLINK_RESTART_Pos = 30;
constexpr uint32_t INLINK_RESTART_Msk = INLINK_RESTART::mask;

/// 1:the in link descriptor's fsm is in idle state. 0:the in link descriptor's fsm is working
/// Position: 31, Width: 1
/// Access: read-only
using INLINK_PARK = BitField<31, 1>;
constexpr uint32_t INLINK_PARK_Pos = 31;
constexpr uint32_t INLINK_PARK_Msk = INLINK_PARK::mask;

}  // namespace dma_in_link

/// CONF1 - CONF1
namespace conf1 {
/// Set this bit to enable decoder to check check_sum in packet header.
/// Position: 0, Width: 1
/// Access: read-write
using CHECK_SUM_EN = BitField<0, 1>;
constexpr uint32_t CHECK_SUM_EN_Pos = 0;
constexpr uint32_t CHECK_SUM_EN_Msk = CHECK_SUM_EN::mask;

/// Set this bit to enable decoder to check seq num in packet header.
/// Position: 1, Width: 1
/// Access: read-write
using CHECK_SEQ_EN = BitField<1, 1>;
constexpr uint32_t CHECK_SEQ_EN_Pos = 1;
constexpr uint32_t CHECK_SEQ_EN_Msk = CHECK_SEQ_EN::mask;

/// Set this bit to disable crc calculation.
/// Position: 2, Width: 1
/// Access: read-write
using CRC_DISABLE = BitField<2, 1>;
constexpr uint32_t CRC_DISABLE_Pos = 2;
constexpr uint32_t CRC_DISABLE_Msk = CRC_DISABLE::mask;

/// Set this bit to save packet header .
/// Position: 3, Width: 1
/// Access: read-write
using SAVE_HEAD = BitField<3, 1>;
constexpr uint32_t SAVE_HEAD_Pos = 3;
constexpr uint32_t SAVE_HEAD_Msk = SAVE_HEAD::mask;

/// Set this bit to enable hardware replace check_sum in packet header automatically.
/// Position: 4, Width: 1
/// Access: read-write
using TX_CHECK_SUM_RE = BitField<4, 1>;
constexpr uint32_t TX_CHECK_SUM_RE_Pos = 4;
constexpr uint32_t TX_CHECK_SUM_RE_Msk = TX_CHECK_SUM_RE::mask;

/// Set this bit to enable hardware replace ack num in packet header automatically.
/// Position: 5, Width: 1
/// Access: read-write
using TX_ACK_NUM_RE = BitField<5, 1>;
constexpr uint32_t TX_ACK_NUM_RE_Pos = 5;
constexpr uint32_t TX_ACK_NUM_RE_Msk = TX_ACK_NUM_RE::mask;

/// Set this bit to check the owner bit in link descriptor.
/// Position: 6, Width: 1
/// Access: read-write
using CHECK_OWNER = BitField<6, 1>;
constexpr uint32_t CHECK_OWNER_Pos = 6;
constexpr uint32_t CHECK_OWNER_Msk = CHECK_OWNER::mask;

/// Set this bit to enable software way to add packet header.
/// Position: 7, Width: 1
/// Access: read-write
using WAIT_SW_START = BitField<7, 1>;
constexpr uint32_t WAIT_SW_START_Pos = 7;
constexpr uint32_t WAIT_SW_START_Msk = WAIT_SW_START::mask;

/// Set this bit to start inserting the packet header.
/// Position: 8, Width: 1
/// Access: read-write
using SW_START = BitField<8, 1>;
constexpr uint32_t SW_START_Pos = 8;
constexpr uint32_t SW_START_Msk = SW_START::mask;

/// when data amount in link descriptor's fifo is more than this register value it will produce
/// uhci_dma_infifo_full_wm_int interrupt. Position: 9, Width: 12 Access: read-write
using DMA_INFIFO_FULL_THRS = BitField<9, 12>;
constexpr uint32_t DMA_INFIFO_FULL_THRS_Pos = 9;
constexpr uint32_t DMA_INFIFO_FULL_THRS_Msk = DMA_INFIFO_FULL_THRS::mask;

}  // namespace conf1

/// STATE0 - STATE0
namespace state0 {
/// Position: 0, Width: 32
/// Access: read-only
using STATE0 = BitField<0, 32>;
constexpr uint32_t STATE0_Pos = 0;
constexpr uint32_t STATE0_Msk = STATE0::mask;

}  // namespace state0

/// STATE1 - STATE1
namespace state1 {
/// Position: 0, Width: 32
/// Access: read-only
using STATE1 = BitField<0, 32>;
constexpr uint32_t STATE1_Pos = 0;
constexpr uint32_t STATE1_Msk = STATE1::mask;

}  // namespace state1

/// DMA_OUT_EOF_DES_ADDR - DMA_OUT_EOF_DES_ADDR
namespace dma_out_eof_des_addr {
/// This register stores the address of out link descriptoir when eof bit in this descriptor is 1.
/// Position: 0, Width: 32
/// Access: read-only
using OUT_EOF_DES_ADDR = BitField<0, 32>;
constexpr uint32_t OUT_EOF_DES_ADDR_Pos = 0;
constexpr uint32_t OUT_EOF_DES_ADDR_Msk = OUT_EOF_DES_ADDR::mask;

}  // namespace dma_out_eof_des_addr

/// DMA_IN_SUC_EOF_DES_ADDR - DMA_IN_SUC_EOF_DES_ADDR
namespace dma_in_suc_eof_des_addr {
/// This register stores the address of in link descriptor when eof bit in this descriptor is 1.
/// Position: 0, Width: 32
/// Access: read-only
using IN_SUC_EOF_DES_ADDR = BitField<0, 32>;
constexpr uint32_t IN_SUC_EOF_DES_ADDR_Pos = 0;
constexpr uint32_t IN_SUC_EOF_DES_ADDR_Msk = IN_SUC_EOF_DES_ADDR::mask;

}  // namespace dma_in_suc_eof_des_addr

/// DMA_IN_ERR_EOF_DES_ADDR - DMA_IN_ERR_EOF_DES_ADDR
namespace dma_in_err_eof_des_addr {
/// This register stores the address of in link descriptor when there are some errors in this
/// descriptor. Position: 0, Width: 32 Access: read-only
using IN_ERR_EOF_DES_ADDR = BitField<0, 32>;
constexpr uint32_t IN_ERR_EOF_DES_ADDR_Pos = 0;
constexpr uint32_t IN_ERR_EOF_DES_ADDR_Msk = IN_ERR_EOF_DES_ADDR::mask;

}  // namespace dma_in_err_eof_des_addr

/// DMA_OUT_EOF_BFR_DES_ADDR - DMA_OUT_EOF_BFR_DES_ADDR
namespace dma_out_eof_bfr_des_addr {
/// This register stores the address of out link descriptor when there are some errors in this
/// descriptor. Position: 0, Width: 32 Access: read-only
using OUT_EOF_BFR_DES_ADDR = BitField<0, 32>;
constexpr uint32_t OUT_EOF_BFR_DES_ADDR_Pos = 0;
constexpr uint32_t OUT_EOF_BFR_DES_ADDR_Msk = OUT_EOF_BFR_DES_ADDR::mask;

}  // namespace dma_out_eof_bfr_des_addr

/// AHB_TEST - AHB_TEST
namespace ahb_test {
/// bit2 is ahb bus test enable ,bit1 is used to choose wrtie(1) or read(0) mode. bit0 is used to
/// choose test only once(1) or continue(0) Position: 0, Width: 3 Access: read-write
using AHB_TESTMODE = BitField<0, 3>;
constexpr uint32_t AHB_TESTMODE_Pos = 0;
constexpr uint32_t AHB_TESTMODE_Msk = AHB_TESTMODE::mask;

/// The two bits represent ahb bus address bit[20:19]
/// Position: 4, Width: 2
/// Access: read-write
using AHB_TESTADDR = BitField<4, 2>;
constexpr uint32_t AHB_TESTADDR_Pos = 4;
constexpr uint32_t AHB_TESTADDR_Msk = AHB_TESTADDR::mask;

}  // namespace ahb_test

/// DMA_IN_DSCR - DMA_IN_DSCR
namespace dma_in_dscr {
/// The content of current in link descriptor's third dword
/// Position: 0, Width: 32
/// Access: read-only
using INLINK_DSCR = BitField<0, 32>;
constexpr uint32_t INLINK_DSCR_Pos = 0;
constexpr uint32_t INLINK_DSCR_Msk = INLINK_DSCR::mask;

}  // namespace dma_in_dscr

/// DMA_IN_DSCR_BF0 - DMA_IN_DSCR_BF0
namespace dma_in_dscr_bf0 {
/// The content of current in link descriptor's first dword
/// Position: 0, Width: 32
/// Access: read-only
using INLINK_DSCR_BF0 = BitField<0, 32>;
constexpr uint32_t INLINK_DSCR_BF0_Pos = 0;
constexpr uint32_t INLINK_DSCR_BF0_Msk = INLINK_DSCR_BF0::mask;

}  // namespace dma_in_dscr_bf0

/// DMA_IN_DSCR_BF1 - DMA_IN_DSCR_BF1
namespace dma_in_dscr_bf1 {
/// The content of current in link descriptor's second dword
/// Position: 0, Width: 32
/// Access: read-only
using INLINK_DSCR_BF1 = BitField<0, 32>;
constexpr uint32_t INLINK_DSCR_BF1_Pos = 0;
constexpr uint32_t INLINK_DSCR_BF1_Msk = INLINK_DSCR_BF1::mask;

}  // namespace dma_in_dscr_bf1

/// DMA_OUT_DSCR - DMA_OUT_DSCR
namespace dma_out_dscr {
/// The content of current out link descriptor's third dword
/// Position: 0, Width: 32
/// Access: read-only
using OUTLINK_DSCR = BitField<0, 32>;
constexpr uint32_t OUTLINK_DSCR_Pos = 0;
constexpr uint32_t OUTLINK_DSCR_Msk = OUTLINK_DSCR::mask;

}  // namespace dma_out_dscr

/// DMA_OUT_DSCR_BF0 - DMA_OUT_DSCR_BF0
namespace dma_out_dscr_bf0 {
/// The content of current out link descriptor's first dword
/// Position: 0, Width: 32
/// Access: read-only
using OUTLINK_DSCR_BF0 = BitField<0, 32>;
constexpr uint32_t OUTLINK_DSCR_BF0_Pos = 0;
constexpr uint32_t OUTLINK_DSCR_BF0_Msk = OUTLINK_DSCR_BF0::mask;

}  // namespace dma_out_dscr_bf0

/// DMA_OUT_DSCR_BF1 - DMA_OUT_DSCR_BF1
namespace dma_out_dscr_bf1 {
/// The content of current out link descriptor's second dword
/// Position: 0, Width: 32
/// Access: read-only
using OUTLINK_DSCR_BF1 = BitField<0, 32>;
constexpr uint32_t OUTLINK_DSCR_BF1_Pos = 0;
constexpr uint32_t OUTLINK_DSCR_BF1_Msk = OUTLINK_DSCR_BF1::mask;

}  // namespace dma_out_dscr_bf1

/// ESCAPE_CONF - ESCAPE_CONF
namespace escape_conf {
/// Set this bit to enable 0xc0 char decode when DMA receives data.
/// Position: 0, Width: 1
/// Access: read-write
using TX_C0_ESC_EN = BitField<0, 1>;
constexpr uint32_t TX_C0_ESC_EN_Pos = 0;
constexpr uint32_t TX_C0_ESC_EN_Msk = TX_C0_ESC_EN::mask;

/// Set this bit to enable 0xdb char decode when DMA receives data.
/// Position: 1, Width: 1
/// Access: read-write
using TX_DB_ESC_EN = BitField<1, 1>;
constexpr uint32_t TX_DB_ESC_EN_Pos = 1;
constexpr uint32_t TX_DB_ESC_EN_Msk = TX_DB_ESC_EN::mask;

/// Set this bit to enable flow control char 0x11 decode when DMA receives data.
/// Position: 2, Width: 1
/// Access: read-write
using TX_11_ESC_EN = BitField<2, 1>;
constexpr uint32_t TX_11_ESC_EN_Pos = 2;
constexpr uint32_t TX_11_ESC_EN_Msk = TX_11_ESC_EN::mask;

/// Set this bit to enable flow control char 0x13 decode when DMA receives data.
/// Position: 3, Width: 1
/// Access: read-write
using TX_13_ESC_EN = BitField<3, 1>;
constexpr uint32_t TX_13_ESC_EN_Pos = 3;
constexpr uint32_t TX_13_ESC_EN_Msk = TX_13_ESC_EN::mask;

/// Set this bit to enable 0xc0 char replace when DMA sends data.
/// Position: 4, Width: 1
/// Access: read-write
using RX_C0_ESC_EN = BitField<4, 1>;
constexpr uint32_t RX_C0_ESC_EN_Pos = 4;
constexpr uint32_t RX_C0_ESC_EN_Msk = RX_C0_ESC_EN::mask;

/// Set this bit to enable 0xdb char replace when DMA sends data.
/// Position: 5, Width: 1
/// Access: read-write
using RX_DB_ESC_EN = BitField<5, 1>;
constexpr uint32_t RX_DB_ESC_EN_Pos = 5;
constexpr uint32_t RX_DB_ESC_EN_Msk = RX_DB_ESC_EN::mask;

/// Set this bit to enable flow control char 0x11 replace when DMA sends data.
/// Position: 6, Width: 1
/// Access: read-write
using RX_11_ESC_EN = BitField<6, 1>;
constexpr uint32_t RX_11_ESC_EN_Pos = 6;
constexpr uint32_t RX_11_ESC_EN_Msk = RX_11_ESC_EN::mask;

/// Set this bit to enable flow control char 0x13 replace when DMA sends data.
/// Position: 7, Width: 1
/// Access: read-write
using RX_13_ESC_EN = BitField<7, 1>;
constexpr uint32_t RX_13_ESC_EN_Pos = 7;
constexpr uint32_t RX_13_ESC_EN_Msk = RX_13_ESC_EN::mask;

}  // namespace escape_conf

/// HUNG_CONF - HUNG_CONF
namespace hung_conf {
/// This register stores the timeout value.when DMA takes more time than this register value to
/// receive a data it will produce uhci_tx_hung_int interrupt. Position: 0, Width: 8 Access:
/// read-write
using TXFIFO_TIMEOUT = BitField<0, 8>;
constexpr uint32_t TXFIFO_TIMEOUT_Pos = 0;
constexpr uint32_t TXFIFO_TIMEOUT_Msk = TXFIFO_TIMEOUT::mask;

/// The tick count is cleared when its value >=(17'd8000>>reg_txfifo_timeout_shift)
/// Position: 8, Width: 3
/// Access: read-write
using TXFIFO_TIMEOUT_SHIFT = BitField<8, 3>;
constexpr uint32_t TXFIFO_TIMEOUT_SHIFT_Pos = 8;
constexpr uint32_t TXFIFO_TIMEOUT_SHIFT_Msk = TXFIFO_TIMEOUT_SHIFT::mask;

/// The enable bit for txfifo receive data timeout
/// Position: 11, Width: 1
/// Access: read-write
using TXFIFO_TIMEOUT_ENA = BitField<11, 1>;
constexpr uint32_t TXFIFO_TIMEOUT_ENA_Pos = 11;
constexpr uint32_t TXFIFO_TIMEOUT_ENA_Msk = TXFIFO_TIMEOUT_ENA::mask;

/// This register stores the timeout value.when DMA takes more time than this register value to read
/// a data from RAM it will produce uhci_rx_hung_int interrupt. Position: 12, Width: 8 Access:
/// read-write
using RXFIFO_TIMEOUT = BitField<12, 8>;
constexpr uint32_t RXFIFO_TIMEOUT_Pos = 12;
constexpr uint32_t RXFIFO_TIMEOUT_Msk = RXFIFO_TIMEOUT::mask;

/// The tick count is cleared when its value >=(17'd8000>>reg_rxfifo_timeout_shift)
/// Position: 20, Width: 3
/// Access: read-write
using RXFIFO_TIMEOUT_SHIFT = BitField<20, 3>;
constexpr uint32_t RXFIFO_TIMEOUT_SHIFT_Pos = 20;
constexpr uint32_t RXFIFO_TIMEOUT_SHIFT_Msk = RXFIFO_TIMEOUT_SHIFT::mask;

/// This is the enable bit for DMA send data timeout
/// Position: 23, Width: 1
/// Access: read-write
using RXFIFO_TIMEOUT_ENA = BitField<23, 1>;
constexpr uint32_t RXFIFO_TIMEOUT_ENA_Pos = 23;
constexpr uint32_t RXFIFO_TIMEOUT_ENA_Msk = RXFIFO_TIMEOUT_ENA::mask;

}  // namespace hung_conf

/// RX_HEAD - RX_HEAD
namespace rx_head {
/// This register stores the packet header received by DMA
/// Position: 0, Width: 32
/// Access: read-only
using RX_HEAD = BitField<0, 32>;
constexpr uint32_t RX_HEAD_Pos = 0;
constexpr uint32_t RX_HEAD_Msk = RX_HEAD::mask;

}  // namespace rx_head

/// QUICK_SENT - QUICK_SENT
namespace quick_sent {
/// The bits are used to choose which short packet
/// Position: 0, Width: 3
/// Access: read-write
using SINGLE_SEND_NUM = BitField<0, 3>;
constexpr uint32_t SINGLE_SEND_NUM_Pos = 0;
constexpr uint32_t SINGLE_SEND_NUM_Msk = SINGLE_SEND_NUM::mask;

/// Set this bit to enable send a short packet
/// Position: 3, Width: 1
/// Access: read-write
using SINGLE_SEND_EN = BitField<3, 1>;
constexpr uint32_t SINGLE_SEND_EN_Pos = 3;
constexpr uint32_t SINGLE_SEND_EN_Msk = SINGLE_SEND_EN::mask;

/// The bits are used to choose which short packet
/// Position: 4, Width: 3
/// Access: read-write
using ALWAYS_SEND_NUM = BitField<4, 3>;
constexpr uint32_t ALWAYS_SEND_NUM_Pos = 4;
constexpr uint32_t ALWAYS_SEND_NUM_Msk = ALWAYS_SEND_NUM::mask;

/// Set this bit to enable continuously send the same short packet
/// Position: 7, Width: 1
/// Access: read-write
using ALWAYS_SEND_EN = BitField<7, 1>;
constexpr uint32_t ALWAYS_SEND_EN_Pos = 7;
constexpr uint32_t ALWAYS_SEND_EN_Msk = ALWAYS_SEND_EN::mask;

}  // namespace quick_sent

/// Q0_WORD0 - Q0_WORD0
namespace q0_word0 {
/// This register stores the content of short packet's first dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q0_WORD0 = BitField<0, 32>;
constexpr uint32_t SEND_Q0_WORD0_Pos = 0;
constexpr uint32_t SEND_Q0_WORD0_Msk = SEND_Q0_WORD0::mask;

}  // namespace q0_word0

/// Q0_WORD1 - Q0_WORD1
namespace q0_word1 {
/// This register stores the content of short packet's second dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q0_WORD1 = BitField<0, 32>;
constexpr uint32_t SEND_Q0_WORD1_Pos = 0;
constexpr uint32_t SEND_Q0_WORD1_Msk = SEND_Q0_WORD1::mask;

}  // namespace q0_word1

/// Q1_WORD0 - Q1_WORD0
namespace q1_word0 {
/// This register stores the content of short packet's first dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q1_WORD0 = BitField<0, 32>;
constexpr uint32_t SEND_Q1_WORD0_Pos = 0;
constexpr uint32_t SEND_Q1_WORD0_Msk = SEND_Q1_WORD0::mask;

}  // namespace q1_word0

/// Q1_WORD1 - Q1_WORD1
namespace q1_word1 {
/// This register stores the content of short packet's second dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q1_WORD1 = BitField<0, 32>;
constexpr uint32_t SEND_Q1_WORD1_Pos = 0;
constexpr uint32_t SEND_Q1_WORD1_Msk = SEND_Q1_WORD1::mask;

}  // namespace q1_word1

/// Q2_WORD0 - Q2_WORD0
namespace q2_word0 {
/// This register stores the content of short packet's first dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q2_WORD0 = BitField<0, 32>;
constexpr uint32_t SEND_Q2_WORD0_Pos = 0;
constexpr uint32_t SEND_Q2_WORD0_Msk = SEND_Q2_WORD0::mask;

}  // namespace q2_word0

/// Q2_WORD1 - Q2_WORD1
namespace q2_word1 {
/// This register stores the content of short packet's second dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q2_WORD1 = BitField<0, 32>;
constexpr uint32_t SEND_Q2_WORD1_Pos = 0;
constexpr uint32_t SEND_Q2_WORD1_Msk = SEND_Q2_WORD1::mask;

}  // namespace q2_word1

/// Q3_WORD0 - Q3_WORD0
namespace q3_word0 {
/// This register stores the content of short packet's first dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q3_WORD0 = BitField<0, 32>;
constexpr uint32_t SEND_Q3_WORD0_Pos = 0;
constexpr uint32_t SEND_Q3_WORD0_Msk = SEND_Q3_WORD0::mask;

}  // namespace q3_word0

/// Q3_WORD1 - Q3_WORD1
namespace q3_word1 {
/// This register stores the content of short packet's second dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q3_WORD1 = BitField<0, 32>;
constexpr uint32_t SEND_Q3_WORD1_Pos = 0;
constexpr uint32_t SEND_Q3_WORD1_Msk = SEND_Q3_WORD1::mask;

}  // namespace q3_word1

/// Q4_WORD0 - Q4_WORD0
namespace q4_word0 {
/// This register stores the content of short packet's first dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q4_WORD0 = BitField<0, 32>;
constexpr uint32_t SEND_Q4_WORD0_Pos = 0;
constexpr uint32_t SEND_Q4_WORD0_Msk = SEND_Q4_WORD0::mask;

}  // namespace q4_word0

/// Q4_WORD1 - Q4_WORD1
namespace q4_word1 {
/// This register stores the content of short packet's second dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q4_WORD1 = BitField<0, 32>;
constexpr uint32_t SEND_Q4_WORD1_Pos = 0;
constexpr uint32_t SEND_Q4_WORD1_Msk = SEND_Q4_WORD1::mask;

}  // namespace q4_word1

/// Q5_WORD0 - Q5_WORD0
namespace q5_word0 {
/// This register stores the content of short packet's first dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q5_WORD0 = BitField<0, 32>;
constexpr uint32_t SEND_Q5_WORD0_Pos = 0;
constexpr uint32_t SEND_Q5_WORD0_Msk = SEND_Q5_WORD0::mask;

}  // namespace q5_word0

/// Q5_WORD1 - Q5_WORD1
namespace q5_word1 {
/// This register stores the content of short packet's second dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q5_WORD1 = BitField<0, 32>;
constexpr uint32_t SEND_Q5_WORD1_Pos = 0;
constexpr uint32_t SEND_Q5_WORD1_Msk = SEND_Q5_WORD1::mask;

}  // namespace q5_word1

/// Q6_WORD0 - Q6_WORD0
namespace q6_word0 {
/// This register stores the content of short packet's first dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q6_WORD0 = BitField<0, 32>;
constexpr uint32_t SEND_Q6_WORD0_Pos = 0;
constexpr uint32_t SEND_Q6_WORD0_Msk = SEND_Q6_WORD0::mask;

}  // namespace q6_word0

/// Q6_WORD1 - Q6_WORD1
namespace q6_word1 {
/// This register stores the content of short packet's second dword
/// Position: 0, Width: 32
/// Access: read-write
using SEND_Q6_WORD1 = BitField<0, 32>;
constexpr uint32_t SEND_Q6_WORD1_Pos = 0;
constexpr uint32_t SEND_Q6_WORD1_Msk = SEND_Q6_WORD1::mask;

}  // namespace q6_word1

/// ESC_CONF0 - ESC_CONF0
namespace esc_conf0 {
/// This register stores the seperator char seperator char is used to seperate the data frame.
/// Position: 0, Width: 8
/// Access: read-write
using SEPER_CHAR = BitField<0, 8>;
constexpr uint32_t SEPER_CHAR_Pos = 0;
constexpr uint32_t SEPER_CHAR_Msk = SEPER_CHAR::mask;

/// This register stores thee first char used to replace seperator char in data.
/// Position: 8, Width: 8
/// Access: read-write
using SEPER_ESC_CHAR0 = BitField<8, 8>;
constexpr uint32_t SEPER_ESC_CHAR0_Pos = 8;
constexpr uint32_t SEPER_ESC_CHAR0_Msk = SEPER_ESC_CHAR0::mask;

/// This register stores the second char used to replace seperator char in data . 0xdc 0xdb replace
/// 0xc0 by default. Position: 16, Width: 8 Access: read-write
using SEPER_ESC_CHAR1 = BitField<16, 8>;
constexpr uint32_t SEPER_ESC_CHAR1_Pos = 16;
constexpr uint32_t SEPER_ESC_CHAR1_Msk = SEPER_ESC_CHAR1::mask;

}  // namespace esc_conf0

/// ESC_CONF1 - ESC_CONF1
namespace esc_conf1 {
/// This register stores the first substitute char used to replace the seperator char.
/// Position: 0, Width: 8
/// Access: read-write
using ESC_SEQ0 = BitField<0, 8>;
constexpr uint32_t ESC_SEQ0_Pos = 0;
constexpr uint32_t ESC_SEQ0_Msk = ESC_SEQ0::mask;

/// This register stores the first char used to replace reg_esc_seq0 in data.
/// Position: 8, Width: 8
/// Access: read-write
using ESC_SEQ0_CHAR0 = BitField<8, 8>;
constexpr uint32_t ESC_SEQ0_CHAR0_Pos = 8;
constexpr uint32_t ESC_SEQ0_CHAR0_Msk = ESC_SEQ0_CHAR0::mask;

/// This register stores the second char used to replace the reg_esc_seq0 in data
/// Position: 16, Width: 8
/// Access: read-write
using ESC_SEQ0_CHAR1 = BitField<16, 8>;
constexpr uint32_t ESC_SEQ0_CHAR1_Pos = 16;
constexpr uint32_t ESC_SEQ0_CHAR1_Msk = ESC_SEQ0_CHAR1::mask;

}  // namespace esc_conf1

/// ESC_CONF2 - ESC_CONF2
namespace esc_conf2 {
/// This register stores the flow control char to turn on the flow_control
/// Position: 0, Width: 8
/// Access: read-write
using ESC_SEQ1 = BitField<0, 8>;
constexpr uint32_t ESC_SEQ1_Pos = 0;
constexpr uint32_t ESC_SEQ1_Msk = ESC_SEQ1::mask;

/// This register stores the first char used to replace the reg_esc_seq1 in data.
/// Position: 8, Width: 8
/// Access: read-write
using ESC_SEQ1_CHAR0 = BitField<8, 8>;
constexpr uint32_t ESC_SEQ1_CHAR0_Pos = 8;
constexpr uint32_t ESC_SEQ1_CHAR0_Msk = ESC_SEQ1_CHAR0::mask;

/// This register stores the second char used to replace the reg_esc_seq1 in data.
/// Position: 16, Width: 8
/// Access: read-write
using ESC_SEQ1_CHAR1 = BitField<16, 8>;
constexpr uint32_t ESC_SEQ1_CHAR1_Pos = 16;
constexpr uint32_t ESC_SEQ1_CHAR1_Msk = ESC_SEQ1_CHAR1::mask;

}  // namespace esc_conf2

/// ESC_CONF3 - ESC_CONF3
namespace esc_conf3 {
/// This register stores the flow_control char to turn off the flow_control
/// Position: 0, Width: 8
/// Access: read-write
using ESC_SEQ2 = BitField<0, 8>;
constexpr uint32_t ESC_SEQ2_Pos = 0;
constexpr uint32_t ESC_SEQ2_Msk = ESC_SEQ2::mask;

/// This register stores the first char used to replace the reg_esc_seq2 in data.
/// Position: 8, Width: 8
/// Access: read-write
using ESC_SEQ2_CHAR0 = BitField<8, 8>;
constexpr uint32_t ESC_SEQ2_CHAR0_Pos = 8;
constexpr uint32_t ESC_SEQ2_CHAR0_Msk = ESC_SEQ2_CHAR0::mask;

/// This register stores the second char used to replace the reg_esc_seq2 in data.
/// Position: 16, Width: 8
/// Access: read-write
using ESC_SEQ2_CHAR1 = BitField<16, 8>;
constexpr uint32_t ESC_SEQ2_CHAR1_Pos = 16;
constexpr uint32_t ESC_SEQ2_CHAR1_Msk = ESC_SEQ2_CHAR1::mask;

}  // namespace esc_conf3

/// PKT_THRES - PKT_THRES
namespace pkt_thres {
/// when the amount of packet payload is greater than this value the process of receiving data is
/// done. Position: 0, Width: 13 Access: read-write
using PKT_THRS = BitField<0, 13>;
constexpr uint32_t PKT_THRS_Pos = 0;
constexpr uint32_t PKT_THRS_Msk = PKT_THRS::mask;

}  // namespace pkt_thres

/// DATE - DATE
namespace date {
/// version information
/// Position: 0, Width: 32
/// Access: read-write
using DATE = BitField<0, 32>;
constexpr uint32_t DATE_Pos = 0;
constexpr uint32_t DATE_Msk = DATE::mask;

}  // namespace date

}  // namespace alloy::hal::espressif::esp32::uhci0
