/// Auto-generated register definitions for GPIO
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::espressif::esp32::gpio {

// ============================================================================
// GPIO - General Purpose Input/Output
// Base Address: 0x3FF44000
// ============================================================================

/// GPIO Register Structure
struct GPIO_Registers {

    /// BT_SELECT
    /// Offset: 0x0000
    volatile uint32_t BT_SELECT;

    /// OUT
    /// Offset: 0x0004
    volatile uint32_t OUT;

    /// OUT_W1TS
    /// Offset: 0x0008
    volatile uint32_t OUT_W1TS;

    /// OUT_W1TC
    /// Offset: 0x000C
    volatile uint32_t OUT_W1TC;

    /// OUT1
    /// Offset: 0x0010
    volatile uint32_t OUT1;

    /// OUT1_W1TS
    /// Offset: 0x0014
    volatile uint32_t OUT1_W1TS;

    /// OUT1_W1TC
    /// Offset: 0x0018
    volatile uint32_t OUT1_W1TC;

    /// SDIO_SELECT
    /// Offset: 0x001C
    volatile uint32_t SDIO_SELECT;

    /// ENABLE
    /// Offset: 0x0020
    volatile uint32_t ENABLE;

    /// ENABLE_W1TS
    /// Offset: 0x0024
    volatile uint32_t ENABLE_W1TS;

    /// ENABLE_W1TC
    /// Offset: 0x0028
    volatile uint32_t ENABLE_W1TC;

    /// ENABLE1
    /// Offset: 0x002C
    volatile uint32_t ENABLE1;

    /// ENABLE1_W1TS
    /// Offset: 0x0030
    volatile uint32_t ENABLE1_W1TS;

    /// ENABLE1_W1TC
    /// Offset: 0x0034
    volatile uint32_t ENABLE1_W1TC;

    /// STRAP
    /// Offset: 0x0038
    volatile uint32_t STRAP;

    /// IN
    /// Offset: 0x003C
    volatile uint32_t IN;

    /// IN1
    /// Offset: 0x0040
    volatile uint32_t IN1;

    /// STATUS
    /// Offset: 0x0044
    volatile uint32_t STATUS;

    /// STATUS_W1TS
    /// Offset: 0x0048
    volatile uint32_t STATUS_W1TS;

    /// STATUS_W1TC
    /// Offset: 0x004C
    volatile uint32_t STATUS_W1TC;

    /// STATUS1
    /// Offset: 0x0050
    volatile uint32_t STATUS1;

    /// STATUS1_W1TS
    /// Offset: 0x0054
    volatile uint32_t STATUS1_W1TS;

    /// STATUS1_W1TC
    /// Offset: 0x0058
    volatile uint32_t STATUS1_W1TC;
    uint8_t RESERVED_005C[4]; ///< Reserved

    /// ACPU_INT
    /// Offset: 0x0060
    volatile uint32_t ACPU_INT;

    /// ACPU_NMI_INT
    /// Offset: 0x0064
    volatile uint32_t ACPU_NMI_INT;

    /// PCPU_INT
    /// Offset: 0x0068
    volatile uint32_t PCPU_INT;

    /// PCPU_NMI_INT
    /// Offset: 0x006C
    volatile uint32_t PCPU_NMI_INT;

    /// CPUSDIO_INT
    /// Offset: 0x0070
    volatile uint32_t CPUSDIO_INT;

    /// ACPU_INT1
    /// Offset: 0x0074
    volatile uint32_t ACPU_INT1;

    /// ACPU_NMI_INT1
    /// Offset: 0x0078
    volatile uint32_t ACPU_NMI_INT1;

    /// PCPU_INT1
    /// Offset: 0x007C
    volatile uint32_t PCPU_INT1;

    /// PCPU_NMI_INT1
    /// Offset: 0x0080
    volatile uint32_t PCPU_NMI_INT1;

    /// CPUSDIO_INT1
    /// Offset: 0x0084
    volatile uint32_t CPUSDIO_INT1;

    /// PIN[40]
    /// Offset: 0x0088
    volatile uint32_t PIN[40][40];

    /// cali_conf
    /// Offset: 0x0128
    volatile uint32_t cali_conf;

    /// cali_data
    /// Offset: 0x012C
    volatile uint32_t cali_data;

    /// FUNC[256]_IN_SEL_CFG
    /// Offset: 0x0130
    volatile uint32_t FUNC[256]_IN_SEL_CFG[256];

    /// FUNC[40]_OUT_SEL_CFG
    /// Offset: 0x0530
    volatile uint32_t FUNC[40]_OUT_SEL_CFG[40];
};

static_assert(sizeof(GPIO_Registers) >= 1488, "GPIO_Registers size mismatch");

/// GPIO peripheral instance
inline GPIO_Registers* GPIO() {
    return reinterpret_cast<GPIO_Registers*>(0x3FF44000);
}

}  // namespace alloy::hal::espressif::esp32::gpio
