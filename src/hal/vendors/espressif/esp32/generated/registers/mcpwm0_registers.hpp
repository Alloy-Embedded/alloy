/// Auto-generated register definitions for MCPWM0
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::espressif::esp32::mcpwm0 {

// ============================================================================
// MCPWM0 - Motor Control Pulse-Width Modulation 0
// Base Address: 0x3FF5E000
// ============================================================================

/// MCPWM0 Register Structure
struct MCPWM0_Registers {

    /// CLK_CFG
    /// Offset: 0x0000
    volatile uint32_t CLK_CFG;

    /// TIMER0_CFG0
    /// Offset: 0x0004
    /// Reset value: 0x0000FF00
    volatile uint32_t TIMER0_CFG0;

    /// TIMER0_CFG1
    /// Offset: 0x0008
    volatile uint32_t TIMER0_CFG1;

    /// TIMER0_SYNC
    /// Offset: 0x000C
    volatile uint32_t TIMER0_SYNC;

    /// TIMER0_STATUS
    /// Offset: 0x0010
    volatile uint32_t TIMER0_STATUS;

    /// TIMER1_CFG0
    /// Offset: 0x0014
    /// Reset value: 0x0000FF00
    volatile uint32_t TIMER1_CFG0;

    /// TIMER1_CFG1
    /// Offset: 0x0018
    volatile uint32_t TIMER1_CFG1;

    /// TIMER1_SYNC
    /// Offset: 0x001C
    volatile uint32_t TIMER1_SYNC;

    /// TIMER1_STATUS
    /// Offset: 0x0020
    volatile uint32_t TIMER1_STATUS;

    /// TIMER2_CFG0
    /// Offset: 0x0024
    /// Reset value: 0x0000FF00
    volatile uint32_t TIMER2_CFG0;

    /// TIMER2_CFG1
    /// Offset: 0x0028
    volatile uint32_t TIMER2_CFG1;

    /// TIMER2_SYNC
    /// Offset: 0x002C
    volatile uint32_t TIMER2_SYNC;

    /// TIMER2_STATUS
    /// Offset: 0x0030
    volatile uint32_t TIMER2_STATUS;

    /// TIMER_SYNCI_CFG
    /// Offset: 0x0034
    volatile uint32_t TIMER_SYNCI_CFG;

    /// OPERATOR_TIMERSEL
    /// Offset: 0x0038
    volatile uint32_t OPERATOR_TIMERSEL;

    /// GEN0_STMP_CFG
    /// Offset: 0x003C
    volatile uint32_t GEN0_STMP_CFG;

    /// GEN0_TSTMP_A
    /// Offset: 0x0040
    volatile uint32_t GEN0_TSTMP_A;

    /// GEN0_TSTMP_B
    /// Offset: 0x0044
    volatile uint32_t GEN0_TSTMP_B;

    /// GEN0_CFG0
    /// Offset: 0x0048
    volatile uint32_t GEN0_CFG0;

    /// GEN0_FORCE
    /// Offset: 0x004C
    /// Reset value: 0x00000020
    volatile uint32_t GEN0_FORCE;

    /// GEN0_A
    /// Offset: 0x0050
    volatile uint32_t GEN0_A;

    /// GEN0_B
    /// Offset: 0x0054
    volatile uint32_t GEN0_B;

    /// DT0_CFG
    /// Offset: 0x0058
    /// Reset value: 0x00018000
    volatile uint32_t DT0_CFG;

    /// DT0_FED_CFG
    /// Offset: 0x005C
    volatile uint32_t DT0_FED_CFG;

    /// DT0_RED_CFG
    /// Offset: 0x0060
    volatile uint32_t DT0_RED_CFG;

    /// CARRIER0_CFG
    /// Offset: 0x0064
    volatile uint32_t CARRIER0_CFG;

    /// FH0_CFG0
    /// Offset: 0x0068
    volatile uint32_t FH0_CFG0;

    /// FH0_CFG1
    /// Offset: 0x006C
    volatile uint32_t FH0_CFG1;

    /// FH0_STATUS
    /// Offset: 0x0070
    volatile uint32_t FH0_STATUS;

    /// GEN1_STMP_CFG
    /// Offset: 0x0074
    volatile uint32_t GEN1_STMP_CFG;

    /// GEN1_TSTMP_A
    /// Offset: 0x0078
    volatile uint32_t GEN1_TSTMP_A;

    /// GEN1_TSTMP_B
    /// Offset: 0x007C
    volatile uint32_t GEN1_TSTMP_B;

    /// GEN1_CFG0
    /// Offset: 0x0080
    volatile uint32_t GEN1_CFG0;

    /// GEN1_FORCE
    /// Offset: 0x0084
    /// Reset value: 0x00000020
    volatile uint32_t GEN1_FORCE;

    /// GEN1_A
    /// Offset: 0x0088
    volatile uint32_t GEN1_A;

    /// GEN1_B
    /// Offset: 0x008C
    volatile uint32_t GEN1_B;

    /// DT1_CFG
    /// Offset: 0x0090
    /// Reset value: 0x00018000
    volatile uint32_t DT1_CFG;

    /// DT1_FED_CFG
    /// Offset: 0x0094
    volatile uint32_t DT1_FED_CFG;

    /// DT1_RED_CFG
    /// Offset: 0x0098
    volatile uint32_t DT1_RED_CFG;

    /// CARRIER1_CFG
    /// Offset: 0x009C
    volatile uint32_t CARRIER1_CFG;

    /// FH1_CFG0
    /// Offset: 0x00A0
    volatile uint32_t FH1_CFG0;

    /// FH1_CFG1
    /// Offset: 0x00A4
    volatile uint32_t FH1_CFG1;

    /// FH1_STATUS
    /// Offset: 0x00A8
    volatile uint32_t FH1_STATUS;

    /// GEN2_STMP_CFG
    /// Offset: 0x00AC
    volatile uint32_t GEN2_STMP_CFG;

    /// GEN2_TSTMP_A
    /// Offset: 0x00B0
    volatile uint32_t GEN2_TSTMP_A;

    /// GEN2_TSTMP_B
    /// Offset: 0x00B4
    volatile uint32_t GEN2_TSTMP_B;

    /// GEN2_CFG0
    /// Offset: 0x00B8
    volatile uint32_t GEN2_CFG0;

    /// GEN2_FORCE
    /// Offset: 0x00BC
    /// Reset value: 0x00000020
    volatile uint32_t GEN2_FORCE;

    /// GEN2_A
    /// Offset: 0x00C0
    volatile uint32_t GEN2_A;

    /// GEN2_B
    /// Offset: 0x00C4
    volatile uint32_t GEN2_B;

    /// DT2_CFG
    /// Offset: 0x00C8
    /// Reset value: 0x00018000
    volatile uint32_t DT2_CFG;

    /// DT2_FED_CFG
    /// Offset: 0x00CC
    volatile uint32_t DT2_FED_CFG;

    /// DT2_RED_CFG
    /// Offset: 0x00D0
    volatile uint32_t DT2_RED_CFG;

    /// CARRIER2_CFG
    /// Offset: 0x00D4
    volatile uint32_t CARRIER2_CFG;

    /// FH2_CFG0
    /// Offset: 0x00D8
    volatile uint32_t FH2_CFG0;

    /// FH2_CFG1
    /// Offset: 0x00DC
    volatile uint32_t FH2_CFG1;

    /// FH2_STATUS
    /// Offset: 0x00E0
    volatile uint32_t FH2_STATUS;

    /// FAULT_DETECT
    /// Offset: 0x00E4
    volatile uint32_t FAULT_DETECT;

    /// CAP_TIMER_CFG
    /// Offset: 0x00E8
    volatile uint32_t CAP_TIMER_CFG;

    /// CAP_TIMER_PHASE
    /// Offset: 0x00EC
    volatile uint32_t CAP_TIMER_PHASE;

    /// CAP_CH0_CFG
    /// Offset: 0x00F0
    volatile uint32_t CAP_CH0_CFG;

    /// CAP_CH1_CFG
    /// Offset: 0x00F4
    volatile uint32_t CAP_CH1_CFG;

    /// CAP_CH2_CFG
    /// Offset: 0x00F8
    volatile uint32_t CAP_CH2_CFG;

    /// CAP_CH0
    /// Offset: 0x00FC
    volatile uint32_t CAP_CH0;

    /// CAP_CH1
    /// Offset: 0x0100
    volatile uint32_t CAP_CH1;

    /// CAP_CH2
    /// Offset: 0x0104
    volatile uint32_t CAP_CH2;

    /// CAP_STATUS
    /// Offset: 0x0108
    volatile uint32_t CAP_STATUS;

    /// UPDATE_CFG
    /// Offset: 0x010C
    /// Reset value: 0x00000055
    volatile uint32_t UPDATE_CFG;

    /// INT_ENA
    /// Offset: 0x0110
    volatile uint32_t INT_ENA;

    /// INT_RAW
    /// Offset: 0x0114
    volatile uint32_t INT_RAW;

    /// INT_ST
    /// Offset: 0x0118
    volatile uint32_t INT_ST;

    /// INT_CLR
    /// Offset: 0x011C
    volatile uint32_t INT_CLR;

    /// CLK
    /// Offset: 0x0120
    volatile uint32_t CLK;

    /// VERSION
    /// Offset: 0x0124
    /// Reset value: 0x02107230
    volatile uint32_t VERSION;
};

static_assert(sizeof(MCPWM0_Registers) >= 296, "MCPWM0_Registers size mismatch");

/// MCPWM0 peripheral instance
inline MCPWM0_Registers* MCPWM0() {
    return reinterpret_cast<MCPWM0_Registers*>(0x3FF5E000);
}

}  // namespace alloy::hal::espressif::esp32::mcpwm0
