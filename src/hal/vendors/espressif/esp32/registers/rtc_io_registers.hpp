/// Auto-generated register definitions for RTC_IO
/// Family: esp32
/// Vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

namespace alloy::hal::espressif::esp32::rtc_io {

// ============================================================================
// RTC_IO - Low-power Input/Output
// Base Address: 0x3FF48400
// ============================================================================

/// RTC_IO Register Structure
struct RTC_IO_Registers {
    /// OUT
    /// Offset: 0x0000
    volatile uint32_t OUT;

    /// OUT_W1TS
    /// Offset: 0x0004
    volatile uint32_t OUT_W1TS;

    /// OUT_W1TC
    /// Offset: 0x0008
    volatile uint32_t OUT_W1TC;

    /// ENABLE
    /// Offset: 0x000C
    volatile uint32_t ENABLE;

    /// ENABLE_W1TS
    /// Offset: 0x0010
    volatile uint32_t ENABLE_W1TS;

    /// ENABLE_W1TC
    /// Offset: 0x0014
    volatile uint32_t ENABLE_W1TC;

    /// STATUS
    /// Offset: 0x0018
    volatile uint32_t STATUS;

    /// STATUS_W1TS
    /// Offset: 0x001C
    volatile uint32_t STATUS_W1TS;

    /// STATUS_W1TC
    /// Offset: 0x0020
    volatile uint32_t STATUS_W1TC;

    /// IN
    /// Offset: 0x0024
    volatile uint32_t IN;

    /// PIN[18]
    /// Offset: 0x0028
    volatile uint32_t PIN[18][18];

    /// RTC_DEBUG_SEL
    /// Offset: 0x0070
    volatile uint32_t RTC_DEBUG_SEL;

    /// DIG_PAD_HOLD
    /// Offset: 0x0074
    volatile uint32_t DIG_PAD_HOLD;

    /// HALL_SENS
    /// Offset: 0x0078
    volatile uint32_t HALL_SENS;

    /// SENSOR_PADS
    /// Offset: 0x007C
    volatile uint32_t SENSOR_PADS;

    /// ADC_PAD
    /// Offset: 0x0080
    volatile uint32_t ADC_PAD;

    /// PAD_DAC1
    /// Offset: 0x0084
    /// Reset value: 0x80000000
    volatile uint32_t PAD_DAC1;

    /// PAD_DAC2
    /// Offset: 0x0088
    /// Reset value: 0x80000000
    volatile uint32_t PAD_DAC2;

    /// XTAL_32K_PAD
    /// Offset: 0x008C
    /// Reset value: 0x84100010
    volatile uint32_t XTAL_32K_PAD;

    /// TOUCH_CFG
    /// Offset: 0x0090
    /// Reset value: 0x66000000
    volatile uint32_t TOUCH_CFG;

    /// TOUCH_PAD0
    /// Offset: 0x0094
    /// Reset value: 0x52000000
    volatile uint32_t TOUCH_PAD0;

    /// TOUCH_PAD1
    /// Offset: 0x0098
    /// Reset value: 0x4A000000
    volatile uint32_t TOUCH_PAD1;

    /// TOUCH_PAD2
    /// Offset: 0x009C
    /// Reset value: 0x52000000
    volatile uint32_t TOUCH_PAD2;

    /// TOUCH_PAD3
    /// Offset: 0x00A0
    /// Reset value: 0x4A000000
    volatile uint32_t TOUCH_PAD3;

    /// TOUCH_PAD4
    /// Offset: 0x00A4
    /// Reset value: 0x52000000
    volatile uint32_t TOUCH_PAD4;

    /// TOUCH_PAD5
    /// Offset: 0x00A8
    /// Reset value: 0x52000000
    volatile uint32_t TOUCH_PAD5;

    /// TOUCH_PAD6
    /// Offset: 0x00AC
    /// Reset value: 0x4A000000
    volatile uint32_t TOUCH_PAD6;

    /// TOUCH_PAD7
    /// Offset: 0x00B0
    /// Reset value: 0x42000000
    volatile uint32_t TOUCH_PAD7;

    /// TOUCH_PAD8
    /// Offset: 0x00B4
    /// Reset value: 0x02000000
    volatile uint32_t TOUCH_PAD8;

    /// TOUCH_PAD9
    /// Offset: 0x00B8
    /// Reset value: 0x02000000
    volatile uint32_t TOUCH_PAD9;

    /// EXT_WAKEUP0
    /// Offset: 0x00BC
    volatile uint32_t EXT_WAKEUP0;

    /// XTL_EXT_CTR
    /// Offset: 0x00C0
    volatile uint32_t XTL_EXT_CTR;

    /// SAR_I2C_IO
    /// Offset: 0x00C4
    volatile uint32_t SAR_I2C_IO;

    /// DATE
    /// Offset: 0x00C8
    /// Reset value: 0x01603160
    volatile uint32_t DATE;
};

static_assert(sizeof(RTC_IO_Registers) >= 204, "RTC_IO_Registers size mismatch");

/// RTC_IO peripheral instance
inline RTC_IO_Registers* RTC_IO() {
    return reinterpret_cast<RTC_IO_Registers*>(0x3FF48400);
}

}  // namespace alloy::hal::espressif::esp32::rtc_io
