/// Auto-generated register definitions for PPB
/// Family: rp2040
/// Vendor: Raspberry Pi
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

namespace alloy::hal::raspberrypi::rp2040::ppb {

// ============================================================================
// PPB - Peripheral Registers
// Base Address: 0xE0000000
// ============================================================================

/// PPB Register Structure
struct PPB_Registers {
    uint8_t RESERVED_0000[57360]; ///< Reserved

    /// Use the SysTick Control and Status Register to enable the SysTick features.
    /// Offset: 0xE010
    /// Reset value: 0x00000000
    volatile uint32_t SYST_CSR;

    /// Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.\n To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
    /// Offset: 0xE014
    /// Reset value: 0x00000000
    volatile uint32_t SYST_RVR;

    /// Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
    /// Offset: 0xE018
    /// Reset value: 0x00000000
    volatile uint32_t SYST_CVR;

    /// Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
    /// Offset: 0xE01C
    /// Reset value: 0x00000000
    volatile uint32_t SYST_CALIB;
    uint8_t RESERVED_E020[224]; ///< Reserved

    /// Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled.\n If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority.
    /// Offset: 0xE100
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_ISER;
    uint8_t RESERVED_E104[124]; ///< Reserved

    /// Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled.
    /// Offset: 0xE180
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_ICER;
    uint8_t RESERVED_E184[124]; ///< Reserved

    /// The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending.
    /// Offset: 0xE200
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_ISPR;
    uint8_t RESERVED_E204[124]; ///< Reserved

    /// Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending.
    /// Offset: 0xE280
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_ICPR;
    uint8_t RESERVED_E284[380]; ///< Reserved

    /// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.\n Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt.\n These registers are only word-accessible
    /// Offset: 0xE400
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_IPR0;

    /// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    /// Offset: 0xE404
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_IPR1;

    /// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    /// Offset: 0xE408
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_IPR2;

    /// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    /// Offset: 0xE40C
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_IPR3;

    /// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    /// Offset: 0xE410
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_IPR4;

    /// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    /// Offset: 0xE414
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_IPR5;

    /// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    /// Offset: 0xE418
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_IPR6;

    /// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    /// Offset: 0xE41C
    /// Reset value: 0x00000000
    volatile uint32_t NVIC_IPR7;
    uint8_t RESERVED_E420[2272]; ///< Reserved

    /// Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core.
    /// Offset: 0xED00
    /// Reset value: 0x410CC601
    volatile uint32_t CPUID;

    /// Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception.
    /// Offset: 0xED04
    /// Reset value: 0x00000000
    volatile uint32_t ICSR;

    /// The VTOR holds the vector table offset address.
    /// Offset: 0xED08
    /// Reset value: 0x00000000
    volatile uint32_t VTOR;

    /// Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
    /// Offset: 0xED0C
    /// Reset value: 0x00000000
    volatile uint32_t AIRCR;

    /// System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
    /// Offset: 0xED10
    /// Reset value: 0x00000000
    volatile uint32_t SCR;

    /// The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault.
    /// Offset: 0xED14
    /// Reset value: 0x00000000
    volatile uint32_t CCR;
    uint8_t RESERVED_ED18[4]; ///< Reserved

    /// System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall.
    /// Offset: 0xED1C
    /// Reset value: 0x00000000
    volatile uint32_t SHPR2;

    /// System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick.
    /// Offset: 0xED20
    /// Reset value: 0x00000000
    volatile uint32_t SHPR3;

    /// Use the System Handler Control and State Register to determine or clear the pending status of SVCall.
    /// Offset: 0xED24
    /// Reset value: 0x00000000
    volatile uint32_t SHCSR;
    uint8_t RESERVED_ED28[104]; ///< Reserved

    /// Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports.
    /// Offset: 0xED90
    /// Reset value: 0x00000800
    volatile uint32_t MPU_TYPE;

    /// Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs.
    /// Offset: 0xED94
    /// Reset value: 0x00000000
    volatile uint32_t MPU_CTRL;

    /// Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR.
    /// Offset: 0xED98
    /// Reset value: 0x00000000
    volatile uint32_t MPU_RNR;

    /// Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated.
    /// Offset: 0xED9C
    /// Reset value: 0x00000000
    volatile uint32_t MPU_RBAR;

    /// Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region.
    /// Offset: 0xEDA0
    /// Reset value: 0x00000000
    volatile uint32_t MPU_RASR;
};

static_assert(sizeof(PPB_Registers) >= 60836, "PPB_Registers size mismatch");

/// PPB peripheral instance
inline PPB_Registers* PPB() {
    return reinterpret_cast<PPB_Registers*>(0xE0000000);
}

}  // namespace alloy::hal::raspberrypi::rp2040::ppb
