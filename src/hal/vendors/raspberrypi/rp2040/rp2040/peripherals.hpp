/// Auto-generated peripheral definitions for RP2040
/// Generated by Alloy Code Generator from CMSIS-SVD
///
/// Device:  RP2040
/// Vendor:  Raspberry Pi
/// Family:  rp2040
///
/// DO NOT EDIT - Regenerate from SVD if needed

#ifndef ALLOY_GENERATED_RP2040_PERIPHERALS_HPP
#define ALLOY_GENERATED_RP2040_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::rp2040 {

// ============================================================================
// PERIPHERAL BASE ADDRESSES
// ============================================================================

namespace peripherals {
    constexpr uintptr_t XIP_CTRL             = 0x14000000;  // QSPI flash execute-in-place block
    constexpr uintptr_t XIP_SSI              = 0x18000000;  // DW_apb_ssi has the following features:\n
        * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation.\n
        * APB3 and APB4 protocol support.\n
        * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits.\n
        * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices.\n
        * Programmable Dual/Quad/Octal SPI support in Master Mode.\n
        * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation.\n
        * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes.\n
        * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes.\n
        * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests.\n
        * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently.\n
        * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus.\n
        * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains.\n
        * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates.\n
        * Programmable features:\n
        - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire.\n
        - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation.\n
        - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer.\n
        * Configured features:\n
        - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.\n
        - 1 slave select output.\n
        - Hardware slave-select – Dedicated hardware slave-select line.\n
        - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller.\n
        - Interrupt polarity – active high interrupt lines.\n
        - Serial clock polarity – low serial-clock polarity directly after reset.\n
        - Serial clock phase – capture on first edge of serial-clock directly after reset.
    constexpr uintptr_t SYSINFO              = 0x40000000;
    constexpr uintptr_t SYSCFG               = 0x40004000;  // Register block for various chip control signals
    constexpr uintptr_t CLOCKS               = 0x40008000;
    constexpr uintptr_t RESETS               = 0x4000C000;
    constexpr uintptr_t PSM                  = 0x40010000;
    constexpr uintptr_t IO_BANK0             = 0x40014000;
    constexpr uintptr_t IO_QSPI              = 0x40018000;
    constexpr uintptr_t PADS_BANK0           = 0x4001C000;
    constexpr uintptr_t PADS_QSPI            = 0x40020000;
    constexpr uintptr_t XOSC                 = 0x40024000;  // Controls the crystal oscillator
    constexpr uintptr_t PLL_SYS              = 0x40028000;
    constexpr uintptr_t PLL_USB              = 0x4002C000;
    constexpr uintptr_t BUSCTRL              = 0x40030000;  // Register block for busfabric control signals and performance counters
    constexpr uintptr_t UART0                = 0x40034000;
    constexpr uintptr_t UART1                = 0x40038000;
    constexpr uintptr_t SPI0                 = 0x4003C000;
    constexpr uintptr_t SPI1                 = 0x40040000;
    constexpr uintptr_t I2C0                 = 0x40044000;  // DW_apb_i2c address block
    constexpr uintptr_t I2C1                 = 0x40048000;
    constexpr uintptr_t ADC                  = 0x4004C000;  // Control and data interface to SAR ADC
    constexpr uintptr_t PWM                  = 0x40050000;  // Simple PWM
    constexpr uintptr_t TIMER                = 0x40054000;  // Controls time and alarms\n
        time is a 64 bit value indicating the time in usec since power-on\n
        timeh is the top 32 bits of time & timel is the bottom 32 bits\n
        to change time write to timelw before timehw\n
        to read time read from timelr before timehr\n
        An alarm is set by setting alarm_enable and writing to the corresponding alarm register\n
        When an alarm is pending, the corresponding alarm_running signal will be high\n
        An alarm can be cancelled before it has finished by clearing the alarm_enable\n
        When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared\n
        To clear the interrupt write a 1 to the corresponding alarm_irq
    constexpr uintptr_t WATCHDOG             = 0x40058000;
    constexpr uintptr_t RTC                  = 0x4005C000;  // Register block to control RTC
    constexpr uintptr_t ROSC                 = 0x40060000;
    constexpr uintptr_t VREG_AND_CHIP_RESET  = 0x40064000;  // control and status for on-chip voltage regulator and chip level reset subsystem
    constexpr uintptr_t TBMAN                = 0x4006C000;  // Testbench manager. Allows the programmer to know what platform their software is running on.
    constexpr uintptr_t DMA                  = 0x50000000;  // DMA with separate read and write masters
    constexpr uintptr_t USBCTRL_REGS         = 0x50110000;  // USB FS/LS controller device registers
    constexpr uintptr_t PIO0                 = 0x50200000;  // Programmable IO block
    constexpr uintptr_t PIO1                 = 0x50300000;
    constexpr uintptr_t SIO                  = 0xD0000000;  // Single-cycle IO block\n
        Provides core-local and inter-core hardware for the two processors, with single-cycle access.
    constexpr uintptr_t PPB                  = 0xE0000000;
} // namespace peripherals

// ============================================================================
// MEMORY MAP
// ============================================================================

namespace memory {
    // Memory regions not defined in SVD
} // namespace memory

} // namespace alloy::generated::rp2040

#endif // ALLOY_GENERATED_RP2040_PERIPHERALS_HPP
