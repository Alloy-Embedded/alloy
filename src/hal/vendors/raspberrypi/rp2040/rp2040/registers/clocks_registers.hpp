/// Auto-generated register definitions for CLOCKS
/// Device: RP2040
/// Vendor: Raspberry Pi
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

namespace alloy::hal::raspberrypi::rp2040::rp2040::clocks {

// ============================================================================
// CLOCKS - Peripheral Registers
// Base Address: 0x40008000
// ============================================================================

/// CLOCKS Register Structure
struct CLOCKS_Registers {

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    volatile uint32_t CLK_GPOUT0_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x0004
    /// Reset value: 0x00000100
    volatile uint32_t CLK_GPOUT0_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x0008
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_GPOUT0_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x000C
    /// Reset value: 0x00000000
    volatile uint32_t CLK_GPOUT1_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x0010
    /// Reset value: 0x00000100
    volatile uint32_t CLK_GPOUT1_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x0014
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_GPOUT1_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    volatile uint32_t CLK_GPOUT2_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x001C
    /// Reset value: 0x00000100
    volatile uint32_t CLK_GPOUT2_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x0020
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_GPOUT2_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    volatile uint32_t CLK_GPOUT3_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x0028
    /// Reset value: 0x00000100
    volatile uint32_t CLK_GPOUT3_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x002C
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_GPOUT3_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    volatile uint32_t CLK_REF_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x0034
    /// Reset value: 0x00000100
    volatile uint32_t CLK_REF_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x0038
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_REF_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    volatile uint32_t CLK_SYS_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x0040
    /// Reset value: 0x00000100
    volatile uint32_t CLK_SYS_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x0044
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_SYS_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    volatile uint32_t CLK_PERI_CTRL;
    uint8_t RESERVED_004C[4]; ///< Reserved

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x0050
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_PERI_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    volatile uint32_t CLK_USB_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x0058
    /// Reset value: 0x00000100
    volatile uint32_t CLK_USB_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x005C
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_USB_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x0060
    /// Reset value: 0x00000000
    volatile uint32_t CLK_ADC_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x0064
    /// Reset value: 0x00000100
    volatile uint32_t CLK_ADC_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x0068
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_ADC_SELECTED;

    /// Clock control, can be changed on-the-fly (except for auxsrc)
    /// Offset: 0x006C
    /// Reset value: 0x00000000
    volatile uint32_t CLK_RTC_CTRL;

    /// Clock divisor, can be changed on-the-fly
    /// Offset: 0x0070
    /// Reset value: 0x00000100
    volatile uint32_t CLK_RTC_DIV;

    /// Indicates which src is currently selected (one-hot)
    /// Offset: 0x0074
    /// Reset value: 0x00000001
    /// Access: read-only
    volatile uint32_t CLK_RTC_SELECTED;

    /// CLK_SYS_RESUS_CTRL
    /// Offset: 0x0078
    /// Reset value: 0x000000FF
    volatile uint32_t CLK_SYS_RESUS_CTRL;

    /// CLK_SYS_RESUS_STATUS
    /// Offset: 0x007C
    /// Reset value: 0x00000000
    volatile uint32_t CLK_SYS_RESUS_STATUS;

    /// Reference clock frequency in kHz
    /// Offset: 0x0080
    /// Reset value: 0x00000000
    volatile uint32_t FC0_REF_KHZ;

    /// Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
    /// Offset: 0x0084
    /// Reset value: 0x00000000
    volatile uint32_t FC0_MIN_KHZ;

    /// Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
    /// Offset: 0x0088
    /// Reset value: 0x01FFFFFF
    volatile uint32_t FC0_MAX_KHZ;

    /// Delays the start of frequency counting to allow the mux to settle\n
            Delay is measured in multiples of the reference clock period
    /// Offset: 0x008C
    /// Reset value: 0x00000001
    volatile uint32_t FC0_DELAY;

    /// The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval\n
            The default gives a test interval of 250us
    /// Offset: 0x0090
    /// Reset value: 0x00000008
    volatile uint32_t FC0_INTERVAL;

    /// Clock sent to frequency counter, set to 0 when not required\n
            Writing to this register initiates the frequency count
    /// Offset: 0x0094
    /// Reset value: 0x00000000
    volatile uint32_t FC0_SRC;

    /// Frequency counter status
    /// Offset: 0x0098
    /// Reset value: 0x00000000
    volatile uint32_t FC0_STATUS;

    /// Result of frequency measurement, only valid when status_done=1
    /// Offset: 0x009C
    /// Reset value: 0x00000000
    volatile uint32_t FC0_RESULT;

    /// enable clock in wake mode
    /// Offset: 0x00A0
    /// Reset value: 0xFFFFFFFF
    volatile uint32_t WAKE_EN0;

    /// enable clock in wake mode
    /// Offset: 0x00A4
    /// Reset value: 0x00007FFF
    volatile uint32_t WAKE_EN1;

    /// enable clock in sleep mode
    /// Offset: 0x00A8
    /// Reset value: 0xFFFFFFFF
    volatile uint32_t SLEEP_EN0;

    /// enable clock in sleep mode
    /// Offset: 0x00AC
    /// Reset value: 0x00007FFF
    volatile uint32_t SLEEP_EN1;

    /// indicates the state of the clock enable
    /// Offset: 0x00B0
    /// Reset value: 0x00000000
    volatile uint32_t ENABLED0;

    /// indicates the state of the clock enable
    /// Offset: 0x00B4
    /// Reset value: 0x00000000
    volatile uint32_t ENABLED1;

    /// Raw Interrupts
    /// Offset: 0x00B8
    /// Reset value: 0x00000000
    volatile uint32_t INTR;

    /// Interrupt Enable
    /// Offset: 0x00BC
    /// Reset value: 0x00000000
    volatile uint32_t INTE;

    /// Interrupt Force
    /// Offset: 0x00C0
    /// Reset value: 0x00000000
    volatile uint32_t INTF;

    /// Interrupt status after masking & forcing
    /// Offset: 0x00C4
    /// Reset value: 0x00000000
    volatile uint32_t INTS;
};

static_assert(sizeof(CLOCKS_Registers) >= 200, "CLOCKS_Registers size mismatch");

/// CLOCKS peripheral instance
inline CLOCKS_Registers* CLOCKS() {
    return reinterpret_cast<CLOCKS_Registers*>(0x40008000);
}

}  // namespace alloy::hal::raspberrypi::rp2040::rp2040::clocks
