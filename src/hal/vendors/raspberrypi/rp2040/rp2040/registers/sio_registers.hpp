/// Auto-generated register definitions for SIO
/// Device: RP2040
/// Vendor: Raspberry Pi
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

namespace alloy::hal::raspberrypi::rp2040::rp2040::sio {

// ============================================================================
// SIO - Single-cycle IO block\n
        Provides core-local and inter-core hardware for the two processors, with single-cycle access.
// Base Address: 0xD0000000
// ============================================================================

/// SIO Register Structure
struct SIO_Registers {

    /// Processor core identifier\n
            Value is 0 when read from processor core 0, and 1 when read from processor core 1.
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t CPUID;

    /// Input value for GPIO pins
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_IN;

    /// Input value for QSPI pins
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_IN;
    uint8_t RESERVED_000C[4]; ///< Reserved

    /// GPIO output value
    /// Offset: 0x0010
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_OUT;

    /// GPIO output value set
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_OUT_SET;

    /// GPIO output value clear
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_OUT_CLR;

    /// GPIO output value XOR
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_OUT_XOR;

    /// GPIO output enable
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_OE;

    /// GPIO output enable set
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_OE_SET;

    /// GPIO output enable clear
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_OE_CLR;

    /// GPIO output enable XOR
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_OE_XOR;

    /// QSPI output value
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_OUT;

    /// QSPI output value set
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_OUT_SET;

    /// QSPI output value clear
    /// Offset: 0x0038
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_OUT_CLR;

    /// QSPI output value XOR
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_OUT_XOR;

    /// QSPI output enable
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_OE;

    /// QSPI output enable set
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_OE_SET;

    /// QSPI output enable clear
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_OE_CLR;

    /// QSPI output enable XOR
    /// Offset: 0x004C
    /// Reset value: 0x00000000
    volatile uint32_t GPIO_HI_OE_XOR;

    /// Status register for inter-core FIFOs (mailboxes).\n
            There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep.\n
            Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX).\n
            Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX).\n
            The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
    /// Offset: 0x0050
    /// Reset value: 0x00000002
    volatile uint32_t FIFO_ST;

    /// Write access to this core's TX FIFO
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    /// Access: write-only
    volatile uint32_t FIFO_WR;

    /// Read access to this core's RX FIFO
    /// Offset: 0x0058
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t FIFO_RD;

    /// Spinlock state\n
            A bitmap containing the state of all 32 spinlocks (1=locked).\n
            Mainly intended for debugging.
    /// Offset: 0x005C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK_ST;

    /// Divider unsigned dividend\n
            Write to the DIVIDEND operand of the divider, i.e. the p in `p / q`.\n
            Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER.\n
            UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an\n
            unsigned calculation, and the S alias starts a signed calculation.
    /// Offset: 0x0060
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DIV_UDIVIDEND;

    /// Divider unsigned divisor\n
            Write to the DIVISOR operand of the divider, i.e. the q in `p / q`.\n
            Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER.\n
            UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an\n
            unsigned calculation, and the S alias starts a signed calculation.
    /// Offset: 0x0064
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DIV_UDIVISOR;

    /// Divider signed dividend\n
            The same as UDIVIDEND, but starts a signed calculation, rather than unsigned.
    /// Offset: 0x0068
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DIV_SDIVIDEND;

    /// Divider signed divisor\n
            The same as UDIVISOR, but starts a signed calculation, rather than unsigned.
    /// Offset: 0x006C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DIV_SDIVISOR;

    /// Divider result quotient\n
            The result of `DIVIDEND / DIVISOR` (division). Contents undefined while CSR_READY is low.\n
            For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and DIVISOR differ.\n
            This register can be written to directly, for context save/restore purposes. This halts any\n
            in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.\n
            Reading from QUOTIENT clears the CSR_DIRTY flag, so should read results in the order\n
            REMAINDER, QUOTIENT if CSR_DIRTY is used.
    /// Offset: 0x0070
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DIV_QUOTIENT;

    /// Divider result remainder\n
            The result of `DIVIDEND % DIVISOR` (modulo). Contents undefined while CSR_READY is low.\n
            For signed calculations, REMAINDER is negative only when DIVIDEND is negative.\n
            This register can be written to directly, for context save/restore purposes. This halts any\n
            in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.
    /// Offset: 0x0074
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DIV_REMAINDER;

    /// Control and status register for divider.
    /// Offset: 0x0078
    /// Reset value: 0x00000001
    volatile uint32_t DIV_CSR;
    uint8_t RESERVED_007C[4]; ///< Reserved

    /// Read/write access to accumulator 0
    /// Offset: 0x0080
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP0_ACCUM0;

    /// Read/write access to accumulator 1
    /// Offset: 0x0084
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP0_ACCUM1;

    /// Read/write access to BASE0 register.
    /// Offset: 0x0088
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP0_BASE0;

    /// Read/write access to BASE1 register.
    /// Offset: 0x008C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP0_BASE1;

    /// Read/write access to BASE2 register.
    /// Offset: 0x0090
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP0_BASE2;

    /// Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
    /// Offset: 0x0094
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP0_POP_LANE0;

    /// Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
    /// Offset: 0x0098
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP0_POP_LANE1;

    /// Read FULL result, and simultaneously write lane results to both accumulators (POP).
    /// Offset: 0x009C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP0_POP_FULL;

    /// Read LANE0 result, without altering any internal state (PEEK).
    /// Offset: 0x00A0
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP0_PEEK_LANE0;

    /// Read LANE1 result, without altering any internal state (PEEK).
    /// Offset: 0x00A4
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP0_PEEK_LANE1;

    /// Read FULL result, without altering any internal state (PEEK).
    /// Offset: 0x00A8
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP0_PEEK_FULL;

    /// Control register for lane 0
    /// Offset: 0x00AC
    /// Reset value: 0x00000000
    volatile uint32_t INTERP0_CTRL_LANE0;

    /// Control register for lane 1
    /// Offset: 0x00B0
    /// Reset value: 0x00000000
    volatile uint32_t INTERP0_CTRL_LANE1;

    /// Values written here are atomically added to ACCUM0\n
            Reading yields lane 0's raw shift and mask value (BASE0 not added).
    /// Offset: 0x00B4
    /// Reset value: 0x00000000
    volatile uint32_t INTERP0_ACCUM0_ADD;

    /// Values written here are atomically added to ACCUM1\n
            Reading yields lane 1's raw shift and mask value (BASE1 not added).
    /// Offset: 0x00B8
    /// Reset value: 0x00000000
    volatile uint32_t INTERP0_ACCUM1_ADD;

    /// On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\n
            Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
    /// Offset: 0x00BC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP0_BASE_1AND0;

    /// Read/write access to accumulator 0
    /// Offset: 0x00C0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP1_ACCUM0;

    /// Read/write access to accumulator 1
    /// Offset: 0x00C4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP1_ACCUM1;

    /// Read/write access to BASE0 register.
    /// Offset: 0x00C8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP1_BASE0;

    /// Read/write access to BASE1 register.
    /// Offset: 0x00CC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP1_BASE1;

    /// Read/write access to BASE2 register.
    /// Offset: 0x00D0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP1_BASE2;

    /// Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
    /// Offset: 0x00D4
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP1_POP_LANE0;

    /// Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
    /// Offset: 0x00D8
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP1_POP_LANE1;

    /// Read FULL result, and simultaneously write lane results to both accumulators (POP).
    /// Offset: 0x00DC
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP1_POP_FULL;

    /// Read LANE0 result, without altering any internal state (PEEK).
    /// Offset: 0x00E0
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP1_PEEK_LANE0;

    /// Read LANE1 result, without altering any internal state (PEEK).
    /// Offset: 0x00E4
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP1_PEEK_LANE1;

    /// Read FULL result, without altering any internal state (PEEK).
    /// Offset: 0x00E8
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t INTERP1_PEEK_FULL;

    /// Control register for lane 0
    /// Offset: 0x00EC
    /// Reset value: 0x00000000
    volatile uint32_t INTERP1_CTRL_LANE0;

    /// Control register for lane 1
    /// Offset: 0x00F0
    /// Reset value: 0x00000000
    volatile uint32_t INTERP1_CTRL_LANE1;

    /// Values written here are atomically added to ACCUM0\n
            Reading yields lane 0's raw shift and mask value (BASE0 not added).
    /// Offset: 0x00F4
    /// Reset value: 0x00000000
    volatile uint32_t INTERP1_ACCUM0_ADD;

    /// Values written here are atomically added to ACCUM1\n
            Reading yields lane 1's raw shift and mask value (BASE1 not added).
    /// Offset: 0x00F8
    /// Reset value: 0x00000000
    volatile uint32_t INTERP1_ACCUM1_ADD;

    /// On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\n
            Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
    /// Offset: 0x00FC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t INTERP1_BASE_1AND0;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0100
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK0;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0104
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK1;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0108
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK2;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x010C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK3;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0110
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK4;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0114
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK5;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0118
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK6;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x011C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK7;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0120
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK8;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0124
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK9;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0128
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK10;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x012C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK11;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0130
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK12;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0134
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK13;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0138
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK14;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x013C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK15;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0140
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK16;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0144
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK17;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0148
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK18;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x014C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK19;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0150
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK20;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0154
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK21;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0158
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK22;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x015C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK23;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0160
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK24;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0164
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK25;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0168
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK26;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x016C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK27;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0170
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK28;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0174
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK29;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x0178
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK30;

    /// Reading from a spinlock address will:\n
            - Return 0 if lock is already locked\n
            - Otherwise return nonzero, and simultaneously claim the lock\n\n
            Writing (any value) releases the lock.\n
            If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n
            The value returned on success is 0x1 << lock number.
    /// Offset: 0x017C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SPINLOCK31;
};

static_assert(sizeof(SIO_Registers) >= 384, "SIO_Registers size mismatch");

/// SIO peripheral instance
inline SIO_Registers* SIO() {
    return reinterpret_cast<SIO_Registers*>(0xD0000000);
}

}  // namespace alloy::hal::raspberrypi::rp2040::rp2040::sio
