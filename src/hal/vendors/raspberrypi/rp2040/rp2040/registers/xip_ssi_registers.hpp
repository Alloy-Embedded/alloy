/// Auto-generated register definitions for XIP_SSI
/// Device: RP2040
/// Vendor: Raspberry Pi
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

namespace alloy::hal::raspberrypi::rp2040::rp2040::xip_ssi {

// ============================================================================
// XIP_SSI - DW_apb_ssi has the following features:\n
        * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation.\n
        * APB3 and APB4 protocol support.\n
        * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits.\n
        * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices.\n
        * Programmable Dual/Quad/Octal SPI support in Master Mode.\n
        * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation.\n
        * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes.\n
        * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes.\n
        * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests.\n
        * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently.\n
        * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus.\n
        * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains.\n
        * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates.\n
        * Programmable features:\n
        - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire.\n
        - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation.\n
        - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer.\n
        * Configured features:\n
        - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.\n
        - 1 slave select output.\n
        - Hardware slave-select – Dedicated hardware slave-select line.\n
        - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller.\n
        - Interrupt polarity – active high interrupt lines.\n
        - Serial clock polarity – low serial-clock polarity directly after reset.\n
        - Serial clock phase – capture on first edge of serial-clock directly after reset.
// Base Address: 0x18000000
// ============================================================================

/// XIP_SSI Register Structure
struct XIP_SSI_Registers {

    /// Control register 0
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    volatile uint32_t CTRLR0;

    /// Master Control register 1
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    volatile uint32_t CTRLR1;

    /// SSI Enable
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    volatile uint32_t SSIENR;

    /// Microwire Control
    /// Offset: 0x000C
    /// Reset value: 0x00000000
    volatile uint32_t MWCR;

    /// Slave enable
    /// Offset: 0x0010
    /// Reset value: 0x00000000
    volatile uint32_t SER;

    /// Baud rate
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    volatile uint32_t BAUDR;

    /// TX FIFO threshold level
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    volatile uint32_t TXFTLR;

    /// RX FIFO threshold level
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    volatile uint32_t RXFTLR;

    /// TX FIFO level
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    volatile uint32_t TXFLR;

    /// RX FIFO level
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    volatile uint32_t RXFLR;

    /// Status register
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    volatile uint32_t SR;

    /// Interrupt mask
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    volatile uint32_t IMR;

    /// Interrupt status
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    volatile uint32_t ISR;

    /// Raw interrupt status
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    volatile uint32_t RISR;

    /// TX FIFO overflow interrupt clear
    /// Offset: 0x0038
    /// Reset value: 0x00000000
    volatile uint32_t TXOICR;

    /// RX FIFO overflow interrupt clear
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    volatile uint32_t RXOICR;

    /// RX FIFO underflow interrupt clear
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    volatile uint32_t RXUICR;

    /// Multi-master interrupt clear
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    volatile uint32_t MSTICR;

    /// Interrupt clear
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    volatile uint32_t ICR;

    /// DMA control
    /// Offset: 0x004C
    /// Reset value: 0x00000000
    volatile uint32_t DMACR;

    /// DMA TX data level
    /// Offset: 0x0050
    /// Reset value: 0x00000000
    volatile uint32_t DMATDLR;

    /// DMA RX data level
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    volatile uint32_t DMARDLR;

    /// Identification register
    /// Offset: 0x0058
    /// Reset value: 0x51535049
    volatile uint32_t IDR;

    /// Version ID
    /// Offset: 0x005C
    /// Reset value: 0x3430312A
    volatile uint32_t SSI_VERSION_ID;

    /// Data Register 0 (of 36)
    /// Offset: 0x0060
    /// Reset value: 0x00000000
    volatile uint32_t DR0;
    uint8_t RESERVED_0064[140]; ///< Reserved

    /// RX sample delay
    /// Offset: 0x00F0
    /// Reset value: 0x00000000
    volatile uint32_t RX_SAMPLE_DLY;

    /// SPI control
    /// Offset: 0x00F4
    /// Reset value: 0x03000000
    volatile uint32_t SPI_CTRLR0;

    /// TX drive edge
    /// Offset: 0x00F8
    /// Reset value: 0x00000000
    volatile uint32_t TXD_DRIVE_EDGE;
};

static_assert(sizeof(XIP_SSI_Registers) >= 252, "XIP_SSI_Registers size mismatch");

/// XIP_SSI peripheral instance
inline XIP_SSI_Registers* XIP_SSI() {
    return reinterpret_cast<XIP_SSI_Registers*>(0x18000000);
}

}  // namespace alloy::hal::raspberrypi::rp2040::rp2040::xip_ssi
