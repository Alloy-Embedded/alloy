/// Auto-generated register definitions for TIM6
/// Device: STM32F103xx
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

namespace alloy::hal::st::stm32f1::stm32f103xx::tim6 {

// ============================================================================
// TIM6 - Basic timer
// Base Address: 0x40001000
// ============================================================================

/// TIM6 Register Structure
struct TIM6_Registers {

    /// control register 1
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CR1;

    /// control register 2
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CR2;
    uint8_t RESERVED_0008[4]; ///< Reserved

    /// DMA/Interrupt enable register
    /// Offset: 0x000C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DIER;

    /// status register
    /// Offset: 0x0010
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SR;

    /// event generation register
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    /// Access: write-only
    volatile uint32_t EGR;
    uint8_t RESERVED_0018[12]; ///< Reserved

    /// counter
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CNT;

    /// prescaler
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t PSC;

    /// auto-reload register
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ARR;
};

static_assert(sizeof(TIM6_Registers) >= 48, "TIM6_Registers size mismatch");

/// TIM6 peripheral instance
inline TIM6_Registers* TIM6() {
    return reinterpret_cast<TIM6_Registers*>(0x40001000);
}

}  // namespace alloy::hal::st::stm32f1::stm32f103xx::tim6
