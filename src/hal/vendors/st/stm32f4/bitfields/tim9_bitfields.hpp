/// Auto-generated bit field definitions for TIM9
/// Family: stm32f4
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32f4::tim9 {

using namespace alloy::hal::bitfields;

// ============================================================================
// TIM9 Bit Field Definitions
// ============================================================================

/// CR1 - control register 1
namespace cr1 {
/// Counter enable
/// Position: 0, Width: 1
using CEN = BitField<0, 1>;
constexpr uint32_t CEN_Pos = 0;
constexpr uint32_t CEN_Msk = CEN::mask;

/// Update disable
/// Position: 1, Width: 1
using UDIS = BitField<1, 1>;
constexpr uint32_t UDIS_Pos = 1;
constexpr uint32_t UDIS_Msk = UDIS::mask;

/// Update request source
/// Position: 2, Width: 1
using URS = BitField<2, 1>;
constexpr uint32_t URS_Pos = 2;
constexpr uint32_t URS_Msk = URS::mask;

/// One-pulse mode
/// Position: 3, Width: 1
using OPM = BitField<3, 1>;
constexpr uint32_t OPM_Pos = 3;
constexpr uint32_t OPM_Msk = OPM::mask;

/// Auto-reload preload enable
/// Position: 7, Width: 1
using ARPE = BitField<7, 1>;
constexpr uint32_t ARPE_Pos = 7;
constexpr uint32_t ARPE_Msk = ARPE::mask;

/// Clock division
/// Position: 8, Width: 2
using CKD = BitField<8, 2>;
constexpr uint32_t CKD_Pos = 8;
constexpr uint32_t CKD_Msk = CKD::mask;

}  // namespace cr1

/// CR2 - control register 2
namespace cr2 {
/// Master mode selection
/// Position: 4, Width: 3
using MMS = BitField<4, 3>;
constexpr uint32_t MMS_Pos = 4;
constexpr uint32_t MMS_Msk = MMS::mask;

}  // namespace cr2

/// SMCR - slave mode control register
namespace smcr {
/// Slave mode selection
/// Position: 0, Width: 3
using SMS = BitField<0, 3>;
constexpr uint32_t SMS_Pos = 0;
constexpr uint32_t SMS_Msk = SMS::mask;

/// Trigger selection
/// Position: 4, Width: 3
using TS = BitField<4, 3>;
constexpr uint32_t TS_Pos = 4;
constexpr uint32_t TS_Msk = TS::mask;

/// Master/Slave mode
/// Position: 7, Width: 1
using MSM = BitField<7, 1>;
constexpr uint32_t MSM_Pos = 7;
constexpr uint32_t MSM_Msk = MSM::mask;

}  // namespace smcr

/// DIER - DMA/Interrupt enable register
namespace dier {
/// Update interrupt enable
/// Position: 0, Width: 1
using UIE = BitField<0, 1>;
constexpr uint32_t UIE_Pos = 0;
constexpr uint32_t UIE_Msk = UIE::mask;

/// Capture/Compare 1 interrupt enable
/// Position: 1, Width: 1
using CC1IE = BitField<1, 1>;
constexpr uint32_t CC1IE_Pos = 1;
constexpr uint32_t CC1IE_Msk = CC1IE::mask;

/// Capture/Compare 2 interrupt enable
/// Position: 2, Width: 1
using CC2IE = BitField<2, 1>;
constexpr uint32_t CC2IE_Pos = 2;
constexpr uint32_t CC2IE_Msk = CC2IE::mask;

/// Trigger interrupt enable
/// Position: 6, Width: 1
using TIE = BitField<6, 1>;
constexpr uint32_t TIE_Pos = 6;
constexpr uint32_t TIE_Msk = TIE::mask;

}  // namespace dier

/// SR - status register
namespace sr {
/// Update interrupt flag
/// Position: 0, Width: 1
using UIF = BitField<0, 1>;
constexpr uint32_t UIF_Pos = 0;
constexpr uint32_t UIF_Msk = UIF::mask;

/// Capture/compare 1 interrupt flag
/// Position: 1, Width: 1
using CC1IF = BitField<1, 1>;
constexpr uint32_t CC1IF_Pos = 1;
constexpr uint32_t CC1IF_Msk = CC1IF::mask;

/// Capture/Compare 2 interrupt flag
/// Position: 2, Width: 1
using CC2IF = BitField<2, 1>;
constexpr uint32_t CC2IF_Pos = 2;
constexpr uint32_t CC2IF_Msk = CC2IF::mask;

/// Trigger interrupt flag
/// Position: 6, Width: 1
using TIF = BitField<6, 1>;
constexpr uint32_t TIF_Pos = 6;
constexpr uint32_t TIF_Msk = TIF::mask;

/// Capture/Compare 1 overcapture flag
/// Position: 9, Width: 1
using CC1OF = BitField<9, 1>;
constexpr uint32_t CC1OF_Pos = 9;
constexpr uint32_t CC1OF_Msk = CC1OF::mask;

/// Capture/compare 2 overcapture flag
/// Position: 10, Width: 1
using CC2OF = BitField<10, 1>;
constexpr uint32_t CC2OF_Pos = 10;
constexpr uint32_t CC2OF_Msk = CC2OF::mask;

}  // namespace sr

/// EGR - event generation register
namespace egr {
/// Update generation
/// Position: 0, Width: 1
using UG = BitField<0, 1>;
constexpr uint32_t UG_Pos = 0;
constexpr uint32_t UG_Msk = UG::mask;

/// Capture/compare 1 generation
/// Position: 1, Width: 1
using CC1G = BitField<1, 1>;
constexpr uint32_t CC1G_Pos = 1;
constexpr uint32_t CC1G_Msk = CC1G::mask;

/// Capture/compare 2 generation
/// Position: 2, Width: 1
using CC2G = BitField<2, 1>;
constexpr uint32_t CC2G_Pos = 2;
constexpr uint32_t CC2G_Msk = CC2G::mask;

/// Trigger generation
/// Position: 6, Width: 1
using TG = BitField<6, 1>;
constexpr uint32_t TG_Pos = 6;
constexpr uint32_t TG_Msk = TG::mask;

}  // namespace egr

/// CCMR1_Output - capture/compare mode register 1 (output mode)
namespace ccmr1_output {
/// Capture/Compare 1 selection
/// Position: 0, Width: 2
using CC1S = BitField<0, 2>;
constexpr uint32_t CC1S_Pos = 0;
constexpr uint32_t CC1S_Msk = CC1S::mask;

/// Output Compare 1 fast enable
/// Position: 2, Width: 1
using OC1FE = BitField<2, 1>;
constexpr uint32_t OC1FE_Pos = 2;
constexpr uint32_t OC1FE_Msk = OC1FE::mask;

/// Output Compare 1 preload enable
/// Position: 3, Width: 1
using OC1PE = BitField<3, 1>;
constexpr uint32_t OC1PE_Pos = 3;
constexpr uint32_t OC1PE_Msk = OC1PE::mask;

/// Output Compare 1 mode
/// Position: 4, Width: 3
using OC1M = BitField<4, 3>;
constexpr uint32_t OC1M_Pos = 4;
constexpr uint32_t OC1M_Msk = OC1M::mask;

/// Capture/Compare 2 selection
/// Position: 8, Width: 2
using CC2S = BitField<8, 2>;
constexpr uint32_t CC2S_Pos = 8;
constexpr uint32_t CC2S_Msk = CC2S::mask;

/// Output Compare 2 fast enable
/// Position: 10, Width: 1
using OC2FE = BitField<10, 1>;
constexpr uint32_t OC2FE_Pos = 10;
constexpr uint32_t OC2FE_Msk = OC2FE::mask;

/// Output Compare 2 preload enable
/// Position: 11, Width: 1
using OC2PE = BitField<11, 1>;
constexpr uint32_t OC2PE_Pos = 11;
constexpr uint32_t OC2PE_Msk = OC2PE::mask;

/// Output Compare 2 mode
/// Position: 12, Width: 3
using OC2M = BitField<12, 3>;
constexpr uint32_t OC2M_Pos = 12;
constexpr uint32_t OC2M_Msk = OC2M::mask;

}  // namespace ccmr1_output

/// CCMR1_Input - capture/compare mode register 1 (input mode)
namespace ccmr1_input {
/// Capture/Compare 1 selection
/// Position: 0, Width: 2
using CC1S = BitField<0, 2>;
constexpr uint32_t CC1S_Pos = 0;
constexpr uint32_t CC1S_Msk = CC1S::mask;

/// Input capture 1 prescaler
/// Position: 2, Width: 2
using ICPCS = BitField<2, 2>;
constexpr uint32_t ICPCS_Pos = 2;
constexpr uint32_t ICPCS_Msk = ICPCS::mask;

/// Input capture 1 filter
/// Position: 4, Width: 3
using IC1F = BitField<4, 3>;
constexpr uint32_t IC1F_Pos = 4;
constexpr uint32_t IC1F_Msk = IC1F::mask;

/// Capture/Compare 2 selection
/// Position: 8, Width: 2
using CC2S = BitField<8, 2>;
constexpr uint32_t CC2S_Pos = 8;
constexpr uint32_t CC2S_Msk = CC2S::mask;

/// Input capture 2 prescaler
/// Position: 10, Width: 2
using IC2PCS = BitField<10, 2>;
constexpr uint32_t IC2PCS_Pos = 10;
constexpr uint32_t IC2PCS_Msk = IC2PCS::mask;

/// Input capture 2 filter
/// Position: 12, Width: 3
using IC2F = BitField<12, 3>;
constexpr uint32_t IC2F_Pos = 12;
constexpr uint32_t IC2F_Msk = IC2F::mask;

}  // namespace ccmr1_input

/// CCER - capture/compare enable register
namespace ccer {
/// Capture/Compare 1 output enable
/// Position: 0, Width: 1
using CC1E = BitField<0, 1>;
constexpr uint32_t CC1E_Pos = 0;
constexpr uint32_t CC1E_Msk = CC1E::mask;

/// Capture/Compare 1 output Polarity
/// Position: 1, Width: 1
using CC1P = BitField<1, 1>;
constexpr uint32_t CC1P_Pos = 1;
constexpr uint32_t CC1P_Msk = CC1P::mask;

/// Capture/Compare 1 output Polarity
/// Position: 3, Width: 1
using CC1NP = BitField<3, 1>;
constexpr uint32_t CC1NP_Pos = 3;
constexpr uint32_t CC1NP_Msk = CC1NP::mask;

/// Capture/Compare 2 output enable
/// Position: 4, Width: 1
using CC2E = BitField<4, 1>;
constexpr uint32_t CC2E_Pos = 4;
constexpr uint32_t CC2E_Msk = CC2E::mask;

/// Capture/Compare 2 output Polarity
/// Position: 5, Width: 1
using CC2P = BitField<5, 1>;
constexpr uint32_t CC2P_Pos = 5;
constexpr uint32_t CC2P_Msk = CC2P::mask;

/// Capture/Compare 2 output Polarity
/// Position: 7, Width: 1
using CC2NP = BitField<7, 1>;
constexpr uint32_t CC2NP_Pos = 7;
constexpr uint32_t CC2NP_Msk = CC2NP::mask;

}  // namespace ccer

/// CNT - counter
namespace cnt {
/// counter value
/// Position: 0, Width: 16
using CNT = BitField<0, 16>;
constexpr uint32_t CNT_Pos = 0;
constexpr uint32_t CNT_Msk = CNT::mask;

}  // namespace cnt

/// PSC - prescaler
namespace psc {
/// Prescaler value
/// Position: 0, Width: 16
using PSC = BitField<0, 16>;
constexpr uint32_t PSC_Pos = 0;
constexpr uint32_t PSC_Msk = PSC::mask;

}  // namespace psc

/// ARR - auto-reload register
namespace arr {
/// Auto-reload value
/// Position: 0, Width: 16
using ARR = BitField<0, 16>;
constexpr uint32_t ARR_Pos = 0;
constexpr uint32_t ARR_Msk = ARR::mask;

}  // namespace arr

/// CCR1 - capture/compare register 1
namespace ccr1 {
/// Capture/Compare 1 value
/// Position: 0, Width: 16
using CCR1 = BitField<0, 16>;
constexpr uint32_t CCR1_Pos = 0;
constexpr uint32_t CCR1_Msk = CCR1::mask;

}  // namespace ccr1

/// CCR2 - capture/compare register 2
namespace ccr2 {
/// Capture/Compare 2 value
/// Position: 0, Width: 16
using CCR2 = BitField<0, 16>;
constexpr uint32_t CCR2_Pos = 0;
constexpr uint32_t CCR2_Msk = CCR2::mask;

}  // namespace ccr2

}  // namespace alloy::hal::st::stm32f4::tim9
