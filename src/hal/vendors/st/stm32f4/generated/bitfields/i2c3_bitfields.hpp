/// Auto-generated bit field definitions for I2C3
/// Family: stm32f4
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32f4::i2c3 {

using namespace alloy::hal::bitfields;

// ============================================================================
// I2C3 Bit Field Definitions
// ============================================================================

/// CR1 - Control register 1
namespace cr1 {
    /// Peripheral enable
    /// Position: 0, Width: 1
    using PE = BitField<0, 1>;
    constexpr uint32_t PE_Pos = 0;
    constexpr uint32_t PE_Msk = PE::mask;

    /// SMBus mode
    /// Position: 1, Width: 1
    using SMBUS = BitField<1, 1>;
    constexpr uint32_t SMBUS_Pos = 1;
    constexpr uint32_t SMBUS_Msk = SMBUS::mask;

    /// SMBus type
    /// Position: 3, Width: 1
    using SMBTYPE = BitField<3, 1>;
    constexpr uint32_t SMBTYPE_Pos = 3;
    constexpr uint32_t SMBTYPE_Msk = SMBTYPE::mask;

    /// ARP enable
    /// Position: 4, Width: 1
    using ENARP = BitField<4, 1>;
    constexpr uint32_t ENARP_Pos = 4;
    constexpr uint32_t ENARP_Msk = ENARP::mask;

    /// PEC enable
    /// Position: 5, Width: 1
    using ENPEC = BitField<5, 1>;
    constexpr uint32_t ENPEC_Pos = 5;
    constexpr uint32_t ENPEC_Msk = ENPEC::mask;

    /// General call enable
    /// Position: 6, Width: 1
    using ENGC = BitField<6, 1>;
    constexpr uint32_t ENGC_Pos = 6;
    constexpr uint32_t ENGC_Msk = ENGC::mask;

    /// Clock stretching disable (Slave mode)
    /// Position: 7, Width: 1
    using NOSTRETCH = BitField<7, 1>;
    constexpr uint32_t NOSTRETCH_Pos = 7;
    constexpr uint32_t NOSTRETCH_Msk = NOSTRETCH::mask;

    /// Start generation
    /// Position: 8, Width: 1
    using START = BitField<8, 1>;
    constexpr uint32_t START_Pos = 8;
    constexpr uint32_t START_Msk = START::mask;

    /// Stop generation
    /// Position: 9, Width: 1
    using STOP = BitField<9, 1>;
    constexpr uint32_t STOP_Pos = 9;
    constexpr uint32_t STOP_Msk = STOP::mask;

    /// Acknowledge enable
    /// Position: 10, Width: 1
    using ACK = BitField<10, 1>;
    constexpr uint32_t ACK_Pos = 10;
    constexpr uint32_t ACK_Msk = ACK::mask;

    /// Acknowledge/PEC Position (for data reception)
    /// Position: 11, Width: 1
    using POS = BitField<11, 1>;
    constexpr uint32_t POS_Pos = 11;
    constexpr uint32_t POS_Msk = POS::mask;

    /// Packet error checking
    /// Position: 12, Width: 1
    using PEC = BitField<12, 1>;
    constexpr uint32_t PEC_Pos = 12;
    constexpr uint32_t PEC_Msk = PEC::mask;

    /// SMBus alert
    /// Position: 13, Width: 1
    using ALERT = BitField<13, 1>;
    constexpr uint32_t ALERT_Pos = 13;
    constexpr uint32_t ALERT_Msk = ALERT::mask;

    /// Software reset
    /// Position: 15, Width: 1
    using SWRST = BitField<15, 1>;
    constexpr uint32_t SWRST_Pos = 15;
    constexpr uint32_t SWRST_Msk = SWRST::mask;

}  // namespace cr1

/// CR2 - Control register 2
namespace cr2 {
    /// Peripheral clock frequency
    /// Position: 0, Width: 6
    using FREQ = BitField<0, 6>;
    constexpr uint32_t FREQ_Pos = 0;
    constexpr uint32_t FREQ_Msk = FREQ::mask;

    /// Error interrupt enable
    /// Position: 8, Width: 1
    using ITERREN = BitField<8, 1>;
    constexpr uint32_t ITERREN_Pos = 8;
    constexpr uint32_t ITERREN_Msk = ITERREN::mask;

    /// Event interrupt enable
    /// Position: 9, Width: 1
    using ITEVTEN = BitField<9, 1>;
    constexpr uint32_t ITEVTEN_Pos = 9;
    constexpr uint32_t ITEVTEN_Msk = ITEVTEN::mask;

    /// Buffer interrupt enable
    /// Position: 10, Width: 1
    using ITBUFEN = BitField<10, 1>;
    constexpr uint32_t ITBUFEN_Pos = 10;
    constexpr uint32_t ITBUFEN_Msk = ITBUFEN::mask;

    /// DMA requests enable
    /// Position: 11, Width: 1
    using DMAEN = BitField<11, 1>;
    constexpr uint32_t DMAEN_Pos = 11;
    constexpr uint32_t DMAEN_Msk = DMAEN::mask;

    /// DMA last transfer
    /// Position: 12, Width: 1
    using LAST = BitField<12, 1>;
    constexpr uint32_t LAST_Pos = 12;
    constexpr uint32_t LAST_Msk = LAST::mask;

}  // namespace cr2

/// OAR1 - Own address register 1
namespace oar1 {
    /// Interface address
    /// Position: 0, Width: 1
    using ADD0 = BitField<0, 1>;
    constexpr uint32_t ADD0_Pos = 0;
    constexpr uint32_t ADD0_Msk = ADD0::mask;

    /// Interface address
    /// Position: 1, Width: 7
    using ADD7 = BitField<1, 7>;
    constexpr uint32_t ADD7_Pos = 1;
    constexpr uint32_t ADD7_Msk = ADD7::mask;

    /// Interface address
    /// Position: 8, Width: 2
    using ADD10 = BitField<8, 2>;
    constexpr uint32_t ADD10_Pos = 8;
    constexpr uint32_t ADD10_Msk = ADD10::mask;

    /// Addressing mode (slave mode)
    /// Position: 15, Width: 1
    using ADDMODE = BitField<15, 1>;
    constexpr uint32_t ADDMODE_Pos = 15;
    constexpr uint32_t ADDMODE_Msk = ADDMODE::mask;

}  // namespace oar1

/// OAR2 - Own address register 2
namespace oar2 {
    /// Dual addressing mode enable
    /// Position: 0, Width: 1
    using ENDUAL = BitField<0, 1>;
    constexpr uint32_t ENDUAL_Pos = 0;
    constexpr uint32_t ENDUAL_Msk = ENDUAL::mask;

    /// Interface address
    /// Position: 1, Width: 7
    using ADD2 = BitField<1, 7>;
    constexpr uint32_t ADD2_Pos = 1;
    constexpr uint32_t ADD2_Msk = ADD2::mask;

}  // namespace oar2

/// DR - Data register
namespace dr {
    /// 8-bit data register
    /// Position: 0, Width: 8
    using DR = BitField<0, 8>;
    constexpr uint32_t DR_Pos = 0;
    constexpr uint32_t DR_Msk = DR::mask;

}  // namespace dr

/// SR1 - Status register 1
namespace sr1 {
    /// Start bit (Master mode)
    /// Position: 0, Width: 1
    /// Access: read-only
    using SB = BitField<0, 1>;
    constexpr uint32_t SB_Pos = 0;
    constexpr uint32_t SB_Msk = SB::mask;

    /// Address sent (master mode)/matched (slave mode)
    /// Position: 1, Width: 1
    /// Access: read-only
    using ADDR = BitField<1, 1>;
    constexpr uint32_t ADDR_Pos = 1;
    constexpr uint32_t ADDR_Msk = ADDR::mask;

    /// Byte transfer finished
    /// Position: 2, Width: 1
    /// Access: read-only
    using BTF = BitField<2, 1>;
    constexpr uint32_t BTF_Pos = 2;
    constexpr uint32_t BTF_Msk = BTF::mask;

    /// 10-bit header sent (Master mode)
    /// Position: 3, Width: 1
    /// Access: read-only
    using ADD10 = BitField<3, 1>;
    constexpr uint32_t ADD10_Pos = 3;
    constexpr uint32_t ADD10_Msk = ADD10::mask;

    /// Stop detection (slave mode)
    /// Position: 4, Width: 1
    /// Access: read-only
    using STOPF = BitField<4, 1>;
    constexpr uint32_t STOPF_Pos = 4;
    constexpr uint32_t STOPF_Msk = STOPF::mask;

    /// Data register not empty (receivers)
    /// Position: 6, Width: 1
    /// Access: read-only
    using RxNE = BitField<6, 1>;
    constexpr uint32_t RxNE_Pos = 6;
    constexpr uint32_t RxNE_Msk = RxNE::mask;

    /// Data register empty (transmitters)
    /// Position: 7, Width: 1
    /// Access: read-only
    using TxE = BitField<7, 1>;
    constexpr uint32_t TxE_Pos = 7;
    constexpr uint32_t TxE_Msk = TxE::mask;

    /// Bus error
    /// Position: 8, Width: 1
    /// Access: read-write
    using BERR = BitField<8, 1>;
    constexpr uint32_t BERR_Pos = 8;
    constexpr uint32_t BERR_Msk = BERR::mask;

    /// Arbitration lost (master mode)
    /// Position: 9, Width: 1
    /// Access: read-write
    using ARLO = BitField<9, 1>;
    constexpr uint32_t ARLO_Pos = 9;
    constexpr uint32_t ARLO_Msk = ARLO::mask;

    /// Acknowledge failure
    /// Position: 10, Width: 1
    /// Access: read-write
    using AF = BitField<10, 1>;
    constexpr uint32_t AF_Pos = 10;
    constexpr uint32_t AF_Msk = AF::mask;

    /// Overrun/Underrun
    /// Position: 11, Width: 1
    /// Access: read-write
    using OVR = BitField<11, 1>;
    constexpr uint32_t OVR_Pos = 11;
    constexpr uint32_t OVR_Msk = OVR::mask;

    /// PEC Error in reception
    /// Position: 12, Width: 1
    /// Access: read-write
    using PECERR = BitField<12, 1>;
    constexpr uint32_t PECERR_Pos = 12;
    constexpr uint32_t PECERR_Msk = PECERR::mask;

    /// Timeout or Tlow error
    /// Position: 14, Width: 1
    /// Access: read-write
    using TIMEOUT = BitField<14, 1>;
    constexpr uint32_t TIMEOUT_Pos = 14;
    constexpr uint32_t TIMEOUT_Msk = TIMEOUT::mask;

    /// SMBus alert
    /// Position: 15, Width: 1
    /// Access: read-write
    using SMBALERT = BitField<15, 1>;
    constexpr uint32_t SMBALERT_Pos = 15;
    constexpr uint32_t SMBALERT_Msk = SMBALERT::mask;

}  // namespace sr1

/// SR2 - Status register 2
namespace sr2 {
    /// Master/slave
    /// Position: 0, Width: 1
    using MSL = BitField<0, 1>;
    constexpr uint32_t MSL_Pos = 0;
    constexpr uint32_t MSL_Msk = MSL::mask;

    /// Bus busy
    /// Position: 1, Width: 1
    using BUSY = BitField<1, 1>;
    constexpr uint32_t BUSY_Pos = 1;
    constexpr uint32_t BUSY_Msk = BUSY::mask;

    /// Transmitter/receiver
    /// Position: 2, Width: 1
    using TRA = BitField<2, 1>;
    constexpr uint32_t TRA_Pos = 2;
    constexpr uint32_t TRA_Msk = TRA::mask;

    /// General call address (Slave mode)
    /// Position: 4, Width: 1
    using GENCALL = BitField<4, 1>;
    constexpr uint32_t GENCALL_Pos = 4;
    constexpr uint32_t GENCALL_Msk = GENCALL::mask;

    /// SMBus device default address (Slave mode)
    /// Position: 5, Width: 1
    using SMBDEFAULT = BitField<5, 1>;
    constexpr uint32_t SMBDEFAULT_Pos = 5;
    constexpr uint32_t SMBDEFAULT_Msk = SMBDEFAULT::mask;

    /// SMBus host header (Slave mode)
    /// Position: 6, Width: 1
    using SMBHOST = BitField<6, 1>;
    constexpr uint32_t SMBHOST_Pos = 6;
    constexpr uint32_t SMBHOST_Msk = SMBHOST::mask;

    /// Dual flag (Slave mode)
    /// Position: 7, Width: 1
    using DUALF = BitField<7, 1>;
    constexpr uint32_t DUALF_Pos = 7;
    constexpr uint32_t DUALF_Msk = DUALF::mask;

    /// acket error checking register
    /// Position: 8, Width: 8
    using PEC = BitField<8, 8>;
    constexpr uint32_t PEC_Pos = 8;
    constexpr uint32_t PEC_Msk = PEC::mask;

}  // namespace sr2

/// CCR - Clock control register
namespace ccr {
    /// Clock control register in Fast/Standard mode (Master mode)
    /// Position: 0, Width: 12
    using CCR = BitField<0, 12>;
    constexpr uint32_t CCR_Pos = 0;
    constexpr uint32_t CCR_Msk = CCR::mask;

    /// Fast mode duty cycle
    /// Position: 14, Width: 1
    using DUTY = BitField<14, 1>;
    constexpr uint32_t DUTY_Pos = 14;
    constexpr uint32_t DUTY_Msk = DUTY::mask;

    /// I2C master mode selection
    /// Position: 15, Width: 1
    using F_S = BitField<15, 1>;
    constexpr uint32_t F_S_Pos = 15;
    constexpr uint32_t F_S_Msk = F_S::mask;

}  // namespace ccr

/// TRISE - TRISE register
namespace trise {
    /// Maximum rise time in Fast/Standard mode (Master mode)
    /// Position: 0, Width: 6
    using TRISE = BitField<0, 6>;
    constexpr uint32_t TRISE_Pos = 0;
    constexpr uint32_t TRISE_Msk = TRISE::mask;

}  // namespace trise

}  // namespace alloy::hal::st::stm32f4::i2c3
