/// Auto-generated register definitions for HASH
/// Family: stm32f4
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::st::stm32f4::hash {

// ============================================================================
// HASH - Hash processor
// Base Address: 0x50060400
// ============================================================================

/// HASH Register Structure
struct HASH_Registers {

    /// control register
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    volatile uint32_t CR;

    /// data input register
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t DIN;

    /// start register
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    volatile uint32_t STR;

    /// digest registers
    /// Offset: 0x000C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HR0;

    /// digest registers
    /// Offset: 0x0010
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HR1;

    /// digest registers
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HR2;

    /// digest registers
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HR3;

    /// digest registers
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HR4;

    /// interrupt enable register
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t IMR;

    /// status register
    /// Offset: 0x0024
    /// Reset value: 0x00000001
    volatile uint32_t SR;
    uint8_t RESERVED_0028[208]; ///< Reserved

    /// context swap registers
    /// Offset: 0x00F8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR0;

    /// context swap registers
    /// Offset: 0x00FC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR1;

    /// context swap registers
    /// Offset: 0x0100
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR2;

    /// context swap registers
    /// Offset: 0x0104
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR3;

    /// context swap registers
    /// Offset: 0x0108
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR4;

    /// context swap registers
    /// Offset: 0x010C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR5;

    /// context swap registers
    /// Offset: 0x0110
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR6;

    /// context swap registers
    /// Offset: 0x0114
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR7;

    /// context swap registers
    /// Offset: 0x0118
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR8;

    /// context swap registers
    /// Offset: 0x011C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR9;

    /// context swap registers
    /// Offset: 0x0120
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR10;

    /// context swap registers
    /// Offset: 0x0124
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR11;

    /// context swap registers
    /// Offset: 0x0128
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR12;

    /// context swap registers
    /// Offset: 0x012C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR13;

    /// context swap registers
    /// Offset: 0x0130
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR14;

    /// context swap registers
    /// Offset: 0x0134
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR15;

    /// context swap registers
    /// Offset: 0x0138
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR16;

    /// context swap registers
    /// Offset: 0x013C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR17;

    /// context swap registers
    /// Offset: 0x0140
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR18;

    /// context swap registers
    /// Offset: 0x0144
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR19;

    /// context swap registers
    /// Offset: 0x0148
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR20;

    /// context swap registers
    /// Offset: 0x014C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR21;

    /// context swap registers
    /// Offset: 0x0150
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR22;

    /// context swap registers
    /// Offset: 0x0154
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR23;

    /// context swap registers
    /// Offset: 0x0158
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR24;

    /// context swap registers
    /// Offset: 0x015C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR25;

    /// context swap registers
    /// Offset: 0x0160
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR26;

    /// context swap registers
    /// Offset: 0x0164
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR27;

    /// context swap registers
    /// Offset: 0x0168
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR28;

    /// context swap registers
    /// Offset: 0x016C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR29;

    /// context swap registers
    /// Offset: 0x0170
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR30;

    /// context swap registers
    /// Offset: 0x0174
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR31;

    /// context swap registers
    /// Offset: 0x0178
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR32;

    /// context swap registers
    /// Offset: 0x017C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR33;

    /// context swap registers
    /// Offset: 0x0180
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR34;

    /// context swap registers
    /// Offset: 0x0184
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR35;

    /// context swap registers
    /// Offset: 0x0188
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR36;

    /// context swap registers
    /// Offset: 0x018C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR37;

    /// context swap registers
    /// Offset: 0x0190
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR38;

    /// context swap registers
    /// Offset: 0x0194
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR39;

    /// context swap registers
    /// Offset: 0x0198
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR40;

    /// context swap registers
    /// Offset: 0x019C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR41;

    /// context swap registers
    /// Offset: 0x01A0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR42;

    /// context swap registers
    /// Offset: 0x01A4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR43;

    /// context swap registers
    /// Offset: 0x01A8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR44;

    /// context swap registers
    /// Offset: 0x01AC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR45;

    /// context swap registers
    /// Offset: 0x01B0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR46;

    /// context swap registers
    /// Offset: 0x01B4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR47;

    /// context swap registers
    /// Offset: 0x01B8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR48;

    /// context swap registers
    /// Offset: 0x01BC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR49;

    /// context swap registers
    /// Offset: 0x01C0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR50;

    /// context swap registers
    /// Offset: 0x01C4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR51;

    /// context swap registers
    /// Offset: 0x01C8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR52;

    /// context swap registers
    /// Offset: 0x01CC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR53;
    uint8_t RESERVED_01D0[320]; ///< Reserved

    /// HASH digest register
    /// Offset: 0x0310
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HASH_HR0;

    /// read-only
    /// Offset: 0x0314
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HASH_HR1;

    /// read-only
    /// Offset: 0x0318
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HASH_HR2;

    /// read-only
    /// Offset: 0x031C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HASH_HR3;

    /// read-only
    /// Offset: 0x0320
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HASH_HR4;

    /// read-only
    /// Offset: 0x0324
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HASH_HR5;

    /// read-only
    /// Offset: 0x0328
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HASH_HR6;

    /// read-only
    /// Offset: 0x032C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t HASH_HR7;
};

static_assert(sizeof(HASH_Registers) >= 816, "HASH_Registers size mismatch");

/// HASH peripheral instance
inline HASH_Registers* HASH() {
    return reinterpret_cast<HASH_Registers*>(0x50060400);
}

}  // namespace alloy::hal::st::stm32f4::hash
