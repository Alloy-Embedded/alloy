/// Auto-generated register definitions for RTC
/// Family: stm32f4
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::st::stm32f4::rtc {

// ============================================================================
// RTC - Real-time clock
// Base Address: 0x40002800
// ============================================================================

/// RTC Register Structure
struct RTC_Registers {

    /// time register
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t TR;

    /// date register
    /// Offset: 0x0004
    /// Reset value: 0x00002101
    /// Access: read-write
    volatile uint32_t DR;

    /// control register
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CR;

    /// initialization and status register
    /// Offset: 0x000C
    /// Reset value: 0x00000007
    volatile uint32_t ISR;

    /// prescaler register
    /// Offset: 0x0010
    /// Reset value: 0x007F00FF
    /// Access: read-write
    volatile uint32_t PRER;

    /// wakeup timer register
    /// Offset: 0x0014
    /// Reset value: 0x0000FFFF
    /// Access: read-write
    volatile uint32_t WUTR;

    /// calibration register
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CALIBR;

    /// alarm A register
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALRMAR;

    /// alarm B register
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALRMBR;

    /// write protection register
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    /// Access: write-only
    volatile uint32_t WPR;

    /// sub second register
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SSR;

    /// shift control register
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    /// Access: write-only
    volatile uint32_t SHIFTR;

    /// time stamp time register
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t TSTR;

    /// time stamp date register
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t TSDR;

    /// timestamp sub second register
    /// Offset: 0x0038
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t TSSSR;

    /// calibration register
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CALR;

    /// tamper and alternate function configuration register
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t TAFCR;

    /// alarm A sub second register
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALRMASSR;

    /// alarm B sub second register
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALRMBSSR;
    uint8_t RESERVED_004C[4]; ///< Reserved

    /// backup register
    /// Offset: 0x0050
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP0R;

    /// backup register
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP1R;

    /// backup register
    /// Offset: 0x0058
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP2R;

    /// backup register
    /// Offset: 0x005C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP3R;

    /// backup register
    /// Offset: 0x0060
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP4R;

    /// backup register
    /// Offset: 0x0064
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP5R;

    /// backup register
    /// Offset: 0x0068
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP6R;

    /// backup register
    /// Offset: 0x006C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP7R;

    /// backup register
    /// Offset: 0x0070
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP8R;

    /// backup register
    /// Offset: 0x0074
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP9R;

    /// backup register
    /// Offset: 0x0078
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP10R;

    /// backup register
    /// Offset: 0x007C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP11R;

    /// backup register
    /// Offset: 0x0080
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP12R;

    /// backup register
    /// Offset: 0x0084
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP13R;

    /// backup register
    /// Offset: 0x0088
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP14R;

    /// backup register
    /// Offset: 0x008C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP15R;

    /// backup register
    /// Offset: 0x0090
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP16R;

    /// backup register
    /// Offset: 0x0094
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP17R;

    /// backup register
    /// Offset: 0x0098
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP18R;

    /// backup register
    /// Offset: 0x009C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP19R;
};

static_assert(sizeof(RTC_Registers) >= 160, "RTC_Registers size mismatch");

/// RTC peripheral instance
inline RTC_Registers* RTC() {
    return reinterpret_cast<RTC_Registers*>(0x40002800);
}

}  // namespace alloy::hal::st::stm32f4::rtc
