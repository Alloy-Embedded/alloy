/// Auto-generated register definitions for ADC1
/// Family: stm32f4
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::st::stm32f4::adc1 {

// ============================================================================
// ADC1 - Analog-to-digital converter
// Base Address: 0x40012000
// ============================================================================

/// ADC1 Register Structure
struct ADC1_Registers {

    /// status register
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SR;

    /// control register 1
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CR1;

    /// control register 2
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CR2;

    /// sample time register 1
    /// Offset: 0x000C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SMPR1;

    /// sample time register 2
    /// Offset: 0x0010
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SMPR2;

    /// injected channel data offset register x
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t JOFR1;

    /// injected channel data offset register x
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t JOFR2;

    /// injected channel data offset register x
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t JOFR3;

    /// injected channel data offset register x
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t JOFR4;

    /// watchdog higher threshold register
    /// Offset: 0x0024
    /// Reset value: 0x00000FFF
    /// Access: read-write
    volatile uint32_t HTR;

    /// watchdog lower threshold register
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t LTR;

    /// regular sequence register 1
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SQR1;

    /// regular sequence register 2
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SQR2;

    /// regular sequence register 3
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t SQR3;

    /// injected sequence register
    /// Offset: 0x0038
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t JSQR;

    /// injected data register x
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t JDR1;

    /// injected data register x
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t JDR2;

    /// injected data register x
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t JDR3;

    /// injected data register x
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t JDR4;

    /// regular data register
    /// Offset: 0x004C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t DR;
};

static_assert(sizeof(ADC1_Registers) >= 80, "ADC1_Registers size mismatch");

/// ADC1 peripheral instance
inline ADC1_Registers* ADC1() {
    return reinterpret_cast<ADC1_Registers*>(0x40012000);
}

}  // namespace alloy::hal::st::stm32f4::adc1
