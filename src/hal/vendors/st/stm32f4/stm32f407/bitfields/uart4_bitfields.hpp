/// Auto-generated bit field definitions for UART4
/// Device: STM32F407
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "bitfield_utils.hpp"

namespace alloy::hal::st::stm32f4::stm32f407::uart4 {

using namespace alloy::hal::bitfields;

// ============================================================================
// UART4 Bit Field Definitions
// ============================================================================

/// SR - Status register
namespace sr {
    /// Parity error
    /// Position: 0, Width: 1
    /// Access: read-only
    using PE = BitField<0, 1>;
    constexpr uint32_t PE_Pos = 0;
    constexpr uint32_t PE_Msk = PE::mask;

    /// Framing error
    /// Position: 1, Width: 1
    /// Access: read-only
    using FE = BitField<1, 1>;
    constexpr uint32_t FE_Pos = 1;
    constexpr uint32_t FE_Msk = FE::mask;

    /// Noise detected flag
    /// Position: 2, Width: 1
    /// Access: read-only
    using NF = BitField<2, 1>;
    constexpr uint32_t NF_Pos = 2;
    constexpr uint32_t NF_Msk = NF::mask;

    /// Overrun error
    /// Position: 3, Width: 1
    /// Access: read-only
    using ORE = BitField<3, 1>;
    constexpr uint32_t ORE_Pos = 3;
    constexpr uint32_t ORE_Msk = ORE::mask;

    /// IDLE line detected
    /// Position: 4, Width: 1
    /// Access: read-only
    using IDLE = BitField<4, 1>;
    constexpr uint32_t IDLE_Pos = 4;
    constexpr uint32_t IDLE_Msk = IDLE::mask;

    /// Read data register not
              empty
    /// Position: 5, Width: 1
    /// Access: read-write
    using RXNE = BitField<5, 1>;
    constexpr uint32_t RXNE_Pos = 5;
    constexpr uint32_t RXNE_Msk = RXNE::mask;

    /// Transmission complete
    /// Position: 6, Width: 1
    /// Access: read-write
    using TC = BitField<6, 1>;
    constexpr uint32_t TC_Pos = 6;
    constexpr uint32_t TC_Msk = TC::mask;

    /// Transmit data register
              empty
    /// Position: 7, Width: 1
    /// Access: read-only
    using TXE = BitField<7, 1>;
    constexpr uint32_t TXE_Pos = 7;
    constexpr uint32_t TXE_Msk = TXE::mask;

    /// LIN break detection flag
    /// Position: 8, Width: 1
    /// Access: read-write
    using LBD = BitField<8, 1>;
    constexpr uint32_t LBD_Pos = 8;
    constexpr uint32_t LBD_Msk = LBD::mask;

}  // namespace sr

/// DR - Data register
namespace dr {
    /// Data value
    /// Position: 0, Width: 9
    using DR = BitField<0, 9>;
    constexpr uint32_t DR_Pos = 0;
    constexpr uint32_t DR_Msk = DR::mask;

}  // namespace dr

/// BRR - Baud rate register
namespace brr {
    /// fraction of USARTDIV
    /// Position: 0, Width: 4
    using DIV_Fraction = BitField<0, 4>;
    constexpr uint32_t DIV_Fraction_Pos = 0;
    constexpr uint32_t DIV_Fraction_Msk = DIV_Fraction::mask;

    /// mantissa of USARTDIV
    /// Position: 4, Width: 12
    using DIV_Mantissa = BitField<4, 12>;
    constexpr uint32_t DIV_Mantissa_Pos = 4;
    constexpr uint32_t DIV_Mantissa_Msk = DIV_Mantissa::mask;

}  // namespace brr

/// CR1 - Control register 1
namespace cr1 {
    /// Send break
    /// Position: 0, Width: 1
    using SBK = BitField<0, 1>;
    constexpr uint32_t SBK_Pos = 0;
    constexpr uint32_t SBK_Msk = SBK::mask;

    /// Receiver wakeup
    /// Position: 1, Width: 1
    using RWU = BitField<1, 1>;
    constexpr uint32_t RWU_Pos = 1;
    constexpr uint32_t RWU_Msk = RWU::mask;

    /// Receiver enable
    /// Position: 2, Width: 1
    using RE = BitField<2, 1>;
    constexpr uint32_t RE_Pos = 2;
    constexpr uint32_t RE_Msk = RE::mask;

    /// Transmitter enable
    /// Position: 3, Width: 1
    using TE = BitField<3, 1>;
    constexpr uint32_t TE_Pos = 3;
    constexpr uint32_t TE_Msk = TE::mask;

    /// IDLE interrupt enable
    /// Position: 4, Width: 1
    using IDLEIE = BitField<4, 1>;
    constexpr uint32_t IDLEIE_Pos = 4;
    constexpr uint32_t IDLEIE_Msk = IDLEIE::mask;

    /// RXNE interrupt enable
    /// Position: 5, Width: 1
    using RXNEIE = BitField<5, 1>;
    constexpr uint32_t RXNEIE_Pos = 5;
    constexpr uint32_t RXNEIE_Msk = RXNEIE::mask;

    /// Transmission complete interrupt
              enable
    /// Position: 6, Width: 1
    using TCIE = BitField<6, 1>;
    constexpr uint32_t TCIE_Pos = 6;
    constexpr uint32_t TCIE_Msk = TCIE::mask;

    /// TXE interrupt enable
    /// Position: 7, Width: 1
    using TXEIE = BitField<7, 1>;
    constexpr uint32_t TXEIE_Pos = 7;
    constexpr uint32_t TXEIE_Msk = TXEIE::mask;

    /// PE interrupt enable
    /// Position: 8, Width: 1
    using PEIE = BitField<8, 1>;
    constexpr uint32_t PEIE_Pos = 8;
    constexpr uint32_t PEIE_Msk = PEIE::mask;

    /// Parity selection
    /// Position: 9, Width: 1
    using PS = BitField<9, 1>;
    constexpr uint32_t PS_Pos = 9;
    constexpr uint32_t PS_Msk = PS::mask;

    /// Parity control enable
    /// Position: 10, Width: 1
    using PCE = BitField<10, 1>;
    constexpr uint32_t PCE_Pos = 10;
    constexpr uint32_t PCE_Msk = PCE::mask;

    /// Wakeup method
    /// Position: 11, Width: 1
    using WAKE = BitField<11, 1>;
    constexpr uint32_t WAKE_Pos = 11;
    constexpr uint32_t WAKE_Msk = WAKE::mask;

    /// Word length
    /// Position: 12, Width: 1
    using M = BitField<12, 1>;
    constexpr uint32_t M_Pos = 12;
    constexpr uint32_t M_Msk = M::mask;

    /// USART enable
    /// Position: 13, Width: 1
    using UE = BitField<13, 1>;
    constexpr uint32_t UE_Pos = 13;
    constexpr uint32_t UE_Msk = UE::mask;

    /// Oversampling mode
    /// Position: 15, Width: 1
    using OVER8 = BitField<15, 1>;
    constexpr uint32_t OVER8_Pos = 15;
    constexpr uint32_t OVER8_Msk = OVER8::mask;

}  // namespace cr1

/// CR2 - Control register 2
namespace cr2 {
    /// Address of the USART node
    /// Position: 0, Width: 4
    using ADD = BitField<0, 4>;
    constexpr uint32_t ADD_Pos = 0;
    constexpr uint32_t ADD_Msk = ADD::mask;

    /// lin break detection length
    /// Position: 5, Width: 1
    using LBDL = BitField<5, 1>;
    constexpr uint32_t LBDL_Pos = 5;
    constexpr uint32_t LBDL_Msk = LBDL::mask;

    /// LIN break detection interrupt
              enable
    /// Position: 6, Width: 1
    using LBDIE = BitField<6, 1>;
    constexpr uint32_t LBDIE_Pos = 6;
    constexpr uint32_t LBDIE_Msk = LBDIE::mask;

    /// STOP bits
    /// Position: 12, Width: 2
    using STOP = BitField<12, 2>;
    constexpr uint32_t STOP_Pos = 12;
    constexpr uint32_t STOP_Msk = STOP::mask;

    /// LIN mode enable
    /// Position: 14, Width: 1
    using LINEN = BitField<14, 1>;
    constexpr uint32_t LINEN_Pos = 14;
    constexpr uint32_t LINEN_Msk = LINEN::mask;

}  // namespace cr2

/// CR3 - Control register 3
namespace cr3 {
    /// Error interrupt enable
    /// Position: 0, Width: 1
    using EIE = BitField<0, 1>;
    constexpr uint32_t EIE_Pos = 0;
    constexpr uint32_t EIE_Msk = EIE::mask;

    /// IrDA mode enable
    /// Position: 1, Width: 1
    using IREN = BitField<1, 1>;
    constexpr uint32_t IREN_Pos = 1;
    constexpr uint32_t IREN_Msk = IREN::mask;

    /// IrDA low-power
    /// Position: 2, Width: 1
    using IRLP = BitField<2, 1>;
    constexpr uint32_t IRLP_Pos = 2;
    constexpr uint32_t IRLP_Msk = IRLP::mask;

    /// Half-duplex selection
    /// Position: 3, Width: 1
    using HDSEL = BitField<3, 1>;
    constexpr uint32_t HDSEL_Pos = 3;
    constexpr uint32_t HDSEL_Msk = HDSEL::mask;

    /// DMA enable receiver
    /// Position: 6, Width: 1
    using DMAR = BitField<6, 1>;
    constexpr uint32_t DMAR_Pos = 6;
    constexpr uint32_t DMAR_Msk = DMAR::mask;

    /// DMA enable transmitter
    /// Position: 7, Width: 1
    using DMAT = BitField<7, 1>;
    constexpr uint32_t DMAT_Pos = 7;
    constexpr uint32_t DMAT_Msk = DMAT::mask;

    /// One sample bit method
              enable
    /// Position: 11, Width: 1
    using ONEBIT = BitField<11, 1>;
    constexpr uint32_t ONEBIT_Pos = 11;
    constexpr uint32_t ONEBIT_Msk = ONEBIT::mask;

}  // namespace cr3

}  // namespace alloy::hal::st::stm32f4::stm32f407::uart4
