/// Auto-generated bit field definitions for AES
/// Family: stm32f7
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32f7::aes {

using namespace alloy::hal::bitfields;

// ============================================================================
// AES Bit Field Definitions
// ============================================================================

/// CR - control register
namespace cr {
    /// AES enable
    /// Position: 0, Width: 1
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;

    /// Data type selection (for data in and data out to/from the cryptographic block)
    /// Position: 1, Width: 2
    using DATATYPE = BitField<1, 2>;
    constexpr uint32_t DATATYPE_Pos = 1;
    constexpr uint32_t DATATYPE_Msk = DATATYPE::mask;

    /// AES operating mode
    /// Position: 3, Width: 2
    using MODE = BitField<3, 2>;
    constexpr uint32_t MODE_Pos = 3;
    constexpr uint32_t MODE_Msk = MODE::mask;

    /// AES chaining mode Bit1 Bit0
    /// Position: 5, Width: 2
    using CHMOD10 = BitField<5, 2>;
    constexpr uint32_t CHMOD10_Pos = 5;
    constexpr uint32_t CHMOD10_Msk = CHMOD10::mask;

    /// Computation Complete Flag Clear
    /// Position: 7, Width: 1
    using CCFC = BitField<7, 1>;
    constexpr uint32_t CCFC_Pos = 7;
    constexpr uint32_t CCFC_Msk = CCFC::mask;

    /// Error clear
    /// Position: 8, Width: 1
    using ERRC = BitField<8, 1>;
    constexpr uint32_t ERRC_Pos = 8;
    constexpr uint32_t ERRC_Msk = ERRC::mask;

    /// CCF flag interrupt enable
    /// Position: 9, Width: 1
    using CCFIE = BitField<9, 1>;
    constexpr uint32_t CCFIE_Pos = 9;
    constexpr uint32_t CCFIE_Msk = CCFIE::mask;

    /// Error interrupt enable
    /// Position: 10, Width: 1
    using ERRIE = BitField<10, 1>;
    constexpr uint32_t ERRIE_Pos = 10;
    constexpr uint32_t ERRIE_Msk = ERRIE::mask;

    /// Enable DMA management of data input phase
    /// Position: 11, Width: 1
    using DMAINEN = BitField<11, 1>;
    constexpr uint32_t DMAINEN_Pos = 11;
    constexpr uint32_t DMAINEN_Msk = DMAINEN::mask;

    /// Enable DMA management of data output phase
    /// Position: 12, Width: 1
    using DMAOUTEN = BitField<12, 1>;
    constexpr uint32_t DMAOUTEN_Pos = 12;
    constexpr uint32_t DMAOUTEN_Msk = DMAOUTEN::mask;

    /// Used only for GCM, CCM and GMAC algorithms and has no effect when other algorithms are selected
    /// Position: 13, Width: 2
    using GCMPH = BitField<13, 2>;
    constexpr uint32_t GCMPH_Pos = 13;
    constexpr uint32_t GCMPH_Msk = GCMPH::mask;

    /// AES chaining mode Bit2
    /// Position: 16, Width: 1
    using CHMOD2 = BitField<16, 1>;
    constexpr uint32_t CHMOD2_Pos = 16;
    constexpr uint32_t CHMOD2_Msk = CHMOD2::mask;

    /// Key size selection
    /// Position: 18, Width: 1
    using KEYSIZE = BitField<18, 1>;
    constexpr uint32_t KEYSIZE_Pos = 18;
    constexpr uint32_t KEYSIZE_Msk = KEYSIZE::mask;

}  // namespace cr

/// SR - status register
namespace sr {
    /// Computation complete flag
    /// Position: 0, Width: 1
    using CCF = BitField<0, 1>;
    constexpr uint32_t CCF_Pos = 0;
    constexpr uint32_t CCF_Msk = CCF::mask;

    /// Read error flag
    /// Position: 1, Width: 1
    using RDERR = BitField<1, 1>;
    constexpr uint32_t RDERR_Pos = 1;
    constexpr uint32_t RDERR_Msk = RDERR::mask;

    /// Write error flag
    /// Position: 2, Width: 1
    using WRERR = BitField<2, 1>;
    constexpr uint32_t WRERR_Pos = 2;
    constexpr uint32_t WRERR_Msk = WRERR::mask;

    /// Busy flag
    /// Position: 3, Width: 1
    using BUSY = BitField<3, 1>;
    constexpr uint32_t BUSY_Pos = 3;
    constexpr uint32_t BUSY_Msk = BUSY::mask;

}  // namespace sr

/// DINR - data input register
namespace dinr {
    /// Data Input Register
    /// Position: 0, Width: 32
    using AES_DINR = BitField<0, 32>;
    constexpr uint32_t AES_DINR_Pos = 0;
    constexpr uint32_t AES_DINR_Msk = AES_DINR::mask;

}  // namespace dinr

/// DOUTR - data output register
namespace doutr {
    /// Data output register
    /// Position: 0, Width: 32
    using AES_DOUTR = BitField<0, 32>;
    constexpr uint32_t AES_DOUTR_Pos = 0;
    constexpr uint32_t AES_DOUTR_Msk = AES_DOUTR::mask;

}  // namespace doutr

/// KEYR0 - key register 0
namespace keyr0 {
    /// Data Output Register (LSB key [31:0])
    /// Position: 0, Width: 32
    using AES_KEYR0 = BitField<0, 32>;
    constexpr uint32_t AES_KEYR0_Pos = 0;
    constexpr uint32_t AES_KEYR0_Msk = AES_KEYR0::mask;

}  // namespace keyr0

/// KEYR1 - key register 1
namespace keyr1 {
    /// AES key register (key [63:32])
    /// Position: 0, Width: 32
    using AES_KEYR1 = BitField<0, 32>;
    constexpr uint32_t AES_KEYR1_Pos = 0;
    constexpr uint32_t AES_KEYR1_Msk = AES_KEYR1::mask;

}  // namespace keyr1

/// KEYR2 - key register 2
namespace keyr2 {
    /// AES key register (key [95:64])
    /// Position: 0, Width: 32
    using AES_KEYR2 = BitField<0, 32>;
    constexpr uint32_t AES_KEYR2_Pos = 0;
    constexpr uint32_t AES_KEYR2_Msk = AES_KEYR2::mask;

}  // namespace keyr2

/// KEYR3 - key register 3
namespace keyr3 {
    /// AES key register (MSB key [127:96])
    /// Position: 0, Width: 32
    using AES_KEYR3 = BitField<0, 32>;
    constexpr uint32_t AES_KEYR3_Pos = 0;
    constexpr uint32_t AES_KEYR3_Msk = AES_KEYR3::mask;

}  // namespace keyr3

/// IVR0 - initialization vector register 0
namespace ivr0 {
    /// initialization vector register (LSB IVR [31:0])
    /// Position: 0, Width: 32
    using AES_IVR0 = BitField<0, 32>;
    constexpr uint32_t AES_IVR0_Pos = 0;
    constexpr uint32_t AES_IVR0_Msk = AES_IVR0::mask;

}  // namespace ivr0

/// IVR1 - initialization vector register 1
namespace ivr1 {
    /// Initialization Vector Register (IVR [63:32])
    /// Position: 0, Width: 32
    using AES_IVR1 = BitField<0, 32>;
    constexpr uint32_t AES_IVR1_Pos = 0;
    constexpr uint32_t AES_IVR1_Msk = AES_IVR1::mask;

}  // namespace ivr1

/// IVR2 - initialization vector register 2
namespace ivr2 {
    /// Initialization Vector Register (IVR [95:64])
    /// Position: 0, Width: 32
    using AES_IVR2 = BitField<0, 32>;
    constexpr uint32_t AES_IVR2_Pos = 0;
    constexpr uint32_t AES_IVR2_Msk = AES_IVR2::mask;

}  // namespace ivr2

/// IVR3 - initialization vector register 3
namespace ivr3 {
    /// Initialization Vector Register (MSB IVR [127:96])
    /// Position: 0, Width: 32
    using AES_IVR3 = BitField<0, 32>;
    constexpr uint32_t AES_IVR3_Pos = 0;
    constexpr uint32_t AES_IVR3_Msk = AES_IVR3::mask;

}  // namespace ivr3

/// KEYR4 - key register 4
namespace keyr4 {
    /// AES key register (MSB key [159:128])
    /// Position: 0, Width: 32
    using AES_KEYR4 = BitField<0, 32>;
    constexpr uint32_t AES_KEYR4_Pos = 0;
    constexpr uint32_t AES_KEYR4_Msk = AES_KEYR4::mask;

}  // namespace keyr4

/// KEYR5 - key register 5
namespace keyr5 {
    /// AES key register (MSB key [191:160])
    /// Position: 0, Width: 32
    using AES_KEYR5 = BitField<0, 32>;
    constexpr uint32_t AES_KEYR5_Pos = 0;
    constexpr uint32_t AES_KEYR5_Msk = AES_KEYR5::mask;

}  // namespace keyr5

/// KEYR6 - key register 6
namespace keyr6 {
    /// AES key register (MSB key [223:192])
    /// Position: 0, Width: 32
    using AES_KEYR6 = BitField<0, 32>;
    constexpr uint32_t AES_KEYR6_Pos = 0;
    constexpr uint32_t AES_KEYR6_Msk = AES_KEYR6::mask;

}  // namespace keyr6

/// KEYR7 - key register 7
namespace keyr7 {
    /// AES key register (MSB key [255:224])
    /// Position: 0, Width: 32
    using AES_KEYR7 = BitField<0, 32>;
    constexpr uint32_t AES_KEYR7_Pos = 0;
    constexpr uint32_t AES_KEYR7_Msk = AES_KEYR7::mask;

}  // namespace keyr7

/// SUSP0R - AES suspend register 0
namespace susp0r {
    /// AES suspend register 0
    /// Position: 0, Width: 32
    using AES_SUSP0R = BitField<0, 32>;
    constexpr uint32_t AES_SUSP0R_Pos = 0;
    constexpr uint32_t AES_SUSP0R_Msk = AES_SUSP0R::mask;

}  // namespace susp0r

/// SUSP1R - AES suspend register 1
namespace susp1r {
    /// AES suspend register 1
    /// Position: 0, Width: 32
    using AES_SUSP1R = BitField<0, 32>;
    constexpr uint32_t AES_SUSP1R_Pos = 0;
    constexpr uint32_t AES_SUSP1R_Msk = AES_SUSP1R::mask;

}  // namespace susp1r

/// SUSP2R - AES suspend register 2
namespace susp2r {
    /// AES suspend register 2
    /// Position: 0, Width: 32
    using AES_SUSP2R = BitField<0, 32>;
    constexpr uint32_t AES_SUSP2R_Pos = 0;
    constexpr uint32_t AES_SUSP2R_Msk = AES_SUSP2R::mask;

}  // namespace susp2r

/// SUSP3R - AES suspend register 3
namespace susp3r {
    /// AES suspend register 3
    /// Position: 0, Width: 32
    using AES_SUSP3R = BitField<0, 32>;
    constexpr uint32_t AES_SUSP3R_Pos = 0;
    constexpr uint32_t AES_SUSP3R_Msk = AES_SUSP3R::mask;

}  // namespace susp3r

/// SUSP4R - AES suspend register 4
namespace susp4r {
    /// AES suspend register 4
    /// Position: 0, Width: 32
    using AES_SUSP4R = BitField<0, 32>;
    constexpr uint32_t AES_SUSP4R_Pos = 0;
    constexpr uint32_t AES_SUSP4R_Msk = AES_SUSP4R::mask;

}  // namespace susp4r

/// SUSP5R - AES suspend register 5
namespace susp5r {
    /// AES suspend register 5
    /// Position: 0, Width: 32
    using AES_SUSP5R = BitField<0, 32>;
    constexpr uint32_t AES_SUSP5R_Pos = 0;
    constexpr uint32_t AES_SUSP5R_Msk = AES_SUSP5R::mask;

}  // namespace susp5r

/// SUSP6R - AES suspend register 6
namespace susp6r {
    /// AES suspend register 6
    /// Position: 0, Width: 32
    using AES_SUSP6R = BitField<0, 32>;
    constexpr uint32_t AES_SUSP6R_Pos = 0;
    constexpr uint32_t AES_SUSP6R_Msk = AES_SUSP6R::mask;

}  // namespace susp6r

/// SUSP7R - AES suspend register 7
namespace susp7r {
    /// AES suspend register 7
    /// Position: 0, Width: 32
    using AES_SUSP7R = BitField<0, 32>;
    constexpr uint32_t AES_SUSP7R_Pos = 0;
    constexpr uint32_t AES_SUSP7R_Msk = AES_SUSP7R::mask;

}  // namespace susp7r

}  // namespace alloy::hal::st::stm32f7::aes
