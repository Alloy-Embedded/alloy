/// Auto-generated register definitions for RTC
/// Family: stm32f7
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::st::stm32f7::rtc {

// ============================================================================
// RTC - Real-time clock
// Base Address: 0x40002800
// ============================================================================

/// RTC Register Structure
struct RTC_Registers {

    /// time register
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t TR;

    /// date register
    /// Offset: 0x0004
    /// Reset value: 0x00002101
    /// Access: read-write
    volatile uint32_t DR;

    /// control register
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CR;

    /// initialization and status register
    /// Offset: 0x000C
    /// Reset value: 0x00000007
    volatile uint32_t ISR;

    /// prescaler register
    /// Offset: 0x0010
    /// Reset value: 0x007F00FF
    /// Access: read-write
    volatile uint32_t PRER;

    /// wakeup timer register
    /// Offset: 0x0014
    /// Reset value: 0x0000FFFF
    /// Access: read-write
    volatile uint32_t WUTR;
    uint8_t RESERVED_0018[4]; ///< Reserved

    /// alarm A register
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALRMAR;

    /// alarm B register
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALRMBR;

    /// write protection register
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    /// Access: write-only
    volatile uint32_t WPR;

    /// sub second register
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t SSR;

    /// shift control register
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    /// Access: write-only
    volatile uint32_t SHIFTR;

    /// time stamp time register
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t TSTR;

    /// time stamp date register
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t TSDR;

    /// timestamp sub second register
    /// Offset: 0x0038
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t TSSSR;

    /// calibration register
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CALR;

    /// tamper configuration register
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t TAMPCR;

    /// alarm A sub second register
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALRMASSR;

    /// alarm B sub second register
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t ALRMBSSR;

    /// option register
    /// Offset: 0x004C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t OR;

    /// backup register
    /// Offset: 0x0050
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP0R;

    /// backup register
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP1R;

    /// backup register
    /// Offset: 0x0058
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP2R;

    /// backup register
    /// Offset: 0x005C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP3R;

    /// backup register
    /// Offset: 0x0060
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP4R;

    /// backup register
    /// Offset: 0x0064
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP5R;

    /// backup register
    /// Offset: 0x0068
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP6R;

    /// backup register
    /// Offset: 0x006C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP7R;

    /// backup register
    /// Offset: 0x0070
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP8R;

    /// backup register
    /// Offset: 0x0074
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP9R;

    /// backup register
    /// Offset: 0x0078
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP10R;

    /// backup register
    /// Offset: 0x007C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP11R;

    /// backup register
    /// Offset: 0x0080
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP12R;

    /// backup register
    /// Offset: 0x0084
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP13R;

    /// backup register
    /// Offset: 0x0088
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP14R;

    /// backup register
    /// Offset: 0x008C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP15R;

    /// backup register
    /// Offset: 0x0090
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP16R;

    /// backup register
    /// Offset: 0x0094
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP17R;

    /// backup register
    /// Offset: 0x0098
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP18R;

    /// backup register
    /// Offset: 0x009C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP19R;

    /// backup register
    /// Offset: 0x00A0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP20R;

    /// backup register
    /// Offset: 0x00A4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP21R;

    /// backup register
    /// Offset: 0x00A8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP22R;

    /// backup register
    /// Offset: 0x00AC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP23R;

    /// backup register
    /// Offset: 0x00B0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP24R;

    /// backup register
    /// Offset: 0x00B4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP25R;

    /// backup register
    /// Offset: 0x00B8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP26R;

    /// backup register
    /// Offset: 0x00BC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP27R;

    /// backup register
    /// Offset: 0x00C0
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP28R;

    /// backup register
    /// Offset: 0x00C4
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP29R;

    /// backup register
    /// Offset: 0x00C8
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP30R;

    /// backup register
    /// Offset: 0x00CC
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BKP31R;
};

static_assert(sizeof(RTC_Registers) >= 208, "RTC_Registers size mismatch");

/// RTC peripheral instance
inline RTC_Registers* RTC() {
    return reinterpret_cast<RTC_Registers*>(0x40002800);
}

}  // namespace alloy::hal::st::stm32f7::rtc
