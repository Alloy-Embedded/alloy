/// Auto-generated bit field definitions for FLASH
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::flash {

using namespace alloy::hal::bitfields;

// ============================================================================
// FLASH Bit Field Definitions
// ============================================================================

/// ACR - Access control register
namespace acr {
    /// Latency
    /// Position: 0, Width: 3
    using LATENCY = BitField<0, 3>;
    constexpr uint32_t LATENCY_Pos = 0;
    constexpr uint32_t LATENCY_Msk = LATENCY::mask;

    /// Prefetch enable
    /// Position: 8, Width: 1
    using PRFTEN = BitField<8, 1>;
    constexpr uint32_t PRFTEN_Pos = 8;
    constexpr uint32_t PRFTEN_Msk = PRFTEN::mask;

    /// Instruction cache enable
    /// Position: 9, Width: 1
    using ICEN = BitField<9, 1>;
    constexpr uint32_t ICEN_Pos = 9;
    constexpr uint32_t ICEN_Msk = ICEN::mask;

    /// Instruction cache reset
    /// Position: 11, Width: 1
    using ICRST = BitField<11, 1>;
    constexpr uint32_t ICRST_Pos = 11;
    constexpr uint32_t ICRST_Msk = ICRST::mask;

    /// Flash User area empty
    /// Position: 16, Width: 1
    using EMPTY = BitField<16, 1>;
    constexpr uint32_t EMPTY_Pos = 16;
    constexpr uint32_t EMPTY_Msk = EMPTY::mask;

    /// Debug access software enable
    /// Position: 18, Width: 1
    using DBG_SWEN = BitField<18, 1>;
    constexpr uint32_t DBG_SWEN_Pos = 18;
    constexpr uint32_t DBG_SWEN_Msk = DBG_SWEN::mask;

}  // namespace acr

/// KEYR - Flash key register
namespace keyr {
    /// KEYR
    /// Position: 0, Width: 32
    using KEYR = BitField<0, 32>;
    constexpr uint32_t KEYR_Pos = 0;
    constexpr uint32_t KEYR_Msk = KEYR::mask;

}  // namespace keyr

/// OPTKEYR - Option byte key register
namespace optkeyr {
    /// Option byte key
    /// Position: 0, Width: 32
    using OPTKEYR = BitField<0, 32>;
    constexpr uint32_t OPTKEYR_Pos = 0;
    constexpr uint32_t OPTKEYR_Msk = OPTKEYR::mask;

}  // namespace optkeyr

/// SR - Status register
namespace sr {
    /// End of operation
    /// Position: 0, Width: 1
    using EOP = BitField<0, 1>;
    constexpr uint32_t EOP_Pos = 0;
    constexpr uint32_t EOP_Msk = EOP::mask;

    /// Operation error
    /// Position: 1, Width: 1
    using OPERR = BitField<1, 1>;
    constexpr uint32_t OPERR_Pos = 1;
    constexpr uint32_t OPERR_Msk = OPERR::mask;

    /// Programming error
    /// Position: 3, Width: 1
    using PROGERR = BitField<3, 1>;
    constexpr uint32_t PROGERR_Pos = 3;
    constexpr uint32_t PROGERR_Msk = PROGERR::mask;

    /// Write protected error
    /// Position: 4, Width: 1
    using WRPERR = BitField<4, 1>;
    constexpr uint32_t WRPERR_Pos = 4;
    constexpr uint32_t WRPERR_Msk = WRPERR::mask;

    /// Programming alignment error
    /// Position: 5, Width: 1
    using PGAERR = BitField<5, 1>;
    constexpr uint32_t PGAERR_Pos = 5;
    constexpr uint32_t PGAERR_Msk = PGAERR::mask;

    /// Size error
    /// Position: 6, Width: 1
    using SIZERR = BitField<6, 1>;
    constexpr uint32_t SIZERR_Pos = 6;
    constexpr uint32_t SIZERR_Msk = SIZERR::mask;

    /// Programming sequence error
    /// Position: 7, Width: 1
    using PGSERR = BitField<7, 1>;
    constexpr uint32_t PGSERR_Pos = 7;
    constexpr uint32_t PGSERR_Msk = PGSERR::mask;

    /// Fast programming data miss error
    /// Position: 8, Width: 1
    using MISERR = BitField<8, 1>;
    constexpr uint32_t MISERR_Pos = 8;
    constexpr uint32_t MISERR_Msk = MISERR::mask;

    /// Fast programming error
    /// Position: 9, Width: 1
    using FASTERR = BitField<9, 1>;
    constexpr uint32_t FASTERR_Pos = 9;
    constexpr uint32_t FASTERR_Msk = FASTERR::mask;

    /// PCROP read error
    /// Position: 14, Width: 1
    using RDERR = BitField<14, 1>;
    constexpr uint32_t RDERR_Pos = 14;
    constexpr uint32_t RDERR_Msk = RDERR::mask;

    /// Option and Engineering bits loading validity error
    /// Position: 15, Width: 1
    using OPTVERR = BitField<15, 1>;
    constexpr uint32_t OPTVERR_Pos = 15;
    constexpr uint32_t OPTVERR_Msk = OPTVERR::mask;

    /// Busy
    /// Position: 16, Width: 1
    using BSY = BitField<16, 1>;
    constexpr uint32_t BSY_Pos = 16;
    constexpr uint32_t BSY_Msk = BSY::mask;

    /// Programming or erase configuration busy.
    /// Position: 18, Width: 1
    using CFGBSY = BitField<18, 1>;
    constexpr uint32_t CFGBSY_Pos = 18;
    constexpr uint32_t CFGBSY_Msk = CFGBSY::mask;

}  // namespace sr

/// CR - Flash control register
namespace cr {
    /// Programming
    /// Position: 0, Width: 1
    using PG = BitField<0, 1>;
    constexpr uint32_t PG_Pos = 0;
    constexpr uint32_t PG_Msk = PG::mask;

    /// Page erase
    /// Position: 1, Width: 1
    using PER = BitField<1, 1>;
    constexpr uint32_t PER_Pos = 1;
    constexpr uint32_t PER_Msk = PER::mask;

    /// Mass erase
    /// Position: 2, Width: 1
    using MER = BitField<2, 1>;
    constexpr uint32_t MER_Pos = 2;
    constexpr uint32_t MER_Msk = MER::mask;

    /// Page number
    /// Position: 3, Width: 6
    using PNB = BitField<3, 6>;
    constexpr uint32_t PNB_Pos = 3;
    constexpr uint32_t PNB_Msk = PNB::mask;

    /// Start
    /// Position: 16, Width: 1
    using STRT = BitField<16, 1>;
    constexpr uint32_t STRT_Pos = 16;
    constexpr uint32_t STRT_Msk = STRT::mask;

    /// Options modification start
    /// Position: 17, Width: 1
    using OPTSTRT = BitField<17, 1>;
    constexpr uint32_t OPTSTRT_Pos = 17;
    constexpr uint32_t OPTSTRT_Msk = OPTSTRT::mask;

    /// Fast programming
    /// Position: 18, Width: 1
    using FSTPG = BitField<18, 1>;
    constexpr uint32_t FSTPG_Pos = 18;
    constexpr uint32_t FSTPG_Msk = FSTPG::mask;

    /// End of operation interrupt enable
    /// Position: 24, Width: 1
    using EOPIE = BitField<24, 1>;
    constexpr uint32_t EOPIE_Pos = 24;
    constexpr uint32_t EOPIE_Msk = EOPIE::mask;

    /// Error interrupt enable
    /// Position: 25, Width: 1
    using ERRIE = BitField<25, 1>;
    constexpr uint32_t ERRIE_Pos = 25;
    constexpr uint32_t ERRIE_Msk = ERRIE::mask;

    /// PCROP read error interrupt enable
    /// Position: 26, Width: 1
    using RDERRIE = BitField<26, 1>;
    constexpr uint32_t RDERRIE_Pos = 26;
    constexpr uint32_t RDERRIE_Msk = RDERRIE::mask;

    /// Force the option byte loading
    /// Position: 27, Width: 1
    using OBL_LAUNCH = BitField<27, 1>;
    constexpr uint32_t OBL_LAUNCH_Pos = 27;
    constexpr uint32_t OBL_LAUNCH_Msk = OBL_LAUNCH::mask;

    /// Securable memory area protection enable
    /// Position: 28, Width: 1
    using SEC_PROT = BitField<28, 1>;
    constexpr uint32_t SEC_PROT_Pos = 28;
    constexpr uint32_t SEC_PROT_Msk = SEC_PROT::mask;

    /// Options Lock
    /// Position: 30, Width: 1
    using OPTLOCK = BitField<30, 1>;
    constexpr uint32_t OPTLOCK_Pos = 30;
    constexpr uint32_t OPTLOCK_Msk = OPTLOCK::mask;

    /// FLASH_CR Lock
    /// Position: 31, Width: 1
    using LOCK = BitField<31, 1>;
    constexpr uint32_t LOCK_Pos = 31;
    constexpr uint32_t LOCK_Msk = LOCK::mask;

}  // namespace cr

/// ECCR - Flash ECC register
namespace eccr {
    /// ECC fail address
    /// Position: 0, Width: 14
    /// Access: read-only
    using ADDR_ECC = BitField<0, 14>;
    constexpr uint32_t ADDR_ECC_Pos = 0;
    constexpr uint32_t ADDR_ECC_Msk = ADDR_ECC::mask;

    /// ECC fail for Corrected ECC Error or Double ECC Error in info block
    /// Position: 20, Width: 1
    /// Access: read-only
    using SYSF_ECC = BitField<20, 1>;
    constexpr uint32_t SYSF_ECC_Pos = 20;
    constexpr uint32_t SYSF_ECC_Msk = SYSF_ECC::mask;

    /// ECC correction interrupt enable
    /// Position: 24, Width: 1
    /// Access: read-write
    using ECCIE = BitField<24, 1>;
    constexpr uint32_t ECCIE_Pos = 24;
    constexpr uint32_t ECCIE_Msk = ECCIE::mask;

    /// ECC correction
    /// Position: 30, Width: 1
    /// Access: read-write
    using ECCC = BitField<30, 1>;
    constexpr uint32_t ECCC_Pos = 30;
    constexpr uint32_t ECCC_Msk = ECCC::mask;

    /// ECC detection
    /// Position: 31, Width: 1
    /// Access: read-write
    using ECCD = BitField<31, 1>;
    constexpr uint32_t ECCD_Pos = 31;
    constexpr uint32_t ECCD_Msk = ECCD::mask;

}  // namespace eccr

/// OPTR - Flash option register
namespace optr {
    /// Read protection level
    /// Position: 0, Width: 8
    using RDP = BitField<0, 8>;
    constexpr uint32_t RDP_Pos = 0;
    constexpr uint32_t RDP_Msk = RDP::mask;

    /// BOR reset Level
    /// Position: 8, Width: 1
    using BOREN = BitField<8, 1>;
    constexpr uint32_t BOREN_Pos = 8;
    constexpr uint32_t BOREN_Msk = BOREN::mask;

    /// These bits contain the VDD supply level threshold that activates the reset
    /// Position: 9, Width: 2
    using BORF_LEV = BitField<9, 2>;
    constexpr uint32_t BORF_LEV_Pos = 9;
    constexpr uint32_t BORF_LEV_Msk = BORF_LEV::mask;

    /// These bits contain the VDD supply level threshold that releases the reset.
    /// Position: 11, Width: 2
    using BORR_LEV = BitField<11, 2>;
    constexpr uint32_t BORR_LEV_Pos = 11;
    constexpr uint32_t BORR_LEV_Msk = BORR_LEV::mask;

    /// nRST_STOP
    /// Position: 13, Width: 1
    using nRST_STOP = BitField<13, 1>;
    constexpr uint32_t nRST_STOP_Pos = 13;
    constexpr uint32_t nRST_STOP_Msk = nRST_STOP::mask;

    /// nRST_STDBY
    /// Position: 14, Width: 1
    using nRST_STDBY = BitField<14, 1>;
    constexpr uint32_t nRST_STDBY_Pos = 14;
    constexpr uint32_t nRST_STDBY_Msk = nRST_STDBY::mask;

    /// nRSTS_HDW
    /// Position: 15, Width: 1
    using nRSTS_HDW = BitField<15, 1>;
    constexpr uint32_t nRSTS_HDW_Pos = 15;
    constexpr uint32_t nRSTS_HDW_Msk = nRSTS_HDW::mask;

    /// Independent watchdog selection
    /// Position: 16, Width: 1
    using IDWG_SW = BitField<16, 1>;
    constexpr uint32_t IDWG_SW_Pos = 16;
    constexpr uint32_t IDWG_SW_Msk = IDWG_SW::mask;

    /// Independent watchdog counter freeze in Stop mode
    /// Position: 17, Width: 1
    using IWDG_STOP = BitField<17, 1>;
    constexpr uint32_t IWDG_STOP_Pos = 17;
    constexpr uint32_t IWDG_STOP_Msk = IWDG_STOP::mask;

    /// Independent watchdog counter freeze in Standby mode
    /// Position: 18, Width: 1
    using IWDG_STDBY = BitField<18, 1>;
    constexpr uint32_t IWDG_STDBY_Pos = 18;
    constexpr uint32_t IWDG_STDBY_Msk = IWDG_STDBY::mask;

    /// Window watchdog selection
    /// Position: 19, Width: 1
    using WWDG_SW = BitField<19, 1>;
    constexpr uint32_t WWDG_SW_Pos = 19;
    constexpr uint32_t WWDG_SW_Msk = WWDG_SW::mask;

    /// SRAM parity check control
    /// Position: 22, Width: 1
    using RAM_PARITY_CHECK = BitField<22, 1>;
    constexpr uint32_t RAM_PARITY_CHECK_Pos = 22;
    constexpr uint32_t RAM_PARITY_CHECK_Msk = RAM_PARITY_CHECK::mask;

    /// nBOOT_SEL
    /// Position: 24, Width: 1
    using nBOOT_SEL = BitField<24, 1>;
    constexpr uint32_t nBOOT_SEL_Pos = 24;
    constexpr uint32_t nBOOT_SEL_Msk = nBOOT_SEL::mask;

    /// Boot configuration
    /// Position: 25, Width: 1
    using nBOOT1 = BitField<25, 1>;
    constexpr uint32_t nBOOT1_Pos = 25;
    constexpr uint32_t nBOOT1_Msk = nBOOT1::mask;

    /// nBOOT0 option bit
    /// Position: 26, Width: 1
    using nBOOT0 = BitField<26, 1>;
    constexpr uint32_t nBOOT0_Pos = 26;
    constexpr uint32_t nBOOT0_Msk = nBOOT0::mask;

    /// NRST_MODE
    /// Position: 27, Width: 2
    using NRST_MODE = BitField<27, 2>;
    constexpr uint32_t NRST_MODE_Pos = 27;
    constexpr uint32_t NRST_MODE_Msk = NRST_MODE::mask;

    /// Internal reset holder enable bit
    /// Position: 29, Width: 1
    using IRHEN = BitField<29, 1>;
    constexpr uint32_t IRHEN_Pos = 29;
    constexpr uint32_t IRHEN_Msk = IRHEN::mask;

}  // namespace optr

/// PCROP1ASR - Flash PCROP zone A Start address register
namespace pcrop1asr {
    /// PCROP1A area start offset
    /// Position: 0, Width: 8
    using PCROP1A_STRT = BitField<0, 8>;
    constexpr uint32_t PCROP1A_STRT_Pos = 0;
    constexpr uint32_t PCROP1A_STRT_Msk = PCROP1A_STRT::mask;

}  // namespace pcrop1asr

/// PCROP1AER - Flash PCROP zone A End address register
namespace pcrop1aer {
    /// PCROP1A area end offset
    /// Position: 0, Width: 8
    using PCROP1A_END = BitField<0, 8>;
    constexpr uint32_t PCROP1A_END_Pos = 0;
    constexpr uint32_t PCROP1A_END_Msk = PCROP1A_END::mask;

    /// PCROP area preserved when RDP level decreased
    /// Position: 31, Width: 1
    using PCROP_RDP = BitField<31, 1>;
    constexpr uint32_t PCROP_RDP_Pos = 31;
    constexpr uint32_t PCROP_RDP_Msk = PCROP_RDP::mask;

}  // namespace pcrop1aer

/// WRP1AR - Flash WRP area A address register
namespace wrp1ar {
    /// WRP area A start offset
    /// Position: 0, Width: 6
    using WRP1A_STRT = BitField<0, 6>;
    constexpr uint32_t WRP1A_STRT_Pos = 0;
    constexpr uint32_t WRP1A_STRT_Msk = WRP1A_STRT::mask;

    /// WRP area A end offset
    /// Position: 16, Width: 6
    using WRP1A_END = BitField<16, 6>;
    constexpr uint32_t WRP1A_END_Pos = 16;
    constexpr uint32_t WRP1A_END_Msk = WRP1A_END::mask;

}  // namespace wrp1ar

/// WRP1BR - Flash WRP area B address register
namespace wrp1br {
    /// WRP area B start offset
    /// Position: 0, Width: 6
    using WRP1B_STRT = BitField<0, 6>;
    constexpr uint32_t WRP1B_STRT_Pos = 0;
    constexpr uint32_t WRP1B_STRT_Msk = WRP1B_STRT::mask;

    /// WRP area B end offset
    /// Position: 16, Width: 6
    using WRP1B_END = BitField<16, 6>;
    constexpr uint32_t WRP1B_END_Pos = 16;
    constexpr uint32_t WRP1B_END_Msk = WRP1B_END::mask;

}  // namespace wrp1br

/// PCROP1BSR - Flash PCROP zone B Start address register
namespace pcrop1bsr {
    /// PCROP1B area start offset
    /// Position: 0, Width: 8
    using PCROP1B_STRT = BitField<0, 8>;
    constexpr uint32_t PCROP1B_STRT_Pos = 0;
    constexpr uint32_t PCROP1B_STRT_Msk = PCROP1B_STRT::mask;

}  // namespace pcrop1bsr

/// PCROP1BER - Flash PCROP area B End address register
namespace pcrop1ber {
    /// PCROP1B area end offset
    /// Position: 0, Width: 9
    using PCROP1B_END = BitField<0, 9>;
    constexpr uint32_t PCROP1B_END_Pos = 0;
    constexpr uint32_t PCROP1B_END_Msk = PCROP1B_END::mask;

}  // namespace pcrop1ber

/// PCROP2ASR - Flash PCROP2 area A start address register
namespace pcrop2asr {
    /// PCROP2A area start offset, bank2
    /// Position: 0, Width: 9
    using PCROP2A_STRT = BitField<0, 9>;
    constexpr uint32_t PCROP2A_STRT_Pos = 0;
    constexpr uint32_t PCROP2A_STRT_Msk = PCROP2A_STRT::mask;

}  // namespace pcrop2asr

/// PCROP2AER - Flash PCROP2 area A end address register
namespace pcrop2aer {
    /// PCROP2A area end offset, bank2
    /// Position: 0, Width: 9
    using PCROP2A_END = BitField<0, 9>;
    constexpr uint32_t PCROP2A_END_Pos = 0;
    constexpr uint32_t PCROP2A_END_Msk = PCROP2A_END::mask;

}  // namespace pcrop2aer

/// WRP2AR - Flash WRP2 area A address register
namespace wrp2ar {
    /// WRP area A start offset, Bank 2
    /// Position: 0, Width: 7
    using WRP2A_STRT = BitField<0, 7>;
    constexpr uint32_t WRP2A_STRT_Pos = 0;
    constexpr uint32_t WRP2A_STRT_Msk = WRP2A_STRT::mask;

    /// WRP area A end offset, Bank 2
    /// Position: 16, Width: 7
    using WRP2A_END = BitField<16, 7>;
    constexpr uint32_t WRP2A_END_Pos = 16;
    constexpr uint32_t WRP2A_END_Msk = WRP2A_END::mask;

}  // namespace wrp2ar

/// WRP2BR - Flash WRP2 area B address register
namespace wrp2br {
    /// WRP area B start offset, Bank 2
    /// Position: 0, Width: 7
    using WRP2B_STRT = BitField<0, 7>;
    constexpr uint32_t WRP2B_STRT_Pos = 0;
    constexpr uint32_t WRP2B_STRT_Msk = WRP2B_STRT::mask;

    /// WRP area B end offset, Bank 2
    /// Position: 16, Width: 7
    using WRP2B_END = BitField<16, 7>;
    constexpr uint32_t WRP2B_END_Pos = 16;
    constexpr uint32_t WRP2B_END_Msk = WRP2B_END::mask;

}  // namespace wrp2br

/// PCROP2BSR - FLASH PCROP2 area B start address register
namespace pcrop2bsr {
    /// PCROP2B area start offset, Bank 2
    /// Position: 0, Width: 9
    using PCROP2B_STRT = BitField<0, 9>;
    constexpr uint32_t PCROP2B_STRT_Pos = 0;
    constexpr uint32_t PCROP2B_STRT_Msk = PCROP2B_STRT::mask;

}  // namespace pcrop2bsr

/// PCROP2BER - FLASH PCROP2 area B end address register
namespace pcrop2ber {
    /// PCROP2B area end offset, Bank 2
    /// Position: 0, Width: 9
    using PCROP2B_END = BitField<0, 9>;
    constexpr uint32_t PCROP2B_END_Pos = 0;
    constexpr uint32_t PCROP2B_END_Msk = PCROP2B_END::mask;

}  // namespace pcrop2ber

/// SECR - Flash Security register
namespace secr {
    /// Securable memory area size
    /// Position: 0, Width: 8
    using SEC_SIZE = BitField<0, 8>;
    constexpr uint32_t SEC_SIZE_Pos = 0;
    constexpr uint32_t SEC_SIZE_Msk = SEC_SIZE::mask;

    /// used to force boot from user area
    /// Position: 16, Width: 1
    using BOOT_LOCK = BitField<16, 1>;
    constexpr uint32_t BOOT_LOCK_Pos = 16;
    constexpr uint32_t BOOT_LOCK_Msk = BOOT_LOCK::mask;

    /// Securable memory area size
    /// Position: 20, Width: 8
    using SEC_SIZE2 = BitField<20, 8>;
    constexpr uint32_t SEC_SIZE2_Pos = 20;
    constexpr uint32_t SEC_SIZE2_Msk = SEC_SIZE2::mask;

}  // namespace secr

}  // namespace alloy::hal::st::stm32g0::flash
