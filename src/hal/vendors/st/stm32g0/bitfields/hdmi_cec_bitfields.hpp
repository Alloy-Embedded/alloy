/// Auto-generated bit field definitions for HDMI_CEC
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::hdmi_cec {

using namespace alloy::hal::bitfields;

// ============================================================================
// HDMI_CEC Bit Field Definitions
// ============================================================================

/// CEC_CR - CEC control register
namespace cec_cr {
    /// CEC enable The CECEN bit is set and cleared by software. CECEN = 1 starts message reception and enables the TXSOM control. CECEN = 0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CECEN = BitField<0, 1>;
    constexpr uint32_t CECEN_Pos = 0;
    constexpr uint32_t CECEN_Msk = CECEN::mask;
    /// Enumerated values for CECEN
    namespace cecen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission starts after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND = 1), in case of transmission underrun (TXUDR = 1), negative acknowledge (TXACKE = 1), and transmission error (TXERR = 1). It is also cleared by CECEN = 0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST = 1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN = 1. TXSOM must be set when transmission data is available into TXDR. HEADER first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR that is used only for reception.
    /// Position: 1, Width: 1
    /// Access: read-write
    using TXSOM = BitField<1, 1>;
    constexpr uint32_t TXSOM_Pos = 1;
    constexpr uint32_t TXSOM_Msk = TXSOM::mask;
    /// Enumerated values for TXSOM
    namespace txsom {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx end of message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN = 1. TXEOM must be set before writing transmission data to TXDR. If TXEOM is set when TXSOM = 0, transmitted message consists of 1 byte (HEADER) only (PING message).
    /// Position: 2, Width: 1
    /// Access: read-write
    using TXEOM = BitField<2, 1>;
    constexpr uint32_t TXEOM_Pos = 2;
    constexpr uint32_t TXEOM_Msk = TXEOM::mask;
    /// Enumerated values for TXEOM
    namespace txeom {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace cec_cr

/// CEC_CFGR - This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
namespace cec_cfgr {
    /// Signal free time SFT bits are set by software. In the SFT = 0x0 configuration, the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. 0x0 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST = 1, TXERR = 1, TXUDR = 1 or TXACKE = 1) 4 data-bit periods if CEC is the new bus initiator 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM = 1)
    /// Position: 0, Width: 3
    /// Access: read-write
    using SFT = BitField<0, 3>;
    constexpr uint32_t SFT_Pos = 0;
    constexpr uint32_t SFT_Msk = SFT::mask;
    /// Enumerated values for SFT
    namespace sft {
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Rx-tolerance The RXTOL bit is set and cleared by software. Start-bit, +/- 200 µs rise, +/- 200 µs fall Data-bit: +/- 200 µs rise. +/- 350 µs fall Start-bit: +/- 400 µs rise, +/- 400 µs fall Data-bit: +/-300 µs rise, +/- 500 µs fall
    /// Position: 3, Width: 1
    /// Access: read-write
    using RXTOL = BitField<3, 1>;
    constexpr uint32_t RXTOL_Pos = 3;
    constexpr uint32_t RXTOL_Msk = RXTOL::mask;
    /// Enumerated values for RXTOL
    namespace rxtol {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx-stop on bit rising error The BRESTP bit is set and cleared by software.
    /// Position: 4, Width: 1
    /// Access: read-write
    using BRESTP = BitField<4, 1>;
    constexpr uint32_t BRESTP_Pos = 4;
    constexpr uint32_t BRESTP_Msk = BRESTP::mask;
    /// Enumerated values for BRESTP
    namespace brestp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Generate error-bit on bit rising error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN = 0, an error-bit is generated upon BRE detection with BRESTP = 1 in broadcast even if BREGEN = 0.
    /// Position: 5, Width: 1
    /// Access: read-write
    using BREGEN = BitField<5, 1>;
    constexpr uint32_t BREGEN_Pos = 5;
    constexpr uint32_t BREGEN_Msk = BREGEN::mask;
    /// Enumerated values for BREGEN
    namespace bregen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Generate error-bit on long bit period error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN = 0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN = 0.
    /// Position: 6, Width: 1
    /// Access: read-write
    using LBPEGEN = BitField<6, 1>;
    constexpr uint32_t LBPEGEN_Pos = 6;
    constexpr uint32_t LBPEGEN_Msk = LBPEGEN::mask;
    /// Enumerated values for LBPEGEN
    namespace lbpegen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Avoid error-bit generation in broadcast The BRDNOGEN bit is set and cleared by software. error-bit on the CEC line. LBPE detection with LBPEGEN = 0 on a broadcast message generates an error-bit on the CEC line.
    /// Position: 7, Width: 1
    /// Access: read-write
    using BRDNOGEN = BitField<7, 1>;
    constexpr uint32_t BRDNOGEN_Pos = 7;
    constexpr uint32_t BRDNOGEN_Msk = BRDNOGEN::mask;
    /// Enumerated values for BRDNOGEN
    namespace brdnogen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// SFT option bit The SFTOPT bit is set and cleared by software.
    /// Position: 8, Width: 1
    /// Access: read-write
    using SFTOP = BitField<8, 1>;
    constexpr uint32_t SFTOP_Pos = 8;
    constexpr uint32_t SFTOP_Msk = SFTOP::mask;
    /// Enumerated values for SFTOP
    namespace sftop {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN = 1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.
    /// Position: 16, Width: 15
    /// Access: read-write
    using OAR = BitField<16, 15>;
    constexpr uint32_t OAR_Pos = 16;
    constexpr uint32_t OAR_Msk = OAR::mask;

    /// Listen mode LSTN bit is set and cleared by software.
    /// Position: 31, Width: 1
    /// Access: read-write
    using LSTN = BitField<31, 1>;
    constexpr uint32_t LSTN_Pos = 31;
    constexpr uint32_t LSTN_Msk = LSTN::mask;
    /// Enumerated values for LSTN
    namespace lstn {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace cec_cfgr

/// CEC_TXDR - CEC Tx data register
namespace cec_txdr {
    /// Tx Data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1
    /// Position: 0, Width: 8
    using TXD = BitField<0, 8>;
    constexpr uint32_t TXD_Pos = 0;
    constexpr uint32_t TXD_Msk = TXD::mask;

}  // namespace cec_txdr

/// CEC_RXDR - CEC Rx Data Register
namespace cec_rxdr {
    /// Rx Data register. RXD is read-only and contains the last data byte which has been received from the CEC line.
    /// Position: 0, Width: 8
    using RXD = BitField<0, 8>;
    constexpr uint32_t RXD_Pos = 0;
    constexpr uint32_t RXD_Msk = RXD::mask;

}  // namespace cec_rxdr

/// CEC_ISR - CEC Interrupt and Status Register
namespace cec_isr {
    /// Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.
    /// Position: 0, Width: 1
    using RXBR = BitField<0, 1>;
    constexpr uint32_t RXBR_Pos = 0;
    constexpr uint32_t RXBR_Msk = RXBR::mask;

    /// End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
    /// Position: 1, Width: 1
    using RXEND = BitField<1, 1>;
    constexpr uint32_t RXEND_Pos = 1;
    constexpr uint32_t RXEND_Msk = RXEND::mask;

    /// Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
    /// Position: 2, Width: 1
    using RXOVR = BitField<2, 1>;
    constexpr uint32_t RXOVR_Pos = 2;
    constexpr uint32_t RXOVR_Msk = RXOVR::mask;

    /// Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
    /// Position: 3, Width: 1
    using BRE = BitField<3, 1>;
    constexpr uint32_t BRE_Pos = 3;
    constexpr uint32_t BRE_Msk = BRE::mask;

    /// Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
    /// Position: 4, Width: 1
    using SBPE = BitField<4, 1>;
    constexpr uint32_t SBPE_Pos = 4;
    constexpr uint32_t SBPE_Msk = SBPE::mask;

    /// Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
    /// Position: 5, Width: 1
    using LBPE = BitField<5, 1>;
    constexpr uint32_t LBPE_Pos = 5;
    constexpr uint32_t LBPE_Msk = LBPE::mask;

    /// Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
    /// Position: 6, Width: 1
    using RXACKE = BitField<6, 1>;
    constexpr uint32_t RXACKE_Pos = 6;
    constexpr uint32_t RXACKE_Msk = RXACKE::mask;

    /// Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
    /// Position: 7, Width: 1
    using ARBLST = BitField<7, 1>;
    constexpr uint32_t ARBLST_Pos = 7;
    constexpr uint32_t ARBLST_Msk = ARBLST::mask;

    /// Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
    /// Position: 8, Width: 1
    using TXBR = BitField<8, 1>;
    constexpr uint32_t TXBR_Pos = 8;
    constexpr uint32_t TXBR_Msk = TXBR::mask;

    /// End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
    /// Position: 9, Width: 1
    using TXEND = BitField<9, 1>;
    constexpr uint32_t TXEND_Pos = 9;
    constexpr uint32_t TXEND_Msk = TXEND::mask;

    /// Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
    /// Position: 10, Width: 1
    using TXUDR = BitField<10, 1>;
    constexpr uint32_t TXUDR_Pos = 10;
    constexpr uint32_t TXUDR_Msk = TXUDR::mask;

    /// Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
    /// Position: 11, Width: 1
    using TXERR = BitField<11, 1>;
    constexpr uint32_t TXERR_Pos = 11;
    constexpr uint32_t TXERR_Msk = TXERR::mask;

    /// Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
    /// Position: 12, Width: 1
    using TXACKE = BitField<12, 1>;
    constexpr uint32_t TXACKE_Pos = 12;
    constexpr uint32_t TXACKE_Msk = TXACKE::mask;

}  // namespace cec_isr

/// CEC_IER - CEC interrupt enable register
namespace cec_ier {
    /// Rx-byte received interrupt enable The RXBRIE bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using RXBRIE = BitField<0, 1>;
    constexpr uint32_t RXBRIE_Pos = 0;
    constexpr uint32_t RXBRIE_Msk = RXBRIE::mask;
    /// Enumerated values for RXBRIE
    namespace rxbrie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End of reception interrupt enable The RXENDIE bit is set and cleared by software.
    /// Position: 1, Width: 1
    /// Access: read-write
    using RXENDIE = BitField<1, 1>;
    constexpr uint32_t RXENDIE_Pos = 1;
    constexpr uint32_t RXENDIE_Msk = RXENDIE::mask;
    /// Enumerated values for RXENDIE
    namespace rxendie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx-buffer overrun interrupt enable The RXOVRIE bit is set and cleared by software.
    /// Position: 2, Width: 1
    /// Access: read-write
    using RXOVRIE = BitField<2, 1>;
    constexpr uint32_t RXOVRIE_Pos = 2;
    constexpr uint32_t RXOVRIE_Msk = RXOVRIE::mask;
    /// Enumerated values for RXOVRIE
    namespace rxovrie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Bit rising error interrupt enable The BREIE bit is set and cleared by software.
    /// Position: 3, Width: 1
    /// Access: read-write
    using BREIE = BitField<3, 1>;
    constexpr uint32_t BREIE_Pos = 3;
    constexpr uint32_t BREIE_Msk = BREIE::mask;
    /// Enumerated values for BREIE
    namespace breie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Short bit period error interrupt enable The SBPEIE bit is set and cleared by software.
    /// Position: 4, Width: 1
    /// Access: read-write
    using SBPEIE = BitField<4, 1>;
    constexpr uint32_t SBPEIE_Pos = 4;
    constexpr uint32_t SBPEIE_Msk = SBPEIE::mask;
    /// Enumerated values for SBPEIE
    namespace sbpeie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Long bit period error interrupt enable The LBPEIE bit is set and cleared by software.
    /// Position: 5, Width: 1
    /// Access: read-write
    using LBPEIE = BitField<5, 1>;
    constexpr uint32_t LBPEIE_Pos = 5;
    constexpr uint32_t LBPEIE_Msk = LBPEIE::mask;
    /// Enumerated values for LBPEIE
    namespace lbpeie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx-missing acknowledge error interrupt enable The RXACKIE bit is set and cleared by software.
    /// Position: 6, Width: 1
    /// Access: read-write
    using RXACKIE = BitField<6, 1>;
    constexpr uint32_t RXACKIE_Pos = 6;
    constexpr uint32_t RXACKIE_Msk = RXACKIE::mask;
    /// Enumerated values for RXACKIE
    namespace rxackie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Arbitration lost interrupt enable The ARBLSTIE bit is set and cleared by software.
    /// Position: 7, Width: 1
    /// Access: read-write
    using ARBLSTIE = BitField<7, 1>;
    constexpr uint32_t ARBLSTIE_Pos = 7;
    constexpr uint32_t ARBLSTIE_Msk = ARBLSTIE::mask;
    /// Enumerated values for ARBLSTIE
    namespace arblstie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx-byte request interrupt enable The TXBRIE bit is set and cleared by software.
    /// Position: 8, Width: 1
    /// Access: read-write
    using TXBRIE = BitField<8, 1>;
    constexpr uint32_t TXBRIE_Pos = 8;
    constexpr uint32_t TXBRIE_Msk = TXBRIE::mask;
    /// Enumerated values for TXBRIE
    namespace txbrie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx-end of message interrupt enable The TXENDIE bit is set and cleared by software.
    /// Position: 9, Width: 1
    /// Access: read-write
    using TXENDIE = BitField<9, 1>;
    constexpr uint32_t TXENDIE_Pos = 9;
    constexpr uint32_t TXENDIE_Msk = TXENDIE::mask;
    /// Enumerated values for TXENDIE
    namespace txendie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx-underrun interrupt enable The TXUDRIE bit is set and cleared by software.
    /// Position: 10, Width: 1
    /// Access: read-write
    using TXUDRIE = BitField<10, 1>;
    constexpr uint32_t TXUDRIE_Pos = 10;
    constexpr uint32_t TXUDRIE_Msk = TXUDRIE::mask;
    /// Enumerated values for TXUDRIE
    namespace txudrie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx-error interrupt enable The TXERRIE bit is set and cleared by software.
    /// Position: 11, Width: 1
    /// Access: read-write
    using TXERRIE = BitField<11, 1>;
    constexpr uint32_t TXERRIE_Pos = 11;
    constexpr uint32_t TXERRIE_Msk = TXERRIE::mask;
    /// Enumerated values for TXERRIE
    namespace txerrie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx-missing acknowledge error interrupt enable The TXACKEIE bit is set and cleared by software.
    /// Position: 12, Width: 1
    /// Access: read-write
    using TXACKIE = BitField<12, 1>;
    constexpr uint32_t TXACKIE_Pos = 12;
    constexpr uint32_t TXACKIE_Msk = TXACKIE::mask;
    /// Enumerated values for TXACKIE
    namespace txackie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace cec_ier

}  // namespace alloy::hal::st::stm32g0::hdmi_cec
