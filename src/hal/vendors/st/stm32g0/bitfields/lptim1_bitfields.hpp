/// Auto-generated bit field definitions for LPTIM1
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::lptim1 {

using namespace alloy::hal::bitfields;

// ============================================================================
// LPTIM1 Bit Field Definitions
// ============================================================================

/// LPTIM_ISR - Interrupt and Status Register
namespace lptim_isr {
    /// Compare match The CMPM bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP registerâs value.
    /// Position: 0, Width: 1
    /// Access: read-only
    using CMPM = BitField<0, 1>;
    constexpr uint32_t CMPM_Pos = 0;
    constexpr uint32_t CMPM_Msk = CMPM::mask;

    /// Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registerâs value reached the LPTIM_ARR registerâs value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.
    /// Position: 1, Width: 1
    /// Access: read-only
    using ARRM = BitField<1, 1>;
    constexpr uint32_t ARRM_Pos = 1;
    constexpr uint32_t ARRM_Msk = ARRM::mask;

    /// External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.
    /// Position: 2, Width: 1
    /// Access: read-only
    using EXTTRIG = BitField<2, 1>;
    constexpr uint32_t EXTTRIG_Pos = 2;
    constexpr uint32_t EXTTRIG_Msk = EXTTRIG::mask;

    /// Compare register update OK CMPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_CMP register has been successfully completed.
    /// Position: 3, Width: 1
    /// Access: read-only
    using CMPOK = BitField<3, 1>;
    constexpr uint32_t CMPOK_Pos = 3;
    constexpr uint32_t CMPOK_Msk = CMPOK::mask;

    /// Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.
    /// Position: 4, Width: 1
    /// Access: read-only
    using ARROK = BitField<4, 1>;
    constexpr uint32_t ARROK_Pos = 4;
    constexpr uint32_t ARROK_Msk = ARROK::mask;

    /// Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    /// Position: 5, Width: 1
    /// Access: read-only
    using UP = BitField<5, 1>;
    constexpr uint32_t UP_Pos = 5;
    constexpr uint32_t UP_Msk = UP::mask;

    /// Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    /// Position: 6, Width: 1
    /// Access: read-only
    using DOWN = BitField<6, 1>;
    constexpr uint32_t DOWN_Pos = 6;
    constexpr uint32_t DOWN_Msk = DOWN::mask;

}  // namespace lptim_isr

/// LPTIM_ICR - Interrupt Clear Register
namespace lptim_icr {
    /// Compare match clear flag Writing 1 to this bit clears the CMP flag in the LPTIM_ISR register
    /// Position: 0, Width: 1
    /// Access: write-only
    using CMPMCF = BitField<0, 1>;
    constexpr uint32_t CMPMCF_Pos = 0;
    constexpr uint32_t CMPMCF_Msk = CMPMCF::mask;

    /// Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register
    /// Position: 1, Width: 1
    /// Access: write-only
    using ARRMCF = BitField<1, 1>;
    constexpr uint32_t ARRMCF_Pos = 1;
    constexpr uint32_t ARRMCF_Msk = ARRMCF::mask;

    /// External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register
    /// Position: 2, Width: 1
    /// Access: write-only
    using EXTTRIGCF = BitField<2, 1>;
    constexpr uint32_t EXTTRIGCF_Pos = 2;
    constexpr uint32_t EXTTRIGCF_Msk = EXTTRIGCF::mask;

    /// Compare register update OK clear flag Writing 1 to this bit clears the CMPOK flag in the LPTIM_ISR register
    /// Position: 3, Width: 1
    /// Access: write-only
    using CMPOKCF = BitField<3, 1>;
    constexpr uint32_t CMPOKCF_Pos = 3;
    constexpr uint32_t CMPOKCF_Msk = CMPOKCF::mask;

    /// Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register
    /// Position: 4, Width: 1
    /// Access: write-only
    using ARROKCF = BitField<4, 1>;
    constexpr uint32_t ARROKCF_Pos = 4;
    constexpr uint32_t ARROKCF_Msk = ARROKCF::mask;

    /// Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    /// Position: 5, Width: 1
    /// Access: write-only
    using UPCF = BitField<5, 1>;
    constexpr uint32_t UPCF_Pos = 5;
    constexpr uint32_t UPCF_Msk = UPCF::mask;

    /// Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    /// Position: 6, Width: 1
    /// Access: write-only
    using DOWNCF = BitField<6, 1>;
    constexpr uint32_t DOWNCF_Pos = 6;
    constexpr uint32_t DOWNCF_Msk = DOWNCF::mask;

}  // namespace lptim_icr

/// LPTIM_IER - Interrupt Enable Register
namespace lptim_ier {
    /// Compare match Interrupt Enable
    /// Position: 0, Width: 1
    /// Access: read-write
    using CMPMIE = BitField<0, 1>;
    constexpr uint32_t CMPMIE_Pos = 0;
    constexpr uint32_t CMPMIE_Msk = CMPMIE::mask;
    /// Enumerated values for CMPMIE
    namespace cmpmie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Autoreload match Interrupt Enable
    /// Position: 1, Width: 1
    /// Access: read-write
    using ARRMIE = BitField<1, 1>;
    constexpr uint32_t ARRMIE_Pos = 1;
    constexpr uint32_t ARRMIE_Msk = ARRMIE::mask;
    /// Enumerated values for ARRMIE
    namespace arrmie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// External trigger valid edge Interrupt Enable
    /// Position: 2, Width: 1
    /// Access: read-write
    using EXTTRIGIE = BitField<2, 1>;
    constexpr uint32_t EXTTRIGIE_Pos = 2;
    constexpr uint32_t EXTTRIGIE_Msk = EXTTRIGIE::mask;
    /// Enumerated values for EXTTRIGIE
    namespace exttrigie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Compare register update OK Interrupt Enable
    /// Position: 3, Width: 1
    /// Access: read-write
    using CMPOKIE = BitField<3, 1>;
    constexpr uint32_t CMPOKIE_Pos = 3;
    constexpr uint32_t CMPOKIE_Msk = CMPOKIE::mask;
    /// Enumerated values for CMPOKIE
    namespace cmpokie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Autoreload register update OK Interrupt Enable
    /// Position: 4, Width: 1
    /// Access: read-write
    using ARROKIE = BitField<4, 1>;
    constexpr uint32_t ARROKIE_Pos = 4;
    constexpr uint32_t ARROKIE_Msk = ARROKIE::mask;
    /// Enumerated values for ARROKIE
    namespace arrokie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Direction change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    /// Position: 5, Width: 1
    /// Access: read-write
    using UPIE = BitField<5, 1>;
    constexpr uint32_t UPIE_Pos = 5;
    constexpr uint32_t UPIE_Msk = UPIE::mask;
    /// Enumerated values for UPIE
    namespace upie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Direction change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    /// Position: 6, Width: 1
    /// Access: read-write
    using DOWNIE = BitField<6, 1>;
    constexpr uint32_t DOWNIE_Pos = 6;
    constexpr uint32_t DOWNIE_Msk = DOWNIE::mask;
    /// Enumerated values for DOWNIE
    namespace downie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace lptim_ier

/// LPTIM_CFGR - Configuration Register
namespace lptim_cfgr {
    /// Clock selector The CKSEL bit selects which clock source the LPTIM will use:
    /// Position: 0, Width: 1
    /// Access: read-write
    using CKSEL = BitField<0, 1>;
    constexpr uint32_t CKSEL_Pos = 0;
    constexpr uint32_t CKSEL_Msk = CKSEL::mask;
    /// Enumerated values for CKSEL
    namespace cksel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Clock Polarity If LPTIM is clocked by an external clock source: When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter: If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active. Refer to for more details about Encoder mode sub-modes.
    /// Position: 1, Width: 2
    /// Access: read-write
    using CKPOL = BitField<1, 2>;
    constexpr uint32_t CKPOL_Pos = 1;
    constexpr uint32_t CKPOL_Msk = CKPOL::mask;
    /// Enumerated values for CKPOL
    namespace ckpol {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Configurable digital filter for external clock The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
    /// Position: 3, Width: 2
    /// Access: read-write
    using CKFLT = BitField<3, 2>;
    constexpr uint32_t CKFLT_Pos = 3;
    constexpr uint32_t CKFLT_Msk = CKFLT::mask;
    /// Enumerated values for CKFLT
    namespace ckflt {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Configurable digital filter for trigger The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
    /// Position: 6, Width: 2
    /// Access: read-write
    using TRGFLT = BitField<6, 2>;
    constexpr uint32_t TRGFLT_Pos = 6;
    constexpr uint32_t TRGFLT_Msk = TRGFLT::mask;
    /// Enumerated values for TRGFLT
    namespace trgflt {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Clock prescaler The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
    /// Position: 9, Width: 3
    /// Access: read-write
    using PRESC = BitField<9, 3>;
    constexpr uint32_t PRESC_Pos = 9;
    constexpr uint32_t PRESC_Msk = PRESC::mask;
    /// Enumerated values for PRESC
    namespace presc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Trigger selector The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources: See for details.
    /// Position: 13, Width: 3
    /// Access: read-write
    using TRIGSEL = BitField<13, 3>;
    constexpr uint32_t TRIGSEL_Pos = 13;
    constexpr uint32_t TRIGSEL_Msk = TRIGSEL::mask;
    /// Enumerated values for TRIGSEL
    namespace trigsel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Trigger enable and polarity The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
    /// Position: 17, Width: 2
    /// Access: read-write
    using TRIGEN = BitField<17, 2>;
    constexpr uint32_t TRIGEN_Pos = 17;
    constexpr uint32_t TRIGEN_Msk = TRIGEN::mask;
    /// Enumerated values for TRIGEN
    namespace trigen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Timeout enable The TIMOUT bit controls the Timeout feature
    /// Position: 19, Width: 1
    /// Access: read-write
    using TIMOUT = BitField<19, 1>;
    constexpr uint32_t TIMOUT_Pos = 19;
    constexpr uint32_t TIMOUT_Msk = TIMOUT::mask;
    /// Enumerated values for TIMOUT
    namespace timout {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Waveform shape The WAVE bit controls the output shape
    /// Position: 20, Width: 1
    /// Access: read-write
    using WAVE = BitField<20, 1>;
    constexpr uint32_t WAVE_Pos = 20;
    constexpr uint32_t WAVE_Msk = WAVE::mask;
    /// Enumerated values for WAVE
    namespace wave {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Waveform shape polarity The WAVEPOL bit controls the output polarity
    /// Position: 21, Width: 1
    /// Access: read-write
    using WAVPOL = BitField<21, 1>;
    constexpr uint32_t WAVPOL_Pos = 21;
    constexpr uint32_t WAVPOL_Msk = WAVPOL::mask;
    /// Enumerated values for WAVPOL
    namespace wavpol {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Registers update mode The PRELOAD bit controls the LPTIM_ARR and the LPTIM_CMP registers update modality
    /// Position: 22, Width: 1
    /// Access: read-write
    using PRELOAD = BitField<22, 1>;
    constexpr uint32_t PRELOAD_Pos = 22;
    constexpr uint32_t PRELOAD_Msk = PRELOAD::mask;
    /// Enumerated values for PRELOAD
    namespace preload {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// counter mode enabled The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:
    /// Position: 23, Width: 1
    /// Access: read-write
    using COUNTMODE = BitField<23, 1>;
    constexpr uint32_t COUNTMODE_Pos = 23;
    constexpr uint32_t COUNTMODE_Msk = COUNTMODE::mask;
    /// Enumerated values for COUNTMODE
    namespace countmode {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Encoder mode enable The ENC bit controls the Encoder mode Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .
    /// Position: 24, Width: 1
    /// Access: read-write
    using ENC = BitField<24, 1>;
    constexpr uint32_t ENC_Pos = 24;
    constexpr uint32_t ENC_Msk = ENC::mask;
    /// Enumerated values for ENC
    namespace enc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace lptim_cfgr

/// LPTIM_CR - Control Register
namespace lptim_cr {
    /// LPTIM enable The ENABLE bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using ENABLE = BitField<0, 1>;
    constexpr uint32_t ENABLE_Pos = 0;
    constexpr uint32_t ENABLE_Msk = ENABLE::mask;
    /// Enumerated values for ENABLE
    namespace enable {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// LPTIM start in Single mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = '00â), setting this bit starts the LPTIM in single pulse mode. If the software start is disabled (TRIGEN[1:0] different than '00â), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected. If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between LPTIM_ARR and LPTIM_CNT registers. This bit can only be set when the LPTIM is enabled. It will be automatically reset by hardware.
    /// Position: 1, Width: 1
    /// Access: read-write
    using SNGSTRT = BitField<1, 1>;
    constexpr uint32_t SNGSTRT_Pos = 1;
    constexpr uint32_t SNGSTRT_Msk = SNGSTRT::mask;

    /// Timer start in Continuous mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = '00â), setting this bit starts the LPTIM in Continuous mode. If the software start is disabled (TRIGEN[1:0] different than '00â), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected. If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between the LPTIM_ARR and LPTIM_CNT registers and the LPTIM counter keeps counting in Continuous mode. This bit can be set only when the LPTIM is enabled. It will be automatically reset by hardware.
    /// Position: 2, Width: 1
    /// Access: read-write
    using CNTSTRT = BitField<2, 1>;
    constexpr uint32_t CNTSTRT_Pos = 2;
    constexpr uint32_t CNTSTRT_Msk = CNTSTRT::mask;

    /// Counter reset This bit is set by software and cleared by hardware. When set to '1' this bit will trigger a synchronous reset of the LPTIM_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock). COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software should consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'.
    /// Position: 3, Width: 1
    /// Access: read-write
    using COUNTRST = BitField<3, 1>;
    constexpr uint32_t COUNTRST_Pos = 3;
    constexpr uint32_t COUNTRST_Msk = COUNTRST::mask;

    /// Reset after read enable This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM_CNT register will asynchronously reset LPTIM_CNT register content.
    /// Position: 4, Width: 1
    /// Access: read-write
    using RSTARE = BitField<4, 1>;
    constexpr uint32_t RSTARE_Pos = 4;
    constexpr uint32_t RSTARE_Msk = RSTARE::mask;

}  // namespace lptim_cr

/// LPTIM_CMP - Compare Register
namespace lptim_cmp {
    /// Compare value
    /// Position: 0, Width: 16
    using CMP = BitField<0, 16>;
    constexpr uint32_t CMP_Pos = 0;
    constexpr uint32_t CMP_Msk = CMP::mask;

}  // namespace lptim_cmp

/// LPTIM_ARR - Autoreload Register
namespace lptim_arr {
    /// Auto reload value
    /// Position: 0, Width: 16
    using ARR = BitField<0, 16>;
    constexpr uint32_t ARR_Pos = 0;
    constexpr uint32_t ARR_Msk = ARR::mask;

}  // namespace lptim_arr

/// LPTIM_CNT - Counter Register
namespace lptim_cnt {
    /// Counter value
    /// Position: 0, Width: 16
    using CNT = BitField<0, 16>;
    constexpr uint32_t CNT_Pos = 0;
    constexpr uint32_t CNT_Msk = CNT::mask;

}  // namespace lptim_cnt

/// LPTIM_CFGR2 - LPTIM configuration register 2
namespace lptim_cfgr2 {
    /// LPTIM input 1 selection The IN1SEL bits control the LPTIM Input 1 multiplexer, which connects LPTIM Input 1 to one of the available inputs. For connection details refer to .
    /// Position: 0, Width: 2
    /// Access: read-write
    using IN1SEL = BitField<0, 2>;
    constexpr uint32_t IN1SEL_Pos = 0;
    constexpr uint32_t IN1SEL_Msk = IN1SEL::mask;
    /// Enumerated values for IN1SEL
    namespace in1sel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// LPTIM input 2 selection The IN2SEL bits control the LPTIM Input 2 multiplexer, which connect LPTIM Input 2 to one of the available inputs. For connection details refer to . Note: If the LPTIM does not support encoder mode feature, these bits are reserved. Please refer to .
    /// Position: 4, Width: 2
    /// Access: read-write
    using IN2SEL = BitField<4, 2>;
    constexpr uint32_t IN2SEL_Pos = 4;
    constexpr uint32_t IN2SEL_Msk = IN2SEL::mask;
    /// Enumerated values for IN2SEL
    namespace in2sel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

}  // namespace lptim_cfgr2

}  // namespace alloy::hal::st::stm32g0::lptim1
