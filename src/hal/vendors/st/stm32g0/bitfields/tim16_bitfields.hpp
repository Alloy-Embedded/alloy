/// Auto-generated bit field definitions for TIM16
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::tim16 {

using namespace alloy::hal::bitfields;

// ============================================================================
// TIM16 Bit Field Definitions
// ============================================================================

/// CR1 - control register 1
namespace cr1 {
    /// Counter enable Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CEN = BitField<0, 1>;
    constexpr uint32_t CEN_Pos = 0;
    constexpr uint32_t CEN_Msk = CEN::mask;
    /// Enumerated values for CEN
    namespace cen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.
    /// Position: 1, Width: 1
    /// Access: read-write
    using UDIS = BitField<1, 1>;
    constexpr uint32_t UDIS_Pos = 1;
    constexpr uint32_t UDIS_Msk = UDIS::mask;
    /// Enumerated values for UDIS
    namespace udis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller
    /// Position: 2, Width: 1
    /// Access: read-write
    using URS = BitField<2, 1>;
    constexpr uint32_t URS_Pos = 2;
    constexpr uint32_t URS_Msk = URS::mask;
    /// Enumerated values for URS
    namespace urs {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// One pulse mode
    /// Position: 3, Width: 1
    /// Access: read-write
    using OPM = BitField<3, 1>;
    constexpr uint32_t OPM_Pos = 3;
    constexpr uint32_t OPM_Msk = OPM::mask;
    /// Enumerated values for OPM
    namespace opm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Auto-reload preload enable
    /// Position: 7, Width: 1
    /// Access: read-write
    using ARPE = BitField<7, 1>;
    constexpr uint32_t ARPE_Pos = 7;
    constexpr uint32_t ARPE_Msk = ARPE::mask;
    /// Enumerated values for ARPE
    namespace arpe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Clock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (TIx),
    /// Position: 8, Width: 2
    /// Access: read-write
    using CKD = BitField<8, 2>;
    constexpr uint32_t CKD_Pos = 8;
    constexpr uint32_t CKD_Msk = CKD::mask;
    /// Enumerated values for CKD
    namespace ckd {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// UIF status bit remapping
    /// Position: 11, Width: 1
    /// Access: read-write
    using UIFREMAP = BitField<11, 1>;
    constexpr uint32_t UIFREMAP_Pos = 11;
    constexpr uint32_t UIFREMAP_Msk = UIFREMAP::mask;
    /// Enumerated values for UIFREMAP
    namespace uifremap {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace cr1

/// CR2 - control register 2
namespace cr2 {
    /// Capture/compare preloaded control Note: This bit acts only on channels that have a complementary output.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CCPC = BitField<0, 1>;
    constexpr uint32_t CCPC_Pos = 0;
    constexpr uint32_t CCPC_Msk = CCPC::mask;
    /// Enumerated values for CCPC
    namespace ccpc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/compare control update selection Note: This bit acts only on channels that have a complementary output.
    /// Position: 2, Width: 1
    /// Access: read-write
    using CCUS = BitField<2, 1>;
    constexpr uint32_t CCUS_Pos = 2;
    constexpr uint32_t CCUS_Msk = CCUS::mask;
    /// Enumerated values for CCUS
    namespace ccus {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/compare DMA selection
    /// Position: 3, Width: 1
    /// Access: read-write
    using CCDS = BitField<3, 1>;
    constexpr uint32_t CCDS_Pos = 3;
    constexpr uint32_t CCDS_Msk = CCDS::mask;
    /// Enumerated values for CCDS
    namespace ccds {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output Idle state 1 (OC1 output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 8, Width: 1
    /// Access: read-write
    using OIS1 = BitField<8, 1>;
    constexpr uint32_t OIS1_Pos = 8;
    constexpr uint32_t OIS1_Msk = OIS1::mask;
    /// Enumerated values for OIS1
    namespace ois1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output Idle state 1 (OC1N output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 9, Width: 1
    /// Access: read-write
    using OIS1N = BitField<9, 1>;
    constexpr uint32_t OIS1N_Pos = 9;
    constexpr uint32_t OIS1N_Msk = OIS1N::mask;
    /// Enumerated values for OIS1N
    namespace ois1n {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace cr2

/// DIER - DMA/Interrupt enable register
namespace dier {
    /// Update interrupt enable
    /// Position: 0, Width: 1
    /// Access: read-write
    using UIE = BitField<0, 1>;
    constexpr uint32_t UIE_Pos = 0;
    constexpr uint32_t UIE_Msk = UIE::mask;
    /// Enumerated values for UIE
    namespace uie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 interrupt enable
    /// Position: 1, Width: 1
    /// Access: read-write
    using CC1IE = BitField<1, 1>;
    constexpr uint32_t CC1IE_Pos = 1;
    constexpr uint32_t CC1IE_Msk = CC1IE::mask;
    /// Enumerated values for CC1IE
    namespace cc1ie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// COM interrupt enable
    /// Position: 5, Width: 1
    /// Access: read-write
    using COMIE = BitField<5, 1>;
    constexpr uint32_t COMIE_Pos = 5;
    constexpr uint32_t COMIE_Msk = COMIE::mask;
    /// Enumerated values for COMIE
    namespace comie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Break interrupt enable
    /// Position: 7, Width: 1
    /// Access: read-write
    using BIE = BitField<7, 1>;
    constexpr uint32_t BIE_Pos = 7;
    constexpr uint32_t BIE_Msk = BIE::mask;
    /// Enumerated values for BIE
    namespace bie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Update DMA request enable
    /// Position: 8, Width: 1
    /// Access: read-write
    using UDE = BitField<8, 1>;
    constexpr uint32_t UDE_Pos = 8;
    constexpr uint32_t UDE_Msk = UDE::mask;
    /// Enumerated values for UDE
    namespace ude {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 DMA request enable
    /// Position: 9, Width: 1
    /// Access: read-write
    using CC1DE = BitField<9, 1>;
    constexpr uint32_t CC1DE_Pos = 9;
    constexpr uint32_t CC1DE_Msk = CC1DE::mask;
    /// Enumerated values for CC1DE
    namespace cc1de {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dier

/// SR - status register
namespace sr {
    /// Update interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
    /// Position: 0, Width: 1
    /// Access: read-write
    using UIF = BitField<0, 1>;
    constexpr uint32_t UIF_Pos = 0;
    constexpr uint32_t UIF_Msk = UIF::mask;
    /// Enumerated values for UIF
    namespace uif {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).
    /// Position: 1, Width: 1
    /// Access: read-write
    using CC1IF = BitField<1, 1>;
    constexpr uint32_t CC1IF_Pos = 1;
    constexpr uint32_t CC1IF_Msk = CC1IF::mask;
    /// Enumerated values for CC1IF
    namespace cc1if {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// COM interrupt flag This flag is set by hardware on a COM event (once the capture/compare control bits âCCxE, CCxNE, OCxMâ have been updated). It is cleared by software.
    /// Position: 5, Width: 1
    /// Access: read-write
    using COMIF = BitField<5, 1>;
    constexpr uint32_t COMIF_Pos = 5;
    constexpr uint32_t COMIF_Msk = COMIF::mask;
    /// Enumerated values for COMIF
    namespace comif {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Break interrupt flag This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
    /// Position: 7, Width: 1
    /// Access: read-write
    using BIF = BitField<7, 1>;
    constexpr uint32_t BIF_Pos = 7;
    constexpr uint32_t BIF_Msk = BIF::mask;
    /// Enumerated values for BIF
    namespace bif {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0â.
    /// Position: 9, Width: 1
    /// Access: read-write
    using CC1OF = BitField<9, 1>;
    constexpr uint32_t CC1OF_Pos = 9;
    constexpr uint32_t CC1OF_Msk = CC1OF::mask;
    /// Enumerated values for CC1OF
    namespace cc1of {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace sr

/// EGR - event generation register
namespace egr {
    /// Update generation This bit can be set by software, it is automatically cleared by hardware.
    /// Position: 0, Width: 1
    /// Access: write-only
    using UG = BitField<0, 1>;
    constexpr uint32_t UG_Pos = 0;
    constexpr uint32_t UG_Msk = UG::mask;
    /// Enumerated values for UG
    namespace ug {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
    /// Position: 1, Width: 1
    /// Access: write-only
    using CC1G = BitField<1, 1>;
    constexpr uint32_t CC1G_Pos = 1;
    constexpr uint32_t CC1G_Msk = CC1G::mask;
    /// Enumerated values for CC1G
    namespace cc1g {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare control update generation This bit can be set by software, it is automatically cleared by hardware. Note: This bit acts only on channels that have a complementary output.
    /// Position: 5, Width: 1
    /// Access: write-only
    using COMG = BitField<5, 1>;
    constexpr uint32_t COMG_Pos = 5;
    constexpr uint32_t COMG_Msk = COMG::mask;
    /// Enumerated values for COMG
    namespace comg {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Break generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.
    /// Position: 7, Width: 1
    /// Access: write-only
    using BG = BitField<7, 1>;
    constexpr uint32_t BG_Pos = 7;
    constexpr uint32_t BG_Msk = BG::mask;
    /// Enumerated values for BG
    namespace bg {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace egr

/// CCMR1_Output - capture/compare mode register (output mode)
namespace ccmr1_output {
    /// Capture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Others: Reserved Note: CC1S bits are writable only when the channel is OFF (CC1E = '0â in TIMx_CCER).
    /// Position: 0, Width: 2
    /// Access: read-write
    using CC1S = BitField<0, 2>;
    constexpr uint32_t CC1S_Pos = 0;
    constexpr uint32_t CC1S_Msk = CC1S::mask;
    /// Enumerated values for CC1S
    namespace cc1s {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output Compare 1 fast enable This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.
    /// Position: 2, Width: 1
    /// Access: read-write
    using OC1FE = BitField<2, 1>;
    constexpr uint32_t OC1FE_Pos = 2;
    constexpr uint32_t OC1FE_Msk = OC1FE::mask;
    /// Enumerated values for OC1FE
    namespace oc1fe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output Compare 1 preload enable Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (the channel is configured in output). The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.
    /// Position: 3, Width: 1
    /// Access: read-write
    using OC1PE = BitField<3, 1>;
    constexpr uint32_t OC1PE_Pos = 3;
    constexpr uint32_t OC1PE_Msk = OC1PE::mask;
    /// Enumerated values for OC1PE
    namespace oc1pe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. All other values: Reserved Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (the channel is configured in output). In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from âfrozenâ mode to âPWMâ mode. The OC1M[3] bit is not contiguous, located in bit 16.
    /// Position: 4, Width: 3
    /// Access: read-write
    using OC1M1 = BitField<4, 3>;
    constexpr uint32_t OC1M1_Pos = 4;
    constexpr uint32_t OC1M1_Msk = OC1M1::mask;
    /// Enumerated values for OC1M1
    namespace oc1m1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Output Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. All other values: Reserved Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (the channel is configured in output). In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from âfrozenâ mode to âPWMâ mode. The OC1M[3] bit is not contiguous, located in bit 16.
    /// Position: 16, Width: 1
    /// Access: read-write
    using OC1M2 = BitField<16, 1>;
    constexpr uint32_t OC1M2_Pos = 16;
    constexpr uint32_t OC1M2_Msk = OC1M2::mask;
    /// Enumerated values for OC1M2
    namespace oc1m2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

}  // namespace ccmr1_output

/// CCMR1_Input - capture/compare mode register 1 (input mode)
namespace ccmr1_input {
    /// Capture/Compare 1 Selection This bit-field defines the direction of the channel (input/output) as well as the used input. Others: Reserved Note: CC1S bits are writable only when the channel is OFF (CC1E = '0â in TIMx_CCER).
    /// Position: 0, Width: 2
    /// Access: read-write
    using CC1S = BitField<0, 2>;
    constexpr uint32_t CC1S_Pos = 0;
    constexpr uint32_t CC1S_Msk = CC1S::mask;
    /// Enumerated values for CC1S
    namespace cc1s {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Input capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=â0â (TIMx_CCER register).
    /// Position: 2, Width: 2
    /// Access: read-write
    using IC1PSC = BitField<2, 2>;
    constexpr uint32_t IC1PSC_Pos = 2;
    constexpr uint32_t IC1PSC_Msk = IC1PSC::mask;
    /// Enumerated values for IC1PSC
    namespace ic1psc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Input capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
    /// Position: 4, Width: 4
    /// Access: read-write
    using IC1F = BitField<4, 4>;
    constexpr uint32_t IC1F_Pos = 4;
    constexpr uint32_t IC1F_Msk = IC1F::mask;
    /// Enumerated values for IC1F
    namespace ic1f {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0xA = 10;
        constexpr uint32_t B_0xB = 11;
        constexpr uint32_t B_0xC = 12;
        constexpr uint32_t B_0xD = 13;
        constexpr uint32_t B_0xE = 14;
        constexpr uint32_t B_0xF = 15;
    }

}  // namespace ccmr1_input

/// CCER - capture/compare enable register
namespace ccer {
    /// Capture/Compare 1 output enable When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to for details.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CC1E = BitField<0, 1>;
    constexpr uint32_t CC1E_Pos = 0;
    constexpr uint32_t CC1E_Msk = CC1E::mask;
    /// Enumerated values for CC1E
    namespace cc1e {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 output polarity When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: this configuration is reserved, it must not be used. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.
    /// Position: 1, Width: 1
    /// Access: read-write
    using CC1P = BitField<1, 1>;
    constexpr uint32_t CC1P_Pos = 1;
    constexpr uint32_t CC1P_Msk = CC1P::mask;
    /// Enumerated values for CC1P
    namespace cc1p {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 complementary output enable
    /// Position: 2, Width: 1
    /// Access: read-write
    using CC1NE = BitField<2, 1>;
    constexpr uint32_t CC1NE_Pos = 2;
    constexpr uint32_t CC1NE_Msk = CC1NE::mask;
    /// Enumerated values for CC1NE
    namespace cc1ne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 complementary output polarity CC1 channel configured as output: CC1 channel configured as input: This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to the description of CC1P. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=â00â (the channel is configured in output). On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated.
    /// Position: 3, Width: 1
    /// Access: read-write
    using CC1NP = BitField<3, 1>;
    constexpr uint32_t CC1NP_Pos = 3;
    constexpr uint32_t CC1NP_Msk = CC1NP::mask;
    /// Enumerated values for CC1NP
    namespace cc1np {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace ccer

/// CNT - counter
namespace cnt {
    /// counter value
    /// Position: 0, Width: 16
    /// Access: read-write
    using CNT = BitField<0, 16>;
    constexpr uint32_t CNT_Pos = 0;
    constexpr uint32_t CNT_Msk = CNT::mask;

    /// UIF Copy
    /// Position: 31, Width: 1
    /// Access: read-only
    using UIFCPY = BitField<31, 1>;
    constexpr uint32_t UIFCPY_Pos = 31;
    constexpr uint32_t UIFCPY_Msk = UIFCPY::mask;

}  // namespace cnt

/// PSC - prescaler
namespace psc {
    /// Prescaler value
    /// Position: 0, Width: 16
    using PSC = BitField<0, 16>;
    constexpr uint32_t PSC_Pos = 0;
    constexpr uint32_t PSC_Msk = PSC::mask;

}  // namespace psc

/// ARR - auto-reload register
namespace arr {
    /// Auto-reload value
    /// Position: 0, Width: 16
    using ARR = BitField<0, 16>;
    constexpr uint32_t ARR_Pos = 0;
    constexpr uint32_t ARR_Msk = ARR::mask;

}  // namespace arr

/// RCR - repetition counter register
namespace rcr {
    /// Repetition counter value
    /// Position: 0, Width: 8
    using REP = BitField<0, 8>;
    constexpr uint32_t REP_Pos = 0;
    constexpr uint32_t REP_Msk = REP::mask;

}  // namespace rcr

/// CCR1 - capture/compare register 1
namespace ccr1 {
    /// Capture/Compare 1 value
    /// Position: 0, Width: 16
    using CCR1 = BitField<0, 16>;
    constexpr uint32_t CCR1_Pos = 0;
    constexpr uint32_t CCR1_Msk = CCR1::mask;

}  // namespace ccr1

/// BDTR - break and dead-time register
namespace bdtr {
    /// Dead-time generator setup This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration. DTG[7:5]=0xx => DT=DTG[7:0]x tdtg with tdtg=tDTS DTG[7:5]=10x => DT=(64+DTG[5:0])xtdtg with Tdtg=2xtDTS DTG[7:5]=110 => DT=(32+DTG[4:0])xtdtg with Tdtg=8xtDTS DTG[7:5]=111 => DT=(32+DTG[4:0])xtdtg with Tdtg=16xtDTS Example if TDTS=125ns (8MHz), dead-time possible values are: 0 to 15875 ns by 125 ns steps, 16 Âµs to 31750 ns by 250 ns steps, 32 Âµs to 63 Âµs by 1 Âµs steps, 64 Âµs to 126 Âµs by 2 Âµs steps Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 0, Width: 8
    /// Access: read-write
    using DTG = BitField<0, 8>;
    constexpr uint32_t DTG_Pos = 0;
    constexpr uint32_t DTG_Msk = DTG::mask;

    /// Lock configuration These bits offer a write protection against software errors. Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.
    /// Position: 8, Width: 2
    /// Access: read-write
    using LOCK = BitField<8, 2>;
    constexpr uint32_t LOCK_Pos = 8;
    constexpr uint32_t LOCK_Msk = LOCK::mask;
    /// Enumerated values for LOCK
    namespace lock {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Off-state selection for Idle mode This bit is used when MOE=0 on channels configured as outputs. See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on pageÂ 846). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 10, Width: 1
    /// Access: read-write
    using OSSI = BitField<10, 1>;
    constexpr uint32_t OSSI_Pos = 10;
    constexpr uint32_t OSSI_Msk = OSSI::mask;
    /// Enumerated values for OSSI
    namespace ossi {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Off-state selection for Run mode This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer. See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on pageÂ 846). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 11, Width: 1
    /// Access: read-write
    using OSSR = BitField<11, 1>;
    constexpr uint32_t OSSR_Pos = 11;
    constexpr uint32_t OSSR_Msk = OSSR::mask;
    /// Enumerated values for OSSR
    namespace ossr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Break enable 1; Break inputs (BRK and CCS clock failure event) enabled Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
    /// Position: 12, Width: 1
    /// Access: read-write
    using BKE = BitField<12, 1>;
    constexpr uint32_t BKE_Pos = 12;
    constexpr uint32_t BKE_Msk = BKE::mask;
    /// Enumerated values for BKE
    namespace bke {
        constexpr uint32_t B_0x0 = 0;
    }

    /// Break polarity Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
    /// Position: 13, Width: 1
    /// Access: read-write
    using BKP = BitField<13, 1>;
    constexpr uint32_t BKP_Pos = 13;
    constexpr uint32_t BKP_Msk = BKP::mask;
    /// Enumerated values for BKP
    namespace bkp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Automatic output enable Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 14, Width: 1
    /// Access: read-write
    using AOE = BitField<14, 1>;
    constexpr uint32_t AOE_Pos = 14;
    constexpr uint32_t AOE_Msk = AOE::mask;
    /// Enumerated values for AOE
    namespace aoe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Main output enable This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on pageÂ 846).
    /// Position: 15, Width: 1
    /// Access: read-write
    using MOE = BitField<15, 1>;
    constexpr uint32_t MOE_Pos = 15;
    constexpr uint32_t MOE_Msk = MOE::mask;
    /// Enumerated values for MOE
    namespace moe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Break filter This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 16, Width: 4
    /// Access: read-write
    using BKF = BitField<16, 4>;
    constexpr uint32_t BKF_Pos = 16;
    constexpr uint32_t BKF_Msk = BKF::mask;
    /// Enumerated values for BKF
    namespace bkf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0xA = 10;
        constexpr uint32_t B_0xB = 11;
        constexpr uint32_t B_0xC = 12;
        constexpr uint32_t B_0xD = 13;
        constexpr uint32_t B_0xE = 14;
        constexpr uint32_t B_0xF = 15;
    }

    /// Break Disarm This bit is cleared by hardware when no break source is active. The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared. Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
    /// Position: 26, Width: 1
    /// Access: read-write
    using BKDSRM = BitField<26, 1>;
    constexpr uint32_t BKDSRM_Pos = 26;
    constexpr uint32_t BKDSRM_Msk = BKDSRM::mask;
    /// Enumerated values for BKDSRM
    namespace bkdsrm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Break Bidirectional In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices. Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
    /// Position: 28, Width: 1
    /// Access: read-write
    using BKBID = BitField<28, 1>;
    constexpr uint32_t BKBID_Pos = 28;
    constexpr uint32_t BKBID_Msk = BKBID::mask;
    /// Enumerated values for BKBID
    namespace bkbid {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace bdtr

/// DCR - DMA control register
namespace dcr {
    /// DMA base address This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ... Example: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.
    /// Position: 0, Width: 5
    /// Access: read-write
    using DBA = BitField<0, 5>;
    constexpr uint32_t DBA_Pos = 0;
    constexpr uint32_t DBA_Msk = DBA::mask;
    /// Enumerated values for DBA
    namespace dba {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// DMA burst length This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below). ...
    /// Position: 8, Width: 5
    /// Access: read-write
    using DBL = BitField<8, 5>;
    constexpr uint32_t DBL_Pos = 8;
    constexpr uint32_t DBL_Msk = DBL::mask;
    /// Enumerated values for DBL
    namespace dbl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x11 = 17;
    }

}  // namespace dcr

/// DMAR - DMA address for full transfer
namespace dmar {
    /// DMA register for burst accesses
    /// Position: 0, Width: 16
    using DMAB = BitField<0, 16>;
    constexpr uint32_t DMAB_Pos = 0;
    constexpr uint32_t DMAB_Msk = DMAB::mask;

}  // namespace dmar

/// AF1 - TIM17 option register 1
namespace af1 {
    /// BRK BKIN input enable This bit enables the BKIN alternate function input for the timerâs BRK input. BKIN input is 'ORedâ with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 0, Width: 1
    /// Access: read-write
    using BKINE = BitField<0, 1>;
    constexpr uint32_t BKINE_Pos = 0;
    constexpr uint32_t BKINE_Msk = BKINE::mask;
    /// Enumerated values for BKINE
    namespace bkine {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// BRK COMP1 enable This bit enables the COMP1 for the timerâs BRK input. COMP1 output is 'ORedâ with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 1, Width: 1
    /// Access: read-write
    using BKCMP1E = BitField<1, 1>;
    constexpr uint32_t BKCMP1E_Pos = 1;
    constexpr uint32_t BKCMP1E_Msk = BKCMP1E::mask;
    /// Enumerated values for BKCMP1E
    namespace bkcmp1e {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// BRK COMP2 enable This bit enables the COMP2 for the timerâs BRK input. COMP2 output is 'ORedâ with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 2, Width: 1
    /// Access: read-write
    using BKCMP2E = BitField<2, 1>;
    constexpr uint32_t BKCMP2E_Pos = 2;
    constexpr uint32_t BKCMP2E_Msk = BKCMP2E::mask;
    /// Enumerated values for BKCMP2E
    namespace bkcmp2e {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// BRK BKIN input polarity This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 9, Width: 1
    /// Access: read-write
    using BKINP = BitField<9, 1>;
    constexpr uint32_t BKINP_Pos = 9;
    constexpr uint32_t BKINP_Msk = BKINP::mask;
    /// Enumerated values for BKINP
    namespace bkinp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// BRK COMP1 input polarity This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 10, Width: 1
    /// Access: read-write
    using BKCMP1P = BitField<10, 1>;
    constexpr uint32_t BKCMP1P_Pos = 10;
    constexpr uint32_t BKCMP1P_Msk = BKCMP1P::mask;
    /// Enumerated values for BKCMP1P
    namespace bkcmp1p {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// BRK COMP2 input polarity This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
    /// Position: 11, Width: 1
    /// Access: read-write
    using BKCMP2P = BitField<11, 1>;
    constexpr uint32_t BKCMP2P_Pos = 11;
    constexpr uint32_t BKCMP2P_Msk = BKCMP2P::mask;
    /// Enumerated values for BKCMP2P
    namespace bkcmp2p {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace af1

/// TISEL - input selection register
namespace tisel {
    /// selects TI1[0] to TI1[15] input Others: Reserved
    /// Position: 0, Width: 4
    /// Access: read-write
    using TI1SEL = BitField<0, 4>;
    constexpr uint32_t TI1SEL_Pos = 0;
    constexpr uint32_t TI1SEL_Msk = TI1SEL::mask;
    /// Enumerated values for TI1SEL
    namespace ti1sel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

}  // namespace tisel

}  // namespace alloy::hal::st::stm32g0::tim16
