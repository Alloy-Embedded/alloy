/// Auto-generated bit field definitions for ADC
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::adc {

using namespace alloy::hal::bitfields;

// ============================================================================
// ADC Bit Field Definitions
// ============================================================================

/// ADC_ISR - ADC interrupt and status register
namespace adc_isr {
    /// ADC ready This bit is set by hardware after the ADC has been enabled (ADENÂ =Â 1) and when the ADC reaches a state where it is ready to accept conversion requests. It is cleared by software writing 1 to it.
    /// Position: 0, Width: 1
    /// Access: read-write
    using ADRDY = BitField<0, 1>;
    constexpr uint32_t ADRDY_Pos = 0;
    constexpr uint32_t ADRDY_Msk = ADRDY::mask;
    /// Enumerated values for ADRDY
    namespace adrdy {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End of sampling flag This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to '1â.
    /// Position: 1, Width: 1
    /// Access: read-write
    using EOSMP = BitField<1, 1>;
    constexpr uint32_t EOSMP_Pos = 1;
    constexpr uint32_t EOSMP_Msk = EOSMP::mask;
    /// Enumerated values for EOSMP
    namespace eosmp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End of conversion flag This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
    /// Position: 2, Width: 1
    /// Access: read-write
    using EOC = BitField<2, 1>;
    constexpr uint32_t EOC_Pos = 2;
    constexpr uint32_t EOC_Msk = EOC::mask;
    /// Enumerated values for EOC
    namespace eoc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End of sequence flag This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
    /// Position: 3, Width: 1
    /// Access: read-write
    using EOS = BitField<3, 1>;
    constexpr uint32_t EOS_Pos = 3;
    constexpr uint32_t EOS_Msk = EOS::mask;
    /// Enumerated values for EOS
    namespace eos {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// ADC overrun This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
    /// Position: 4, Width: 1
    /// Access: read-write
    using OVR = BitField<4, 1>;
    constexpr uint32_t OVR_Pos = 4;
    constexpr uint32_t OVR_Msk = OVR::mask;
    /// Enumerated values for OVR
    namespace ovr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog 1 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
    /// Position: 7, Width: 1
    /// Access: read-write
    using AWD1 = BitField<7, 1>;
    constexpr uint32_t AWD1_Pos = 7;
    constexpr uint32_t AWD1_Msk = AWD1::mask;
    /// Enumerated values for AWD1
    namespace awd1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog 2 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
    /// Position: 8, Width: 1
    /// Access: read-write
    using AWD2 = BitField<8, 1>;
    constexpr uint32_t AWD2_Pos = 8;
    constexpr uint32_t AWD2_Msk = AWD2::mask;
    /// Enumerated values for AWD2
    namespace awd2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog 3 flag This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
    /// Position: 9, Width: 1
    /// Access: read-write
    using AWD3 = BitField<9, 1>;
    constexpr uint32_t AWD3_Pos = 9;
    constexpr uint32_t AWD3_Msk = AWD3::mask;
    /// Enumerated values for AWD3
    namespace awd3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End Of Calibration flag This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
    /// Position: 11, Width: 1
    /// Access: read-write
    using EOCAL = BitField<11, 1>;
    constexpr uint32_t EOCAL_Pos = 11;
    constexpr uint32_t EOCAL_Msk = EOCAL::mask;
    /// Enumerated values for EOCAL
    namespace eocal {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel Configuration Ready flag This flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it. Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.
    /// Position: 13, Width: 1
    /// Access: read-write
    using CCRDY = BitField<13, 1>;
    constexpr uint32_t CCRDY_Pos = 13;
    constexpr uint32_t CCRDY_Msk = CCRDY::mask;
    /// Enumerated values for CCRDY
    namespace ccrdy {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace adc_isr

/// ADC_IER - ADC interrupt enable register
namespace adc_ier {
    /// ADC ready interrupt enable This bit is set and cleared by software to enable/disable the ADC Ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 0, Width: 1
    /// Access: read-write
    using ADRDYIE = BitField<0, 1>;
    constexpr uint32_t ADRDYIE_Pos = 0;
    constexpr uint32_t ADRDYIE_Msk = ADRDYIE::mask;
    /// Enumerated values for ADRDYIE
    namespace adrdyie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End of sampling flag interrupt enable This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 1, Width: 1
    /// Access: read-write
    using EOSMPIE = BitField<1, 1>;
    constexpr uint32_t EOSMPIE_Pos = 1;
    constexpr uint32_t EOSMPIE_Msk = EOSMPIE::mask;
    /// Enumerated values for EOSMPIE
    namespace eosmpie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End of conversion interrupt enable This bit is set and cleared by software to enable/disable the end of conversion interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 2, Width: 1
    /// Access: read-write
    using EOCIE = BitField<2, 1>;
    constexpr uint32_t EOCIE_Pos = 2;
    constexpr uint32_t EOCIE_Msk = EOCIE::mask;
    /// Enumerated values for EOCIE
    namespace eocie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End of conversion sequence interrupt enable This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 3, Width: 1
    /// Access: read-write
    using EOSIE = BitField<3, 1>;
    constexpr uint32_t EOSIE_Pos = 3;
    constexpr uint32_t EOSIE_Msk = EOSIE::mask;
    /// Enumerated values for EOSIE
    namespace eosie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Overrun interrupt enable This bit is set and cleared by software to enable/disable the overrun interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 4, Width: 1
    /// Access: read-write
    using OVRIE = BitField<4, 1>;
    constexpr uint32_t OVRIE_Pos = 4;
    constexpr uint32_t OVRIE_Msk = OVRIE::mask;
    /// Enumerated values for OVRIE
    namespace ovrie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog 1 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 7, Width: 1
    /// Access: read-write
    using AWD1IE = BitField<7, 1>;
    constexpr uint32_t AWD1IE_Pos = 7;
    constexpr uint32_t AWD1IE_Msk = AWD1IE::mask;
    /// Enumerated values for AWD1IE
    namespace awd1ie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog 2 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 8, Width: 1
    /// Access: read-write
    using AWD2IE = BitField<8, 1>;
    constexpr uint32_t AWD2IE_Pos = 8;
    constexpr uint32_t AWD2IE_Msk = AWD2IE::mask;
    /// Enumerated values for AWD2IE
    namespace awd2ie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog 3 interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 9, Width: 1
    /// Access: read-write
    using AWD3IE = BitField<9, 1>;
    constexpr uint32_t AWD3IE_Pos = 9;
    constexpr uint32_t AWD3IE_Msk = AWD3IE::mask;
    /// Enumerated values for AWD3IE
    namespace awd3ie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// End of calibration interrupt enable This bit is set and cleared by software to enable/disable the end of calibration interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 11, Width: 1
    /// Access: read-write
    using EOCALIE = BitField<11, 1>;
    constexpr uint32_t EOCALIE_Pos = 11;
    constexpr uint32_t EOCALIE_Msk = EOCALIE::mask;
    /// Enumerated values for EOCALIE
    namespace eocalie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel Configuration Ready Interrupt enable This bit is set and cleared by software to enable/disable the channel configuration ready interrupt. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 13, Width: 1
    /// Access: read-write
    using CCRDYIE = BitField<13, 1>;
    constexpr uint32_t CCRDYIE_Pos = 13;
    constexpr uint32_t CCRDYIE_Msk = CCRDYIE::mask;
    /// Enumerated values for CCRDYIE
    namespace ccrdyie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace adc_ier

/// ADC_CR - ADC control register
namespace adc_cr {
    /// ADC enable command This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set. It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command. Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCALÂ =Â 0, ADSTPÂ =Â 0, ADSTARTÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0)
    /// Position: 0, Width: 1
    /// Access: read-write
    using ADEN = BitField<0, 1>;
    constexpr uint32_t ADEN_Pos = 0;
    constexpr uint32_t ADEN_Msk = ADEN::mask;
    /// Enumerated values for ADEN
    namespace aden {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// ADC disable command This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state). It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time). Note: Setting ADDIS to '1â is only effective when ADENÂ =Â 1 and ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing)
    /// Position: 1, Width: 1
    /// Access: read-write
    using ADDIS = BitField<1, 1>;
    constexpr uint32_t ADDIS_Pos = 1;
    constexpr uint32_t ADDIS_Msk = ADDIS::mask;
    /// Enumerated values for ADDIS
    namespace addis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// ADC start conversion command This bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration). It is cleared by hardware: In single conversion mode (CONTÂ =Â 0, DISCENÂ =Â 0), when software trigger is selected (EXTENÂ =Â 00): at the assertion of the end of Conversion Sequence (EOS) flag. In discontinuous conversion mode(CONTÂ =Â 0, DISCENÂ =Â 1), when the software trigger is selected (EXTENÂ =Â 00): at the assertion of the end of Conversion (EOC) flag. In all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware. Note: The software is allowed to set ADSTART only when ADENÂ =Â 1 and ADDISÂ =Â 0 (ADC is enabled and there is no pending request to disable the ADC). After writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored.
    /// Position: 2, Width: 1
    /// Access: read-write
    using ADSTART = BitField<2, 1>;
    constexpr uint32_t ADSTART_Pos = 2;
    constexpr uint32_t ADSTART_Msk = ADSTART::mask;
    /// Enumerated values for ADSTART
    namespace adstart {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// ADC stop conversion command This bit is set by software to stop and discard an ongoing conversion (ADSTP Command). It is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command. Note: Setting ADSTP to '1â is only effective when ADSTARTÂ =Â 1 and ADDISÂ =Â 0 (ADC is enabled and may be converting and there is no pending request to disable the ADC)
    /// Position: 4, Width: 1
    /// Access: read-write
    using ADSTP = BitField<4, 1>;
    constexpr uint32_t ADSTP_Pos = 4;
    constexpr uint32_t ADSTP_Msk = ADSTP::mask;
    /// Enumerated values for ADSTP
    namespace adstp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// ADC Voltage Regulator Enable This bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP. It is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0. Note: The software is allowed to program this bit field only when the ADC is disabled (ADCALÂ =Â 0, ADSTARTÂ =Â 0, ADSTPÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0).
    /// Position: 28, Width: 1
    /// Access: read-write
    using ADVREGEN = BitField<28, 1>;
    constexpr uint32_t ADVREGEN_Pos = 28;
    constexpr uint32_t ADVREGEN_Msk = ADVREGEN::mask;
    /// Enumerated values for ADVREGEN
    namespace advregen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// ADC calibration This bit is set by software to start the calibration of the ADC. It is cleared by hardware after calibration is complete. Note: The software is allowed to set ADCAL only when the ADC is disabled (ADCALÂ =Â 0, ADSTARTÂ =Â 0, ADSTPÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0). The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADENÂ =Â 1 and ADSTARTÂ =Â 0 (ADC enabled and no conversion is ongoing).
    /// Position: 31, Width: 1
    /// Access: read-write
    using ADCAL = BitField<31, 1>;
    constexpr uint32_t ADCAL_Pos = 31;
    constexpr uint32_t ADCAL_Msk = ADCAL::mask;
    /// Enumerated values for ADCAL
    namespace adcal {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace adc_cr

/// ADC_CFGR1 - ADC configuration register 1
namespace adc_cfgr1 {
    /// Direct memory access enable This bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to . Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 0, Width: 1
    /// Access: read-write
    using DMAEN = BitField<0, 1>;
    constexpr uint32_t DMAEN_Pos = 0;
    constexpr uint32_t DMAEN_Msk = DMAEN::mask;
    /// Enumerated values for DMAEN
    namespace dmaen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Direct memory access configuration This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAENÂ =Â 1. For more details, refer to pageÂ 403 Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 1, Width: 1
    /// Access: read-write
    using DMACFG = BitField<1, 1>;
    constexpr uint32_t DMACFG_Pos = 1;
    constexpr uint32_t DMACFG_Msk = DMACFG::mask;
    /// Enumerated values for DMACFG
    namespace dmacfg {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Scan sequence direction This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 2, Width: 1
    /// Access: read-write
    using SCANDIR = BitField<2, 1>;
    constexpr uint32_t SCANDIR_Pos = 2;
    constexpr uint32_t SCANDIR_Msk = SCANDIR::mask;
    /// Enumerated values for SCANDIR
    namespace scandir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Data resolution These bits are written by software to select the resolution of the conversion. Note: The software is allowed to write these bits only when ADENÂ =Â 0.
    /// Position: 3, Width: 2
    /// Access: read-write
    using RES = BitField<3, 2>;
    constexpr uint32_t RES_Pos = 3;
    constexpr uint32_t RES_Msk = RES::mask;
    /// Enumerated values for RES
    namespace res {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Data alignment This bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on pageÂ 401 Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 5, Width: 1
    /// Access: read-write
    using ALIGN = BitField<5, 1>;
    constexpr uint32_t ALIGN_Pos = 5;
    constexpr uint32_t ALIGN_Msk = ALIGN::mask;
    /// Enumerated values for ALIGN
    namespace align {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// External trigger selection These bits select the external event used to trigger the start of conversion (refer to External triggers for details): Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 6, Width: 3
    /// Access: read-write
    using EXTSEL = BitField<6, 3>;
    constexpr uint32_t EXTSEL_Pos = 6;
    constexpr uint32_t EXTSEL_Msk = EXTSEL::mask;
    /// Enumerated values for EXTSEL
    namespace extsel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// External trigger enable and polarity selection These bits are set and cleared by software to select the external trigger polarity and enable the trigger. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 10, Width: 2
    /// Access: read-write
    using EXTEN = BitField<10, 2>;
    constexpr uint32_t EXTEN_Pos = 10;
    constexpr uint32_t EXTEN_Msk = EXTEN::mask;
    /// Enumerated values for EXTEN
    namespace exten {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Overrun management mode This bit is set and cleared by software and configure the way data overruns are managed. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 12, Width: 1
    /// Access: read-write
    using OVRMOD = BitField<12, 1>;
    constexpr uint32_t OVRMOD_Pos = 12;
    constexpr uint32_t OVRMOD_Msk = OVRMOD::mask;
    /// Enumerated values for OVRMOD
    namespace ovrmod {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Single / continuous conversion mode This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCENÂ =Â 1 and CONTÂ =Â 1. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 13, Width: 1
    /// Access: read-write
    using CONT = BitField<13, 1>;
    constexpr uint32_t CONT_Pos = 13;
    constexpr uint32_t CONT_Msk = CONT::mask;
    /// Enumerated values for CONT
    namespace cont {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wait conversion mode This bit is set and cleared by software to enable/disable wait conversion mode.. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 14, Width: 1
    /// Access: read-write
    using WAIT = BitField<14, 1>;
    constexpr uint32_t WAIT_Pos = 14;
    constexpr uint32_t WAIT_Msk = WAIT::mask;
    /// Enumerated values for WAIT
    namespace wait {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Auto-off mode This bit is set and cleared by software to enable/disable auto-off mode.. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 15, Width: 1
    /// Access: read-write
    using AUTOFF = BitField<15, 1>;
    constexpr uint32_t AUTOFF_Pos = 15;
    constexpr uint32_t AUTOFF_Msk = AUTOFF::mask;
    /// Enumerated values for AUTOFF
    namespace autoff {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Discontinuous mode This bit is set and cleared by software to enable/disable discontinuous mode. Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCENÂ =Â 1 and CONTÂ =Â 1. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 16, Width: 1
    /// Access: read-write
    using DISCEN = BitField<16, 1>;
    constexpr uint32_t DISCEN_Pos = 16;
    constexpr uint32_t DISCEN_Msk = DISCEN::mask;
    /// Enumerated values for DISCEN
    namespace discen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Mode selection of the ADC_CHSELR register This bit is set and cleared by software to control the ADC_CHSELR feature: Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 21, Width: 1
    /// Access: read-write
    using CHSELRMOD = BitField<21, 1>;
    constexpr uint32_t CHSELRMOD_Pos = 21;
    constexpr uint32_t CHSELRMOD_Msk = CHSELRMOD::mask;
    /// Enumerated values for CHSELRMOD
    namespace chselrmod {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Enable the watchdog on a single channel or on all channels This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 22, Width: 1
    /// Access: read-write
    using AWD1SGL = BitField<22, 1>;
    constexpr uint32_t AWD1SGL_Pos = 22;
    constexpr uint32_t AWD1SGL_Msk = AWD1SGL::mask;
    /// Enumerated values for AWD1SGL
    namespace awd1sgl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 23, Width: 1
    /// Access: read-write
    using AWD1EN = BitField<23, 1>;
    constexpr uint32_t AWD1EN_Pos = 23;
    constexpr uint32_t AWD1EN_Msk = AWD1EN::mask;
    /// Enumerated values for AWD1EN
    namespace awd1en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog. ..... Others: Reserved Note: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register. The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 26, Width: 5
    /// Access: read-write
    using AWD1CH = BitField<26, 5>;
    constexpr uint32_t AWD1CH_Pos = 26;
    constexpr uint32_t AWD1CH_Msk = AWD1CH::mask;
    /// Enumerated values for AWD1CH
    namespace awd1ch {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x11 = 17;
        constexpr uint32_t B_0x12 = 18;
    }

}  // namespace adc_cfgr1

/// ADC_CFGR2 - ADC configuration register 2
namespace adc_cfgr2 {
    /// Oversampler Enable This bit is set and cleared by software. Note: Software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 0, Width: 1
    /// Access: read-write
    using OVSE = BitField<0, 1>;
    constexpr uint32_t OVSE_Pos = 0;
    constexpr uint32_t OVSE_Msk = OVSE::mask;
    /// Enumerated values for OVSE
    namespace ovse {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Oversampling ratio This bit filed defines the number of oversampling ratio. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 2, Width: 3
    /// Access: read-write
    using OVSR = BitField<2, 3>;
    constexpr uint32_t OVSR_Pos = 2;
    constexpr uint32_t OVSR_Msk = OVSR::mask;
    /// Enumerated values for OVSR
    namespace ovsr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Oversampling shift This bit is set and cleared by software. Others: Reserved Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 5, Width: 4
    /// Access: read-write
    using OVSS = BitField<5, 4>;
    constexpr uint32_t OVSS_Pos = 5;
    constexpr uint32_t OVSS_Msk = OVSS::mask;
    /// Enumerated values for OVSS
    namespace ovss {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
    }

    /// Triggered Oversampling This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 9, Width: 1
    /// Access: read-write
    using TOVS = BitField<9, 1>;
    constexpr uint32_t TOVS_Pos = 9;
    constexpr uint32_t TOVS_Msk = TOVS::mask;
    /// Enumerated values for TOVS
    namespace tovs {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Low frequency trigger mode enable This bit is set and cleared by software. Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
    /// Position: 29, Width: 1
    /// Access: read-write
    using LFTRIG = BitField<29, 1>;
    constexpr uint32_t LFTRIG_Pos = 29;
    constexpr uint32_t LFTRIG_Msk = LFTRIG::mask;
    /// Enumerated values for LFTRIG
    namespace lftrig {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// ADC clock mode These bits are set and cleared by software to define how the analog ADC is clocked: In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion. Note: The software is allowed to write these bits only when the ADC is disabled (ADCALÂ =Â 0, ADSTARTÂ =Â 0, ADSTPÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0).
    /// Position: 30, Width: 2
    /// Access: read-write
    using CKMODE = BitField<30, 2>;
    constexpr uint32_t CKMODE_Pos = 30;
    constexpr uint32_t CKMODE_Msk = CKMODE::mask;
    /// Enumerated values for CKMODE
    namespace ckmode {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

}  // namespace adc_cfgr2

/// ADC_SMPR - ADC sampling time register
namespace adc_smpr {
    /// Sampling time selection 1 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 0, Width: 3
    /// Access: read-write
    using SMP1 = BitField<0, 3>;
    constexpr uint32_t SMP1_Pos = 0;
    constexpr uint32_t SMP1_Msk = SMP1::mask;
    /// Enumerated values for SMP1
    namespace smp1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Sampling time selection 2 These bits are written by software to select the sampling time that applies to all channels. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 4, Width: 3
    /// Access: read-write
    using SMP2 = BitField<4, 3>;
    constexpr uint32_t SMP2_Pos = 4;
    constexpr uint32_t SMP2_Msk = SMP2::mask;
    /// Enumerated values for SMP2
    namespace smp2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 8, Width: 1
    /// Access: read-write
    using SMPSEL0 = BitField<8, 1>;
    constexpr uint32_t SMPSEL0_Pos = 8;
    constexpr uint32_t SMPSEL0_Msk = SMPSEL0::mask;
    /// Enumerated values for SMPSEL0
    namespace smpsel0 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 9, Width: 1
    /// Access: read-write
    using SMPSEL1 = BitField<9, 1>;
    constexpr uint32_t SMPSEL1_Pos = 9;
    constexpr uint32_t SMPSEL1_Msk = SMPSEL1::mask;
    /// Enumerated values for SMPSEL1
    namespace smpsel1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 10, Width: 1
    /// Access: read-write
    using SMPSEL2 = BitField<10, 1>;
    constexpr uint32_t SMPSEL2_Pos = 10;
    constexpr uint32_t SMPSEL2_Msk = SMPSEL2::mask;
    /// Enumerated values for SMPSEL2
    namespace smpsel2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 11, Width: 1
    /// Access: read-write
    using SMPSEL3 = BitField<11, 1>;
    constexpr uint32_t SMPSEL3_Pos = 11;
    constexpr uint32_t SMPSEL3_Msk = SMPSEL3::mask;
    /// Enumerated values for SMPSEL3
    namespace smpsel3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 12, Width: 1
    /// Access: read-write
    using SMPSEL4 = BitField<12, 1>;
    constexpr uint32_t SMPSEL4_Pos = 12;
    constexpr uint32_t SMPSEL4_Msk = SMPSEL4::mask;
    /// Enumerated values for SMPSEL4
    namespace smpsel4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 13, Width: 1
    /// Access: read-write
    using SMPSEL5 = BitField<13, 1>;
    constexpr uint32_t SMPSEL5_Pos = 13;
    constexpr uint32_t SMPSEL5_Msk = SMPSEL5::mask;
    /// Enumerated values for SMPSEL5
    namespace smpsel5 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 14, Width: 1
    /// Access: read-write
    using SMPSEL6 = BitField<14, 1>;
    constexpr uint32_t SMPSEL6_Pos = 14;
    constexpr uint32_t SMPSEL6_Msk = SMPSEL6::mask;
    /// Enumerated values for SMPSEL6
    namespace smpsel6 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 15, Width: 1
    /// Access: read-write
    using SMPSEL7 = BitField<15, 1>;
    constexpr uint32_t SMPSEL7_Pos = 15;
    constexpr uint32_t SMPSEL7_Msk = SMPSEL7::mask;
    /// Enumerated values for SMPSEL7
    namespace smpsel7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 16, Width: 1
    /// Access: read-write
    using SMPSEL8 = BitField<16, 1>;
    constexpr uint32_t SMPSEL8_Pos = 16;
    constexpr uint32_t SMPSEL8_Msk = SMPSEL8::mask;
    /// Enumerated values for SMPSEL8
    namespace smpsel8 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 17, Width: 1
    /// Access: read-write
    using SMPSEL9 = BitField<17, 1>;
    constexpr uint32_t SMPSEL9_Pos = 17;
    constexpr uint32_t SMPSEL9_Msk = SMPSEL9::mask;
    /// Enumerated values for SMPSEL9
    namespace smpsel9 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 18, Width: 1
    /// Access: read-write
    using SMPSEL10 = BitField<18, 1>;
    constexpr uint32_t SMPSEL10_Pos = 18;
    constexpr uint32_t SMPSEL10_Msk = SMPSEL10::mask;
    /// Enumerated values for SMPSEL10
    namespace smpsel10 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 19, Width: 1
    /// Access: read-write
    using SMPSEL11 = BitField<19, 1>;
    constexpr uint32_t SMPSEL11_Pos = 19;
    constexpr uint32_t SMPSEL11_Msk = SMPSEL11::mask;
    /// Enumerated values for SMPSEL11
    namespace smpsel11 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 20, Width: 1
    /// Access: read-write
    using SMPSEL12 = BitField<20, 1>;
    constexpr uint32_t SMPSEL12_Pos = 20;
    constexpr uint32_t SMPSEL12_Msk = SMPSEL12::mask;
    /// Enumerated values for SMPSEL12
    namespace smpsel12 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 21, Width: 1
    /// Access: read-write
    using SMPSEL13 = BitField<21, 1>;
    constexpr uint32_t SMPSEL13_Pos = 21;
    constexpr uint32_t SMPSEL13_Msk = SMPSEL13::mask;
    /// Enumerated values for SMPSEL13
    namespace smpsel13 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 22, Width: 1
    /// Access: read-write
    using SMPSEL14 = BitField<22, 1>;
    constexpr uint32_t SMPSEL14_Pos = 22;
    constexpr uint32_t SMPSEL14_Msk = SMPSEL14::mask;
    /// Enumerated values for SMPSEL14
    namespace smpsel14 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 23, Width: 1
    /// Access: read-write
    using SMPSEL15 = BitField<23, 1>;
    constexpr uint32_t SMPSEL15_Pos = 23;
    constexpr uint32_t SMPSEL15_Msk = SMPSEL15::mask;
    /// Enumerated values for SMPSEL15
    namespace smpsel15 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 24, Width: 1
    /// Access: read-write
    using SMPSEL16 = BitField<24, 1>;
    constexpr uint32_t SMPSEL16_Pos = 24;
    constexpr uint32_t SMPSEL16_Msk = SMPSEL16::mask;
    /// Enumerated values for SMPSEL16
    namespace smpsel16 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 25, Width: 1
    /// Access: read-write
    using SMPSEL17 = BitField<25, 1>;
    constexpr uint32_t SMPSEL17_Pos = 25;
    constexpr uint32_t SMPSEL17_Msk = SMPSEL17::mask;
    /// Enumerated values for SMPSEL17
    namespace smpsel17 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x sampling time selection These bits are written by software to define which sampling time is used. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 26, Width: 1
    /// Access: read-write
    using SMPSEL18 = BitField<26, 1>;
    constexpr uint32_t SMPSEL18_Pos = 26;
    constexpr uint32_t SMPSEL18_Msk = SMPSEL18::mask;
    /// Enumerated values for SMPSEL18
    namespace smpsel18 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace adc_smpr

/// ADC_AWD1TR - ADC watchdog threshold register
namespace adc_awd1tr {
    /// Analog watchdog 1 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on pageÂ 407.
    /// Position: 0, Width: 12
    /// Access: read-write
    using LT1 = BitField<0, 12>;
    constexpr uint32_t LT1_Pos = 0;
    constexpr uint32_t LT1_Msk = LT1::mask;

    /// Analog watchdog 1 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on pageÂ 407.
    /// Position: 16, Width: 12
    /// Access: read-write
    using HT1 = BitField<16, 12>;
    constexpr uint32_t HT1_Pos = 16;
    constexpr uint32_t HT1_Msk = HT1::mask;

}  // namespace adc_awd1tr

/// ADC_AWD2TR - ADC watchdog threshold register
namespace adc_awd2tr {
    /// Analog watchdog 2 lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on pageÂ 407.
    /// Position: 0, Width: 12
    /// Access: read-write
    using LT2 = BitField<0, 12>;
    constexpr uint32_t LT2_Pos = 0;
    constexpr uint32_t LT2_Msk = LT2::mask;

    /// Analog watchdog 2 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on pageÂ 407.
    /// Position: 16, Width: 12
    /// Access: read-write
    using HT2 = BitField<16, 12>;
    constexpr uint32_t HT2_Pos = 16;
    constexpr uint32_t HT2_Msk = HT2::mask;

}  // namespace adc_awd2tr

/// ADC_CHSELR - ADC channel selection register [alternate]
namespace adc_chselr {
    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CHSEL0 = BitField<0, 1>;
    constexpr uint32_t CHSEL0_Pos = 0;
    constexpr uint32_t CHSEL0_Msk = CHSEL0::mask;
    /// Enumerated values for CHSEL0
    namespace chsel0 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 1, Width: 1
    /// Access: read-write
    using CHSEL1 = BitField<1, 1>;
    constexpr uint32_t CHSEL1_Pos = 1;
    constexpr uint32_t CHSEL1_Msk = CHSEL1::mask;
    /// Enumerated values for CHSEL1
    namespace chsel1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 2, Width: 1
    /// Access: read-write
    using CHSEL2 = BitField<2, 1>;
    constexpr uint32_t CHSEL2_Pos = 2;
    constexpr uint32_t CHSEL2_Msk = CHSEL2::mask;
    /// Enumerated values for CHSEL2
    namespace chsel2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 3, Width: 1
    /// Access: read-write
    using CHSEL3 = BitField<3, 1>;
    constexpr uint32_t CHSEL3_Pos = 3;
    constexpr uint32_t CHSEL3_Msk = CHSEL3::mask;
    /// Enumerated values for CHSEL3
    namespace chsel3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 4, Width: 1
    /// Access: read-write
    using CHSEL4 = BitField<4, 1>;
    constexpr uint32_t CHSEL4_Pos = 4;
    constexpr uint32_t CHSEL4_Msk = CHSEL4::mask;
    /// Enumerated values for CHSEL4
    namespace chsel4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 5, Width: 1
    /// Access: read-write
    using CHSEL5 = BitField<5, 1>;
    constexpr uint32_t CHSEL5_Pos = 5;
    constexpr uint32_t CHSEL5_Msk = CHSEL5::mask;
    /// Enumerated values for CHSEL5
    namespace chsel5 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 6, Width: 1
    /// Access: read-write
    using CHSEL6 = BitField<6, 1>;
    constexpr uint32_t CHSEL6_Pos = 6;
    constexpr uint32_t CHSEL6_Msk = CHSEL6::mask;
    /// Enumerated values for CHSEL6
    namespace chsel6 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 7, Width: 1
    /// Access: read-write
    using CHSEL7 = BitField<7, 1>;
    constexpr uint32_t CHSEL7_Pos = 7;
    constexpr uint32_t CHSEL7_Msk = CHSEL7::mask;
    /// Enumerated values for CHSEL7
    namespace chsel7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 8, Width: 1
    /// Access: read-write
    using CHSEL8 = BitField<8, 1>;
    constexpr uint32_t CHSEL8_Pos = 8;
    constexpr uint32_t CHSEL8_Msk = CHSEL8::mask;
    /// Enumerated values for CHSEL8
    namespace chsel8 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 9, Width: 1
    /// Access: read-write
    using CHSEL9 = BitField<9, 1>;
    constexpr uint32_t CHSEL9_Pos = 9;
    constexpr uint32_t CHSEL9_Msk = CHSEL9::mask;
    /// Enumerated values for CHSEL9
    namespace chsel9 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 10, Width: 1
    /// Access: read-write
    using CHSEL10 = BitField<10, 1>;
    constexpr uint32_t CHSEL10_Pos = 10;
    constexpr uint32_t CHSEL10_Msk = CHSEL10::mask;
    /// Enumerated values for CHSEL10
    namespace chsel10 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 11, Width: 1
    /// Access: read-write
    using CHSEL11 = BitField<11, 1>;
    constexpr uint32_t CHSEL11_Pos = 11;
    constexpr uint32_t CHSEL11_Msk = CHSEL11::mask;
    /// Enumerated values for CHSEL11
    namespace chsel11 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 12, Width: 1
    /// Access: read-write
    using CHSEL12 = BitField<12, 1>;
    constexpr uint32_t CHSEL12_Pos = 12;
    constexpr uint32_t CHSEL12_Msk = CHSEL12::mask;
    /// Enumerated values for CHSEL12
    namespace chsel12 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 13, Width: 1
    /// Access: read-write
    using CHSEL13 = BitField<13, 1>;
    constexpr uint32_t CHSEL13_Pos = 13;
    constexpr uint32_t CHSEL13_Msk = CHSEL13::mask;
    /// Enumerated values for CHSEL13
    namespace chsel13 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 14, Width: 1
    /// Access: read-write
    using CHSEL14 = BitField<14, 1>;
    constexpr uint32_t CHSEL14_Pos = 14;
    constexpr uint32_t CHSEL14_Msk = CHSEL14::mask;
    /// Enumerated values for CHSEL14
    namespace chsel14 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 15, Width: 1
    /// Access: read-write
    using CHSEL15 = BitField<15, 1>;
    constexpr uint32_t CHSEL15_Pos = 15;
    constexpr uint32_t CHSEL15_Msk = CHSEL15::mask;
    /// Enumerated values for CHSEL15
    namespace chsel15 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 16, Width: 1
    /// Access: read-write
    using CHSEL16 = BitField<16, 1>;
    constexpr uint32_t CHSEL16_Pos = 16;
    constexpr uint32_t CHSEL16_Msk = CHSEL16::mask;
    /// Enumerated values for CHSEL16
    namespace chsel16 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 17, Width: 1
    /// Access: read-write
    using CHSEL17 = BitField<17, 1>;
    constexpr uint32_t CHSEL17_Pos = 17;
    constexpr uint32_t CHSEL17_Msk = CHSEL17::mask;
    /// Enumerated values for CHSEL17
    namespace chsel17 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel-x selection These bits are written by software and define which channels are part of the sequence of channels to be converted. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing). If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
    /// Position: 18, Width: 1
    /// Access: read-write
    using CHSEL18 = BitField<18, 1>;
    constexpr uint32_t CHSEL18_Pos = 18;
    constexpr uint32_t CHSEL18_Msk = CHSEL18::mask;
    /// Enumerated values for CHSEL18
    namespace chsel18 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace adc_chselr

/// CHSELR_1 - channel selection register CHSELRMOD = 1 in ADC_CFGR1
namespace chselr_1 {
    /// 1st conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 0, Width: 4
    /// Access: read-write
    using SQ1 = BitField<0, 4>;
    constexpr uint32_t SQ1_Pos = 0;
    constexpr uint32_t SQ1_Msk = SQ1::mask;

    /// 2nd conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 4, Width: 4
    /// Access: read-write
    using SQ2 = BitField<4, 4>;
    constexpr uint32_t SQ2_Pos = 4;
    constexpr uint32_t SQ2_Msk = SQ2::mask;

    /// 3rd conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 8, Width: 4
    /// Access: read-write
    using SQ3 = BitField<8, 4>;
    constexpr uint32_t SQ3_Pos = 8;
    constexpr uint32_t SQ3_Msk = SQ3::mask;

    /// 4th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 12, Width: 4
    /// Access: read-write
    using SQ4 = BitField<12, 4>;
    constexpr uint32_t SQ4_Pos = 12;
    constexpr uint32_t SQ4_Msk = SQ4::mask;

    /// 5th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 16, Width: 4
    /// Access: read-write
    using SQ5 = BitField<16, 4>;
    constexpr uint32_t SQ5_Pos = 16;
    constexpr uint32_t SQ5_Msk = SQ5::mask;

    /// 6th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 20, Width: 4
    /// Access: read-write
    using SQ6 = BitField<20, 4>;
    constexpr uint32_t SQ6_Pos = 20;
    constexpr uint32_t SQ6_Msk = SQ6::mask;

    /// 7th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. Refer to SQ8[3:0] for a definition of channel selection. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 24, Width: 4
    /// Access: read-write
    using SQ7 = BitField<24, 4>;
    constexpr uint32_t SQ7_Pos = 24;
    constexpr uint32_t SQ7_Msk = SQ7::mask;

    /// 8th conversion of the sequence These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence. When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored. ... Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 28, Width: 4
    /// Access: read-write
    using SQ8 = BitField<28, 4>;
    constexpr uint32_t SQ8_Pos = 28;
    constexpr uint32_t SQ8_Msk = SQ8::mask;
    /// Enumerated values for SQ8
    namespace sq8 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0xC = 12;
        constexpr uint32_t B_0xD = 13;
        constexpr uint32_t B_0xE = 14;
        constexpr uint32_t B_0xF = 15;
    }

}  // namespace chselr_1

/// ADC_AWD3TR - ADC watchdog threshold register
namespace adc_awd3tr {
    /// Analog watchdog 3lower threshold These bits are written by software to define the lower threshold for the analog watchdog. Refer to ADC_AWDxTR) on pageÂ 407.
    /// Position: 0, Width: 12
    /// Access: read-write
    using LT3 = BitField<0, 12>;
    constexpr uint32_t LT3_Pos = 0;
    constexpr uint32_t LT3_Msk = LT3::mask;

    /// Analog watchdog 3 higher threshold These bits are written by software to define the higher threshold for the analog watchdog. Refer to ADC_AWDxTR) on pageÂ 407.
    /// Position: 16, Width: 12
    /// Access: read-write
    using HT3 = BitField<16, 12>;
    constexpr uint32_t HT3_Pos = 16;
    constexpr uint32_t HT3_Msk = HT3::mask;

}  // namespace adc_awd3tr

/// ADC_DR - ADC data register
namespace adc_dr {
    /// Converted data These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on pageÂ 401. Just after a calibration is complete, DATA[6:0] contains the calibration factor.
    /// Position: 0, Width: 16
    /// Access: read-only
    using DATA = BitField<0, 16>;
    constexpr uint32_t DATA_Pos = 0;
    constexpr uint32_t DATA_Msk = DATA::mask;

}  // namespace adc_dr

/// ADC_AWD2CR - ADC Analog Watchdog 2 Configuration register
namespace adc_awd2cr {
    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 0, Width: 1
    /// Access: read-write
    using AWD2CH0 = BitField<0, 1>;
    constexpr uint32_t AWD2CH0_Pos = 0;
    constexpr uint32_t AWD2CH0_Msk = AWD2CH0::mask;
    /// Enumerated values for AWD2CH0
    namespace awd2ch0 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 1, Width: 1
    /// Access: read-write
    using AWD2CH1 = BitField<1, 1>;
    constexpr uint32_t AWD2CH1_Pos = 1;
    constexpr uint32_t AWD2CH1_Msk = AWD2CH1::mask;
    /// Enumerated values for AWD2CH1
    namespace awd2ch1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 2, Width: 1
    /// Access: read-write
    using AWD2CH2 = BitField<2, 1>;
    constexpr uint32_t AWD2CH2_Pos = 2;
    constexpr uint32_t AWD2CH2_Msk = AWD2CH2::mask;
    /// Enumerated values for AWD2CH2
    namespace awd2ch2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 3, Width: 1
    /// Access: read-write
    using AWD2CH3 = BitField<3, 1>;
    constexpr uint32_t AWD2CH3_Pos = 3;
    constexpr uint32_t AWD2CH3_Msk = AWD2CH3::mask;
    /// Enumerated values for AWD2CH3
    namespace awd2ch3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 4, Width: 1
    /// Access: read-write
    using AWD2CH4 = BitField<4, 1>;
    constexpr uint32_t AWD2CH4_Pos = 4;
    constexpr uint32_t AWD2CH4_Msk = AWD2CH4::mask;
    /// Enumerated values for AWD2CH4
    namespace awd2ch4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 5, Width: 1
    /// Access: read-write
    using AWD2CH5 = BitField<5, 1>;
    constexpr uint32_t AWD2CH5_Pos = 5;
    constexpr uint32_t AWD2CH5_Msk = AWD2CH5::mask;
    /// Enumerated values for AWD2CH5
    namespace awd2ch5 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 6, Width: 1
    /// Access: read-write
    using AWD2CH6 = BitField<6, 1>;
    constexpr uint32_t AWD2CH6_Pos = 6;
    constexpr uint32_t AWD2CH6_Msk = AWD2CH6::mask;
    /// Enumerated values for AWD2CH6
    namespace awd2ch6 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 7, Width: 1
    /// Access: read-write
    using AWD2CH7 = BitField<7, 1>;
    constexpr uint32_t AWD2CH7_Pos = 7;
    constexpr uint32_t AWD2CH7_Msk = AWD2CH7::mask;
    /// Enumerated values for AWD2CH7
    namespace awd2ch7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 8, Width: 1
    /// Access: read-write
    using AWD2CH8 = BitField<8, 1>;
    constexpr uint32_t AWD2CH8_Pos = 8;
    constexpr uint32_t AWD2CH8_Msk = AWD2CH8::mask;
    /// Enumerated values for AWD2CH8
    namespace awd2ch8 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 9, Width: 1
    /// Access: read-write
    using AWD2CH9 = BitField<9, 1>;
    constexpr uint32_t AWD2CH9_Pos = 9;
    constexpr uint32_t AWD2CH9_Msk = AWD2CH9::mask;
    /// Enumerated values for AWD2CH9
    namespace awd2ch9 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 10, Width: 1
    /// Access: read-write
    using AWD2CH10 = BitField<10, 1>;
    constexpr uint32_t AWD2CH10_Pos = 10;
    constexpr uint32_t AWD2CH10_Msk = AWD2CH10::mask;
    /// Enumerated values for AWD2CH10
    namespace awd2ch10 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 11, Width: 1
    /// Access: read-write
    using AWD2CH11 = BitField<11, 1>;
    constexpr uint32_t AWD2CH11_Pos = 11;
    constexpr uint32_t AWD2CH11_Msk = AWD2CH11::mask;
    /// Enumerated values for AWD2CH11
    namespace awd2ch11 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 12, Width: 1
    /// Access: read-write
    using AWD2CH12 = BitField<12, 1>;
    constexpr uint32_t AWD2CH12_Pos = 12;
    constexpr uint32_t AWD2CH12_Msk = AWD2CH12::mask;
    /// Enumerated values for AWD2CH12
    namespace awd2ch12 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 13, Width: 1
    /// Access: read-write
    using AWD2CH13 = BitField<13, 1>;
    constexpr uint32_t AWD2CH13_Pos = 13;
    constexpr uint32_t AWD2CH13_Msk = AWD2CH13::mask;
    /// Enumerated values for AWD2CH13
    namespace awd2ch13 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 14, Width: 1
    /// Access: read-write
    using AWD2CH14 = BitField<14, 1>;
    constexpr uint32_t AWD2CH14_Pos = 14;
    constexpr uint32_t AWD2CH14_Msk = AWD2CH14::mask;
    /// Enumerated values for AWD2CH14
    namespace awd2ch14 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 15, Width: 1
    /// Access: read-write
    using AWD2CH15 = BitField<15, 1>;
    constexpr uint32_t AWD2CH15_Pos = 15;
    constexpr uint32_t AWD2CH15_Msk = AWD2CH15::mask;
    /// Enumerated values for AWD2CH15
    namespace awd2ch15 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 16, Width: 1
    /// Access: read-write
    using AWD2CH16 = BitField<16, 1>;
    constexpr uint32_t AWD2CH16_Pos = 16;
    constexpr uint32_t AWD2CH16_Msk = AWD2CH16::mask;
    /// Enumerated values for AWD2CH16
    namespace awd2ch16 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 17, Width: 1
    /// Access: read-write
    using AWD2CH17 = BitField<17, 1>;
    constexpr uint32_t AWD2CH17_Pos = 17;
    constexpr uint32_t AWD2CH17_Msk = AWD2CH17::mask;
    /// Enumerated values for AWD2CH17
    namespace awd2ch17 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2). Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 18, Width: 1
    /// Access: read-write
    using AWD2CH18 = BitField<18, 1>;
    constexpr uint32_t AWD2CH18_Pos = 18;
    constexpr uint32_t AWD2CH18_Msk = AWD2CH18::mask;
    /// Enumerated values for AWD2CH18
    namespace awd2ch18 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace adc_awd2cr

/// ADC_AWD3CR - ADC Analog Watchdog 3 Configuration register
namespace adc_awd3cr {
    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 0, Width: 1
    /// Access: read-write
    using AWD3CH0 = BitField<0, 1>;
    constexpr uint32_t AWD3CH0_Pos = 0;
    constexpr uint32_t AWD3CH0_Msk = AWD3CH0::mask;
    /// Enumerated values for AWD3CH0
    namespace awd3ch0 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 1, Width: 1
    /// Access: read-write
    using AWD3CH1 = BitField<1, 1>;
    constexpr uint32_t AWD3CH1_Pos = 1;
    constexpr uint32_t AWD3CH1_Msk = AWD3CH1::mask;
    /// Enumerated values for AWD3CH1
    namespace awd3ch1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 2, Width: 1
    /// Access: read-write
    using AWD3CH2 = BitField<2, 1>;
    constexpr uint32_t AWD3CH2_Pos = 2;
    constexpr uint32_t AWD3CH2_Msk = AWD3CH2::mask;
    /// Enumerated values for AWD3CH2
    namespace awd3ch2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 3, Width: 1
    /// Access: read-write
    using AWD3CH3 = BitField<3, 1>;
    constexpr uint32_t AWD3CH3_Pos = 3;
    constexpr uint32_t AWD3CH3_Msk = AWD3CH3::mask;
    /// Enumerated values for AWD3CH3
    namespace awd3ch3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 4, Width: 1
    /// Access: read-write
    using AWD3CH4 = BitField<4, 1>;
    constexpr uint32_t AWD3CH4_Pos = 4;
    constexpr uint32_t AWD3CH4_Msk = AWD3CH4::mask;
    /// Enumerated values for AWD3CH4
    namespace awd3ch4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 5, Width: 1
    /// Access: read-write
    using AWD3CH5 = BitField<5, 1>;
    constexpr uint32_t AWD3CH5_Pos = 5;
    constexpr uint32_t AWD3CH5_Msk = AWD3CH5::mask;
    /// Enumerated values for AWD3CH5
    namespace awd3ch5 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 6, Width: 1
    /// Access: read-write
    using AWD3CH6 = BitField<6, 1>;
    constexpr uint32_t AWD3CH6_Pos = 6;
    constexpr uint32_t AWD3CH6_Msk = AWD3CH6::mask;
    /// Enumerated values for AWD3CH6
    namespace awd3ch6 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 7, Width: 1
    /// Access: read-write
    using AWD3CH7 = BitField<7, 1>;
    constexpr uint32_t AWD3CH7_Pos = 7;
    constexpr uint32_t AWD3CH7_Msk = AWD3CH7::mask;
    /// Enumerated values for AWD3CH7
    namespace awd3ch7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 8, Width: 1
    /// Access: read-write
    using AWD3CH8 = BitField<8, 1>;
    constexpr uint32_t AWD3CH8_Pos = 8;
    constexpr uint32_t AWD3CH8_Msk = AWD3CH8::mask;
    /// Enumerated values for AWD3CH8
    namespace awd3ch8 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 9, Width: 1
    /// Access: read-write
    using AWD3CH9 = BitField<9, 1>;
    constexpr uint32_t AWD3CH9_Pos = 9;
    constexpr uint32_t AWD3CH9_Msk = AWD3CH9::mask;
    /// Enumerated values for AWD3CH9
    namespace awd3ch9 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 10, Width: 1
    /// Access: read-write
    using AWD3CH10 = BitField<10, 1>;
    constexpr uint32_t AWD3CH10_Pos = 10;
    constexpr uint32_t AWD3CH10_Msk = AWD3CH10::mask;
    /// Enumerated values for AWD3CH10
    namespace awd3ch10 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 11, Width: 1
    /// Access: read-write
    using AWD3CH11 = BitField<11, 1>;
    constexpr uint32_t AWD3CH11_Pos = 11;
    constexpr uint32_t AWD3CH11_Msk = AWD3CH11::mask;
    /// Enumerated values for AWD3CH11
    namespace awd3ch11 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 12, Width: 1
    /// Access: read-write
    using AWD3CH12 = BitField<12, 1>;
    constexpr uint32_t AWD3CH12_Pos = 12;
    constexpr uint32_t AWD3CH12_Msk = AWD3CH12::mask;
    /// Enumerated values for AWD3CH12
    namespace awd3ch12 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 13, Width: 1
    /// Access: read-write
    using AWD3CH13 = BitField<13, 1>;
    constexpr uint32_t AWD3CH13_Pos = 13;
    constexpr uint32_t AWD3CH13_Msk = AWD3CH13::mask;
    /// Enumerated values for AWD3CH13
    namespace awd3ch13 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 14, Width: 1
    /// Access: read-write
    using AWD3CH14 = BitField<14, 1>;
    constexpr uint32_t AWD3CH14_Pos = 14;
    constexpr uint32_t AWD3CH14_Msk = AWD3CH14::mask;
    /// Enumerated values for AWD3CH14
    namespace awd3ch14 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 15, Width: 1
    /// Access: read-write
    using AWD3CH15 = BitField<15, 1>;
    constexpr uint32_t AWD3CH15_Pos = 15;
    constexpr uint32_t AWD3CH15_Msk = AWD3CH15::mask;
    /// Enumerated values for AWD3CH15
    namespace awd3ch15 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 16, Width: 1
    /// Access: read-write
    using AWD3CH16 = BitField<16, 1>;
    constexpr uint32_t AWD3CH16_Pos = 16;
    constexpr uint32_t AWD3CH16_Msk = AWD3CH16::mask;
    /// Enumerated values for AWD3CH16
    namespace awd3ch16 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 17, Width: 1
    /// Access: read-write
    using AWD3CH17 = BitField<17, 1>;
    constexpr uint32_t AWD3CH17_Pos = 17;
    constexpr uint32_t AWD3CH17_Msk = AWD3CH17::mask;
    /// Enumerated values for AWD3CH17
    namespace awd3ch17 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog watchdog channel selection These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3). Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
    /// Position: 18, Width: 1
    /// Access: read-write
    using AWD3CH18 = BitField<18, 1>;
    constexpr uint32_t AWD3CH18_Pos = 18;
    constexpr uint32_t AWD3CH18_Msk = AWD3CH18::mask;
    /// Enumerated values for AWD3CH18
    namespace awd3ch18 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace adc_awd3cr

/// ADC_CALFACT - ADC Calibration factor
namespace adc_calfact {
    /// Calibration factor These bits are written by hardware or by software. Once a calibration is complete,Â they are updated by hardware with the calibration factors. Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched. Just after a calibration is complete, DATA[6:0] contains the calibration factor. Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection.
    /// Position: 0, Width: 7
    /// Access: read-write
    using CALFACT = BitField<0, 7>;
    constexpr uint32_t CALFACT_Pos = 0;
    constexpr uint32_t CALFACT_Msk = CALFACT::mask;

}  // namespace adc_calfact

/// ADC_CCR - ADC common configuration register
namespace adc_ccr {
    /// ADC prescaler Set and cleared by software to select the frequency of the clock to the ADC. Other: Reserved Note: Software is allowed to write these bits only when the ADC is disabled (ADCALÂ =Â 0, ADSTARTÂ =Â 0, ADSTPÂ =Â 0, ADDISÂ =Â 0 and ADENÂ =Â 0).
    /// Position: 18, Width: 4
    /// Access: read-write
    using PRESC = BitField<18, 4>;
    constexpr uint32_t PRESC_Pos = 18;
    constexpr uint32_t PRESC_Msk = PRESC::mask;
    /// Enumerated values for PRESC
    namespace presc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0xA = 10;
        constexpr uint32_t B_0xB = 11;
    }

    /// VREFINT enable This bit is set and cleared by software to enable/disable the VREFINT. Note: Software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 22, Width: 1
    /// Access: read-write
    using VREFEN = BitField<22, 1>;
    constexpr uint32_t VREFEN_Pos = 22;
    constexpr uint32_t VREFEN_Msk = VREFEN::mask;
    /// Enumerated values for VREFEN
    namespace vrefen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Temperature sensor enable This bit is set and cleared by software to enable/disable the temperature sensor. Note: Software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing).
    /// Position: 23, Width: 1
    /// Access: read-write
    using TSEN = BitField<23, 1>;
    constexpr uint32_t TSEN_Pos = 23;
    constexpr uint32_t TSEN_Msk = TSEN::mask;
    /// Enumerated values for TSEN
    namespace tsen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// VBAT enable This bit is set and cleared by software to enable/disable the VBAT channel. Note: The software is allowed to write this bit only when ADSTARTÂ =Â 0 (which ensures that no conversion is ongoing)
    /// Position: 24, Width: 1
    /// Access: read-write
    using VBATEN = BitField<24, 1>;
    constexpr uint32_t VBATEN_Pos = 24;
    constexpr uint32_t VBATEN_Msk = VBATEN::mask;
    /// Enumerated values for VBATEN
    namespace vbaten {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace adc_ccr

}  // namespace alloy::hal::st::stm32g0::adc
