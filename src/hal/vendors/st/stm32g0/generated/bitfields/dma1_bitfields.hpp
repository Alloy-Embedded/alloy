/// Auto-generated bit field definitions for DMA1
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::dma1 {

using namespace alloy::hal::bitfields;

// ============================================================================
// DMA1 Bit Field Definitions
// ============================================================================

/// DMA_ISR - DMA interrupt status register
namespace dma_isr {
    /// global interrupt flag for channel 1
    /// Position: 0, Width: 1
    /// Access: read-only
    using GIF1 = BitField<0, 1>;
    constexpr uint32_t GIF1_Pos = 0;
    constexpr uint32_t GIF1_Msk = GIF1::mask;
    /// Enumerated values for GIF1
    namespace gif1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete (TC) flag for channel 1
    /// Position: 1, Width: 1
    /// Access: read-only
    using TCIF1 = BitField<1, 1>;
    constexpr uint32_t TCIF1_Pos = 1;
    constexpr uint32_t TCIF1_Msk = TCIF1::mask;
    /// Enumerated values for TCIF1
    namespace tcif1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer (HT) flag for channel 1
    /// Position: 2, Width: 1
    /// Access: read-only
    using HTIF1 = BitField<2, 1>;
    constexpr uint32_t HTIF1_Pos = 2;
    constexpr uint32_t HTIF1_Msk = HTIF1::mask;
    /// Enumerated values for HTIF1
    namespace htif1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error (TE) flag for channel 1
    /// Position: 3, Width: 1
    /// Access: read-only
    using TEIF1 = BitField<3, 1>;
    constexpr uint32_t TEIF1_Pos = 3;
    constexpr uint32_t TEIF1_Msk = TEIF1::mask;
    /// Enumerated values for TEIF1
    namespace teif1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// global interrupt flag for channel 2
    /// Position: 4, Width: 1
    /// Access: read-only
    using GIF2 = BitField<4, 1>;
    constexpr uint32_t GIF2_Pos = 4;
    constexpr uint32_t GIF2_Msk = GIF2::mask;
    /// Enumerated values for GIF2
    namespace gif2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete (TC) flag for channel 2
    /// Position: 5, Width: 1
    /// Access: read-only
    using TCIF2 = BitField<5, 1>;
    constexpr uint32_t TCIF2_Pos = 5;
    constexpr uint32_t TCIF2_Msk = TCIF2::mask;
    /// Enumerated values for TCIF2
    namespace tcif2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer (HT) flag for channel 2
    /// Position: 6, Width: 1
    /// Access: read-only
    using HTIF2 = BitField<6, 1>;
    constexpr uint32_t HTIF2_Pos = 6;
    constexpr uint32_t HTIF2_Msk = HTIF2::mask;
    /// Enumerated values for HTIF2
    namespace htif2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error (TE) flag for channel 2
    /// Position: 7, Width: 1
    /// Access: read-only
    using TEIF2 = BitField<7, 1>;
    constexpr uint32_t TEIF2_Pos = 7;
    constexpr uint32_t TEIF2_Msk = TEIF2::mask;
    /// Enumerated values for TEIF2
    namespace teif2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// global interrupt flag for channel 3
    /// Position: 8, Width: 1
    /// Access: read-only
    using GIF3 = BitField<8, 1>;
    constexpr uint32_t GIF3_Pos = 8;
    constexpr uint32_t GIF3_Msk = GIF3::mask;
    /// Enumerated values for GIF3
    namespace gif3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete (TC) flag for channel 3
    /// Position: 9, Width: 1
    /// Access: read-only
    using TCIF3 = BitField<9, 1>;
    constexpr uint32_t TCIF3_Pos = 9;
    constexpr uint32_t TCIF3_Msk = TCIF3::mask;
    /// Enumerated values for TCIF3
    namespace tcif3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer (HT) flag for channel 3
    /// Position: 10, Width: 1
    /// Access: read-only
    using HTIF3 = BitField<10, 1>;
    constexpr uint32_t HTIF3_Pos = 10;
    constexpr uint32_t HTIF3_Msk = HTIF3::mask;
    /// Enumerated values for HTIF3
    namespace htif3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error (TE) flag for channel 3
    /// Position: 11, Width: 1
    /// Access: read-only
    using TEIF3 = BitField<11, 1>;
    constexpr uint32_t TEIF3_Pos = 11;
    constexpr uint32_t TEIF3_Msk = TEIF3::mask;
    /// Enumerated values for TEIF3
    namespace teif3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// global interrupt flag for channel 4
    /// Position: 12, Width: 1
    /// Access: read-only
    using GIF4 = BitField<12, 1>;
    constexpr uint32_t GIF4_Pos = 12;
    constexpr uint32_t GIF4_Msk = GIF4::mask;
    /// Enumerated values for GIF4
    namespace gif4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete (TC) flag for channel 4
    /// Position: 13, Width: 1
    /// Access: read-only
    using TCIF4 = BitField<13, 1>;
    constexpr uint32_t TCIF4_Pos = 13;
    constexpr uint32_t TCIF4_Msk = TCIF4::mask;
    /// Enumerated values for TCIF4
    namespace tcif4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer (HT) flag for channel 4
    /// Position: 14, Width: 1
    /// Access: read-only
    using HTIF4 = BitField<14, 1>;
    constexpr uint32_t HTIF4_Pos = 14;
    constexpr uint32_t HTIF4_Msk = HTIF4::mask;
    /// Enumerated values for HTIF4
    namespace htif4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error (TE) flag for channel 4
    /// Position: 15, Width: 1
    /// Access: read-only
    using TEIF4 = BitField<15, 1>;
    constexpr uint32_t TEIF4_Pos = 15;
    constexpr uint32_t TEIF4_Msk = TEIF4::mask;
    /// Enumerated values for TEIF4
    namespace teif4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// global interrupt flag for channel 5
    /// Position: 16, Width: 1
    /// Access: read-only
    using GIF5 = BitField<16, 1>;
    constexpr uint32_t GIF5_Pos = 16;
    constexpr uint32_t GIF5_Msk = GIF5::mask;
    /// Enumerated values for GIF5
    namespace gif5 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete (TC) flag for channel 5
    /// Position: 17, Width: 1
    /// Access: read-only
    using TCIF5 = BitField<17, 1>;
    constexpr uint32_t TCIF5_Pos = 17;
    constexpr uint32_t TCIF5_Msk = TCIF5::mask;
    /// Enumerated values for TCIF5
    namespace tcif5 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer (HT) flag for channel 5
    /// Position: 18, Width: 1
    /// Access: read-only
    using HTIF5 = BitField<18, 1>;
    constexpr uint32_t HTIF5_Pos = 18;
    constexpr uint32_t HTIF5_Msk = HTIF5::mask;
    /// Enumerated values for HTIF5
    namespace htif5 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error (TE) flag for channel 5
    /// Position: 19, Width: 1
    /// Access: read-only
    using TEIF5 = BitField<19, 1>;
    constexpr uint32_t TEIF5_Pos = 19;
    constexpr uint32_t TEIF5_Msk = TEIF5::mask;
    /// Enumerated values for TEIF5
    namespace teif5 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// global interrupt flag for channel 6
    /// Position: 20, Width: 1
    /// Access: read-only
    using GIF6 = BitField<20, 1>;
    constexpr uint32_t GIF6_Pos = 20;
    constexpr uint32_t GIF6_Msk = GIF6::mask;
    /// Enumerated values for GIF6
    namespace gif6 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete (TC) flag for channel 6
    /// Position: 21, Width: 1
    /// Access: read-only
    using TCIF6 = BitField<21, 1>;
    constexpr uint32_t TCIF6_Pos = 21;
    constexpr uint32_t TCIF6_Msk = TCIF6::mask;
    /// Enumerated values for TCIF6
    namespace tcif6 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer (HT) flag for channel 6
    /// Position: 22, Width: 1
    /// Access: read-only
    using HTIF6 = BitField<22, 1>;
    constexpr uint32_t HTIF6_Pos = 22;
    constexpr uint32_t HTIF6_Msk = HTIF6::mask;
    /// Enumerated values for HTIF6
    namespace htif6 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error (TE) flag for channel 6
    /// Position: 23, Width: 1
    /// Access: read-only
    using TEIF6 = BitField<23, 1>;
    constexpr uint32_t TEIF6_Pos = 23;
    constexpr uint32_t TEIF6_Msk = TEIF6::mask;
    /// Enumerated values for TEIF6
    namespace teif6 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// global interrupt flag for channel 7
    /// Position: 24, Width: 1
    /// Access: read-only
    using GIF7 = BitField<24, 1>;
    constexpr uint32_t GIF7_Pos = 24;
    constexpr uint32_t GIF7_Msk = GIF7::mask;
    /// Enumerated values for GIF7
    namespace gif7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete (TC) flag for channel 7
    /// Position: 25, Width: 1
    /// Access: read-only
    using TCIF7 = BitField<25, 1>;
    constexpr uint32_t TCIF7_Pos = 25;
    constexpr uint32_t TCIF7_Msk = TCIF7::mask;
    /// Enumerated values for TCIF7
    namespace tcif7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer (HT) flag for channel 7
    /// Position: 26, Width: 1
    /// Access: read-only
    using HTIF7 = BitField<26, 1>;
    constexpr uint32_t HTIF7_Pos = 26;
    constexpr uint32_t HTIF7_Msk = HTIF7::mask;
    /// Enumerated values for HTIF7
    namespace htif7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error (TE) flag for channel 7
    /// Position: 27, Width: 1
    /// Access: read-only
    using TEIF7 = BitField<27, 1>;
    constexpr uint32_t TEIF7_Pos = 27;
    constexpr uint32_t TEIF7_Msk = TEIF7::mask;
    /// Enumerated values for TEIF7
    namespace teif7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dma_isr

/// DMA_IFCR - DMA interrupt flag clear register
namespace dma_ifcr {
    /// global interrupt flag clear for channel 1
    /// Position: 0, Width: 1
    /// Access: write-only
    using CGIF1 = BitField<0, 1>;
    constexpr uint32_t CGIF1_Pos = 0;
    constexpr uint32_t CGIF1_Msk = CGIF1::mask;

    /// transfer complete flag clear for channel 1
    /// Position: 1, Width: 1
    /// Access: write-only
    using CTCIF1 = BitField<1, 1>;
    constexpr uint32_t CTCIF1_Pos = 1;
    constexpr uint32_t CTCIF1_Msk = CTCIF1::mask;

    /// half transfer flag clear for channel 1
    /// Position: 2, Width: 1
    /// Access: write-only
    using CHTIF1 = BitField<2, 1>;
    constexpr uint32_t CHTIF1_Pos = 2;
    constexpr uint32_t CHTIF1_Msk = CHTIF1::mask;

    /// transfer error flag clear for channel 1
    /// Position: 3, Width: 1
    /// Access: write-only
    using CTEIF1 = BitField<3, 1>;
    constexpr uint32_t CTEIF1_Pos = 3;
    constexpr uint32_t CTEIF1_Msk = CTEIF1::mask;

    /// global interrupt flag clear for channel 2
    /// Position: 4, Width: 1
    /// Access: write-only
    using CGIF2 = BitField<4, 1>;
    constexpr uint32_t CGIF2_Pos = 4;
    constexpr uint32_t CGIF2_Msk = CGIF2::mask;

    /// transfer complete flag clear for channel 2
    /// Position: 5, Width: 1
    /// Access: write-only
    using CTCIF2 = BitField<5, 1>;
    constexpr uint32_t CTCIF2_Pos = 5;
    constexpr uint32_t CTCIF2_Msk = CTCIF2::mask;

    /// half transfer flag clear for channel 2
    /// Position: 6, Width: 1
    /// Access: write-only
    using CHTIF2 = BitField<6, 1>;
    constexpr uint32_t CHTIF2_Pos = 6;
    constexpr uint32_t CHTIF2_Msk = CHTIF2::mask;

    /// transfer error flag clear for channel 2
    /// Position: 7, Width: 1
    /// Access: write-only
    using CTEIF2 = BitField<7, 1>;
    constexpr uint32_t CTEIF2_Pos = 7;
    constexpr uint32_t CTEIF2_Msk = CTEIF2::mask;

    /// global interrupt flag clear for channel 3
    /// Position: 8, Width: 1
    /// Access: write-only
    using CGIF3 = BitField<8, 1>;
    constexpr uint32_t CGIF3_Pos = 8;
    constexpr uint32_t CGIF3_Msk = CGIF3::mask;

    /// transfer complete flag clear for channel 3
    /// Position: 9, Width: 1
    /// Access: write-only
    using CTCIF3 = BitField<9, 1>;
    constexpr uint32_t CTCIF3_Pos = 9;
    constexpr uint32_t CTCIF3_Msk = CTCIF3::mask;

    /// half transfer flag clear for channel 3
    /// Position: 10, Width: 1
    /// Access: write-only
    using CHTIF3 = BitField<10, 1>;
    constexpr uint32_t CHTIF3_Pos = 10;
    constexpr uint32_t CHTIF3_Msk = CHTIF3::mask;

    /// transfer error flag clear for channel 3
    /// Position: 11, Width: 1
    /// Access: write-only
    using CTEIF3 = BitField<11, 1>;
    constexpr uint32_t CTEIF3_Pos = 11;
    constexpr uint32_t CTEIF3_Msk = CTEIF3::mask;

    /// global interrupt flag clear for channel 4
    /// Position: 12, Width: 1
    /// Access: write-only
    using CGIF4 = BitField<12, 1>;
    constexpr uint32_t CGIF4_Pos = 12;
    constexpr uint32_t CGIF4_Msk = CGIF4::mask;

    /// transfer complete flag clear for channel 4
    /// Position: 13, Width: 1
    /// Access: write-only
    using CTCIF4 = BitField<13, 1>;
    constexpr uint32_t CTCIF4_Pos = 13;
    constexpr uint32_t CTCIF4_Msk = CTCIF4::mask;

    /// half transfer flag clear for channel 4
    /// Position: 14, Width: 1
    /// Access: write-only
    using CHTIF4 = BitField<14, 1>;
    constexpr uint32_t CHTIF4_Pos = 14;
    constexpr uint32_t CHTIF4_Msk = CHTIF4::mask;

    /// transfer error flag clear for channel 4
    /// Position: 15, Width: 1
    /// Access: write-only
    using CTEIF4 = BitField<15, 1>;
    constexpr uint32_t CTEIF4_Pos = 15;
    constexpr uint32_t CTEIF4_Msk = CTEIF4::mask;

    /// global interrupt flag clear for channel 5
    /// Position: 16, Width: 1
    /// Access: write-only
    using CGIF5 = BitField<16, 1>;
    constexpr uint32_t CGIF5_Pos = 16;
    constexpr uint32_t CGIF5_Msk = CGIF5::mask;

    /// transfer complete flag clear for channel 5
    /// Position: 17, Width: 1
    /// Access: write-only
    using CTCIF5 = BitField<17, 1>;
    constexpr uint32_t CTCIF5_Pos = 17;
    constexpr uint32_t CTCIF5_Msk = CTCIF5::mask;

    /// half transfer flag clear for channel 5
    /// Position: 18, Width: 1
    /// Access: write-only
    using CHTIF5 = BitField<18, 1>;
    constexpr uint32_t CHTIF5_Pos = 18;
    constexpr uint32_t CHTIF5_Msk = CHTIF5::mask;

    /// transfer error flag clear for channel 5
    /// Position: 19, Width: 1
    /// Access: write-only
    using CTEIF5 = BitField<19, 1>;
    constexpr uint32_t CTEIF5_Pos = 19;
    constexpr uint32_t CTEIF5_Msk = CTEIF5::mask;

    /// global interrupt flag clear for channel 6
    /// Position: 20, Width: 1
    /// Access: write-only
    using CGIF6 = BitField<20, 1>;
    constexpr uint32_t CGIF6_Pos = 20;
    constexpr uint32_t CGIF6_Msk = CGIF6::mask;

    /// transfer complete flag clear for channel 6
    /// Position: 21, Width: 1
    /// Access: write-only
    using CTCIF6 = BitField<21, 1>;
    constexpr uint32_t CTCIF6_Pos = 21;
    constexpr uint32_t CTCIF6_Msk = CTCIF6::mask;

    /// half transfer flag clear for channel 6
    /// Position: 22, Width: 1
    /// Access: write-only
    using CHTIF6 = BitField<22, 1>;
    constexpr uint32_t CHTIF6_Pos = 22;
    constexpr uint32_t CHTIF6_Msk = CHTIF6::mask;

    /// transfer error flag clear for channel 6
    /// Position: 23, Width: 1
    /// Access: write-only
    using CTEIF6 = BitField<23, 1>;
    constexpr uint32_t CTEIF6_Pos = 23;
    constexpr uint32_t CTEIF6_Msk = CTEIF6::mask;

    /// global interrupt flag clear for channel 7
    /// Position: 24, Width: 1
    /// Access: write-only
    using CGIF7 = BitField<24, 1>;
    constexpr uint32_t CGIF7_Pos = 24;
    constexpr uint32_t CGIF7_Msk = CGIF7::mask;

    /// transfer complete flag clear for channel 7
    /// Position: 25, Width: 1
    /// Access: write-only
    using CTCIF7 = BitField<25, 1>;
    constexpr uint32_t CTCIF7_Pos = 25;
    constexpr uint32_t CTCIF7_Msk = CTCIF7::mask;

    /// half transfer flag clear for channel 7
    /// Position: 26, Width: 1
    /// Access: write-only
    using CHTIF7 = BitField<26, 1>;
    constexpr uint32_t CHTIF7_Pos = 26;
    constexpr uint32_t CHTIF7_Msk = CHTIF7::mask;

    /// transfer error flag clear for channel 7
    /// Position: 27, Width: 1
    /// Access: write-only
    using CTEIF7 = BitField<27, 1>;
    constexpr uint32_t CTEIF7_Pos = 27;
    constexpr uint32_t CTEIF7_Msk = CTEIF7::mask;

}  // namespace dma_ifcr

/// DMA_CCR1 - DMA channel 1 configuration register
namespace dma_ccr1 {
    /// channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;
    /// Enumerated values for EN
    namespace en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 1, Width: 1
    /// Access: read-write
    using TCIE = BitField<1, 1>;
    constexpr uint32_t TCIE_Pos = 1;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 2, Width: 1
    /// Access: read-write
    using HTIE = BitField<2, 1>;
    constexpr uint32_t HTIE_Pos = 2;
    constexpr uint32_t HTIE_Msk = HTIE::mask;
    /// Enumerated values for HTIE
    namespace htie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 3, Width: 1
    /// Access: read-write
    using TEIE = BitField<3, 1>;
    constexpr uint32_t TEIE_Pos = 3;
    constexpr uint32_t TEIE_Msk = TEIE::mask;
    /// Enumerated values for TEIE
    namespace teie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 4, Width: 1
    /// Access: read-write
    using DIR = BitField<4, 1>;
    constexpr uint32_t DIR_Pos = 4;
    constexpr uint32_t DIR_Msk = DIR::mask;
    /// Enumerated values for DIR
    namespace dir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 5, Width: 1
    /// Access: read-write
    using CIRC = BitField<5, 1>;
    constexpr uint32_t CIRC_Pos = 5;
    constexpr uint32_t CIRC_Msk = CIRC::mask;
    /// Enumerated values for CIRC
    namespace circ {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 6, Width: 1
    /// Access: read-write
    using PINC = BitField<6, 1>;
    constexpr uint32_t PINC_Pos = 6;
    constexpr uint32_t PINC_Msk = PINC::mask;
    /// Enumerated values for PINC
    namespace pinc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 7, Width: 1
    /// Access: read-write
    using MINC = BitField<7, 1>;
    constexpr uint32_t MINC_Pos = 7;
    constexpr uint32_t MINC_Msk = MINC::mask;
    /// Enumerated values for MINC
    namespace minc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 8, Width: 2
    /// Access: read-write
    using PSIZE = BitField<8, 2>;
    constexpr uint32_t PSIZE_Pos = 8;
    constexpr uint32_t PSIZE_Msk = PSIZE::mask;
    /// Enumerated values for PSIZE
    namespace psize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 10, Width: 2
    /// Access: read-write
    using MSIZE = BitField<10, 2>;
    constexpr uint32_t MSIZE_Pos = 10;
    constexpr uint32_t MSIZE_Msk = MSIZE::mask;
    /// Enumerated values for MSIZE
    namespace msize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 12, Width: 2
    /// Access: read-write
    using PL = BitField<12, 2>;
    constexpr uint32_t PL_Pos = 12;
    constexpr uint32_t PL_Msk = PL::mask;
    /// Enumerated values for PL
    namespace pl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 14, Width: 1
    /// Access: read-write
    using MEM2MEM = BitField<14, 1>;
    constexpr uint32_t MEM2MEM_Pos = 14;
    constexpr uint32_t MEM2MEM_Msk = MEM2MEM::mask;
    /// Enumerated values for MEM2MEM
    namespace mem2mem {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dma_ccr1

/// DMA_CNDTR1 - DMA channel 1 number of data to transfer register
namespace dma_cndtr1 {
    /// number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 16
    /// Access: read-write
    using NDT = BitField<0, 16>;
    constexpr uint32_t NDT_Pos = 0;
    constexpr uint32_t NDT_Msk = NDT::mask;

}  // namespace dma_cndtr1

/// DMA_CPAR1 - DMA channel 1 peripheral address register
namespace dma_cpar1 {
    /// peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using PA = BitField<0, 32>;
    constexpr uint32_t PA_Pos = 0;
    constexpr uint32_t PA_Msk = PA::mask;

}  // namespace dma_cpar1

/// DMA_CMAR1 - DMA channel 1 memory address register
namespace dma_cmar1 {
    /// peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using MA = BitField<0, 32>;
    constexpr uint32_t MA_Pos = 0;
    constexpr uint32_t MA_Msk = MA::mask;

}  // namespace dma_cmar1

/// DMA_CCR2 - DMA channel 2 configuration register
namespace dma_ccr2 {
    /// channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;
    /// Enumerated values for EN
    namespace en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 1, Width: 1
    /// Access: read-write
    using TCIE = BitField<1, 1>;
    constexpr uint32_t TCIE_Pos = 1;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 2, Width: 1
    /// Access: read-write
    using HTIE = BitField<2, 1>;
    constexpr uint32_t HTIE_Pos = 2;
    constexpr uint32_t HTIE_Msk = HTIE::mask;
    /// Enumerated values for HTIE
    namespace htie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 3, Width: 1
    /// Access: read-write
    using TEIE = BitField<3, 1>;
    constexpr uint32_t TEIE_Pos = 3;
    constexpr uint32_t TEIE_Msk = TEIE::mask;
    /// Enumerated values for TEIE
    namespace teie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 4, Width: 1
    /// Access: read-write
    using DIR = BitField<4, 1>;
    constexpr uint32_t DIR_Pos = 4;
    constexpr uint32_t DIR_Msk = DIR::mask;
    /// Enumerated values for DIR
    namespace dir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 5, Width: 1
    /// Access: read-write
    using CIRC = BitField<5, 1>;
    constexpr uint32_t CIRC_Pos = 5;
    constexpr uint32_t CIRC_Msk = CIRC::mask;
    /// Enumerated values for CIRC
    namespace circ {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 6, Width: 1
    /// Access: read-write
    using PINC = BitField<6, 1>;
    constexpr uint32_t PINC_Pos = 6;
    constexpr uint32_t PINC_Msk = PINC::mask;
    /// Enumerated values for PINC
    namespace pinc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 7, Width: 1
    /// Access: read-write
    using MINC = BitField<7, 1>;
    constexpr uint32_t MINC_Pos = 7;
    constexpr uint32_t MINC_Msk = MINC::mask;
    /// Enumerated values for MINC
    namespace minc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 8, Width: 2
    /// Access: read-write
    using PSIZE = BitField<8, 2>;
    constexpr uint32_t PSIZE_Pos = 8;
    constexpr uint32_t PSIZE_Msk = PSIZE::mask;
    /// Enumerated values for PSIZE
    namespace psize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 10, Width: 2
    /// Access: read-write
    using MSIZE = BitField<10, 2>;
    constexpr uint32_t MSIZE_Pos = 10;
    constexpr uint32_t MSIZE_Msk = MSIZE::mask;
    /// Enumerated values for MSIZE
    namespace msize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 12, Width: 2
    /// Access: read-write
    using PL = BitField<12, 2>;
    constexpr uint32_t PL_Pos = 12;
    constexpr uint32_t PL_Msk = PL::mask;
    /// Enumerated values for PL
    namespace pl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 14, Width: 1
    /// Access: read-write
    using MEM2MEM = BitField<14, 1>;
    constexpr uint32_t MEM2MEM_Pos = 14;
    constexpr uint32_t MEM2MEM_Msk = MEM2MEM::mask;
    /// Enumerated values for MEM2MEM
    namespace mem2mem {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dma_ccr2

/// DMA_CNDTR2 - DMA channel 2 number of data to transfer register
namespace dma_cndtr2 {
    /// number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 16
    /// Access: read-write
    using NDT = BitField<0, 16>;
    constexpr uint32_t NDT_Pos = 0;
    constexpr uint32_t NDT_Msk = NDT::mask;

}  // namespace dma_cndtr2

/// DMA_CPAR2 - DMA channel 2 peripheral address register
namespace dma_cpar2 {
    /// peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using PA = BitField<0, 32>;
    constexpr uint32_t PA_Pos = 0;
    constexpr uint32_t PA_Msk = PA::mask;

}  // namespace dma_cpar2

/// DMA_CMAR2 - DMA channel 2 memory address register
namespace dma_cmar2 {
    /// peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using MA = BitField<0, 32>;
    constexpr uint32_t MA_Pos = 0;
    constexpr uint32_t MA_Msk = MA::mask;

}  // namespace dma_cmar2

/// DMA_CCR3 - DMA channel 3 configuration register
namespace dma_ccr3 {
    /// channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;
    /// Enumerated values for EN
    namespace en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 1, Width: 1
    /// Access: read-write
    using TCIE = BitField<1, 1>;
    constexpr uint32_t TCIE_Pos = 1;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 2, Width: 1
    /// Access: read-write
    using HTIE = BitField<2, 1>;
    constexpr uint32_t HTIE_Pos = 2;
    constexpr uint32_t HTIE_Msk = HTIE::mask;
    /// Enumerated values for HTIE
    namespace htie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 3, Width: 1
    /// Access: read-write
    using TEIE = BitField<3, 1>;
    constexpr uint32_t TEIE_Pos = 3;
    constexpr uint32_t TEIE_Msk = TEIE::mask;
    /// Enumerated values for TEIE
    namespace teie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 4, Width: 1
    /// Access: read-write
    using DIR = BitField<4, 1>;
    constexpr uint32_t DIR_Pos = 4;
    constexpr uint32_t DIR_Msk = DIR::mask;
    /// Enumerated values for DIR
    namespace dir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 5, Width: 1
    /// Access: read-write
    using CIRC = BitField<5, 1>;
    constexpr uint32_t CIRC_Pos = 5;
    constexpr uint32_t CIRC_Msk = CIRC::mask;
    /// Enumerated values for CIRC
    namespace circ {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 6, Width: 1
    /// Access: read-write
    using PINC = BitField<6, 1>;
    constexpr uint32_t PINC_Pos = 6;
    constexpr uint32_t PINC_Msk = PINC::mask;
    /// Enumerated values for PINC
    namespace pinc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 7, Width: 1
    /// Access: read-write
    using MINC = BitField<7, 1>;
    constexpr uint32_t MINC_Pos = 7;
    constexpr uint32_t MINC_Msk = MINC::mask;
    /// Enumerated values for MINC
    namespace minc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 8, Width: 2
    /// Access: read-write
    using PSIZE = BitField<8, 2>;
    constexpr uint32_t PSIZE_Pos = 8;
    constexpr uint32_t PSIZE_Msk = PSIZE::mask;
    /// Enumerated values for PSIZE
    namespace psize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 10, Width: 2
    /// Access: read-write
    using MSIZE = BitField<10, 2>;
    constexpr uint32_t MSIZE_Pos = 10;
    constexpr uint32_t MSIZE_Msk = MSIZE::mask;
    /// Enumerated values for MSIZE
    namespace msize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 12, Width: 2
    /// Access: read-write
    using PL = BitField<12, 2>;
    constexpr uint32_t PL_Pos = 12;
    constexpr uint32_t PL_Msk = PL::mask;
    /// Enumerated values for PL
    namespace pl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 14, Width: 1
    /// Access: read-write
    using MEM2MEM = BitField<14, 1>;
    constexpr uint32_t MEM2MEM_Pos = 14;
    constexpr uint32_t MEM2MEM_Msk = MEM2MEM::mask;
    /// Enumerated values for MEM2MEM
    namespace mem2mem {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dma_ccr3

/// DMA_CNDTR3 - DMA channel 3 number of data to transfer register
namespace dma_cndtr3 {
    /// number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 16
    /// Access: read-write
    using NDT = BitField<0, 16>;
    constexpr uint32_t NDT_Pos = 0;
    constexpr uint32_t NDT_Msk = NDT::mask;

}  // namespace dma_cndtr3

/// DMA_CPAR3 - DMA channel 3 peripheral address register
namespace dma_cpar3 {
    /// peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using PA = BitField<0, 32>;
    constexpr uint32_t PA_Pos = 0;
    constexpr uint32_t PA_Msk = PA::mask;

}  // namespace dma_cpar3

/// DMA_CMAR3 - DMA channel 3 memory address register
namespace dma_cmar3 {
    /// peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using MA = BitField<0, 32>;
    constexpr uint32_t MA_Pos = 0;
    constexpr uint32_t MA_Msk = MA::mask;

}  // namespace dma_cmar3

/// DMA_CCR4 - DMA channel 4 configuration register
namespace dma_ccr4 {
    /// channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;
    /// Enumerated values for EN
    namespace en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 1, Width: 1
    /// Access: read-write
    using TCIE = BitField<1, 1>;
    constexpr uint32_t TCIE_Pos = 1;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 2, Width: 1
    /// Access: read-write
    using HTIE = BitField<2, 1>;
    constexpr uint32_t HTIE_Pos = 2;
    constexpr uint32_t HTIE_Msk = HTIE::mask;
    /// Enumerated values for HTIE
    namespace htie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 3, Width: 1
    /// Access: read-write
    using TEIE = BitField<3, 1>;
    constexpr uint32_t TEIE_Pos = 3;
    constexpr uint32_t TEIE_Msk = TEIE::mask;
    /// Enumerated values for TEIE
    namespace teie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 4, Width: 1
    /// Access: read-write
    using DIR = BitField<4, 1>;
    constexpr uint32_t DIR_Pos = 4;
    constexpr uint32_t DIR_Msk = DIR::mask;
    /// Enumerated values for DIR
    namespace dir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 5, Width: 1
    /// Access: read-write
    using CIRC = BitField<5, 1>;
    constexpr uint32_t CIRC_Pos = 5;
    constexpr uint32_t CIRC_Msk = CIRC::mask;
    /// Enumerated values for CIRC
    namespace circ {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 6, Width: 1
    /// Access: read-write
    using PINC = BitField<6, 1>;
    constexpr uint32_t PINC_Pos = 6;
    constexpr uint32_t PINC_Msk = PINC::mask;
    /// Enumerated values for PINC
    namespace pinc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 7, Width: 1
    /// Access: read-write
    using MINC = BitField<7, 1>;
    constexpr uint32_t MINC_Pos = 7;
    constexpr uint32_t MINC_Msk = MINC::mask;
    /// Enumerated values for MINC
    namespace minc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 8, Width: 2
    /// Access: read-write
    using PSIZE = BitField<8, 2>;
    constexpr uint32_t PSIZE_Pos = 8;
    constexpr uint32_t PSIZE_Msk = PSIZE::mask;
    /// Enumerated values for PSIZE
    namespace psize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 10, Width: 2
    /// Access: read-write
    using MSIZE = BitField<10, 2>;
    constexpr uint32_t MSIZE_Pos = 10;
    constexpr uint32_t MSIZE_Msk = MSIZE::mask;
    /// Enumerated values for MSIZE
    namespace msize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 12, Width: 2
    /// Access: read-write
    using PL = BitField<12, 2>;
    constexpr uint32_t PL_Pos = 12;
    constexpr uint32_t PL_Msk = PL::mask;
    /// Enumerated values for PL
    namespace pl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 14, Width: 1
    /// Access: read-write
    using MEM2MEM = BitField<14, 1>;
    constexpr uint32_t MEM2MEM_Pos = 14;
    constexpr uint32_t MEM2MEM_Msk = MEM2MEM::mask;
    /// Enumerated values for MEM2MEM
    namespace mem2mem {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dma_ccr4

/// DMA_CNDTR4 - DMA channel 4 number of data to transfer register
namespace dma_cndtr4 {
    /// number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 16
    /// Access: read-write
    using NDT = BitField<0, 16>;
    constexpr uint32_t NDT_Pos = 0;
    constexpr uint32_t NDT_Msk = NDT::mask;

}  // namespace dma_cndtr4

/// DMA_CPAR4 - DMA channel 4 peripheral address register
namespace dma_cpar4 {
    /// peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using PA = BitField<0, 32>;
    constexpr uint32_t PA_Pos = 0;
    constexpr uint32_t PA_Msk = PA::mask;

}  // namespace dma_cpar4

/// DMA_CMAR4 - DMA channel 4 memory address register
namespace dma_cmar4 {
    /// peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using MA = BitField<0, 32>;
    constexpr uint32_t MA_Pos = 0;
    constexpr uint32_t MA_Msk = MA::mask;

}  // namespace dma_cmar4

/// DMA_CCR5 - DMA channel 5 configuration register
namespace dma_ccr5 {
    /// channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;
    /// Enumerated values for EN
    namespace en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 1, Width: 1
    /// Access: read-write
    using TCIE = BitField<1, 1>;
    constexpr uint32_t TCIE_Pos = 1;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 2, Width: 1
    /// Access: read-write
    using HTIE = BitField<2, 1>;
    constexpr uint32_t HTIE_Pos = 2;
    constexpr uint32_t HTIE_Msk = HTIE::mask;
    /// Enumerated values for HTIE
    namespace htie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 3, Width: 1
    /// Access: read-write
    using TEIE = BitField<3, 1>;
    constexpr uint32_t TEIE_Pos = 3;
    constexpr uint32_t TEIE_Msk = TEIE::mask;
    /// Enumerated values for TEIE
    namespace teie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 4, Width: 1
    /// Access: read-write
    using DIR = BitField<4, 1>;
    constexpr uint32_t DIR_Pos = 4;
    constexpr uint32_t DIR_Msk = DIR::mask;
    /// Enumerated values for DIR
    namespace dir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 5, Width: 1
    /// Access: read-write
    using CIRC = BitField<5, 1>;
    constexpr uint32_t CIRC_Pos = 5;
    constexpr uint32_t CIRC_Msk = CIRC::mask;
    /// Enumerated values for CIRC
    namespace circ {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 6, Width: 1
    /// Access: read-write
    using PINC = BitField<6, 1>;
    constexpr uint32_t PINC_Pos = 6;
    constexpr uint32_t PINC_Msk = PINC::mask;
    /// Enumerated values for PINC
    namespace pinc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 7, Width: 1
    /// Access: read-write
    using MINC = BitField<7, 1>;
    constexpr uint32_t MINC_Pos = 7;
    constexpr uint32_t MINC_Msk = MINC::mask;
    /// Enumerated values for MINC
    namespace minc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 8, Width: 2
    /// Access: read-write
    using PSIZE = BitField<8, 2>;
    constexpr uint32_t PSIZE_Pos = 8;
    constexpr uint32_t PSIZE_Msk = PSIZE::mask;
    /// Enumerated values for PSIZE
    namespace psize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 10, Width: 2
    /// Access: read-write
    using MSIZE = BitField<10, 2>;
    constexpr uint32_t MSIZE_Pos = 10;
    constexpr uint32_t MSIZE_Msk = MSIZE::mask;
    /// Enumerated values for MSIZE
    namespace msize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 12, Width: 2
    /// Access: read-write
    using PL = BitField<12, 2>;
    constexpr uint32_t PL_Pos = 12;
    constexpr uint32_t PL_Msk = PL::mask;
    /// Enumerated values for PL
    namespace pl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 14, Width: 1
    /// Access: read-write
    using MEM2MEM = BitField<14, 1>;
    constexpr uint32_t MEM2MEM_Pos = 14;
    constexpr uint32_t MEM2MEM_Msk = MEM2MEM::mask;
    /// Enumerated values for MEM2MEM
    namespace mem2mem {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dma_ccr5

/// DMA_CNDTR5 - DMA channel 5 number of data to transfer register
namespace dma_cndtr5 {
    /// number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 16
    /// Access: read-write
    using NDT = BitField<0, 16>;
    constexpr uint32_t NDT_Pos = 0;
    constexpr uint32_t NDT_Msk = NDT::mask;

}  // namespace dma_cndtr5

/// DMA_CPAR5 - DMA channel 5 peripheral address register
namespace dma_cpar5 {
    /// peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using PA = BitField<0, 32>;
    constexpr uint32_t PA_Pos = 0;
    constexpr uint32_t PA_Msk = PA::mask;

}  // namespace dma_cpar5

/// DMA_CMAR5 - DMA channel 5 memory address register
namespace dma_cmar5 {
    /// peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using MA = BitField<0, 32>;
    constexpr uint32_t MA_Pos = 0;
    constexpr uint32_t MA_Msk = MA::mask;

}  // namespace dma_cmar5

/// DMA_CCR6 - DMA channel 6 configuration register
namespace dma_ccr6 {
    /// channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;
    /// Enumerated values for EN
    namespace en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 1, Width: 1
    /// Access: read-write
    using TCIE = BitField<1, 1>;
    constexpr uint32_t TCIE_Pos = 1;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 2, Width: 1
    /// Access: read-write
    using HTIE = BitField<2, 1>;
    constexpr uint32_t HTIE_Pos = 2;
    constexpr uint32_t HTIE_Msk = HTIE::mask;
    /// Enumerated values for HTIE
    namespace htie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 3, Width: 1
    /// Access: read-write
    using TEIE = BitField<3, 1>;
    constexpr uint32_t TEIE_Pos = 3;
    constexpr uint32_t TEIE_Msk = TEIE::mask;
    /// Enumerated values for TEIE
    namespace teie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 4, Width: 1
    /// Access: read-write
    using DIR = BitField<4, 1>;
    constexpr uint32_t DIR_Pos = 4;
    constexpr uint32_t DIR_Msk = DIR::mask;
    /// Enumerated values for DIR
    namespace dir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 5, Width: 1
    /// Access: read-write
    using CIRC = BitField<5, 1>;
    constexpr uint32_t CIRC_Pos = 5;
    constexpr uint32_t CIRC_Msk = CIRC::mask;
    /// Enumerated values for CIRC
    namespace circ {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 6, Width: 1
    /// Access: read-write
    using PINC = BitField<6, 1>;
    constexpr uint32_t PINC_Pos = 6;
    constexpr uint32_t PINC_Msk = PINC::mask;
    /// Enumerated values for PINC
    namespace pinc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 7, Width: 1
    /// Access: read-write
    using MINC = BitField<7, 1>;
    constexpr uint32_t MINC_Pos = 7;
    constexpr uint32_t MINC_Msk = MINC::mask;
    /// Enumerated values for MINC
    namespace minc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 8, Width: 2
    /// Access: read-write
    using PSIZE = BitField<8, 2>;
    constexpr uint32_t PSIZE_Pos = 8;
    constexpr uint32_t PSIZE_Msk = PSIZE::mask;
    /// Enumerated values for PSIZE
    namespace psize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 10, Width: 2
    /// Access: read-write
    using MSIZE = BitField<10, 2>;
    constexpr uint32_t MSIZE_Pos = 10;
    constexpr uint32_t MSIZE_Msk = MSIZE::mask;
    /// Enumerated values for MSIZE
    namespace msize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 12, Width: 2
    /// Access: read-write
    using PL = BitField<12, 2>;
    constexpr uint32_t PL_Pos = 12;
    constexpr uint32_t PL_Msk = PL::mask;
    /// Enumerated values for PL
    namespace pl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 14, Width: 1
    /// Access: read-write
    using MEM2MEM = BitField<14, 1>;
    constexpr uint32_t MEM2MEM_Pos = 14;
    constexpr uint32_t MEM2MEM_Msk = MEM2MEM::mask;
    /// Enumerated values for MEM2MEM
    namespace mem2mem {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dma_ccr6

/// DMA_CNDTR6 - DMA channel 6 number of data to transfer register
namespace dma_cndtr6 {
    /// number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 16
    /// Access: read-write
    using NDT = BitField<0, 16>;
    constexpr uint32_t NDT_Pos = 0;
    constexpr uint32_t NDT_Msk = NDT::mask;

}  // namespace dma_cndtr6

/// DMA_CPAR6 - DMA channel 6 peripheral address register
namespace dma_cpar6 {
    /// peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using PA = BitField<0, 32>;
    constexpr uint32_t PA_Pos = 0;
    constexpr uint32_t PA_Msk = PA::mask;

}  // namespace dma_cpar6

/// DMA_CMAR6 - DMA channel 6 memory address register
namespace dma_cmar6 {
    /// peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using MA = BitField<0, 32>;
    constexpr uint32_t MA_Pos = 0;
    constexpr uint32_t MA_Msk = MA::mask;

}  // namespace dma_cmar6

/// DMA_CCR7 - DMA channel 7 configuration register
namespace dma_ccr7 {
    /// channel enable When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register). Note: this bit is set and cleared by software.
    /// Position: 0, Width: 1
    /// Access: read-write
    using EN = BitField<0, 1>;
    constexpr uint32_t EN_Pos = 0;
    constexpr uint32_t EN_Msk = EN::mask;
    /// Enumerated values for EN
    namespace en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer complete interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 1, Width: 1
    /// Access: read-write
    using TCIE = BitField<1, 1>;
    constexpr uint32_t TCIE_Pos = 1;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// half transfer interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 2, Width: 1
    /// Access: read-write
    using HTIE = BitField<2, 1>;
    constexpr uint32_t HTIE_Pos = 2;
    constexpr uint32_t HTIE_Msk = HTIE::mask;
    /// Enumerated values for HTIE
    namespace htie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// transfer error interrupt enable Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 3, Width: 1
    /// Access: read-write
    using TEIE = BitField<3, 1>;
    constexpr uint32_t TEIE_Pos = 3;
    constexpr uint32_t TEIE_Msk = TEIE::mask;
    /// Enumerated values for TEIE
    namespace teie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// data transfer direction This bit must be set only in memory-to-peripheral and peripheral-to-memory modes. Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode. Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 4, Width: 1
    /// Access: read-write
    using DIR = BitField<4, 1>;
    constexpr uint32_t DIR_Pos = 4;
    constexpr uint32_t DIR_Msk = DIR::mask;
    /// Enumerated values for DIR
    namespace dir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// circular mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 5, Width: 1
    /// Access: read-write
    using CIRC = BitField<5, 1>;
    constexpr uint32_t CIRC_Pos = 5;
    constexpr uint32_t CIRC_Msk = CIRC::mask;
    /// Enumerated values for CIRC
    namespace circ {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral increment mode Defines the increment mode for each DMA transfer to the identified peripheral. n memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 6, Width: 1
    /// Access: read-write
    using PINC = BitField<6, 1>;
    constexpr uint32_t PINC_Pos = 6;
    constexpr uint32_t PINC_Msk = PINC::mask;
    /// Enumerated values for PINC
    namespace pinc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// memory increment mode Defines the increment mode for each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 7, Width: 1
    /// Access: read-write
    using MINC = BitField<7, 1>;
    constexpr uint32_t MINC_Pos = 7;
    constexpr uint32_t MINC_Msk = MINC::mask;
    /// Enumerated values for MINC
    namespace minc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// peripheral size Defines the data size of each DMA transfer to the identified peripheral. In memory-to-memory mode, this field identifies the memory destination if DIRÂ =Â 1 and the memory source if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIRÂ =Â 1 and the peripheral source if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 8, Width: 2
    /// Access: read-write
    using PSIZE = BitField<8, 2>;
    constexpr uint32_t PSIZE_Pos = 8;
    constexpr uint32_t PSIZE_Msk = PSIZE::mask;
    /// Enumerated values for PSIZE
    namespace psize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// memory size Defines the data size of each DMA transfer to the identified memory. In memory-to-memory mode, this field identifies the memory source if DIRÂ =Â 1 and the memory destination if DIRÂ =Â 0. In peripheral-to-peripheral mode, this field identifies the peripheral source if DIRÂ =Â 1 and the peripheral destination if DIRÂ =Â 0. Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 10, Width: 2
    /// Access: read-write
    using MSIZE = BitField<10, 2>;
    constexpr uint32_t MSIZE_Pos = 10;
    constexpr uint32_t MSIZE_Msk = MSIZE::mask;
    /// Enumerated values for MSIZE
    namespace msize {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// priority level Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 12, Width: 2
    /// Access: read-write
    using PL = BitField<12, 2>;
    constexpr uint32_t PL_Pos = 12;
    constexpr uint32_t PL_Msk = PL::mask;
    /// Enumerated values for PL
    namespace pl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// memory-to-memory mode Note: this bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 14, Width: 1
    /// Access: read-write
    using MEM2MEM = BitField<14, 1>;
    constexpr uint32_t MEM2MEM_Pos = 14;
    constexpr uint32_t MEM2MEM_Msk = MEM2MEM::mask;
    /// Enumerated values for MEM2MEM
    namespace mem2mem {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dma_ccr7

/// DMA_CNDTR7 - DMA channel 7 number of data to transfer register
namespace dma_cndtr7 {
    /// number of data to transfer (0 to 216Â -Â 1) This field is updated by hardware when the channel is enabled: It is decremented after each single DMA 'read followed by writeâ transfer, indicating the remaining amount of data items to transfer. It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRCÂ =Â 0 in the DMA_CCRx register). It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRCÂ =Â 1). If this field is zero, no transfer can be served whatever the channel status (enabled or not). Note: this field is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 16
    /// Access: read-write
    using NDT = BitField<0, 16>;
    constexpr uint32_t NDT_Pos = 0;
    constexpr uint32_t NDT_Msk = NDT::mask;

}  // namespace dma_cndtr7

/// DMA_CPAR7 - DMA channel 7 peripheral address register
namespace dma_cpar7 {
    /// peripheral address It contains the base address of the peripheral data register from/to which the data will be read/written. When PSIZE[1:0]Â =Â 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address. When PSIZEÂ =Â 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory destination address if DIRÂ =Â 1 and the memory source address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIRÂ =Â 1 and the peripheral source address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using PA = BitField<0, 32>;
    constexpr uint32_t PA_Pos = 0;
    constexpr uint32_t PA_Msk = PA::mask;

}  // namespace dma_cpar7

/// DMA_CMAR7 - DMA channel 7 memory address register
namespace dma_cmar7 {
    /// peripheral address It contains the base address of the memory from/to which the data will be read/written. When MSIZE[1:0]Â =Â 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address. When MSIZEÂ =Â 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address. In memory-to-memory mode, this register identifies the memory source address if DIRÂ =Â 1 and the memory destination address if DIRÂ =Â 0. In peripheral-to-peripheral mode, this register identifies the peripheral source address DIRÂ =Â 1 and the peripheral destination address if DIRÂ =Â 0. Note: this register is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (ENÂ =Â 1).
    /// Position: 0, Width: 32
    /// Access: read-write
    using MA = BitField<0, 32>;
    constexpr uint32_t MA_Pos = 0;
    constexpr uint32_t MA_Msk = MA::mask;

}  // namespace dma_cmar7

}  // namespace alloy::hal::st::stm32g0::dma1
