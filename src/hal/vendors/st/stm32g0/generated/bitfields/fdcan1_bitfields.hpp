/// Auto-generated bit field definitions for FDCAN1
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::fdcan1 {

using namespace alloy::hal::bitfields;

// ============================================================================
// FDCAN1 Bit Field Definitions
// ============================================================================

/// FDCAN_CREL - FDCAN core release register
namespace fdcan_crel {
    /// 18
    /// Position: 0, Width: 8
    /// Access: read-only
    using DAY = BitField<0, 8>;
    constexpr uint32_t DAY_Pos = 0;
    constexpr uint32_t DAY_Msk = DAY::mask;

    /// 12
    /// Position: 8, Width: 8
    /// Access: read-only
    using MON = BitField<8, 8>;
    constexpr uint32_t MON_Pos = 8;
    constexpr uint32_t MON_Msk = MON::mask;

    /// 4
    /// Position: 16, Width: 4
    /// Access: read-only
    using YEAR = BitField<16, 4>;
    constexpr uint32_t YEAR_Pos = 16;
    constexpr uint32_t YEAR_Msk = YEAR::mask;

    /// 1
    /// Position: 20, Width: 4
    /// Access: read-only
    using SUBSTEP = BitField<20, 4>;
    constexpr uint32_t SUBSTEP_Pos = 20;
    constexpr uint32_t SUBSTEP_Msk = SUBSTEP::mask;

    /// 2
    /// Position: 24, Width: 4
    /// Access: read-only
    using STEP = BitField<24, 4>;
    constexpr uint32_t STEP_Pos = 24;
    constexpr uint32_t STEP_Msk = STEP::mask;

    /// 3
    /// Position: 28, Width: 4
    /// Access: read-only
    using REL = BitField<28, 4>;
    constexpr uint32_t REL_Pos = 28;
    constexpr uint32_t REL_Msk = REL::mask;

}  // namespace fdcan_crel

/// FDCAN_ENDN - FDCAN endian register
namespace fdcan_endn {
    /// Endianness test value The endianness test value is 0x8765 4321.
    /// Position: 0, Width: 32
    /// Access: read-only
    using ETV = BitField<0, 32>;
    constexpr uint32_t ETV_Pos = 0;
    constexpr uint32_t ETV_Msk = ETV::mask;

}  // namespace fdcan_endn

/// FDCAN_DBTP - FDCAN data bit timing and prescaler register
namespace fdcan_dbtp {
    /// Synchronization jump width Must always be smaller than DTSEG2, valid values are 0 to 15. The value used by the hardware is the one programmed, incremented by 1: tSJW = (DSJW + 1) x tq.
    /// Position: 0, Width: 4
    /// Access: read-write
    using DSJW = BitField<0, 4>;
    constexpr uint32_t DSJW_Pos = 0;
    constexpr uint32_t DSJW_Msk = DSJW::mask;

    /// Data time segment after sample point Valid values are 0 to 15. The value used by the hardware is the one programmed, incremented by 1, i.e. tBS2 = (DTSEG2 + 1) x tq.
    /// Position: 4, Width: 4
    /// Access: read-write
    using DTSEG2 = BitField<4, 4>;
    constexpr uint32_t DTSEG2_Pos = 4;
    constexpr uint32_t DTSEG2_Msk = DTSEG2::mask;

    /// Data time segment before sample point Valid values are 0 to 31. The value used by the hardware is the one programmed, incremented by 1, i.e. tBS1 = (DTSEG1 + 1) x tq.
    /// Position: 8, Width: 5
    /// Access: read-write
    using DTSEG1 = BitField<8, 5>;
    constexpr uint32_t DTSEG1_Pos = 8;
    constexpr uint32_t DTSEG1_Msk = DTSEG1::mask;

    /// Data bit rate prescaler The value by which the oscillator frequency is divided to generate the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Baud Rate Prescaler are 0 to 31. The hardware interpreters this value as the value programmed plus 1.
    /// Position: 16, Width: 5
    /// Access: read-write
    using DBRP = BitField<16, 5>;
    constexpr uint32_t DBRP_Pos = 16;
    constexpr uint32_t DBRP_Msk = DBRP::mask;

    /// Transceiver delay compensation
    /// Position: 23, Width: 1
    /// Access: read-write
    using TDC = BitField<23, 1>;
    constexpr uint32_t TDC_Pos = 23;
    constexpr uint32_t TDC_Msk = TDC::mask;
    /// Enumerated values for TDC
    namespace tdc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_dbtp

/// FDCAN_TEST - FDCAN test register
namespace fdcan_test {
    /// Loop back mode
    /// Position: 4, Width: 1
    /// Access: read-write
    using LBCK = BitField<4, 1>;
    constexpr uint32_t LBCK_Pos = 4;
    constexpr uint32_t LBCK_Msk = LBCK::mask;
    /// Enumerated values for LBCK
    namespace lbck {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Control of transmit pin
    /// Position: 5, Width: 2
    /// Access: read-write
    using TX = BitField<5, 2>;
    constexpr uint32_t TX_Pos = 5;
    constexpr uint32_t TX_Msk = TX::mask;
    /// Enumerated values for TX
    namespace tx {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Receive pin Monitors the actual value of pin FDCANx_RX
    /// Position: 7, Width: 1
    /// Access: read-only
    using RX = BitField<7, 1>;
    constexpr uint32_t RX_Pos = 7;
    constexpr uint32_t RX_Msk = RX::mask;
    /// Enumerated values for RX
    namespace rx {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_test

/// FDCAN_RWD - FDCAN RAM watchdog register
namespace fdcan_rwd {
    /// Watchdog configuration Start value of the message RAM watchdog counter. With the reset value of 00, the counter is disabled. These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of FDCAN_CCCR register are set to 1.
    /// Position: 0, Width: 8
    /// Access: read-write
    using WDC = BitField<0, 8>;
    constexpr uint32_t WDC_Pos = 0;
    constexpr uint32_t WDC_Msk = WDC::mask;

    /// Watchdog value Actual message RAM watchdog counter value.
    /// Position: 8, Width: 8
    /// Access: read-only
    using WDV = BitField<8, 8>;
    constexpr uint32_t WDV_Pos = 8;
    constexpr uint32_t WDV_Msk = WDV::mask;

}  // namespace fdcan_rwd

/// FDCAN_CCCR - FDCAN CC control register
namespace fdcan_cccr {
    /// Initialization
    /// Position: 0, Width: 1
    /// Access: read-write
    using INIT = BitField<0, 1>;
    constexpr uint32_t INIT_Pos = 0;
    constexpr uint32_t INIT_Msk = INIT::mask;
    /// Enumerated values for INIT
    namespace init {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Configuration change enable
    /// Position: 1, Width: 1
    /// Access: read-write
    using CCE = BitField<1, 1>;
    constexpr uint32_t CCE_Pos = 1;
    constexpr uint32_t CCE_Msk = CCE::mask;
    /// Enumerated values for CCE
    namespace cce {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// ASM restricted operation mode The restricted operation mode is intended for applications that adapt themselves to different CAN bit rates. The application tests different bit rates and leaves the Restricted Operation Mode after it has received a valid frame. In the optional Restricted Operation Mode the node is able to transmit and receive data and remote frames and it gives acknowledge to valid frames, but it does not send active error frames or overload frames. In case of an error condition or overload condition, it does not send dominant bits, instead it waits for the occurrence of bus idle condition to resynchronize itself to the CAN communication. The error counters are not incremented. Bit ASM can only be set by software when both CCE and INIT are set to 1. The bit can be reset by the software at any time.
    /// Position: 2, Width: 1
    /// Access: read-write
    using ASM = BitField<2, 1>;
    constexpr uint32_t ASM_Pos = 2;
    constexpr uint32_t ASM_Msk = ASM::mask;
    /// Enumerated values for ASM
    namespace asm_ {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Clock stop acknowledge
    /// Position: 3, Width: 1
    /// Access: read-only
    using CSA = BitField<3, 1>;
    constexpr uint32_t CSA_Pos = 3;
    constexpr uint32_t CSA_Msk = CSA::mask;
    /// Enumerated values for CSA
    namespace csa {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Clock stop request
    /// Position: 4, Width: 1
    /// Access: read-write
    using CSR = BitField<4, 1>;
    constexpr uint32_t CSR_Pos = 4;
    constexpr uint32_t CSR_Msk = CSR::mask;
    /// Enumerated values for CSR
    namespace csr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Bus monitoring mode Bit MON can only be set by software when both CCE and INIT are set to 1. The bit can be reset by the Host at any time.
    /// Position: 5, Width: 1
    /// Access: read-write
    using MON = BitField<5, 1>;
    constexpr uint32_t MON_Pos = 5;
    constexpr uint32_t MON_Msk = MON::mask;
    /// Enumerated values for MON
    namespace mon {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Disable automatic retransmission
    /// Position: 6, Width: 1
    /// Access: read-write
    using DAR = BitField<6, 1>;
    constexpr uint32_t DAR_Pos = 6;
    constexpr uint32_t DAR_Msk = DAR::mask;
    /// Enumerated values for DAR
    namespace dar {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Test mode enable
    /// Position: 7, Width: 1
    /// Access: read-write
    using TEST = BitField<7, 1>;
    constexpr uint32_t TEST_Pos = 7;
    constexpr uint32_t TEST_Msk = TEST::mask;
    /// Enumerated values for TEST
    namespace test {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// FD operation enable
    /// Position: 8, Width: 1
    /// Access: read-write
    using FDOE = BitField<8, 1>;
    constexpr uint32_t FDOE_Pos = 8;
    constexpr uint32_t FDOE_Msk = FDOE::mask;
    /// Enumerated values for FDOE
    namespace fdoe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// FDCAN bit rate switching
    /// Position: 9, Width: 1
    /// Access: read-write
    using BRSE = BitField<9, 1>;
    constexpr uint32_t BRSE_Pos = 9;
    constexpr uint32_t BRSE_Msk = BRSE::mask;
    /// Enumerated values for BRSE
    namespace brse {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Protocol exception handling disable
    /// Position: 12, Width: 1
    /// Access: read-write
    using PXHD = BitField<12, 1>;
    constexpr uint32_t PXHD_Pos = 12;
    constexpr uint32_t PXHD_Msk = PXHD::mask;
    /// Enumerated values for PXHD
    namespace pxhd {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Edge filtering during bus integration
    /// Position: 13, Width: 1
    /// Access: read-write
    using EFBI = BitField<13, 1>;
    constexpr uint32_t EFBI_Pos = 13;
    constexpr uint32_t EFBI_Msk = EFBI::mask;
    /// Enumerated values for EFBI
    namespace efbi {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// If this bit is set, the FDCAN pauses for two CAN bit times before starting the next transmission after successfully transmitting a frame.
    /// Position: 14, Width: 1
    /// Access: read-write
    using TXP = BitField<14, 1>;
    constexpr uint32_t TXP_Pos = 14;
    constexpr uint32_t TXP_Msk = TXP::mask;
    /// Enumerated values for TXP
    namespace txp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Non ISO operation If this bit is set, the FDCAN uses the CAN FD frame format as specified by the Bosch CAN FD Specification V1.0.
    /// Position: 15, Width: 1
    /// Access: read-write
    using NISO = BitField<15, 1>;
    constexpr uint32_t NISO_Pos = 15;
    constexpr uint32_t NISO_Msk = NISO::mask;
    /// Enumerated values for NISO
    namespace niso {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_cccr

/// FDCAN_NBTP - FDCAN nominal bit timing and prescaler register
namespace fdcan_nbtp {
    /// Nominal time segment after sample point Valid values are 0 to 127. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.
    /// Position: 0, Width: 7
    /// Access: read-write
    using NTSEG2 = BitField<0, 7>;
    constexpr uint32_t NTSEG2_Pos = 0;
    constexpr uint32_t NTSEG2_Msk = NTSEG2::mask;

    /// Nominal time segment before sample point Valid values are 0 to 255. The actual interpretation by the hardware of this value is such that one more than the programmed value is used. These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 8, Width: 8
    /// Access: read-write
    using NTSEG1 = BitField<8, 8>;
    constexpr uint32_t NTSEG1_Pos = 8;
    constexpr uint32_t NTSEG1_Msk = NTSEG1::mask;

    /// Bit rate prescaler Value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values are 0 to 511. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used. These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 16, Width: 9
    /// Access: read-write
    using NBRP = BitField<16, 9>;
    constexpr uint32_t NBRP_Pos = 16;
    constexpr uint32_t NBRP_Msk = NBRP::mask;

    /// Nominal (re)synchronization jump width Valid values are 0 to 127. The actual interpretation by the hardware of this value is such that the used value is the one programmed incremented by one. These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 25, Width: 7
    /// Access: read-write
    using NSJW = BitField<25, 7>;
    constexpr uint32_t NSJW_Pos = 25;
    constexpr uint32_t NSJW_Msk = NSJW::mask;

}  // namespace fdcan_nbtp

/// FDCAN_TSCC - FDCAN timestamp counter configuration register
namespace fdcan_tscc {
    /// Timestamp select These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 0, Width: 2
    /// Access: read-write
    using TSS = BitField<0, 2>;
    constexpr uint32_t TSS_Pos = 0;
    constexpr uint32_t TSS_Msk = TSS::mask;
    /// Enumerated values for TSS
    namespace tss {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Timestamp counter prescaler Configures the timestamp and timeout counters time unit in multiples of CAN bit times [1 â¦ 16]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used. In CAN FD mode the internal timestamp counter TCP does not provide a constant time base due to the different CAN bit times between arbitration phase and data phase. Thus CAN FD requires an external counter for timestamp generation (TSS = 10). These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 16, Width: 4
    /// Access: read-write
    using TCP = BitField<16, 4>;
    constexpr uint32_t TCP_Pos = 16;
    constexpr uint32_t TCP_Msk = TCP::mask;

}  // namespace fdcan_tscc

/// FDCAN_TSCV - FDCAN timestamp counter value register
namespace fdcan_tscv {
    /// Timestamp counter The internal/external timestamp counter value is captured on start of frame (both Rx and Tx). When TSCC[TSS] = 01, the timestamp counter is incremented in multiples of CAN bit times [1 â¦ 16] depending on the configuration of TSCC[TCP]. A wrap around sets interrupt flag IR[TSW]. Write access resets the counter to 0. When TSCC.TSS = 10, TSC reflects the external timestamp counter value. A write access has no impact.
    /// Position: 0, Width: 16
    /// Access: read-write
    using TSC = BitField<0, 16>;
    constexpr uint32_t TSC_Pos = 0;
    constexpr uint32_t TSC_Msk = TSC::mask;

}  // namespace fdcan_tscv

/// FDCAN_TOCC - FDCAN timeout counter configuration register
namespace fdcan_tocc {
    /// Timeout counter enable This is a protected write (P) bit, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 0, Width: 1
    /// Access: read-write
    using ETOC = BitField<0, 1>;
    constexpr uint32_t ETOC_Pos = 0;
    constexpr uint32_t ETOC_Msk = ETOC::mask;
    /// Enumerated values for ETOC
    namespace etoc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Timeout select When operating in Continuous mode, a write to TOCV presets the counter to the value configured by TOCC[TOP] and continues down-counting. When the timeout counter is controlled by one of the FIFOs, an empty FIFO presets the counter to the value configured by TOCC[TOP]. Down-counting is started when the first FIFO element is stored. These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 1, Width: 2
    /// Access: read-write
    using TOS = BitField<1, 2>;
    constexpr uint32_t TOS_Pos = 1;
    constexpr uint32_t TOS_Msk = TOS::mask;
    /// Enumerated values for TOS
    namespace tos {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Timeout period Start value of the timeout counter (down-counter). Configures the timeout period.
    /// Position: 16, Width: 16
    /// Access: read-write
    using TOP = BitField<16, 16>;
    constexpr uint32_t TOP_Pos = 16;
    constexpr uint32_t TOP_Msk = TOP::mask;

}  // namespace fdcan_tocc

/// FDCAN_TOCV - FDCAN timeout counter value register
namespace fdcan_tocv {
    /// Timeout counter The timeout counter is decremented in multiples of CAN bit times [1 â¦ 16] depending on the configuration of TSCC.TCP. When decremented to 0, interrupt flag IR.TOO is set and the Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.
    /// Position: 0, Width: 16
    /// Access: read-write
    using TOC = BitField<0, 16>;
    constexpr uint32_t TOC_Pos = 0;
    constexpr uint32_t TOC_Msk = TOC::mask;

}  // namespace fdcan_tocv

/// FDCAN_ECR - FDCAN error counter register
namespace fdcan_ecr {
    /// Transmit error counter Actual state of the transmit error counter, values between 0 and 255. When CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented.
    /// Position: 0, Width: 8
    /// Access: read-only
    using TEC = BitField<0, 8>;
    constexpr uint32_t TEC_Pos = 0;
    constexpr uint32_t TEC_Msk = TEC::mask;

    /// Receive error counter Actual state of the receive error counter, values between 0 and 127.
    /// Position: 8, Width: 7
    /// Access: read-only
    using REC = BitField<8, 7>;
    constexpr uint32_t REC_Pos = 8;
    constexpr uint32_t REC_Msk = REC::mask;

    /// Receive error passive
    /// Position: 15, Width: 1
    /// Access: read-only
    using RP = BitField<15, 1>;
    constexpr uint32_t RP_Pos = 15;
    constexpr uint32_t RP_Msk = RP::mask;
    /// Enumerated values for RP
    namespace rp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CAN error logging The counter is incremented each time when a CAN protocol error causes the transmit error counter or the receive error counter to be incremented. It is reset by read access to CEL. The counter stops at 0xFF; the next increment of TEC or REC sets interrupt flag IR[ELO]. Access type is RX: reset on read.
    /// Position: 16, Width: 8
    /// Access: read-write
    using CEL = BitField<16, 8>;
    constexpr uint32_t CEL_Pos = 16;
    constexpr uint32_t CEL_Msk = CEL::mask;

}  // namespace fdcan_ecr

/// FDCAN_PSR - FDCAN protocol status register
namespace fdcan_psr {
    /// Last error code The LEC indicates the type of the last error to occur on the CAN bus. This field is cleared to 0 when a message has been transferred (reception or transmission) without error. Access type is RS: set on read.
    /// Position: 0, Width: 3
    /// Access: read-write
    using LEC = BitField<0, 3>;
    constexpr uint32_t LEC_Pos = 0;
    constexpr uint32_t LEC_Msk = LEC::mask;
    /// Enumerated values for LEC
    namespace lec {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Activity Monitors the moduleâs CAN communication state.
    /// Position: 3, Width: 2
    /// Access: read-only
    using ACT = BitField<3, 2>;
    constexpr uint32_t ACT_Pos = 3;
    constexpr uint32_t ACT_Msk = ACT::mask;
    /// Enumerated values for ACT
    namespace act {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Error passive
    /// Position: 5, Width: 1
    /// Access: read-only
    using EP = BitField<5, 1>;
    constexpr uint32_t EP_Pos = 5;
    constexpr uint32_t EP_Msk = EP::mask;
    /// Enumerated values for EP
    namespace ep {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Warning Sstatus
    /// Position: 6, Width: 1
    /// Access: read-only
    using EW = BitField<6, 1>;
    constexpr uint32_t EW_Pos = 6;
    constexpr uint32_t EW_Msk = EW::mask;
    /// Enumerated values for EW
    namespace ew {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Bus_Off status
    /// Position: 7, Width: 1
    /// Access: read-only
    using BO = BitField<7, 1>;
    constexpr uint32_t BO_Pos = 7;
    constexpr uint32_t BO_Msk = BO::mask;
    /// Enumerated values for BO
    namespace bo {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Data last error code Type of last error that occurred in the data phase of a FDCAN format frame with its BRS flag set. Coding is the same as for LEC. This field is cleared to 0 when a FDCAN format frame with its BRS flag set has been transferred (reception or transmission) without error. Access type is RS: set on read.
    /// Position: 8, Width: 3
    /// Access: read-write
    using DLEC = BitField<8, 3>;
    constexpr uint32_t DLEC_Pos = 8;
    constexpr uint32_t DLEC_Msk = DLEC::mask;

    /// ESI flag of last received FDCAN message This bit is set together with REDL, independent of acceptance filtering. Access type is RX: reset on read.
    /// Position: 11, Width: 1
    /// Access: read-write
    using RESI = BitField<11, 1>;
    constexpr uint32_t RESI_Pos = 11;
    constexpr uint32_t RESI_Msk = RESI::mask;
    /// Enumerated values for RESI
    namespace resi {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// BRS flag of last received FDCAN message This bit is set together with REDL, independent of acceptance filtering. Access type is RX: reset on read.
    /// Position: 12, Width: 1
    /// Access: read-write
    using RBRS = BitField<12, 1>;
    constexpr uint32_t RBRS_Pos = 12;
    constexpr uint32_t RBRS_Msk = RBRS::mask;
    /// Enumerated values for RBRS
    namespace rbrs {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Received FDCAN message This bit is set independent of acceptance filtering. Access type is RX: reset on read.
    /// Position: 13, Width: 1
    /// Access: read-write
    using REDL = BitField<13, 1>;
    constexpr uint32_t REDL_Pos = 13;
    constexpr uint32_t REDL_Msk = REDL::mask;
    /// Enumerated values for REDL
    namespace redl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Protocol exception event
    /// Position: 14, Width: 1
    /// Access: read-write
    using PXE = BitField<14, 1>;
    constexpr uint32_t PXE_Pos = 14;
    constexpr uint32_t PXE_Msk = PXE::mask;
    /// Enumerated values for PXE
    namespace pxe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmitter delay compensation value Position of the secondary sample point, defined by the sum of the measured delay from FDCAN_TX to FDCAN_RX and TDCR.TDCO. The SSP position is, in the data phase, the number of minimum time quanta (mtq) between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.
    /// Position: 16, Width: 7
    /// Access: read-only
    using TDCV = BitField<16, 7>;
    constexpr uint32_t TDCV_Pos = 16;
    constexpr uint32_t TDCV_Msk = TDCV::mask;

}  // namespace fdcan_psr

/// FDCAN_TDCR - FDCAN transmitter delay compensation register
namespace fdcan_tdcr {
    /// Transmitter delay compensation filter window length Defines the minimum value for the SSP position, dominant edges on FDCAN_RX that would result in an earlier SSP position are ignored for transmitter delay measurements. These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 0, Width: 7
    /// Access: read-write
    using TDCF = BitField<0, 7>;
    constexpr uint32_t TDCF_Pos = 0;
    constexpr uint32_t TDCF_Msk = TDCF::mask;

    /// Transmitter delay compensation offset Offset value defining the distance between the measured delay from FDCAN_TX to FDCAN_RX and the secondary sample point. Valid values are 0 to 127 mtq. These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 8, Width: 7
    /// Access: read-write
    using TDCO = BitField<8, 7>;
    constexpr uint32_t TDCO_Pos = 8;
    constexpr uint32_t TDCO_Msk = TDCO::mask;

}  // namespace fdcan_tdcr

/// FDCAN_IR - FDCAN interrupt register
namespace fdcan_ir {
    /// Rx FIFO 0 new message
    /// Position: 0, Width: 1
    /// Access: read-write
    using RF0N = BitField<0, 1>;
    constexpr uint32_t RF0N_Pos = 0;
    constexpr uint32_t RF0N_Msk = RF0N::mask;
    /// Enumerated values for RF0N
    namespace rf0n {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 0 full
    /// Position: 1, Width: 1
    /// Access: read-write
    using RF0F = BitField<1, 1>;
    constexpr uint32_t RF0F_Pos = 1;
    constexpr uint32_t RF0F_Msk = RF0F::mask;
    /// Enumerated values for RF0F
    namespace rf0f {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 0 message lost
    /// Position: 2, Width: 1
    /// Access: read-write
    using RF0L = BitField<2, 1>;
    constexpr uint32_t RF0L_Pos = 2;
    constexpr uint32_t RF0L_Msk = RF0L::mask;
    /// Enumerated values for RF0L
    namespace rf0l {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 1 new message
    /// Position: 3, Width: 1
    /// Access: read-write
    using RF1N = BitField<3, 1>;
    constexpr uint32_t RF1N_Pos = 3;
    constexpr uint32_t RF1N_Msk = RF1N::mask;
    /// Enumerated values for RF1N
    namespace rf1n {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 1 full
    /// Position: 4, Width: 1
    /// Access: read-write
    using RF1F = BitField<4, 1>;
    constexpr uint32_t RF1F_Pos = 4;
    constexpr uint32_t RF1F_Msk = RF1F::mask;
    /// Enumerated values for RF1F
    namespace rf1f {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 1 message lost
    /// Position: 5, Width: 1
    /// Access: read-write
    using RF1L = BitField<5, 1>;
    constexpr uint32_t RF1L_Pos = 5;
    constexpr uint32_t RF1L_Msk = RF1L::mask;
    /// Enumerated values for RF1L
    namespace rf1l {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// High-priority message
    /// Position: 6, Width: 1
    /// Access: read-write
    using HPM = BitField<6, 1>;
    constexpr uint32_t HPM_Pos = 6;
    constexpr uint32_t HPM_Msk = HPM::mask;
    /// Enumerated values for HPM
    namespace hpm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmission completed
    /// Position: 7, Width: 1
    /// Access: read-write
    using TC = BitField<7, 1>;
    constexpr uint32_t TC_Pos = 7;
    constexpr uint32_t TC_Msk = TC::mask;
    /// Enumerated values for TC
    namespace tc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmission cancellation finished
    /// Position: 8, Width: 1
    /// Access: read-write
    using TCF = BitField<8, 1>;
    constexpr uint32_t TCF_Pos = 8;
    constexpr uint32_t TCF_Msk = TCF::mask;
    /// Enumerated values for TCF
    namespace tcf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx FIFO empty
    /// Position: 9, Width: 1
    /// Access: read-write
    using TFE = BitField<9, 1>;
    constexpr uint32_t TFE_Pos = 9;
    constexpr uint32_t TFE_Msk = TFE::mask;
    /// Enumerated values for TFE
    namespace tfe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx event FIFO New Entry
    /// Position: 10, Width: 1
    /// Access: read-write
    using TEFN = BitField<10, 1>;
    constexpr uint32_t TEFN_Pos = 10;
    constexpr uint32_t TEFN_Msk = TEFN::mask;
    /// Enumerated values for TEFN
    namespace tefn {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx event FIFO full
    /// Position: 11, Width: 1
    /// Access: read-write
    using TEFF = BitField<11, 1>;
    constexpr uint32_t TEFF_Pos = 11;
    constexpr uint32_t TEFF_Msk = TEFF::mask;
    /// Enumerated values for TEFF
    namespace teff {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx event FIFO element lost
    /// Position: 12, Width: 1
    /// Access: read-write
    using TEFL = BitField<12, 1>;
    constexpr uint32_t TEFL_Pos = 12;
    constexpr uint32_t TEFL_Msk = TEFL::mask;
    /// Enumerated values for TEFL
    namespace tefl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Timestamp wraparound
    /// Position: 13, Width: 1
    /// Access: read-write
    using TSW = BitField<13, 1>;
    constexpr uint32_t TSW_Pos = 13;
    constexpr uint32_t TSW_Msk = TSW::mask;
    /// Enumerated values for TSW
    namespace tsw {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Message RAM access failure The flag is set when the Rx handler: has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx Handler starts processing of the following message. was unable to write a message to the message RAM. In this case message storage is aborted. In both cases the FIFO put index is not updated. The partly stored message is overwritten when the next message is stored to this location. The flag is also set when the Tx Handler was not able to read a message from the Message RAM in time. In this case message transmission is aborted. In case of a Tx Handler access failure the FDCAN is switched into Restricted Operation Mode (see mode). To leave Restricted Operation Mode, the Host CPU has to reset CCCR.ASM.
    /// Position: 14, Width: 1
    /// Access: read-write
    using MRAF = BitField<14, 1>;
    constexpr uint32_t MRAF_Pos = 14;
    constexpr uint32_t MRAF_Msk = MRAF::mask;
    /// Enumerated values for MRAF
    namespace mraf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Timeout occurred
    /// Position: 15, Width: 1
    /// Access: read-write
    using TOO = BitField<15, 1>;
    constexpr uint32_t TOO_Pos = 15;
    constexpr uint32_t TOO_Msk = TOO::mask;
    /// Enumerated values for TOO
    namespace too {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Error logging overflow
    /// Position: 16, Width: 1
    /// Access: read-write
    using ELO = BitField<16, 1>;
    constexpr uint32_t ELO_Pos = 16;
    constexpr uint32_t ELO_Msk = ELO::mask;
    /// Enumerated values for ELO
    namespace elo {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Error passive
    /// Position: 17, Width: 1
    /// Access: read-write
    using EP = BitField<17, 1>;
    constexpr uint32_t EP_Pos = 17;
    constexpr uint32_t EP_Msk = EP::mask;
    /// Enumerated values for EP
    namespace ep {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Warning status
    /// Position: 18, Width: 1
    /// Access: read-write
    using EW = BitField<18, 1>;
    constexpr uint32_t EW_Pos = 18;
    constexpr uint32_t EW_Msk = EW::mask;
    /// Enumerated values for EW
    namespace ew {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Bus_Off status
    /// Position: 19, Width: 1
    /// Access: read-write
    using BO = BitField<19, 1>;
    constexpr uint32_t BO_Pos = 19;
    constexpr uint32_t BO_Msk = BO::mask;
    /// Enumerated values for BO
    namespace bo {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Watchdog interrupt
    /// Position: 20, Width: 1
    /// Access: read-write
    using WDI = BitField<20, 1>;
    constexpr uint32_t WDI_Pos = 20;
    constexpr uint32_t WDI_Msk = WDI::mask;
    /// Enumerated values for WDI
    namespace wdi {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Protocol error in arbitration phase (nominal bit time is used)
    /// Position: 21, Width: 1
    /// Access: read-write
    using PEA = BitField<21, 1>;
    constexpr uint32_t PEA_Pos = 21;
    constexpr uint32_t PEA_Msk = PEA::mask;
    /// Enumerated values for PEA
    namespace pea {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Protocol error in data phase (data bit time is used)
    /// Position: 22, Width: 1
    /// Access: read-write
    using PED = BitField<22, 1>;
    constexpr uint32_t PED_Pos = 22;
    constexpr uint32_t PED_Msk = PED::mask;
    /// Enumerated values for PED
    namespace ped {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Access to reserved address
    /// Position: 23, Width: 1
    /// Access: read-write
    using ARA = BitField<23, 1>;
    constexpr uint32_t ARA_Pos = 23;
    constexpr uint32_t ARA_Msk = ARA::mask;
    /// Enumerated values for ARA
    namespace ara {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_ir

/// FDCAN_IE - FDCAN interrupt enable register
namespace fdcan_ie {
    /// Rx FIFO 0 new message interrupt enable
    /// Position: 0, Width: 1
    /// Access: read-write
    using RF0NE = BitField<0, 1>;
    constexpr uint32_t RF0NE_Pos = 0;
    constexpr uint32_t RF0NE_Msk = RF0NE::mask;
    /// Enumerated values for RF0NE
    namespace rf0ne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 0 full interrupt enable
    /// Position: 1, Width: 1
    /// Access: read-write
    using RF0FE = BitField<1, 1>;
    constexpr uint32_t RF0FE_Pos = 1;
    constexpr uint32_t RF0FE_Msk = RF0FE::mask;
    /// Enumerated values for RF0FE
    namespace rf0fe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 0 message lost interrupt enable
    /// Position: 2, Width: 1
    /// Access: read-write
    using RF0LE = BitField<2, 1>;
    constexpr uint32_t RF0LE_Pos = 2;
    constexpr uint32_t RF0LE_Msk = RF0LE::mask;
    /// Enumerated values for RF0LE
    namespace rf0le {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 1 new message interrupt enable
    /// Position: 3, Width: 1
    /// Access: read-write
    using RF1NE = BitField<3, 1>;
    constexpr uint32_t RF1NE_Pos = 3;
    constexpr uint32_t RF1NE_Msk = RF1NE::mask;
    /// Enumerated values for RF1NE
    namespace rf1ne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 1 full interrupt enable
    /// Position: 4, Width: 1
    /// Access: read-write
    using RF1FE = BitField<4, 1>;
    constexpr uint32_t RF1FE_Pos = 4;
    constexpr uint32_t RF1FE_Msk = RF1FE::mask;
    /// Enumerated values for RF1FE
    namespace rf1fe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 1 message lost interrupt enable
    /// Position: 5, Width: 1
    /// Access: read-write
    using RF1LE = BitField<5, 1>;
    constexpr uint32_t RF1LE_Pos = 5;
    constexpr uint32_t RF1LE_Msk = RF1LE::mask;
    /// Enumerated values for RF1LE
    namespace rf1le {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// High-priority message interrupt enable
    /// Position: 6, Width: 1
    /// Access: read-write
    using HPME = BitField<6, 1>;
    constexpr uint32_t HPME_Pos = 6;
    constexpr uint32_t HPME_Msk = HPME::mask;
    /// Enumerated values for HPME
    namespace hpme {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmission completed interrupt enable
    /// Position: 7, Width: 1
    /// Access: read-write
    using TCE = BitField<7, 1>;
    constexpr uint32_t TCE_Pos = 7;
    constexpr uint32_t TCE_Msk = TCE::mask;
    /// Enumerated values for TCE
    namespace tce {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmission cancellation finished interrupt enable
    /// Position: 8, Width: 1
    /// Access: read-write
    using TCFE = BitField<8, 1>;
    constexpr uint32_t TCFE_Pos = 8;
    constexpr uint32_t TCFE_Msk = TCFE::mask;
    /// Enumerated values for TCFE
    namespace tcfe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx FIFO empty interrupt enable
    /// Position: 9, Width: 1
    /// Access: read-write
    using TFEE = BitField<9, 1>;
    constexpr uint32_t TFEE_Pos = 9;
    constexpr uint32_t TFEE_Msk = TFEE::mask;
    /// Enumerated values for TFEE
    namespace tfee {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx event FIFO new entry interrupt enable
    /// Position: 10, Width: 1
    /// Access: read-write
    using TEFNE = BitField<10, 1>;
    constexpr uint32_t TEFNE_Pos = 10;
    constexpr uint32_t TEFNE_Msk = TEFNE::mask;
    /// Enumerated values for TEFNE
    namespace tefne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx event FIFO full interrupt enable
    /// Position: 11, Width: 1
    /// Access: read-write
    using TEFFE = BitField<11, 1>;
    constexpr uint32_t TEFFE_Pos = 11;
    constexpr uint32_t TEFFE_Msk = TEFFE::mask;
    /// Enumerated values for TEFFE
    namespace teffe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx event FIFO element lost interrupt enable
    /// Position: 12, Width: 1
    /// Access: read-write
    using TEFLE = BitField<12, 1>;
    constexpr uint32_t TEFLE_Pos = 12;
    constexpr uint32_t TEFLE_Msk = TEFLE::mask;
    /// Enumerated values for TEFLE
    namespace tefle {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Timestamp wraparound interrupt enable
    /// Position: 13, Width: 1
    /// Access: read-write
    using TSWE = BitField<13, 1>;
    constexpr uint32_t TSWE_Pos = 13;
    constexpr uint32_t TSWE_Msk = TSWE::mask;
    /// Enumerated values for TSWE
    namespace tswe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Message RAM access failure interrupt enable
    /// Position: 14, Width: 1
    /// Access: read-write
    using MRAFE = BitField<14, 1>;
    constexpr uint32_t MRAFE_Pos = 14;
    constexpr uint32_t MRAFE_Msk = MRAFE::mask;
    /// Enumerated values for MRAFE
    namespace mrafe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Timeout occurred interrupt enable
    /// Position: 15, Width: 1
    /// Access: read-write
    using TOOE = BitField<15, 1>;
    constexpr uint32_t TOOE_Pos = 15;
    constexpr uint32_t TOOE_Msk = TOOE::mask;
    /// Enumerated values for TOOE
    namespace tooe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Error logging overflow interrupt enable
    /// Position: 16, Width: 1
    /// Access: read-write
    using ELOE = BitField<16, 1>;
    constexpr uint32_t ELOE_Pos = 16;
    constexpr uint32_t ELOE_Msk = ELOE::mask;
    /// Enumerated values for ELOE
    namespace eloe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Error passive interrupt enable
    /// Position: 17, Width: 1
    /// Access: read-write
    using EPE = BitField<17, 1>;
    constexpr uint32_t EPE_Pos = 17;
    constexpr uint32_t EPE_Msk = EPE::mask;
    /// Enumerated values for EPE
    namespace epe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Warning status interrupt enable
    /// Position: 18, Width: 1
    /// Access: read-write
    using EWE = BitField<18, 1>;
    constexpr uint32_t EWE_Pos = 18;
    constexpr uint32_t EWE_Msk = EWE::mask;
    /// Enumerated values for EWE
    namespace ewe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Bus_Off status
    /// Position: 19, Width: 1
    /// Access: read-write
    using BOE = BitField<19, 1>;
    constexpr uint32_t BOE_Pos = 19;
    constexpr uint32_t BOE_Msk = BOE::mask;
    /// Enumerated values for BOE
    namespace boe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Watchdog interrupt enable
    /// Position: 20, Width: 1
    /// Access: read-write
    using WDIE = BitField<20, 1>;
    constexpr uint32_t WDIE_Pos = 20;
    constexpr uint32_t WDIE_Msk = WDIE::mask;
    /// Enumerated values for WDIE
    namespace wdie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Protocol error in arbitration phase enable
    /// Position: 21, Width: 1
    /// Access: read-write
    using PEAE = BitField<21, 1>;
    constexpr uint32_t PEAE_Pos = 21;
    constexpr uint32_t PEAE_Msk = PEAE::mask;

    /// Protocol error in data phase enable
    /// Position: 22, Width: 1
    /// Access: read-write
    using PEDE = BitField<22, 1>;
    constexpr uint32_t PEDE_Pos = 22;
    constexpr uint32_t PEDE_Msk = PEDE::mask;

    /// Access to reserved address enable
    /// Position: 23, Width: 1
    /// Access: read-write
    using ARAE = BitField<23, 1>;
    constexpr uint32_t ARAE_Pos = 23;
    constexpr uint32_t ARAE_Msk = ARAE::mask;

}  // namespace fdcan_ie

/// FDCAN_ILS - FDCAN interrupt line select register
namespace fdcan_ils {
    /// RX FIFO bit grouping the following interruption RF0LL: Rx FIFO 0 message lost interrupt line RF0FL: Rx FIFO 0 full interrupt line RF0NL: Rx FIFO 0 new message interrupt line
    /// Position: 0, Width: 1
    /// Access: read-write
    using RxFIFO0 = BitField<0, 1>;
    constexpr uint32_t RxFIFO0_Pos = 0;
    constexpr uint32_t RxFIFO0_Msk = RxFIFO0::mask;

    /// RX FIFO bit grouping the following interruption RF1LL: Rx FIFO 1 message lost interrupt line RF1FL: Rx FIFO 1 full Interrupt line RF1NL: Rx FIFO 1 new message interrupt line
    /// Position: 1, Width: 1
    /// Access: read-write
    using RxFIFO1 = BitField<1, 1>;
    constexpr uint32_t RxFIFO1_Pos = 1;
    constexpr uint32_t RxFIFO1_Msk = RxFIFO1::mask;

    /// Status message bit grouping the following interruption TCFL: Transmission cancellation finished interrupt line TCL: Transmission completed interrupt line HPML: High-priority message interrupt line
    /// Position: 2, Width: 1
    /// Access: read-write
    using SMSG = BitField<2, 1>;
    constexpr uint32_t SMSG_Pos = 2;
    constexpr uint32_t SMSG_Msk = SMSG::mask;

    /// Tx FIFO ERROR grouping the following interruption TEFLL: Tx event FIFO element lost interrupt line TEFFL: Tx event FIFO full interrupt line TEFNL: Tx event FIFO new entry interrupt line TFEL: Tx FIFO empty interrupt line
    /// Position: 3, Width: 1
    /// Access: read-write
    using TFERR = BitField<3, 1>;
    constexpr uint32_t TFERR_Pos = 3;
    constexpr uint32_t TFERR_Msk = TFERR::mask;

    /// Interrupt regrouping the following interruption TOOL: Timeout occurred interrupt line MRAFL: Message RAM access failure interrupt line TSWL: Timestamp wraparound interrupt line
    /// Position: 4, Width: 1
    /// Access: read-write
    using MISC = BitField<4, 1>;
    constexpr uint32_t MISC_Pos = 4;
    constexpr uint32_t MISC_Msk = MISC::mask;

    /// BERR
    /// Position: 5, Width: 1
    /// Access: read-write
    using BERR = BitField<5, 1>;
    constexpr uint32_t BERR_Pos = 5;
    constexpr uint32_t BERR_Msk = BERR::mask;

    /// Protocol error grouping the following interruption ARAL: Access to reserved address line PEDL: Protocol error in data phase line PEAL: Protocol error in arbitration phase line WDIL: Watchdog interrupt line BOL: Bus_Off status EWL: Warning status interrupt line
    /// Position: 6, Width: 1
    /// Access: read-write
    using PERR = BitField<6, 1>;
    constexpr uint32_t PERR_Pos = 6;
    constexpr uint32_t PERR_Msk = PERR::mask;

}  // namespace fdcan_ils

/// FDCAN_ILE - FDCAN interrupt line enable register
namespace fdcan_ile {
    /// Enable interrupt line 0
    /// Position: 0, Width: 1
    /// Access: read-write
    using EINT0 = BitField<0, 1>;
    constexpr uint32_t EINT0_Pos = 0;
    constexpr uint32_t EINT0_Msk = EINT0::mask;
    /// Enumerated values for EINT0
    namespace eint0 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Enable interrupt line 1
    /// Position: 1, Width: 1
    /// Access: read-write
    using EINT1 = BitField<1, 1>;
    constexpr uint32_t EINT1_Pos = 1;
    constexpr uint32_t EINT1_Msk = EINT1::mask;
    /// Enumerated values for EINT1
    namespace eint1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_ile

/// FDCAN_RXGFC - FDCAN global filter configuration register
namespace fdcan_rxgfc {
    /// Reject remote frames extended These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 0, Width: 1
    /// Access: read-write
    using RRFE = BitField<0, 1>;
    constexpr uint32_t RRFE_Pos = 0;
    constexpr uint32_t RRFE_Msk = RRFE::mask;
    /// Enumerated values for RRFE
    namespace rrfe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Reject remote frames standard These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 1, Width: 1
    /// Access: read-write
    using RRFS = BitField<1, 1>;
    constexpr uint32_t RRFS_Pos = 1;
    constexpr uint32_t RRFS_Msk = RRFS::mask;
    /// Enumerated values for RRFS
    namespace rrfs {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Accept non-matching frames extended Defines how received messages with 29-bit IDs that do not match any element of the filter list are treated. These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 2, Width: 2
    /// Access: read-write
    using ANFE = BitField<2, 2>;
    constexpr uint32_t ANFE_Pos = 2;
    constexpr uint32_t ANFE_Msk = ANFE::mask;
    /// Enumerated values for ANFE
    namespace anfe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Accept Non-matching frames standard Defines how received messages with 11-bit IDs that do not match any element of the filter list are treated. These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 4, Width: 2
    /// Access: read-write
    using ANFS = BitField<4, 2>;
    constexpr uint32_t ANFS_Pos = 4;
    constexpr uint32_t ANFS_Msk = ANFS::mask;
    /// Enumerated values for ANFS
    namespace anfs {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// FIFO 1 operation mode (overwrite or blocking) This is a protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 8, Width: 1
    /// Access: read-write
    using F1OM = BitField<8, 1>;
    constexpr uint32_t F1OM_Pos = 8;
    constexpr uint32_t F1OM_Msk = F1OM::mask;

    /// FIFO 0 operation mode (overwrite or blocking) This is protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 9, Width: 1
    /// Access: read-write
    using F0OM = BitField<9, 1>;
    constexpr uint32_t F0OM_Pos = 9;
    constexpr uint32_t F0OM_Msk = F0OM::mask;

    /// List size standard >28: Values greater than 28 are interpreted as 28. These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 16, Width: 5
    /// Access: read-write
    using LSS = BitField<16, 5>;
    constexpr uint32_t LSS_Pos = 16;
    constexpr uint32_t LSS_Msk = LSS::mask;
    /// Enumerated values for LSS
    namespace lss {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0xa = 10;
        constexpr uint32_t B_0xb = 11;
        constexpr uint32_t B_0xc = 12;
        constexpr uint32_t B_0xd = 13;
        constexpr uint32_t B_0xe = 14;
        constexpr uint32_t B_0xf = 15;
        constexpr uint32_t B_0x10 = 16;
        constexpr uint32_t B_0x11 = 17;
        constexpr uint32_t B_0x12 = 18;
        constexpr uint32_t B_0x13 = 19;
        constexpr uint32_t B_0x14 = 20;
        constexpr uint32_t B_0x15 = 21;
        constexpr uint32_t B_0x16 = 22;
        constexpr uint32_t B_0x17 = 23;
        constexpr uint32_t B_0x18 = 24;
        constexpr uint32_t B_0x19 = 25;
        constexpr uint32_t B_0x1a = 26;
        constexpr uint32_t B_0x1b = 27;
        constexpr uint32_t B_0x1c = 28;
    }

    /// List size extended >8: Values greater than 8 are interpreted as 8. These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 24, Width: 4
    /// Access: read-write
    using LSE = BitField<24, 4>;
    constexpr uint32_t LSE_Pos = 24;
    constexpr uint32_t LSE_Msk = LSE::mask;
    /// Enumerated values for LSE
    namespace lse {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
    }

}  // namespace fdcan_rxgfc

/// FDCAN_XIDAM - FDCAN extended ID and mask register
namespace fdcan_xidam {
    /// Extended ID mask For acceptance filtering of extended frames the Extended ID AND Mask is AND-ed with the Message ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all bits set to 1 the mask is not active. These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 0, Width: 29
    /// Access: read-write
    using EIDM = BitField<0, 29>;
    constexpr uint32_t EIDM_Pos = 0;
    constexpr uint32_t EIDM_Msk = EIDM::mask;

}  // namespace fdcan_xidam

/// FDCAN_HPMS - FDCAN high-priority message status register
namespace fdcan_hpms {
    /// Buffer index Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = 1.
    /// Position: 0, Width: 3
    /// Access: read-only
    using BIDX = BitField<0, 3>;
    constexpr uint32_t BIDX_Pos = 0;
    constexpr uint32_t BIDX_Msk = BIDX::mask;

    /// Message storage indicator
    /// Position: 6, Width: 2
    /// Access: read-only
    using MSI = BitField<6, 2>;
    constexpr uint32_t MSI_Pos = 6;
    constexpr uint32_t MSI_Msk = MSI::mask;
    /// Enumerated values for MSI
    namespace msi {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Filter index Index of matching filter element. Range is 0 to RXGFC[LSS] - 1 or RXGFC[LSE] - 1.
    /// Position: 8, Width: 5
    /// Access: read-only
    using FIDX = BitField<8, 5>;
    constexpr uint32_t FIDX_Pos = 8;
    constexpr uint32_t FIDX_Msk = FIDX::mask;

    /// Filter list Indicates the filter list of the matching filter element.
    /// Position: 15, Width: 1
    /// Access: read-only
    using FLST = BitField<15, 1>;
    constexpr uint32_t FLST_Pos = 15;
    constexpr uint32_t FLST_Msk = FLST::mask;
    /// Enumerated values for FLST
    namespace flst {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_hpms

/// FDCAN_RXF0S - FDCAN Rx FIFO 0 status register
namespace fdcan_rxf0s {
    /// Rx FIFO 0 fill level Number of elements stored in Rx FIFO 0, range 0 to 3.
    /// Position: 0, Width: 4
    /// Access: read-only
    using F0FL = BitField<0, 4>;
    constexpr uint32_t F0FL_Pos = 0;
    constexpr uint32_t F0FL_Msk = F0FL::mask;

    /// Rx FIFO 0 get index Rx FIFO 0 read index pointer, range 0 to 2.
    /// Position: 8, Width: 2
    /// Access: read-only
    using F0GI = BitField<8, 2>;
    constexpr uint32_t F0GI_Pos = 8;
    constexpr uint32_t F0GI_Msk = F0GI::mask;

    /// Rx FIFO 0 put index Rx FIFO 0 write index pointer, range 0 to 2.
    /// Position: 16, Width: 2
    /// Access: read-only
    using F0PI = BitField<16, 2>;
    constexpr uint32_t F0PI_Pos = 16;
    constexpr uint32_t F0PI_Msk = F0PI::mask;

    /// Rx FIFO 0 full
    /// Position: 24, Width: 1
    /// Access: read-only
    using F0F = BitField<24, 1>;
    constexpr uint32_t F0F_Pos = 24;
    constexpr uint32_t F0F_Msk = F0F::mask;
    /// Enumerated values for F0F
    namespace f0f {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 0 message lost This bit is a copy of interrupt flag IR[RF0L]. When IR[RF0L] is reset, this bit is also reset.
    /// Position: 25, Width: 1
    /// Access: read-only
    using RF0L = BitField<25, 1>;
    constexpr uint32_t RF0L_Pos = 25;
    constexpr uint32_t RF0L_Msk = RF0L::mask;
    /// Enumerated values for RF0L
    namespace rf0l {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_rxf0s

/// FDCAN_RXF0A - CAN Rx FIFO 0 acknowledge register
namespace fdcan_rxf0a {
    /// Rx FIFO 0 acknowledge index After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the buffer index of the last element read from Rx FIFO 0 to F0AI. This sets the Rx FIFOÂ 0 get index RXF0S[F0GI] to F0AI + 1 and update the FIFO 0 fill level RXF0S[F0FL].
    /// Position: 0, Width: 3
    /// Access: read-write
    using F0AI = BitField<0, 3>;
    constexpr uint32_t F0AI_Pos = 0;
    constexpr uint32_t F0AI_Msk = F0AI::mask;

}  // namespace fdcan_rxf0a

/// FDCAN_RXF1S - FDCAN Rx FIFO 1 status register
namespace fdcan_rxf1s {
    /// Rx FIFO 1 fill level Number of elements stored in Rx FIFO 1, range 0 to 3.
    /// Position: 0, Width: 4
    /// Access: read-only
    using F1FL = BitField<0, 4>;
    constexpr uint32_t F1FL_Pos = 0;
    constexpr uint32_t F1FL_Msk = F1FL::mask;

    /// Rx FIFO 1 get index Rx FIFO 1 read index pointer, range 0 to 2.
    /// Position: 8, Width: 2
    /// Access: read-only
    using F1GI = BitField<8, 2>;
    constexpr uint32_t F1GI_Pos = 8;
    constexpr uint32_t F1GI_Msk = F1GI::mask;

    /// Rx FIFO 1 put index Rx FIFO 1 write index pointer, range 0 to 2.
    /// Position: 16, Width: 2
    /// Access: read-only
    using F1PI = BitField<16, 2>;
    constexpr uint32_t F1PI_Pos = 16;
    constexpr uint32_t F1PI_Msk = F1PI::mask;

    /// Rx FIFO 1 full
    /// Position: 24, Width: 1
    /// Access: read-only
    using F1F = BitField<24, 1>;
    constexpr uint32_t F1F_Pos = 24;
    constexpr uint32_t F1F_Msk = F1F::mask;
    /// Enumerated values for F1F
    namespace f1f {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx FIFO 1 message lost This bit is a copy of interrupt flag IR[RF1L]. When IR[RF1L] is reset, this bit is also reset.
    /// Position: 25, Width: 1
    /// Access: read-only
    using RF1L = BitField<25, 1>;
    constexpr uint32_t RF1L_Pos = 25;
    constexpr uint32_t RF1L_Msk = RF1L::mask;
    /// Enumerated values for RF1L
    namespace rf1l {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_rxf1s

/// FDCAN_RXF1A - FDCAN Rx FIFO 1 acknowledge register
namespace fdcan_rxf1a {
    /// Rx FIFO 1 acknowledge index After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the buffer index of the last element read from Rx FIFO 1 to F1AI. This sets the Rx FIFOÂ 1 get index RXF1S[F1GI] to F1AI + 1 and update the FIFO 1 Fill Level RXF1S[F1FL].
    /// Position: 0, Width: 3
    /// Access: read-write
    using F1AI = BitField<0, 3>;
    constexpr uint32_t F1AI_Pos = 0;
    constexpr uint32_t F1AI_Msk = F1AI::mask;

}  // namespace fdcan_rxf1a

/// FDCAN_TXBC - FDCAN Tx buffer configuration register
namespace fdcan_txbc {
    /// Tx FIFO/queue mode This is a protected write (P) bit, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 24, Width: 1
    /// Access: read-write
    using TFQM = BitField<24, 1>;
    constexpr uint32_t TFQM_Pos = 24;
    constexpr uint32_t TFQM_Msk = TFQM::mask;
    /// Enumerated values for TFQM
    namespace tfqm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txbc

/// FDCAN_TXFQS - FDCAN Tx FIFO/queue status register
namespace fdcan_txfqs {
    /// Tx FIFO free level Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 3. Read as 0 when Tx queue operation is configured (TXBC[TFQM] = 1).
    /// Position: 0, Width: 3
    /// Access: read-only
    using TFFL = BitField<0, 3>;
    constexpr uint32_t TFFL_Pos = 0;
    constexpr uint32_t TFFL_Msk = TFFL::mask;

    /// Tx FIFO get index Tx FIFO read index pointer, range 0 to 3. Read as 0 when Tx queue operation is configured (TXBC.TFQM = 1)
    /// Position: 8, Width: 2
    /// Access: read-only
    using TFGI = BitField<8, 2>;
    constexpr uint32_t TFGI_Pos = 8;
    constexpr uint32_t TFGI_Msk = TFGI::mask;

    /// Tx FIFO/queue put index Tx FIFO/queue write index pointer, range 0 to 3
    /// Position: 16, Width: 2
    /// Access: read-only
    using TFQPI = BitField<16, 2>;
    constexpr uint32_t TFQPI_Pos = 16;
    constexpr uint32_t TFQPI_Msk = TFQPI::mask;

    /// Tx FIFO/queue full
    /// Position: 21, Width: 1
    /// Access: read-only
    using TFQF = BitField<21, 1>;
    constexpr uint32_t TFQF_Pos = 21;
    constexpr uint32_t TFQF_Msk = TFQF::mask;
    /// Enumerated values for TFQF
    namespace tfqf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txfqs

/// FDCAN_TXBRP - FDCAN Tx buffer request pending register
namespace fdcan_txbrp {
    /// Transmission request pending Each Tx Buffer has its own transmission request pending bit. The bits are set via register TXBAR. The bits are reset after a requested transmission has completed or has been canceled via register TXBCR. After a TXBRP bit has been set, a Tx scan is started to check for the pending Tx request with the highest priority (Tx Buffer with lowest Message ID). A cancellation request resets the corresponding transmission request pending bit of register TXBRP. In case a transmission has already been started when a cancellation is requested, this is done at the end of the transmission, regardless whether the transmission was successful or not. The cancellation request bits are reset directly after the corresponding TXBRP bit has been reset. After a cancellation has been requested, a finished cancellation is signaled via TXBCF after successful transmission together with the corresponding TXBTO bit when the transmission has not yet been started at the point of cancellation when the transmission has been aborted due to lost arbitration when an error occurred during frame transmission In DAR mode all transmissions are automatically canceled if they are not successful. The corresponding TXBCF bit is set for all unsuccessful transmissions.
    /// Position: 0, Width: 3
    /// Access: read-only
    using TRP = BitField<0, 3>;
    constexpr uint32_t TRP_Pos = 0;
    constexpr uint32_t TRP_Msk = TRP::mask;
    /// Enumerated values for TRP
    namespace trp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txbrp

/// FDCAN_TXBAR - FDCAN Tx buffer add request register
namespace fdcan_txbar {
    /// Add request Each Tx buffer has its own add request bit. Writing a 1 sets the corresponding add request bit; writing a 0 has no impact. This enables the Host to set transmission requests for multiple Tx buffers with one write to TXBAR. When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan process has completed.
    /// Position: 0, Width: 3
    /// Access: read-write
    using AR = BitField<0, 3>;
    constexpr uint32_t AR_Pos = 0;
    constexpr uint32_t AR_Msk = AR::mask;
    /// Enumerated values for AR
    namespace ar {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txbar

/// FDCAN_TXBCR - FDCAN Tx buffer cancellation request register
namespace fdcan_txbcr {
    /// Cancellation request Each Tx buffer has its own cancellation request bit. Writing a 1 sets the corresponding CR bit; writing a 0 has no impact. This enables the Host to set cancellation requests for multiple Tx buffers with one write to TXBCR. The bits remain set until the corresponding TXBRP bit is reset.
    /// Position: 0, Width: 3
    /// Access: read-write
    using CR = BitField<0, 3>;
    constexpr uint32_t CR_Pos = 0;
    constexpr uint32_t CR_Msk = CR::mask;
    /// Enumerated values for CR
    namespace cr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txbcr

/// FDCAN_TXBTO - FDCAN Tx buffer transmission occurred register
namespace fdcan_txbto {
    /// Transmission occurred. Each Tx buffer has its own TO bit. The bits are set when the corresponding TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR.
    /// Position: 0, Width: 3
    /// Access: read-only
    using TO = BitField<0, 3>;
    constexpr uint32_t TO_Pos = 0;
    constexpr uint32_t TO_Msk = TO::mask;
    /// Enumerated values for TO
    namespace to {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txbto

/// FDCAN_TXBCF - FDCAN Tx buffer cancellation finished register
namespace fdcan_txbcf {
    /// Cancellation finished Each Tx buffer has its own CF bit. The bits are set when the corresponding TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR.
    /// Position: 0, Width: 3
    /// Access: read-only
    using CF = BitField<0, 3>;
    constexpr uint32_t CF_Pos = 0;
    constexpr uint32_t CF_Msk = CF::mask;
    /// Enumerated values for CF
    namespace cf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txbcf

/// FDCAN_TXBTIE - FDCAN Tx buffer transmission interrupt enable register
namespace fdcan_txbtie {
    /// Transmission interrupt enable Each Tx buffer has its own TIE bit.
    /// Position: 0, Width: 3
    /// Access: read-write
    using TIE = BitField<0, 3>;
    constexpr uint32_t TIE_Pos = 0;
    constexpr uint32_t TIE_Msk = TIE::mask;
    /// Enumerated values for TIE
    namespace tie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txbtie

/// FDCAN_TXBCIE - FDCAN Tx buffer cancellation finished interrupt enable register
namespace fdcan_txbcie {
    /// Cancellation finished interrupt enable. Each Tx buffer has its own CFIE bit.
    /// Position: 0, Width: 3
    /// Access: read-write
    using CFIE = BitField<0, 3>;
    constexpr uint32_t CFIE_Pos = 0;
    constexpr uint32_t CFIE_Msk = CFIE::mask;
    /// Enumerated values for CFIE
    namespace cfie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace fdcan_txbcie

/// FDCAN_TXEFS - FDCAN Tx event FIFO status register
namespace fdcan_txefs {
    /// Event FIFO fill level Number of elements stored in Tx event FIFO, range 0 to 3.
    /// Position: 0, Width: 3
    /// Access: read-only
    using EFFL = BitField<0, 3>;
    constexpr uint32_t EFFL_Pos = 0;
    constexpr uint32_t EFFL_Msk = EFFL::mask;

    /// Event FIFO get index Tx Event FIFO read index pointer, range 0 to 3.
    /// Position: 8, Width: 2
    /// Access: read-only
    using EFGI = BitField<8, 2>;
    constexpr uint32_t EFGI_Pos = 8;
    constexpr uint32_t EFGI_Msk = EFGI::mask;

    /// Event FIFO put index Tx Event FIFO write index pointer, range 0 to 3.
    /// Position: 16, Width: 2
    /// Access: read-only
    using EFPI = BitField<16, 2>;
    constexpr uint32_t EFPI_Pos = 16;
    constexpr uint32_t EFPI_Msk = EFPI::mask;

    /// Event FIFO full
    /// Position: 24, Width: 1
    /// Access: read-only
    using EFF = BitField<24, 1>;
    constexpr uint32_t EFF_Pos = 24;
    constexpr uint32_t EFF_Msk = EFF::mask;
    /// Enumerated values for EFF
    namespace eff {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx Event FIFO element lost This bit is a copy of interrupt flag IR[TEFL]. When IR[TEFL] is reset, this bit is also reset. 0 No Tx event FIFO element lost 1 Tx event FIFO element lost, also set after write attempt to Tx Event FIFO of size 0.
    /// Position: 25, Width: 1
    /// Access: read-only
    using TEFL = BitField<25, 1>;
    constexpr uint32_t TEFL_Pos = 25;
    constexpr uint32_t TEFL_Msk = TEFL::mask;

}  // namespace fdcan_txefs

/// FDCAN_TXEFA - FDCAN Tx event FIFO acknowledge register
namespace fdcan_txefa {
    /// Event FIFO acknowledge index After the Host has read an element or a sequence of elements from the Tx event FIFO, it has to write the index of the last element read from Tx event FIFO to EFAI. This sets the Tx event FIFO get index TXEFS[EFGI] to EFAI + 1 and updates the FIFO 0 fill level TXEFS[EFFL].
    /// Position: 0, Width: 2
    /// Access: read-write
    using EFAI = BitField<0, 2>;
    constexpr uint32_t EFAI_Pos = 0;
    constexpr uint32_t EFAI_Msk = EFAI::mask;

}  // namespace fdcan_txefa

/// FDCAN_CKDIV - FDCAN CFG clock divider register
namespace fdcan_ckdiv {
    /// input clock divider The APB clock could be divided prior to be used by the CAN sub system. The rate must be computed using the divider output clock. These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.
    /// Position: 0, Width: 4
    /// Access: read-write
    using PDIV = BitField<0, 4>;
    constexpr uint32_t PDIV_Pos = 0;
    constexpr uint32_t PDIV_Msk = PDIV::mask;
    /// Enumerated values for PDIV
    namespace pdiv {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0xA = 10;
        constexpr uint32_t B_0xB = 11;
        constexpr uint32_t B_0xC = 12;
        constexpr uint32_t B_0xD = 13;
        constexpr uint32_t B_0xE = 14;
        constexpr uint32_t B_0xF = 15;
    }

}  // namespace fdcan_ckdiv

}  // namespace alloy::hal::st::stm32g0::fdcan1
