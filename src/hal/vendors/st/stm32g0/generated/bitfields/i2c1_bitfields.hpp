/// Auto-generated bit field definitions for I2C1
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::i2c1 {

using namespace alloy::hal::bitfields;

// ============================================================================
// I2C1 Bit Field Definitions
// ============================================================================

/// I2C_CR1 - Control register 1
namespace i2c_cr1 {
    /// Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    /// Position: 0, Width: 1
    /// Access: read-write
    using PE = BitField<0, 1>;
    constexpr uint32_t PE_Pos = 0;
    constexpr uint32_t PE_Msk = PE::mask;
    /// Enumerated values for PE
    namespace pe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TX Interrupt enable
    /// Position: 1, Width: 1
    /// Access: read-write
    using TXIE = BitField<1, 1>;
    constexpr uint32_t TXIE_Pos = 1;
    constexpr uint32_t TXIE_Msk = TXIE::mask;
    /// Enumerated values for TXIE
    namespace txie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RX Interrupt enable
    /// Position: 2, Width: 1
    /// Access: read-write
    using RXIE = BitField<2, 1>;
    constexpr uint32_t RXIE_Pos = 2;
    constexpr uint32_t RXIE_Msk = RXIE::mask;
    /// Enumerated values for RXIE
    namespace rxie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Address match Interrupt enable (slave only)
    /// Position: 3, Width: 1
    /// Access: read-write
    using ADDRIE = BitField<3, 1>;
    constexpr uint32_t ADDRIE_Pos = 3;
    constexpr uint32_t ADDRIE_Msk = ADDRIE::mask;
    /// Enumerated values for ADDRIE
    namespace addrie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Not acknowledge received Interrupt enable
    /// Position: 4, Width: 1
    /// Access: read-write
    using NACKIE = BitField<4, 1>;
    constexpr uint32_t NACKIE_Pos = 4;
    constexpr uint32_t NACKIE_Msk = NACKIE::mask;
    /// Enumerated values for NACKIE
    namespace nackie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Stop detection Interrupt enable
    /// Position: 5, Width: 1
    /// Access: read-write
    using STOPIE = BitField<5, 1>;
    constexpr uint32_t STOPIE_Pos = 5;
    constexpr uint32_t STOPIE_Msk = STOPIE::mask;
    /// Enumerated values for STOPIE
    namespace stopie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transfer Complete interrupt enable Note: Any of these events generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    /// Position: 6, Width: 1
    /// Access: read-write
    using TCIE = BitField<6, 1>;
    constexpr uint32_t TCIE_Pos = 6;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    /// Position: 7, Width: 1
    /// Access: read-write
    using ERRIE = BitField<7, 1>;
    constexpr uint32_t ERRIE_Pos = 7;
    constexpr uint32_t ERRIE_Msk = ERRIE::mask;
    /// Enumerated values for ERRIE
    namespace errie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
    /// Position: 8, Width: 4
    /// Access: read-write
    using DNF = BitField<8, 4>;
    constexpr uint32_t DNF_Pos = 8;
    constexpr uint32_t DNF_Msk = DNF::mask;
    /// Enumerated values for DNF
    namespace dnf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0xF = 15;
    }

    /// Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    /// Position: 12, Width: 1
    /// Access: read-write
    using ANFOFF = BitField<12, 1>;
    constexpr uint32_t ANFOFF_Pos = 12;
    constexpr uint32_t ANFOFF_Msk = ANFOFF::mask;
    /// Enumerated values for ANFOFF
    namespace anfoff {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// DMA transmission requests enable
    /// Position: 14, Width: 1
    /// Access: read-write
    using TXDMAEN = BitField<14, 1>;
    constexpr uint32_t TXDMAEN_Pos = 14;
    constexpr uint32_t TXDMAEN_Msk = TXDMAEN::mask;
    /// Enumerated values for TXDMAEN
    namespace txdmaen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// DMA reception requests enable
    /// Position: 15, Width: 1
    /// Access: read-write
    using RXDMAEN = BitField<15, 1>;
    constexpr uint32_t RXDMAEN_Pos = 15;
    constexpr uint32_t RXDMAEN_Msk = RXDMAEN::mask;
    /// Enumerated values for RXDMAEN
    namespace rxdmaen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Slave byte control This bit is used to enable hardware byte control in slave mode.
    /// Position: 16, Width: 1
    /// Access: read-write
    using SBC = BitField<16, 1>;
    constexpr uint32_t SBC_Pos = 16;
    constexpr uint32_t SBC_Msk = SBC::mask;
    /// Enumerated values for SBC
    namespace sbc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    /// Position: 17, Width: 1
    /// Access: read-write
    using NOSTRETCH = BitField<17, 1>;
    constexpr uint32_t NOSTRETCH_Pos = 17;
    constexpr uint32_t NOSTRETCH_Msk = NOSTRETCH::mask;
    /// Enumerated values for NOSTRETCH
    namespace nostretch {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to . Note: WUPEN can be set only when DNF = '0000â
    /// Position: 18, Width: 1
    /// Access: read-write
    using WUPEN = BitField<18, 1>;
    constexpr uint32_t WUPEN_Pos = 18;
    constexpr uint32_t WUPEN_Msk = WUPEN::mask;
    /// Enumerated values for WUPEN
    namespace wupen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// General call enable
    /// Position: 19, Width: 1
    /// Access: read-write
    using GCEN = BitField<19, 1>;
    constexpr uint32_t GCEN_Pos = 19;
    constexpr uint32_t GCEN_Msk = GCEN::mask;
    /// Enumerated values for GCEN
    namespace gcen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// SMBus Host Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    /// Position: 20, Width: 1
    /// Access: read-write
    using SMBHEN = BitField<20, 1>;
    constexpr uint32_t SMBHEN_Pos = 20;
    constexpr uint32_t SMBHEN_Msk = SMBHEN::mask;
    /// Enumerated values for SMBHEN
    namespace smbhen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// SMBus Device Default Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    /// Position: 21, Width: 1
    /// Access: read-write
    using SMBDEN = BitField<21, 1>;
    constexpr uint32_t SMBDEN_Pos = 21;
    constexpr uint32_t SMBDEN_Msk = SMBDEN::mask;
    /// Enumerated values for SMBDEN
    namespace smbden {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// SMBus alert enable Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    /// Position: 22, Width: 1
    /// Access: read-write
    using ALERTEN = BitField<22, 1>;
    constexpr uint32_t ALERTEN_Pos = 22;
    constexpr uint32_t ALERTEN_Msk = ALERTEN::mask;
    /// Enumerated values for ALERTEN
    namespace alerten {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    /// Position: 23, Width: 1
    /// Access: read-write
    using PECEN = BitField<23, 1>;
    constexpr uint32_t PECEN_Pos = 23;
    constexpr uint32_t PECEN_Msk = PECEN::mask;
    /// Enumerated values for PECEN
    namespace pecen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace i2c_cr1

/// I2C_CR2 - Control register 2
namespace i2c_cr2 {
    /// Slave address (master mode) In 7-bit addressing mode (ADD10 = 0): SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care. In 10-bit addressing mode (ADD10 = 1): SADD[9:0] should be written with the 10-bit slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    /// Position: 0, Width: 10
    /// Access: read-write
    using SADD = BitField<0, 10>;
    constexpr uint32_t SADD_Pos = 0;
    constexpr uint32_t SADD_Msk = SADD::mask;

    /// Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    /// Position: 10, Width: 1
    /// Access: read-write
    using RD_WRN = BitField<10, 1>;
    constexpr uint32_t RD_WRN_Pos = 10;
    constexpr uint32_t RD_WRN_Msk = RD_WRN::mask;
    /// Enumerated values for RD_WRN
    namespace rd_wrn {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    /// Position: 11, Width: 1
    /// Access: read-write
    using ADD10 = BitField<11, 1>;
    constexpr uint32_t ADD10_Pos = 11;
    constexpr uint32_t ADD10_Msk = ADD10::mask;
    /// Enumerated values for ADD10
    namespace add10 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    /// Position: 12, Width: 1
    /// Access: read-write
    using HEAD10R = BitField<12, 1>;
    constexpr uint32_t HEAD10R_Pos = 12;
    constexpr uint32_t HEAD10R_Msk = HEAD10R::mask;
    /// Enumerated values for HEAD10R
    namespace head10r {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing '1â to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit generates a START condition once the bus is free. Note: Writing '0â to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    /// Position: 13, Width: 1
    /// Access: read-write
    using START = BitField<13, 1>;
    constexpr uint32_t START_Pos = 13;
    constexpr uint32_t START_Msk = START::mask;
    /// Enumerated values for START
    namespace start {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Stop generation (master mode) The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0. In Master Mode: Note: Writing '0â to this bit has no effect.
    /// Position: 14, Width: 1
    /// Access: read-write
    using STOP = BitField<14, 1>;
    constexpr uint32_t STOP_Pos = 14;
    constexpr uint32_t STOP_Msk = STOP::mask;
    /// Enumerated values for STOP
    namespace stop {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing '0â to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    /// Position: 15, Width: 1
    /// Access: read-write
    using NACK = BitField<15, 1>;
    constexpr uint32_t NACK_Pos = 15;
    constexpr uint32_t NACK_Msk = NACK::mask;
    /// Enumerated values for NACK
    namespace nack {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Number of bytes The number of bytes to be transmitted/received is programmed there. This field is donât care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
    /// Position: 16, Width: 8
    /// Access: read-write
    using NBYTES = BitField<16, 8>;
    constexpr uint32_t NBYTES_Pos = 16;
    constexpr uint32_t NBYTES_Msk = NBYTES::mask;

    /// NBYTES reload mode This bit is set and cleared by software.
    /// Position: 24, Width: 1
    /// Access: read-write
    using RELOAD = BitField<24, 1>;
    constexpr uint32_t RELOAD_Pos = 24;
    constexpr uint32_t RELOAD_Msk = RELOAD::mask;
    /// Enumerated values for RELOAD
    namespace reload {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    /// Position: 25, Width: 1
    /// Access: read-write
    using AUTOEND = BitField<25, 1>;
    constexpr uint32_t AUTOEND_Pos = 25;
    constexpr uint32_t AUTOEND_Msk = AUTOEND::mask;
    /// Enumerated values for AUTOEND
    namespace autoend {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing '0â to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0â. Refer to .
    /// Position: 26, Width: 1
    /// Access: read-write
    using PECBYTE = BitField<26, 1>;
    constexpr uint32_t PECBYTE_Pos = 26;
    constexpr uint32_t PECBYTE_Msk = PECBYTE::mask;
    /// Enumerated values for PECBYTE
    namespace pecbyte {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace i2c_cr2

/// I2C_OAR1 - Own address register 1
namespace i2c_oar1 {
    /// Interface own slave address 7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care. 10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address. Note: These bits can be written only when OA1EN=0.
    /// Position: 0, Width: 10
    /// Access: read-write
    using OA1 = BitField<0, 10>;
    constexpr uint32_t OA1_Pos = 0;
    constexpr uint32_t OA1_Msk = OA1::mask;

    /// Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    /// Position: 10, Width: 1
    /// Access: read-write
    using OA1MODE = BitField<10, 1>;
    constexpr uint32_t OA1MODE_Pos = 10;
    constexpr uint32_t OA1MODE_Msk = OA1MODE::mask;
    /// Enumerated values for OA1MODE
    namespace oa1mode {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Own Address 1 enable
    /// Position: 15, Width: 1
    /// Access: read-write
    using OA1EN = BitField<15, 1>;
    constexpr uint32_t OA1EN_Pos = 15;
    constexpr uint32_t OA1EN_Msk = OA1EN::mask;
    /// Enumerated values for OA1EN
    namespace oa1en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace i2c_oar1

/// I2C_OAR2 - Own address register 2
namespace i2c_oar2 {
    /// Interface address 7-bit addressing mode: 7-bit address Note: These bits can be written only when OA2EN=0.
    /// Position: 1, Width: 7
    /// Access: read-write
    using OA2 = BitField<1, 7>;
    constexpr uint32_t OA2_Pos = 1;
    constexpr uint32_t OA2_Msk = OA2::mask;

    /// Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
    /// Position: 8, Width: 3
    /// Access: read-write
    using OA2MSK = BitField<8, 3>;
    constexpr uint32_t OA2MSK_Pos = 8;
    constexpr uint32_t OA2MSK_Msk = OA2MSK::mask;
    /// Enumerated values for OA2MSK
    namespace oa2msk {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Own Address 2 enable
    /// Position: 15, Width: 1
    /// Access: read-write
    using OA2EN = BitField<15, 1>;
    constexpr uint32_t OA2EN_Pos = 15;
    constexpr uint32_t OA2EN_Msk = OA2EN::mask;
    /// Enumerated values for OA2EN
    namespace oa2en {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace i2c_oar2

/// I2C_TIMINGR - Timing register
namespace i2c_timingr {
    /// SCL low period (master mode)
    /// Position: 0, Width: 8
    using SCLL = BitField<0, 8>;
    constexpr uint32_t SCLL_Pos = 0;
    constexpr uint32_t SCLL_Msk = SCLL::mask;

    /// SCL high period (master mode)
    /// Position: 8, Width: 8
    using SCLH = BitField<8, 8>;
    constexpr uint32_t SCLH_Pos = 8;
    constexpr uint32_t SCLH_Msk = SCLH::mask;

    /// Data hold time
    /// Position: 16, Width: 4
    using SDADEL = BitField<16, 4>;
    constexpr uint32_t SDADEL_Pos = 16;
    constexpr uint32_t SDADEL_Msk = SDADEL::mask;

    /// Data setup time
    /// Position: 20, Width: 4
    using SCLDEL = BitField<20, 4>;
    constexpr uint32_t SCLDEL_Pos = 20;
    constexpr uint32_t SCLDEL_Msk = SCLDEL::mask;

    /// Timing prescaler
    /// Position: 28, Width: 4
    using PRESC = BitField<28, 4>;
    constexpr uint32_t PRESC_Pos = 28;
    constexpr uint32_t PRESC_Msk = PRESC::mask;

}  // namespace i2c_timingr

/// I2C_TIMEOUTR - Status register 1
namespace i2c_timeoutr {
    /// Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
    /// Position: 0, Width: 12
    /// Access: read-write
    using TIMEOUTA = BitField<0, 12>;
    constexpr uint32_t TIMEOUTA_Pos = 0;
    constexpr uint32_t TIMEOUTA_Msk = TIMEOUTA::mask;

    /// Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    /// Position: 12, Width: 1
    /// Access: read-write
    using TIDLE = BitField<12, 1>;
    constexpr uint32_t TIDLE_Pos = 12;
    constexpr uint32_t TIDLE_Msk = TIDLE::mask;
    /// Enumerated values for TIDLE
    namespace tidle {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Clock timeout enable
    /// Position: 15, Width: 1
    /// Access: read-write
    using TIMOUTEN = BitField<15, 1>;
    constexpr uint32_t TIMOUTEN_Pos = 15;
    constexpr uint32_t TIMOUTEN_Msk = TIMOUTEN::mask;
    /// Enumerated values for TIMOUTEN
    namespace timouten {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
    /// Position: 16, Width: 12
    /// Access: read-write
    using TIMEOUTB = BitField<16, 12>;
    constexpr uint32_t TIMEOUTB_Pos = 16;
    constexpr uint32_t TIMEOUTB_Msk = TIMEOUTB::mask;

    /// Extended clock timeout enable
    /// Position: 31, Width: 1
    /// Access: read-write
    using TEXTEN = BitField<31, 1>;
    constexpr uint32_t TEXTEN_Pos = 31;
    constexpr uint32_t TEXTEN_Msk = TEXTEN::mask;
    /// Enumerated values for TEXTEN
    namespace texten {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace i2c_timeoutr

/// I2C_ISR - Interrupt and Status register
namespace i2c_isr {
    /// Transmit data register empty (transmitters)
    /// Position: 0, Width: 1
    /// Access: read-write
    using TXE = BitField<0, 1>;
    constexpr uint32_t TXE_Pos = 0;
    constexpr uint32_t TXE_Msk = TXE::mask;

    /// Transmit interrupt status (transmitters)
    /// Position: 1, Width: 1
    /// Access: read-write
    using TXIS = BitField<1, 1>;
    constexpr uint32_t TXIS_Pos = 1;
    constexpr uint32_t TXIS_Msk = TXIS::mask;

    /// Receive data register not empty (receivers)
    /// Position: 2, Width: 1
    /// Access: read-only
    using RXNE = BitField<2, 1>;
    constexpr uint32_t RXNE_Pos = 2;
    constexpr uint32_t RXNE_Msk = RXNE::mask;

    /// Address matched (slave mode)
    /// Position: 3, Width: 1
    /// Access: read-only
    using ADDR = BitField<3, 1>;
    constexpr uint32_t ADDR_Pos = 3;
    constexpr uint32_t ADDR_Msk = ADDR::mask;

    /// Not acknowledge received flag
    /// Position: 4, Width: 1
    /// Access: read-only
    using NACKF = BitField<4, 1>;
    constexpr uint32_t NACKF_Pos = 4;
    constexpr uint32_t NACKF_Msk = NACKF::mask;

    /// Stop detection flag
    /// Position: 5, Width: 1
    /// Access: read-only
    using STOPF = BitField<5, 1>;
    constexpr uint32_t STOPF_Pos = 5;
    constexpr uint32_t STOPF_Msk = STOPF::mask;

    /// Transfer Complete (master mode)
    /// Position: 6, Width: 1
    /// Access: read-only
    using TC = BitField<6, 1>;
    constexpr uint32_t TC_Pos = 6;
    constexpr uint32_t TC_Msk = TC::mask;

    /// Transfer Complete Reload
    /// Position: 7, Width: 1
    /// Access: read-only
    using TCR = BitField<7, 1>;
    constexpr uint32_t TCR_Pos = 7;
    constexpr uint32_t TCR_Msk = TCR::mask;

    /// Bus error
    /// Position: 8, Width: 1
    /// Access: read-only
    using BERR = BitField<8, 1>;
    constexpr uint32_t BERR_Pos = 8;
    constexpr uint32_t BERR_Msk = BERR::mask;

    /// Arbitration lost
    /// Position: 9, Width: 1
    /// Access: read-only
    using ARLO = BitField<9, 1>;
    constexpr uint32_t ARLO_Pos = 9;
    constexpr uint32_t ARLO_Msk = ARLO::mask;

    /// Overrun/Underrun (slave mode)
    /// Position: 10, Width: 1
    /// Access: read-only
    using OVR = BitField<10, 1>;
    constexpr uint32_t OVR_Pos = 10;
    constexpr uint32_t OVR_Msk = OVR::mask;

    /// PEC Error in reception
    /// Position: 11, Width: 1
    /// Access: read-only
    using PECERR = BitField<11, 1>;
    constexpr uint32_t PECERR_Pos = 11;
    constexpr uint32_t PECERR_Msk = PECERR::mask;

    /// Timeout or t_low detection flag
    /// Position: 12, Width: 1
    /// Access: read-only
    using TIMEOUT = BitField<12, 1>;
    constexpr uint32_t TIMEOUT_Pos = 12;
    constexpr uint32_t TIMEOUT_Msk = TIMEOUT::mask;

    /// SMBus alert
    /// Position: 13, Width: 1
    /// Access: read-only
    using ALERT = BitField<13, 1>;
    constexpr uint32_t ALERT_Pos = 13;
    constexpr uint32_t ALERT_Msk = ALERT::mask;

    /// Bus busy
    /// Position: 15, Width: 1
    /// Access: read-only
    using BUSY = BitField<15, 1>;
    constexpr uint32_t BUSY_Pos = 15;
    constexpr uint32_t BUSY_Msk = BUSY::mask;

    /// Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
    /// Position: 16, Width: 1
    /// Access: read-only
    using DIR = BitField<16, 1>;
    constexpr uint32_t DIR_Pos = 16;
    constexpr uint32_t DIR_Msk = DIR::mask;
    /// Enumerated values for DIR
    namespace dir {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Address match code (Slave mode)
    /// Position: 17, Width: 7
    /// Access: read-only
    using ADDCODE = BitField<17, 7>;
    constexpr uint32_t ADDCODE_Pos = 17;
    constexpr uint32_t ADDCODE_Msk = ADDCODE::mask;

}  // namespace i2c_isr

/// I2C_ICR - Interrupt clear register
namespace i2c_icr {
    /// Address Matched flag clear
    /// Position: 3, Width: 1
    using ADDRCF = BitField<3, 1>;
    constexpr uint32_t ADDRCF_Pos = 3;
    constexpr uint32_t ADDRCF_Msk = ADDRCF::mask;

    /// Not Acknowledge flag clear
    /// Position: 4, Width: 1
    using NACKCF = BitField<4, 1>;
    constexpr uint32_t NACKCF_Pos = 4;
    constexpr uint32_t NACKCF_Msk = NACKCF::mask;

    /// Stop detection flag clear
    /// Position: 5, Width: 1
    using STOPCF = BitField<5, 1>;
    constexpr uint32_t STOPCF_Pos = 5;
    constexpr uint32_t STOPCF_Msk = STOPCF::mask;

    /// Bus error flag clear
    /// Position: 8, Width: 1
    using BERRCF = BitField<8, 1>;
    constexpr uint32_t BERRCF_Pos = 8;
    constexpr uint32_t BERRCF_Msk = BERRCF::mask;

    /// Arbitration lost flag clear
    /// Position: 9, Width: 1
    using ARLOCF = BitField<9, 1>;
    constexpr uint32_t ARLOCF_Pos = 9;
    constexpr uint32_t ARLOCF_Msk = ARLOCF::mask;

    /// Overrun/Underrun flag clear
    /// Position: 10, Width: 1
    using OVRCF = BitField<10, 1>;
    constexpr uint32_t OVRCF_Pos = 10;
    constexpr uint32_t OVRCF_Msk = OVRCF::mask;

    /// PEC Error flag clear
    /// Position: 11, Width: 1
    using PECCF = BitField<11, 1>;
    constexpr uint32_t PECCF_Pos = 11;
    constexpr uint32_t PECCF_Msk = PECCF::mask;

    /// Timeout detection flag clear
    /// Position: 12, Width: 1
    using TIMOUTCF = BitField<12, 1>;
    constexpr uint32_t TIMOUTCF_Pos = 12;
    constexpr uint32_t TIMOUTCF_Msk = TIMOUTCF::mask;

    /// Alert flag clear
    /// Position: 13, Width: 1
    using ALERTCF = BitField<13, 1>;
    constexpr uint32_t ALERTCF_Pos = 13;
    constexpr uint32_t ALERTCF_Msk = ALERTCF::mask;

}  // namespace i2c_icr

/// I2C_PECR - PEC register
namespace i2c_pecr {
    /// Packet error checking register
    /// Position: 0, Width: 8
    using PEC = BitField<0, 8>;
    constexpr uint32_t PEC_Pos = 0;
    constexpr uint32_t PEC_Msk = PEC::mask;

}  // namespace i2c_pecr

/// I2C_RXDR - Receive data register
namespace i2c_rxdr {
    /// 8-bit receive data
    /// Position: 0, Width: 8
    using RXDATA = BitField<0, 8>;
    constexpr uint32_t RXDATA_Pos = 0;
    constexpr uint32_t RXDATA_Msk = RXDATA::mask;

}  // namespace i2c_rxdr

/// I2C_TXDR - Transmit data register
namespace i2c_txdr {
    /// 8-bit transmit data
    /// Position: 0, Width: 8
    using TXDATA = BitField<0, 8>;
    constexpr uint32_t TXDATA_Pos = 0;
    constexpr uint32_t TXDATA_Msk = TXDATA::mask;

}  // namespace i2c_txdr

}  // namespace alloy::hal::st::stm32g0::i2c1
