/// Auto-generated bit field definitions for LPUART1
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::lpuart1 {

using namespace alloy::hal::bitfields;

// ============================================================================
// LPUART1 Bit Field Definitions
// ============================================================================

/// LPUART_CR1_enabled - LPUART control register 1 [alternate]
namespace lpuart_cr1_enabled {
    /// LPUART enable When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
    /// Position: 0, Width: 1
    /// Access: read-write
    using UE = BitField<0, 1>;
    constexpr uint32_t UE_Pos = 0;
    constexpr uint32_t UE_Msk = UE::mask;
    /// Enumerated values for UE
    namespace ue {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// LPUART enable in Stop mode When this bit is cleared, the LPUART is not able to wake up the MCU from low-power mode. When this bit is set, the LPUART is able to wake up the MCU from low-power mode, provided that the LPUART clock selection is HSI or LSE in the RCC. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it on exit from low-power mode.
    /// Position: 1, Width: 1
    /// Access: read-write
    using UESM = BitField<1, 1>;
    constexpr uint32_t UESM_Pos = 1;
    constexpr uint32_t UESM_Msk = UESM::mask;
    /// Enumerated values for UESM
    namespace uesm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receiver enable This bit enables the receiver. It is set and cleared by software.
    /// Position: 2, Width: 1
    /// Access: read-write
    using RE = BitField<2, 1>;
    constexpr uint32_t RE_Pos = 2;
    constexpr uint32_t RE_Msk = RE::mask;
    /// Enumerated values for RE
    namespace re {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit (â0â followed by â1â) sends a preamble (idle line) after the current word. In order to generate an idle character, the TE must not be immediately written to 1. In order to ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register. When TE is set there is a 1 bit-time delay before the transmission starts.
    /// Position: 3, Width: 1
    /// Access: read-write
    using TE = BitField<3, 1>;
    constexpr uint32_t TE_Pos = 3;
    constexpr uint32_t TE_Msk = TE::mask;
    /// Enumerated values for TE
    namespace te {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// IDLE interrupt enable This bit is set and cleared by software.
    /// Position: 4, Width: 1
    /// Access: read-write
    using IDLEIE = BitField<4, 1>;
    constexpr uint32_t IDLEIE_Pos = 4;
    constexpr uint32_t IDLEIE_Msk = IDLEIE::mask;
    /// Enumerated values for IDLEIE
    namespace idleie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXFIFO not empty interrupt enable This bit is set and cleared by software.
    /// Position: 5, Width: 1
    /// Access: read-write
    using RXFNEIE = BitField<5, 1>;
    constexpr uint32_t RXFNEIE_Pos = 5;
    constexpr uint32_t RXFNEIE_Msk = RXFNEIE::mask;
    /// Enumerated values for RXFNEIE
    namespace rxfneie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmission complete interrupt enable This bit is set and cleared by software.
    /// Position: 6, Width: 1
    /// Access: read-write
    using TCIE = BitField<6, 1>;
    constexpr uint32_t TCIE_Pos = 6;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXFIFO not full interrupt enable This bit is set and cleared by software.
    /// Position: 7, Width: 1
    /// Access: read-write
    using TXFNFIE = BitField<7, 1>;
    constexpr uint32_t TXFNFIE_Pos = 7;
    constexpr uint32_t TXFNFIE_Msk = TXFNFIE::mask;
    /// Enumerated values for TXFNFIE
    namespace txfnfie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// PE interrupt enable This bit is set and cleared by software.
    /// Position: 8, Width: 1
    /// Access: read-write
    using PEIE = BitField<8, 1>;
    constexpr uint32_t PEIE_Pos = 8;
    constexpr uint32_t PEIE_Msk = PEIE::mask;
    /// Enumerated values for PEIE
    namespace peie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 9, Width: 1
    /// Access: read-write
    using PS = BitField<9, 1>;
    constexpr uint32_t PS_Pos = 9;
    constexpr uint32_t PS_Msk = PS::mask;
    /// Enumerated values for PS
    namespace ps {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if MÂ =Â 1; 8th bit if MÂ =Â 0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 10, Width: 1
    /// Access: read-write
    using PCE = BitField<10, 1>;
    constexpr uint32_t PCE_Pos = 10;
    constexpr uint32_t PCE_Msk = PCE::mask;
    /// Enumerated values for PCE
    namespace pce {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receiver wakeup method This bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 11, Width: 1
    /// Access: read-write
    using WAKE = BitField<11, 1>;
    constexpr uint32_t WAKE_Pos = 11;
    constexpr uint32_t WAKE_Msk = WAKE::mask;
    /// Enumerated values for WAKE
    namespace wake {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description). This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 12, Width: 1
    /// Access: read-write
    using M0 = BitField<12, 1>;
    constexpr uint32_t M0_Pos = 12;
    constexpr uint32_t M0_Msk = M0::mask;

    /// Mute mode enable This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.
    /// Position: 13, Width: 1
    /// Access: read-write
    using MME = BitField<13, 1>;
    constexpr uint32_t MME_Pos = 13;
    constexpr uint32_t MME_Msk = MME::mask;
    /// Enumerated values for MME
    namespace mme {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Character match interrupt enable This bit is set and cleared by software.
    /// Position: 14, Width: 1
    /// Access: read-write
    using CMIE = BitField<14, 1>;
    constexpr uint32_t CMIE_Pos = 14;
    constexpr uint32_t CMIE_Msk = CMIE::mask;
    /// Enumerated values for CMIE
    namespace cmie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer control and RS485 Driver Enable. If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 16, Width: 5
    /// Access: read-write
    using DEDT = BitField<16, 5>;
    constexpr uint32_t DEDT_Pos = 16;
    constexpr uint32_t DEDT_Msk = DEDT::mask;

    /// Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer . This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 21, Width: 5
    /// Access: read-write
    using DEAT = BitField<21, 5>;
    constexpr uint32_t DEAT_Pos = 21;
    constexpr uint32_t DEAT_Msk = DEAT::mask;

    /// Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00â: 1 Start bit, 8 Data bits, n Stop bit M[1:0] = '01â: 1 Start bit, 9 Data bits, n Stop bit M[1:0] = '10â: 1 Start bit, 7 Data bits, n Stop bit This bit can only be written when the LPUART is disabled (UEÂ =Â 0). Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.
    /// Position: 28, Width: 1
    /// Access: read-write
    using M1 = BitField<28, 1>;
    constexpr uint32_t M1_Pos = 28;
    constexpr uint32_t M1_Msk = M1::mask;

    /// FIFO mode enable This bit is set and cleared by software.
    /// Position: 29, Width: 1
    /// Access: read-write
    using FIFOEN = BitField<29, 1>;
    constexpr uint32_t FIFOEN_Pos = 29;
    constexpr uint32_t FIFOEN_Msk = FIFOEN::mask;
    /// Enumerated values for FIFOEN
    namespace fifoen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXFIFO empty interrupt enable This bit is set and cleared by software.
    /// Position: 30, Width: 1
    /// Access: read-write
    using TXFEIE = BitField<30, 1>;
    constexpr uint32_t TXFEIE_Pos = 30;
    constexpr uint32_t TXFEIE_Msk = TXFEIE::mask;
    /// Enumerated values for TXFEIE
    namespace txfeie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXFIFO Full interrupt enable This bit is set and cleared by software.
    /// Position: 31, Width: 1
    /// Access: read-write
    using RXFFIE = BitField<31, 1>;
    constexpr uint32_t RXFFIE_Pos = 31;
    constexpr uint32_t RXFFIE_Msk = RXFFIE::mask;
    /// Enumerated values for RXFFIE
    namespace rxffie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace lpuart_cr1_enabled

/// LPUART_CR1_disabled - LPUART control register 1 [alternate]
namespace lpuart_cr1_disabled {
    /// LPUART enable When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
    /// Position: 0, Width: 1
    /// Access: read-write
    using UE = BitField<0, 1>;
    constexpr uint32_t UE_Pos = 0;
    constexpr uint32_t UE_Msk = UE::mask;
    /// Enumerated values for UE
    namespace ue {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// LPUART enable in Stop mode When this bit is cleared, the LPUART is not able to wake up the MCU from low-power mode. When this bit is set, the LPUART is able to wake up the MCU from low-power mode, provided that the LPUART clock selection is HSI or LSE in the RCC. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it on exit from low-power mode.
    /// Position: 1, Width: 1
    /// Access: read-write
    using UESM = BitField<1, 1>;
    constexpr uint32_t UESM_Pos = 1;
    constexpr uint32_t UESM_Msk = UESM::mask;
    /// Enumerated values for UESM
    namespace uesm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receiver enable This bit enables the receiver. It is set and cleared by software.
    /// Position: 2, Width: 1
    /// Access: read-write
    using RE = BitField<2, 1>;
    constexpr uint32_t RE_Pos = 2;
    constexpr uint32_t RE_Msk = RE::mask;
    /// Enumerated values for RE
    namespace re {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit (â0â followed by â1â) sends a preamble (idle line) after the current word. In order to generate an idle character, the TE must not be immediately written to 1. In order to ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register. When TE is set there is a 1 bit-time delay before the transmission starts.
    /// Position: 3, Width: 1
    /// Access: read-write
    using TE = BitField<3, 1>;
    constexpr uint32_t TE_Pos = 3;
    constexpr uint32_t TE_Msk = TE::mask;
    /// Enumerated values for TE
    namespace te {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// IDLE interrupt enable This bit is set and cleared by software.
    /// Position: 4, Width: 1
    /// Access: read-write
    using IDLEIE = BitField<4, 1>;
    constexpr uint32_t IDLEIE_Pos = 4;
    constexpr uint32_t IDLEIE_Msk = IDLEIE::mask;
    /// Enumerated values for IDLEIE
    namespace idleie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXFIFO not empty interrupt enable This bit is set and cleared by software.
    /// Position: 5, Width: 1
    /// Access: read-write
    using RXFNEIE = BitField<5, 1>;
    constexpr uint32_t RXFNEIE_Pos = 5;
    constexpr uint32_t RXFNEIE_Msk = RXFNEIE::mask;
    /// Enumerated values for RXFNEIE
    namespace rxfneie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmission complete interrupt enable This bit is set and cleared by software.
    /// Position: 6, Width: 1
    /// Access: read-write
    using TCIE = BitField<6, 1>;
    constexpr uint32_t TCIE_Pos = 6;
    constexpr uint32_t TCIE_Msk = TCIE::mask;
    /// Enumerated values for TCIE
    namespace tcie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXFIFO not full interrupt enable This bit is set and cleared by software.
    /// Position: 7, Width: 1
    /// Access: read-write
    using TXFNFIE = BitField<7, 1>;
    constexpr uint32_t TXFNFIE_Pos = 7;
    constexpr uint32_t TXFNFIE_Msk = TXFNFIE::mask;
    /// Enumerated values for TXFNFIE
    namespace txfnfie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// PE interrupt enable This bit is set and cleared by software.
    /// Position: 8, Width: 1
    /// Access: read-write
    using PEIE = BitField<8, 1>;
    constexpr uint32_t PEIE_Pos = 8;
    constexpr uint32_t PEIE_Msk = PEIE::mask;
    /// Enumerated values for PEIE
    namespace peie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Parity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 9, Width: 1
    /// Access: read-write
    using PS = BitField<9, 1>;
    constexpr uint32_t PS_Pos = 9;
    constexpr uint32_t PS_Msk = PS::mask;
    /// Enumerated values for PS
    namespace ps {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Parity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if MÂ =Â 1; 8th bit if MÂ =Â 0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 10, Width: 1
    /// Access: read-write
    using PCE = BitField<10, 1>;
    constexpr uint32_t PCE_Pos = 10;
    constexpr uint32_t PCE_Msk = PCE::mask;
    /// Enumerated values for PCE
    namespace pce {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receiver wakeup method This bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 11, Width: 1
    /// Access: read-write
    using WAKE = BitField<11, 1>;
    constexpr uint32_t WAKE_Pos = 11;
    constexpr uint32_t WAKE_Msk = WAKE::mask;
    /// Enumerated values for WAKE
    namespace wake {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description). This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 12, Width: 1
    /// Access: read-write
    using M0 = BitField<12, 1>;
    constexpr uint32_t M0_Pos = 12;
    constexpr uint32_t M0_Msk = M0::mask;

    /// Mute mode enable This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.
    /// Position: 13, Width: 1
    /// Access: read-write
    using MME = BitField<13, 1>;
    constexpr uint32_t MME_Pos = 13;
    constexpr uint32_t MME_Msk = MME::mask;
    /// Enumerated values for MME
    namespace mme {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Character match interrupt enable This bit is set and cleared by software.
    /// Position: 14, Width: 1
    /// Access: read-write
    using CMIE = BitField<14, 1>;
    constexpr uint32_t CMIE_Pos = 14;
    constexpr uint32_t CMIE_Msk = CMIE::mask;
    /// Enumerated values for CMIE
    namespace cmie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer control and RS485 Driver Enable. If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 16, Width: 5
    /// Access: read-write
    using DEDT = BitField<16, 5>;
    constexpr uint32_t DEDT_Pos = 16;
    constexpr uint32_t DEDT_Msk = DEDT::mask;

    /// Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer . This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 21, Width: 5
    /// Access: read-write
    using DEAT = BitField<21, 5>;
    constexpr uint32_t DEAT_Pos = 21;
    constexpr uint32_t DEAT_Msk = DEAT::mask;

    /// Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00â: 1 Start bit, 8 Data bits, n Stop bit M[1:0] = '01â: 1 Start bit, 9 Data bits, n Stop bit M[1:0] = '10â: 1 Start bit, 7 Data bits, n Stop bit This bit can only be written when the LPUART is disabled (UEÂ =Â 0). Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.
    /// Position: 28, Width: 1
    /// Access: read-write
    using M1 = BitField<28, 1>;
    constexpr uint32_t M1_Pos = 28;
    constexpr uint32_t M1_Msk = M1::mask;

    /// FIFO mode enable This bit is set and cleared by software.
    /// Position: 29, Width: 1
    /// Access: read-write
    using FIFOEN = BitField<29, 1>;
    constexpr uint32_t FIFOEN_Pos = 29;
    constexpr uint32_t FIFOEN_Msk = FIFOEN::mask;
    /// Enumerated values for FIFOEN
    namespace fifoen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace lpuart_cr1_disabled

/// LPUART_CR2 - LPUART control register 2
namespace lpuart_cr2 {
    /// 7-bit Address Detection/4-bit Address Detection This bit is for selection between 4-bit address detection or 7-bit address detection. This bit can only be written when the LPUART is disabled (UEÂ =Â 0) Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.
    /// Position: 4, Width: 1
    /// Access: read-write
    using ADDM7 = BitField<4, 1>;
    constexpr uint32_t ADDM7_Pos = 4;
    constexpr uint32_t ADDM7_Msk = ADDM7::mask;
    /// Enumerated values for ADDM7
    namespace addm7 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// STOP bits These bits are used for programming the stop bits. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 12, Width: 2
    /// Access: read-write
    using STOP = BitField<12, 2>;
    constexpr uint32_t STOP_Pos = 12;
    constexpr uint32_t STOP_Msk = STOP::mask;
    /// Enumerated values for STOP
    namespace stop {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x2 = 2;
    }

    /// Swap TX/RX pins This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 15, Width: 1
    /// Access: read-write
    using SWAP = BitField<15, 1>;
    constexpr uint32_t SWAP_Pos = 15;
    constexpr uint32_t SWAP_Msk = SWAP::mask;
    /// Enumerated values for SWAP
    namespace swap {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the RX line. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 16, Width: 1
    /// Access: read-write
    using RXINV = BitField<16, 1>;
    constexpr uint32_t RXINV_Pos = 16;
    constexpr uint32_t RXINV_Msk = RXINV::mask;
    /// Enumerated values for RXINV
    namespace rxinv {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the TX line. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 17, Width: 1
    /// Access: read-write
    using TXINV = BitField<17, 1>;
    constexpr uint32_t TXINV_Pos = 17;
    constexpr uint32_t TXINV_Msk = TXINV::mask;
    /// Enumerated values for TXINV
    namespace txinv {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Binary data inversion This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 18, Width: 1
    /// Access: read-write
    using DATAINV = BitField<18, 1>;
    constexpr uint32_t DATAINV_Pos = 18;
    constexpr uint32_t DATAINV_Msk = DATAINV::mask;
    /// Enumerated values for DATAINV
    namespace datainv {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Most significant bit first This bit is set and cleared by software. This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 19, Width: 1
    /// Access: read-write
    using MSBFIRST = BitField<19, 1>;
    constexpr uint32_t MSBFIRST_Pos = 19;
    constexpr uint32_t MSBFIRST_Msk = MSBFIRST::mask;
    /// Enumerated values for MSBFIRST
    namespace msbfirst {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Address of the LPUART node ADD[7:4]: These bits give the address of the LPUART node or a character code to be recognized. They are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or Stop mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match. These bits can only be written when reception is disabled (RE = 0) or the LPUART is disabled (UEÂ =Â 0) ADD[3:0]: These bits give the address of the LPUART node or a character code to be recognized. They are used for wakeup with address mark detection in multiprocessor communication during Mute mode or low-power mode. These bits can only be written when reception is disabled (RE = 0) or the LPUART is disabled (UEÂ =Â 0)
    /// Position: 24, Width: 8
    /// Access: read-write
    using ADD = BitField<24, 8>;
    constexpr uint32_t ADD_Pos = 24;
    constexpr uint32_t ADD_Msk = ADD::mask;

}  // namespace lpuart_cr2

/// LPUART_CR3 - LPUART control register 3
namespace lpuart_cr3 {
    /// Error interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FEÂ =Â 1 or OREÂ =Â 1 or NEÂ =Â 1 in the LPUART_ISR register).
    /// Position: 0, Width: 1
    /// Access: read-write
    using EIE = BitField<0, 1>;
    constexpr uint32_t EIE_Pos = 0;
    constexpr uint32_t EIE_Msk = EIE::mask;
    /// Enumerated values for EIE
    namespace eie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Half-duplex selection Selection of Single-wire Half-duplex mode This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 3, Width: 1
    /// Access: read-write
    using HDSEL = BitField<3, 1>;
    constexpr uint32_t HDSEL_Pos = 3;
    constexpr uint32_t HDSEL_Msk = HDSEL::mask;
    /// Enumerated values for HDSEL
    namespace hdsel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// DMA enable receiver This bit is set/reset by software
    /// Position: 6, Width: 1
    /// Access: read-write
    using DMAR = BitField<6, 1>;
    constexpr uint32_t DMAR_Pos = 6;
    constexpr uint32_t DMAR_Msk = DMAR::mask;
    /// Enumerated values for DMAR
    namespace dmar {
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x0 = 0;
    }

    /// DMA enable transmitter This bit is set/reset by software
    /// Position: 7, Width: 1
    /// Access: read-write
    using DMAT = BitField<7, 1>;
    constexpr uint32_t DMAT_Pos = 7;
    constexpr uint32_t DMAT_Msk = DMAT::mask;
    /// Enumerated values for DMAT
    namespace dmat {
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x0 = 0;
    }

    /// RTS enable This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 8, Width: 1
    /// Access: read-write
    using RTSE = BitField<8, 1>;
    constexpr uint32_t RTSE_Pos = 8;
    constexpr uint32_t RTSE_Msk = RTSE::mask;
    /// Enumerated values for RTSE
    namespace rtse {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CTS enable This bit can only be written when the LPUART is disabled (UEÂ =Â 0)
    /// Position: 9, Width: 1
    /// Access: read-write
    using CTSE = BitField<9, 1>;
    constexpr uint32_t CTSE_Pos = 9;
    constexpr uint32_t CTSE_Msk = CTSE::mask;
    /// Enumerated values for CTSE
    namespace ctse {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CTS interrupt enable
    /// Position: 10, Width: 1
    /// Access: read-write
    using CTSIE = BitField<10, 1>;
    constexpr uint32_t CTSIE_Pos = 10;
    constexpr uint32_t CTSIE_Msk = CTSIE::mask;
    /// Enumerated values for CTSIE
    namespace ctsie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Overrun Disable This bit is used to disable the receive overrun detection. the ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register. This bit can only be written when the LPUART is disabled (UEÂ =Â 0). Note: This control bit enables checking the communication flow w/o reading the data.
    /// Position: 12, Width: 1
    /// Access: read-write
    using OVRDIS = BitField<12, 1>;
    constexpr uint32_t OVRDIS_Pos = 12;
    constexpr uint32_t OVRDIS_Msk = OVRDIS::mask;
    /// Enumerated values for OVRDIS
    namespace ovrdis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// DMA Disable on Reception Error This bit can only be written when the LPUART is disabled (UEÂ =Â 0). Note: The reception errors are: parity error, framing error or noise error.
    /// Position: 13, Width: 1
    /// Access: read-write
    using DDRE = BitField<13, 1>;
    constexpr uint32_t DDRE_Pos = 13;
    constexpr uint32_t DDRE_Msk = DDRE::mask;
    /// Enumerated values for DDRE
    namespace ddre {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Driver enable mode This bit enables the user to activate the external transceiver control, through the DE signal. This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 14, Width: 1
    /// Access: read-write
    using DEM = BitField<14, 1>;
    constexpr uint32_t DEM_Pos = 14;
    constexpr uint32_t DEM_Msk = DEM::mask;
    /// Enumerated values for DEM
    namespace dem {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Driver enable polarity selection This bit can only be written when the LPUART is disabled (UEÂ =Â 0).
    /// Position: 15, Width: 1
    /// Access: read-write
    using DEP = BitField<15, 1>;
    constexpr uint32_t DEP_Pos = 15;
    constexpr uint32_t DEP_Msk = DEP::mask;
    /// Enumerated values for DEP
    namespace dep {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wakeup from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag). This bitfield can only be written when the LPUART is disabled (UEÂ =Â 0). Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .
    /// Position: 20, Width: 2
    /// Access: read-write
    using WUS = BitField<20, 2>;
    constexpr uint32_t WUS_Pos = 20;
    constexpr uint32_t WUS_Msk = WUS::mask;
    /// Enumerated values for WUS
    namespace wus {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Wakeup from low-power mode interrupt enable This bit is set and cleared by software. Note: WUFIE must be set before entering in low-power mode. If the LPUART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .
    /// Position: 22, Width: 1
    /// Access: read-write
    using WUFIE = BitField<22, 1>;
    constexpr uint32_t WUFIE_Pos = 22;
    constexpr uint32_t WUFIE_Msk = WUFIE::mask;
    /// Enumerated values for WUFIE
    namespace wufie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXFIFO threshold interrupt enable This bit is set and cleared by software.
    /// Position: 23, Width: 1
    /// Access: read-write
    using TXFTIE = BitField<23, 1>;
    constexpr uint32_t TXFTIE_Pos = 23;
    constexpr uint32_t TXFTIE_Msk = TXFTIE::mask;
    /// Enumerated values for TXFTIE
    namespace txftie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receive FIFO threshold configuration Remaining combinations: Reserved.
    /// Position: 25, Width: 3
    /// Access: read-write
    using RXFTCFG = BitField<25, 3>;
    constexpr uint32_t RXFTCFG_Pos = 25;
    constexpr uint32_t RXFTCFG_Msk = RXFTCFG::mask;
    /// Enumerated values for RXFTCFG
    namespace rxftcfg {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
    }

    /// RXFIFO threshold interrupt enable This bit is set and cleared by software.
    /// Position: 28, Width: 1
    /// Access: read-write
    using RXFTIE = BitField<28, 1>;
    constexpr uint32_t RXFTIE_Pos = 28;
    constexpr uint32_t RXFTIE_Msk = RXFTIE::mask;
    /// Enumerated values for RXFTIE
    namespace rxftie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXFIFO threshold configuration Remaining combinations: Reserved.
    /// Position: 29, Width: 3
    /// Access: read-write
    using TXFTCFG = BitField<29, 3>;
    constexpr uint32_t TXFTCFG_Pos = 29;
    constexpr uint32_t TXFTCFG_Msk = TXFTCFG::mask;
    /// Enumerated values for TXFTCFG
    namespace txftcfg {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
    }

}  // namespace lpuart_cr3

/// LPUART_BRR - LPUART baud rate register
namespace lpuart_brr {
    /// LPUART baud rate
    /// Position: 0, Width: 20
    /// Access: read-write
    using BRR = BitField<0, 20>;
    constexpr uint32_t BRR_Pos = 0;
    constexpr uint32_t BRR_Msk = BRR::mask;

}  // namespace lpuart_brr

/// LPUART_RQR - LPUART request register
namespace lpuart_rqr {
    /// Send break request Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. Note: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.
    /// Position: 1, Width: 1
    /// Access: write-only
    using SBKRQ = BitField<1, 1>;
    constexpr uint32_t SBKRQ_Pos = 1;
    constexpr uint32_t SBKRQ_Msk = SBKRQ::mask;

    /// Mute mode request Writing 1 to this bit puts the LPUART in Mute mode and resets the RWU flag.
    /// Position: 2, Width: 1
    /// Access: write-only
    using MMRQ = BitField<2, 1>;
    constexpr uint32_t MMRQ_Pos = 2;
    constexpr uint32_t MMRQ_Msk = MMRQ::mask;

    /// Receive data flush request Writing 1 to this bit clears the RXNE flag. This enables discarding the received data without reading it, and avoid an overrun condition.
    /// Position: 3, Width: 1
    /// Access: write-only
    using RXFRQ = BitField<3, 1>;
    constexpr uint32_t RXFRQ_Pos = 3;
    constexpr uint32_t RXFRQ_Msk = RXFRQ::mask;

    /// Transmit data flush request This bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register). Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.
    /// Position: 4, Width: 1
    /// Access: write-only
    using TXFRQ = BitField<4, 1>;
    constexpr uint32_t TXFRQ_Pos = 4;
    constexpr uint32_t TXFRQ_Msk = TXFRQ::mask;

}  // namespace lpuart_rqr

/// LPUART_ISR_enabled - LPUART interrupt and status register [alternate]
namespace lpuart_isr_enabled {
    /// Parity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register. An interrupt is generated if PEIE = 1 in the LPUART_CR1 register. Note: This error is associated with the character in the LPUART_RDR.
    /// Position: 0, Width: 1
    /// Access: read-only
    using PE = BitField<0, 1>;
    constexpr uint32_t PE_Pos = 0;
    constexpr uint32_t PE_Msk = PE::mask;
    /// Enumerated values for PE
    namespace pe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIEÂ =Â 1 in the LPUART_CR1 register. Note: This error is associated with the character in the LPUART_RDR.
    /// Position: 1, Width: 1
    /// Access: read-only
    using FE = BitField<1, 1>;
    constexpr uint32_t FE_Pos = 1;
    constexpr uint32_t FE_Msk = FE::mask;
    /// Enumerated values for FE
    namespace fe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Start bit noise detection flag This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NECF bit in the LPUART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. This error is associated with the character in the LPUART_RDR.
    /// Position: 2, Width: 1
    /// Access: read-only
    using NE = BitField<2, 1>;
    constexpr uint32_t NE_Pos = 2;
    constexpr uint32_t NE_Msk = NE::mask;
    /// Enumerated values for NE
    namespace ne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register. An interrupt is generated if RXFNEIEÂ =Â 1 or EIE = 1 in the LPUART_CR1 register. Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.
    /// Position: 3, Width: 1
    /// Access: read-only
    using ORE = BitField<3, 1>;
    constexpr uint32_t ORE_Pos = 3;
    constexpr uint32_t ORE_Msk = ORE::mask;
    /// Enumerated values for ORE
    namespace ore {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Idle line detected This bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIEÂ =Â 1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register. Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MMEÂ =Â 1), IDLE is set if the LPUART is not mute (RWUÂ =Â 0), whatever the Mute mode selected by the WAKE bit. If RWUÂ =Â 1, IDLE is not set.
    /// Position: 4, Width: 1
    /// Access: read-only
    using IDLE = BitField<4, 1>;
    constexpr uint32_t IDLE_Pos = 4;
    constexpr uint32_t IDLE_Msk = IDLE::mask;
    /// Enumerated values for IDLE
    namespace idle {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register. An interrupt is generated if RXFNEIEÂ =Â 1 in the LPUART_CR1 register.
    /// Position: 5, Width: 1
    /// Access: read-only
    using RXFNE = BitField<5, 1>;
    constexpr uint32_t RXFNE_Pos = 5;
    constexpr uint32_t RXFNE_Msk = RXFNE::mask;
    /// Enumerated values for RXFNE
    namespace rxfne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmission complete This bit is set by hardware if the transmission of a frame containing data is complete and if TXFF is set. An interrupt is generated if TCIEÂ =Â 1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the TCCF in the LPUART_ICR register or by a write to the LPUART_TDR register. An interrupt is generated if TCIEÂ =Â 1 in the LPUART_CR1 register. Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.
    /// Position: 6, Width: 1
    /// Access: read-only
    using TC = BitField<6, 1>;
    constexpr uint32_t TC_Pos = 6;
    constexpr uint32_t TC_Msk = TC::mask;
    /// Enumerated values for TC
    namespace tc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXFIFO not full TXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR. The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time). An interrupt is generated if the TXFNFIE bit Â =Â 1 in the LPUART_CR1 register. Note: This bit is used during single buffer transmission.
    /// Position: 7, Width: 1
    /// Access: read-only
    using TXFNF = BitField<7, 1>;
    constexpr uint32_t TXFNF_Pos = 7;
    constexpr uint32_t TXFNF_Msk = TXFNF::mask;
    /// Enumerated values for TXFNF
    namespace txfnf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register. An interrupt is generated if CTSIEÂ =Â 1 in the LPUART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
    /// Position: 9, Width: 1
    /// Access: read-only
    using CTSIF = BitField<9, 1>;
    constexpr uint32_t CTSIF_Pos = 9;
    constexpr uint32_t CTSIF_Msk = CTSIF::mask;
    /// Enumerated values for CTSIF
    namespace ctsif {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
    /// Position: 10, Width: 1
    /// Access: read-only
    using CTS = BitField<10, 1>;
    constexpr uint32_t CTS_Pos = 10;
    constexpr uint32_t CTS_Msk = CTS::mask;
    /// Enumerated values for CTS
    namespace cts {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
    /// Position: 16, Width: 1
    /// Access: read-only
    using BUSY = BitField<16, 1>;
    constexpr uint32_t BUSY_Pos = 16;
    constexpr uint32_t BUSY_Msk = BUSY::mask;
    /// Enumerated values for BUSY
    namespace busy {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register. An interrupt is generated if CMIEÂ =Â 1in the LPUART_CR1 register.
    /// Position: 17, Width: 1
    /// Access: read-only
    using CMF = BitField<17, 1>;
    constexpr uint32_t CMF_Pos = 17;
    constexpr uint32_t CMF_Msk = CMF::mask;
    /// Enumerated values for CMF
    namespace cmf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
    /// Position: 18, Width: 1
    /// Access: read-only
    using SBKF = BitField<18, 1>;
    constexpr uint32_t SBKF_Pos = 18;
    constexpr uint32_t SBKF_Msk = SBKF::mask;
    /// Enumerated values for SBKF
    namespace sbkf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receiver wakeup from Mute mode This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register. Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.
    /// Position: 19, Width: 1
    /// Access: read-only
    using RWU = BitField<19, 1>;
    constexpr uint32_t RWU_Pos = 19;
    constexpr uint32_t RWU_Msk = RWU::mask;
    /// Enumerated values for RWU
    namespace rwu {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register. An interrupt is generated if WUFIEÂ =Â 1 in the LPUART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value
    /// Position: 20, Width: 1
    /// Access: read-only
    using WUF = BitField<20, 1>;
    constexpr uint32_t WUF_Pos = 20;
    constexpr uint32_t WUF_Msk = WUF::mask;

    /// Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART. It can be used when an idle frame request is generated by writing TEÂ =Â 0, followed by TEÂ =Â 1 in the LPUART_CR1 register, in order to respect the TEÂ =Â 0 minimum period.
    /// Position: 21, Width: 1
    /// Access: read-only
    using TEACK = BitField<21, 1>;
    constexpr uint32_t TEACK_Pos = 21;
    constexpr uint32_t TEACK_Msk = TEACK::mask;

    /// Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART. It can be used to verify that the LPUART is ready for reception before entering low-power mode. Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.
    /// Position: 22, Width: 1
    /// Access: read-only
    using REACK = BitField<22, 1>;
    constexpr uint32_t REACK_Pos = 22;
    constexpr uint32_t REACK_Msk = REACK::mask;

    /// TXFIFO empty This bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register. An interrupt is generated if the TXFEIE bit Â =Â 1 (bit 30) in the LPUART_CR1 register.
    /// Position: 23, Width: 1
    /// Access: read-only
    using TXFE = BitField<23, 1>;
    constexpr uint32_t TXFE_Pos = 23;
    constexpr uint32_t TXFE_Msk = TXFE::mask;
    /// Enumerated values for TXFE
    namespace txfe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXFIFO full This bit is set by hardware when the number of received data corresponds to RXFIFOÂ sizeÂ +Â 1 (RXFIFO full + 1 data in the LPUART_RDR register. An interrupt is generated if the RXFFIE bit Â =Â 1 in the LPUART_CR1 register.
    /// Position: 24, Width: 1
    /// Access: read-only
    using RXFF = BitField<24, 1>;
    constexpr uint32_t RXFF_Pos = 24;
    constexpr uint32_t RXFF_Msk = RXFF::mask;
    /// Enumerated values for RXFF
    namespace rxff {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXFIFO threshold flag This bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit Â =Â 1 (bit 27) in the LPUART_CR3 register.
    /// Position: 26, Width: 1
    /// Access: read-only
    using RXFT = BitField<26, 1>;
    constexpr uint32_t RXFT_Pos = 26;
    constexpr uint32_t RXFT_Msk = RXFT::mask;
    /// Enumerated values for RXFT
    namespace rxft {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXFIFO threshold flag This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit Â =Â 1 (bit 31) in the LPUART_CR3 register.
    /// Position: 27, Width: 1
    /// Access: read-only
    using TXFT = BitField<27, 1>;
    constexpr uint32_t TXFT_Pos = 27;
    constexpr uint32_t TXFT_Msk = TXFT::mask;
    /// Enumerated values for TXFT
    namespace txft {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace lpuart_isr_enabled

/// LPUART_ISR_disabled - LPUART interrupt and status register [alternate]
namespace lpuart_isr_disabled {
    /// Parity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register. An interrupt is generated if PEIE = 1 in the LPUART_CR1 register. Note: This error is associated with the character in the LPUART_RDR.
    /// Position: 0, Width: 1
    /// Access: read-only
    using PE = BitField<0, 1>;
    constexpr uint32_t PE_Pos = 0;
    constexpr uint32_t PE_Msk = PE::mask;
    /// Enumerated values for PE
    namespace pe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIEÂ =Â 1 in the LPUART_CR1 register. Note: This error is associated with the character in the LPUART_RDR.
    /// Position: 1, Width: 1
    /// Access: read-only
    using FE = BitField<1, 1>;
    constexpr uint32_t FE_Pos = 1;
    constexpr uint32_t FE_Msk = FE::mask;
    /// Enumerated values for FE
    namespace fe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Start bit noise detection flag This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NECF bit in the LPUART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. This error is associated with the character in the LPUART_RDR.
    /// Position: 2, Width: 1
    /// Access: read-only
    using NE = BitField<2, 1>;
    constexpr uint32_t NE_Pos = 2;
    constexpr uint32_t NE_Msk = NE::mask;
    /// Enumerated values for NE
    namespace ne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register. An interrupt is generated if RXFNEIEÂ =Â 1 or EIE = 1 in the LPUART_CR1 register. Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.
    /// Position: 3, Width: 1
    /// Access: read-only
    using ORE = BitField<3, 1>;
    constexpr uint32_t ORE_Pos = 3;
    constexpr uint32_t ORE_Msk = ORE::mask;
    /// Enumerated values for ORE
    namespace ore {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Idle line detected This bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIEÂ =Â 1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register. Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MMEÂ =Â 1), IDLE is set if the LPUART is not mute (RWUÂ =Â 0), whatever the Mute mode selected by the WAKE bit. If RWUÂ =Â 1, IDLE is not set.
    /// Position: 4, Width: 1
    /// Access: read-only
    using IDLE = BitField<4, 1>;
    constexpr uint32_t IDLE_Pos = 4;
    constexpr uint32_t IDLE_Msk = IDLE::mask;
    /// Enumerated values for IDLE
    namespace idle {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register. An interrupt is generated if RXFNEIEÂ =Â 1 in the LPUART_CR1 register.
    /// Position: 5, Width: 1
    /// Access: read-only
    using RXFNE = BitField<5, 1>;
    constexpr uint32_t RXFNE_Pos = 5;
    constexpr uint32_t RXFNE_Msk = RXFNE::mask;
    /// Enumerated values for RXFNE
    namespace rxfne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmission complete This bit is set by hardware if the transmission of a frame containing data is complete and if TXFF is set. An interrupt is generated if TCIEÂ =Â 1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the TCCF in the LPUART_ICR register or by a write to the LPUART_TDR register. An interrupt is generated if TCIEÂ =Â 1 in the LPUART_CR1 register. Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.
    /// Position: 6, Width: 1
    /// Access: read-only
    using TC = BitField<6, 1>;
    constexpr uint32_t TC_Pos = 6;
    constexpr uint32_t TC_Msk = TC::mask;
    /// Enumerated values for TC
    namespace tc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXFIFO not full TXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR. The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time). An interrupt is generated if the TXFNFIE bit Â =Â 1 in the LPUART_CR1 register. Note: This bit is used during single buffer transmission.
    /// Position: 7, Width: 1
    /// Access: read-only
    using TXFNF = BitField<7, 1>;
    constexpr uint32_t TXFNF_Pos = 7;
    constexpr uint32_t TXFNF_Msk = TXFNF::mask;
    /// Enumerated values for TXFNF
    namespace txfnf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register. An interrupt is generated if CTSIEÂ =Â 1 in the LPUART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
    /// Position: 9, Width: 1
    /// Access: read-only
    using CTSIF = BitField<9, 1>;
    constexpr uint32_t CTSIF_Pos = 9;
    constexpr uint32_t CTSIF_Msk = CTSIF::mask;
    /// Enumerated values for CTSIF
    namespace ctsif {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
    /// Position: 10, Width: 1
    /// Access: read-only
    using CTS = BitField<10, 1>;
    constexpr uint32_t CTS_Pos = 10;
    constexpr uint32_t CTS_Msk = CTS::mask;
    /// Enumerated values for CTS
    namespace cts {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
    /// Position: 16, Width: 1
    /// Access: read-only
    using BUSY = BitField<16, 1>;
    constexpr uint32_t BUSY_Pos = 16;
    constexpr uint32_t BUSY_Msk = BUSY::mask;
    /// Enumerated values for BUSY
    namespace busy {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Character match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register. An interrupt is generated if CMIEÂ =Â 1in the LPUART_CR1 register.
    /// Position: 17, Width: 1
    /// Access: read-only
    using CMF = BitField<17, 1>;
    constexpr uint32_t CMF_Pos = 17;
    constexpr uint32_t CMF_Msk = CMF::mask;
    /// Enumerated values for CMF
    namespace cmf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Send break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
    /// Position: 18, Width: 1
    /// Access: read-only
    using SBKF = BitField<18, 1>;
    constexpr uint32_t SBKF_Pos = 18;
    constexpr uint32_t SBKF_Msk = SBKF::mask;
    /// Enumerated values for SBKF
    namespace sbkf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receiver wakeup from Mute mode This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register. Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.
    /// Position: 19, Width: 1
    /// Access: read-only
    using RWU = BitField<19, 1>;
    constexpr uint32_t RWU_Pos = 19;
    constexpr uint32_t RWU_Msk = RWU::mask;
    /// Enumerated values for RWU
    namespace rwu {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register. An interrupt is generated if WUFIEÂ =Â 1 in the LPUART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value
    /// Position: 20, Width: 1
    /// Access: read-only
    using WUF = BitField<20, 1>;
    constexpr uint32_t WUF_Pos = 20;
    constexpr uint32_t WUF_Msk = WUF::mask;

    /// Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART. It can be used when an idle frame request is generated by writing TEÂ =Â 0, followed by TEÂ =Â 1 in the LPUART_CR1 register, in order to respect the TEÂ =Â 0 minimum period.
    /// Position: 21, Width: 1
    /// Access: read-only
    using TEACK = BitField<21, 1>;
    constexpr uint32_t TEACK_Pos = 21;
    constexpr uint32_t TEACK_Msk = TEACK::mask;

    /// Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART. It can be used to verify that the LPUART is ready for reception before entering low-power mode. Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.
    /// Position: 22, Width: 1
    /// Access: read-only
    using REACK = BitField<22, 1>;
    constexpr uint32_t REACK_Pos = 22;
    constexpr uint32_t REACK_Msk = REACK::mask;

}  // namespace lpuart_isr_disabled

/// LPUART_ICR - LPUART interrupt flag clear register
namespace lpuart_icr {
    /// Parity error clear flag Writing 1 to this bit clears the PE flag in the LPUART_ISR register.
    /// Position: 0, Width: 1
    /// Access: write-only
    using PECF = BitField<0, 1>;
    constexpr uint32_t PECF_Pos = 0;
    constexpr uint32_t PECF_Msk = PECF::mask;

    /// Framing error clear flag Writing 1 to this bit clears the FE flag in the LPUART_ISR register.
    /// Position: 1, Width: 1
    /// Access: write-only
    using FECF = BitField<1, 1>;
    constexpr uint32_t FECF_Pos = 1;
    constexpr uint32_t FECF_Msk = FECF::mask;

    /// Noise detected clear flag Writing 1 to this bit clears the NE flag in the LPUART_ISR register.
    /// Position: 2, Width: 1
    /// Access: write-only
    using NECF = BitField<2, 1>;
    constexpr uint32_t NECF_Pos = 2;
    constexpr uint32_t NECF_Msk = NECF::mask;

    /// Overrun error clear flag Writing 1 to this bit clears the ORE flag in the LPUART_ISR register.
    /// Position: 3, Width: 1
    /// Access: write-only
    using ORECF = BitField<3, 1>;
    constexpr uint32_t ORECF_Pos = 3;
    constexpr uint32_t ORECF_Msk = ORECF::mask;

    /// Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the LPUART_ISR register.
    /// Position: 4, Width: 1
    /// Access: write-only
    using IDLECF = BitField<4, 1>;
    constexpr uint32_t IDLECF_Pos = 4;
    constexpr uint32_t IDLECF_Msk = IDLECF::mask;

    /// Transmission complete clear flag Writing 1 to this bit clears the TC flag in the LPUART_ISR register.
    /// Position: 6, Width: 1
    /// Access: write-only
    using TCCF = BitField<6, 1>;
    constexpr uint32_t TCCF_Pos = 6;
    constexpr uint32_t TCCF_Msk = TCCF::mask;

    /// CTS clear flag Writing 1 to this bit clears the CTSIF flag in the LPUART_ISR register.
    /// Position: 9, Width: 1
    /// Access: write-only
    using CTSCF = BitField<9, 1>;
    constexpr uint32_t CTSCF_Pos = 9;
    constexpr uint32_t CTSCF_Msk = CTSCF::mask;

    /// Character match clear flag Writing 1 to this bit clears the CMF flag in the LPUART_ISR register.
    /// Position: 17, Width: 1
    /// Access: write-only
    using CMCF = BitField<17, 1>;
    constexpr uint32_t CMCF_Pos = 17;
    constexpr uint32_t CMCF_Msk = CMCF::mask;

    /// Wakeup from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the LPUART_ISR register. Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
    /// Position: 20, Width: 1
    /// Access: write-only
    using WUCF = BitField<20, 1>;
    constexpr uint32_t WUCF_Pos = 20;
    constexpr uint32_t WUCF_Msk = WUCF::mask;

}  // namespace lpuart_icr

/// LPUART_RDR - LPUART receive data register
namespace lpuart_rdr {
    /// Receive data value Contains the received data character. The RDR register provides the parallel interface between the input shift register and the internal bus (see ). When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.
    /// Position: 0, Width: 9
    /// Access: read-only
    using RDR = BitField<0, 9>;
    constexpr uint32_t RDR_Pos = 0;
    constexpr uint32_t RDR_Msk = RDR::mask;

}  // namespace lpuart_rdr

/// LPUART_TDR - LPUART transmit data register
namespace lpuart_tdr {
    /// Transmit data value Contains the data character to be transmitted. The TDR register provides the parallel interface between the internal bus and the output shift register (see ). When transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity. Note: This register must be written only when TXE/TXFNFÂ =Â 1.
    /// Position: 0, Width: 9
    /// Access: read-write
    using TDR = BitField<0, 9>;
    constexpr uint32_t TDR_Pos = 0;
    constexpr uint32_t TDR_Msk = TDR::mask;

}  // namespace lpuart_tdr

/// LPUART_PRESC - LPUART prescaler register
namespace lpuart_presc {
    /// Clock prescaler The LPUART input clock can be divided by a prescaler: Remaining combinations: Reserved. Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.
    /// Position: 0, Width: 4
    /// Access: read-write
    using PRESCALER = BitField<0, 4>;
    constexpr uint32_t PRESCALER_Pos = 0;
    constexpr uint32_t PRESCALER_Msk = PRESCALER::mask;
    /// Enumerated values for PRESCALER
    namespace prescaler {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0xA = 10;
        constexpr uint32_t B_0xB = 11;
    }

}  // namespace lpuart_presc

}  // namespace alloy::hal::st::stm32g0::lpuart1
