/// Auto-generated bit field definitions for RTC
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::rtc {

using namespace alloy::hal::bitfields;

// ============================================================================
// RTC Bit Field Definitions
// ============================================================================

/// RTC_TR - RTC time register
namespace rtc_tr {
    /// Second units in BCD format
    /// Position: 0, Width: 4
    /// Access: read-write
    using SU = BitField<0, 4>;
    constexpr uint32_t SU_Pos = 0;
    constexpr uint32_t SU_Msk = SU::mask;

    /// Second tens in BCD format
    /// Position: 4, Width: 3
    /// Access: read-write
    using ST = BitField<4, 3>;
    constexpr uint32_t ST_Pos = 4;
    constexpr uint32_t ST_Msk = ST::mask;

    /// Minute units in BCD format
    /// Position: 8, Width: 4
    /// Access: read-write
    using MNU = BitField<8, 4>;
    constexpr uint32_t MNU_Pos = 8;
    constexpr uint32_t MNU_Msk = MNU::mask;

    /// Minute tens in BCD format
    /// Position: 12, Width: 3
    /// Access: read-write
    using MNT = BitField<12, 3>;
    constexpr uint32_t MNT_Pos = 12;
    constexpr uint32_t MNT_Msk = MNT::mask;

    /// Hour units in BCD format
    /// Position: 16, Width: 4
    /// Access: read-write
    using HU = BitField<16, 4>;
    constexpr uint32_t HU_Pos = 16;
    constexpr uint32_t HU_Msk = HU::mask;

    /// Hour tens in BCD format
    /// Position: 20, Width: 2
    /// Access: read-write
    using HT = BitField<20, 2>;
    constexpr uint32_t HT_Pos = 20;
    constexpr uint32_t HT_Msk = HT::mask;

    /// AM/PM notation
    /// Position: 22, Width: 1
    /// Access: read-write
    using PM = BitField<22, 1>;
    constexpr uint32_t PM_Pos = 22;
    constexpr uint32_t PM_Msk = PM::mask;
    /// Enumerated values for PM
    namespace pm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace rtc_tr

/// RTC_DR - RTC date register
namespace rtc_dr {
    /// Date units in BCD format
    /// Position: 0, Width: 4
    /// Access: read-write
    using DU = BitField<0, 4>;
    constexpr uint32_t DU_Pos = 0;
    constexpr uint32_t DU_Msk = DU::mask;

    /// Date tens in BCD format
    /// Position: 4, Width: 2
    /// Access: read-write
    using DT = BitField<4, 2>;
    constexpr uint32_t DT_Pos = 4;
    constexpr uint32_t DT_Msk = DT::mask;

    /// Month units in BCD format
    /// Position: 8, Width: 4
    /// Access: read-write
    using MU = BitField<8, 4>;
    constexpr uint32_t MU_Pos = 8;
    constexpr uint32_t MU_Msk = MU::mask;

    /// Month tens in BCD format
    /// Position: 12, Width: 1
    /// Access: read-write
    using MT = BitField<12, 1>;
    constexpr uint32_t MT_Pos = 12;
    constexpr uint32_t MT_Msk = MT::mask;

    /// Week day units ...
    /// Position: 13, Width: 3
    /// Access: read-write
    using WDU = BitField<13, 3>;
    constexpr uint32_t WDU_Pos = 13;
    constexpr uint32_t WDU_Msk = WDU::mask;
    /// Enumerated values for WDU
    namespace wdu {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Year units in BCD format
    /// Position: 16, Width: 4
    /// Access: read-write
    using YU = BitField<16, 4>;
    constexpr uint32_t YU_Pos = 16;
    constexpr uint32_t YU_Msk = YU::mask;

    /// Year tens in BCD format
    /// Position: 20, Width: 4
    /// Access: read-write
    using YT = BitField<20, 4>;
    constexpr uint32_t YT_Pos = 20;
    constexpr uint32_t YT_Msk = YT::mask;

}  // namespace rtc_dr

/// RTC_SSR - RTC sub second register
namespace rtc_ssr {
    /// Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
    /// Position: 0, Width: 16
    /// Access: read-only
    using SS = BitField<0, 16>;
    constexpr uint32_t SS_Pos = 0;
    constexpr uint32_t SS_Msk = SS::mask;

}  // namespace rtc_ssr

/// RTC_ICSR - RTC initialization control and status register
namespace rtc_icsr {
    /// Alarm A write flag This bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
    /// Position: 0, Width: 1
    /// Access: read-only
    using ALRAWF = BitField<0, 1>;
    constexpr uint32_t ALRAWF_Pos = 0;
    constexpr uint32_t ALRAWF_Msk = ALRAWF::mask;
    /// Enumerated values for ALRAWF
    namespace alrawf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm B write flag This bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
    /// Position: 1, Width: 1
    /// Access: read-only
    using ALRBWF = BitField<1, 1>;
    constexpr uint32_t ALRBWF_Pos = 1;
    constexpr uint32_t ALRBWF_Msk = ALRBWF::mask;
    /// Enumerated values for ALRBWF
    namespace alrbwf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wakeup timer write flag This bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
    /// Position: 2, Width: 1
    /// Access: read-only
    using WUTWF = BitField<2, 1>;
    constexpr uint32_t WUTWF_Pos = 2;
    constexpr uint32_t WUTWF_Msk = WUTWF::mask;
    /// Enumerated values for WUTWF
    namespace wutwf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
    /// Position: 3, Width: 1
    /// Access: read-only
    using SHPF = BitField<3, 1>;
    constexpr uint32_t SHPF_Pos = 3;
    constexpr uint32_t SHPF_Msk = SHPF::mask;
    /// Enumerated values for SHPF
    namespace shpf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (RTC domain reset state).
    /// Position: 4, Width: 1
    /// Access: read-only
    using INITS = BitField<4, 1>;
    constexpr uint32_t INITS_Pos = 4;
    constexpr uint32_t INITS_Msk = INITS::mask;
    /// Enumerated values for INITS
    namespace inits {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
    /// Position: 5, Width: 1
    /// Access: read-write
    using RSF = BitField<5, 1>;
    constexpr uint32_t RSF_Pos = 5;
    constexpr uint32_t RSF_Msk = RSF::mask;
    /// Enumerated values for RSF
    namespace rsf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
    /// Position: 6, Width: 1
    /// Access: read-only
    using INITF = BitField<6, 1>;
    constexpr uint32_t INITF_Pos = 6;
    constexpr uint32_t INITF_Msk = INITF::mask;
    /// Enumerated values for INITF
    namespace initf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Initialization mode
    /// Position: 7, Width: 1
    /// Access: read-write
    using INIT = BitField<7, 1>;
    constexpr uint32_t INIT_Pos = 7;
    constexpr uint32_t INIT_Msk = INIT::mask;
    /// Enumerated values for INIT
    namespace init {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to .
    /// Position: 16, Width: 1
    /// Access: read-only
    using RECALPF = BitField<16, 1>;
    constexpr uint32_t RECALPF_Pos = 16;
    constexpr uint32_t RECALPF_Msk = RECALPF::mask;

}  // namespace rtc_icsr

/// RTC_PRER - RTC prescaler register
namespace rtc_prer {
    /// Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
    /// Position: 0, Width: 15
    /// Access: read-write
    using PREDIV_S = BitField<0, 15>;
    constexpr uint32_t PREDIV_S_Pos = 0;
    constexpr uint32_t PREDIV_S_Msk = PREDIV_S::mask;

    /// Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
    /// Position: 16, Width: 7
    /// Access: read-write
    using PREDIV_A = BitField<16, 7>;
    constexpr uint32_t PREDIV_A_Pos = 16;
    constexpr uint32_t PREDIV_A_Msk = PREDIV_A::mask;

}  // namespace rtc_prer

/// RTC_WUTR - RTC wakeup timer register
namespace rtc_wutr {
    /// Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]Â +Â 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register. When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs between WUT and (WUT + 1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden.
    /// Position: 0, Width: 16
    /// Access: read-write
    using WUT = BitField<0, 16>;
    constexpr uint32_t WUT_Pos = 0;
    constexpr uint32_t WUT_Msk = WUT::mask;

}  // namespace rtc_wutr

/// RTC_CR - RTC control register
namespace rtc_cr {
    /// ck_wut wakeup clock selection 10x: ck_spre (usually 1Â Hz) clock is selected 11x: ck_spre (usually 1Â Hz) clock is selected and 216Â is added to the WUT counter value
    /// Position: 0, Width: 3
    /// Access: read-write
    using WUCKSEL = BitField<0, 3>;
    constexpr uint32_t WUCKSEL_Pos = 0;
    constexpr uint32_t WUCKSEL_Msk = WUCKSEL::mask;
    /// Enumerated values for WUCKSEL
    namespace wucksel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Timestamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
    /// Position: 3, Width: 1
    /// Access: read-write
    using TSEDGE = BitField<3, 1>;
    constexpr uint32_t TSEDGE_Pos = 3;
    constexpr uint32_t TSEDGE_Msk = TSEDGE::mask;
    /// Enumerated values for TSEDGE
    namespace tsedge {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RTC_REFIN reference clock detection enable (50 or 60Â Hz) Note: PREDIV_S must be 0x00FF.
    /// Position: 4, Width: 1
    /// Access: read-write
    using REFCKON = BitField<4, 1>;
    constexpr uint32_t REFCKON_Pos = 4;
    constexpr uint32_t REFCKON_Msk = REFCKON::mask;
    /// Enumerated values for REFCKON
    namespace refckon {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Bypass the shadow registers Note: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
    /// Position: 5, Width: 1
    /// Access: read-write
    using BYPSHAD = BitField<5, 1>;
    constexpr uint32_t BYPSHAD_Pos = 5;
    constexpr uint32_t BYPSHAD_Msk = BYPSHAD::mask;
    /// Enumerated values for BYPSHAD
    namespace bypshad {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Hour format
    /// Position: 6, Width: 1
    /// Access: read-write
    using FMT = BitField<6, 1>;
    constexpr uint32_t FMT_Pos = 6;
    constexpr uint32_t FMT_Msk = FMT::mask;
    /// Enumerated values for FMT
    namespace fmt {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm A enable
    /// Position: 8, Width: 1
    /// Access: read-write
    using ALRAE = BitField<8, 1>;
    constexpr uint32_t ALRAE_Pos = 8;
    constexpr uint32_t ALRAE_Msk = ALRAE::mask;
    /// Enumerated values for ALRAE
    namespace alrae {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm B enable
    /// Position: 9, Width: 1
    /// Access: read-write
    using ALRBE = BitField<9, 1>;
    constexpr uint32_t ALRBE_Pos = 9;
    constexpr uint32_t ALRBE_Msk = ALRBE::mask;
    /// Enumerated values for ALRBE
    namespace alrbe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wakeup timer enable Note: When the wakeup timer is disabled, wait for WUTWF=1 before enabling it again.
    /// Position: 10, Width: 1
    /// Access: read-write
    using WUTE = BitField<10, 1>;
    constexpr uint32_t WUTE_Pos = 10;
    constexpr uint32_t WUTE_Msk = WUTE::mask;
    /// Enumerated values for WUTE
    namespace wute {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// timestamp enable
    /// Position: 11, Width: 1
    /// Access: read-write
    using TSE = BitField<11, 1>;
    constexpr uint32_t TSE_Pos = 11;
    constexpr uint32_t TSE_Msk = TSE::mask;
    /// Enumerated values for TSE
    namespace tse {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm A interrupt enable
    /// Position: 12, Width: 1
    /// Access: read-write
    using ALRAIE = BitField<12, 1>;
    constexpr uint32_t ALRAIE_Pos = 12;
    constexpr uint32_t ALRAIE_Msk = ALRAIE::mask;
    /// Enumerated values for ALRAIE
    namespace alraie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm B interrupt enable
    /// Position: 13, Width: 1
    /// Access: read-write
    using ALRBIE = BitField<13, 1>;
    constexpr uint32_t ALRBIE_Pos = 13;
    constexpr uint32_t ALRBIE_Msk = ALRBIE::mask;
    /// Enumerated values for ALRBIE
    namespace alrbie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wakeup timer interrupt enable
    /// Position: 14, Width: 1
    /// Access: read-write
    using WUTIE = BitField<14, 1>;
    constexpr uint32_t WUTIE_Pos = 14;
    constexpr uint32_t WUTIE_Msk = WUTIE::mask;
    /// Enumerated values for WUTIE
    namespace wutie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Timestamp interrupt enable
    /// Position: 15, Width: 1
    /// Access: read-write
    using TSIE = BitField<15, 1>;
    constexpr uint32_t TSIE_Pos = 15;
    constexpr uint32_t TSIE_Msk = TSIE::mask;
    /// Enumerated values for TSIE
    namespace tsie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
    /// Position: 16, Width: 1
    /// Access: write-only
    using ADD1H = BitField<16, 1>;
    constexpr uint32_t ADD1H_Pos = 16;
    constexpr uint32_t ADD1H_Msk = ADD1H::mask;
    /// Enumerated values for ADD1H
    namespace add1h {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
    /// Position: 17, Width: 1
    /// Access: write-only
    using SUB1H = BitField<17, 1>;
    constexpr uint32_t SUB1H_Pos = 17;
    constexpr uint32_t SUB1H_Msk = SUB1H::mask;
    /// Enumerated values for SUB1H
    namespace sub1h {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
    /// Position: 18, Width: 1
    /// Access: read-write
    using BKP = BitField<18, 1>;
    constexpr uint32_t BKP_Pos = 18;
    constexpr uint32_t BKP_Msk = BKP::mask;

    /// Calibration output selection When COE = 1, this bit selects which signal is output on CALIB. These frequencies are valid for RTCCLK at 32.768Â kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to .
    /// Position: 19, Width: 1
    /// Access: read-write
    using COSEL = BitField<19, 1>;
    constexpr uint32_t COSEL_Pos = 19;
    constexpr uint32_t COSEL_Msk = COSEL::mask;
    /// Enumerated values for COSEL
    namespace cosel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output polarity This bit is used to configure the polarity of TAMPALRM output.
    /// Position: 20, Width: 1
    /// Access: read-write
    using POL = BitField<20, 1>;
    constexpr uint32_t POL_Pos = 20;
    constexpr uint32_t POL_Msk = POL::mask;
    /// Enumerated values for POL
    namespace pol {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output selection These bits are used to select the flag to be routed to TAMPALRM output.
    /// Position: 21, Width: 2
    /// Access: read-write
    using OSEL = BitField<21, 2>;
    constexpr uint32_t OSEL_Pos = 21;
    constexpr uint32_t OSEL_Msk = OSEL::mask;
    /// Enumerated values for OSEL
    namespace osel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Calibration output enable This bit enables the CALIB output
    /// Position: 23, Width: 1
    /// Access: read-write
    using COE = BitField<23, 1>;
    constexpr uint32_t COE_Pos = 23;
    constexpr uint32_t COE_Msk = COE::mask;
    /// Enumerated values for COE
    namespace coe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// timestamp on internal event enable
    /// Position: 24, Width: 1
    /// Access: read-write
    using ITSE = BitField<24, 1>;
    constexpr uint32_t ITSE_Pos = 24;
    constexpr uint32_t ITSE_Msk = ITSE::mask;
    /// Enumerated values for ITSE
    namespace itse {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Activate timestamp on tamper detection event TAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set after the tamper flags, therefore if TAMPTS and TSIE are set, it is recommended to disable the tamper interrupts in order to avoid servicing 2 interrupts.
    /// Position: 25, Width: 1
    /// Access: read-write
    using TAMPTS = BitField<25, 1>;
    constexpr uint32_t TAMPTS_Pos = 25;
    constexpr uint32_t TAMPTS_Msk = TAMPTS::mask;
    /// Enumerated values for TAMPTS
    namespace tampts {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tamper detection output enable on TAMPALRM
    /// Position: 26, Width: 1
    /// Access: read-write
    using TAMPOE = BitField<26, 1>;
    constexpr uint32_t TAMPOE_Pos = 26;
    constexpr uint32_t TAMPOE_Msk = TAMPOE::mask;
    /// Enumerated values for TAMPOE
    namespace tampoe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TAMPALRM pull-up enable
    /// Position: 29, Width: 1
    /// Access: read-write
    using TAMPALRM_PU = BitField<29, 1>;
    constexpr uint32_t TAMPALRM_PU_Pos = 29;
    constexpr uint32_t TAMPALRM_PU_Msk = TAMPALRM_PU::mask;
    /// Enumerated values for TAMPALRM_PU
    namespace tampalrm_pu {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TAMPALRM output type
    /// Position: 30, Width: 1
    /// Access: read-write
    using TAMPALRM_TYPE = BitField<30, 1>;
    constexpr uint32_t TAMPALRM_TYPE_Pos = 30;
    constexpr uint32_t TAMPALRM_TYPE_Msk = TAMPALRM_TYPE::mask;
    /// Enumerated values for TAMPALRM_TYPE
    namespace tampalrm_type {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RTC_OUT2 output enable Setting this bit allows to remap the RTC outputs on RTC_OUT2 as follows: OUT2EN = 0: RTC output 2 disable If OSEL â 00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1 If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1 OUT2EN = 1: RTC output 2 enable If (OSEL â 00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2 If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2 If (OSELâ 00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1.
    /// Position: 31, Width: 1
    /// Access: read-write
    using OUT2EN = BitField<31, 1>;
    constexpr uint32_t OUT2EN_Pos = 31;
    constexpr uint32_t OUT2EN_Msk = OUT2EN::mask;

}  // namespace rtc_cr

/// RTC_WPR - RTC write protection register
namespace rtc_wpr {
    /// Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to for a description of how to unlock RTC register write protection.
    /// Position: 0, Width: 8
    /// Access: write-only
    using KEY = BitField<0, 8>;
    constexpr uint32_t KEY_Pos = 0;
    constexpr uint32_t KEY_Msk = KEY::mask;

}  // namespace rtc_wpr

/// RTC_CALR - RTC calibration register
namespace rtc_calr {
    /// Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768Â Hz). This decreases the frequency of the calendar with a resolution of 0.9537Â ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See .
    /// Position: 0, Width: 9
    /// Access: read-write
    using CALM = BitField<0, 9>;
    constexpr uint32_t CALM_Pos = 0;
    constexpr uint32_t CALM_Msk = CALM::mask;

    /// Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1. Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration.
    /// Position: 13, Width: 1
    /// Access: read-write
    using CALW16 = BitField<13, 1>;
    constexpr uint32_t CALW16_Pos = 13;
    constexpr uint32_t CALW16_Msk = CALW16::mask;

    /// Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration.
    /// Position: 14, Width: 1
    /// Access: read-write
    using CALW8 = BitField<14, 1>;
    constexpr uint32_t CALW8_Pos = 14;
    constexpr uint32_t CALW8_Msk = CALW8::mask;

    /// Increase frequency of RTC by 488.5Â ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768Â Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 Ã CALP) - CALM. Refer to .
    /// Position: 15, Width: 1
    /// Access: read-write
    using CALP = BitField<15, 1>;
    constexpr uint32_t CALP_Pos = 15;
    constexpr uint32_t CALP_Msk = CALP::mask;
    /// Enumerated values for CALP
    namespace calp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace rtc_calr

/// RTC_SHIFTR - RTC shift control register
namespace rtc_shiftr {
    /// Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.
    /// Position: 0, Width: 15
    /// Access: write-only
    using SUBFS = BitField<0, 15>;
    constexpr uint32_t SUBFS_Pos = 0;
    constexpr uint32_t SUBFS_Msk = SUBFS::mask;

    /// Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
    /// Position: 31, Width: 1
    /// Access: write-only
    using ADD1S = BitField<31, 1>;
    constexpr uint32_t ADD1S_Pos = 31;
    constexpr uint32_t ADD1S_Msk = ADD1S::mask;
    /// Enumerated values for ADD1S
    namespace add1s {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace rtc_shiftr

/// RTC_TSTR - RTC timestamp time register
namespace rtc_tstr {
    /// Second units in BCD format.
    /// Position: 0, Width: 4
    /// Access: read-only
    using SU = BitField<0, 4>;
    constexpr uint32_t SU_Pos = 0;
    constexpr uint32_t SU_Msk = SU::mask;

    /// Second tens in BCD format.
    /// Position: 4, Width: 3
    /// Access: read-only
    using ST = BitField<4, 3>;
    constexpr uint32_t ST_Pos = 4;
    constexpr uint32_t ST_Msk = ST::mask;

    /// Minute units in BCD format.
    /// Position: 8, Width: 4
    /// Access: read-only
    using MNU = BitField<8, 4>;
    constexpr uint32_t MNU_Pos = 8;
    constexpr uint32_t MNU_Msk = MNU::mask;

    /// Minute tens in BCD format.
    /// Position: 12, Width: 3
    /// Access: read-only
    using MNT = BitField<12, 3>;
    constexpr uint32_t MNT_Pos = 12;
    constexpr uint32_t MNT_Msk = MNT::mask;

    /// Hour units in BCD format.
    /// Position: 16, Width: 4
    /// Access: read-only
    using HU = BitField<16, 4>;
    constexpr uint32_t HU_Pos = 16;
    constexpr uint32_t HU_Msk = HU::mask;

    /// Hour tens in BCD format.
    /// Position: 20, Width: 2
    /// Access: read-only
    using HT = BitField<20, 2>;
    constexpr uint32_t HT_Pos = 20;
    constexpr uint32_t HT_Msk = HT::mask;

    /// AM/PM notation
    /// Position: 22, Width: 1
    /// Access: read-only
    using PM = BitField<22, 1>;
    constexpr uint32_t PM_Pos = 22;
    constexpr uint32_t PM_Msk = PM::mask;
    /// Enumerated values for PM
    namespace pm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace rtc_tstr

/// RTC_TSDR - RTC timestamp date register
namespace rtc_tsdr {
    /// Date units in BCD format
    /// Position: 0, Width: 4
    /// Access: read-only
    using DU = BitField<0, 4>;
    constexpr uint32_t DU_Pos = 0;
    constexpr uint32_t DU_Msk = DU::mask;

    /// Date tens in BCD format
    /// Position: 4, Width: 2
    /// Access: read-only
    using DT = BitField<4, 2>;
    constexpr uint32_t DT_Pos = 4;
    constexpr uint32_t DT_Msk = DT::mask;

    /// Month units in BCD format
    /// Position: 8, Width: 4
    /// Access: read-only
    using MU = BitField<8, 4>;
    constexpr uint32_t MU_Pos = 8;
    constexpr uint32_t MU_Msk = MU::mask;

    /// Month tens in BCD format
    /// Position: 12, Width: 1
    /// Access: read-only
    using MT = BitField<12, 1>;
    constexpr uint32_t MT_Pos = 12;
    constexpr uint32_t MT_Msk = MT::mask;

    /// Week day units
    /// Position: 13, Width: 3
    /// Access: read-only
    using WDU = BitField<13, 3>;
    constexpr uint32_t WDU_Pos = 13;
    constexpr uint32_t WDU_Msk = WDU::mask;

}  // namespace rtc_tsdr

/// RTC_TSSSR - RTC timestamp sub second register
namespace rtc_tsssr {
    /// Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
    /// Position: 0, Width: 16
    /// Access: read-only
    using SS = BitField<0, 16>;
    constexpr uint32_t SS_Pos = 0;
    constexpr uint32_t SS_Msk = SS::mask;

}  // namespace rtc_tsssr

/// RTC_ALRMAR - RTC alarm A register
namespace rtc_alrmar {
    /// Second units in BCD format.
    /// Position: 0, Width: 4
    /// Access: read-write
    using SU = BitField<0, 4>;
    constexpr uint32_t SU_Pos = 0;
    constexpr uint32_t SU_Msk = SU::mask;

    /// Second tens in BCD format.
    /// Position: 4, Width: 3
    /// Access: read-write
    using ST = BitField<4, 3>;
    constexpr uint32_t ST_Pos = 4;
    constexpr uint32_t ST_Msk = ST::mask;

    /// Alarm A seconds mask
    /// Position: 7, Width: 1
    /// Access: read-write
    using MSK1 = BitField<7, 1>;
    constexpr uint32_t MSK1_Pos = 7;
    constexpr uint32_t MSK1_Msk = MSK1::mask;
    /// Enumerated values for MSK1
    namespace msk1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Minute units in BCD format
    /// Position: 8, Width: 4
    /// Access: read-write
    using MNU = BitField<8, 4>;
    constexpr uint32_t MNU_Pos = 8;
    constexpr uint32_t MNU_Msk = MNU::mask;

    /// Minute tens in BCD format
    /// Position: 12, Width: 3
    /// Access: read-write
    using MNT = BitField<12, 3>;
    constexpr uint32_t MNT_Pos = 12;
    constexpr uint32_t MNT_Msk = MNT::mask;

    /// Alarm A minutes mask
    /// Position: 15, Width: 1
    /// Access: read-write
    using MSK2 = BitField<15, 1>;
    constexpr uint32_t MSK2_Pos = 15;
    constexpr uint32_t MSK2_Msk = MSK2::mask;
    /// Enumerated values for MSK2
    namespace msk2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Hour units in BCD format
    /// Position: 16, Width: 4
    /// Access: read-write
    using HU = BitField<16, 4>;
    constexpr uint32_t HU_Pos = 16;
    constexpr uint32_t HU_Msk = HU::mask;

    /// Hour tens in BCD format
    /// Position: 20, Width: 2
    /// Access: read-write
    using HT = BitField<20, 2>;
    constexpr uint32_t HT_Pos = 20;
    constexpr uint32_t HT_Msk = HT::mask;

    /// AM/PM notation
    /// Position: 22, Width: 1
    /// Access: read-write
    using PM = BitField<22, 1>;
    constexpr uint32_t PM_Pos = 22;
    constexpr uint32_t PM_Msk = PM::mask;
    /// Enumerated values for PM
    namespace pm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm A hours mask
    /// Position: 23, Width: 1
    /// Access: read-write
    using MSK3 = BitField<23, 1>;
    constexpr uint32_t MSK3_Pos = 23;
    constexpr uint32_t MSK3_Msk = MSK3::mask;
    /// Enumerated values for MSK3
    namespace msk3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Date units or day in BCD format
    /// Position: 24, Width: 4
    /// Access: read-write
    using DU = BitField<24, 4>;
    constexpr uint32_t DU_Pos = 24;
    constexpr uint32_t DU_Msk = DU::mask;

    /// Date tens in BCD format
    /// Position: 28, Width: 2
    /// Access: read-write
    using DT = BitField<28, 2>;
    constexpr uint32_t DT_Pos = 28;
    constexpr uint32_t DT_Msk = DT::mask;

    /// Week day selection
    /// Position: 30, Width: 1
    /// Access: read-write
    using WDSEL = BitField<30, 1>;
    constexpr uint32_t WDSEL_Pos = 30;
    constexpr uint32_t WDSEL_Msk = WDSEL::mask;
    /// Enumerated values for WDSEL
    namespace wdsel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm A date mask
    /// Position: 31, Width: 1
    /// Access: read-write
    using MSK4 = BitField<31, 1>;
    constexpr uint32_t MSK4_Pos = 31;
    constexpr uint32_t MSK4_Msk = MSK4::mask;
    /// Enumerated values for MSK4
    namespace msk4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace rtc_alrmar

/// RTC_ALRMASSR - RTC alarm A sub second register
namespace rtc_alrmassr {
    /// Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
    /// Position: 0, Width: 15
    /// Access: read-write
    using SS = BitField<0, 15>;
    constexpr uint32_t SS_Pos = 0;
    constexpr uint32_t SS_Msk = SS::mask;

    /// Mask the most-significant bits starting at this bit 2: SS[14:2] are don't care in alarm A comparison. Only SS[1:0] are compared. 3: SS[14:3] are don't care in alarm A comparison. Only SS[2:0] are compared. ... 12: SS[14:12] are don't care in alarm A comparison. SS[11:0] are compared. 13: SS[14:13] are don't care in alarm A comparison. SS[12:0] are compared. 14: SS[14] is don't care in alarm A comparison. SS[13:0] are compared. 15: All 15 SS bits are compared and must match to activate alarm. The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. Note: The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    /// Position: 24, Width: 4
    /// Access: read-write
    using MASKSS = BitField<24, 4>;
    constexpr uint32_t MASKSS_Pos = 24;
    constexpr uint32_t MASKSS_Msk = MASKSS::mask;
    /// Enumerated values for MASKSS
    namespace maskss {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace rtc_alrmassr

/// RTC_ALRMBR - RTC alarm B register
namespace rtc_alrmbr {
    /// Second units in BCD format
    /// Position: 0, Width: 4
    /// Access: read-write
    using SU = BitField<0, 4>;
    constexpr uint32_t SU_Pos = 0;
    constexpr uint32_t SU_Msk = SU::mask;

    /// Second tens in BCD format
    /// Position: 4, Width: 3
    /// Access: read-write
    using ST = BitField<4, 3>;
    constexpr uint32_t ST_Pos = 4;
    constexpr uint32_t ST_Msk = ST::mask;

    /// Alarm B seconds mask
    /// Position: 7, Width: 1
    /// Access: read-write
    using MSK1 = BitField<7, 1>;
    constexpr uint32_t MSK1_Pos = 7;
    constexpr uint32_t MSK1_Msk = MSK1::mask;
    /// Enumerated values for MSK1
    namespace msk1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Minute units in BCD format
    /// Position: 8, Width: 4
    /// Access: read-write
    using MNU = BitField<8, 4>;
    constexpr uint32_t MNU_Pos = 8;
    constexpr uint32_t MNU_Msk = MNU::mask;

    /// Minute tens in BCD format
    /// Position: 12, Width: 3
    /// Access: read-write
    using MNT = BitField<12, 3>;
    constexpr uint32_t MNT_Pos = 12;
    constexpr uint32_t MNT_Msk = MNT::mask;

    /// Alarm B minutes mask
    /// Position: 15, Width: 1
    /// Access: read-write
    using MSK2 = BitField<15, 1>;
    constexpr uint32_t MSK2_Pos = 15;
    constexpr uint32_t MSK2_Msk = MSK2::mask;
    /// Enumerated values for MSK2
    namespace msk2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Hour units in BCD format
    /// Position: 16, Width: 4
    /// Access: read-write
    using HU = BitField<16, 4>;
    constexpr uint32_t HU_Pos = 16;
    constexpr uint32_t HU_Msk = HU::mask;

    /// Hour tens in BCD format
    /// Position: 20, Width: 2
    /// Access: read-write
    using HT = BitField<20, 2>;
    constexpr uint32_t HT_Pos = 20;
    constexpr uint32_t HT_Msk = HT::mask;

    /// AM/PM notation
    /// Position: 22, Width: 1
    /// Access: read-write
    using PM = BitField<22, 1>;
    constexpr uint32_t PM_Pos = 22;
    constexpr uint32_t PM_Msk = PM::mask;
    /// Enumerated values for PM
    namespace pm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm B hours mask
    /// Position: 23, Width: 1
    /// Access: read-write
    using MSK3 = BitField<23, 1>;
    constexpr uint32_t MSK3_Pos = 23;
    constexpr uint32_t MSK3_Msk = MSK3::mask;
    /// Enumerated values for MSK3
    namespace msk3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Date units or day in BCD format
    /// Position: 24, Width: 4
    /// Access: read-write
    using DU = BitField<24, 4>;
    constexpr uint32_t DU_Pos = 24;
    constexpr uint32_t DU_Msk = DU::mask;

    /// Date tens in BCD format
    /// Position: 28, Width: 2
    /// Access: read-write
    using DT = BitField<28, 2>;
    constexpr uint32_t DT_Pos = 28;
    constexpr uint32_t DT_Msk = DT::mask;

    /// Week day selection
    /// Position: 30, Width: 1
    /// Access: read-write
    using WDSEL = BitField<30, 1>;
    constexpr uint32_t WDSEL_Pos = 30;
    constexpr uint32_t WDSEL_Msk = WDSEL::mask;
    /// Enumerated values for WDSEL
    namespace wdsel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Alarm B date mask
    /// Position: 31, Width: 1
    /// Access: read-write
    using MSK4 = BitField<31, 1>;
    constexpr uint32_t MSK4_Pos = 31;
    constexpr uint32_t MSK4_Msk = MSK4::mask;
    /// Enumerated values for MSK4
    namespace msk4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace rtc_alrmbr

/// RTC_ALRMBSSR - RTC alarm B sub second register
namespace rtc_alrmbssr {
    /// Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
    /// Position: 0, Width: 15
    /// Access: read-write
    using SS = BitField<0, 15>;
    constexpr uint32_t SS_Pos = 0;
    constexpr uint32_t SS_Msk = SS::mask;

    /// Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    /// Position: 24, Width: 4
    /// Access: read-write
    using MASKSS = BitField<24, 4>;
    constexpr uint32_t MASKSS_Pos = 24;
    constexpr uint32_t MASKSS_Msk = MASKSS::mask;
    /// Enumerated values for MASKSS
    namespace maskss {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0xC = 12;
        constexpr uint32_t B_0xD = 13;
        constexpr uint32_t B_0xE = 14;
        constexpr uint32_t B_0xF = 15;
    }

}  // namespace rtc_alrmbssr

/// RTC_SR - RTC status register
namespace rtc_sr {
    /// Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
    /// Position: 0, Width: 1
    /// Access: read-only
    using ALRAF = BitField<0, 1>;
    constexpr uint32_t ALRAF_Pos = 0;
    constexpr uint32_t ALRAF_Msk = ALRAF::mask;

    /// Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR).
    /// Position: 1, Width: 1
    /// Access: read-only
    using ALRBF = BitField<1, 1>;
    constexpr uint32_t ALRBF_Pos = 1;
    constexpr uint32_t ALRBF_Msk = ALRBF::mask;

    /// Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
    /// Position: 2, Width: 1
    /// Access: read-only
    using WUTF = BitField<2, 1>;
    constexpr uint32_t WUTF_Pos = 2;
    constexpr uint32_t WUTF_Msk = WUTF::mask;

    /// Timestamp flag This flag is set by hardware when a timestamp event occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
    /// Position: 3, Width: 1
    /// Access: read-only
    using TSF = BitField<3, 1>;
    constexpr uint32_t TSF_Pos = 3;
    constexpr uint32_t TSF_Msk = TSF::mask;

    /// Timestamp overflow flag This flag is set by hardware when a timestamp event occurs while TSF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
    /// Position: 4, Width: 1
    /// Access: read-only
    using TSOVF = BitField<4, 1>;
    constexpr uint32_t TSOVF_Pos = 4;
    constexpr uint32_t TSOVF_Msk = TSOVF::mask;

    /// Internal timestamp flag This flag is set by hardware when a timestamp on the internal event occurs.
    /// Position: 5, Width: 1
    /// Access: read-only
    using ITSF = BitField<5, 1>;
    constexpr uint32_t ITSF_Pos = 5;
    constexpr uint32_t ITSF_Msk = ITSF::mask;

}  // namespace rtc_sr

/// RTC_MISR - RTC masked interrupt status register
namespace rtc_misr {
    /// Alarm A masked flag This flag is set by hardware when the alarm A interrupt occurs.
    /// Position: 0, Width: 1
    /// Access: read-only
    using ALRAMF = BitField<0, 1>;
    constexpr uint32_t ALRAMF_Pos = 0;
    constexpr uint32_t ALRAMF_Msk = ALRAMF::mask;

    /// Alarm B masked flag This flag is set by hardware when the alarm B interrupt occurs.
    /// Position: 1, Width: 1
    /// Access: read-only
    using ALRBMF = BitField<1, 1>;
    constexpr uint32_t ALRBMF_Pos = 1;
    constexpr uint32_t ALRBMF_Msk = ALRBMF::mask;

    /// Wakeup timer masked flag This flag is set by hardware when the wakeup timer interrupt occurs. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
    /// Position: 2, Width: 1
    /// Access: read-only
    using WUTMF = BitField<2, 1>;
    constexpr uint32_t WUTMF_Pos = 2;
    constexpr uint32_t WUTMF_Msk = WUTMF::mask;

    /// Timestamp masked flag This flag is set by hardware when a timestamp interrupt occurs. If ITSF flag is set, TSF must be cleared together with ITSF.
    /// Position: 3, Width: 1
    /// Access: read-only
    using TSMF = BitField<3, 1>;
    constexpr uint32_t TSMF_Pos = 3;
    constexpr uint32_t TSMF_Msk = TSMF::mask;

    /// Timestamp overflow masked flag This flag is set by hardware when a timestamp interrupt occurs while TSMF is already set. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
    /// Position: 4, Width: 1
    /// Access: read-only
    using TSOVMF = BitField<4, 1>;
    constexpr uint32_t TSOVMF_Pos = 4;
    constexpr uint32_t TSOVMF_Msk = TSOVMF::mask;

    /// Internal timestamp masked flag This flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised.
    /// Position: 5, Width: 1
    /// Access: read-only
    using ITSMF = BitField<5, 1>;
    constexpr uint32_t ITSMF_Pos = 5;
    constexpr uint32_t ITSMF_Msk = ITSMF::mask;

}  // namespace rtc_misr

/// RTC_SCR - RTC status clear register
namespace rtc_scr {
    /// Clear alarm A flag Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
    /// Position: 0, Width: 1
    /// Access: write-only
    using CALRAF = BitField<0, 1>;
    constexpr uint32_t CALRAF_Pos = 0;
    constexpr uint32_t CALRAF_Msk = CALRAF::mask;

    /// Clear alarm B flag Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
    /// Position: 1, Width: 1
    /// Access: write-only
    using CALRBF = BitField<1, 1>;
    constexpr uint32_t CALRBF_Pos = 1;
    constexpr uint32_t CALRBF_Msk = CALRBF::mask;

    /// Clear wakeup timer flag Writing 1 in this bit clears the WUTF bit in the RTC_SR register.
    /// Position: 2, Width: 1
    /// Access: write-only
    using CWUTF = BitField<2, 1>;
    constexpr uint32_t CWUTF_Pos = 2;
    constexpr uint32_t CWUTF_Msk = CWUTF::mask;

    /// Clear timestamp flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. If ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF.
    /// Position: 3, Width: 1
    /// Access: write-only
    using CTSF = BitField<3, 1>;
    constexpr uint32_t CTSF_Pos = 3;
    constexpr uint32_t CTSF_Msk = CTSF::mask;

    /// Clear timestamp overflow flag Writing 1 in this bit clears the TSOVF bit in the RTC_SR register. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
    /// Position: 4, Width: 1
    /// Access: write-only
    using CTSOVF = BitField<4, 1>;
    constexpr uint32_t CTSOVF_Pos = 4;
    constexpr uint32_t CTSOVF_Msk = CTSOVF::mask;

    /// Clear internal timestamp flag Writing 1 in this bit clears the ITSF bit in the RTC_SR register.
    /// Position: 5, Width: 1
    /// Access: write-only
    using CITSF = BitField<5, 1>;
    constexpr uint32_t CITSF_Pos = 5;
    constexpr uint32_t CITSF_Msk = CITSF::mask;

}  // namespace rtc_scr

}  // namespace alloy::hal::st::stm32g0::rtc
