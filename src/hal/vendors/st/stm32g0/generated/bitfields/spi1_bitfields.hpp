/// Auto-generated bit field definitions for SPI1
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::spi1 {

using namespace alloy::hal::bitfields;

// ============================================================================
// SPI1 Bit Field Definitions
// ============================================================================

/// SPI_CR1 - SPI control register 1
namespace spi_cr1 {
    /// Clock phase Note: This bit should not be changed when communication is ongoing. This bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CPHA = BitField<0, 1>;
    constexpr uint32_t CPHA_Pos = 0;
    constexpr uint32_t CPHA_Msk = CPHA::mask;
    /// Enumerated values for CPHA
    namespace cpha {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Clock polarity Note: This bit should not be changed when communication is ongoing. This bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode.
    /// Position: 1, Width: 1
    /// Access: read-write
    using CPOL = BitField<1, 1>;
    constexpr uint32_t CPOL_Pos = 1;
    constexpr uint32_t CPOL_Msk = CPOL::mask;
    /// Enumerated values for CPOL
    namespace cpol {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Master selection Note: This bit should not be changed when communication is ongoing. This bit is not used in I2S mode.
    /// Position: 2, Width: 1
    /// Access: read-write
    using MSTR = BitField<2, 1>;
    constexpr uint32_t MSTR_Pos = 2;
    constexpr uint32_t MSTR_Msk = MSTR::mask;
    /// Enumerated values for MSTR
    namespace mstr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Baud rate control Note: These bits should not be changed when communication is ongoing. These bits are not used in I2S mode.
    /// Position: 3, Width: 3
    /// Access: read-write
    using BR = BitField<3, 3>;
    constexpr uint32_t BR_Pos = 3;
    constexpr uint32_t BR_Msk = BR::mask;
    /// Enumerated values for BR
    namespace br {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// SPI enable Note: When disabling the SPI, follow the procedure described in SPI on pageÂ 1021. This bit is not used in I2S mode.
    /// Position: 6, Width: 1
    /// Access: read-write
    using SPE = BitField<6, 1>;
    constexpr uint32_t SPE_Pos = 6;
    constexpr uint32_t SPE_Msk = SPE::mask;
    /// Enumerated values for SPE
    namespace spe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Frame format Note: 1. This bit should not be changed when communication is ongoing. 2. This bit is not used in I2S mode and SPI TI mode.
    /// Position: 7, Width: 1
    /// Access: read-write
    using LSBFIRST = BitField<7, 1>;
    constexpr uint32_t LSBFIRST_Pos = 7;
    constexpr uint32_t LSBFIRST_Msk = LSBFIRST::mask;
    /// Enumerated values for LSBFIRST
    namespace lsbfirst {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Internal slave select This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored. Note: This bit is not used in I2S mode and SPI TI mode.
    /// Position: 8, Width: 1
    /// Access: read-write
    using SSI = BitField<8, 1>;
    constexpr uint32_t SSI_Pos = 8;
    constexpr uint32_t SSI_Msk = SSI::mask;

    /// Software slave management When the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit. Note: This bit is not used in I2S mode and SPI TI mode.
    /// Position: 9, Width: 1
    /// Access: read-write
    using SSM = BitField<9, 1>;
    constexpr uint32_t SSM_Pos = 9;
    constexpr uint32_t SSM_Msk = SSM::mask;
    /// Enumerated values for SSM
    namespace ssm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receive only mode enabled. This bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted. Note: This bit is not used in I2S mode.
    /// Position: 10, Width: 1
    /// Access: read-write
    using RXONLY = BitField<10, 1>;
    constexpr uint32_t RXONLY_Pos = 10;
    constexpr uint32_t RXONLY_Msk = RXONLY::mask;
    /// Enumerated values for RXONLY
    namespace rxonly {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CRC length This bit is set and cleared by software to select the CRC length. Note: This bit should be written only when SPI is disabled (SPE = '0â) for correct operation. This bit is not used in I2S mode.
    /// Position: 11, Width: 1
    /// Access: read-write
    using CRCL = BitField<11, 1>;
    constexpr uint32_t CRCL_Pos = 11;
    constexpr uint32_t CRCL_Msk = CRCL::mask;
    /// Enumerated values for CRCL
    namespace crcl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmit CRC next Note: This bit has to be written as soon as the last data is written in the SPI_DR register. This bit is not used in I2S mode.
    /// Position: 12, Width: 1
    /// Access: read-write
    using CRCNEXT = BitField<12, 1>;
    constexpr uint32_t CRCNEXT_Pos = 12;
    constexpr uint32_t CRCNEXT_Msk = CRCNEXT::mask;
    /// Enumerated values for CRCNEXT
    namespace crcnext {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Hardware CRC calculation enable Note: This bit should be written only when SPI is disabled (SPE = '0â) for correct operation. This bit is not used in I2S mode.
    /// Position: 13, Width: 1
    /// Access: read-write
    using CRCEN = BitField<13, 1>;
    constexpr uint32_t CRCEN_Pos = 13;
    constexpr uint32_t CRCEN_Msk = CRCEN::mask;
    /// Enumerated values for CRCEN
    namespace crcen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output enable in bidirectional mode This bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode. Note: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used. This bit is not used in I2S mode.
    /// Position: 14, Width: 1
    /// Access: read-write
    using BIDIOE = BitField<14, 1>;
    constexpr uint32_t BIDIOE_Pos = 14;
    constexpr uint32_t BIDIOE_Msk = BIDIOE::mask;
    /// Enumerated values for BIDIOE
    namespace bidioe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Bidirectional data mode enable. This bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active. Note: This bit is not used in I2S mode.
    /// Position: 15, Width: 1
    /// Access: read-write
    using BIDIMODE = BitField<15, 1>;
    constexpr uint32_t BIDIMODE_Pos = 15;
    constexpr uint32_t BIDIMODE_Msk = BIDIMODE::mask;
    /// Enumerated values for BIDIMODE
    namespace bidimode {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace spi_cr1

/// SPI_CR2 - SPI control register 2
namespace spi_cr2 {
    /// Rx buffer DMA enable When this bit is set, a DMA request is generated whenever the RXNE flag is set.
    /// Position: 0, Width: 1
    /// Access: read-write
    using RXDMAEN = BitField<0, 1>;
    constexpr uint32_t RXDMAEN_Pos = 0;
    constexpr uint32_t RXDMAEN_Msk = RXDMAEN::mask;
    /// Enumerated values for RXDMAEN
    namespace rxdmaen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx buffer DMA enable When this bit is set, a DMA request is generated whenever the TXE flag is set.
    /// Position: 1, Width: 1
    /// Access: read-write
    using TXDMAEN = BitField<1, 1>;
    constexpr uint32_t TXDMAEN_Pos = 1;
    constexpr uint32_t TXDMAEN_Msk = TXDMAEN::mask;
    /// Enumerated values for TXDMAEN
    namespace txdmaen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// SS output enable Note: This bit is not used in I2S mode and SPI TI mode.
    /// Position: 2, Width: 1
    /// Access: read-write
    using SSOE = BitField<2, 1>;
    constexpr uint32_t SSOE_Pos = 2;
    constexpr uint32_t SSOE_Msk = SSOE::mask;
    /// Enumerated values for SSOE
    namespace ssoe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// NSS pulse management This bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer. It has no meaning if CPHA = â1â, or FRF = â1â. Note: 1. This bit must be written only when the SPI is disabled (SPE=0). 2. This bit is not used in I2S mode and SPI TI mode.
    /// Position: 3, Width: 1
    /// Access: read-write
    using NSSP = BitField<3, 1>;
    constexpr uint32_t NSSP_Pos = 3;
    constexpr uint32_t NSSP_Msk = NSSP::mask;
    /// Enumerated values for NSSP
    namespace nssp {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Frame format 1 SPI TI mode Note: This bit must be written only when the SPI is disabled (SPE=0). This bit is not used in I2S mode.
    /// Position: 4, Width: 1
    /// Access: read-write
    using FRF = BitField<4, 1>;
    constexpr uint32_t FRF_Pos = 4;
    constexpr uint32_t FRF_Msk = FRF::mask;
    /// Enumerated values for FRF
    namespace frf {
        constexpr uint32_t B_0x0 = 0;
    }

    /// Error interrupt enable This bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode and UDR, OVR, and FRE in I2S mode).
    /// Position: 5, Width: 1
    /// Access: read-write
    using ERRIE = BitField<5, 1>;
    constexpr uint32_t ERRIE_Pos = 5;
    constexpr uint32_t ERRIE_Msk = ERRIE::mask;
    /// Enumerated values for ERRIE
    namespace errie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RX buffer not empty interrupt enable
    /// Position: 6, Width: 1
    /// Access: read-write
    using RXNEIE = BitField<6, 1>;
    constexpr uint32_t RXNEIE_Pos = 6;
    constexpr uint32_t RXNEIE_Msk = RXNEIE::mask;
    /// Enumerated values for RXNEIE
    namespace rxneie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx buffer empty interrupt enable
    /// Position: 7, Width: 1
    /// Access: read-write
    using TXEIE = BitField<7, 1>;
    constexpr uint32_t TXEIE_Pos = 7;
    constexpr uint32_t TXEIE_Msk = TXEIE::mask;
    /// Enumerated values for TXEIE
    namespace txeie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Data size These bits configure the data length for SPI transfers. If software attempts to write one of the âNot usedâ values, they are forced to the value â0111â (8-bit) Note: These bits are not used in I2S mode.
    /// Position: 8, Width: 4
    /// Access: read-write
    using DS = BitField<8, 4>;
    constexpr uint32_t DS_Pos = 8;
    constexpr uint32_t DS_Msk = DS::mask;
    /// Enumerated values for DS
    namespace ds {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0xA = 10;
        constexpr uint32_t B_0xB = 11;
        constexpr uint32_t B_0xC = 12;
        constexpr uint32_t B_0xD = 13;
        constexpr uint32_t B_0xE = 14;
        constexpr uint32_t B_0xF = 15;
    }

    /// FIFO reception threshold This bit is used to set the threshold of the RXFIFO that triggers an RXNE event Note: This bit is not used in I2S mode.
    /// Position: 12, Width: 1
    /// Access: read-write
    using FRXTH = BitField<12, 1>;
    constexpr uint32_t FRXTH_Pos = 12;
    constexpr uint32_t FRXTH_Msk = FRXTH::mask;
    /// Enumerated values for FRXTH
    namespace frxth {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Last DMA transfer for reception This bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register). Note: Refer to if the CRCEN bit is set. This bit is not used in IÂ²S mode.
    /// Position: 13, Width: 1
    /// Access: read-write
    using LDMA_RX = BitField<13, 1>;
    constexpr uint32_t LDMA_RX_Pos = 13;
    constexpr uint32_t LDMA_RX_Msk = LDMA_RX::mask;
    /// Enumerated values for LDMA_RX
    namespace ldma_rx {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Last DMA transfer for transmission This bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register). Note: Refer to if the CRCEN bit is set. This bit is not used in IÂ²S mode.
    /// Position: 14, Width: 1
    /// Access: read-write
    using LDMA_TX = BitField<14, 1>;
    constexpr uint32_t LDMA_TX_Pos = 14;
    constexpr uint32_t LDMA_TX_Msk = LDMA_TX::mask;
    /// Enumerated values for LDMA_TX
    namespace ldma_tx {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace spi_cr2

/// SPI_SR - SPI status register
namespace spi_sr {
    /// Receive buffer not empty
    /// Position: 0, Width: 1
    /// Access: read-only
    using RXNE = BitField<0, 1>;
    constexpr uint32_t RXNE_Pos = 0;
    constexpr uint32_t RXNE_Msk = RXNE::mask;
    /// Enumerated values for RXNE
    namespace rxne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmit buffer empty
    /// Position: 1, Width: 1
    /// Access: read-only
    using TXE = BitField<1, 1>;
    constexpr uint32_t TXE_Pos = 1;
    constexpr uint32_t TXE_Msk = TXE::mask;
    /// Enumerated values for TXE
    namespace txe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Channel side Note: This bit is not used in SPI mode. It has no significance in PCM mode.
    /// Position: 2, Width: 1
    /// Access: read-only
    using CHSIDE = BitField<2, 1>;
    constexpr uint32_t CHSIDE_Pos = 2;
    constexpr uint32_t CHSIDE_Msk = CHSIDE::mask;
    /// Enumerated values for CHSIDE
    namespace chside {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Underrun flag This flag is set by hardware and reset by a software sequence. Refer to pageÂ 1057 for the software sequence. Note: This bit is not used in SPI mode.
    /// Position: 3, Width: 1
    /// Access: read-only
    using UDR = BitField<3, 1>;
    constexpr uint32_t UDR_Pos = 3;
    constexpr uint32_t UDR_Msk = UDR::mask;
    /// Enumerated values for UDR
    namespace udr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CRC error flag Note: This flag is set by hardware and cleared by software writing 0. This bit is not used in I2S mode.
    /// Position: 4, Width: 1
    /// Access: read-write
    using CRCERR = BitField<4, 1>;
    constexpr uint32_t CRCERR_Pos = 4;
    constexpr uint32_t CRCERR_Msk = CRCERR::mask;
    /// Enumerated values for CRCERR
    namespace crcerr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Mode fault This flag is set by hardware and reset by a software sequence. Refer to (MODF) on pageÂ 1031 for the software sequence. Note: This bit is not used in I2S mode.
    /// Position: 5, Width: 1
    /// Access: read-only
    using MODF = BitField<5, 1>;
    constexpr uint32_t MODF_Pos = 5;
    constexpr uint32_t MODF_Msk = MODF::mask;
    /// Enumerated values for MODF
    namespace modf {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Overrun flag This flag is set by hardware and reset by a software sequence. Refer to pageÂ 1057 for the software sequence.
    /// Position: 6, Width: 1
    /// Access: read-only
    using OVR = BitField<6, 1>;
    constexpr uint32_t OVR_Pos = 6;
    constexpr uint32_t OVR_Msk = OVR::mask;
    /// Enumerated values for OVR
    namespace ovr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Busy flag This flag is set and cleared by hardware. Note: The BSY flag must be used with caution: refer to and .
    /// Position: 7, Width: 1
    /// Access: read-only
    using BSY = BitField<7, 1>;
    constexpr uint32_t BSY_Pos = 7;
    constexpr uint32_t BSY_Msk = BSY::mask;
    /// Enumerated values for BSY
    namespace bsy {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Frame format error This flag is used for SPI in TI slave mode and I2S slave mode. Refer to error flags and . This flag is set by hardware and reset when SPI_SR is read by software.
    /// Position: 8, Width: 1
    /// Access: read-only
    using FRE = BitField<8, 1>;
    constexpr uint32_t FRE_Pos = 8;
    constexpr uint32_t FRE_Msk = FRE::mask;
    /// Enumerated values for FRE
    namespace fre {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// FIFO reception level These bits are set and cleared by hardware. Note: These bits are not used in IÂ²S mode and in SPI receive-only mode while CRC calculation is enabled.
    /// Position: 9, Width: 2
    /// Access: read-only
    using FRLVL = BitField<9, 2>;
    constexpr uint32_t FRLVL_Pos = 9;
    constexpr uint32_t FRLVL_Msk = FRLVL::mask;
    /// Enumerated values for FRLVL
    namespace frlvl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// FIFO transmission level These bits are set and cleared by hardware. Note: This bit is not used in I2S mode.
    /// Position: 11, Width: 2
    /// Access: read-only
    using FTLVL = BitField<11, 2>;
    constexpr uint32_t FTLVL_Pos = 11;
    constexpr uint32_t FTLVL_Msk = FTLVL::mask;
    /// Enumerated values for FTLVL
    namespace ftlvl {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

}  // namespace spi_sr

/// SPI_DR - SPI data register
namespace spi_dr {
    /// Data register Data received or to be transmitted The data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See ). Note: Data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. The Rx threshold setting must always correspond with the read access currently used.
    /// Position: 0, Width: 16
    /// Access: read-write
    using DR = BitField<0, 16>;
    constexpr uint32_t DR_Pos = 0;
    constexpr uint32_t DR_Msk = DR::mask;

}  // namespace spi_dr

/// SPI_CRCPR - SPI CRC polynomial register
namespace spi_crcpr {
    /// CRC polynomial register This register contains the polynomial for the CRC calculation. The CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required.
    /// Position: 0, Width: 16
    /// Access: read-write
    using CRCPOLY = BitField<0, 16>;
    constexpr uint32_t CRCPOLY_Pos = 0;
    constexpr uint32_t CRCPOLY_Msk = CRCPOLY::mask;

}  // namespace spi_crcpr

/// SPI_RXCRCR - SPI Rx CRC register
namespace spi_rxcrcr {
    /// Rx CRC register When CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register. Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard. The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard. Note: A read to this register when the BSY Flag is set could return an incorrect value. These bits are not used in I2S mode.
    /// Position: 0, Width: 16
    /// Access: read-only
    using RXCRC = BitField<0, 16>;
    constexpr uint32_t RXCRC_Pos = 0;
    constexpr uint32_t RXCRC_Msk = RXCRC::mask;

}  // namespace spi_rxcrcr

/// SPI_TXCRCR - SPI Tx CRC register
namespace spi_txcrcr {
    /// Tx CRC register When CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPI_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register. Only the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard. The entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard. Note: A read to this register when the BSY flag is set could return an incorrect value. These bits are not used in I2S mode.
    /// Position: 0, Width: 16
    /// Access: read-only
    using TXCRC = BitField<0, 16>;
    constexpr uint32_t TXCRC_Pos = 0;
    constexpr uint32_t TXCRC_Msk = TXCRC::mask;

}  // namespace spi_txcrcr

/// SPI_I2SCFGR - SPI_I2S configuration register
namespace spi_i2scfgr {
    /// Channel length (number of bits per audio channel) The bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in. Note: For correct operation, this bit should be configured when the I2S is disabled. It is not used in SPI mode.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CHLEN = BitField<0, 1>;
    constexpr uint32_t CHLEN_Pos = 0;
    constexpr uint32_t CHLEN_Msk = CHLEN::mask;
    /// Enumerated values for CHLEN
    namespace chlen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Data length to be transferred Note: For correct operation, these bits should be configured when the I2S is disabled. They are not used in SPI mode.
    /// Position: 1, Width: 2
    /// Access: read-write
    using DATLEN = BitField<1, 2>;
    constexpr uint32_t DATLEN_Pos = 1;
    constexpr uint32_t DATLEN_Msk = DATLEN::mask;
    /// Enumerated values for DATLEN
    namespace datlen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Inactive state clock polarity Note: For correct operation, this bit should be configured when the I2S is disabled. It is not used in SPI mode. The bit CKPOL does not affect the CK edge sensitivity used to receive or transmit the SD and WS signals.
    /// Position: 3, Width: 1
    /// Access: read-write
    using CKPOL = BitField<3, 1>;
    constexpr uint32_t CKPOL_Pos = 3;
    constexpr uint32_t CKPOL_Msk = CKPOL::mask;
    /// Enumerated values for CKPOL
    namespace ckpol {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// I2S standard selection For more details on I2S standards, refer to Note: For correct operation, these bits should be configured when the I2S is disabled. They are not used in SPI mode.
    /// Position: 4, Width: 2
    /// Access: read-write
    using I2SSTD = BitField<4, 2>;
    constexpr uint32_t I2SSTD_Pos = 4;
    constexpr uint32_t I2SSTD_Msk = I2SSTD::mask;
    /// Enumerated values for I2SSTD
    namespace i2sstd {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// PCM frame synchronization Note: This bit has a meaning only if I2SSTD = 11 (PCM standard is used). It is not used in SPI mode.
    /// Position: 7, Width: 1
    /// Access: read-write
    using PCMSYNC = BitField<7, 1>;
    constexpr uint32_t PCMSYNC_Pos = 7;
    constexpr uint32_t PCMSYNC_Msk = PCMSYNC::mask;
    /// Enumerated values for PCMSYNC
    namespace pcmsync {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// I2S configuration mode Note: These bits should be configured when the I2S is disabled. They are not used in SPI mode.
    /// Position: 8, Width: 2
    /// Access: read-write
    using I2SCFG = BitField<8, 2>;
    constexpr uint32_t I2SCFG_Pos = 8;
    constexpr uint32_t I2SCFG_Msk = I2SCFG::mask;
    /// Enumerated values for I2SCFG
    namespace i2scfg {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// I2S enable Note: This bit is not used in SPI mode.
    /// Position: 10, Width: 1
    /// Access: read-write
    using I2SE = BitField<10, 1>;
    constexpr uint32_t I2SE_Pos = 10;
    constexpr uint32_t I2SE_Msk = I2SE::mask;
    /// Enumerated values for I2SE
    namespace i2se {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// I2S mode selection Note: This bit should be configured when the SPI is disabled.
    /// Position: 11, Width: 1
    /// Access: read-write
    using I2SMOD = BitField<11, 1>;
    constexpr uint32_t I2SMOD_Pos = 11;
    constexpr uint32_t I2SMOD_Msk = I2SMOD::mask;
    /// Enumerated values for I2SMOD
    namespace i2smod {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Asynchronous start enable. When the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and an appropriate transition is detected on the WS signal. When the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and the appropriate level is detected on the WS signal. Note: The appropriate transition is a falling edge on WS signal when I2S Philips Standard is used, or a rising edge for other standards. The appropriate level is a low level on WS signal when I2S Philips Standard is used, or a high level for other standards. Please refer to for additional information.
    /// Position: 12, Width: 1
    /// Access: read-write
    using ASTRTEN = BitField<12, 1>;
    constexpr uint32_t ASTRTEN_Pos = 12;
    constexpr uint32_t ASTRTEN_Msk = ASTRTEN::mask;
    /// Enumerated values for ASTRTEN
    namespace astrten {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace spi_i2scfgr

/// SPI_I2SPR - SPI_I2S prescaler register
namespace spi_i2spr {
    /// I2S linear prescaler I2SDIV [7:0] = 0 or I2SDIV [7:0] = 1 are forbidden values. Refer to . Note: These bits should be configured when the I2S is disabled. They are used only when the I2S is in master mode. They are not used in SPI mode.
    /// Position: 0, Width: 8
    /// Access: read-write
    using I2SDIV = BitField<0, 8>;
    constexpr uint32_t I2SDIV_Pos = 0;
    constexpr uint32_t I2SDIV_Msk = I2SDIV::mask;

    /// Odd factor for the prescaler Refer to . Note: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode. It is not used in SPI mode.
    /// Position: 8, Width: 1
    /// Access: read-write
    using ODD = BitField<8, 1>;
    constexpr uint32_t ODD_Pos = 8;
    constexpr uint32_t ODD_Msk = ODD::mask;
    /// Enumerated values for ODD
    namespace odd {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Master clock output enable Note: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode. It is not used in SPI mode.
    /// Position: 9, Width: 1
    /// Access: read-write
    using MCKOE = BitField<9, 1>;
    constexpr uint32_t MCKOE_Pos = 9;
    constexpr uint32_t MCKOE_Msk = MCKOE::mask;
    /// Enumerated values for MCKOE
    namespace mckoe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace spi_i2spr

}  // namespace alloy::hal::st::stm32g0::spi1
