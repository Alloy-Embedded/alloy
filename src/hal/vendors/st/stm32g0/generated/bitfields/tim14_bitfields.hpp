/// Auto-generated bit field definitions for TIM14
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::tim14 {

using namespace alloy::hal::bitfields;

// ============================================================================
// TIM14 Bit Field Definitions
// ============================================================================

/// CR1 - control register 1
namespace cr1 {
    /// Counter enable Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CEN = BitField<0, 1>;
    constexpr uint32_t CEN_Pos = 0;
    constexpr uint32_t CEN_Msk = CEN::mask;
    /// Enumerated values for CEN
    namespace cen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Update disable This bit is set and cleared by software to enable/disable update interrupt (UEV) event generation. Counter overflow Setting the UG bit. Buffered registers are then loaded with their preload values.
    /// Position: 1, Width: 1
    /// Access: read-write
    using UDIS = BitField<1, 1>;
    constexpr uint32_t UDIS_Pos = 1;
    constexpr uint32_t UDIS_Msk = UDIS::mask;
    /// Enumerated values for UDIS
    namespace udis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Update request source This bit is set and cleared by software to select the update interrupt (UEV) sources. Counter overflow Setting the UG bit
    /// Position: 2, Width: 1
    /// Access: read-write
    using URS = BitField<2, 1>;
    constexpr uint32_t URS_Pos = 2;
    constexpr uint32_t URS_Msk = URS::mask;
    /// Enumerated values for URS
    namespace urs {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// One-pulse mode
    /// Position: 3, Width: 1
    /// Access: read-write
    using OPM = BitField<3, 1>;
    constexpr uint32_t OPM_Pos = 3;
    constexpr uint32_t OPM_Msk = OPM::mask;
    /// Enumerated values for OPM
    namespace opm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Auto-reload preload enable
    /// Position: 7, Width: 1
    /// Access: read-write
    using ARPE = BitField<7, 1>;
    constexpr uint32_t ARPE_Pos = 7;
    constexpr uint32_t ARPE_Msk = ARPE::mask;
    /// Enumerated values for ARPE
    namespace arpe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Clock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),
    /// Position: 8, Width: 2
    /// Access: read-write
    using CKD = BitField<8, 2>;
    constexpr uint32_t CKD_Pos = 8;
    constexpr uint32_t CKD_Msk = CKD::mask;
    /// Enumerated values for CKD
    namespace ckd {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// UIF status bit remapping
    /// Position: 11, Width: 1
    /// Access: read-write
    using UIFREMAP = BitField<11, 1>;
    constexpr uint32_t UIFREMAP_Pos = 11;
    constexpr uint32_t UIFREMAP_Msk = UIFREMAP::mask;
    /// Enumerated values for UIFREMAP
    namespace uifremap {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace cr1

/// DIER - DMA/Interrupt enable register
namespace dier {
    /// Update interrupt enable
    /// Position: 0, Width: 1
    /// Access: read-write
    using UIE = BitField<0, 1>;
    constexpr uint32_t UIE_Pos = 0;
    constexpr uint32_t UIE_Msk = UIE::mask;
    /// Enumerated values for UIE
    namespace uie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 interrupt enable
    /// Position: 1, Width: 1
    /// Access: read-write
    using CC1IE = BitField<1, 1>;
    constexpr uint32_t CC1IE_Pos = 1;
    constexpr uint32_t CC1IE_Msk = CC1IE::mask;
    /// Enumerated values for CC1IE
    namespace cc1ie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dier

/// SR - status register
namespace sr {
    /// Update interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow and if UDIS=â0â in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=â0â and UDIS=â0â in the TIMx_CR1 register.
    /// Position: 0, Width: 1
    /// Access: read-write
    using UIF = BitField<0, 1>;
    constexpr uint32_t UIF_Pos = 0;
    constexpr uint32_t UIF_Msk = UIF::mask;
    /// Enumerated values for UIF
    namespace uif {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).
    /// Position: 1, Width: 1
    /// Access: read-write
    using CC1IF = BitField<1, 1>;
    constexpr uint32_t CC1IF_Pos = 1;
    constexpr uint32_t CC1IF_Msk = CC1IF::mask;
    /// Enumerated values for CC1IF
    namespace cc1if {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0â.
    /// Position: 9, Width: 1
    /// Access: read-write
    using CC1OF = BitField<9, 1>;
    constexpr uint32_t CC1OF_Pos = 9;
    constexpr uint32_t CC1OF_Msk = CC1OF::mask;
    /// Enumerated values for CC1OF
    namespace cc1of {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace sr

/// EGR - event generation register
namespace egr {
    /// Update generation This bit can be set by software, it is automatically cleared by hardware.
    /// Position: 0, Width: 1
    /// Access: write-only
    using UG = BitField<0, 1>;
    constexpr uint32_t UG_Pos = 0;
    constexpr uint32_t UG_Msk = UG::mask;
    /// Enumerated values for UG
    namespace ug {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
    /// Position: 1, Width: 1
    /// Access: write-only
    using CC1G = BitField<1, 1>;
    constexpr uint32_t CC1G_Pos = 1;
    constexpr uint32_t CC1G_Msk = CC1G::mask;
    /// Enumerated values for CC1G
    namespace cc1g {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace egr

/// CCMR1_Output - capture/compare mode register 1 (output mode)
namespace ccmr1_output {
    /// Capture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
    /// Position: 0, Width: 2
    /// Access: read-write
    using CC1S = BitField<0, 2>;
    constexpr uint32_t CC1S_Pos = 0;
    constexpr uint32_t CC1S_Msk = CC1S::mask;
    /// Enumerated values for CC1S
    namespace cc1s {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output compare 1 fast enable This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.
    /// Position: 2, Width: 1
    /// Access: read-write
    using OC1FE = BitField<2, 1>;
    constexpr uint32_t OC1FE_Pos = 2;
    constexpr uint32_t OC1FE_Msk = OC1FE::mask;
    /// Enumerated values for OC1FE
    namespace oc1fe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output compare 1 preload enable Note: The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.
    /// Position: 3, Width: 1
    /// Access: read-write
    using OC1PE = BitField<3, 1>;
    constexpr uint32_t OC1PE_Pos = 3;
    constexpr uint32_t OC1PE_Msk = OC1PE::mask;
    /// Enumerated values for OC1PE
    namespace oc1pe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Output compare 1 mode (refer to bit 16 for OC1M[3]) These bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit. Others: Reserved Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode. Note: The OC1M[3] bit is not contiguous, located in bit 16.
    /// Position: 4, Width: 3
    /// Access: read-write
    using OC1M1 = BitField<4, 3>;
    constexpr uint32_t OC1M1_Pos = 4;
    constexpr uint32_t OC1M1_Msk = OC1M1::mask;
    /// Enumerated values for OC1M1
    namespace oc1m1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// Output compare 1 mode (refer to bit 16 for OC1M[3]) These bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit. Others: Reserved Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode. Note: The OC1M[3] bit is not contiguous, located in bit 16.
    /// Position: 16, Width: 1
    /// Access: read-write
    using OC1M2 = BitField<16, 1>;
    constexpr uint32_t OC1M2_Pos = 16;
    constexpr uint32_t OC1M2_Msk = OC1M2::mask;
    /// Enumerated values for OC1M2
    namespace oc1m2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

}  // namespace ccmr1_output

/// CCMR1_Input - capture/compare mode register 1 (input mode)
namespace ccmr1_input {
    /// Capture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
    /// Position: 0, Width: 2
    /// Access: read-write
    using CC1S = BitField<0, 2>;
    constexpr uint32_t CC1S_Pos = 0;
    constexpr uint32_t CC1S_Msk = CC1S::mask;
    /// Enumerated values for CC1S
    namespace cc1s {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Input capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=â0â (TIMx_CCER register).
    /// Position: 2, Width: 2
    /// Access: read-write
    using IC1PSC = BitField<2, 2>;
    constexpr uint32_t IC1PSC_Pos = 2;
    constexpr uint32_t IC1PSC_Msk = IC1PSC::mask;
    /// Enumerated values for IC1PSC
    namespace ic1psc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// Input capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
    /// Position: 4, Width: 4
    /// Access: read-write
    using IC1F = BitField<4, 4>;
    constexpr uint32_t IC1F_Pos = 4;
    constexpr uint32_t IC1F_Msk = IC1F::mask;
    /// Enumerated values for IC1F
    namespace ic1f {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
        constexpr uint32_t B_0x8 = 8;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0xA = 10;
        constexpr uint32_t B_0xB = 11;
        constexpr uint32_t B_0xC = 12;
        constexpr uint32_t B_0xD = 13;
        constexpr uint32_t B_0xE = 14;
        constexpr uint32_t B_0xF = 15;
    }

}  // namespace ccmr1_input

/// CCER - capture/compare enable register
namespace ccer {
    /// Capture/Compare 1 output enable.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CC1E = BitField<0, 1>;
    constexpr uint32_t CC1E_Pos = 0;
    constexpr uint32_t CC1E_Msk = CC1E::mask;
    /// Enumerated values for CC1E
    namespace cc1e {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 output Polarity. When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: This configuration is reserved, it must not be used.
    /// Position: 1, Width: 1
    /// Access: read-write
    using CC1P = BitField<1, 1>;
    constexpr uint32_t CC1P_Pos = 1;
    constexpr uint32_t CC1P_Msk = CC1P::mask;
    /// Enumerated values for CC1P
    namespace cc1p {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Capture/Compare 1 complementary output Polarity. CC1 channel configured as output: CC1NP must be kept cleared. CC1 channel configured as input: CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description).
    /// Position: 3, Width: 1
    /// Access: read-write
    using CC1NP = BitField<3, 1>;
    constexpr uint32_t CC1NP_Pos = 3;
    constexpr uint32_t CC1NP_Msk = CC1NP::mask;

}  // namespace ccer

/// CNT - counter
namespace cnt {
    /// low counter value
    /// Position: 0, Width: 16
    using CNT = BitField<0, 16>;
    constexpr uint32_t CNT_Pos = 0;
    constexpr uint32_t CNT_Msk = CNT::mask;

    /// UIF Copy
    /// Position: 31, Width: 1
    using UIFCPY = BitField<31, 1>;
    constexpr uint32_t UIFCPY_Pos = 31;
    constexpr uint32_t UIFCPY_Msk = UIFCPY::mask;

}  // namespace cnt

/// PSC - prescaler
namespace psc {
    /// Prescaler value
    /// Position: 0, Width: 16
    using PSC = BitField<0, 16>;
    constexpr uint32_t PSC_Pos = 0;
    constexpr uint32_t PSC_Msk = PSC::mask;

}  // namespace psc

/// ARR - auto-reload register
namespace arr {
    /// Low Auto-reload value
    /// Position: 0, Width: 16
    using ARR = BitField<0, 16>;
    constexpr uint32_t ARR_Pos = 0;
    constexpr uint32_t ARR_Msk = ARR::mask;

}  // namespace arr

/// CCR1 - capture/compare register 1
namespace ccr1 {
    /// Low Capture/Compare 1 value
    /// Position: 0, Width: 16
    using CCR1 = BitField<0, 16>;
    constexpr uint32_t CCR1_Pos = 0;
    constexpr uint32_t CCR1_Msk = CCR1::mask;

}  // namespace ccr1

/// TISEL - TIM timer input selection register
namespace tisel {
    /// selects TI1[0] to TI1[15] input Others: Reserved
    /// Position: 0, Width: 4
    /// Access: read-write
    using TI1SEL = BitField<0, 4>;
    constexpr uint32_t TI1SEL_Pos = 0;
    constexpr uint32_t TI1SEL_Msk = TI1SEL::mask;
    /// Enumerated values for TI1SEL
    namespace ti1sel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

}  // namespace tisel

}  // namespace alloy::hal::st::stm32g0::tim14
