/// Auto-generated bit field definitions for TIM6
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::tim6 {

using namespace alloy::hal::bitfields;

// ============================================================================
// TIM6 Bit Field Definitions
// ============================================================================

/// CR1 - control register 1
namespace cr1 {
    /// Counter enable Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.
    /// Position: 0, Width: 1
    /// Access: read-write
    using CEN = BitField<0, 1>;
    constexpr uint32_t CEN_Pos = 0;
    constexpr uint32_t CEN_Msk = CEN::mask;
    /// Enumerated values for CEN
    namespace cen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.
    /// Position: 1, Width: 1
    /// Access: read-write
    using UDIS = BitField<1, 1>;
    constexpr uint32_t UDIS_Pos = 1;
    constexpr uint32_t UDIS_Msk = UDIS::mask;
    /// Enumerated values for UDIS
    namespace udis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller
    /// Position: 2, Width: 1
    /// Access: read-write
    using URS = BitField<2, 1>;
    constexpr uint32_t URS_Pos = 2;
    constexpr uint32_t URS_Msk = URS::mask;
    /// Enumerated values for URS
    namespace urs {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// One-pulse mode
    /// Position: 3, Width: 1
    /// Access: read-write
    using OPM = BitField<3, 1>;
    constexpr uint32_t OPM_Pos = 3;
    constexpr uint32_t OPM_Msk = OPM::mask;
    /// Enumerated values for OPM
    namespace opm {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Auto-reload preload enable
    /// Position: 7, Width: 1
    /// Access: read-write
    using ARPE = BitField<7, 1>;
    constexpr uint32_t ARPE_Pos = 7;
    constexpr uint32_t ARPE_Msk = ARPE::mask;
    /// Enumerated values for ARPE
    namespace arpe {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// UIF status bit remapping
    /// Position: 11, Width: 1
    /// Access: read-write
    using UIFREMAP = BitField<11, 1>;
    constexpr uint32_t UIFREMAP_Pos = 11;
    constexpr uint32_t UIFREMAP_Msk = UIFREMAP::mask;
    /// Enumerated values for UIFREMAP
    namespace uifremap {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace cr1

/// CR2 - control register 2
namespace cr2 {
    /// Master mode selection These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register). Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
    /// Position: 4, Width: 3
    /// Access: read-write
    using MMS = BitField<4, 3>;
    constexpr uint32_t MMS_Pos = 4;
    constexpr uint32_t MMS_Msk = MMS::mask;
    /// Enumerated values for MMS
    namespace mms {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

}  // namespace cr2

/// DIER - DMA/Interrupt enable register
namespace dier {
    /// Update interrupt enable
    /// Position: 0, Width: 1
    /// Access: read-write
    using UIE = BitField<0, 1>;
    constexpr uint32_t UIE_Pos = 0;
    constexpr uint32_t UIE_Msk = UIE::mask;
    /// Enumerated values for UIE
    namespace uie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Update DMA request enable
    /// Position: 8, Width: 1
    /// Access: read-write
    using UDE = BitField<8, 1>;
    constexpr uint32_t UDE_Pos = 8;
    constexpr uint32_t UDE_Msk = UDE::mask;
    /// Enumerated values for UDE
    namespace ude {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace dier

/// SR - status register
namespace sr {
    /// Update interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0 and UDIS = 0 in the TIMx_CR1 register.
    /// Position: 0, Width: 1
    /// Access: read-write
    using UIF = BitField<0, 1>;
    constexpr uint32_t UIF_Pos = 0;
    constexpr uint32_t UIF_Msk = UIF::mask;
    /// Enumerated values for UIF
    namespace uif {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace sr

/// EGR - event generation register
namespace egr {
    /// Update generation This bit can be set by software, it is automatically cleared by hardware.
    /// Position: 0, Width: 1
    /// Access: write-only
    using UG = BitField<0, 1>;
    constexpr uint32_t UG_Pos = 0;
    constexpr uint32_t UG_Msk = UG::mask;
    /// Enumerated values for UG
    namespace ug {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace egr

/// CNT - counter
namespace cnt {
    /// Counter value
    /// Position: 0, Width: 16
    /// Access: read-write
    using CNT = BitField<0, 16>;
    constexpr uint32_t CNT_Pos = 0;
    constexpr uint32_t CNT_Msk = CNT::mask;

    /// UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.
    /// Position: 31, Width: 1
    /// Access: read-only
    using UIFCPY = BitField<31, 1>;
    constexpr uint32_t UIFCPY_Pos = 31;
    constexpr uint32_t UIFCPY_Msk = UIFCPY::mask;

}  // namespace cnt

/// PSC - prescaler
namespace psc {
    /// Prescaler value
    /// Position: 0, Width: 16
    using PSC = BitField<0, 16>;
    constexpr uint32_t PSC_Pos = 0;
    constexpr uint32_t PSC_Msk = PSC::mask;

}  // namespace psc

/// ARR - auto-reload register
namespace arr {
    /// Prescaler value
    /// Position: 0, Width: 16
    using ARR = BitField<0, 16>;
    constexpr uint32_t ARR_Pos = 0;
    constexpr uint32_t ARR_Msk = ARR::mask;

}  // namespace arr

}  // namespace alloy::hal::st::stm32g0::tim6
