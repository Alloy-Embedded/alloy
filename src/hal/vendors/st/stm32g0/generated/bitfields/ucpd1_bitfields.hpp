/// Auto-generated bit field definitions for UCPD1
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::st::stm32g0::ucpd1 {

using namespace alloy::hal::bitfields;

// ============================================================================
// UCPD1 Bit Field Definitions
// ============================================================================

/// UCPD_CFGR1 - UCPD configuration register 1
namespace ucpd_cfgr1 {
    /// Division ratio for producing half-bit clock The bitfield determines the division ratio (the bitfield value plus one) of a ucpd_clk divider producing half-bit clock (hbit_clk).
    /// Position: 0, Width: 6
    /// Access: read-write
    using HBITCLKDIV = BitField<0, 6>;
    constexpr uint32_t HBITCLKDIV_Pos = 0;
    constexpr uint32_t HBITCLKDIV_Msk = HBITCLKDIV::mask;
    /// Enumerated values for HBITCLKDIV
    namespace hbitclkdiv {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1A = 26;
        constexpr uint32_t B_0x3F = 63;
    }

    /// Division ratio for producing inter-frame gap timer clock The bitfield determines the division ratio (the bitfield value minus one) of a ucpd_clk divider producing inter-frame gap timer clock (tInterFrameGap). The division ratio 15 is to apply for Tx clock at the USB PD 2.0 specification nominal value. The division ratios below 15 are to apply for Tx clock below nominal, and the division ratios above 15 for Tx clock above nominal.
    /// Position: 6, Width: 5
    /// Access: read-write
    using IFRGAP = BitField<6, 5>;
    constexpr uint32_t IFRGAP_Pos = 6;
    constexpr uint32_t IFRGAP_Msk = IFRGAP::mask;
    /// Enumerated values for IFRGAP
    namespace ifrgap {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0xD = 13;
        constexpr uint32_t B_0xE = 14;
        constexpr uint32_t B_0xF = 15;
        constexpr uint32_t B_0x1F = 31;
    }

    /// Transition window duration The bitfield determines the division ratio (the bitfield value minus one) of a hbit_clk divider producing tTransitionWindow interval. Set a value that produces an interval of 12 to 20 us, taking into account the ucpd_clk frequency and the HBITCLKDIV[5:0] bitfield setting.
    /// Position: 11, Width: 5
    /// Access: read-write
    using TRANSWIN = BitField<11, 5>;
    constexpr uint32_t TRANSWIN_Pos = 11;
    constexpr uint32_t TRANSWIN_Msk = TRANSWIN::mask;
    /// Enumerated values for TRANSWIN
    namespace transwin {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x9 = 9;
        constexpr uint32_t B_0x1F = 31;
    }

    /// Pre-scaler division ratio for generating ucpd_clk The bitfield determines the division ratio of a kernel clock pre-scaler producing UCPD peripheral clock (ucpd_clk). It is recommended to use the pre-scaler so as to set the ucpd_clk frequency in the range from 6 to 9 MHz.
    /// Position: 17, Width: 3
    /// Access: read-write
    using PSC_USBPDCLK = BitField<17, 3>;
    constexpr uint32_t PSC_USBPDCLK_Pos = 17;
    constexpr uint32_t PSC_USBPDCLK_Msk = PSC_USBPDCLK::mask;
    /// Enumerated values for PSC_USBPDCLK
    namespace psc_usbpdclk {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
    }

    /// Receiver ordered set enable The bitfield determines the types of ordered sets that the receiver must detect. When set/cleared, each bit enables/disables a specific function: 0bxxxxxxxx1: SOP detect enabled 0bxxxxxxx1x: SOP' detect enabled 0bxxxxxx1xx: SOP'' detect enabled 0bxxxxx1xxx: Hard Reset detect enabled 0bxxxx1xxxx: Cable Detect reset enabled 0bxxx1xxxxx: SOP'_Debug enabled 0bxx1xxxxxx: SOP''_Debug enabled 0bx1xxxxxxx: SOP extension#1 enabled 0b1xxxxxxxx: SOP extension#2 enabled
    /// Position: 20, Width: 9
    /// Access: read-write
    using RXORDSETEN = BitField<20, 9>;
    constexpr uint32_t RXORDSETEN_Pos = 20;
    constexpr uint32_t RXORDSETEN_Msk = RXORDSETEN::mask;

    /// Transmission DMA mode enable When set, the bit enables DMA mode for transmission.
    /// Position: 29, Width: 1
    /// Access: read-write
    using TXDMAEN = BitField<29, 1>;
    constexpr uint32_t TXDMAEN_Pos = 29;
    constexpr uint32_t TXDMAEN_Msk = TXDMAEN::mask;
    /// Enumerated values for TXDMAEN
    namespace txdmaen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Reception DMA mode enable When set, the bit enables DMA mode for reception.
    /// Position: 30, Width: 1
    /// Access: read-write
    using RXDMAEN = BitField<30, 1>;
    constexpr uint32_t RXDMAEN_Pos = 30;
    constexpr uint32_t RXDMAEN_Msk = RXDMAEN::mask;
    /// Enumerated values for RXDMAEN
    namespace rxdmaen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// UCPD peripheral enable General enable of the UCPD peripheral. Upon disabling, the peripheral instantly quits any ongoing activity and all control bits and bitfields default to their reset values. They must be set to their desired values each time the peripheral transits from disabled to enabled state.
    /// Position: 31, Width: 1
    /// Access: read-write
    using UCPDEN = BitField<31, 1>;
    constexpr uint32_t UCPDEN_Pos = 31;
    constexpr uint32_t UCPDEN_Msk = UCPDEN::mask;
    /// Enumerated values for UCPDEN
    namespace ucpden {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace ucpd_cfgr1

/// UCPD_CFGR2 - UCPD configuration register 2
namespace ucpd_cfgr2 {
    /// BMC decoder Rx pre-filter enable The sampling clock is that of the receiver (that is, after pre-scaler).
    /// Position: 0, Width: 1
    /// Access: read-write
    using RXFILTDIS = BitField<0, 1>;
    constexpr uint32_t RXFILTDIS_Pos = 0;
    constexpr uint32_t RXFILTDIS_Msk = RXFILTDIS::mask;
    /// Enumerated values for RXFILTDIS
    namespace rxfiltdis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// BMC decoder Rx pre-filter sampling method Number of consistent consecutive samples before confirming a new value.
    /// Position: 1, Width: 1
    /// Access: read-write
    using RXFILT2N3 = BitField<1, 1>;
    constexpr uint32_t RXFILT2N3_Pos = 1;
    constexpr uint32_t RXFILT2N3_Msk = RXFILT2N3::mask;
    /// Enumerated values for RXFILT2N3
    namespace rxfilt2n3 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Force ClkReq clock request
    /// Position: 2, Width: 1
    /// Access: read-write
    using FORCECLK = BitField<2, 1>;
    constexpr uint32_t FORCECLK_Pos = 2;
    constexpr uint32_t FORCECLK_Msk = FORCECLK::mask;
    /// Enumerated values for FORCECLK
    namespace forceclk {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Wakeup from Stop mode enable Setting the bit enables the UCPD_ASYNC_INT signal.
    /// Position: 3, Width: 1
    /// Access: read-write
    using WUPEN = BitField<3, 1>;
    constexpr uint32_t WUPEN_Pos = 3;
    constexpr uint32_t WUPEN_Msk = WUPEN::mask;
    /// Enumerated values for WUPEN
    namespace wupen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace ucpd_cfgr2

/// UCPD_CFGR3 - UCPD configuration register 3
namespace ucpd_cfgr3 {
    /// SW trim value for RPD resistors on the CC1 line
    /// Position: 0, Width: 4
    /// Access: read-write
    using TRIM1_NG_CCRPD = BitField<0, 4>;
    constexpr uint32_t TRIM1_NG_CCRPD_Pos = 0;
    constexpr uint32_t TRIM1_NG_CCRPD_Msk = TRIM1_NG_CCRPD::mask;

    /// SW trim value for RP1A5 resistors on the CC1 line
    /// Position: 4, Width: 5
    /// Access: read-write
    using TRIM1_NG_CC1A5 = BitField<4, 5>;
    constexpr uint32_t TRIM1_NG_CC1A5_Pos = 4;
    constexpr uint32_t TRIM1_NG_CC1A5_Msk = TRIM1_NG_CC1A5::mask;

    /// SW trim value for RP3A0 resistors on the CC1 line
    /// Position: 9, Width: 4
    /// Access: read-write
    using TRIM1_NG_CC3A0 = BitField<9, 4>;
    constexpr uint32_t TRIM1_NG_CC3A0_Pos = 9;
    constexpr uint32_t TRIM1_NG_CC3A0_Msk = TRIM1_NG_CC3A0::mask;

    /// SW trim value for RPD resistors on the CC2 line
    /// Position: 16, Width: 4
    /// Access: read-write
    using TRIM2_NG_CCRPD = BitField<16, 4>;
    constexpr uint32_t TRIM2_NG_CCRPD_Pos = 16;
    constexpr uint32_t TRIM2_NG_CCRPD_Msk = TRIM2_NG_CCRPD::mask;

    /// SW trim value for RP1A5 resistors on the CC2 line
    /// Position: 20, Width: 5
    /// Access: read-write
    using TRIM2_NG_CC1A5 = BitField<20, 5>;
    constexpr uint32_t TRIM2_NG_CC1A5_Pos = 20;
    constexpr uint32_t TRIM2_NG_CC1A5_Msk = TRIM2_NG_CC1A5::mask;

    /// SW trim value for RP3A0 resistors on the CC2 line
    /// Position: 25, Width: 4
    /// Access: read-write
    using TRIM2_NG_CC3A0 = BitField<25, 4>;
    constexpr uint32_t TRIM2_NG_CC3A0_Pos = 25;
    constexpr uint32_t TRIM2_NG_CC3A0_Msk = TRIM2_NG_CC3A0::mask;

}  // namespace ucpd_cfgr3

/// UCPD_CR - UCPD control register
namespace ucpd_cr {
    /// Type of Tx packet Writing the bitfield triggers the action as follows, depending on the value: Others: invalid From V1.1 of the USB PD specification, there is a counter defined for the duration of the BIST Carrier Mode 2. To quit this mode correctly (after the "tBISTContMode" delay), disable the peripheral (UCPDEN = 0).
    /// Position: 0, Width: 2
    /// Access: read-write
    using TXMODE = BitField<0, 2>;
    constexpr uint32_t TXMODE_Pos = 0;
    constexpr uint32_t TXMODE_Msk = TXMODE::mask;
    /// Enumerated values for TXMODE
    namespace txmode {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
    }

    /// Command to send a Tx packet The bit is cleared by hardware as soon as the packet transmission begins or is discarded.
    /// Position: 2, Width: 1
    /// Access: read-write
    using TXSEND = BitField<2, 1>;
    constexpr uint32_t TXSEND_Pos = 2;
    constexpr uint32_t TXSEND_Msk = TXSEND::mask;
    /// Enumerated values for TXSEND
    namespace txsend {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Command to send a Tx Hard Reset The bit is cleared by hardware as soon as the message transmission begins or is discarded.
    /// Position: 3, Width: 1
    /// Access: read-write
    using TXHRST = BitField<3, 1>;
    constexpr uint32_t TXHRST_Pos = 3;
    constexpr uint32_t TXHRST_Msk = TXHRST::mask;
    /// Enumerated values for TXHRST
    namespace txhrst {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receiver mode Determines the mode of the receiver. When the bit is set, RXORDSET behaves normally, RXDR no longer receives bytes yet the CRC checking still proceeds as for a normal message.
    /// Position: 4, Width: 1
    /// Access: read-write
    using RXMODE = BitField<4, 1>;
    constexpr uint32_t RXMODE_Pos = 4;
    constexpr uint32_t RXMODE_Msk = RXMODE::mask;
    /// Enumerated values for RXMODE
    namespace rxmode {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// USB Power Delivery receiver enable Both CC1 and CC2 receivers are disabled when the bit is cleared. Only the CC receiver selected via the PHYCCSEL bit is enabled when the bit is set.
    /// Position: 5, Width: 1
    /// Access: read-write
    using PHYRXEN = BitField<5, 1>;
    constexpr uint32_t PHYRXEN_Pos = 5;
    constexpr uint32_t PHYRXEN_Msk = PHYRXEN::mask;
    /// Enumerated values for PHYRXEN
    namespace phyrxen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CC1/CC2 line selector for USB Power Delivery signaling The selection depends on the cable orientation as discovered at attach.
    /// Position: 6, Width: 1
    /// Access: read-write
    using PHYCCSEL = BitField<6, 1>;
    constexpr uint32_t PHYCCSEL_Pos = 6;
    constexpr uint32_t PHYCCSEL_Msk = PHYCCSEL::mask;
    /// Enumerated values for PHYCCSEL
    namespace phyccsel {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Analog PHY sub-mode Refer to TYPEC_VSTATE_CCx for the effect of this bitfield.
    /// Position: 7, Width: 2
    /// Access: read-write
    using ANASUBMODE = BitField<7, 2>;
    constexpr uint32_t ANASUBMODE_Pos = 7;
    constexpr uint32_t ANASUBMODE_Msk = ANASUBMODE::mask;

    /// Analog PHY operating mode The bit takes effect upon setting the UCPDx_STROBE bit of the SYS_CONFIG register. The use of CC1 and CC2 depends on CCENABLE. Refer to ANAMODE, ANASUBMODE and link with TYPEC_VSTATE_CCx for the effect of this bitfield in conjunction with ANASUBMODE[1:0].
    /// Position: 9, Width: 1
    /// Access: read-write
    using ANAMODE = BitField<9, 1>;
    constexpr uint32_t ANAMODE_Pos = 9;
    constexpr uint32_t ANAMODE_Msk = ANAMODE::mask;
    /// Enumerated values for ANAMODE
    namespace anamode {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CC line enable This bitfield enables CC1 and CC2 line analog PHYs (pull-ups and pull-downs) according to ANAMODE and ANASUBMODE[1:0] setting. A single line PHY can be enabled when, for example, the other line is driven by VCONN via an external VCONN switch. Enabling both PHYs is the normal usage for sink/source.
    /// Position: 10, Width: 2
    /// Access: read-write
    using CCENABLE = BitField<10, 2>;
    constexpr uint32_t CCENABLE_Pos = 10;
    constexpr uint32_t CCENABLE_Msk = CCENABLE::mask;
    /// Enumerated values for CCENABLE
    namespace ccenable {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// VCONN switch enable for CC1
    /// Position: 13, Width: 1
    /// Access: read-write
    using CC1VCONNEN = BitField<13, 1>;
    constexpr uint32_t CC1VCONNEN_Pos = 13;
    constexpr uint32_t CC1VCONNEN_Msk = CC1VCONNEN::mask;
    /// Enumerated values for CC1VCONNEN
    namespace cc1vconnen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// VCONN switch enable for CC2
    /// Position: 14, Width: 1
    /// Access: read-write
    using CC2VCONNEN = BitField<14, 1>;
    constexpr uint32_t CC2VCONNEN_Pos = 14;
    constexpr uint32_t CC2VCONNEN_Msk = CC2VCONNEN::mask;
    /// Enumerated values for CC2VCONNEN
    namespace cc2vconnen {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Dead battery function enable The bit takes effect upon setting the USBPDstrobe bit of the SYS_CONFIG register. Dead battery function only operates if the external circuit is appropriately configured.
    /// Position: 15, Width: 1
    /// Access: read-write
    using DBATTEN = BitField<15, 1>;
    constexpr uint32_t DBATTEN_Pos = 15;
    constexpr uint32_t DBATTEN_Msk = DBATTEN::mask;
    /// Enumerated values for DBATTEN
    namespace dbatten {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// FRS event detection enable Setting the bit enables FRS Rx event (FRSEVT) detection on the CC line selected through the PHYCCSEL bit. 0: Disable Clear the bit when the device is attached to an FRS-incapable source/sink.
    /// Position: 16, Width: 1
    /// Access: read-write
    using FRSRXEN = BitField<16, 1>;
    constexpr uint32_t FRSRXEN_Pos = 16;
    constexpr uint32_t FRSRXEN_Msk = FRSRXEN::mask;
    /// Enumerated values for FRSRXEN
    namespace frsrxen {
        constexpr uint32_t B_0x1 = 1;
    }

    /// FRS Tx signaling enable. Setting the bit enables FRS Tx signaling. The bit is cleared by hardware after a delay respecting the USB Power Delivery specification Revision 3.0.
    /// Position: 17, Width: 1
    /// Access: read-write
    using FRSTX = BitField<17, 1>;
    constexpr uint32_t FRSTX_Pos = 17;
    constexpr uint32_t FRSTX_Msk = FRSTX::mask;
    /// Enumerated values for FRSTX
    namespace frstx {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rdch condition drive The bit drives Rdch condition on the CC line selected through the PHYCCSEL bit (thus associated with VCONN), by remaining set during the source-only UnattachedWait.SRC state, to respect the Type-C state. Refer to "USB Type-C ECN for Source VCONN Discharge". The CCENABLE[1:0] bitfield must be set accordingly, too. Changing the bit value only takes effect upon setting the UCPDx_STROBE bit of the SYSCFG_CFGR1 register.
    /// Position: 18, Width: 1
    /// Access: read-write
    using RDCH = BitField<18, 1>;
    constexpr uint32_t RDCH_Pos = 18;
    constexpr uint32_t RDCH_Msk = RDCH::mask;
    /// Enumerated values for RDCH
    namespace rdch {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CC1 Type-C detector disable The bit disables the Type-C detector on the CC1 line. When enabled, the Type-C detector for CC1 is configured through ANAMODE and ANASUBMODE[1:0].
    /// Position: 20, Width: 1
    /// Access: read-write
    using CC1TCDIS = BitField<20, 1>;
    constexpr uint32_t CC1TCDIS_Pos = 20;
    constexpr uint32_t CC1TCDIS_Msk = CC1TCDIS::mask;
    /// Enumerated values for CC1TCDIS
    namespace cc1tcdis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// CC2 Type-C detector disable The bit disables the Type-C detector on the CC2 line. When enabled, the Type-C detector for CC2 is configured through ANAMODE and ANASUBMODE[1:0].
    /// Position: 21, Width: 1
    /// Access: read-write
    using CC2TCDIS = BitField<21, 1>;
    constexpr uint32_t CC2TCDIS_Pos = 21;
    constexpr uint32_t CC2TCDIS_Msk = CC2TCDIS::mask;
    /// Enumerated values for CC2TCDIS
    namespace cc2tcdis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace ucpd_cr

/// UCPD_IMR - UCPD interrupt mask register
namespace ucpd_imr {
    /// TXIS interrupt enable
    /// Position: 0, Width: 1
    /// Access: read-write
    using TXISIE = BitField<0, 1>;
    constexpr uint32_t TXISIE_Pos = 0;
    constexpr uint32_t TXISIE_Msk = TXISIE::mask;
    /// Enumerated values for TXISIE
    namespace txisie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXMSGDISC interrupt enable
    /// Position: 1, Width: 1
    /// Access: read-write
    using TXMSGDISCIE = BitField<1, 1>;
    constexpr uint32_t TXMSGDISCIE_Pos = 1;
    constexpr uint32_t TXMSGDISCIE_Msk = TXMSGDISCIE::mask;
    /// Enumerated values for TXMSGDISCIE
    namespace txmsgdiscie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXMSGSENT interrupt enable
    /// Position: 2, Width: 1
    /// Access: read-write
    using TXMSGSENTIE = BitField<2, 1>;
    constexpr uint32_t TXMSGSENTIE_Pos = 2;
    constexpr uint32_t TXMSGSENTIE_Msk = TXMSGSENTIE::mask;
    /// Enumerated values for TXMSGSENTIE
    namespace txmsgsentie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXMSGABT interrupt enable
    /// Position: 3, Width: 1
    /// Access: read-write
    using TXMSGABTIE = BitField<3, 1>;
    constexpr uint32_t TXMSGABTIE_Pos = 3;
    constexpr uint32_t TXMSGABTIE_Msk = TXMSGABTIE::mask;
    /// Enumerated values for TXMSGABTIE
    namespace txmsgabtie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// HRSTDISC interrupt enable
    /// Position: 4, Width: 1
    /// Access: read-write
    using HRSTDISCIE = BitField<4, 1>;
    constexpr uint32_t HRSTDISCIE_Pos = 4;
    constexpr uint32_t HRSTDISCIE_Msk = HRSTDISCIE::mask;
    /// Enumerated values for HRSTDISCIE
    namespace hrstdiscie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// HRSTSENT interrupt enable
    /// Position: 5, Width: 1
    /// Access: read-write
    using HRSTSENTIE = BitField<5, 1>;
    constexpr uint32_t HRSTSENTIE_Pos = 5;
    constexpr uint32_t HRSTSENTIE_Msk = HRSTSENTIE::mask;
    /// Enumerated values for HRSTSENTIE
    namespace hrstsentie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TXUND interrupt enable
    /// Position: 6, Width: 1
    /// Access: read-write
    using TXUNDIE = BitField<6, 1>;
    constexpr uint32_t TXUNDIE_Pos = 6;
    constexpr uint32_t TXUNDIE_Msk = TXUNDIE::mask;
    /// Enumerated values for TXUNDIE
    namespace txundie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXNE interrupt enable
    /// Position: 8, Width: 1
    /// Access: read-write
    using RXNEIE = BitField<8, 1>;
    constexpr uint32_t RXNEIE_Pos = 8;
    constexpr uint32_t RXNEIE_Msk = RXNEIE::mask;
    /// Enumerated values for RXNEIE
    namespace rxneie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXORDDET interrupt enable
    /// Position: 9, Width: 1
    /// Access: read-write
    using RXORDDETIE = BitField<9, 1>;
    constexpr uint32_t RXORDDETIE_Pos = 9;
    constexpr uint32_t RXORDDETIE_Msk = RXORDDETIE::mask;
    /// Enumerated values for RXORDDETIE
    namespace rxorddetie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXHRSTDET interrupt enable
    /// Position: 10, Width: 1
    /// Access: read-write
    using RXHRSTDETIE = BitField<10, 1>;
    constexpr uint32_t RXHRSTDETIE_Pos = 10;
    constexpr uint32_t RXHRSTDETIE_Msk = RXHRSTDETIE::mask;
    /// Enumerated values for RXHRSTDETIE
    namespace rxhrstdetie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXOVR interrupt enable
    /// Position: 11, Width: 1
    /// Access: read-write
    using RXOVRIE = BitField<11, 1>;
    constexpr uint32_t RXOVRIE_Pos = 11;
    constexpr uint32_t RXOVRIE_Msk = RXOVRIE::mask;
    /// Enumerated values for RXOVRIE
    namespace rxovrie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// RXMSGEND interrupt enable
    /// Position: 12, Width: 1
    /// Access: read-write
    using RXMSGENDIE = BitField<12, 1>;
    constexpr uint32_t RXMSGENDIE_Pos = 12;
    constexpr uint32_t RXMSGENDIE_Msk = RXMSGENDIE::mask;
    /// Enumerated values for RXMSGENDIE
    namespace rxmsgendie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// TYPECEVT1 interrupt enable
    /// Position: 14, Width: 1
    /// Access: read-write
    using TYPECEVT1IE = BitField<14, 1>;
    constexpr uint32_t TYPECEVT1IE_Pos = 14;
    constexpr uint32_t TYPECEVT1IE_Msk = TYPECEVT1IE::mask;

    /// TYPECEVT2 interrupt enable
    /// Position: 15, Width: 1
    /// Access: read-write
    using TYPECEVT2IE = BitField<15, 1>;
    constexpr uint32_t TYPECEVT2IE_Pos = 15;
    constexpr uint32_t TYPECEVT2IE_Msk = TYPECEVT2IE::mask;
    /// Enumerated values for TYPECEVT2IE
    namespace typecevt2ie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// FRSEVT interrupt enable
    /// Position: 20, Width: 1
    /// Access: read-only
    using FRSEVTIE = BitField<20, 1>;
    constexpr uint32_t FRSEVTIE_Pos = 20;
    constexpr uint32_t FRSEVTIE_Msk = FRSEVTIE::mask;
    /// Enumerated values for FRSEVTIE
    namespace frsevtie {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace ucpd_imr

/// UCPD_SR - UCPD status register
namespace ucpd_sr {
    /// Transmit interrupt status The flag indicates that the UCPD_TXDR register is empty and new data write is required (as the amount of data sent has not reached the payload size defined in the TXPAYSZ bitfield). The flag is cleared with the data write into the UCPD_TXDR register.
    /// Position: 0, Width: 1
    /// Access: read-only
    using TXIS = BitField<0, 1>;
    constexpr uint32_t TXIS_Pos = 0;
    constexpr uint32_t TXIS_Msk = TXIS::mask;
    /// Enumerated values for TXIS
    namespace txis {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Message transmission discarded The flag indicates that a message transmission was dropped. The flag is cleared by setting the TXMSGDISCCF bit. Transmission of a message can be dropped if there is a concurrent receive in progress or at excessive noise on the line. After a Tx message is discarded, the flag is only raised when the CC line becomes idle.
    /// Position: 1, Width: 1
    /// Access: read-only
    using TXMSGDISC = BitField<1, 1>;
    constexpr uint32_t TXMSGDISC_Pos = 1;
    constexpr uint32_t TXMSGDISC_Msk = TXMSGDISC::mask;
    /// Enumerated values for TXMSGDISC
    namespace txmsgdisc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Message transmission completed The flag indicates the completion of packet transmission. It is cleared by setting the TXMSGSENTCF bit. In the event of a message transmission interrupted by a Hard Reset, the flag is not raised.
    /// Position: 2, Width: 1
    /// Access: read-only
    using TXMSGSENT = BitField<2, 1>;
    constexpr uint32_t TXMSGSENT_Pos = 2;
    constexpr uint32_t TXMSGSENT_Msk = TXMSGSENT::mask;
    /// Enumerated values for TXMSGSENT
    namespace txmsgsent {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Transmit message abort The flag indicates that a Tx message is aborted due to a subsequent Hard Reset message send request taking priority during transmit. It is cleared by setting the TXMSGABTCF bit.
    /// Position: 3, Width: 1
    /// Access: read-only
    using TXMSGABT = BitField<3, 1>;
    constexpr uint32_t TXMSGABT_Pos = 3;
    constexpr uint32_t TXMSGABT_Msk = TXMSGABT::mask;
    /// Enumerated values for TXMSGABT
    namespace txmsgabt {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Hard Reset discarded The flag indicates that the Hard Reset message is discarded. The flag is cleared by setting the HRSTDISCCF bit.
    /// Position: 4, Width: 1
    /// Access: read-only
    using HRSTDISC = BitField<4, 1>;
    constexpr uint32_t HRSTDISC_Pos = 4;
    constexpr uint32_t HRSTDISC_Msk = HRSTDISC::mask;
    /// Enumerated values for HRSTDISC
    namespace hrstdisc {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Hard Reset message sent The flag indicates that the Hard Reset message is sent. The flag is cleared by setting the HRSTSENTCF bit.
    /// Position: 5, Width: 1
    /// Access: read-only
    using HRSTSENT = BitField<5, 1>;
    constexpr uint32_t HRSTSENT_Pos = 5;
    constexpr uint32_t HRSTSENT_Msk = HRSTSENT::mask;
    /// Enumerated values for HRSTSENT
    namespace hrstsent {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Tx data underrun detection The flag indicates that the Tx data register (UCPD_TXDR) was not written in time for a transmit message to execute normally. It is cleared by setting the TXUNDCF bit.
    /// Position: 6, Width: 1
    /// Access: read-only
    using TXUND = BitField<6, 1>;
    constexpr uint32_t TXUND_Pos = 6;
    constexpr uint32_t TXUND_Msk = TXUND::mask;
    /// Enumerated values for TXUND
    namespace txund {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receive data register not empty detection The flag indicates that the UCPD_RXDR register is not empty. It is automatically cleared upon reading UCPD_RXDR.
    /// Position: 8, Width: 1
    /// Access: read-only
    using RXNE = BitField<8, 1>;
    constexpr uint32_t RXNE_Pos = 8;
    constexpr uint32_t RXNE_Msk = RXNE::mask;
    /// Enumerated values for RXNE
    namespace rxne {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx ordered set (4 K-codes) detection The flag indicates the detection of an ordered set. The relevant information is stored in the RXORDSET[2:0] bitfield of the UCPD_RX_ORDSET register. It is cleared by setting the RXORDDETCF bit.
    /// Position: 9, Width: 1
    /// Access: read-only
    using RXORDDET = BitField<9, 1>;
    constexpr uint32_t RXORDDET_Pos = 9;
    constexpr uint32_t RXORDDET_Msk = RXORDDET::mask;
    /// Enumerated values for RXORDDET
    namespace rxorddet {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx Hard Reset receipt detection The flag indicates the receipt of valid Hard Reset message. It is cleared by setting the RXHRSTDETCF bit.
    /// Position: 10, Width: 1
    /// Access: read-only
    using RXHRSTDET = BitField<10, 1>;
    constexpr uint32_t RXHRSTDET_Pos = 10;
    constexpr uint32_t RXHRSTDET_Msk = RXHRSTDET::mask;
    /// Enumerated values for RXHRSTDET
    namespace rxhrstdet {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx data overflow detection The flag indicates Rx data buffer overflow. It is cleared by setting the RXOVRCF bit. The buffer overflow can occur if the received data are not read fast enough.
    /// Position: 11, Width: 1
    /// Access: read-only
    using RXOVR = BitField<11, 1>;
    constexpr uint32_t RXOVR_Pos = 11;
    constexpr uint32_t RXOVR_Msk = RXOVR::mask;
    /// Enumerated values for RXOVR
    namespace rxovr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Rx message received The flag indicates whether a message (except Hard Reset message) has been received, regardless the CRC value. The flag is cleared by setting the RXMSGENDCF bit. The RXERR flag set when the RXMSGEND flag goes high indicates errors in the last-received message.
    /// Position: 12, Width: 1
    /// Access: read-only
    using RXMSGEND = BitField<12, 1>;
    constexpr uint32_t RXMSGEND_Pos = 12;
    constexpr uint32_t RXMSGEND_Msk = RXMSGEND::mask;
    /// Enumerated values for RXMSGEND
    namespace rxmsgend {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Receive message error The flag indicates errors of the last Rx message declared (via RXMSGEND), such as incorrect CRC or truncated message (a line becoming static before EOP is met). It is asserted whenever the RXMSGEND flag is set.
    /// Position: 13, Width: 1
    /// Access: read-only
    using RXERR = BitField<13, 1>;
    constexpr uint32_t RXERR_Pos = 13;
    constexpr uint32_t RXERR_Msk = RXERR::mask;
    /// Enumerated values for RXERR
    namespace rxerr {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Type-C voltage level event on CC1 line The flag indicates a change of the TYPEC_VSTATE_CC1[1:0] bitfield value, which corresponds to a new Type-C event. It is cleared by setting the TYPECEVT2CF bit.
    /// Position: 14, Width: 1
    /// Access: read-only
    using TYPECEVT1 = BitField<14, 1>;
    constexpr uint32_t TYPECEVT1_Pos = 14;
    constexpr uint32_t TYPECEVT1_Msk = TYPECEVT1::mask;
    /// Enumerated values for TYPECEVT1
    namespace typecevt1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// Type-C voltage level event on CC2 line The flag indicates a change of the TYPEC_VSTATE_CC2[1:0] bitfield value, which corresponds to a new Type-C event. It is cleared by setting the TYPECEVT2CF bit.
    /// Position: 15, Width: 1
    /// Access: read-only
    using TYPECEVT2 = BitField<15, 1>;
    constexpr uint32_t TYPECEVT2_Pos = 15;
    constexpr uint32_t TYPECEVT2_Msk = TYPECEVT2::mask;
    /// Enumerated values for TYPECEVT2
    namespace typecevt2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// The status bitfield indicates the voltage level on the CC1 line in its steady state. The voltage variation on the CC1 line during USB PD messages due to the BMC PHY modulation does not impact the bitfield value.
    /// Position: 16, Width: 2
    /// Access: read-only
    using TYPEC_VSTATE_CC1 = BitField<16, 2>;
    constexpr uint32_t TYPEC_VSTATE_CC1_Pos = 16;
    constexpr uint32_t TYPEC_VSTATE_CC1_Msk = TYPEC_VSTATE_CC1::mask;
    /// Enumerated values for TYPEC_VSTATE_CC1
    namespace typec_vstate_cc1 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// CC2 line voltage level The status bitfield indicates the voltage level on the CC2 line in its steady state. The voltage variation on the CC2 line during USB PD messages due to the BMC PHY modulation does not impact the bitfield value.
    /// Position: 18, Width: 2
    /// Access: read-only
    using TYPEC_VSTATE_CC2 = BitField<18, 2>;
    constexpr uint32_t TYPEC_VSTATE_CC2_Pos = 18;
    constexpr uint32_t TYPEC_VSTATE_CC2_Msk = TYPEC_VSTATE_CC2::mask;
    /// Enumerated values for TYPEC_VSTATE_CC2
    namespace typec_vstate_cc2 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
    }

    /// FRS detection event The flag is cleared by setting the FRSEVTCF bit.
    /// Position: 20, Width: 1
    /// Access: read-only
    using FRSEVT = BitField<20, 1>;
    constexpr uint32_t FRSEVT_Pos = 20;
    constexpr uint32_t FRSEVT_Msk = FRSEVT::mask;
    /// Enumerated values for FRSEVT
    namespace frsevt {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

}  // namespace ucpd_sr

/// UCPD_ICR - UCPD interrupt clear register
namespace ucpd_icr {
    /// Tx message discard flag (TXMSGDISC) clear Setting the bit clears the TXMSGDISC flag in the UCPD_SR register.
    /// Position: 1, Width: 1
    /// Access: write-only
    using TXMSGDISCCF = BitField<1, 1>;
    constexpr uint32_t TXMSGDISCCF_Pos = 1;
    constexpr uint32_t TXMSGDISCCF_Msk = TXMSGDISCCF::mask;

    /// Tx message send flag (TXMSGSENT) clear Setting the bit clears the TXMSGSENT flag in the UCPD_SR register.
    /// Position: 2, Width: 1
    /// Access: write-only
    using TXMSGSENTCF = BitField<2, 1>;
    constexpr uint32_t TXMSGSENTCF_Pos = 2;
    constexpr uint32_t TXMSGSENTCF_Msk = TXMSGSENTCF::mask;

    /// Tx message abort flag (TXMSGABT) clear Setting the bit clears the TXMSGABT flag in the UCPD_SR register.
    /// Position: 3, Width: 1
    /// Access: write-only
    using TXMSGABTCF = BitField<3, 1>;
    constexpr uint32_t TXMSGABTCF_Pos = 3;
    constexpr uint32_t TXMSGABTCF_Msk = TXMSGABTCF::mask;

    /// Hard reset discard flag (HRSTDISC) clear Setting the bit clears the HRSTDISC flag in the UCPD_SR register.
    /// Position: 4, Width: 1
    /// Access: write-only
    using HRSTDISCCF = BitField<4, 1>;
    constexpr uint32_t HRSTDISCCF_Pos = 4;
    constexpr uint32_t HRSTDISCCF_Msk = HRSTDISCCF::mask;

    /// Hard reset send flag (HRSTSENT) clear Setting the bit clears the HRSTSENT flag in the UCPD_SR register.
    /// Position: 5, Width: 1
    /// Access: write-only
    using HRSTSENTCF = BitField<5, 1>;
    constexpr uint32_t HRSTSENTCF_Pos = 5;
    constexpr uint32_t HRSTSENTCF_Msk = HRSTSENTCF::mask;

    /// Tx underflow flag (TXUND) clear Setting the bit clears the TXUND flag in the UCPD_SR register.
    /// Position: 6, Width: 1
    /// Access: write-only
    using TXUNDCF = BitField<6, 1>;
    constexpr uint32_t TXUNDCF_Pos = 6;
    constexpr uint32_t TXUNDCF_Msk = TXUNDCF::mask;

    /// Rx ordered set detect flag (RXORDDET) clear Setting the bit clears the RXORDDET flag in the UCPD_SR register.
    /// Position: 9, Width: 1
    /// Access: write-only
    using RXORDDETCF = BitField<9, 1>;
    constexpr uint32_t RXORDDETCF_Pos = 9;
    constexpr uint32_t RXORDDETCF_Msk = RXORDDETCF::mask;

    /// Rx Hard Reset detect flag (RXHRSTDET) clear Setting the bit clears the RXHRSTDET flag in the UCPD_SR register.
    /// Position: 10, Width: 1
    /// Access: write-only
    using RXHRSTDETCF = BitField<10, 1>;
    constexpr uint32_t RXHRSTDETCF_Pos = 10;
    constexpr uint32_t RXHRSTDETCF_Msk = RXHRSTDETCF::mask;

    /// Rx overflow flag (RXOVR) clear Setting the bit clears the RXOVR flag in the UCPD_SR register.
    /// Position: 11, Width: 1
    /// Access: write-only
    using RXOVRCF = BitField<11, 1>;
    constexpr uint32_t RXOVRCF_Pos = 11;
    constexpr uint32_t RXOVRCF_Msk = RXOVRCF::mask;

    /// Rx message received flag (RXMSGEND) clear Setting the bit clears the RXMSGEND flag in the UCPD_SR register.
    /// Position: 12, Width: 1
    /// Access: write-only
    using RXMSGENDCF = BitField<12, 1>;
    constexpr uint32_t RXMSGENDCF_Pos = 12;
    constexpr uint32_t RXMSGENDCF_Msk = RXMSGENDCF::mask;

    /// Type-C CC1 event flag (TYPECEVT1) clear Setting the bit clears the TYPECEVT1 flag in the UCPD_SR register
    /// Position: 14, Width: 1
    /// Access: write-only
    using TYPECEVT1CF = BitField<14, 1>;
    constexpr uint32_t TYPECEVT1CF_Pos = 14;
    constexpr uint32_t TYPECEVT1CF_Msk = TYPECEVT1CF::mask;

    /// Type-C CC2 line event flag (TYPECEVT2) clear Setting the bit clears the TYPECEVT2 flag in the UCPD_SR register
    /// Position: 15, Width: 1
    /// Access: write-only
    using TYPECEVT2CF = BitField<15, 1>;
    constexpr uint32_t TYPECEVT2CF_Pos = 15;
    constexpr uint32_t TYPECEVT2CF_Msk = TYPECEVT2CF::mask;

    /// FRS event flag (FRSEVT) clear Setting the bit clears the FRSEVT flag in the UCPD_SR register.
    /// Position: 20, Width: 1
    /// Access: write-only
    using FRSEVTCF = BitField<20, 1>;
    constexpr uint32_t FRSEVTCF_Pos = 20;
    constexpr uint32_t FRSEVTCF_Msk = FRSEVTCF::mask;

}  // namespace ucpd_icr

/// UCPD_TX_ORDSETR - UCPD Tx ordered set type register
namespace ucpd_tx_ordsetr {
    /// Ordered set to transmit The bitfield determines a full 20-bit sequence to transmit, consisting of four K-codes, each of five bits, defining the packet to transmit. The bit 0 (bit 0 of K-code1) is the first, the bit 19 (bit 4 of K‑code4) the last.
    /// Position: 0, Width: 20
    /// Access: read-write
    using TXORDSET = BitField<0, 20>;
    constexpr uint32_t TXORDSET_Pos = 0;
    constexpr uint32_t TXORDSET_Msk = TXORDSET::mask;

}  // namespace ucpd_tx_ordsetr

/// UCPD_TX_PAYSZR - UCPD Tx payload size register
namespace ucpd_tx_payszr {
    /// Payload size yet to transmit The bitfield is modified by software and by hardware. It contains the number of bytes of a payload (including header but excluding CRC) yet to transmit: each time a data byte is written into the UCPD_TXDR register, the bitfield value decrements and the TXIS bit is set, except when the bitfield value reaches zero. The enumerated values are standard payload sizes before the start of transmission.
    /// Position: 0, Width: 10
    /// Access: read-write
    using TXPAYSZ = BitField<0, 10>;
    constexpr uint32_t TXPAYSZ_Pos = 0;
    constexpr uint32_t TXPAYSZ_Msk = TXPAYSZ::mask;
    /// Enumerated values for TXPAYSZ
    namespace txpaysz {
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x1E = 30;
        constexpr uint32_t B_0x106 = 262;
        constexpr uint32_t B_0x3FF = 1023;
    }

}  // namespace ucpd_tx_payszr

/// UCPD_TXDR - UCPD Tx data register
namespace ucpd_txdr {
    /// Data byte to transmit
    /// Position: 0, Width: 8
    /// Access: read-write
    using TXDATA = BitField<0, 8>;
    constexpr uint32_t TXDATA_Pos = 0;
    constexpr uint32_t TXDATA_Msk = TXDATA::mask;

}  // namespace ucpd_txdr

/// UCPD_RX_ORDSETR - UCPD Rx ordered set register
namespace ucpd_rx_ordsetr {
    /// Rx ordered set code detected
    /// Position: 0, Width: 3
    /// Access: read-only
    using RXORDSET = BitField<0, 3>;
    constexpr uint32_t RXORDSET_Pos = 0;
    constexpr uint32_t RXORDSET_Msk = RXORDSET::mask;
    /// Enumerated values for RXORDSET
    namespace rxordset {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
        constexpr uint32_t B_0x5 = 5;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x7 = 7;
    }

    /// The bit indicates the number of correct K‑codes. For debug purposes only.
    /// Position: 3, Width: 1
    /// Access: read-only
    using RXSOP3OF4 = BitField<3, 1>;
    constexpr uint32_t RXSOP3OF4_Pos = 3;
    constexpr uint32_t RXSOP3OF4_Msk = RXSOP3OF4::mask;
    /// Enumerated values for RXSOP3OF4
    namespace rxsop3of4 {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
    }

    /// The bitfield is for debug purposes only. Others: Invalid
    /// Position: 4, Width: 3
    /// Access: read-only
    using RXSOPKINVALID = BitField<4, 3>;
    constexpr uint32_t RXSOPKINVALID_Pos = 4;
    constexpr uint32_t RXSOPKINVALID_Msk = RXSOPKINVALID::mask;
    /// Enumerated values for RXSOPKINVALID
    namespace rxsopkinvalid {
        constexpr uint32_t B_0x0 = 0;
        constexpr uint32_t B_0x1 = 1;
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x3 = 3;
        constexpr uint32_t B_0x4 = 4;
    }

}  // namespace ucpd_rx_ordsetr

/// UCPD_RX_PAYSZR - UCPD Rx payload size register
namespace ucpd_rx_payszr {
    /// Rx payload size received This bitfield contains the number of bytes of a payload (including header but excluding CRC) received: each time a new data byte is received in the UCPD_RXDR register, the bitfield value increments and the RXMSGEND flag is set (and an interrupt generated if enabled). The bitfield may return a spurious value when a byte reception is ongoing (the RXMSGEND flag is low).
    /// Position: 0, Width: 10
    /// Access: read-only
    using RXPAYSZ = BitField<0, 10>;
    constexpr uint32_t RXPAYSZ_Pos = 0;
    constexpr uint32_t RXPAYSZ_Msk = RXPAYSZ::mask;
    /// Enumerated values for RXPAYSZ
    namespace rxpaysz {
        constexpr uint32_t B_0x2 = 2;
        constexpr uint32_t B_0x6 = 6;
        constexpr uint32_t B_0x1E = 30;
        constexpr uint32_t B_0x106 = 262;
        constexpr uint32_t B_0x3FF = 1023;
    }

}  // namespace ucpd_rx_payszr

/// UCPD_RXDR - UCPD receive data register
namespace ucpd_rxdr {
    /// Data byte received
    /// Position: 0, Width: 8
    /// Access: read-only
    using RXDATA = BitField<0, 8>;
    constexpr uint32_t RXDATA_Pos = 0;
    constexpr uint32_t RXDATA_Msk = RXDATA::mask;

}  // namespace ucpd_rxdr

/// UCPD_RX_ORDEXTR1 - UCPD Rx ordered set extension register 1
namespace ucpd_rx_ordextr1 {
    /// Ordered set 1 received The bitfield contains a full 20-bit sequence received, consisting of four K‑codes, each of five bits. The bit 0 (bit 0 of K‑code1) is receive first, the bit 19 (bit 4 of K‑code4) last.
    /// Position: 0, Width: 20
    /// Access: read-write
    using RXSOPX1 = BitField<0, 20>;
    constexpr uint32_t RXSOPX1_Pos = 0;
    constexpr uint32_t RXSOPX1_Msk = RXSOPX1::mask;

}  // namespace ucpd_rx_ordextr1

/// UCPD_RX_ORDEXTR2 - UCPD Rx ordered set extension register 2
namespace ucpd_rx_ordextr2 {
    /// Ordered set 2 received The bitfield contains a full 20-bit sequence received, consisting of four K‑codes, each of five bits. The bit 0 (bit 0 of K‑code1) is receive first, the bit 19 (bit 4 of K‑code4) last.
    /// Position: 0, Width: 20
    /// Access: read-write
    using RXSOPX2 = BitField<0, 20>;
    constexpr uint32_t RXSOPX2_Pos = 0;
    constexpr uint32_t RXSOPX2_Msk = RXSOPX2::mask;

}  // namespace ucpd_rx_ordextr2

}  // namespace alloy::hal::st::stm32g0::ucpd1
