/// Auto-generated register definitions for ADC
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::st::stm32g0::adc {

// ============================================================================
// ADC - Analog to Digital Converter
// Base Address: 0x40012400
// ============================================================================

/// ADC Register Structure
struct ADC_Registers {

    /// ADC interrupt and status register
    /// Offset: 0x0000
    /// Reset value: 0x00000000
    volatile uint32_t ADC_ISR;

    /// ADC interrupt enable register
    /// Offset: 0x0004
    /// Reset value: 0x00000000
    volatile uint32_t ADC_IER;

    /// ADC control register
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    volatile uint32_t ADC_CR;

    /// ADC configuration register 1
    /// Offset: 0x000C
    /// Reset value: 0x00000000
    volatile uint32_t ADC_CFGR1;

    /// ADC configuration register 2
    /// Offset: 0x0010
    /// Reset value: 0x00000000
    volatile uint32_t ADC_CFGR2;

    /// ADC sampling time register
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    volatile uint32_t ADC_SMPR;
    uint8_t RESERVED_0018[8]; ///< Reserved

    /// ADC watchdog threshold register
    /// Offset: 0x0020
    /// Reset value: 0x0FFF0000
    volatile uint32_t ADC_AWD1TR;

    /// ADC watchdog threshold register
    /// Offset: 0x0024
    /// Reset value: 0x0FFF0000
    volatile uint32_t ADC_AWD2TR;

    /// ADC channel selection register [alternate]
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    volatile uint32_t ADC_CHSELR;

    /// channel selection register CHSELRMOD = 1 in ADC_CFGR1
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    volatile uint32_t CHSELR_1;

    /// ADC watchdog threshold register
    /// Offset: 0x002C
    /// Reset value: 0x0FFF0000
    volatile uint32_t ADC_AWD3TR;
    uint8_t RESERVED_0030[16]; ///< Reserved

    /// ADC data register
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    volatile uint32_t ADC_DR;
    uint8_t RESERVED_0044[92]; ///< Reserved

    /// ADC Analog Watchdog 2 Configuration register
    /// Offset: 0x00A0
    /// Reset value: 0x00000000
    volatile uint32_t ADC_AWD2CR;

    /// ADC Analog Watchdog 3 Configuration register
    /// Offset: 0x00A4
    /// Reset value: 0x00000000
    volatile uint32_t ADC_AWD3CR;
    uint8_t RESERVED_00A8[12]; ///< Reserved

    /// ADC Calibration factor
    /// Offset: 0x00B4
    /// Reset value: 0x00000000
    volatile uint32_t ADC_CALFACT;
    uint8_t RESERVED_00B8[592]; ///< Reserved

    /// ADC common configuration register
    /// Offset: 0x0308
    /// Reset value: 0x00000000
    volatile uint32_t ADC_CCR;
};

static_assert(sizeof(ADC_Registers) >= 780, "ADC_Registers size mismatch");

/// ADC peripheral instance
inline ADC_Registers* ADC() {
    return reinterpret_cast<ADC_Registers*>(0x40012400);
}

}  // namespace alloy::hal::st::stm32g0::adc
