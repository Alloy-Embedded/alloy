/// Auto-generated register definitions for RCC
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::st::stm32g0::rcc {

// ============================================================================
// RCC - Reset and clock control
// Base Address: 0x40021000
// ============================================================================

/// RCC Register Structure
struct RCC_Registers {

    /// Clock control register
    /// Offset: 0x0000
    /// Reset value: 0x00000500
    /// Access: read-write
    volatile uint32_t CR;

    /// Internal clock sources calibration register
    /// Offset: 0x0004
    /// Reset value: 0x00004000
    volatile uint32_t ICSCR;

    /// Clock configuration register
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    volatile uint32_t CFGR;

    /// PLL configuration register
    /// Offset: 0x000C
    /// Reset value: 0x00001000
    /// Access: read-write
    volatile uint32_t PLLCFGR;
    uint8_t RESERVED_0010[4]; ///< Reserved

    /// RCC clock recovery RC register
    /// Offset: 0x0014
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t CRRCR;

    /// Clock interrupt enable register
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CIER;

    /// Clock interrupt flag register
    /// Offset: 0x001C
    /// Reset value: 0x00000000
    /// Access: read-only
    volatile uint32_t CIFR;

    /// Clock interrupt clear register
    /// Offset: 0x0020
    /// Reset value: 0x00000000
    /// Access: write-only
    volatile uint32_t CICR;

    /// I/O port reset register
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t IOPRSTR;

    /// AHB peripheral reset register
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t AHBRSTR;

    /// APB peripheral reset register 1
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t APBRSTR1;

    /// APB peripheral reset register 2
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t APBRSTR2;

    /// GPIO clock enable register
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t IOPENR;

    /// AHB peripheral clock enable register
    /// Offset: 0x0038
    /// Reset value: 0x00000100
    /// Access: read-write
    volatile uint32_t AHBENR;

    /// APB peripheral clock enable register 1
    /// Offset: 0x003C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t APBENR1;

    /// APB peripheral clock enable register 2
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t APBENR2;

    /// GPIO in Sleep mode clock enable register
    /// Offset: 0x0044
    /// Reset value: 0x0000003F
    /// Access: read-write
    volatile uint32_t IOPSMENR;

    /// AHB peripheral clock enable in Sleep mode register
    /// Offset: 0x0048
    /// Reset value: 0x00051303
    /// Access: read-write
    volatile uint32_t AHBSMENR;

    /// APB peripheral clock enable in Sleep mode register 1
    /// Offset: 0x004C
    /// Reset value: 0xFFFFFFB7
    /// Access: read-write
    volatile uint32_t APBSMENR1;

    /// APB peripheral clock enable in Sleep mode register 2
    /// Offset: 0x0050
    /// Reset value: 0x0017D801
    /// Access: read-write
    volatile uint32_t APBSMENR2;

    /// Peripherals independent clock configuration register
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CCIPR;

    /// Peripherals independent clock configuration register 2
    /// Offset: 0x0058
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CCIPR2;

    /// RTC domain control register
    /// Offset: 0x005C
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t BDCR;

    /// Control/status register
    /// Offset: 0x0060
    /// Reset value: 0x00000000
    /// Access: read-write
    volatile uint32_t CSR;
};

static_assert(sizeof(RCC_Registers) >= 100, "RCC_Registers size mismatch");

/// RCC peripheral instance
inline RCC_Registers* RCC() {
    return reinterpret_cast<RCC_Registers*>(0x40021000);
}

}  // namespace alloy::hal::st::stm32g0::rcc
