/// Auto-generated register definitions for RTC
/// Family: stm32g0
/// Vendor: STMicro
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::st::stm32g0::rtc {

// ============================================================================
// RTC - Real-time clock
// Base Address: 0x40002800
// ============================================================================

/// RTC Register Structure
struct RTC_Registers {

    /// RTC time register
    /// Offset: 0x0000
    /// Reset value: 0x00000007
    volatile uint32_t RTC_TR;

    /// RTC date register
    /// Offset: 0x0004
    /// Reset value: 0x00002101
    volatile uint32_t RTC_DR;

    /// RTC sub second register
    /// Offset: 0x0008
    /// Reset value: 0x00000000
    volatile uint32_t RTC_SSR;

    /// RTC initialization control and status register
    /// Offset: 0x000C
    /// Reset value: 0x00000007
    volatile uint32_t RTC_ICSR;

    /// RTC prescaler register
    /// Offset: 0x0010
    /// Reset value: 0x007F00FF
    volatile uint32_t RTC_PRER;

    /// RTC wakeup timer register
    /// Offset: 0x0014
    /// Reset value: 0x0000FFFF
    volatile uint32_t RTC_WUTR;

    /// RTC control register
    /// Offset: 0x0018
    /// Reset value: 0x00000000
    volatile uint32_t RTC_CR;
    uint8_t RESERVED_001C[8]; ///< Reserved

    /// RTC write protection register
    /// Offset: 0x0024
    /// Reset value: 0x00000000
    volatile uint32_t RTC_WPR;

    /// RTC calibration register
    /// Offset: 0x0028
    /// Reset value: 0x00000000
    volatile uint32_t RTC_CALR;

    /// RTC shift control register
    /// Offset: 0x002C
    /// Reset value: 0x00000000
    volatile uint32_t RTC_SHIFTR;

    /// RTC timestamp time register
    /// Offset: 0x0030
    /// Reset value: 0x00000000
    volatile uint32_t RTC_TSTR;

    /// RTC timestamp date register
    /// Offset: 0x0034
    /// Reset value: 0x00000000
    volatile uint32_t RTC_TSDR;

    /// RTC timestamp sub second register
    /// Offset: 0x0038
    /// Reset value: 0x00000000
    volatile uint32_t RTC_TSSSR;
    uint8_t RESERVED_003C[4]; ///< Reserved

    /// RTC alarm A register
    /// Offset: 0x0040
    /// Reset value: 0x00000000
    volatile uint32_t RTC_ALRMAR;

    /// RTC alarm A sub second register
    /// Offset: 0x0044
    /// Reset value: 0x00000000
    volatile uint32_t RTC_ALRMASSR;

    /// RTC alarm B register
    /// Offset: 0x0048
    /// Reset value: 0x00000000
    volatile uint32_t RTC_ALRMBR;

    /// RTC alarm B sub second register
    /// Offset: 0x004C
    /// Reset value: 0x00000000
    volatile uint32_t RTC_ALRMBSSR;

    /// RTC status register
    /// Offset: 0x0050
    /// Reset value: 0x00000000
    volatile uint32_t RTC_SR;

    /// RTC masked interrupt status register
    /// Offset: 0x0054
    /// Reset value: 0x00000000
    volatile uint32_t RTC_MISR;
    uint8_t RESERVED_0058[4]; ///< Reserved

    /// RTC status clear register
    /// Offset: 0x005C
    /// Reset value: 0x00000000
    volatile uint32_t RTC_SCR;
};

static_assert(sizeof(RTC_Registers) >= 96, "RTC_Registers size mismatch");

/// RTC peripheral instance
inline RTC_Registers* RTC() {
    return reinterpret_cast<RTC_Registers*>(0x40002800);
}

}  // namespace alloy::hal::st::stm32g0::rtc
