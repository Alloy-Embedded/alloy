/// Auto-generated enumeration definitions
/// Device: MSP432P411V
/// Vendor: Texas Instruments
///
/// This file contains type-safe enum classes for all register field
/// enumerated values extracted from the CMSIS-SVD file.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::ti::msp432::msp432p411v::enums {

// ============================================================================
// ENUMERATED VALUE DEFINITIONS
// ============================================================================

// ----------------------------------------------------------------------------
// ADC14 - ADC14
// ----------------------------------------------------------------------------

/// ADC14 start conversion
/// Register: ADC14CTL0
/// Field: ADC14SC [0:0]
enum class ADC14_ADC14CTL0_ADC14SC : uint32_t {
    ADC14SC_0 = 0x0,
    ADC14SC_1 = 0x1,
};

/// ADC14 enable conversion
/// Register: ADC14CTL0
/// Field: ADC14ENC [1:1]
enum class ADC14_ADC14CTL0_ADC14ENC : uint32_t {
    ADC14ENC_0 = 0x0,
    ADC14ENC_1 = 0x1,
};

/// ADC14 on
/// Register: ADC14CTL0
/// Field: ADC14ON [4:4]
enum class ADC14_ADC14CTL0_ADC14ON : uint32_t {
    ADC14ON_0 = 0x0,
    ADC14ON_1 = 0x1,
};

/// ADC14 multiple sample and conversion
/// Register: ADC14CTL0
/// Field: ADC14MSC [7:7]
enum class ADC14_ADC14CTL0_ADC14MSC : uint32_t {
    ADC14MSC_0 = 0x0,
    ADC14MSC_1 = 0x1,
};

/// ADC14 sample-and-hold time
/// Register: ADC14CTL0
/// Field: ADC14SHT0 [8:11]
enum class ADC14_ADC14CTL0_ADC14SHT0 : uint32_t {
    ADC14SHT0_0 = 0x0,
    ADC14SHT0_1 = 0x1,
    ADC14SHT0_2 = 0x2,
    ADC14SHT0_3 = 0x3,
    ADC14SHT0_4 = 0x4,
    ADC14SHT0_5 = 0x5,
    ADC14SHT0_6 = 0x6,
    ADC14SHT0_7 = 0x7,
};

/// ADC14 sample-and-hold time
/// Register: ADC14CTL0
/// Field: ADC14SHT1 [12:15]
enum class ADC14_ADC14CTL0_ADC14SHT1 : uint32_t {
    ADC14SHT1_0 = 0x0,
    ADC14SHT1_1 = 0x1,
    ADC14SHT1_2 = 0x2,
    ADC14SHT1_3 = 0x3,
    ADC14SHT1_4 = 0x4,
    ADC14SHT1_5 = 0x5,
    ADC14SHT1_6 = 0x6,
    ADC14SHT1_7 = 0x7,
};

/// ADC14 busy
/// Register: ADC14CTL0
/// Field: ADC14BUSY [16:16]
enum class ADC14_ADC14CTL0_ADC14BUSY : uint32_t {
    ADC14BUSY_0 = 0x0,
    ADC14BUSY_1 = 0x1,
};

/// ADC14 conversion sequence mode select
/// Register: ADC14CTL0
/// Field: ADC14CONSEQ [17:18]
enum class ADC14_ADC14CTL0_ADC14CONSEQ : uint32_t {
    ADC14CONSEQ_0 = 0x0,
    ADC14CONSEQ_1 = 0x1,
    ADC14CONSEQ_2 = 0x2,
    ADC14CONSEQ_3 = 0x3,
};

/// ADC14 clock source select
/// Register: ADC14CTL0
/// Field: ADC14SSEL [19:21]
enum class ADC14_ADC14CTL0_ADC14SSEL : uint32_t {
    ADC14SSEL_0 = 0x0,
    ADC14SSEL_1 = 0x1,
    ADC14SSEL_2 = 0x2,
    ADC14SSEL_3 = 0x3,
    ADC14SSEL_4 = 0x4,
    ADC14SSEL_5 = 0x5,
};

/// ADC14 clock divider
/// Register: ADC14CTL0
/// Field: ADC14DIV [22:24]
enum class ADC14_ADC14CTL0_ADC14DIV : uint32_t {
    ADC14DIV_0 = 0x0,
    ADC14DIV_1 = 0x1,
    ADC14DIV_2 = 0x2,
    ADC14DIV_3 = 0x3,
    ADC14DIV_4 = 0x4,
    ADC14DIV_5 = 0x5,
    ADC14DIV_6 = 0x6,
    ADC14DIV_7 = 0x7,
};

/// ADC14 invert signal sample-and-hold
/// Register: ADC14CTL0
/// Field: ADC14ISSH [25:25]
enum class ADC14_ADC14CTL0_ADC14ISSH : uint32_t {
    ADC14ISSH_0 = 0x0,
    ADC14ISSH_1 = 0x1,
};

/// ADC14 sample-and-hold pulse-mode select
/// Register: ADC14CTL0
/// Field: ADC14SHP [26:26]
enum class ADC14_ADC14CTL0_ADC14SHP : uint32_t {
    ADC14SHP_0 = 0x0,
    ADC14SHP_1 = 0x1,
};

/// ADC14 sample-and-hold source select
/// Register: ADC14CTL0
/// Field: ADC14SHS [27:29]
enum class ADC14_ADC14CTL0_ADC14SHS : uint32_t {
    ADC14SHS_0 = 0x0,
    ADC14SHS_1 = 0x1,
    ADC14SHS_2 = 0x2,
    ADC14SHS_3 = 0x3,
    ADC14SHS_4 = 0x4,
    ADC14SHS_5 = 0x5,
    ADC14SHS_6 = 0x6,
    ADC14SHS_7 = 0x7,
};

/// ADC14 predivider
/// Register: ADC14CTL0
/// Field: ADC14PDIV [30:31]
enum class ADC14_ADC14CTL0_ADC14PDIV : uint32_t {
    ADC14PDIV_0 = 0x0,
    ADC14PDIV_1 = 0x1,
    ADC14PDIV_2 = 0x2,
    ADC14PDIV_3 = 0x3,
};

/// ADC14 power modes
/// Register: ADC14CTL1
/// Field: ADC14PWRMD [0:1]
enum class ADC14_ADC14CTL1_ADC14PWRMD : uint32_t {
    ADC14PWRMD_0 = 0x0,
    ADC14PWRMD_2 = 0x2,
};

/// ADC14 reference buffer burst
/// Register: ADC14CTL1
/// Field: ADC14REFBURST [2:2]
enum class ADC14_ADC14CTL1_ADC14REFBURST : uint32_t {
    ADC14REFBURST_0 = 0x0,
    ADC14REFBURST_1 = 0x1,
};

/// ADC14 data read-back format
/// Register: ADC14CTL1
/// Field: ADC14DF [3:3]
enum class ADC14_ADC14CTL1_ADC14DF : uint32_t {
    ADC14DF_0 = 0x0,
    ADC14DF_1 = 0x1,
};

/// ADC14 resolution
/// Register: ADC14CTL1
/// Field: ADC14RES [4:5]
enum class ADC14_ADC14CTL1_ADC14RES : uint32_t {
    ADC14RES_0 = 0x0,
    ADC14RES_1 = 0x1,
    ADC14RES_2 = 0x2,
    ADC14RES_3 = 0x3,
};

/// Controls 1/2 AVCC ADC input channel selection
/// Register: ADC14CTL1
/// Field: ADC14BATMAP [22:22]
enum class ADC14_ADC14CTL1_ADC14BATMAP : uint32_t {
    ADC14BATMAP_0 = 0x0,
    ADC14BATMAP_1 = 0x1,
};

/// Controls temperature sensor ADC input channel selection
/// Register: ADC14CTL1
/// Field: ADC14TCMAP [23:23]
enum class ADC14_ADC14CTL1_ADC14TCMAP : uint32_t {
    ADC14TCMAP_0 = 0x0,
    ADC14TCMAP_1 = 0x1,
};

/// Controls internal channel 0 selection to ADC input channel MAX-2
/// Register: ADC14CTL1
/// Field: ADC14CH0MAP [24:24]
enum class ADC14_ADC14CTL1_ADC14CH0MAP : uint32_t {
    ADC14CH0MAP_0 = 0x0,
    ADC14CH0MAP_1 = 0x1,
};

/// Controls internal channel 1 selection to ADC input channel MAX-3
/// Register: ADC14CTL1
/// Field: ADC14CH1MAP [25:25]
enum class ADC14_ADC14CTL1_ADC14CH1MAP : uint32_t {
    ADC14CH1MAP_0 = 0x0,
    ADC14CH1MAP_1 = 0x1,
};

/// Controls internal channel 2 selection to ADC input channel MAX-4
/// Register: ADC14CTL1
/// Field: ADC14CH2MAP [26:26]
enum class ADC14_ADC14CTL1_ADC14CH2MAP : uint32_t {
    ADC14CH2MAP_0 = 0x0,
    ADC14CH2MAP_1 = 0x1,
};

/// Controls internal channel 3 selection to ADC input channel MAX-5
/// Register: ADC14CTL1
/// Field: ADC14CH3MAP [27:27]
enum class ADC14_ADC14CTL1_ADC14CH3MAP : uint32_t {
    ADC14CH3MAP_0 = 0x0,
    ADC14CH3MAP_1 = 0x1,
};

/// Input channel select
/// Register: ADC14MCTL[%s]
/// Field: ADC14INCH [0:4]
enum class ADC14_ADC14MCTL[%S]_ADC14INCH : uint32_t {
    ADC14INCH_0 = 0x0,
    ADC14INCH_1 = 0x1,
    ADC14INCH_2 = 0x2,
    ADC14INCH_3 = 0x3,
    ADC14INCH_4 = 0x4,
    ADC14INCH_5 = 0x5,
    ADC14INCH_6 = 0x6,
    ADC14INCH_7 = 0x7,
    ADC14INCH_8 = 0x8,
    ADC14INCH_9 = 0x9,
    ADC14INCH_10 = 0xA,
    ADC14INCH_11 = 0xB,
    ADC14INCH_12 = 0xC,
    ADC14INCH_13 = 0xD,
    ADC14INCH_14 = 0xE,
    ADC14INCH_15 = 0xF,
    ADC14INCH_16 = 0x10,
    ADC14INCH_17 = 0x11,
    ADC14INCH_18 = 0x12,
    ADC14INCH_19 = 0x13,
    ADC14INCH_20 = 0x14,
    ADC14INCH_21 = 0x15,
    ADC14INCH_22 = 0x16,
    ADC14INCH_23 = 0x17,
    ADC14INCH_24 = 0x18,
    ADC14INCH_25 = 0x19,
    ADC14INCH_26 = 0x1A,
    ADC14INCH_27 = 0x1B,
    ADC14INCH_28 = 0x1C,
    ADC14INCH_29 = 0x1D,
    ADC14INCH_30 = 0x1E,
    ADC14INCH_31 = 0x1F,
};

/// End of sequence
/// Register: ADC14MCTL[%s]
/// Field: ADC14EOS [7:7]
enum class ADC14_ADC14MCTL[%S]_ADC14EOS : uint32_t {
    ADC14EOS_0 = 0x0,
    ADC14EOS_1 = 0x1,
};

/// Selects combinations of V(R+) and V(R-) sources
/// Register: ADC14MCTL[%s]
/// Field: ADC14VRSEL [8:11]
enum class ADC14_ADC14MCTL[%S]_ADC14VRSEL : uint32_t {
    ADC14VRSEL_0 = 0x0,
    ADC14VRSEL_1 = 0x1,
    ADC14VRSEL_14 = 0xE,
    ADC14VRSEL_15 = 0xF,
};

/// Differential mode
/// Register: ADC14MCTL[%s]
/// Field: ADC14DIF [13:13]
enum class ADC14_ADC14MCTL[%S]_ADC14DIF : uint32_t {
    ADC14DIF_0 = 0x0,
    ADC14DIF_1 = 0x1,
};

/// Comparator window enable
/// Register: ADC14MCTL[%s]
/// Field: ADC14WINC [14:14]
enum class ADC14_ADC14MCTL[%S]_ADC14WINC : uint32_t {
    ADC14WINC_0 = 0x0,
    ADC14WINC_1 = 0x1,
};

/// Window comparator threshold register selection
/// Register: ADC14MCTL[%s]
/// Field: ADC14WINCTH [15:15]
enum class ADC14_ADC14MCTL[%S]_ADC14WINCTH : uint32_t {
    ADC14WINCTH_0 = 0x0,
    ADC14WINCTH_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE0 [0:0]
enum class ADC14_ADC14IER0_ADC14IE0 : uint32_t {
    ADC14IE0_0 = 0x0,
    ADC14IE0_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE1 [1:1]
enum class ADC14_ADC14IER0_ADC14IE1 : uint32_t {
    ADC14IE1_0 = 0x0,
    ADC14IE1_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE2 [2:2]
enum class ADC14_ADC14IER0_ADC14IE2 : uint32_t {
    ADC14IE2_0 = 0x0,
    ADC14IE2_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE3 [3:3]
enum class ADC14_ADC14IER0_ADC14IE3 : uint32_t {
    ADC14IE3_0 = 0x0,
    ADC14IE3_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE4 [4:4]
enum class ADC14_ADC14IER0_ADC14IE4 : uint32_t {
    ADC14IE4_0 = 0x0,
    ADC14IE4_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE5 [5:5]
enum class ADC14_ADC14IER0_ADC14IE5 : uint32_t {
    ADC14IE5_0 = 0x0,
    ADC14IE5_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE6 [6:6]
enum class ADC14_ADC14IER0_ADC14IE6 : uint32_t {
    ADC14IE6_0 = 0x0,
    ADC14IE6_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE7 [7:7]
enum class ADC14_ADC14IER0_ADC14IE7 : uint32_t {
    ADC14IE7_0 = 0x0,
    ADC14IE7_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE8 [8:8]
enum class ADC14_ADC14IER0_ADC14IE8 : uint32_t {
    ADC14IE8_0 = 0x0,
    ADC14IE8_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE9 [9:9]
enum class ADC14_ADC14IER0_ADC14IE9 : uint32_t {
    ADC14IE9_0 = 0x0,
    ADC14IE9_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE10 [10:10]
enum class ADC14_ADC14IER0_ADC14IE10 : uint32_t {
    ADC14IE10_0 = 0x0,
    ADC14IE10_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE11 [11:11]
enum class ADC14_ADC14IER0_ADC14IE11 : uint32_t {
    ADC14IE11_0 = 0x0,
    ADC14IE11_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE12 [12:12]
enum class ADC14_ADC14IER0_ADC14IE12 : uint32_t {
    ADC14IE12_0 = 0x0,
    ADC14IE12_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE13 [13:13]
enum class ADC14_ADC14IER0_ADC14IE13 : uint32_t {
    ADC14IE13_0 = 0x0,
    ADC14IE13_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE14 [14:14]
enum class ADC14_ADC14IER0_ADC14IE14 : uint32_t {
    ADC14IE14_0 = 0x0,
    ADC14IE14_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE15 [15:15]
enum class ADC14_ADC14IER0_ADC14IE15 : uint32_t {
    ADC14IE15_0 = 0x0,
    ADC14IE15_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE16 [16:16]
enum class ADC14_ADC14IER0_ADC14IE16 : uint32_t {
    ADC14IE16_0 = 0x0,
    ADC14IE16_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE17 [17:17]
enum class ADC14_ADC14IER0_ADC14IE17 : uint32_t {
    ADC14IE17_0 = 0x0,
    ADC14IE17_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE19 [19:19]
enum class ADC14_ADC14IER0_ADC14IE19 : uint32_t {
    ADC14IE19_0 = 0x0,
    ADC14IE19_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE18 [18:18]
enum class ADC14_ADC14IER0_ADC14IE18 : uint32_t {
    ADC14IE18_0 = 0x0,
    ADC14IE18_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE20 [20:20]
enum class ADC14_ADC14IER0_ADC14IE20 : uint32_t {
    ADC14IE20_0 = 0x0,
    ADC14IE20_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE21 [21:21]
enum class ADC14_ADC14IER0_ADC14IE21 : uint32_t {
    ADC14IE21_0 = 0x0,
    ADC14IE21_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE22 [22:22]
enum class ADC14_ADC14IER0_ADC14IE22 : uint32_t {
    ADC14IE22_0 = 0x0,
    ADC14IE22_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE23 [23:23]
enum class ADC14_ADC14IER0_ADC14IE23 : uint32_t {
    ADC14IE23_0 = 0x0,
    ADC14IE23_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE24 [24:24]
enum class ADC14_ADC14IER0_ADC14IE24 : uint32_t {
    ADC14IE24_0 = 0x0,
    ADC14IE24_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE25 [25:25]
enum class ADC14_ADC14IER0_ADC14IE25 : uint32_t {
    ADC14IE25_0 = 0x0,
    ADC14IE25_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE26 [26:26]
enum class ADC14_ADC14IER0_ADC14IE26 : uint32_t {
    ADC14IE26_0 = 0x0,
    ADC14IE26_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE27 [27:27]
enum class ADC14_ADC14IER0_ADC14IE27 : uint32_t {
    ADC14IE27_0 = 0x0,
    ADC14IE27_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE28 [28:28]
enum class ADC14_ADC14IER0_ADC14IE28 : uint32_t {
    ADC14IE28_0 = 0x0,
    ADC14IE28_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE29 [29:29]
enum class ADC14_ADC14IER0_ADC14IE29 : uint32_t {
    ADC14IE29_0 = 0x0,
    ADC14IE29_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE30 [30:30]
enum class ADC14_ADC14IER0_ADC14IE30 : uint32_t {
    ADC14IE30_0 = 0x0,
    ADC14IE30_1 = 0x1,
};

/// Interrupt enable
/// Register: ADC14IER0
/// Field: ADC14IE31 [31:31]
enum class ADC14_ADC14IER0_ADC14IE31 : uint32_t {
    ADC14IE31_0 = 0x0,
    ADC14IE31_1 = 0x1,
};

/// Interrupt enable for ADC14MEMx within comparator window
/// Register: ADC14IER1
/// Field: ADC14INIE [1:1]
enum class ADC14_ADC14IER1_ADC14INIE : uint32_t {
    ADC14INIE_0 = 0x0,
    ADC14INIE_1 = 0x1,
};

/// Interrupt enable for ADC14MEMx below comparator window
/// Register: ADC14IER1
/// Field: ADC14LOIE [2:2]
enum class ADC14_ADC14IER1_ADC14LOIE : uint32_t {
    ADC14LOIE_0 = 0x0,
    ADC14LOIE_1 = 0x1,
};

/// Interrupt enable for ADC14MEMx above comparator window
/// Register: ADC14IER1
/// Field: ADC14HIIE [3:3]
enum class ADC14_ADC14IER1_ADC14HIIE : uint32_t {
    ADC14HIIE_0 = 0x0,
    ADC14HIIE_1 = 0x1,
};

/// ADC14MEMx overflow-interrupt enable
/// Register: ADC14IER1
/// Field: ADC14OVIE [4:4]
enum class ADC14_ADC14IER1_ADC14OVIE : uint32_t {
    ADC14OVIE_0 = 0x0,
    ADC14OVIE_1 = 0x1,
};

/// ADC14 conversion-time-overflow interrupt enable
/// Register: ADC14IER1
/// Field: ADC14TOVIE [5:5]
enum class ADC14_ADC14IER1_ADC14TOVIE : uint32_t {
    ADC14TOVIE_0 = 0x0,
    ADC14TOVIE_1 = 0x1,
};

/// ADC14 local buffered reference ready interrupt enable
/// Register: ADC14IER1
/// Field: ADC14RDYIE [6:6]
enum class ADC14_ADC14IER1_ADC14RDYIE : uint32_t {
    ADC14RDYIE_0 = 0x0,
    ADC14RDYIE_1 = 0x1,
};

/// ADC14MEM0 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG0 [0:0]
enum class ADC14_ADC14IFGR0_ADC14IFG0 : uint32_t {
    ADC14IFG0_0 = 0x0,
    ADC14IFG0_1 = 0x1,
};

/// ADC14MEM1 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG1 [1:1]
enum class ADC14_ADC14IFGR0_ADC14IFG1 : uint32_t {
    ADC14IFG1_0 = 0x0,
    ADC14IFG1_1 = 0x1,
};

/// ADC14MEM2 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG2 [2:2]
enum class ADC14_ADC14IFGR0_ADC14IFG2 : uint32_t {
    ADC14IFG2_0 = 0x0,
    ADC14IFG2_1 = 0x1,
};

/// ADC14MEM3 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG3 [3:3]
enum class ADC14_ADC14IFGR0_ADC14IFG3 : uint32_t {
    ADC14IFG3_0 = 0x0,
    ADC14IFG3_1 = 0x1,
};

/// ADC14MEM4 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG4 [4:4]
enum class ADC14_ADC14IFGR0_ADC14IFG4 : uint32_t {
    ADC14IFG4_0 = 0x0,
    ADC14IFG4_1 = 0x1,
};

/// ADC14MEM5 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG5 [5:5]
enum class ADC14_ADC14IFGR0_ADC14IFG5 : uint32_t {
    ADC14IFG5_0 = 0x0,
    ADC14IFG5_1 = 0x1,
};

/// ADC14MEM6 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG6 [6:6]
enum class ADC14_ADC14IFGR0_ADC14IFG6 : uint32_t {
    ADC14IFG6_0 = 0x0,
    ADC14IFG6_1 = 0x1,
};

/// ADC14MEM7 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG7 [7:7]
enum class ADC14_ADC14IFGR0_ADC14IFG7 : uint32_t {
    ADC14IFG7_0 = 0x0,
    ADC14IFG7_1 = 0x1,
};

/// ADC14MEM8 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG8 [8:8]
enum class ADC14_ADC14IFGR0_ADC14IFG8 : uint32_t {
    ADC14IFG8_0 = 0x0,
    ADC14IFG8_1 = 0x1,
};

/// ADC14MEM9 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG9 [9:9]
enum class ADC14_ADC14IFGR0_ADC14IFG9 : uint32_t {
    ADC14IFG9_0 = 0x0,
    ADC14IFG9_1 = 0x1,
};

/// ADC14MEM10 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG10 [10:10]
enum class ADC14_ADC14IFGR0_ADC14IFG10 : uint32_t {
    ADC14IFG10_0 = 0x0,
    ADC14IFG10_1 = 0x1,
};

/// ADC14MEM11 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG11 [11:11]
enum class ADC14_ADC14IFGR0_ADC14IFG11 : uint32_t {
    ADC14IFG11_0 = 0x0,
    ADC14IFG11_1 = 0x1,
};

/// ADC14MEM12 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG12 [12:12]
enum class ADC14_ADC14IFGR0_ADC14IFG12 : uint32_t {
    ADC14IFG12_0 = 0x0,
    ADC14IFG12_1 = 0x1,
};

/// ADC14MEM13 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG13 [13:13]
enum class ADC14_ADC14IFGR0_ADC14IFG13 : uint32_t {
    ADC14IFG13_0 = 0x0,
    ADC14IFG13_1 = 0x1,
};

/// ADC14MEM14 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG14 [14:14]
enum class ADC14_ADC14IFGR0_ADC14IFG14 : uint32_t {
    ADC14IFG14_0 = 0x0,
    ADC14IFG14_1 = 0x1,
};

/// ADC14MEM15 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG15 [15:15]
enum class ADC14_ADC14IFGR0_ADC14IFG15 : uint32_t {
    ADC14IFG15_0 = 0x0,
    ADC14IFG15_1 = 0x1,
};

/// ADC14MEM16 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG16 [16:16]
enum class ADC14_ADC14IFGR0_ADC14IFG16 : uint32_t {
    ADC14IFG16_0 = 0x0,
    ADC14IFG16_1 = 0x1,
};

/// ADC14MEM17 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG17 [17:17]
enum class ADC14_ADC14IFGR0_ADC14IFG17 : uint32_t {
    ADC14IFG17_0 = 0x0,
    ADC14IFG17_1 = 0x1,
};

/// ADC14MEM18 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG18 [18:18]
enum class ADC14_ADC14IFGR0_ADC14IFG18 : uint32_t {
    ADC14IFG18_0 = 0x0,
    ADC14IFG18_1 = 0x1,
};

/// ADC14MEM19 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG19 [19:19]
enum class ADC14_ADC14IFGR0_ADC14IFG19 : uint32_t {
    ADC14IFG19_0 = 0x0,
    ADC14IFG19_1 = 0x1,
};

/// ADC14MEM20 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG20 [20:20]
enum class ADC14_ADC14IFGR0_ADC14IFG20 : uint32_t {
    ADC14IFG20_0 = 0x0,
    ADC14IFG20_1 = 0x1,
};

/// ADC14MEM21 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG21 [21:21]
enum class ADC14_ADC14IFGR0_ADC14IFG21 : uint32_t {
    ADC14IFG21_0 = 0x0,
    ADC14IFG21_1 = 0x1,
};

/// ADC14MEM22 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG22 [22:22]
enum class ADC14_ADC14IFGR0_ADC14IFG22 : uint32_t {
    ADC14IFG22_0 = 0x0,
    ADC14IFG22_1 = 0x1,
};

/// ADC14MEM23 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG23 [23:23]
enum class ADC14_ADC14IFGR0_ADC14IFG23 : uint32_t {
    ADC14IFG23_0 = 0x0,
    ADC14IFG23_1 = 0x1,
};

/// ADC14MEM24 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG24 [24:24]
enum class ADC14_ADC14IFGR0_ADC14IFG24 : uint32_t {
    ADC14IFG24_0 = 0x0,
    ADC14IFG24_1 = 0x1,
};

/// ADC14MEM25 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG25 [25:25]
enum class ADC14_ADC14IFGR0_ADC14IFG25 : uint32_t {
    ADC14IFG25_0 = 0x0,
    ADC14IFG25_1 = 0x1,
};

/// ADC14MEM26 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG26 [26:26]
enum class ADC14_ADC14IFGR0_ADC14IFG26 : uint32_t {
    ADC14IFG26_0 = 0x0,
    ADC14IFG26_1 = 0x1,
};

/// ADC14MEM27 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG27 [27:27]
enum class ADC14_ADC14IFGR0_ADC14IFG27 : uint32_t {
    ADC14IFG27_0 = 0x0,
    ADC14IFG27_1 = 0x1,
};

/// ADC14MEM28 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG28 [28:28]
enum class ADC14_ADC14IFGR0_ADC14IFG28 : uint32_t {
    ADC14IFG28_0 = 0x0,
    ADC14IFG28_1 = 0x1,
};

/// ADC14MEM29 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG29 [29:29]
enum class ADC14_ADC14IFGR0_ADC14IFG29 : uint32_t {
    ADC14IFG29_0 = 0x0,
    ADC14IFG29_1 = 0x1,
};

/// ADC14MEM30 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG30 [30:30]
enum class ADC14_ADC14IFGR0_ADC14IFG30 : uint32_t {
    ADC14IFG30_0 = 0x0,
    ADC14IFG30_1 = 0x1,
};

/// ADC14MEM31 interrupt flag
/// Register: ADC14IFGR0
/// Field: ADC14IFG31 [31:31]
enum class ADC14_ADC14IFGR0_ADC14IFG31 : uint32_t {
    ADC14IFG31_0 = 0x0,
    ADC14IFG31_1 = 0x1,
};

/// Interrupt flag for ADC14MEMx within comparator window
/// Register: ADC14IFGR1
/// Field: ADC14INIFG [1:1]
enum class ADC14_ADC14IFGR1_ADC14INIFG : uint32_t {
    ADC14INIFG_0 = 0x0,
    ADC14INIFG_1 = 0x1,
};

/// Interrupt flag for ADC14MEMx below comparator window
/// Register: ADC14IFGR1
/// Field: ADC14LOIFG [2:2]
enum class ADC14_ADC14IFGR1_ADC14LOIFG : uint32_t {
    ADC14LOIFG_0 = 0x0,
    ADC14LOIFG_1 = 0x1,
};

/// Interrupt flag for ADC14MEMx above comparator window
/// Register: ADC14IFGR1
/// Field: ADC14HIIFG [3:3]
enum class ADC14_ADC14IFGR1_ADC14HIIFG : uint32_t {
    ADC14HIIFG_0 = 0x0,
    ADC14HIIFG_1 = 0x1,
};

/// ADC14MEMx overflow interrupt flag
/// Register: ADC14IFGR1
/// Field: ADC14OVIFG [4:4]
enum class ADC14_ADC14IFGR1_ADC14OVIFG : uint32_t {
    ADC14OVIFG_0 = 0x0,
    ADC14OVIFG_1 = 0x1,
};

/// ADC14 conversion time overflow interrupt flag
/// Register: ADC14IFGR1
/// Field: ADC14TOVIFG [5:5]
enum class ADC14_ADC14IFGR1_ADC14TOVIFG : uint32_t {
    ADC14TOVIFG_0 = 0x0,
    ADC14TOVIFG_1 = 0x1,
};

/// ADC14 local buffered reference ready interrupt flag
/// Register: ADC14IFGR1
/// Field: ADC14RDYIFG [6:6]
enum class ADC14_ADC14IFGR1_ADC14RDYIFG : uint32_t {
    ADC14RDYIFG_0 = 0x0,
    ADC14RDYIFG_1 = 0x1,
};

/// clear ADC14IFG0
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG0 [0:0]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG0 : uint32_t {
    CLRADC14IFG0_0 = 0x0,
    CLRADC14IFG0_1 = 0x1,
};

/// clear ADC14IFG1
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG1 [1:1]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG1 : uint32_t {
    CLRADC14IFG1_0 = 0x0,
    CLRADC14IFG1_1 = 0x1,
};

/// clear ADC14IFG2
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG2 [2:2]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG2 : uint32_t {
    CLRADC14IFG2_0 = 0x0,
    CLRADC14IFG2_1 = 0x1,
};

/// clear ADC14IFG3
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG3 [3:3]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG3 : uint32_t {
    CLRADC14IFG3_0 = 0x0,
    CLRADC14IFG3_1 = 0x1,
};

/// clear ADC14IFG4
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG4 [4:4]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG4 : uint32_t {
    CLRADC14IFG4_0 = 0x0,
    CLRADC14IFG4_1 = 0x1,
};

/// clear ADC14IFG5
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG5 [5:5]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG5 : uint32_t {
    CLRADC14IFG5_0 = 0x0,
    CLRADC14IFG5_1 = 0x1,
};

/// clear ADC14IFG6
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG6 [6:6]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG6 : uint32_t {
    CLRADC14IFG6_0 = 0x0,
    CLRADC14IFG6_1 = 0x1,
};

/// clear ADC14IFG7
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG7 [7:7]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG7 : uint32_t {
    CLRADC14IFG7_0 = 0x0,
    CLRADC14IFG7_1 = 0x1,
};

/// clear ADC14IFG8
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG8 [8:8]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG8 : uint32_t {
    CLRADC14IFG8_0 = 0x0,
    CLRADC14IFG8_1 = 0x1,
};

/// clear ADC14IFG9
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG9 [9:9]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG9 : uint32_t {
    CLRADC14IFG9_0 = 0x0,
    CLRADC14IFG9_1 = 0x1,
};

/// clear ADC14IFG10
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG10 [10:10]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG10 : uint32_t {
    CLRADC14IFG10_0 = 0x0,
    CLRADC14IFG10_1 = 0x1,
};

/// clear ADC14IFG11
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG11 [11:11]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG11 : uint32_t {
    CLRADC14IFG11_0 = 0x0,
    CLRADC14IFG11_1 = 0x1,
};

/// clear ADC14IFG12
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG12 [12:12]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG12 : uint32_t {
    CLRADC14IFG12_0 = 0x0,
    CLRADC14IFG12_1 = 0x1,
};

/// clear ADC14IFG13
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG13 [13:13]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG13 : uint32_t {
    CLRADC14IFG13_0 = 0x0,
    CLRADC14IFG13_1 = 0x1,
};

/// clear ADC14IFG14
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG14 [14:14]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG14 : uint32_t {
    CLRADC14IFG14_0 = 0x0,
    CLRADC14IFG14_1 = 0x1,
};

/// clear ADC14IFG15
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG15 [15:15]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG15 : uint32_t {
    CLRADC14IFG15_0 = 0x0,
    CLRADC14IFG15_1 = 0x1,
};

/// clear ADC14IFG16
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG16 [16:16]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG16 : uint32_t {
    CLRADC14IFG16_0 = 0x0,
    CLRADC14IFG16_1 = 0x1,
};

/// clear ADC14IFG17
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG17 [17:17]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG17 : uint32_t {
    CLRADC14IFG17_0 = 0x0,
    CLRADC14IFG17_1 = 0x1,
};

/// clear ADC14IFG18
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG18 [18:18]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG18 : uint32_t {
    CLRADC14IFG18_0 = 0x0,
    CLRADC14IFG18_1 = 0x1,
};

/// clear ADC14IFG19
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG19 [19:19]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG19 : uint32_t {
    CLRADC14IFG19_0 = 0x0,
    CLRADC14IFG19_1 = 0x1,
};

/// clear ADC14IFG20
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG20 [20:20]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG20 : uint32_t {
    CLRADC14IFG20_0 = 0x0,
    CLRADC14IFG20_1 = 0x1,
};

/// clear ADC14IFG21
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG21 [21:21]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG21 : uint32_t {
    CLRADC14IFG21_0 = 0x0,
    CLRADC14IFG21_1 = 0x1,
};

/// clear ADC14IFG22
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG22 [22:22]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG22 : uint32_t {
    CLRADC14IFG22_0 = 0x0,
    CLRADC14IFG22_1 = 0x1,
};

/// clear ADC14IFG23
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG23 [23:23]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG23 : uint32_t {
    CLRADC14IFG23_0 = 0x0,
    CLRADC14IFG23_1 = 0x1,
};

/// clear ADC14IFG24
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG24 [24:24]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG24 : uint32_t {
    CLRADC14IFG24_0 = 0x0,
    CLRADC14IFG24_1 = 0x1,
};

/// clear ADC14IFG25
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG25 [25:25]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG25 : uint32_t {
    CLRADC14IFG25_0 = 0x0,
    CLRADC14IFG25_1 = 0x1,
};

/// clear ADC14IFG26
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG26 [26:26]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG26 : uint32_t {
    CLRADC14IFG26_0 = 0x0,
    CLRADC14IFG26_1 = 0x1,
};

/// clear ADC14IFG27
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG27 [27:27]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG27 : uint32_t {
    CLRADC14IFG27_0 = 0x0,
    CLRADC14IFG27_1 = 0x1,
};

/// clear ADC14IFG28
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG28 [28:28]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG28 : uint32_t {
    CLRADC14IFG28_0 = 0x0,
    CLRADC14IFG28_1 = 0x1,
};

/// clear ADC14IFG29
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG29 [29:29]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG29 : uint32_t {
    CLRADC14IFG29_0 = 0x0,
    CLRADC14IFG29_1 = 0x1,
};

/// clear ADC14IFG30
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG30 [30:30]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG30 : uint32_t {
    CLRADC14IFG30_0 = 0x0,
    CLRADC14IFG30_1 = 0x1,
};

/// clear ADC14IFG31
/// Register: ADC14CLRIFGR0
/// Field: CLRADC14IFG31 [31:31]
enum class ADC14_ADC14CLRIFGR0_CLRADC14IFG31 : uint32_t {
    CLRADC14IFG31_0 = 0x0,
    CLRADC14IFG31_1 = 0x1,
};

/// clear ADC14INIFG
/// Register: ADC14CLRIFGR1
/// Field: CLRADC14INIFG [1:1]
enum class ADC14_ADC14CLRIFGR1_CLRADC14INIFG : uint32_t {
    CLRADC14INIFG_0 = 0x0,
    CLRADC14INIFG_1 = 0x1,
};

/// clear ADC14LOIFG
/// Register: ADC14CLRIFGR1
/// Field: CLRADC14LOIFG [2:2]
enum class ADC14_ADC14CLRIFGR1_CLRADC14LOIFG : uint32_t {
    CLRADC14LOIFG_0 = 0x0,
    CLRADC14LOIFG_1 = 0x1,
};

/// clear ADC14HIIFG
/// Register: ADC14CLRIFGR1
/// Field: CLRADC14HIIFG [3:3]
enum class ADC14_ADC14CLRIFGR1_CLRADC14HIIFG : uint32_t {
    CLRADC14HIIFG_0 = 0x0,
    CLRADC14HIIFG_1 = 0x1,
};

/// clear ADC14OVIFG
/// Register: ADC14CLRIFGR1
/// Field: CLRADC14OVIFG [4:4]
enum class ADC14_ADC14CLRIFGR1_CLRADC14OVIFG : uint32_t {
    CLRADC14OVIFG_0 = 0x0,
    CLRADC14OVIFG_1 = 0x1,
};

/// clear ADC14TOVIFG
/// Register: ADC14CLRIFGR1
/// Field: CLRADC14TOVIFG [5:5]
enum class ADC14_ADC14CLRIFGR1_CLRADC14TOVIFG : uint32_t {
    CLRADC14TOVIFG_0 = 0x0,
    CLRADC14TOVIFG_1 = 0x1,
};

/// clear ADC14RDYIFG
/// Register: ADC14CLRIFGR1
/// Field: CLRADC14RDYIFG [6:6]
enum class ADC14_ADC14CLRIFGR1_CLRADC14RDYIFG : uint32_t {
    CLRADC14RDYIFG_0 = 0x0,
    CLRADC14RDYIFG_1 = 0x1,
};

/// ADC14 interrupt vector value
/// Register: ADC14IV
/// Field: ADC14IV [0:31]
enum class ADC14_ADC14IV_ADC14IV : uint32_t {
    ADC14IV_0 = 0x0,
    ADC14IV_2 = 0x2,
    ADC14IV_4 = 0x4,
    ADC14IV_6 = 0x6,
    ADC14IV_8 = 0x8,
    ADC14IV_10 = 0xA,
    ADC14IV_12 = 0xC,
    ADC14IV_14 = 0xE,
    ADC14IV_16 = 0x10,
    ADC14IV_18 = 0x12,
    ADC14IV_20 = 0x14,
    ADC14IV_22 = 0x16,
    ADC14IV_24 = 0x18,
    ADC14IV_26 = 0x1A,
    ADC14IV_28 = 0x1C,
    ADC14IV_30 = 0x1E,
    ADC14IV_32 = 0x20,
    ADC14IV_34 = 0x22,
    ADC14IV_36 = 0x24,
    ADC14IV_38 = 0x26,
    ADC14IV_40 = 0x28,
    ADC14IV_42 = 0x2A,
    ADC14IV_44 = 0x2C,
    ADC14IV_46 = 0x2E,
    ADC14IV_48 = 0x30,
    ADC14IV_50 = 0x32,
    ADC14IV_52 = 0x34,
    ADC14IV_54 = 0x36,
    ADC14IV_56 = 0x38,
    ADC14IV_58 = 0x3A,
    ADC14IV_60 = 0x3C,
    ADC14IV_62 = 0x3E,
    ADC14IV_64 = 0x40,
    ADC14IV_66 = 0x42,
    ADC14IV_68 = 0x44,
    ADC14IV_70 = 0x46,
    ADC14IV_72 = 0x48,
    ADC14IV_74 = 0x4A,
    ADC14IV_76 = 0x4C,
};

// ----------------------------------------------------------------------------
// AES256 - AES256
// ----------------------------------------------------------------------------

/// AES operation
/// Register: AESACTL0
/// Field: AESOPx [0:1]
enum class AES256_AESACTL0_AESOPX : uint16_t {
    AESOPx_0 = 0x0,
    AESOPx_1 = 0x1,
    AESOPx_2 = 0x2,
    AESOPx_3 = 0x3,
};

/// AES key length
/// Register: AESACTL0
/// Field: AESKLx [2:3]
enum class AES256_AESACTL0_AESKLX : uint16_t {
    AESKLx_0 = 0x0,
    AESKLx_1 = 0x1,
    AESKLx_2 = 0x2,
};

/// AES cipher mode select
/// Register: AESACTL0
/// Field: AESCMx [5:6]
enum class AES256_AESACTL0_AESCMX : uint16_t {
    AESCMx_0 = 0x0,
    AESCMx_1 = 0x1,
    AESCMx_2 = 0x2,
    AESCMx_3 = 0x3,
};

/// AES software reset
/// Register: AESACTL0
/// Field: AESSWRST [7:7]
enum class AES256_AESACTL0_AESSWRST : uint16_t {
    AESSWRST_0 = 0x0,
    AESSWRST_1 = 0x1,
};

/// AES ready interrupt flag
/// Register: AESACTL0
/// Field: AESRDYIFG [8:8]
enum class AES256_AESACTL0_AESRDYIFG : uint16_t {
    AESRDYIFG_0 = 0x0,
    AESRDYIFG_1 = 0x1,
};

/// AES error flag
/// Register: AESACTL0
/// Field: AESERRFG [11:11]
enum class AES256_AESACTL0_AESERRFG : uint16_t {
    AESERRFG_0 = 0x0,
    AESERRFG_1 = 0x1,
};

/// AES ready interrupt enable
/// Register: AESACTL0
/// Field: AESRDYIE [12:12]
enum class AES256_AESACTL0_AESRDYIE : uint16_t {
    AESRDYIE_0 = 0x0,
    AESRDYIE_1 = 0x1,
};

/// AES cipher mode enable
/// Register: AESACTL0
/// Field: AESCMEN [15:15]
enum class AES256_AESACTL0_AESCMEN : uint16_t {
    AESCMEN_0 = 0x0,
    AESCMEN_1 = 0x1,
};

/// AES accelerator module busy
/// Register: AESASTAT
/// Field: AESBUSY [0:0]
enum class AES256_AESASTAT_AESBUSY : uint16_t {
    AESBUSY_0 = 0x0,
    AESBUSY_1 = 0x1,
};

/// All 16 bytes written to AESAKEY
/// Register: AESASTAT
/// Field: AESKEYWR [1:1]
enum class AES256_AESASTAT_AESKEYWR : uint16_t {
    AESKEYWR_0 = 0x0,
    AESKEYWR_1 = 0x1,
};

/// All 16 bytes written to AESADIN, AESAXDIN or AESAXIN
/// Register: AESASTAT
/// Field: AESDINWR [2:2]
enum class AES256_AESASTAT_AESDINWR : uint16_t {
    AESDINWR_0 = 0x0,
    AESDINWR_1 = 0x1,
};

/// All 16 bytes read from AESADOUT
/// Register: AESASTAT
/// Field: AESDOUTRD [3:3]
enum class AES256_AESASTAT_AESDOUTRD : uint16_t {
    AESDOUTRD_0 = 0x0,
    AESDOUTRD_1 = 0x1,
};

// ----------------------------------------------------------------------------
// CAPTIO0 - CAPTIO0
// ----------------------------------------------------------------------------

/// Capacitive Touch IO pin select
/// Register: CAPTIOxCTL
/// Field: CAPTIOPISELx [1:3]
enum class CAPTIO0_CAPTIOXCTL_CAPTIOPISELX : uint16_t {
    CAPTIOPISELx_0 = 0x0,
    CAPTIOPISELx_1 = 0x1,
    CAPTIOPISELx_2 = 0x2,
    CAPTIOPISELx_3 = 0x3,
    CAPTIOPISELx_4 = 0x4,
    CAPTIOPISELx_5 = 0x5,
    CAPTIOPISELx_6 = 0x6,
    CAPTIOPISELx_7 = 0x7,
};

/// Capacitive Touch IO port select
/// Register: CAPTIOxCTL
/// Field: CAPTIOPOSELx [4:7]
enum class CAPTIO0_CAPTIOXCTL_CAPTIOPOSELX : uint16_t {
    CAPTIOPOSELx_0 = 0x0,
    CAPTIOPOSELx_1 = 0x1,
    CAPTIOPOSELx_2 = 0x2,
    CAPTIOPOSELx_3 = 0x3,
    CAPTIOPOSELx_4 = 0x4,
    CAPTIOPOSELx_5 = 0x5,
    CAPTIOPOSELx_6 = 0x6,
    CAPTIOPOSELx_7 = 0x7,
    CAPTIOPOSELx_8 = 0x8,
    CAPTIOPOSELx_9 = 0x9,
    CAPTIOPOSELx_10 = 0xA,
    CAPTIOPOSELx_11 = 0xB,
    CAPTIOPOSELx_12 = 0xC,
    CAPTIOPOSELx_13 = 0xD,
    CAPTIOPOSELx_14 = 0xE,
    CAPTIOPOSELx_15 = 0xF,
};

/// Capacitive Touch IO enable
/// Register: CAPTIOxCTL
/// Field: CAPTIOEN [8:8]
enum class CAPTIO0_CAPTIOXCTL_CAPTIOEN : uint16_t {
    CAPTIOEN_0 = 0x0,
    CAPTIOEN_1 = 0x1,
};

/// Capacitive Touch IO state
/// Register: CAPTIOxCTL
/// Field: CAPTIOSTATE [9:9]
enum class CAPTIO0_CAPTIOXCTL_CAPTIOSTATE : uint16_t {
    CAPTIOSTATE_0 = 0x0,
    CAPTIOSTATE_1 = 0x1,
};

// ----------------------------------------------------------------------------
// CAPTIO1 - CAPTIO1
// ----------------------------------------------------------------------------

/// Capacitive Touch IO pin select
/// Register: CAPTIOxCTL
/// Field: CAPTIOPISELx [1:3]
enum class CAPTIO1_CAPTIOXCTL_CAPTIOPISELX : uint16_t {
    CAPTIOPISELx_0 = 0x0,
    CAPTIOPISELx_1 = 0x1,
    CAPTIOPISELx_2 = 0x2,
    CAPTIOPISELx_3 = 0x3,
    CAPTIOPISELx_4 = 0x4,
    CAPTIOPISELx_5 = 0x5,
    CAPTIOPISELx_6 = 0x6,
    CAPTIOPISELx_7 = 0x7,
};

/// Capacitive Touch IO port select
/// Register: CAPTIOxCTL
/// Field: CAPTIOPOSELx [4:7]
enum class CAPTIO1_CAPTIOXCTL_CAPTIOPOSELX : uint16_t {
    CAPTIOPOSELx_0 = 0x0,
    CAPTIOPOSELx_1 = 0x1,
    CAPTIOPOSELx_2 = 0x2,
    CAPTIOPOSELx_3 = 0x3,
    CAPTIOPOSELx_4 = 0x4,
    CAPTIOPOSELx_5 = 0x5,
    CAPTIOPOSELx_6 = 0x6,
    CAPTIOPOSELx_7 = 0x7,
    CAPTIOPOSELx_8 = 0x8,
    CAPTIOPOSELx_9 = 0x9,
    CAPTIOPOSELx_10 = 0xA,
    CAPTIOPOSELx_11 = 0xB,
    CAPTIOPOSELx_12 = 0xC,
    CAPTIOPOSELx_13 = 0xD,
    CAPTIOPOSELx_14 = 0xE,
    CAPTIOPOSELx_15 = 0xF,
};

/// Capacitive Touch IO enable
/// Register: CAPTIOxCTL
/// Field: CAPTIOEN [8:8]
enum class CAPTIO1_CAPTIOXCTL_CAPTIOEN : uint16_t {
    CAPTIOEN_0 = 0x0,
    CAPTIOEN_1 = 0x1,
};

/// Capacitive Touch IO state
/// Register: CAPTIOxCTL
/// Field: CAPTIOSTATE [9:9]
enum class CAPTIO1_CAPTIOXCTL_CAPTIOSTATE : uint16_t {
    CAPTIOSTATE_0 = 0x0,
    CAPTIOSTATE_1 = 0x1,
};

// ----------------------------------------------------------------------------
// COMP_E0 - COMP_E0
// ----------------------------------------------------------------------------

/// Channel input selected for the V+ terminal
/// Register: CExCTL0
/// Field: CEIPSEL [0:3]
enum class COMP_E0_CEXCTL0_CEIPSEL : uint16_t {
    CEIPSEL_0 = 0x0,
    CEIPSEL_1 = 0x1,
    CEIPSEL_2 = 0x2,
    CEIPSEL_3 = 0x3,
    CEIPSEL_4 = 0x4,
    CEIPSEL_5 = 0x5,
    CEIPSEL_6 = 0x6,
    CEIPSEL_7 = 0x7,
    CEIPSEL_8 = 0x8,
    CEIPSEL_9 = 0x9,
    CEIPSEL_10 = 0xA,
    CEIPSEL_11 = 0xB,
    CEIPSEL_12 = 0xC,
    CEIPSEL_13 = 0xD,
    CEIPSEL_14 = 0xE,
    CEIPSEL_15 = 0xF,
};

/// Channel input enable for the V+ terminal
/// Register: CExCTL0
/// Field: CEIPEN [7:7]
enum class COMP_E0_CEXCTL0_CEIPEN : uint16_t {
    CEIPEN_0 = 0x0,
    CEIPEN_1 = 0x1,
};

/// Channel input selected for the - terminal
/// Register: CExCTL0
/// Field: CEIMSEL [8:11]
enum class COMP_E0_CEXCTL0_CEIMSEL : uint16_t {
    CEIMSEL_0 = 0x0,
    CEIMSEL_1 = 0x1,
    CEIMSEL_2 = 0x2,
    CEIMSEL_3 = 0x3,
    CEIMSEL_4 = 0x4,
    CEIMSEL_5 = 0x5,
    CEIMSEL_6 = 0x6,
    CEIMSEL_7 = 0x7,
    CEIMSEL_8 = 0x8,
    CEIMSEL_9 = 0x9,
    CEIMSEL_10 = 0xA,
    CEIMSEL_11 = 0xB,
    CEIMSEL_12 = 0xC,
    CEIMSEL_13 = 0xD,
    CEIMSEL_14 = 0xE,
    CEIMSEL_15 = 0xF,
};

/// Channel input enable for the - terminal
/// Register: CExCTL0
/// Field: CEIMEN [15:15]
enum class COMP_E0_CEXCTL0_CEIMEN : uint16_t {
    CEIMEN_0 = 0x0,
    CEIMEN_1 = 0x1,
};

/// Comparator output polarity
/// Register: CExCTL1
/// Field: CEOUTPOL [1:1]
enum class COMP_E0_CEXCTL1_CEOUTPOL : uint16_t {
    CEOUTPOL_0 = 0x0,
    CEOUTPOL_1 = 0x1,
};

/// Comparator output filter
/// Register: CExCTL1
/// Field: CEF [2:2]
enum class COMP_E0_CEXCTL1_CEF : uint16_t {
    CEF_0 = 0x0,
    CEF_1 = 0x1,
};

/// Interrupt edge select for CEIIFG and CEIFG
/// Register: CExCTL1
/// Field: CEIES [3:3]
enum class COMP_E0_CEXCTL1_CEIES : uint16_t {
    CEIES_0 = 0x0,
    CEIES_1 = 0x1,
};

/// Input short
/// Register: CExCTL1
/// Field: CESHORT [4:4]
enum class COMP_E0_CEXCTL1_CESHORT : uint16_t {
    CESHORT_0 = 0x0,
    CESHORT_1 = 0x1,
};

/// Filter delay
/// Register: CExCTL1
/// Field: CEFDLY [6:7]
enum class COMP_E0_CEXCTL1_CEFDLY : uint16_t {
    CEFDLY_0 = 0x0,
    CEFDLY_1 = 0x1,
    CEFDLY_2 = 0x2,
    CEFDLY_3 = 0x3,
};

/// Power Mode
/// Register: CExCTL1
/// Field: CEPWRMD [8:9]
enum class COMP_E0_CEXCTL1_CEPWRMD : uint16_t {
    CEPWRMD_0 = 0x0,
    CEPWRMD_1 = 0x1,
    CEPWRMD_2 = 0x2,
};

/// Comparator On
/// Register: CExCTL1
/// Field: CEON [10:10]
enum class COMP_E0_CEXCTL1_CEON : uint16_t {
    CEON_0 = 0x0,
    CEON_1 = 0x1,
};

/// This bit is valid of CEMRVS is set to 1
/// Register: CExCTL1
/// Field: CEMRVL [11:11]
enum class COMP_E0_CEXCTL1_CEMRVL : uint16_t {
    CEMRVL_0 = 0x0,
    CEMRVL_1 = 0x1,
};

/// This bit defines if the comparator output selects between VREF0 or VREF1 if CERS = 00, 01, or 10.
/// Register: CExCTL1
/// Field: CEMRVS [12:12]
enum class COMP_E0_CEXCTL1_CEMRVS : uint16_t {
    CEMRVS_0 = 0x0,
    CEMRVS_1 = 0x1,
};

/// Reference select
/// Register: CExCTL2
/// Field: CERSEL [5:5]
enum class COMP_E0_CEXCTL2_CERSEL : uint16_t {
    CERSEL_0 = 0x0,
    CERSEL_1 = 0x1,
};

/// Reference source
/// Register: CExCTL2
/// Field: CERS [6:7]
enum class COMP_E0_CEXCTL2_CERS : uint16_t {
    CERS_0 = 0x0,
    CERS_1 = 0x1,
    CERS_2 = 0x2,
    CERS_3 = 0x3,
};

/// Reference voltage level
/// Register: CExCTL2
/// Field: CEREFL [13:14]
enum class COMP_E0_CEXCTL2_CEREFL : uint16_t {
    CEREFL_0 = 0x0,
    CEREFL_1 = 0x1,
    CEREFL_2 = 0x2,
    CEREFL_3 = 0x3,
};

/// Reference accuracy
/// Register: CExCTL2
/// Field: CEREFACC [15:15]
enum class COMP_E0_CEXCTL2_CEREFACC : uint16_t {
    CEREFACC_0 = 0x0,
    CEREFACC_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD0 [0:0]
enum class COMP_E0_CEXCTL3_CEPD0 : uint16_t {
    CEPD0_0 = 0x0,
    CEPD0_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD1 [1:1]
enum class COMP_E0_CEXCTL3_CEPD1 : uint16_t {
    CEPD1_0 = 0x0,
    CEPD1_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD2 [2:2]
enum class COMP_E0_CEXCTL3_CEPD2 : uint16_t {
    CEPD2_0 = 0x0,
    CEPD2_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD3 [3:3]
enum class COMP_E0_CEXCTL3_CEPD3 : uint16_t {
    CEPD3_0 = 0x0,
    CEPD3_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD4 [4:4]
enum class COMP_E0_CEXCTL3_CEPD4 : uint16_t {
    CEPD4_0 = 0x0,
    CEPD4_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD5 [5:5]
enum class COMP_E0_CEXCTL3_CEPD5 : uint16_t {
    CEPD5_0 = 0x0,
    CEPD5_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD6 [6:6]
enum class COMP_E0_CEXCTL3_CEPD6 : uint16_t {
    CEPD6_0 = 0x0,
    CEPD6_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD7 [7:7]
enum class COMP_E0_CEXCTL3_CEPD7 : uint16_t {
    CEPD7_0 = 0x0,
    CEPD7_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD8 [8:8]
enum class COMP_E0_CEXCTL3_CEPD8 : uint16_t {
    CEPD8_0 = 0x0,
    CEPD8_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD9 [9:9]
enum class COMP_E0_CEXCTL3_CEPD9 : uint16_t {
    CEPD9_0 = 0x0,
    CEPD9_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD10 [10:10]
enum class COMP_E0_CEXCTL3_CEPD10 : uint16_t {
    CEPD10_0 = 0x0,
    CEPD10_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD11 [11:11]
enum class COMP_E0_CEXCTL3_CEPD11 : uint16_t {
    CEPD11_0 = 0x0,
    CEPD11_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD12 [12:12]
enum class COMP_E0_CEXCTL3_CEPD12 : uint16_t {
    CEPD12_0 = 0x0,
    CEPD12_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD13 [13:13]
enum class COMP_E0_CEXCTL3_CEPD13 : uint16_t {
    CEPD13_0 = 0x0,
    CEPD13_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD14 [14:14]
enum class COMP_E0_CEXCTL3_CEPD14 : uint16_t {
    CEPD14_0 = 0x0,
    CEPD14_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD15 [15:15]
enum class COMP_E0_CEXCTL3_CEPD15 : uint16_t {
    CEPD15_0 = 0x0,
    CEPD15_1 = 0x1,
};

/// Comparator output interrupt flag
/// Register: CExINT
/// Field: CEIFG [0:0]
enum class COMP_E0_CEXINT_CEIFG : uint16_t {
    CEIFG_0 = 0x0,
    CEIFG_1 = 0x1,
};

/// Comparator output inverted interrupt flag
/// Register: CExINT
/// Field: CEIIFG [1:1]
enum class COMP_E0_CEXINT_CEIIFG : uint16_t {
    CEIIFG_0 = 0x0,
    CEIIFG_1 = 0x1,
};

/// Comparator ready interrupt flag
/// Register: CExINT
/// Field: CERDYIFG [4:4]
enum class COMP_E0_CEXINT_CERDYIFG : uint16_t {
    CERDYIFG_0 = 0x0,
    CERDYIFG_1 = 0x1,
};

/// Comparator output interrupt enable
/// Register: CExINT
/// Field: CEIE [8:8]
enum class COMP_E0_CEXINT_CEIE : uint16_t {
    CEIE_0 = 0x0,
    CEIE_1 = 0x1,
};

/// Comparator output interrupt enable inverted polarity
/// Register: CExINT
/// Field: CEIIE [9:9]
enum class COMP_E0_CEXINT_CEIIE : uint16_t {
    CEIIE_0 = 0x0,
    CEIIE_1 = 0x1,
};

/// Comparator ready interrupt enable
/// Register: CExINT
/// Field: CERDYIE [12:12]
enum class COMP_E0_CEXINT_CERDYIE : uint16_t {
    CERDYIE_0 = 0x0,
    CERDYIE_1 = 0x1,
};

/// Comparator interrupt vector word register
/// Register: CExIV
/// Field: CEIV [0:15]
enum class COMP_E0_CEXIV_CEIV : uint16_t {
    CEIV_0 = 0x0,
    CEIV_2 = 0x2,
    CEIV_4 = 0x4,
    CEIV_10 = 0xA,
};

// ----------------------------------------------------------------------------
// COMP_E1 - COMP_E1
// ----------------------------------------------------------------------------

/// Channel input selected for the V+ terminal
/// Register: CExCTL0
/// Field: CEIPSEL [0:3]
enum class COMP_E1_CEXCTL0_CEIPSEL : uint16_t {
    CEIPSEL_0 = 0x0,
    CEIPSEL_1 = 0x1,
    CEIPSEL_2 = 0x2,
    CEIPSEL_3 = 0x3,
    CEIPSEL_4 = 0x4,
    CEIPSEL_5 = 0x5,
    CEIPSEL_6 = 0x6,
    CEIPSEL_7 = 0x7,
    CEIPSEL_8 = 0x8,
    CEIPSEL_9 = 0x9,
    CEIPSEL_10 = 0xA,
    CEIPSEL_11 = 0xB,
    CEIPSEL_12 = 0xC,
    CEIPSEL_13 = 0xD,
    CEIPSEL_14 = 0xE,
    CEIPSEL_15 = 0xF,
};

/// Channel input enable for the V+ terminal
/// Register: CExCTL0
/// Field: CEIPEN [7:7]
enum class COMP_E1_CEXCTL0_CEIPEN : uint16_t {
    CEIPEN_0 = 0x0,
    CEIPEN_1 = 0x1,
};

/// Channel input selected for the - terminal
/// Register: CExCTL0
/// Field: CEIMSEL [8:11]
enum class COMP_E1_CEXCTL0_CEIMSEL : uint16_t {
    CEIMSEL_0 = 0x0,
    CEIMSEL_1 = 0x1,
    CEIMSEL_2 = 0x2,
    CEIMSEL_3 = 0x3,
    CEIMSEL_4 = 0x4,
    CEIMSEL_5 = 0x5,
    CEIMSEL_6 = 0x6,
    CEIMSEL_7 = 0x7,
    CEIMSEL_8 = 0x8,
    CEIMSEL_9 = 0x9,
    CEIMSEL_10 = 0xA,
    CEIMSEL_11 = 0xB,
    CEIMSEL_12 = 0xC,
    CEIMSEL_13 = 0xD,
    CEIMSEL_14 = 0xE,
    CEIMSEL_15 = 0xF,
};

/// Channel input enable for the - terminal
/// Register: CExCTL0
/// Field: CEIMEN [15:15]
enum class COMP_E1_CEXCTL0_CEIMEN : uint16_t {
    CEIMEN_0 = 0x0,
    CEIMEN_1 = 0x1,
};

/// Comparator output polarity
/// Register: CExCTL1
/// Field: CEOUTPOL [1:1]
enum class COMP_E1_CEXCTL1_CEOUTPOL : uint16_t {
    CEOUTPOL_0 = 0x0,
    CEOUTPOL_1 = 0x1,
};

/// Comparator output filter
/// Register: CExCTL1
/// Field: CEF [2:2]
enum class COMP_E1_CEXCTL1_CEF : uint16_t {
    CEF_0 = 0x0,
    CEF_1 = 0x1,
};

/// Interrupt edge select for CEIIFG and CEIFG
/// Register: CExCTL1
/// Field: CEIES [3:3]
enum class COMP_E1_CEXCTL1_CEIES : uint16_t {
    CEIES_0 = 0x0,
    CEIES_1 = 0x1,
};

/// Input short
/// Register: CExCTL1
/// Field: CESHORT [4:4]
enum class COMP_E1_CEXCTL1_CESHORT : uint16_t {
    CESHORT_0 = 0x0,
    CESHORT_1 = 0x1,
};

/// Filter delay
/// Register: CExCTL1
/// Field: CEFDLY [6:7]
enum class COMP_E1_CEXCTL1_CEFDLY : uint16_t {
    CEFDLY_0 = 0x0,
    CEFDLY_1 = 0x1,
    CEFDLY_2 = 0x2,
    CEFDLY_3 = 0x3,
};

/// Power Mode
/// Register: CExCTL1
/// Field: CEPWRMD [8:9]
enum class COMP_E1_CEXCTL1_CEPWRMD : uint16_t {
    CEPWRMD_0 = 0x0,
    CEPWRMD_1 = 0x1,
    CEPWRMD_2 = 0x2,
};

/// Comparator On
/// Register: CExCTL1
/// Field: CEON [10:10]
enum class COMP_E1_CEXCTL1_CEON : uint16_t {
    CEON_0 = 0x0,
    CEON_1 = 0x1,
};

/// This bit is valid of CEMRVS is set to 1
/// Register: CExCTL1
/// Field: CEMRVL [11:11]
enum class COMP_E1_CEXCTL1_CEMRVL : uint16_t {
    CEMRVL_0 = 0x0,
    CEMRVL_1 = 0x1,
};

/// This bit defines if the comparator output selects between VREF0 or VREF1 if CERS = 00, 01, or 10.
/// Register: CExCTL1
/// Field: CEMRVS [12:12]
enum class COMP_E1_CEXCTL1_CEMRVS : uint16_t {
    CEMRVS_0 = 0x0,
    CEMRVS_1 = 0x1,
};

/// Reference select
/// Register: CExCTL2
/// Field: CERSEL [5:5]
enum class COMP_E1_CEXCTL2_CERSEL : uint16_t {
    CERSEL_0 = 0x0,
    CERSEL_1 = 0x1,
};

/// Reference source
/// Register: CExCTL2
/// Field: CERS [6:7]
enum class COMP_E1_CEXCTL2_CERS : uint16_t {
    CERS_0 = 0x0,
    CERS_1 = 0x1,
    CERS_2 = 0x2,
    CERS_3 = 0x3,
};

/// Reference voltage level
/// Register: CExCTL2
/// Field: CEREFL [13:14]
enum class COMP_E1_CEXCTL2_CEREFL : uint16_t {
    CEREFL_0 = 0x0,
    CEREFL_1 = 0x1,
    CEREFL_2 = 0x2,
    CEREFL_3 = 0x3,
};

/// Reference accuracy
/// Register: CExCTL2
/// Field: CEREFACC [15:15]
enum class COMP_E1_CEXCTL2_CEREFACC : uint16_t {
    CEREFACC_0 = 0x0,
    CEREFACC_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD0 [0:0]
enum class COMP_E1_CEXCTL3_CEPD0 : uint16_t {
    CEPD0_0 = 0x0,
    CEPD0_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD1 [1:1]
enum class COMP_E1_CEXCTL3_CEPD1 : uint16_t {
    CEPD1_0 = 0x0,
    CEPD1_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD2 [2:2]
enum class COMP_E1_CEXCTL3_CEPD2 : uint16_t {
    CEPD2_0 = 0x0,
    CEPD2_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD3 [3:3]
enum class COMP_E1_CEXCTL3_CEPD3 : uint16_t {
    CEPD3_0 = 0x0,
    CEPD3_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD4 [4:4]
enum class COMP_E1_CEXCTL3_CEPD4 : uint16_t {
    CEPD4_0 = 0x0,
    CEPD4_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD5 [5:5]
enum class COMP_E1_CEXCTL3_CEPD5 : uint16_t {
    CEPD5_0 = 0x0,
    CEPD5_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD6 [6:6]
enum class COMP_E1_CEXCTL3_CEPD6 : uint16_t {
    CEPD6_0 = 0x0,
    CEPD6_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD7 [7:7]
enum class COMP_E1_CEXCTL3_CEPD7 : uint16_t {
    CEPD7_0 = 0x0,
    CEPD7_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD8 [8:8]
enum class COMP_E1_CEXCTL3_CEPD8 : uint16_t {
    CEPD8_0 = 0x0,
    CEPD8_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD9 [9:9]
enum class COMP_E1_CEXCTL3_CEPD9 : uint16_t {
    CEPD9_0 = 0x0,
    CEPD9_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD10 [10:10]
enum class COMP_E1_CEXCTL3_CEPD10 : uint16_t {
    CEPD10_0 = 0x0,
    CEPD10_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD11 [11:11]
enum class COMP_E1_CEXCTL3_CEPD11 : uint16_t {
    CEPD11_0 = 0x0,
    CEPD11_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD12 [12:12]
enum class COMP_E1_CEXCTL3_CEPD12 : uint16_t {
    CEPD12_0 = 0x0,
    CEPD12_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD13 [13:13]
enum class COMP_E1_CEXCTL3_CEPD13 : uint16_t {
    CEPD13_0 = 0x0,
    CEPD13_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD14 [14:14]
enum class COMP_E1_CEXCTL3_CEPD14 : uint16_t {
    CEPD14_0 = 0x0,
    CEPD14_1 = 0x1,
};

/// Port disable
/// Register: CExCTL3
/// Field: CEPD15 [15:15]
enum class COMP_E1_CEXCTL3_CEPD15 : uint16_t {
    CEPD15_0 = 0x0,
    CEPD15_1 = 0x1,
};

/// Comparator output interrupt flag
/// Register: CExINT
/// Field: CEIFG [0:0]
enum class COMP_E1_CEXINT_CEIFG : uint16_t {
    CEIFG_0 = 0x0,
    CEIFG_1 = 0x1,
};

/// Comparator output inverted interrupt flag
/// Register: CExINT
/// Field: CEIIFG [1:1]
enum class COMP_E1_CEXINT_CEIIFG : uint16_t {
    CEIIFG_0 = 0x0,
    CEIIFG_1 = 0x1,
};

/// Comparator ready interrupt flag
/// Register: CExINT
/// Field: CERDYIFG [4:4]
enum class COMP_E1_CEXINT_CERDYIFG : uint16_t {
    CERDYIFG_0 = 0x0,
    CERDYIFG_1 = 0x1,
};

/// Comparator output interrupt enable
/// Register: CExINT
/// Field: CEIE [8:8]
enum class COMP_E1_CEXINT_CEIE : uint16_t {
    CEIE_0 = 0x0,
    CEIE_1 = 0x1,
};

/// Comparator output interrupt enable inverted polarity
/// Register: CExINT
/// Field: CEIIE [9:9]
enum class COMP_E1_CEXINT_CEIIE : uint16_t {
    CEIIE_0 = 0x0,
    CEIIE_1 = 0x1,
};

/// Comparator ready interrupt enable
/// Register: CExINT
/// Field: CERDYIE [12:12]
enum class COMP_E1_CEXINT_CERDYIE : uint16_t {
    CERDYIE_0 = 0x0,
    CERDYIE_1 = 0x1,
};

/// Comparator interrupt vector word register
/// Register: CExIV
/// Field: CEIV [0:15]
enum class COMP_E1_CEXIV_CEIV : uint16_t {
    CEIV_0 = 0x0,
    CEIV_2 = 0x2,
    CEIV_4 = 0x4,
    CEIV_10 = 0xA,
};

// ----------------------------------------------------------------------------
// CS - CS
// ----------------------------------------------------------------------------

/// DCO frequency range select
/// Register: CSCTL0
/// Field: DCORSEL [16:18]
enum class CS_CSCTL0_DCORSEL : uint32_t {
    DCORSEL_0 = 0x0,
    DCORSEL_1 = 0x1,
    DCORSEL_2 = 0x2,
    DCORSEL_3 = 0x3,
    DCORSEL_4 = 0x4,
    DCORSEL_5 = 0x5,
};

/// Enables the DCO external resistor mode
/// Register: CSCTL0
/// Field: DCORES [22:22]
enum class CS_CSCTL0_DCORES : uint32_t {
    DCORES_0 = 0x0,
    DCORES_1 = 0x1,
};

/// Enables the DCO oscillator
/// Register: CSCTL0
/// Field: DCOEN [23:23]
enum class CS_CSCTL0_DCOEN : uint32_t {
    DCOEN_0 = 0x0,
    DCOEN_1 = 0x1,
};

/// Selects the MCLK source
/// Register: CSCTL1
/// Field: SELM [0:2]
enum class CS_CSCTL1_SELM : uint32_t {
    SELM_0 = 0x0,
    SELM_1 = 0x1,
    SELM_2 = 0x2,
    SELM_3 = 0x3,
    SELM_4 = 0x4,
    SELM_5 = 0x5,
    SELM_6 = 0x6,
    SELM_7 = 0x7,
};

/// Selects the SMCLK and HSMCLK source
/// Register: CSCTL1
/// Field: SELS [4:6]
enum class CS_CSCTL1_SELS : uint32_t {
    SELS_0 = 0x0,
    SELS_1 = 0x1,
    SELS_2 = 0x2,
    SELS_3 = 0x3,
    SELS_4 = 0x4,
    SELS_5 = 0x5,
    SELS_6 = 0x6,
    SELS_7 = 0x7,
};

/// Selects the ACLK source
/// Register: CSCTL1
/// Field: SELA [8:10]
enum class CS_CSCTL1_SELA : uint32_t {
    SELA_0 = 0x0,
    SELA_1 = 0x1,
    SELA_2 = 0x2,
    SELA_3 = 0x3,
    SELA_4 = 0x4,
    SELA_5 = 0x5,
    SELA_6 = 0x6,
    SELA_7 = 0x7,
};

/// Selects the BCLK source
/// Register: CSCTL1
/// Field: SELB [12:12]
enum class CS_CSCTL1_SELB : uint32_t {
    SELB_0 = 0x0,
    SELB_1 = 0x1,
};

/// MCLK source divider
/// Register: CSCTL1
/// Field: DIVM [16:18]
enum class CS_CSCTL1_DIVM : uint32_t {
    DIVM_0 = 0x0,
    DIVM_1 = 0x1,
    DIVM_2 = 0x2,
    DIVM_3 = 0x3,
    DIVM_4 = 0x4,
    DIVM_5 = 0x5,
    DIVM_6 = 0x6,
    DIVM_7 = 0x7,
};

/// HSMCLK source divider
/// Register: CSCTL1
/// Field: DIVHS [20:22]
enum class CS_CSCTL1_DIVHS : uint32_t {
    DIVHS_0 = 0x0,
    DIVHS_1 = 0x1,
    DIVHS_2 = 0x2,
    DIVHS_3 = 0x3,
    DIVHS_4 = 0x4,
    DIVHS_5 = 0x5,
    DIVHS_6 = 0x6,
    DIVHS_7 = 0x7,
};

/// ACLK source divider
/// Register: CSCTL1
/// Field: DIVA [24:26]
enum class CS_CSCTL1_DIVA : uint32_t {
    DIVA_0 = 0x0,
    DIVA_1 = 0x1,
    DIVA_2 = 0x2,
    DIVA_3 = 0x3,
    DIVA_4 = 0x4,
    DIVA_5 = 0x5,
    DIVA_6 = 0x6,
    DIVA_7 = 0x7,
};

/// SMCLK source divider
/// Register: CSCTL1
/// Field: DIVS [28:30]
enum class CS_CSCTL1_DIVS : uint32_t {
    DIVS_0 = 0x0,
    DIVS_1 = 0x1,
    DIVS_2 = 0x2,
    DIVS_3 = 0x3,
    DIVS_4 = 0x4,
    DIVS_5 = 0x5,
    DIVS_6 = 0x6,
    DIVS_7 = 0x7,
};

/// LFXT oscillator current can be adjusted to its drive needs
/// Register: CSCTL2
/// Field: LFXTDRIVE [0:1]
enum class CS_CSCTL2_LFXTDRIVE : uint32_t {
    LFXTDRIVE_0 = 0x0,
    LFXTDRIVE_1 = 0x1,
    LFXTDRIVE_2 = 0x2,
    LFXTDRIVE_3 = 0x3,
};

/// Disables the automatic gain control of the LFXT crystal
/// Register: CSCTL2
/// Field: LFXTAGCOFF [7:7]
enum class CS_CSCTL2_LFXTAGCOFF : uint32_t {
    LFXTAGCOFF_0 = 0x0,
    LFXTAGCOFF_1 = 0x1,
};

/// Turns on the LFXT oscillator regardless if used as a clock resource
/// Register: CSCTL2
/// Field: LFXT_EN [8:8]
enum class CS_CSCTL2_LFXT_EN : uint32_t {
    LFXT_EN_0 = 0x0,
    LFXT_EN_1 = 0x1,
};

/// LFXT bypass select
/// Register: CSCTL2
/// Field: LFXTBYPASS [9:9]
enum class CS_CSCTL2_LFXTBYPASS : uint32_t {
    LFXTBYPASS_0 = 0x0,
    LFXTBYPASS_1 = 0x1,
};

/// HFXT oscillator drive selection
/// Register: CSCTL2
/// Field: HFXTDRIVE [16:16]
enum class CS_CSCTL2_HFXTDRIVE : uint32_t {
    HFXTDRIVE_0 = 0x0,
    HFXTDRIVE_1 = 0x1,
};

/// HFXT frequency selection
/// Register: CSCTL2
/// Field: HFXTFREQ [20:22]
enum class CS_CSCTL2_HFXTFREQ : uint32_t {
    HFXTFREQ_0 = 0x0,
    HFXTFREQ_1 = 0x1,
    HFXTFREQ_2 = 0x2,
    HFXTFREQ_3 = 0x3,
    HFXTFREQ_4 = 0x4,
    HFXTFREQ_5 = 0x5,
    HFXTFREQ_6 = 0x6,
};

/// Turns on the HFXT oscillator regardless if used as a clock resource
/// Register: CSCTL2
/// Field: HFXT_EN [24:24]
enum class CS_CSCTL2_HFXT_EN : uint32_t {
    HFXT_EN_0 = 0x0,
    HFXT_EN_1 = 0x1,
};

/// HFXT bypass select
/// Register: CSCTL2
/// Field: HFXTBYPASS [25:25]
enum class CS_CSCTL2_HFXTBYPASS : uint32_t {
    HFXTBYPASS_0 = 0x0,
    HFXTBYPASS_1 = 0x1,
};

/// Start flag counter for LFXT
/// Register: CSCTL3
/// Field: FCNTLF [0:1]
enum class CS_CSCTL3_FCNTLF : uint32_t {
    FCNTLF_0 = 0x0,
    FCNTLF_1 = 0x1,
    FCNTLF_2 = 0x2,
    FCNTLF_3 = 0x3,
};

/// Reset start fault counter for LFXT
/// Register: CSCTL3
/// Field: RFCNTLF [2:2]
enum class CS_CSCTL3_RFCNTLF : uint32_t {
    RFCNTLF_0 = 0x0,
    RFCNTLF_1 = 0x1,
};

/// Enable start fault counter for LFXT
/// Register: CSCTL3
/// Field: FCNTLF_EN [3:3]
enum class CS_CSCTL3_FCNTLF_EN : uint32_t {
    FCNTLF_EN_0 = 0x0,
    FCNTLF_EN_1 = 0x1,
};

/// Start flag counter for HFXT
/// Register: CSCTL3
/// Field: FCNTHF [4:5]
enum class CS_CSCTL3_FCNTHF : uint32_t {
    FCNTHF_0 = 0x0,
    FCNTHF_1 = 0x1,
    FCNTHF_2 = 0x2,
    FCNTHF_3 = 0x3,
};

/// Reset start fault counter for HFXT
/// Register: CSCTL3
/// Field: RFCNTHF [6:6]
enum class CS_CSCTL3_RFCNTHF : uint32_t {
    RFCNTHF_0 = 0x0,
    RFCNTHF_1 = 0x1,
};

/// Enable start fault counter for HFXT
/// Register: CSCTL3
/// Field: FCNTHF_EN [7:7]
enum class CS_CSCTL3_FCNTHF_EN : uint32_t {
    FCNTHF_EN_0 = 0x0,
    FCNTHF_EN_1 = 0x1,
};

/// Start flag counter for HFXT2
/// Register: CSCTL3
/// Field: FCNTHF2 [8:9]
enum class CS_CSCTL3_FCNTHF2 : uint32_t {
    FCNTHF2_0 = 0x0,
    FCNTHF2_1 = 0x1,
    FCNTHF2_2 = 0x2,
    FCNTHF2_3 = 0x3,
};

/// Reset start fault counter for HFXT2
/// Register: CSCTL3
/// Field: RFCNTHF2 [10:10]
enum class CS_CSCTL3_RFCNTHF2 : uint32_t {
    RFCNTHF2_0 = 0x0,
    RFCNTHF2_1 = 0x1,
};

/// Enable start fault counter for HFXT2
/// Register: CSCTL3
/// Field: FCNTHF2_EN [11:11]
enum class CS_CSCTL3_FCNTHF2_EN : uint32_t {
    FCNTHF2_EN_0 = 0x0,
    FCNTHF2_EN_1 = 0x1,
};

/// ACLK system clock conditional request enable
/// Register: CSCLKEN
/// Field: ACLK_EN [0:0]
enum class CS_CSCLKEN_ACLK_EN : uint32_t {
    ACLK_EN_0 = 0x0,
    ACLK_EN_1 = 0x1,
};

/// MCLK system clock conditional request enable
/// Register: CSCLKEN
/// Field: MCLK_EN [1:1]
enum class CS_CSCLKEN_MCLK_EN : uint32_t {
    MCLK_EN_0 = 0x0,
    MCLK_EN_1 = 0x1,
};

/// HSMCLK system clock conditional request enable
/// Register: CSCLKEN
/// Field: HSMCLK_EN [2:2]
enum class CS_CSCLKEN_HSMCLK_EN : uint32_t {
    HSMCLK_EN_0 = 0x0,
    HSMCLK_EN_1 = 0x1,
};

/// SMCLK system clock conditional request enable
/// Register: CSCLKEN
/// Field: SMCLK_EN [3:3]
enum class CS_CSCLKEN_SMCLK_EN : uint32_t {
    SMCLK_EN_0 = 0x0,
    SMCLK_EN_1 = 0x1,
};

/// Turns on the VLO oscillator
/// Register: CSCLKEN
/// Field: VLO_EN [8:8]
enum class CS_CSCLKEN_VLO_EN : uint32_t {
    VLO_EN_0 = 0x0,
    VLO_EN_1 = 0x1,
};

/// Turns on the REFO oscillator
/// Register: CSCLKEN
/// Field: REFO_EN [9:9]
enum class CS_CSCLKEN_REFO_EN : uint32_t {
    REFO_EN_0 = 0x0,
    REFO_EN_1 = 0x1,
};

/// Turns on the MODOSC oscillator
/// Register: CSCLKEN
/// Field: MODOSC_EN [10:10]
enum class CS_CSCLKEN_MODOSC_EN : uint32_t {
    MODOSC_EN_0 = 0x0,
    MODOSC_EN_1 = 0x1,
};

/// Selects REFO nominal frequency
/// Register: CSCLKEN
/// Field: REFOFSEL [15:15]
enum class CS_CSCLKEN_REFOFSEL : uint32_t {
    REFOFSEL_0 = 0x0,
    REFOFSEL_1 = 0x1,
};

/// DCO status
/// Register: CSSTAT
/// Field: DCO_ON [0:0]
enum class CS_CSSTAT_DCO_ON : uint32_t {
    DCO_ON_0 = 0x0,
    DCO_ON_1 = 0x1,
};

/// DCO bias status
/// Register: CSSTAT
/// Field: DCOBIAS_ON [1:1]
enum class CS_CSSTAT_DCOBIAS_ON : uint32_t {
    DCOBIAS_ON_0 = 0x0,
    DCOBIAS_ON_1 = 0x1,
};

/// HFXT status
/// Register: CSSTAT
/// Field: HFXT_ON [2:2]
enum class CS_CSSTAT_HFXT_ON : uint32_t {
    HFXT_ON_0 = 0x0,
    HFXT_ON_1 = 0x1,
};

/// HFXT2 status
/// Register: CSSTAT
/// Field: HFXT2_ON [3:3]
enum class CS_CSSTAT_HFXT2_ON : uint32_t {
    HFXT2_ON_0 = 0x0,
    HFXT2_ON_1 = 0x1,
};

/// MODOSC status
/// Register: CSSTAT
/// Field: MODOSC_ON [4:4]
enum class CS_CSSTAT_MODOSC_ON : uint32_t {
    MODOSC_ON_0 = 0x0,
    MODOSC_ON_1 = 0x1,
};

/// VLO status
/// Register: CSSTAT
/// Field: VLO_ON [5:5]
enum class CS_CSSTAT_VLO_ON : uint32_t {
    VLO_ON_0 = 0x0,
    VLO_ON_1 = 0x1,
};

/// LFXT status
/// Register: CSSTAT
/// Field: LFXT_ON [6:6]
enum class CS_CSSTAT_LFXT_ON : uint32_t {
    LFXT_ON_0 = 0x0,
    LFXT_ON_1 = 0x1,
};

/// REFO status
/// Register: CSSTAT
/// Field: REFO_ON [7:7]
enum class CS_CSSTAT_REFO_ON : uint32_t {
    REFO_ON_0 = 0x0,
    REFO_ON_1 = 0x1,
};

/// ACLK system clock status
/// Register: CSSTAT
/// Field: ACLK_ON [16:16]
enum class CS_CSSTAT_ACLK_ON : uint32_t {
    ACLK_ON_0 = 0x0,
    ACLK_ON_1 = 0x1,
};

/// MCLK system clock status
/// Register: CSSTAT
/// Field: MCLK_ON [17:17]
enum class CS_CSSTAT_MCLK_ON : uint32_t {
    MCLK_ON_0 = 0x0,
    MCLK_ON_1 = 0x1,
};

/// HSMCLK system clock status
/// Register: CSSTAT
/// Field: HSMCLK_ON [18:18]
enum class CS_CSSTAT_HSMCLK_ON : uint32_t {
    HSMCLK_ON_0 = 0x0,
    HSMCLK_ON_1 = 0x1,
};

/// SMCLK system clock status
/// Register: CSSTAT
/// Field: SMCLK_ON [19:19]
enum class CS_CSSTAT_SMCLK_ON : uint32_t {
    SMCLK_ON_0 = 0x0,
    SMCLK_ON_1 = 0x1,
};

/// MODCLK system clock status
/// Register: CSSTAT
/// Field: MODCLK_ON [20:20]
enum class CS_CSSTAT_MODCLK_ON : uint32_t {
    MODCLK_ON_0 = 0x0,
    MODCLK_ON_1 = 0x1,
};

/// VLOCLK system clock status
/// Register: CSSTAT
/// Field: VLOCLK_ON [21:21]
enum class CS_CSSTAT_VLOCLK_ON : uint32_t {
    VLOCLK_ON_0 = 0x0,
    VLOCLK_ON_1 = 0x1,
};

/// LFXTCLK system clock status
/// Register: CSSTAT
/// Field: LFXTCLK_ON [22:22]
enum class CS_CSSTAT_LFXTCLK_ON : uint32_t {
    LFXTCLK_ON_0 = 0x0,
    LFXTCLK_ON_1 = 0x1,
};

/// REFOCLK system clock status
/// Register: CSSTAT
/// Field: REFOCLK_ON [23:23]
enum class CS_CSSTAT_REFOCLK_ON : uint32_t {
    REFOCLK_ON_0 = 0x0,
    REFOCLK_ON_1 = 0x1,
};

/// ACLK Ready status
/// Register: CSSTAT
/// Field: ACLK_READY [24:24]
enum class CS_CSSTAT_ACLK_READY : uint32_t {
    ACLK_READY_0 = 0x0,
    ACLK_READY_1 = 0x1,
};

/// MCLK Ready status
/// Register: CSSTAT
/// Field: MCLK_READY [25:25]
enum class CS_CSSTAT_MCLK_READY : uint32_t {
    MCLK_READY_0 = 0x0,
    MCLK_READY_1 = 0x1,
};

/// HSMCLK Ready status
/// Register: CSSTAT
/// Field: HSMCLK_READY [26:26]
enum class CS_CSSTAT_HSMCLK_READY : uint32_t {
    HSMCLK_READY_0 = 0x0,
    HSMCLK_READY_1 = 0x1,
};

/// SMCLK Ready status
/// Register: CSSTAT
/// Field: SMCLK_READY [27:27]
enum class CS_CSSTAT_SMCLK_READY : uint32_t {
    SMCLK_READY_0 = 0x0,
    SMCLK_READY_1 = 0x1,
};

/// BCLK Ready status
/// Register: CSSTAT
/// Field: BCLK_READY [28:28]
enum class CS_CSSTAT_BCLK_READY : uint32_t {
    BCLK_READY_0 = 0x0,
    BCLK_READY_1 = 0x1,
};

/// LFXT oscillator fault flag interrupt enable
/// Register: CSIE
/// Field: LFXTIE [0:0]
enum class CS_CSIE_LFXTIE : uint32_t {
    LFXTIE_0 = 0x0,
    LFXTIE_1 = 0x1,
};

/// HFXT oscillator fault flag interrupt enable
/// Register: CSIE
/// Field: HFXTIE [1:1]
enum class CS_CSIE_HFXTIE : uint32_t {
    HFXTIE_0 = 0x0,
    HFXTIE_1 = 0x1,
};

/// HFXT2 oscillator fault flag interrupt enable
/// Register: CSIE
/// Field: HFXT2IE [2:2]
enum class CS_CSIE_HFXT2IE : uint32_t {
    HFXT2IE_0 = 0x0,
    HFXT2IE_1 = 0x1,
};

/// DCO external resistor open circuit fault flag interrupt enable.
/// Register: CSIE
/// Field: DCOR_OPNIE [6:6]
enum class CS_CSIE_DCOR_OPNIE : uint32_t {
    DCOR_OPNIE_0 = 0x0,
    DCOR_OPNIE_1 = 0x1,
};

/// Start fault counter interrupt enable LFXT
/// Register: CSIE
/// Field: FCNTLFIE [8:8]
enum class CS_CSIE_FCNTLFIE : uint32_t {
    FCNTLFIE_0 = 0x0,
    FCNTLFIE_1 = 0x1,
};

/// Start fault counter interrupt enable HFXT
/// Register: CSIE
/// Field: FCNTHFIE [9:9]
enum class CS_CSIE_FCNTHFIE : uint32_t {
    FCNTHFIE_0 = 0x0,
    FCNTHFIE_1 = 0x1,
};

/// Start fault counter interrupt enable HFXT2
/// Register: CSIE
/// Field: FCNTHF2IE [10:10]
enum class CS_CSIE_FCNTHF2IE : uint32_t {
    FCNTHF2IE_0 = 0x0,
    FCNTHF2IE_1 = 0x1,
};

/// PLL out-of-lock interrupt enable
/// Register: CSIE
/// Field: PLLOOLIE [12:12]
enum class CS_CSIE_PLLOOLIE : uint32_t {
    PLLOOLIE_0 = 0x0,
    PLLOOLIE_1 = 0x1,
};

/// PLL loss-of-signal interrupt enable
/// Register: CSIE
/// Field: PLLLOSIE [13:13]
enum class CS_CSIE_PLLLOSIE : uint32_t {
    PLLLOSIE_0 = 0x0,
    PLLLOSIE_1 = 0x1,
};

/// PLL out-of-range interrupt enable
/// Register: CSIE
/// Field: PLLOORIE [14:14]
enum class CS_CSIE_PLLOORIE : uint32_t {
    PLLOORIE_0 = 0x0,
    PLLOORIE_1 = 0x1,
};

/// REFCNT period counter interrupt enable
/// Register: CSIE
/// Field: CALIE [15:15]
enum class CS_CSIE_CALIE : uint32_t {
    CALIE_0 = 0x0,
    CALIE_1 = 0x1,
};

/// LFXT oscillator fault flag
/// Register: CSIFG
/// Field: LFXTIFG [0:0]
enum class CS_CSIFG_LFXTIFG : uint32_t {
    LFXTIFG_0 = 0x0,
    LFXTIFG_1 = 0x1,
};

/// HFXT oscillator fault flag
/// Register: CSIFG
/// Field: HFXTIFG [1:1]
enum class CS_CSIFG_HFXTIFG : uint32_t {
    HFXTIFG_0 = 0x0,
    HFXTIFG_1 = 0x1,
};

/// HFXT2 oscillator fault flag
/// Register: CSIFG
/// Field: HFXT2IFG [2:2]
enum class CS_CSIFG_HFXT2IFG : uint32_t {
    HFXT2IFG_0 = 0x0,
    HFXT2IFG_1 = 0x1,
};

/// DCO external resistor short circuit fault flag.
/// Register: CSIFG
/// Field: DCOR_SHTIFG [5:5]
enum class CS_CSIFG_DCOR_SHTIFG : uint32_t {
    DCOR_SHTIFG_0 = 0x0,
    DCOR_SHTIFG_1 = 0x1,
};

/// DCO external resistor open circuit fault flag.
/// Register: CSIFG
/// Field: DCOR_OPNIFG [6:6]
enum class CS_CSIFG_DCOR_OPNIFG : uint32_t {
    DCOR_OPNIFG_0 = 0x0,
    DCOR_OPNIFG_1 = 0x1,
};

/// Start fault counter interrupt flag LFXT
/// Register: CSIFG
/// Field: FCNTLFIFG [8:8]
enum class CS_CSIFG_FCNTLFIFG : uint32_t {
    FCNTLFIFG_0 = 0x0,
    FCNTLFIFG_1 = 0x1,
};

/// Start fault counter interrupt flag HFXT
/// Register: CSIFG
/// Field: FCNTHFIFG [9:9]
enum class CS_CSIFG_FCNTHFIFG : uint32_t {
    FCNTHFIFG_0 = 0x0,
    FCNTHFIFG_1 = 0x1,
};

/// Start fault counter interrupt flag HFXT2
/// Register: CSIFG
/// Field: FCNTHF2IFG [11:11]
enum class CS_CSIFG_FCNTHF2IFG : uint32_t {
    FCNTHF2IFG_0 = 0x0,
    FCNTHF2IFG_1 = 0x1,
};

/// PLL out-of-lock interrupt flag
/// Register: CSIFG
/// Field: PLLOOLIFG [12:12]
enum class CS_CSIFG_PLLOOLIFG : uint32_t {
    PLLOOLIFG_0 = 0x0,
    PLLOOLIFG_1 = 0x1,
};

/// PLL loss-of-signal interrupt flag
/// Register: CSIFG
/// Field: PLLLOSIFG [13:13]
enum class CS_CSIFG_PLLLOSIFG : uint32_t {
    PLLLOSIFG_0 = 0x0,
    PLLLOSIFG_1 = 0x1,
};

/// PLL out-of-range interrupt flag
/// Register: CSIFG
/// Field: PLLOORIFG [14:14]
enum class CS_CSIFG_PLLOORIFG : uint32_t {
    PLLOORIFG_0 = 0x0,
    PLLOORIFG_1 = 0x1,
};

/// REFCNT period counter expired
/// Register: CSIFG
/// Field: CALIFG [15:15]
enum class CS_CSIFG_CALIFG : uint32_t {
    CALIFG_0 = 0x0,
    CALIFG_1 = 0x1,
};

/// Clear LFXT oscillator fault interrupt flag
/// Register: CSCLRIFG
/// Field: CLR_LFXTIFG [0:0]
enum class CS_CSCLRIFG_CLR_LFXTIFG : uint32_t {
    CLR_LFXTIFG_0 = 0x0,
    CLR_LFXTIFG_1 = 0x1,
};

/// Clear HFXT oscillator fault interrupt flag
/// Register: CSCLRIFG
/// Field: CLR_HFXTIFG [1:1]
enum class CS_CSCLRIFG_CLR_HFXTIFG : uint32_t {
    CLR_HFXTIFG_0 = 0x0,
    CLR_HFXTIFG_1 = 0x1,
};

/// Clear HFXT2 oscillator fault interrupt flag
/// Register: CSCLRIFG
/// Field: CLR_HFXT2IFG [2:2]
enum class CS_CSCLRIFG_CLR_HFXT2IFG : uint32_t {
    CLR_HFXT2IFG_0 = 0x0,
    CLR_HFXT2IFG_1 = 0x1,
};

/// Clear DCO external resistor open circuit fault interrupt flag.
/// Register: CSCLRIFG
/// Field: CLR_DCOR_OPNIFG [6:6]
enum class CS_CSCLRIFG_CLR_DCOR_OPNIFG : uint32_t {
    CLR_DCOR_OPNIFG_0 = 0x0,
    CLR_DCOR_OPNIFG_1 = 0x1,
};

/// REFCNT period counter clear interrupt flag
/// Register: CSCLRIFG
/// Field: CLR_CALIFG [15:15]
enum class CS_CSCLRIFG_CLR_CALIFG : uint32_t {
    CLR_CALIFG_0 = 0x0,
    CLR_CALIFG_1 = 0x1,
};

/// Start fault counter clear interrupt flag LFXT
/// Register: CSCLRIFG
/// Field: CLR_FCNTLFIFG [8:8]
enum class CS_CSCLRIFG_CLR_FCNTLFIFG : uint32_t {
    CLR_FCNTLFIFG_0 = 0x0,
    CLR_FCNTLFIFG_1 = 0x1,
};

/// Start fault counter clear interrupt flag HFXT
/// Register: CSCLRIFG
/// Field: CLR_FCNTHFIFG [9:9]
enum class CS_CSCLRIFG_CLR_FCNTHFIFG : uint32_t {
    CLR_FCNTHFIFG_0 = 0x0,
    CLR_FCNTHFIFG_1 = 0x1,
};

/// Start fault counter clear interrupt flag HFXT2
/// Register: CSCLRIFG
/// Field: CLR_FCNTHF2IFG [10:10]
enum class CS_CSCLRIFG_CLR_FCNTHF2IFG : uint32_t {
    CLR_FCNTHF2IFG_0 = 0x0,
    CLR_FCNTHF2IFG_1 = 0x1,
};

/// PLL out-of-lock clear interrupt flag
/// Register: CSCLRIFG
/// Field: CLR_PLLOOLIFG [12:12]
enum class CS_CSCLRIFG_CLR_PLLOOLIFG : uint32_t {
    CLR_PLLOOLIFG_0 = 0x0,
    CLR_PLLOOLIFG_1 = 0x1,
};

/// PLL loss-of-signal clear interrupt flag
/// Register: CSCLRIFG
/// Field: CLR_PLLLOSIFG [13:13]
enum class CS_CSCLRIFG_CLR_PLLLOSIFG : uint32_t {
    CLR_PLLLOSIFG_0 = 0x0,
    CLR_PLLLOSIFG_1 = 0x1,
};

/// PLL out-of-range clear interrupt flag
/// Register: CSCLRIFG
/// Field: CLR_PLLOORIFG [14:14]
enum class CS_CSCLRIFG_CLR_PLLOORIFG : uint32_t {
    CLR_PLLOORIFG_0 = 0x0,
    CLR_PLLOORIFG_1 = 0x1,
};

/// Set LFXT oscillator fault interrupt flag
/// Register: CSSETIFG
/// Field: SET_LFXTIFG [0:0]
enum class CS_CSSETIFG_SET_LFXTIFG : uint32_t {
    SET_LFXTIFG_0 = 0x0,
    SET_LFXTIFG_1 = 0x1,
};

/// Set HFXT oscillator fault interrupt flag
/// Register: CSSETIFG
/// Field: SET_HFXTIFG [1:1]
enum class CS_CSSETIFG_SET_HFXTIFG : uint32_t {
    SET_HFXTIFG_0 = 0x0,
    SET_HFXTIFG_1 = 0x1,
};

/// Set HFXT2 oscillator fault interrupt flag
/// Register: CSSETIFG
/// Field: SET_HFXT2IFG [2:2]
enum class CS_CSSETIFG_SET_HFXT2IFG : uint32_t {
    SET_HFXT2IFG_0 = 0x0,
    SET_HFXT2IFG_1 = 0x1,
};

/// Set DCO external resistor open circuit fault interrupt flag.
/// Register: CSSETIFG
/// Field: SET_DCOR_OPNIFG [6:6]
enum class CS_CSSETIFG_SET_DCOR_OPNIFG : uint32_t {
    SET_DCOR_OPNIFG_0 = 0x0,
    SET_DCOR_OPNIFG_1 = 0x1,
};

/// REFCNT period counter set interrupt flag
/// Register: CSSETIFG
/// Field: SET_CALIFG [15:15]
enum class CS_CSSETIFG_SET_CALIFG : uint32_t {
    SET_CALIFG_0 = 0x0,
    SET_CALIFG_1 = 0x1,
};

/// Start fault counter set interrupt flag HFXT
/// Register: CSSETIFG
/// Field: SET_FCNTHFIFG [9:9]
enum class CS_CSSETIFG_SET_FCNTHFIFG : uint32_t {
    SET_FCNTHFIFG_0 = 0x0,
    SET_FCNTHFIFG_1 = 0x1,
};

/// Start fault counter set interrupt flag HFXT2
/// Register: CSSETIFG
/// Field: SET_FCNTHF2IFG [10:10]
enum class CS_CSSETIFG_SET_FCNTHF2IFG : uint32_t {
    SET_FCNTHF2IFG_0 = 0x0,
    SET_FCNTHF2IFG_1 = 0x1,
};

/// Start fault counter set interrupt flag LFXT
/// Register: CSSETIFG
/// Field: SET_FCNTLFIFG [8:8]
enum class CS_CSSETIFG_SET_FCNTLFIFG : uint32_t {
    SET_FCNTLFIFG_0 = 0x0,
    SET_FCNTLFIFG_1 = 0x1,
};

/// PLL out-of-lock set interrupt flag
/// Register: CSSETIFG
/// Field: SET_PLLOOLIFG [12:12]
enum class CS_CSSETIFG_SET_PLLOOLIFG : uint32_t {
    SET_PLLOOLIFG_0 = 0x0,
    SET_PLLOOLIFG_1 = 0x1,
};

/// PLL loss-of-signal set interrupt flag
/// Register: CSSETIFG
/// Field: SET_PLLLOSIFG [13:13]
enum class CS_CSSETIFG_SET_PLLLOSIFG : uint32_t {
    SET_PLLLOSIFG_0 = 0x0,
    SET_PLLLOSIFG_1 = 0x1,
};

/// PLL out-of-range set interrupt flag
/// Register: CSSETIFG
/// Field: SET_PLLOORIFG [14:14]
enum class CS_CSSETIFG_SET_PLLOORIFG : uint32_t {
    SET_PLLOORIFG_0 = 0x0,
    SET_PLLOORIFG_1 = 0x1,
};

// ----------------------------------------------------------------------------
// DIO - DIO
// ----------------------------------------------------------------------------

/// Port 1 interrupt vector value
/// Register: P1IV
/// Field: P1IV [0:4]
enum class DIO_P1IV_P1IV : uint16_t {
    P1IV_0 = 0x0,
    P1IV_2 = 0x2,
    P1IV_4 = 0x4,
    P1IV_6 = 0x6,
    P1IV_8 = 0x8,
    P1IV_10 = 0xA,
    P1IV_12 = 0xC,
    P1IV_14 = 0xE,
    P1IV_16 = 0x10,
};

/// Port 2 interrupt vector value
/// Register: P2IV
/// Field: P2IV [0:4]
enum class DIO_P2IV_P2IV : uint16_t {
    P2IV_0 = 0x0,
    P2IV_2 = 0x2,
    P2IV_4 = 0x4,
    P2IV_6 = 0x6,
    P2IV_8 = 0x8,
    P2IV_10 = 0xA,
    P2IV_12 = 0xC,
    P2IV_14 = 0xE,
    P2IV_16 = 0x10,
};

/// Port 3 interrupt vector value
/// Register: P3IV
/// Field: P3IV [0:4]
enum class DIO_P3IV_P3IV : uint16_t {
    P3IV_0 = 0x0,
    P3IV_2 = 0x2,
    P3IV_4 = 0x4,
    P3IV_6 = 0x6,
    P3IV_8 = 0x8,
    P3IV_10 = 0xA,
    P3IV_12 = 0xC,
    P3IV_14 = 0xE,
    P3IV_16 = 0x10,
};

/// Port 4 interrupt vector value
/// Register: P4IV
/// Field: P4IV [0:4]
enum class DIO_P4IV_P4IV : uint16_t {
    P4IV_0 = 0x0,
    P4IV_2 = 0x2,
    P4IV_4 = 0x4,
    P4IV_6 = 0x6,
    P4IV_8 = 0x8,
    P4IV_10 = 0xA,
    P4IV_12 = 0xC,
    P4IV_14 = 0xE,
    P4IV_16 = 0x10,
};

/// Port 5 interrupt vector value
/// Register: P5IV
/// Field: P5IV [0:4]
enum class DIO_P5IV_P5IV : uint16_t {
    P5IV_0 = 0x0,
    P5IV_2 = 0x2,
    P5IV_4 = 0x4,
    P5IV_6 = 0x6,
    P5IV_8 = 0x8,
    P5IV_10 = 0xA,
    P5IV_12 = 0xC,
    P5IV_14 = 0xE,
    P5IV_16 = 0x10,
};

/// Port 6 interrupt vector value
/// Register: P6IV
/// Field: P6IV [0:4]
enum class DIO_P6IV_P6IV : uint16_t {
    P6IV_0 = 0x0,
    P6IV_2 = 0x2,
    P6IV_4 = 0x4,
    P6IV_6 = 0x6,
    P6IV_8 = 0x8,
    P6IV_10 = 0xA,
    P6IV_12 = 0xC,
    P6IV_14 = 0xE,
    P6IV_16 = 0x10,
};

/// Port 7 interrupt vector value
/// Register: P7IV
/// Field: P7IV [0:4]
enum class DIO_P7IV_P7IV : uint16_t {
    P7IV_0 = 0x0,
    P7IV_2 = 0x2,
    P7IV_4 = 0x4,
    P7IV_6 = 0x6,
    P7IV_8 = 0x8,
    P7IV_10 = 0xA,
    P7IV_12 = 0xC,
    P7IV_14 = 0xE,
    P7IV_16 = 0x10,
};

/// Port 8 interrupt vector value
/// Register: P8IV
/// Field: P8IV [0:4]
enum class DIO_P8IV_P8IV : uint16_t {
    P8IV_0 = 0x0,
    P8IV_2 = 0x2,
    P8IV_4 = 0x4,
    P8IV_6 = 0x6,
    P8IV_8 = 0x8,
    P8IV_10 = 0xA,
    P8IV_12 = 0xC,
    P8IV_14 = 0xE,
    P8IV_16 = 0x10,
};

/// Port 9 interrupt vector value
/// Register: P9IV
/// Field: P9IV [0:4]
enum class DIO_P9IV_P9IV : uint16_t {
    P9IV_0 = 0x0,
    P9IV_2 = 0x2,
    P9IV_4 = 0x4,
    P9IV_6 = 0x6,
    P9IV_8 = 0x8,
    P9IV_10 = 0xA,
    P9IV_12 = 0xC,
    P9IV_14 = 0xE,
    P9IV_16 = 0x10,
};

/// Port 10 interrupt vector value
/// Register: P10IV
/// Field: P10IV [0:4]
enum class DIO_P10IV_P10IV : uint16_t {
    P10IV_0 = 0x0,
    P10IV_2 = 0x2,
    P10IV_4 = 0x4,
    P10IV_6 = 0x6,
    P10IV_8 = 0x8,
    P10IV_10 = 0xA,
    P10IV_12 = 0xC,
    P10IV_14 = 0xE,
    P10IV_16 = 0x10,
};

// ----------------------------------------------------------------------------
// DMA - DMA
// ----------------------------------------------------------------------------

/// Enable status of the controller
/// Register: DMA_STAT
/// Field: MASTEN [0:0]
enum class DMA_DMA_STAT_MASTEN : uint32_t {
    MASTEN_0 = 0x0,
    MASTEN_1 = 0x1,
};

/// Current state of the control state machine.

State can be one of the following:
/// Register: DMA_STAT
/// Field: STATE [4:7]
enum class DMA_DMA_STAT_STATE : uint32_t {
    STATE_0 = 0x0,
    STATE_1 = 0x1,
    STATE_2 = 0x2,
    STATE_3 = 0x3,
    STATE_4 = 0x4,
    STATE_5 = 0x5,
    STATE_6 = 0x6,
    STATE_7 = 0x7,
    STATE_8 = 0x8,
    STATE_9 = 0x9,
    STATE_10 = 0xA,
};

/// Number of available DMA channels minus one.
/// Register: DMA_STAT
/// Field: DMACHANS [16:20]
enum class DMA_DMA_STAT_DMACHANS : uint32_t {
    DMACHANS_0 = 0x0,
    DMACHANS_1 = 0x1,
    DMACHANS_30 = 0x1E,
    DMACHANS_31 = 0x1F,
};

/// To reduce the gate count the controller can be configured to exclude the integration test logic.

The values 2h to Fh are Reserved.
/// Register: DMA_STAT
/// Field: TESTSTAT [28:31]
enum class DMA_DMA_STAT_TESTSTAT : uint32_t {
    TESTSTAT_0 = 0x0,
    TESTSTAT_1 = 0x1,
};

/// Enable status of the controller
/// Register: DMA_CFG
/// Field: MASTEN [0:0]
enum class DMA_DMA_CFG_MASTEN : uint32_t {
    MASTEN_0 = 0x0,
    MASTEN_1 = 0x1,
};

/// Channel wait on request status.
/// Register: DMA_WAITSTAT
/// Field: WAITREQ [0:31]
enum class DMA_DMA_WAITSTAT_WAITREQ : uint32_t {
    WAITREQ_0 = 0x0,
    WAITREQ_1 = 0x1,
};

/// Set the appropriate bit to generate a software DMA request on the

corresponding DMA channel.

Writing to a bit where a DMA channel is not implemented does not

create a DMA request for that channel.
/// Register: DMA_SWREQ
/// Field: CHNL_SW_REQ [0:31]
enum class DMA_DMA_SWREQ_CHNL_SW_REQ : uint32_t {
    CHNL_SW_REQ_0 = 0x0,
    CHNL_SW_REQ_1 = 0x1,
};

/// Returns the useburst status, or disables dma_sreq from generating DMA requests.
/// Register: DMA_USEBURSTSET
/// Field: SET [0:31]
enum class DMA_DMA_USEBURSTSET_SET : uint32_t {
    SET_0_READ = 0x0,
    SET_1_READ = 0x1,
};

/// Set the appropriate bit to enable dma_sreq to generate requests.
/// Register: DMA_USEBURSTCLR
/// Field: CLR [0:31]
enum class DMA_DMA_USEBURSTCLR_CLR : uint32_t {
    CLR_0 = 0x0,
    CLR_1 = 0x1,
};

/// Returns the request mask status of dma_req and dma_sreq, or

disables the corresponding channel from generating DMA requests.
/// Register: DMA_REQMASKSET
/// Field: SET [0:31]
enum class DMA_DMA_REQMASKSET_SET : uint32_t {
    SET_0_READ = 0x0,
    SET_1_READ = 0x1,
};

/// Set the appropriate bit to enable DMA requests for the channel

corresponding to dma_req and dma_sreq.
/// Register: DMA_REQMASKCLR
/// Field: CLR [0:31]
enum class DMA_DMA_REQMASKCLR_CLR : uint32_t {
    CLR_0 = 0x0,
    CLR_1 = 0x1,
};

/// Returns the enable status of the channels, or enables the

corresponding channels.
/// Register: DMA_ENASET
/// Field: SET [0:31]
enum class DMA_DMA_ENASET_SET : uint32_t {
    SET_0_READ = 0x0,
    SET_1_READ = 0x1,
};

/// Set the appropriate bit to disable the corresponding DMA channel.

Note: The controller disables a channel, by setting the appropriate

bit, when:

a) it completes the DMA cycle

b) it reads a channel_cfg memory location which has cycle_ctrl =

b000

c) an ERROR occurs on the AHB-Lite bus.
/// Register: DMA_ENACLR
/// Field: CLR [0:31]
enum class DMA_DMA_ENACLR_CLR : uint32_t {
    CLR_0 = 0x0,
    CLR_1 = 0x1,
};

/// Channel Primary-Alternate Set Register
/// Register: DMA_ALTSET
/// Field: SET [0:31]
enum class DMA_DMA_ALTSET_SET : uint32_t {
    SET_0_READ = 0x0,
    SET_1_READ = 0x1,
};

/// Channel Primary-Alternate Clear Register
/// Register: DMA_ALTCLR
/// Field: CLR [0:31]
enum class DMA_DMA_ALTCLR_CLR : uint32_t {
    CLR_0 = 0x0,
    CLR_1 = 0x1,
};

/// Returns the channel priority mask status, or sets the channel priority

to high.
/// Register: DMA_PRIOSET
/// Field: SET [0:31]
enum class DMA_DMA_PRIOSET_SET : uint32_t {
    SET_0_READ = 0x0,
    SET_1_READ = 0x1,
};

/// Set the appropriate bit to select the default priority level for the

specified DMA channel.
/// Register: DMA_PRIOCLR
/// Field: CLR [0:31]
enum class DMA_DMA_PRIOCLR_CLR : uint32_t {
    CLR_0 = 0x0,
    CLR_1 = 0x1,
};

/// Returns the status of dma_err, or sets the signal LOW.



For test purposes, use the ERRSET register to set dma_err HIGH.

Note: If you deassert dma_err at the same time as an ERROR

occurs on the AHB-Lite bus, then the ERROR condition takes

precedence and dma_err remains asserted.
/// Register: DMA_ERRCLR
/// Field: ERRCLR [0:0]
enum class DMA_DMA_ERRCLR_ERRCLR : uint32_t {
    ERRCLR_0_READ = 0x0,
    ERRCLR_1_READ = 0x1,
};

// ----------------------------------------------------------------------------
// DWT - DWT
// ----------------------------------------------------------------------------

/// Selects a tap on the DWT_CYCCNT register. These are spaced at bits [6] and [10]. When the selected bit in the CYCCNT register changes from 0 to 1 or 1 to 0, it emits into the POSTCNT, bits [8:5], post-scalar counter. That counter then counts down. On a bit change when post-scalar is 0, it triggers an event for PC sampling or CYCEVTCNT.
/// Register: DWT_CTRL
/// Field: CYCTAP [9:9]
enum class DWT_DWT_CTRL_CYCTAP : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Feeds a synchronization pulse to the ITM SYNCENA control. The value selected here picks the rate (approximately 1/second or less) by selecting a tap on the DWT_CYCCNT register. To use synchronization (heartbeat and hot-connect synchronization), CYCCNTENA must be set to 1, SYNCTAP must be set to one of its values, and SYNCENA must be set to 1.
/// Register: DWT_CTRL
/// Field: SYNCTAP [10:11]
enum class DWT_DWT_CTRL_SYNCTAP : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Enables PC Sampling event. A PC sample event is emitted when the POSTCNT counter triggers it. See CYCTAP, bit [9], and POSTPRESET, bits [4:1], for details. Enabling this bit overrides CYCEVTENA (bit [20]). Reset clears the PCSAMPLENA bit.
/// Register: DWT_CTRL
/// Field: PCSAMPLEENA [12:12]
enum class DWT_DWT_CTRL_PCSAMPLEENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Enables Interrupt event tracing. Reset clears the EXCEVTENA bit.
/// Register: DWT_CTRL
/// Field: EXCTRCENA [16:16]
enum class DWT_DWT_CTRL_EXCTRCENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Enables CPI count event. Emits an event when DWT_CPICNT overflows (every 256 cycles of multi-cycle instructions). Reset clears the CPIEVTENA bit.
/// Register: DWT_CTRL
/// Field: CPIEVTENA [17:17]
enum class DWT_DWT_CTRL_CPIEVTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Enables Interrupt overhead event. Emits an event when DWT_EXCCNT overflows (every 256 cycles of interrupt overhead). Reset clears the EXCEVTENA bit.
/// Register: DWT_CTRL
/// Field: EXCEVTENA [18:18]
enum class DWT_DWT_CTRL_EXCEVTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Enables Sleep count event. Emits an event when DWT_SLEEPCNT overflows (every 256 cycles that the processor is sleeping). Reset clears the SLEEPEVTENA bit.
/// Register: DWT_CTRL
/// Field: SLEEPEVTENA [19:19]
enum class DWT_DWT_CTRL_SLEEPEVTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Enables LSU count event. Emits an event when DWT_LSUCNT overflows (every 256 cycles of LSU operation). LSU counts include all LSU costs after the initial cycle for the instruction. Reset clears the LSUEVTENA bit.
/// Register: DWT_CTRL
/// Field: LSUEVTENA [20:20]
enum class DWT_DWT_CTRL_LSUEVTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Enables Folded instruction count event. Emits an event when DWT_FOLDCNT overflows (every 256 cycles of folded instructions). A folded instruction is one that does not incur even one cycle to execute. For example, an IT instruction is folded away and so does not use up one cycle. Reset clears the FOLDEVTENA bit.
/// Register: DWT_CTRL
/// Field: FOLDEVTENA [21:21]
enum class DWT_DWT_CTRL_FOLDEVTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Enables Cycle count event. Emits an event when the POSTCNT counter triggers it. See CYCTAP (bit [9]) and POSTPRESET, bits [4:1], for details. This event is only emitted if PCSAMPLENA, bit [12], is disabled. PCSAMPLENA overrides the setting of this bit. Reset clears the CYCEVTENA bit.
/// Register: DWT_CTRL
/// Field: CYCEVTENA [22:22]
enum class DWT_DWT_CTRL_CYCEVTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Function settings. Note 1: If the ETM is not fitted, then ETM trigger is not possible. Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.
/// Register: DWT_FUNCTION0
/// Field: FUNCTION [0:3]
enum class DWT_DWT_FUNCTION0_FUNCTION : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
    en_0b0100 = 0x4,
    en_0b0101 = 0x5,
    en_0b0110 = 0x6,
    en_0b0111 = 0x7,
    en_0b1000 = 0x8,
    en_0b1001 = 0x9,
    en_0b1010 = 0xA,
    en_0b1011 = 0xB,
    en_0b1100 = 0xC,
    en_0b1101 = 0xD,
    en_0b1110 = 0xE,
    en_0b1111 = 0xF,
};

/// LNK1ENA
/// Register: DWT_FUNCTION0
/// Field: LNK1ENA [9:9]
enum class DWT_DWT_FUNCTION0_LNK1ENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Defines the size of the data in the COMP register that is to be matched:
/// Register: DWT_FUNCTION0
/// Field: DATAVSIZE [10:11]
enum class DWT_DWT_FUNCTION0_DATAVSIZE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Function settings. Note 1: If the ETM is not fitted, then ETM trigger is not possible. Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. Note 3: FUNCTION is overridden for comparators given by DATAVADDR0 and DATAVADDR1 in DWT_FUNCTION1if DATAVMATCH is also set in DWT_FUNCTION1. The comparators given by DATAVADDR0 and DATAVADDR1 can then only perform address comparator matches for comparator 1 data matches. Note 4: If the data matching functionality is not included during implementation it is not possible to set DATAVADDR0, DATAVADDR1, or DATAVMATCH in DWT_FUNCTION1. This means that the data matching functionality is not available in the implementation. Test the availability of data matching by writing and reading the DATAVMATCH bit in DWT_FUNCTION1. If it is not settable then data matching is unavailable. Note 5: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.
/// Register: DWT_FUNCTION1
/// Field: FUNCTION [0:3]
enum class DWT_DWT_FUNCTION1_FUNCTION : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
    en_0b0100 = 0x4,
    en_0b0101 = 0x5,
    en_0b0110 = 0x6,
    en_0b0111 = 0x7,
    en_0b1000 = 0x8,
    en_0b1001 = 0x9,
    en_0b1010 = 0xA,
    en_0b1011 = 0xB,
    en_0b1100 = 0xC,
    en_0b1101 = 0xD,
    en_0b1110 = 0xE,
    en_0b1111 = 0xF,
};

/// LNK1ENA
/// Register: DWT_FUNCTION1
/// Field: LNK1ENA [9:9]
enum class DWT_DWT_FUNCTION1_LNK1ENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Defines the size of the data in the COMP register that is to be matched:
/// Register: DWT_FUNCTION1
/// Field: DATAVSIZE [10:11]
enum class DWT_DWT_FUNCTION1_DATAVSIZE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Function settings. Note 1: If the ETM is not fitted, then ETM trigger is not possible. Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.
/// Register: DWT_FUNCTION2
/// Field: FUNCTION [0:3]
enum class DWT_DWT_FUNCTION2_FUNCTION : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
    en_0b0100 = 0x4,
    en_0b0101 = 0x5,
    en_0b0110 = 0x6,
    en_0b0111 = 0x7,
    en_0b1000 = 0x8,
    en_0b1001 = 0x9,
    en_0b1010 = 0xA,
    en_0b1011 = 0xB,
    en_0b1100 = 0xC,
    en_0b1101 = 0xD,
    en_0b1110 = 0xE,
    en_0b1111 = 0xF,
};

/// LNK1ENA
/// Register: DWT_FUNCTION2
/// Field: LNK1ENA [9:9]
enum class DWT_DWT_FUNCTION2_LNK1ENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Defines the size of the data in the COMP register that is to be matched:
/// Register: DWT_FUNCTION2
/// Field: DATAVSIZE [10:11]
enum class DWT_DWT_FUNCTION2_DATAVSIZE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Function settings. Note 1: If the ETM is not fitted, then ETM trigger is not possible. Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.
/// Register: DWT_FUNCTION3
/// Field: FUNCTION [0:3]
enum class DWT_DWT_FUNCTION3_FUNCTION : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
    en_0b0100 = 0x4,
    en_0b0101 = 0x5,
    en_0b0110 = 0x6,
    en_0b0111 = 0x7,
    en_0b1000 = 0x8,
    en_0b1001 = 0x9,
    en_0b1010 = 0xA,
    en_0b1011 = 0xB,
    en_0b1100 = 0xC,
    en_0b1101 = 0xD,
    en_0b1110 = 0xE,
    en_0b1111 = 0xF,
};

/// LNK1ENA
/// Register: DWT_FUNCTION3
/// Field: LNK1ENA [9:9]
enum class DWT_DWT_FUNCTION3_LNK1ENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Defines the size of the data in the COMP register that is to be matched:
/// Register: DWT_FUNCTION3
/// Field: DATAVSIZE [10:11]
enum class DWT_DWT_FUNCTION3_DATAVSIZE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

// ----------------------------------------------------------------------------
// EUSCI_A0 - EUSCI_A0
// ----------------------------------------------------------------------------

/// Software reset enable
/// Register: UCAxCTLW0
/// Field: UCSWRST [0:0]
enum class EUSCI_A0_UCAXCTLW0_UCSWRST : uint16_t {
    UCSWRST_0 = 0x0,
    UCSWRST_1 = 0x1,
};

/// Transmit break
/// Register: UCAxCTLW0
/// Field: UCTXBRK [1:1]
enum class EUSCI_A0_UCAXCTLW0_UCTXBRK : uint16_t {
    UCTXBRK_0 = 0x0,
    UCTXBRK_1 = 0x1,
};

/// Transmit address
/// Register: UCAxCTLW0
/// Field: UCTXADDR [2:2]
enum class EUSCI_A0_UCAXCTLW0_UCTXADDR : uint16_t {
    UCTXADDR_0 = 0x0,
    UCTXADDR_1 = 0x1,
};

/// Dormant
/// Register: UCAxCTLW0
/// Field: UCDORM [3:3]
enum class EUSCI_A0_UCAXCTLW0_UCDORM : uint16_t {
    UCDORM_0 = 0x0,
    UCDORM_1 = 0x1,
};

/// Receive break character interrupt enable
/// Register: UCAxCTLW0
/// Field: UCBRKIE [4:4]
enum class EUSCI_A0_UCAXCTLW0_UCBRKIE : uint16_t {
    UCBRKIE_0 = 0x0,
    UCBRKIE_1 = 0x1,
};

/// Receive erroneous-character interrupt enable
/// Register: UCAxCTLW0
/// Field: UCRXEIE [5:5]
enum class EUSCI_A0_UCAXCTLW0_UCRXEIE : uint16_t {
    UCRXEIE_0 = 0x0,
    UCRXEIE_1 = 0x1,
};

/// eUSCI_A clock source select
/// Register: UCAxCTLW0
/// Field: UCSSEL [6:7]
enum class EUSCI_A0_UCAXCTLW0_UCSSEL : uint16_t {
    UCSSEL_0 = 0x0,
    UCSSEL_1 = 0x1,
    UCSSEL_2 = 0x2,
};

/// Synchronous mode enable
/// Register: UCAxCTLW0
/// Field: UCSYNC [8:8]
enum class EUSCI_A0_UCAXCTLW0_UCSYNC : uint16_t {
    UCSYNC_0 = 0x0,
    UCSYNC_1 = 0x1,
};

/// eUSCI_A mode
/// Register: UCAxCTLW0
/// Field: UCMODE [9:10]
enum class EUSCI_A0_UCAXCTLW0_UCMODE : uint16_t {
    UCMODE_0 = 0x0,
    UCMODE_1 = 0x1,
    UCMODE_2 = 0x2,
    UCMODE_3 = 0x3,
};

/// Stop bit select
/// Register: UCAxCTLW0
/// Field: UCSPB [11:11]
enum class EUSCI_A0_UCAXCTLW0_UCSPB : uint16_t {
    UCSPB_0 = 0x0,
    UCSPB_1 = 0x1,
};

/// Character length
/// Register: UCAxCTLW0
/// Field: UC7BIT [12:12]
enum class EUSCI_A0_UCAXCTLW0_UC7BIT : uint16_t {
    UC7BIT_0 = 0x0,
    UC7BIT_1 = 0x1,
};

/// MSB first select
/// Register: UCAxCTLW0
/// Field: UCMSB [13:13]
enum class EUSCI_A0_UCAXCTLW0_UCMSB : uint16_t {
    UCMSB_0 = 0x0,
    UCMSB_1 = 0x1,
};

/// Parity select
/// Register: UCAxCTLW0
/// Field: UCPAR [14:14]
enum class EUSCI_A0_UCAXCTLW0_UCPAR : uint16_t {
    UCPAR_0 = 0x0,
    UCPAR_1 = 0x1,
};

/// Parity enable
/// Register: UCAxCTLW0
/// Field: UCPEN [15:15]
enum class EUSCI_A0_UCAXCTLW0_UCPEN : uint16_t {
    UCPEN_0 = 0x0,
    UCPEN_1 = 0x1,
};

/// Deglitch time
/// Register: UCAxCTLW1
/// Field: UCGLIT [0:1]
enum class EUSCI_A0_UCAXCTLW1_UCGLIT : uint16_t {
    UCGLIT_0 = 0x0,
    UCGLIT_1 = 0x1,
    UCGLIT_2 = 0x2,
    UCGLIT_3 = 0x3,
};

/// Oversampling mode enabled
/// Register: UCAxMCTLW
/// Field: UCOS16 [0:0]
enum class EUSCI_A0_UCAXMCTLW_UCOS16 : uint16_t {
    UCOS16_0 = 0x0,
    UCOS16_1 = 0x1,
};

/// eUSCI_A busy
/// Register: UCAxSTATW
/// Field: UCBUSY [0:0]
enum class EUSCI_A0_UCAXSTATW_UCBUSY : uint16_t {
    UCBUSY_0 = 0x0,
    UCBUSY_1 = 0x1,
};

/// Receive error flag
/// Register: UCAxSTATW
/// Field: UCRXERR [2:2]
enum class EUSCI_A0_UCAXSTATW_UCRXERR : uint16_t {
    UCRXERR_0 = 0x0,
    UCRXERR_1 = 0x1,
};

/// Break detect flag
/// Register: UCAxSTATW
/// Field: UCBRK [3:3]
enum class EUSCI_A0_UCAXSTATW_UCBRK : uint16_t {
    UCBRK_0 = 0x0,
    UCBRK_1 = 0x1,
};

/// Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.
/// Register: UCAxSTATW
/// Field: UCPE [4:4]
enum class EUSCI_A0_UCAXSTATW_UCPE : uint16_t {
    UCPE_0 = 0x0,
    UCPE_1 = 0x1,
};

/// Overrun error flag
/// Register: UCAxSTATW
/// Field: UCOE [5:5]
enum class EUSCI_A0_UCAXSTATW_UCOE : uint16_t {
    UCOE_0 = 0x0,
    UCOE_1 = 0x1,
};

/// Framing error flag
/// Register: UCAxSTATW
/// Field: UCFE [6:6]
enum class EUSCI_A0_UCAXSTATW_UCFE : uint16_t {
    UCFE_0 = 0x0,
    UCFE_1 = 0x1,
};

/// Listen enable
/// Register: UCAxSTATW
/// Field: UCLISTEN [7:7]
enum class EUSCI_A0_UCAXSTATW_UCLISTEN : uint16_t {
    UCLISTEN_0 = 0x0,
    UCLISTEN_1 = 0x1,
};

/// Automatic baud-rate detect enable
/// Register: UCAxABCTL
/// Field: UCABDEN [0:0]
enum class EUSCI_A0_UCAXABCTL_UCABDEN : uint16_t {
    UCABDEN_0 = 0x0,
    UCABDEN_1 = 0x1,
};

/// Break time out error
/// Register: UCAxABCTL
/// Field: UCBTOE [2:2]
enum class EUSCI_A0_UCAXABCTL_UCBTOE : uint16_t {
    UCBTOE_0 = 0x0,
    UCBTOE_1 = 0x1,
};

/// Synch field time out error
/// Register: UCAxABCTL
/// Field: UCSTOE [3:3]
enum class EUSCI_A0_UCAXABCTL_UCSTOE : uint16_t {
    UCSTOE_0 = 0x0,
    UCSTOE_1 = 0x1,
};

/// Break/synch delimiter length
/// Register: UCAxABCTL
/// Field: UCDELIM [4:5]
enum class EUSCI_A0_UCAXABCTL_UCDELIM : uint16_t {
    UCDELIM_0 = 0x0,
    UCDELIM_1 = 0x1,
    UCDELIM_2 = 0x2,
    UCDELIM_3 = 0x3,
};

/// IrDA encoder/decoder enable
/// Register: UCAxIRCTL
/// Field: UCIREN [0:0]
enum class EUSCI_A0_UCAXIRCTL_UCIREN : uint16_t {
    UCIREN_0 = 0x0,
    UCIREN_1 = 0x1,
};

/// IrDA transmit pulse clock select
/// Register: UCAxIRCTL
/// Field: UCIRTXCLK [1:1]
enum class EUSCI_A0_UCAXIRCTL_UCIRTXCLK : uint16_t {
    UCIRTXCLK_0 = 0x0,
    UCIRTXCLK_1 = 0x1,
};

/// IrDA receive filter enabled
/// Register: UCAxIRCTL
/// Field: UCIRRXFE [8:8]
enum class EUSCI_A0_UCAXIRCTL_UCIRRXFE : uint16_t {
    UCIRRXFE_0 = 0x0,
    UCIRRXFE_1 = 0x1,
};

/// IrDA receive input UCAxRXD polarity
/// Register: UCAxIRCTL
/// Field: UCIRRXPL [9:9]
enum class EUSCI_A0_UCAXIRCTL_UCIRRXPL : uint16_t {
    UCIRRXPL_0 = 0x0,
    UCIRRXPL_1 = 0x1,
};

/// Receive interrupt enable
/// Register: UCAxIE
/// Field: UCRXIE [0:0]
enum class EUSCI_A0_UCAXIE_UCRXIE : uint16_t {
    UCRXIE_0 = 0x0,
    UCRXIE_1 = 0x1,
};

/// Transmit interrupt enable
/// Register: UCAxIE
/// Field: UCTXIE [1:1]
enum class EUSCI_A0_UCAXIE_UCTXIE : uint16_t {
    UCTXIE_0 = 0x0,
    UCTXIE_1 = 0x1,
};

/// Start bit interrupt enable
/// Register: UCAxIE
/// Field: UCSTTIE [2:2]
enum class EUSCI_A0_UCAXIE_UCSTTIE : uint16_t {
    UCSTTIE_0 = 0x0,
    UCSTTIE_1 = 0x1,
};

/// Transmit complete interrupt enable
/// Register: UCAxIE
/// Field: UCTXCPTIE [3:3]
enum class EUSCI_A0_UCAXIE_UCTXCPTIE : uint16_t {
    UCTXCPTIE_0 = 0x0,
    UCTXCPTIE_1 = 0x1,
};

/// Receive interrupt flag
/// Register: UCAxIFG
/// Field: UCRXIFG [0:0]
enum class EUSCI_A0_UCAXIFG_UCRXIFG : uint16_t {
    UCRXIFG_0 = 0x0,
    UCRXIFG_1 = 0x1,
};

/// Transmit interrupt flag
/// Register: UCAxIFG
/// Field: UCTXIFG [1:1]
enum class EUSCI_A0_UCAXIFG_UCTXIFG : uint16_t {
    UCTXIFG_0 = 0x0,
    UCTXIFG_1 = 0x1,
};

/// Start bit interrupt flag
/// Register: UCAxIFG
/// Field: UCSTTIFG [2:2]
enum class EUSCI_A0_UCAXIFG_UCSTTIFG : uint16_t {
    UCSTTIFG_0 = 0x0,
    UCSTTIFG_1 = 0x1,
};

/// Transmit ready interrupt enable
/// Register: UCAxIFG
/// Field: UCTXCPTIFG [3:3]
enum class EUSCI_A0_UCAXIFG_UCTXCPTIFG : uint16_t {
    UCTXCPTIFG_0 = 0x0,
    UCTXCPTIFG_1 = 0x1,
};

/// eUSCI_A interrupt vector value
/// Register: UCAxIV
/// Field: UCIV [0:15]
enum class EUSCI_A0_UCAXIV_UCIV : uint16_t {
    UCIV_0 = 0x0,
    UCIV_2 = 0x2,
    UCIV_4 = 0x4,
    UCIV_6 = 0x6,
    UCIV_8 = 0x8,
};

// ----------------------------------------------------------------------------
// EUSCI_A1 - EUSCI_A1
// ----------------------------------------------------------------------------

/// Software reset enable
/// Register: UCAxCTLW0
/// Field: UCSWRST [0:0]
enum class EUSCI_A1_UCAXCTLW0_UCSWRST : uint16_t {
    UCSWRST_0 = 0x0,
    UCSWRST_1 = 0x1,
};

/// Transmit break
/// Register: UCAxCTLW0
/// Field: UCTXBRK [1:1]
enum class EUSCI_A1_UCAXCTLW0_UCTXBRK : uint16_t {
    UCTXBRK_0 = 0x0,
    UCTXBRK_1 = 0x1,
};

/// Transmit address
/// Register: UCAxCTLW0
/// Field: UCTXADDR [2:2]
enum class EUSCI_A1_UCAXCTLW0_UCTXADDR : uint16_t {
    UCTXADDR_0 = 0x0,
    UCTXADDR_1 = 0x1,
};

/// Dormant
/// Register: UCAxCTLW0
/// Field: UCDORM [3:3]
enum class EUSCI_A1_UCAXCTLW0_UCDORM : uint16_t {
    UCDORM_0 = 0x0,
    UCDORM_1 = 0x1,
};

/// Receive break character interrupt enable
/// Register: UCAxCTLW0
/// Field: UCBRKIE [4:4]
enum class EUSCI_A1_UCAXCTLW0_UCBRKIE : uint16_t {
    UCBRKIE_0 = 0x0,
    UCBRKIE_1 = 0x1,
};

/// Receive erroneous-character interrupt enable
/// Register: UCAxCTLW0
/// Field: UCRXEIE [5:5]
enum class EUSCI_A1_UCAXCTLW0_UCRXEIE : uint16_t {
    UCRXEIE_0 = 0x0,
    UCRXEIE_1 = 0x1,
};

/// eUSCI_A clock source select
/// Register: UCAxCTLW0
/// Field: UCSSEL [6:7]
enum class EUSCI_A1_UCAXCTLW0_UCSSEL : uint16_t {
    UCSSEL_0 = 0x0,
    UCSSEL_1 = 0x1,
    UCSSEL_2 = 0x2,
};

/// Synchronous mode enable
/// Register: UCAxCTLW0
/// Field: UCSYNC [8:8]
enum class EUSCI_A1_UCAXCTLW0_UCSYNC : uint16_t {
    UCSYNC_0 = 0x0,
    UCSYNC_1 = 0x1,
};

/// eUSCI_A mode
/// Register: UCAxCTLW0
/// Field: UCMODE [9:10]
enum class EUSCI_A1_UCAXCTLW0_UCMODE : uint16_t {
    UCMODE_0 = 0x0,
    UCMODE_1 = 0x1,
    UCMODE_2 = 0x2,
    UCMODE_3 = 0x3,
};

/// Stop bit select
/// Register: UCAxCTLW0
/// Field: UCSPB [11:11]
enum class EUSCI_A1_UCAXCTLW0_UCSPB : uint16_t {
    UCSPB_0 = 0x0,
    UCSPB_1 = 0x1,
};

/// Character length
/// Register: UCAxCTLW0
/// Field: UC7BIT [12:12]
enum class EUSCI_A1_UCAXCTLW0_UC7BIT : uint16_t {
    UC7BIT_0 = 0x0,
    UC7BIT_1 = 0x1,
};

/// MSB first select
/// Register: UCAxCTLW0
/// Field: UCMSB [13:13]
enum class EUSCI_A1_UCAXCTLW0_UCMSB : uint16_t {
    UCMSB_0 = 0x0,
    UCMSB_1 = 0x1,
};

/// Parity select
/// Register: UCAxCTLW0
/// Field: UCPAR [14:14]
enum class EUSCI_A1_UCAXCTLW0_UCPAR : uint16_t {
    UCPAR_0 = 0x0,
    UCPAR_1 = 0x1,
};

/// Parity enable
/// Register: UCAxCTLW0
/// Field: UCPEN [15:15]
enum class EUSCI_A1_UCAXCTLW0_UCPEN : uint16_t {
    UCPEN_0 = 0x0,
    UCPEN_1 = 0x1,
};

/// Deglitch time
/// Register: UCAxCTLW1
/// Field: UCGLIT [0:1]
enum class EUSCI_A1_UCAXCTLW1_UCGLIT : uint16_t {
    UCGLIT_0 = 0x0,
    UCGLIT_1 = 0x1,
    UCGLIT_2 = 0x2,
    UCGLIT_3 = 0x3,
};

/// Oversampling mode enabled
/// Register: UCAxMCTLW
/// Field: UCOS16 [0:0]
enum class EUSCI_A1_UCAXMCTLW_UCOS16 : uint16_t {
    UCOS16_0 = 0x0,
    UCOS16_1 = 0x1,
};

/// eUSCI_A busy
/// Register: UCAxSTATW
/// Field: UCBUSY [0:0]
enum class EUSCI_A1_UCAXSTATW_UCBUSY : uint16_t {
    UCBUSY_0 = 0x0,
    UCBUSY_1 = 0x1,
};

/// Receive error flag
/// Register: UCAxSTATW
/// Field: UCRXERR [2:2]
enum class EUSCI_A1_UCAXSTATW_UCRXERR : uint16_t {
    UCRXERR_0 = 0x0,
    UCRXERR_1 = 0x1,
};

/// Break detect flag
/// Register: UCAxSTATW
/// Field: UCBRK [3:3]
enum class EUSCI_A1_UCAXSTATW_UCBRK : uint16_t {
    UCBRK_0 = 0x0,
    UCBRK_1 = 0x1,
};

/// Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.
/// Register: UCAxSTATW
/// Field: UCPE [4:4]
enum class EUSCI_A1_UCAXSTATW_UCPE : uint16_t {
    UCPE_0 = 0x0,
    UCPE_1 = 0x1,
};

/// Overrun error flag
/// Register: UCAxSTATW
/// Field: UCOE [5:5]
enum class EUSCI_A1_UCAXSTATW_UCOE : uint16_t {
    UCOE_0 = 0x0,
    UCOE_1 = 0x1,
};

/// Framing error flag
/// Register: UCAxSTATW
/// Field: UCFE [6:6]
enum class EUSCI_A1_UCAXSTATW_UCFE : uint16_t {
    UCFE_0 = 0x0,
    UCFE_1 = 0x1,
};

/// Listen enable
/// Register: UCAxSTATW
/// Field: UCLISTEN [7:7]
enum class EUSCI_A1_UCAXSTATW_UCLISTEN : uint16_t {
    UCLISTEN_0 = 0x0,
    UCLISTEN_1 = 0x1,
};

/// Automatic baud-rate detect enable
/// Register: UCAxABCTL
/// Field: UCABDEN [0:0]
enum class EUSCI_A1_UCAXABCTL_UCABDEN : uint16_t {
    UCABDEN_0 = 0x0,
    UCABDEN_1 = 0x1,
};

/// Break time out error
/// Register: UCAxABCTL
/// Field: UCBTOE [2:2]
enum class EUSCI_A1_UCAXABCTL_UCBTOE : uint16_t {
    UCBTOE_0 = 0x0,
    UCBTOE_1 = 0x1,
};

/// Synch field time out error
/// Register: UCAxABCTL
/// Field: UCSTOE [3:3]
enum class EUSCI_A1_UCAXABCTL_UCSTOE : uint16_t {
    UCSTOE_0 = 0x0,
    UCSTOE_1 = 0x1,
};

/// Break/synch delimiter length
/// Register: UCAxABCTL
/// Field: UCDELIM [4:5]
enum class EUSCI_A1_UCAXABCTL_UCDELIM : uint16_t {
    UCDELIM_0 = 0x0,
    UCDELIM_1 = 0x1,
    UCDELIM_2 = 0x2,
    UCDELIM_3 = 0x3,
};

/// IrDA encoder/decoder enable
/// Register: UCAxIRCTL
/// Field: UCIREN [0:0]
enum class EUSCI_A1_UCAXIRCTL_UCIREN : uint16_t {
    UCIREN_0 = 0x0,
    UCIREN_1 = 0x1,
};

/// IrDA transmit pulse clock select
/// Register: UCAxIRCTL
/// Field: UCIRTXCLK [1:1]
enum class EUSCI_A1_UCAXIRCTL_UCIRTXCLK : uint16_t {
    UCIRTXCLK_0 = 0x0,
    UCIRTXCLK_1 = 0x1,
};

/// IrDA receive filter enabled
/// Register: UCAxIRCTL
/// Field: UCIRRXFE [8:8]
enum class EUSCI_A1_UCAXIRCTL_UCIRRXFE : uint16_t {
    UCIRRXFE_0 = 0x0,
    UCIRRXFE_1 = 0x1,
};

/// IrDA receive input UCAxRXD polarity
/// Register: UCAxIRCTL
/// Field: UCIRRXPL [9:9]
enum class EUSCI_A1_UCAXIRCTL_UCIRRXPL : uint16_t {
    UCIRRXPL_0 = 0x0,
    UCIRRXPL_1 = 0x1,
};

/// Receive interrupt enable
/// Register: UCAxIE
/// Field: UCRXIE [0:0]
enum class EUSCI_A1_UCAXIE_UCRXIE : uint16_t {
    UCRXIE_0 = 0x0,
    UCRXIE_1 = 0x1,
};

/// Transmit interrupt enable
/// Register: UCAxIE
/// Field: UCTXIE [1:1]
enum class EUSCI_A1_UCAXIE_UCTXIE : uint16_t {
    UCTXIE_0 = 0x0,
    UCTXIE_1 = 0x1,
};

/// Start bit interrupt enable
/// Register: UCAxIE
/// Field: UCSTTIE [2:2]
enum class EUSCI_A1_UCAXIE_UCSTTIE : uint16_t {
    UCSTTIE_0 = 0x0,
    UCSTTIE_1 = 0x1,
};

/// Transmit complete interrupt enable
/// Register: UCAxIE
/// Field: UCTXCPTIE [3:3]
enum class EUSCI_A1_UCAXIE_UCTXCPTIE : uint16_t {
    UCTXCPTIE_0 = 0x0,
    UCTXCPTIE_1 = 0x1,
};

/// Receive interrupt flag
/// Register: UCAxIFG
/// Field: UCRXIFG [0:0]
enum class EUSCI_A1_UCAXIFG_UCRXIFG : uint16_t {
    UCRXIFG_0 = 0x0,
    UCRXIFG_1 = 0x1,
};

/// Transmit interrupt flag
/// Register: UCAxIFG
/// Field: UCTXIFG [1:1]
enum class EUSCI_A1_UCAXIFG_UCTXIFG : uint16_t {
    UCTXIFG_0 = 0x0,
    UCTXIFG_1 = 0x1,
};

/// Start bit interrupt flag
/// Register: UCAxIFG
/// Field: UCSTTIFG [2:2]
enum class EUSCI_A1_UCAXIFG_UCSTTIFG : uint16_t {
    UCSTTIFG_0 = 0x0,
    UCSTTIFG_1 = 0x1,
};

/// Transmit ready interrupt enable
/// Register: UCAxIFG
/// Field: UCTXCPTIFG [3:3]
enum class EUSCI_A1_UCAXIFG_UCTXCPTIFG : uint16_t {
    UCTXCPTIFG_0 = 0x0,
    UCTXCPTIFG_1 = 0x1,
};

/// eUSCI_A interrupt vector value
/// Register: UCAxIV
/// Field: UCIV [0:15]
enum class EUSCI_A1_UCAXIV_UCIV : uint16_t {
    UCIV_0 = 0x0,
    UCIV_2 = 0x2,
    UCIV_4 = 0x4,
    UCIV_6 = 0x6,
    UCIV_8 = 0x8,
};

// ----------------------------------------------------------------------------
// EUSCI_A2 - EUSCI_A2
// ----------------------------------------------------------------------------

/// Software reset enable
/// Register: UCAxCTLW0
/// Field: UCSWRST [0:0]
enum class EUSCI_A2_UCAXCTLW0_UCSWRST : uint16_t {
    UCSWRST_0 = 0x0,
    UCSWRST_1 = 0x1,
};

/// Transmit break
/// Register: UCAxCTLW0
/// Field: UCTXBRK [1:1]
enum class EUSCI_A2_UCAXCTLW0_UCTXBRK : uint16_t {
    UCTXBRK_0 = 0x0,
    UCTXBRK_1 = 0x1,
};

/// Transmit address
/// Register: UCAxCTLW0
/// Field: UCTXADDR [2:2]
enum class EUSCI_A2_UCAXCTLW0_UCTXADDR : uint16_t {
    UCTXADDR_0 = 0x0,
    UCTXADDR_1 = 0x1,
};

/// Dormant
/// Register: UCAxCTLW0
/// Field: UCDORM [3:3]
enum class EUSCI_A2_UCAXCTLW0_UCDORM : uint16_t {
    UCDORM_0 = 0x0,
    UCDORM_1 = 0x1,
};

/// Receive break character interrupt enable
/// Register: UCAxCTLW0
/// Field: UCBRKIE [4:4]
enum class EUSCI_A2_UCAXCTLW0_UCBRKIE : uint16_t {
    UCBRKIE_0 = 0x0,
    UCBRKIE_1 = 0x1,
};

/// Receive erroneous-character interrupt enable
/// Register: UCAxCTLW0
/// Field: UCRXEIE [5:5]
enum class EUSCI_A2_UCAXCTLW0_UCRXEIE : uint16_t {
    UCRXEIE_0 = 0x0,
    UCRXEIE_1 = 0x1,
};

/// eUSCI_A clock source select
/// Register: UCAxCTLW0
/// Field: UCSSEL [6:7]
enum class EUSCI_A2_UCAXCTLW0_UCSSEL : uint16_t {
    UCSSEL_0 = 0x0,
    UCSSEL_1 = 0x1,
    UCSSEL_2 = 0x2,
};

/// Synchronous mode enable
/// Register: UCAxCTLW0
/// Field: UCSYNC [8:8]
enum class EUSCI_A2_UCAXCTLW0_UCSYNC : uint16_t {
    UCSYNC_0 = 0x0,
    UCSYNC_1 = 0x1,
};

/// eUSCI_A mode
/// Register: UCAxCTLW0
/// Field: UCMODE [9:10]
enum class EUSCI_A2_UCAXCTLW0_UCMODE : uint16_t {
    UCMODE_0 = 0x0,
    UCMODE_1 = 0x1,
    UCMODE_2 = 0x2,
    UCMODE_3 = 0x3,
};

/// Stop bit select
/// Register: UCAxCTLW0
/// Field: UCSPB [11:11]
enum class EUSCI_A2_UCAXCTLW0_UCSPB : uint16_t {
    UCSPB_0 = 0x0,
    UCSPB_1 = 0x1,
};

/// Character length
/// Register: UCAxCTLW0
/// Field: UC7BIT [12:12]
enum class EUSCI_A2_UCAXCTLW0_UC7BIT : uint16_t {
    UC7BIT_0 = 0x0,
    UC7BIT_1 = 0x1,
};

/// MSB first select
/// Register: UCAxCTLW0
/// Field: UCMSB [13:13]
enum class EUSCI_A2_UCAXCTLW0_UCMSB : uint16_t {
    UCMSB_0 = 0x0,
    UCMSB_1 = 0x1,
};

/// Parity select
/// Register: UCAxCTLW0
/// Field: UCPAR [14:14]
enum class EUSCI_A2_UCAXCTLW0_UCPAR : uint16_t {
    UCPAR_0 = 0x0,
    UCPAR_1 = 0x1,
};

/// Parity enable
/// Register: UCAxCTLW0
/// Field: UCPEN [15:15]
enum class EUSCI_A2_UCAXCTLW0_UCPEN : uint16_t {
    UCPEN_0 = 0x0,
    UCPEN_1 = 0x1,
};

/// Deglitch time
/// Register: UCAxCTLW1
/// Field: UCGLIT [0:1]
enum class EUSCI_A2_UCAXCTLW1_UCGLIT : uint16_t {
    UCGLIT_0 = 0x0,
    UCGLIT_1 = 0x1,
    UCGLIT_2 = 0x2,
    UCGLIT_3 = 0x3,
};

/// Oversampling mode enabled
/// Register: UCAxMCTLW
/// Field: UCOS16 [0:0]
enum class EUSCI_A2_UCAXMCTLW_UCOS16 : uint16_t {
    UCOS16_0 = 0x0,
    UCOS16_1 = 0x1,
};

/// eUSCI_A busy
/// Register: UCAxSTATW
/// Field: UCBUSY [0:0]
enum class EUSCI_A2_UCAXSTATW_UCBUSY : uint16_t {
    UCBUSY_0 = 0x0,
    UCBUSY_1 = 0x1,
};

/// Receive error flag
/// Register: UCAxSTATW
/// Field: UCRXERR [2:2]
enum class EUSCI_A2_UCAXSTATW_UCRXERR : uint16_t {
    UCRXERR_0 = 0x0,
    UCRXERR_1 = 0x1,
};

/// Break detect flag
/// Register: UCAxSTATW
/// Field: UCBRK [3:3]
enum class EUSCI_A2_UCAXSTATW_UCBRK : uint16_t {
    UCBRK_0 = 0x0,
    UCBRK_1 = 0x1,
};

/// Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.
/// Register: UCAxSTATW
/// Field: UCPE [4:4]
enum class EUSCI_A2_UCAXSTATW_UCPE : uint16_t {
    UCPE_0 = 0x0,
    UCPE_1 = 0x1,
};

/// Overrun error flag
/// Register: UCAxSTATW
/// Field: UCOE [5:5]
enum class EUSCI_A2_UCAXSTATW_UCOE : uint16_t {
    UCOE_0 = 0x0,
    UCOE_1 = 0x1,
};

/// Framing error flag
/// Register: UCAxSTATW
/// Field: UCFE [6:6]
enum class EUSCI_A2_UCAXSTATW_UCFE : uint16_t {
    UCFE_0 = 0x0,
    UCFE_1 = 0x1,
};

/// Listen enable
/// Register: UCAxSTATW
/// Field: UCLISTEN [7:7]
enum class EUSCI_A2_UCAXSTATW_UCLISTEN : uint16_t {
    UCLISTEN_0 = 0x0,
    UCLISTEN_1 = 0x1,
};

/// Automatic baud-rate detect enable
/// Register: UCAxABCTL
/// Field: UCABDEN [0:0]
enum class EUSCI_A2_UCAXABCTL_UCABDEN : uint16_t {
    UCABDEN_0 = 0x0,
    UCABDEN_1 = 0x1,
};

/// Break time out error
/// Register: UCAxABCTL
/// Field: UCBTOE [2:2]
enum class EUSCI_A2_UCAXABCTL_UCBTOE : uint16_t {
    UCBTOE_0 = 0x0,
    UCBTOE_1 = 0x1,
};

/// Synch field time out error
/// Register: UCAxABCTL
/// Field: UCSTOE [3:3]
enum class EUSCI_A2_UCAXABCTL_UCSTOE : uint16_t {
    UCSTOE_0 = 0x0,
    UCSTOE_1 = 0x1,
};

/// Break/synch delimiter length
/// Register: UCAxABCTL
/// Field: UCDELIM [4:5]
enum class EUSCI_A2_UCAXABCTL_UCDELIM : uint16_t {
    UCDELIM_0 = 0x0,
    UCDELIM_1 = 0x1,
    UCDELIM_2 = 0x2,
    UCDELIM_3 = 0x3,
};

/// IrDA encoder/decoder enable
/// Register: UCAxIRCTL
/// Field: UCIREN [0:0]
enum class EUSCI_A2_UCAXIRCTL_UCIREN : uint16_t {
    UCIREN_0 = 0x0,
    UCIREN_1 = 0x1,
};

/// IrDA transmit pulse clock select
/// Register: UCAxIRCTL
/// Field: UCIRTXCLK [1:1]
enum class EUSCI_A2_UCAXIRCTL_UCIRTXCLK : uint16_t {
    UCIRTXCLK_0 = 0x0,
    UCIRTXCLK_1 = 0x1,
};

/// IrDA receive filter enabled
/// Register: UCAxIRCTL
/// Field: UCIRRXFE [8:8]
enum class EUSCI_A2_UCAXIRCTL_UCIRRXFE : uint16_t {
    UCIRRXFE_0 = 0x0,
    UCIRRXFE_1 = 0x1,
};

/// IrDA receive input UCAxRXD polarity
/// Register: UCAxIRCTL
/// Field: UCIRRXPL [9:9]
enum class EUSCI_A2_UCAXIRCTL_UCIRRXPL : uint16_t {
    UCIRRXPL_0 = 0x0,
    UCIRRXPL_1 = 0x1,
};

/// Receive interrupt enable
/// Register: UCAxIE
/// Field: UCRXIE [0:0]
enum class EUSCI_A2_UCAXIE_UCRXIE : uint16_t {
    UCRXIE_0 = 0x0,
    UCRXIE_1 = 0x1,
};

/// Transmit interrupt enable
/// Register: UCAxIE
/// Field: UCTXIE [1:1]
enum class EUSCI_A2_UCAXIE_UCTXIE : uint16_t {
    UCTXIE_0 = 0x0,
    UCTXIE_1 = 0x1,
};

/// Start bit interrupt enable
/// Register: UCAxIE
/// Field: UCSTTIE [2:2]
enum class EUSCI_A2_UCAXIE_UCSTTIE : uint16_t {
    UCSTTIE_0 = 0x0,
    UCSTTIE_1 = 0x1,
};

/// Transmit complete interrupt enable
/// Register: UCAxIE
/// Field: UCTXCPTIE [3:3]
enum class EUSCI_A2_UCAXIE_UCTXCPTIE : uint16_t {
    UCTXCPTIE_0 = 0x0,
    UCTXCPTIE_1 = 0x1,
};

/// Receive interrupt flag
/// Register: UCAxIFG
/// Field: UCRXIFG [0:0]
enum class EUSCI_A2_UCAXIFG_UCRXIFG : uint16_t {
    UCRXIFG_0 = 0x0,
    UCRXIFG_1 = 0x1,
};

/// Transmit interrupt flag
/// Register: UCAxIFG
/// Field: UCTXIFG [1:1]
enum class EUSCI_A2_UCAXIFG_UCTXIFG : uint16_t {
    UCTXIFG_0 = 0x0,
    UCTXIFG_1 = 0x1,
};

/// Start bit interrupt flag
/// Register: UCAxIFG
/// Field: UCSTTIFG [2:2]
enum class EUSCI_A2_UCAXIFG_UCSTTIFG : uint16_t {
    UCSTTIFG_0 = 0x0,
    UCSTTIFG_1 = 0x1,
};

/// Transmit ready interrupt enable
/// Register: UCAxIFG
/// Field: UCTXCPTIFG [3:3]
enum class EUSCI_A2_UCAXIFG_UCTXCPTIFG : uint16_t {
    UCTXCPTIFG_0 = 0x0,
    UCTXCPTIFG_1 = 0x1,
};

/// eUSCI_A interrupt vector value
/// Register: UCAxIV
/// Field: UCIV [0:15]
enum class EUSCI_A2_UCAXIV_UCIV : uint16_t {
    UCIV_0 = 0x0,
    UCIV_2 = 0x2,
    UCIV_4 = 0x4,
    UCIV_6 = 0x6,
    UCIV_8 = 0x8,
};

// ----------------------------------------------------------------------------
// EUSCI_A3 - EUSCI_A3
// ----------------------------------------------------------------------------

/// Software reset enable
/// Register: UCAxCTLW0
/// Field: UCSWRST [0:0]
enum class EUSCI_A3_UCAXCTLW0_UCSWRST : uint16_t {
    UCSWRST_0 = 0x0,
    UCSWRST_1 = 0x1,
};

/// Transmit break
/// Register: UCAxCTLW0
/// Field: UCTXBRK [1:1]
enum class EUSCI_A3_UCAXCTLW0_UCTXBRK : uint16_t {
    UCTXBRK_0 = 0x0,
    UCTXBRK_1 = 0x1,
};

/// Transmit address
/// Register: UCAxCTLW0
/// Field: UCTXADDR [2:2]
enum class EUSCI_A3_UCAXCTLW0_UCTXADDR : uint16_t {
    UCTXADDR_0 = 0x0,
    UCTXADDR_1 = 0x1,
};

/// Dormant
/// Register: UCAxCTLW0
/// Field: UCDORM [3:3]
enum class EUSCI_A3_UCAXCTLW0_UCDORM : uint16_t {
    UCDORM_0 = 0x0,
    UCDORM_1 = 0x1,
};

/// Receive break character interrupt enable
/// Register: UCAxCTLW0
/// Field: UCBRKIE [4:4]
enum class EUSCI_A3_UCAXCTLW0_UCBRKIE : uint16_t {
    UCBRKIE_0 = 0x0,
    UCBRKIE_1 = 0x1,
};

/// Receive erroneous-character interrupt enable
/// Register: UCAxCTLW0
/// Field: UCRXEIE [5:5]
enum class EUSCI_A3_UCAXCTLW0_UCRXEIE : uint16_t {
    UCRXEIE_0 = 0x0,
    UCRXEIE_1 = 0x1,
};

/// eUSCI_A clock source select
/// Register: UCAxCTLW0
/// Field: UCSSEL [6:7]
enum class EUSCI_A3_UCAXCTLW0_UCSSEL : uint16_t {
    UCSSEL_0 = 0x0,
    UCSSEL_1 = 0x1,
    UCSSEL_2 = 0x2,
};

/// Synchronous mode enable
/// Register: UCAxCTLW0
/// Field: UCSYNC [8:8]
enum class EUSCI_A3_UCAXCTLW0_UCSYNC : uint16_t {
    UCSYNC_0 = 0x0,
    UCSYNC_1 = 0x1,
};

/// eUSCI_A mode
/// Register: UCAxCTLW0
/// Field: UCMODE [9:10]
enum class EUSCI_A3_UCAXCTLW0_UCMODE : uint16_t {
    UCMODE_0 = 0x0,
    UCMODE_1 = 0x1,
    UCMODE_2 = 0x2,
    UCMODE_3 = 0x3,
};

/// Stop bit select
/// Register: UCAxCTLW0
/// Field: UCSPB [11:11]
enum class EUSCI_A3_UCAXCTLW0_UCSPB : uint16_t {
    UCSPB_0 = 0x0,
    UCSPB_1 = 0x1,
};

/// Character length
/// Register: UCAxCTLW0
/// Field: UC7BIT [12:12]
enum class EUSCI_A3_UCAXCTLW0_UC7BIT : uint16_t {
    UC7BIT_0 = 0x0,
    UC7BIT_1 = 0x1,
};

/// MSB first select
/// Register: UCAxCTLW0
/// Field: UCMSB [13:13]
enum class EUSCI_A3_UCAXCTLW0_UCMSB : uint16_t {
    UCMSB_0 = 0x0,
    UCMSB_1 = 0x1,
};

/// Parity select
/// Register: UCAxCTLW0
/// Field: UCPAR [14:14]
enum class EUSCI_A3_UCAXCTLW0_UCPAR : uint16_t {
    UCPAR_0 = 0x0,
    UCPAR_1 = 0x1,
};

/// Parity enable
/// Register: UCAxCTLW0
/// Field: UCPEN [15:15]
enum class EUSCI_A3_UCAXCTLW0_UCPEN : uint16_t {
    UCPEN_0 = 0x0,
    UCPEN_1 = 0x1,
};

/// Deglitch time
/// Register: UCAxCTLW1
/// Field: UCGLIT [0:1]
enum class EUSCI_A3_UCAXCTLW1_UCGLIT : uint16_t {
    UCGLIT_0 = 0x0,
    UCGLIT_1 = 0x1,
    UCGLIT_2 = 0x2,
    UCGLIT_3 = 0x3,
};

/// Oversampling mode enabled
/// Register: UCAxMCTLW
/// Field: UCOS16 [0:0]
enum class EUSCI_A3_UCAXMCTLW_UCOS16 : uint16_t {
    UCOS16_0 = 0x0,
    UCOS16_1 = 0x1,
};

/// eUSCI_A busy
/// Register: UCAxSTATW
/// Field: UCBUSY [0:0]
enum class EUSCI_A3_UCAXSTATW_UCBUSY : uint16_t {
    UCBUSY_0 = 0x0,
    UCBUSY_1 = 0x1,
};

/// Receive error flag
/// Register: UCAxSTATW
/// Field: UCRXERR [2:2]
enum class EUSCI_A3_UCAXSTATW_UCRXERR : uint16_t {
    UCRXERR_0 = 0x0,
    UCRXERR_1 = 0x1,
};

/// Break detect flag
/// Register: UCAxSTATW
/// Field: UCBRK [3:3]
enum class EUSCI_A3_UCAXSTATW_UCBRK : uint16_t {
    UCBRK_0 = 0x0,
    UCBRK_1 = 0x1,
};

/// Parity error flag. When UCPEN = 0, UCPE is read as 0. UCPE is cleared when UCAxRXBUF is read.
/// Register: UCAxSTATW
/// Field: UCPE [4:4]
enum class EUSCI_A3_UCAXSTATW_UCPE : uint16_t {
    UCPE_0 = 0x0,
    UCPE_1 = 0x1,
};

/// Overrun error flag
/// Register: UCAxSTATW
/// Field: UCOE [5:5]
enum class EUSCI_A3_UCAXSTATW_UCOE : uint16_t {
    UCOE_0 = 0x0,
    UCOE_1 = 0x1,
};

/// Framing error flag
/// Register: UCAxSTATW
/// Field: UCFE [6:6]
enum class EUSCI_A3_UCAXSTATW_UCFE : uint16_t {
    UCFE_0 = 0x0,
    UCFE_1 = 0x1,
};

/// Listen enable
/// Register: UCAxSTATW
/// Field: UCLISTEN [7:7]
enum class EUSCI_A3_UCAXSTATW_UCLISTEN : uint16_t {
    UCLISTEN_0 = 0x0,
    UCLISTEN_1 = 0x1,
};

/// Automatic baud-rate detect enable
/// Register: UCAxABCTL
/// Field: UCABDEN [0:0]
enum class EUSCI_A3_UCAXABCTL_UCABDEN : uint16_t {
    UCABDEN_0 = 0x0,
    UCABDEN_1 = 0x1,
};

/// Break time out error
/// Register: UCAxABCTL
/// Field: UCBTOE [2:2]
enum class EUSCI_A3_UCAXABCTL_UCBTOE : uint16_t {
    UCBTOE_0 = 0x0,
    UCBTOE_1 = 0x1,
};

/// Synch field time out error
/// Register: UCAxABCTL
/// Field: UCSTOE [3:3]
enum class EUSCI_A3_UCAXABCTL_UCSTOE : uint16_t {
    UCSTOE_0 = 0x0,
    UCSTOE_1 = 0x1,
};

/// Break/synch delimiter length
/// Register: UCAxABCTL
/// Field: UCDELIM [4:5]
enum class EUSCI_A3_UCAXABCTL_UCDELIM : uint16_t {
    UCDELIM_0 = 0x0,
    UCDELIM_1 = 0x1,
    UCDELIM_2 = 0x2,
    UCDELIM_3 = 0x3,
};

/// IrDA encoder/decoder enable
/// Register: UCAxIRCTL
/// Field: UCIREN [0:0]
enum class EUSCI_A3_UCAXIRCTL_UCIREN : uint16_t {
    UCIREN_0 = 0x0,
    UCIREN_1 = 0x1,
};

/// IrDA transmit pulse clock select
/// Register: UCAxIRCTL
/// Field: UCIRTXCLK [1:1]
enum class EUSCI_A3_UCAXIRCTL_UCIRTXCLK : uint16_t {
    UCIRTXCLK_0 = 0x0,
    UCIRTXCLK_1 = 0x1,
};

/// IrDA receive filter enabled
/// Register: UCAxIRCTL
/// Field: UCIRRXFE [8:8]
enum class EUSCI_A3_UCAXIRCTL_UCIRRXFE : uint16_t {
    UCIRRXFE_0 = 0x0,
    UCIRRXFE_1 = 0x1,
};

/// IrDA receive input UCAxRXD polarity
/// Register: UCAxIRCTL
/// Field: UCIRRXPL [9:9]
enum class EUSCI_A3_UCAXIRCTL_UCIRRXPL : uint16_t {
    UCIRRXPL_0 = 0x0,
    UCIRRXPL_1 = 0x1,
};

/// Receive interrupt enable
/// Register: UCAxIE
/// Field: UCRXIE [0:0]
enum class EUSCI_A3_UCAXIE_UCRXIE : uint16_t {
    UCRXIE_0 = 0x0,
    UCRXIE_1 = 0x1,
};

/// Transmit interrupt enable
/// Register: UCAxIE
/// Field: UCTXIE [1:1]
enum class EUSCI_A3_UCAXIE_UCTXIE : uint16_t {
    UCTXIE_0 = 0x0,
    UCTXIE_1 = 0x1,
};

/// Start bit interrupt enable
/// Register: UCAxIE
/// Field: UCSTTIE [2:2]
enum class EUSCI_A3_UCAXIE_UCSTTIE : uint16_t {
    UCSTTIE_0 = 0x0,
    UCSTTIE_1 = 0x1,
};

/// Transmit complete interrupt enable
/// Register: UCAxIE
/// Field: UCTXCPTIE [3:3]
enum class EUSCI_A3_UCAXIE_UCTXCPTIE : uint16_t {
    UCTXCPTIE_0 = 0x0,
    UCTXCPTIE_1 = 0x1,
};

/// Receive interrupt flag
/// Register: UCAxIFG
/// Field: UCRXIFG [0:0]
enum class EUSCI_A3_UCAXIFG_UCRXIFG : uint16_t {
    UCRXIFG_0 = 0x0,
    UCRXIFG_1 = 0x1,
};

/// Transmit interrupt flag
/// Register: UCAxIFG
/// Field: UCTXIFG [1:1]
enum class EUSCI_A3_UCAXIFG_UCTXIFG : uint16_t {
    UCTXIFG_0 = 0x0,
    UCTXIFG_1 = 0x1,
};

/// Start bit interrupt flag
/// Register: UCAxIFG
/// Field: UCSTTIFG [2:2]
enum class EUSCI_A3_UCAXIFG_UCSTTIFG : uint16_t {
    UCSTTIFG_0 = 0x0,
    UCSTTIFG_1 = 0x1,
};

/// Transmit ready interrupt enable
/// Register: UCAxIFG
/// Field: UCTXCPTIFG [3:3]
enum class EUSCI_A3_UCAXIFG_UCTXCPTIFG : uint16_t {
    UCTXCPTIFG_0 = 0x0,
    UCTXCPTIFG_1 = 0x1,
};

/// eUSCI_A interrupt vector value
/// Register: UCAxIV
/// Field: UCIV [0:15]
enum class EUSCI_A3_UCAXIV_UCIV : uint16_t {
    UCIV_0 = 0x0,
    UCIV_2 = 0x2,
    UCIV_4 = 0x4,
    UCIV_6 = 0x6,
    UCIV_8 = 0x8,
};

// ----------------------------------------------------------------------------
// EUSCI_B0 - EUSCI_B0
// ----------------------------------------------------------------------------

/// Software reset enable
/// Register: UCBxCTLW0
/// Field: UCSWRST [0:0]
enum class EUSCI_B0_UCBXCTLW0_UCSWRST : uint16_t {
    UCSWRST_0 = 0x0,
    UCSWRST_1 = 0x1,
};

/// Transmit START condition in master mode
/// Register: UCBxCTLW0
/// Field: UCTXSTT [1:1]
enum class EUSCI_B0_UCBXCTLW0_UCTXSTT : uint16_t {
    UCTXSTT_0 = 0x0,
    UCTXSTT_1 = 0x1,
};

/// Transmit STOP condition in master mode
/// Register: UCBxCTLW0
/// Field: UCTXSTP [2:2]
enum class EUSCI_B0_UCBXCTLW0_UCTXSTP : uint16_t {
    UCTXSTP_0 = 0x0,
    UCTXSTP_1 = 0x1,
};

/// Transmit a NACK
/// Register: UCBxCTLW0
/// Field: UCTXNACK [3:3]
enum class EUSCI_B0_UCBXCTLW0_UCTXNACK : uint16_t {
    UCTXNACK_0 = 0x0,
    UCTXNACK_1 = 0x1,
};

/// Transmitter/receiver
/// Register: UCBxCTLW0
/// Field: UCTR [4:4]
enum class EUSCI_B0_UCBXCTLW0_UCTR : uint16_t {
    UCTR_0 = 0x0,
    UCTR_1 = 0x1,
};

/// Transmit ACK condition in slave mode
/// Register: UCBxCTLW0
/// Field: UCTXACK [5:5]
enum class EUSCI_B0_UCBXCTLW0_UCTXACK : uint16_t {
    UCTXACK_0 = 0x0,
    UCTXACK_1 = 0x1,
};

/// eUSCI_B clock source select
/// Register: UCBxCTLW0
/// Field: UCSSEL [6:7]
enum class EUSCI_B0_UCBXCTLW0_UCSSEL : uint16_t {
    UCSSEL_0 = 0x0,
    UCSSEL_1 = 0x1,
    UCSSEL_2 = 0x2,
    UCSSEL_3 = 0x3,
};

/// Synchronous mode enable
/// Register: UCBxCTLW0
/// Field: UCSYNC [8:8]
enum class EUSCI_B0_UCBXCTLW0_UCSYNC : uint16_t {
    UCSYNC_0 = 0x0,
    UCSYNC_1 = 0x1,
};

/// eUSCI_B mode
/// Register: UCBxCTLW0
/// Field: UCMODE [9:10]
enum class EUSCI_B0_UCBXCTLW0_UCMODE : uint16_t {
    UCMODE_0 = 0x0,
    UCMODE_1 = 0x1,
    UCMODE_2 = 0x2,
    UCMODE_3 = 0x3,
};

/// Master mode select
/// Register: UCBxCTLW0
/// Field: UCMST [11:11]
enum class EUSCI_B0_UCBXCTLW0_UCMST : uint16_t {
    UCMST_0 = 0x0,
    UCMST_1 = 0x1,
};

/// Multi-master environment select
/// Register: UCBxCTLW0
/// Field: UCMM [13:13]
enum class EUSCI_B0_UCBXCTLW0_UCMM : uint16_t {
    UCMM_0 = 0x0,
    UCMM_1 = 0x1,
};

/// Slave addressing mode select
/// Register: UCBxCTLW0
/// Field: UCSLA10 [14:14]
enum class EUSCI_B0_UCBXCTLW0_UCSLA10 : uint16_t {
    UCSLA10_0 = 0x0,
    UCSLA10_1 = 0x1,
};

/// Own addressing mode select
/// Register: UCBxCTLW0
/// Field: UCA10 [15:15]
enum class EUSCI_B0_UCBXCTLW0_UCA10 : uint16_t {
    UCA10_0 = 0x0,
    UCA10_1 = 0x1,
};

/// Deglitch time
/// Register: UCBxCTLW1
/// Field: UCGLIT [0:1]
enum class EUSCI_B0_UCBXCTLW1_UCGLIT : uint16_t {
    UCGLIT_0 = 0x0,
    UCGLIT_1 = 0x1,
    UCGLIT_2 = 0x2,
    UCGLIT_3 = 0x3,
};

/// Automatic STOP condition generation
/// Register: UCBxCTLW1
/// Field: UCASTP [2:3]
enum class EUSCI_B0_UCBXCTLW1_UCASTP : uint16_t {
    UCASTP_0 = 0x0,
    UCASTP_1 = 0x1,
    UCASTP_2 = 0x2,
};

/// SW or HW ACK control
/// Register: UCBxCTLW1
/// Field: UCSWACK [4:4]
enum class EUSCI_B0_UCBXCTLW1_UCSWACK : uint16_t {
    UCSWACK_0 = 0x0,
    UCSWACK_1 = 0x1,
};

/// ACK all master bytes
/// Register: UCBxCTLW1
/// Field: UCSTPNACK [5:5]
enum class EUSCI_B0_UCBXCTLW1_UCSTPNACK : uint16_t {
    UCSTPNACK_0 = 0x0,
    UCSTPNACK_1 = 0x1,
};

/// Clock low timeout select
/// Register: UCBxCTLW1
/// Field: UCCLTO [6:7]
enum class EUSCI_B0_UCBXCTLW1_UCCLTO : uint16_t {
    UCCLTO_0 = 0x0,
    UCCLTO_1 = 0x1,
    UCCLTO_2 = 0x2,
    UCCLTO_3 = 0x3,
};

/// Early UCTXIFG0
/// Register: UCBxCTLW1
/// Field: UCETXINT [8:8]
enum class EUSCI_B0_UCBXCTLW1_UCETXINT : uint16_t {
    UCETXINT_0 = 0x0,
    UCETXINT_1 = 0x1,
};

/// Bus busy
/// Register: UCBxSTATW
/// Field: UCBBUSY [4:4]
enum class EUSCI_B0_UCBXSTATW_UCBBUSY : uint16_t {
    UCBBUSY_0 = 0x0,
    UCBBUSY_1 = 0x1,
};

/// General call address received
/// Register: UCBxSTATW
/// Field: UCGC [5:5]
enum class EUSCI_B0_UCBXSTATW_UCGC : uint16_t {
    UCGC_0 = 0x0,
    UCGC_1 = 0x1,
};

/// SCL low
/// Register: UCBxSTATW
/// Field: UCSCLLOW [6:6]
enum class EUSCI_B0_UCBXSTATW_UCSCLLOW : uint16_t {
    UCSCLLOW_0 = 0x0,
    UCSCLLOW_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA0
/// Field: UCOAEN [10:10]
enum class EUSCI_B0_UCBXI2COA0_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// General call response enable
/// Register: UCBxI2COA0
/// Field: UCGCEN [15:15]
enum class EUSCI_B0_UCBXI2COA0_UCGCEN : uint16_t {
    UCGCEN_0 = 0x0,
    UCGCEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA1
/// Field: UCOAEN [10:10]
enum class EUSCI_B0_UCBXI2COA1_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA2
/// Field: UCOAEN [10:10]
enum class EUSCI_B0_UCBXI2COA2_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA3
/// Field: UCOAEN [10:10]
enum class EUSCI_B0_UCBXI2COA3_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Receive interrupt enable 0
/// Register: UCBxIE
/// Field: UCRXIE0 [0:0]
enum class EUSCI_B0_UCBXIE_UCRXIE0 : uint16_t {
    UCRXIE0_0 = 0x0,
    UCRXIE0_1 = 0x1,
};

/// Transmit interrupt enable 0
/// Register: UCBxIE
/// Field: UCTXIE0 [1:1]
enum class EUSCI_B0_UCBXIE_UCTXIE0 : uint16_t {
    UCTXIE0_0 = 0x0,
    UCTXIE0_1 = 0x1,
};

/// START condition interrupt enable
/// Register: UCBxIE
/// Field: UCSTTIE [2:2]
enum class EUSCI_B0_UCBXIE_UCSTTIE : uint16_t {
    UCSTTIE_0 = 0x0,
    UCSTTIE_1 = 0x1,
};

/// STOP condition interrupt enable
/// Register: UCBxIE
/// Field: UCSTPIE [3:3]
enum class EUSCI_B0_UCBXIE_UCSTPIE : uint16_t {
    UCSTPIE_0 = 0x0,
    UCSTPIE_1 = 0x1,
};

/// Arbitration lost interrupt enable
/// Register: UCBxIE
/// Field: UCALIE [4:4]
enum class EUSCI_B0_UCBXIE_UCALIE : uint16_t {
    UCALIE_0 = 0x0,
    UCALIE_1 = 0x1,
};

/// Not-acknowledge interrupt enable
/// Register: UCBxIE
/// Field: UCNACKIE [5:5]
enum class EUSCI_B0_UCBXIE_UCNACKIE : uint16_t {
    UCNACKIE_0 = 0x0,
    UCNACKIE_1 = 0x1,
};

/// Byte counter interrupt enable
/// Register: UCBxIE
/// Field: UCBCNTIE [6:6]
enum class EUSCI_B0_UCBXIE_UCBCNTIE : uint16_t {
    UCBCNTIE_0 = 0x0,
    UCBCNTIE_1 = 0x1,
};

/// Clock low timeout interrupt enable
/// Register: UCBxIE
/// Field: UCCLTOIE [7:7]
enum class EUSCI_B0_UCBXIE_UCCLTOIE : uint16_t {
    UCCLTOIE_0 = 0x0,
    UCCLTOIE_1 = 0x1,
};

/// Receive interrupt enable 1
/// Register: UCBxIE
/// Field: UCRXIE1 [8:8]
enum class EUSCI_B0_UCBXIE_UCRXIE1 : uint16_t {
    UCRXIE1_0 = 0x0,
    UCRXIE1_1 = 0x1,
};

/// Transmit interrupt enable 1
/// Register: UCBxIE
/// Field: UCTXIE1 [9:9]
enum class EUSCI_B0_UCBXIE_UCTXIE1 : uint16_t {
    UCTXIE1_0 = 0x0,
    UCTXIE1_1 = 0x1,
};

/// Receive interrupt enable 2
/// Register: UCBxIE
/// Field: UCRXIE2 [10:10]
enum class EUSCI_B0_UCBXIE_UCRXIE2 : uint16_t {
    UCRXIE2_0 = 0x0,
    UCRXIE2_1 = 0x1,
};

/// Transmit interrupt enable 2
/// Register: UCBxIE
/// Field: UCTXIE2 [11:11]
enum class EUSCI_B0_UCBXIE_UCTXIE2 : uint16_t {
    UCTXIE2_0 = 0x0,
    UCTXIE2_1 = 0x1,
};

/// Receive interrupt enable 3
/// Register: UCBxIE
/// Field: UCRXIE3 [12:12]
enum class EUSCI_B0_UCBXIE_UCRXIE3 : uint16_t {
    UCRXIE3_0 = 0x0,
    UCRXIE3_1 = 0x1,
};

/// Transmit interrupt enable 3
/// Register: UCBxIE
/// Field: UCTXIE3 [13:13]
enum class EUSCI_B0_UCBXIE_UCTXIE3 : uint16_t {
    UCTXIE3_0 = 0x0,
    UCTXIE3_1 = 0x1,
};

/// Bit position 9 interrupt enable
/// Register: UCBxIE
/// Field: UCBIT9IE [14:14]
enum class EUSCI_B0_UCBXIE_UCBIT9IE : uint16_t {
    UCBIT9IE_0 = 0x0,
    UCBIT9IE_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 0
/// Register: UCBxIFG
/// Field: UCRXIFG0 [0:0]
enum class EUSCI_B0_UCBXIFG_UCRXIFG0 : uint16_t {
    UCRXIFG0_0 = 0x0,
    UCRXIFG0_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 0
/// Register: UCBxIFG
/// Field: UCTXIFG0 [1:1]
enum class EUSCI_B0_UCBXIFG_UCTXIFG0 : uint16_t {
    UCTXIFG0_0 = 0x0,
    UCTXIFG0_1 = 0x1,
};

/// START condition interrupt flag
/// Register: UCBxIFG
/// Field: UCSTTIFG [2:2]
enum class EUSCI_B0_UCBXIFG_UCSTTIFG : uint16_t {
    UCSTTIFG_0 = 0x0,
    UCSTTIFG_1 = 0x1,
};

/// STOP condition interrupt flag
/// Register: UCBxIFG
/// Field: UCSTPIFG [3:3]
enum class EUSCI_B0_UCBXIFG_UCSTPIFG : uint16_t {
    UCSTPIFG_0 = 0x0,
    UCSTPIFG_1 = 0x1,
};

/// Arbitration lost interrupt flag
/// Register: UCBxIFG
/// Field: UCALIFG [4:4]
enum class EUSCI_B0_UCBXIFG_UCALIFG : uint16_t {
    UCALIFG_0 = 0x0,
    UCALIFG_1 = 0x1,
};

/// Not-acknowledge received interrupt flag
/// Register: UCBxIFG
/// Field: UCNACKIFG [5:5]
enum class EUSCI_B0_UCBXIFG_UCNACKIFG : uint16_t {
    UCNACKIFG_0 = 0x0,
    UCNACKIFG_1 = 0x1,
};

/// Byte counter interrupt flag
/// Register: UCBxIFG
/// Field: UCBCNTIFG [6:6]
enum class EUSCI_B0_UCBXIFG_UCBCNTIFG : uint16_t {
    UCBCNTIFG_0 = 0x0,
    UCBCNTIFG_1 = 0x1,
};

/// Clock low timeout interrupt flag
/// Register: UCBxIFG
/// Field: UCCLTOIFG [7:7]
enum class EUSCI_B0_UCBXIFG_UCCLTOIFG : uint16_t {
    UCCLTOIFG_0 = 0x0,
    UCCLTOIFG_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 1
/// Register: UCBxIFG
/// Field: UCRXIFG1 [8:8]
enum class EUSCI_B0_UCBXIFG_UCRXIFG1 : uint16_t {
    UCRXIFG1_0 = 0x0,
    UCRXIFG1_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 1
/// Register: UCBxIFG
/// Field: UCTXIFG1 [9:9]
enum class EUSCI_B0_UCBXIFG_UCTXIFG1 : uint16_t {
    UCTXIFG1_0 = 0x0,
    UCTXIFG1_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 2
/// Register: UCBxIFG
/// Field: UCRXIFG2 [10:10]
enum class EUSCI_B0_UCBXIFG_UCRXIFG2 : uint16_t {
    UCRXIFG2_0 = 0x0,
    UCRXIFG2_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 2
/// Register: UCBxIFG
/// Field: UCTXIFG2 [11:11]
enum class EUSCI_B0_UCBXIFG_UCTXIFG2 : uint16_t {
    UCTXIFG2_0 = 0x0,
    UCTXIFG2_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 3
/// Register: UCBxIFG
/// Field: UCRXIFG3 [12:12]
enum class EUSCI_B0_UCBXIFG_UCRXIFG3 : uint16_t {
    UCRXIFG3_0 = 0x0,
    UCRXIFG3_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 3
/// Register: UCBxIFG
/// Field: UCTXIFG3 [13:13]
enum class EUSCI_B0_UCBXIFG_UCTXIFG3 : uint16_t {
    UCTXIFG3_0 = 0x0,
    UCTXIFG3_1 = 0x1,
};

/// Bit position 9 interrupt flag
/// Register: UCBxIFG
/// Field: UCBIT9IFG [14:14]
enum class EUSCI_B0_UCBXIFG_UCBIT9IFG : uint16_t {
    UCBIT9IFG_0 = 0x0,
    UCBIT9IFG_1 = 0x1,
};

/// eUSCI_B interrupt vector value
/// Register: UCBxIV
/// Field: UCIV [0:15]
enum class EUSCI_B0_UCBXIV_UCIV : uint16_t {
    UCIV_0 = 0x0,
    UCIV_2 = 0x2,
    UCIV_4 = 0x4,
    UCIV_6 = 0x6,
    UCIV_8 = 0x8,
    UCIV_10 = 0xA,
    UCIV_12 = 0xC,
    UCIV_14 = 0xE,
    UCIV_16 = 0x10,
    UCIV_18 = 0x12,
    UCIV_20 = 0x14,
    UCIV_22 = 0x16,
    UCIV_24 = 0x18,
    UCIV_26 = 0x1A,
    UCIV_28 = 0x1C,
    UCIV_30 = 0x1E,
};

// ----------------------------------------------------------------------------
// EUSCI_B1 - EUSCI_B1
// ----------------------------------------------------------------------------

/// Software reset enable
/// Register: UCBxCTLW0
/// Field: UCSWRST [0:0]
enum class EUSCI_B1_UCBXCTLW0_UCSWRST : uint16_t {
    UCSWRST_0 = 0x0,
    UCSWRST_1 = 0x1,
};

/// Transmit START condition in master mode
/// Register: UCBxCTLW0
/// Field: UCTXSTT [1:1]
enum class EUSCI_B1_UCBXCTLW0_UCTXSTT : uint16_t {
    UCTXSTT_0 = 0x0,
    UCTXSTT_1 = 0x1,
};

/// Transmit STOP condition in master mode
/// Register: UCBxCTLW0
/// Field: UCTXSTP [2:2]
enum class EUSCI_B1_UCBXCTLW0_UCTXSTP : uint16_t {
    UCTXSTP_0 = 0x0,
    UCTXSTP_1 = 0x1,
};

/// Transmit a NACK
/// Register: UCBxCTLW0
/// Field: UCTXNACK [3:3]
enum class EUSCI_B1_UCBXCTLW0_UCTXNACK : uint16_t {
    UCTXNACK_0 = 0x0,
    UCTXNACK_1 = 0x1,
};

/// Transmitter/receiver
/// Register: UCBxCTLW0
/// Field: UCTR [4:4]
enum class EUSCI_B1_UCBXCTLW0_UCTR : uint16_t {
    UCTR_0 = 0x0,
    UCTR_1 = 0x1,
};

/// Transmit ACK condition in slave mode
/// Register: UCBxCTLW0
/// Field: UCTXACK [5:5]
enum class EUSCI_B1_UCBXCTLW0_UCTXACK : uint16_t {
    UCTXACK_0 = 0x0,
    UCTXACK_1 = 0x1,
};

/// eUSCI_B clock source select
/// Register: UCBxCTLW0
/// Field: UCSSEL [6:7]
enum class EUSCI_B1_UCBXCTLW0_UCSSEL : uint16_t {
    UCSSEL_0 = 0x0,
    UCSSEL_1 = 0x1,
    UCSSEL_2 = 0x2,
    UCSSEL_3 = 0x3,
};

/// Synchronous mode enable
/// Register: UCBxCTLW0
/// Field: UCSYNC [8:8]
enum class EUSCI_B1_UCBXCTLW0_UCSYNC : uint16_t {
    UCSYNC_0 = 0x0,
    UCSYNC_1 = 0x1,
};

/// eUSCI_B mode
/// Register: UCBxCTLW0
/// Field: UCMODE [9:10]
enum class EUSCI_B1_UCBXCTLW0_UCMODE : uint16_t {
    UCMODE_0 = 0x0,
    UCMODE_1 = 0x1,
    UCMODE_2 = 0x2,
    UCMODE_3 = 0x3,
};

/// Master mode select
/// Register: UCBxCTLW0
/// Field: UCMST [11:11]
enum class EUSCI_B1_UCBXCTLW0_UCMST : uint16_t {
    UCMST_0 = 0x0,
    UCMST_1 = 0x1,
};

/// Multi-master environment select
/// Register: UCBxCTLW0
/// Field: UCMM [13:13]
enum class EUSCI_B1_UCBXCTLW0_UCMM : uint16_t {
    UCMM_0 = 0x0,
    UCMM_1 = 0x1,
};

/// Slave addressing mode select
/// Register: UCBxCTLW0
/// Field: UCSLA10 [14:14]
enum class EUSCI_B1_UCBXCTLW0_UCSLA10 : uint16_t {
    UCSLA10_0 = 0x0,
    UCSLA10_1 = 0x1,
};

/// Own addressing mode select
/// Register: UCBxCTLW0
/// Field: UCA10 [15:15]
enum class EUSCI_B1_UCBXCTLW0_UCA10 : uint16_t {
    UCA10_0 = 0x0,
    UCA10_1 = 0x1,
};

/// Deglitch time
/// Register: UCBxCTLW1
/// Field: UCGLIT [0:1]
enum class EUSCI_B1_UCBXCTLW1_UCGLIT : uint16_t {
    UCGLIT_0 = 0x0,
    UCGLIT_1 = 0x1,
    UCGLIT_2 = 0x2,
    UCGLIT_3 = 0x3,
};

/// Automatic STOP condition generation
/// Register: UCBxCTLW1
/// Field: UCASTP [2:3]
enum class EUSCI_B1_UCBXCTLW1_UCASTP : uint16_t {
    UCASTP_0 = 0x0,
    UCASTP_1 = 0x1,
    UCASTP_2 = 0x2,
};

/// SW or HW ACK control
/// Register: UCBxCTLW1
/// Field: UCSWACK [4:4]
enum class EUSCI_B1_UCBXCTLW1_UCSWACK : uint16_t {
    UCSWACK_0 = 0x0,
    UCSWACK_1 = 0x1,
};

/// ACK all master bytes
/// Register: UCBxCTLW1
/// Field: UCSTPNACK [5:5]
enum class EUSCI_B1_UCBXCTLW1_UCSTPNACK : uint16_t {
    UCSTPNACK_0 = 0x0,
    UCSTPNACK_1 = 0x1,
};

/// Clock low timeout select
/// Register: UCBxCTLW1
/// Field: UCCLTO [6:7]
enum class EUSCI_B1_UCBXCTLW1_UCCLTO : uint16_t {
    UCCLTO_0 = 0x0,
    UCCLTO_1 = 0x1,
    UCCLTO_2 = 0x2,
    UCCLTO_3 = 0x3,
};

/// Early UCTXIFG0
/// Register: UCBxCTLW1
/// Field: UCETXINT [8:8]
enum class EUSCI_B1_UCBXCTLW1_UCETXINT : uint16_t {
    UCETXINT_0 = 0x0,
    UCETXINT_1 = 0x1,
};

/// Bus busy
/// Register: UCBxSTATW
/// Field: UCBBUSY [4:4]
enum class EUSCI_B1_UCBXSTATW_UCBBUSY : uint16_t {
    UCBBUSY_0 = 0x0,
    UCBBUSY_1 = 0x1,
};

/// General call address received
/// Register: UCBxSTATW
/// Field: UCGC [5:5]
enum class EUSCI_B1_UCBXSTATW_UCGC : uint16_t {
    UCGC_0 = 0x0,
    UCGC_1 = 0x1,
};

/// SCL low
/// Register: UCBxSTATW
/// Field: UCSCLLOW [6:6]
enum class EUSCI_B1_UCBXSTATW_UCSCLLOW : uint16_t {
    UCSCLLOW_0 = 0x0,
    UCSCLLOW_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA0
/// Field: UCOAEN [10:10]
enum class EUSCI_B1_UCBXI2COA0_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// General call response enable
/// Register: UCBxI2COA0
/// Field: UCGCEN [15:15]
enum class EUSCI_B1_UCBXI2COA0_UCGCEN : uint16_t {
    UCGCEN_0 = 0x0,
    UCGCEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA1
/// Field: UCOAEN [10:10]
enum class EUSCI_B1_UCBXI2COA1_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA2
/// Field: UCOAEN [10:10]
enum class EUSCI_B1_UCBXI2COA2_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA3
/// Field: UCOAEN [10:10]
enum class EUSCI_B1_UCBXI2COA3_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Receive interrupt enable 0
/// Register: UCBxIE
/// Field: UCRXIE0 [0:0]
enum class EUSCI_B1_UCBXIE_UCRXIE0 : uint16_t {
    UCRXIE0_0 = 0x0,
    UCRXIE0_1 = 0x1,
};

/// Transmit interrupt enable 0
/// Register: UCBxIE
/// Field: UCTXIE0 [1:1]
enum class EUSCI_B1_UCBXIE_UCTXIE0 : uint16_t {
    UCTXIE0_0 = 0x0,
    UCTXIE0_1 = 0x1,
};

/// START condition interrupt enable
/// Register: UCBxIE
/// Field: UCSTTIE [2:2]
enum class EUSCI_B1_UCBXIE_UCSTTIE : uint16_t {
    UCSTTIE_0 = 0x0,
    UCSTTIE_1 = 0x1,
};

/// STOP condition interrupt enable
/// Register: UCBxIE
/// Field: UCSTPIE [3:3]
enum class EUSCI_B1_UCBXIE_UCSTPIE : uint16_t {
    UCSTPIE_0 = 0x0,
    UCSTPIE_1 = 0x1,
};

/// Arbitration lost interrupt enable
/// Register: UCBxIE
/// Field: UCALIE [4:4]
enum class EUSCI_B1_UCBXIE_UCALIE : uint16_t {
    UCALIE_0 = 0x0,
    UCALIE_1 = 0x1,
};

/// Not-acknowledge interrupt enable
/// Register: UCBxIE
/// Field: UCNACKIE [5:5]
enum class EUSCI_B1_UCBXIE_UCNACKIE : uint16_t {
    UCNACKIE_0 = 0x0,
    UCNACKIE_1 = 0x1,
};

/// Byte counter interrupt enable
/// Register: UCBxIE
/// Field: UCBCNTIE [6:6]
enum class EUSCI_B1_UCBXIE_UCBCNTIE : uint16_t {
    UCBCNTIE_0 = 0x0,
    UCBCNTIE_1 = 0x1,
};

/// Clock low timeout interrupt enable
/// Register: UCBxIE
/// Field: UCCLTOIE [7:7]
enum class EUSCI_B1_UCBXIE_UCCLTOIE : uint16_t {
    UCCLTOIE_0 = 0x0,
    UCCLTOIE_1 = 0x1,
};

/// Receive interrupt enable 1
/// Register: UCBxIE
/// Field: UCRXIE1 [8:8]
enum class EUSCI_B1_UCBXIE_UCRXIE1 : uint16_t {
    UCRXIE1_0 = 0x0,
    UCRXIE1_1 = 0x1,
};

/// Transmit interrupt enable 1
/// Register: UCBxIE
/// Field: UCTXIE1 [9:9]
enum class EUSCI_B1_UCBXIE_UCTXIE1 : uint16_t {
    UCTXIE1_0 = 0x0,
    UCTXIE1_1 = 0x1,
};

/// Receive interrupt enable 2
/// Register: UCBxIE
/// Field: UCRXIE2 [10:10]
enum class EUSCI_B1_UCBXIE_UCRXIE2 : uint16_t {
    UCRXIE2_0 = 0x0,
    UCRXIE2_1 = 0x1,
};

/// Transmit interrupt enable 2
/// Register: UCBxIE
/// Field: UCTXIE2 [11:11]
enum class EUSCI_B1_UCBXIE_UCTXIE2 : uint16_t {
    UCTXIE2_0 = 0x0,
    UCTXIE2_1 = 0x1,
};

/// Receive interrupt enable 3
/// Register: UCBxIE
/// Field: UCRXIE3 [12:12]
enum class EUSCI_B1_UCBXIE_UCRXIE3 : uint16_t {
    UCRXIE3_0 = 0x0,
    UCRXIE3_1 = 0x1,
};

/// Transmit interrupt enable 3
/// Register: UCBxIE
/// Field: UCTXIE3 [13:13]
enum class EUSCI_B1_UCBXIE_UCTXIE3 : uint16_t {
    UCTXIE3_0 = 0x0,
    UCTXIE3_1 = 0x1,
};

/// Bit position 9 interrupt enable
/// Register: UCBxIE
/// Field: UCBIT9IE [14:14]
enum class EUSCI_B1_UCBXIE_UCBIT9IE : uint16_t {
    UCBIT9IE_0 = 0x0,
    UCBIT9IE_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 0
/// Register: UCBxIFG
/// Field: UCRXIFG0 [0:0]
enum class EUSCI_B1_UCBXIFG_UCRXIFG0 : uint16_t {
    UCRXIFG0_0 = 0x0,
    UCRXIFG0_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 0
/// Register: UCBxIFG
/// Field: UCTXIFG0 [1:1]
enum class EUSCI_B1_UCBXIFG_UCTXIFG0 : uint16_t {
    UCTXIFG0_0 = 0x0,
    UCTXIFG0_1 = 0x1,
};

/// START condition interrupt flag
/// Register: UCBxIFG
/// Field: UCSTTIFG [2:2]
enum class EUSCI_B1_UCBXIFG_UCSTTIFG : uint16_t {
    UCSTTIFG_0 = 0x0,
    UCSTTIFG_1 = 0x1,
};

/// STOP condition interrupt flag
/// Register: UCBxIFG
/// Field: UCSTPIFG [3:3]
enum class EUSCI_B1_UCBXIFG_UCSTPIFG : uint16_t {
    UCSTPIFG_0 = 0x0,
    UCSTPIFG_1 = 0x1,
};

/// Arbitration lost interrupt flag
/// Register: UCBxIFG
/// Field: UCALIFG [4:4]
enum class EUSCI_B1_UCBXIFG_UCALIFG : uint16_t {
    UCALIFG_0 = 0x0,
    UCALIFG_1 = 0x1,
};

/// Not-acknowledge received interrupt flag
/// Register: UCBxIFG
/// Field: UCNACKIFG [5:5]
enum class EUSCI_B1_UCBXIFG_UCNACKIFG : uint16_t {
    UCNACKIFG_0 = 0x0,
    UCNACKIFG_1 = 0x1,
};

/// Byte counter interrupt flag
/// Register: UCBxIFG
/// Field: UCBCNTIFG [6:6]
enum class EUSCI_B1_UCBXIFG_UCBCNTIFG : uint16_t {
    UCBCNTIFG_0 = 0x0,
    UCBCNTIFG_1 = 0x1,
};

/// Clock low timeout interrupt flag
/// Register: UCBxIFG
/// Field: UCCLTOIFG [7:7]
enum class EUSCI_B1_UCBXIFG_UCCLTOIFG : uint16_t {
    UCCLTOIFG_0 = 0x0,
    UCCLTOIFG_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 1
/// Register: UCBxIFG
/// Field: UCRXIFG1 [8:8]
enum class EUSCI_B1_UCBXIFG_UCRXIFG1 : uint16_t {
    UCRXIFG1_0 = 0x0,
    UCRXIFG1_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 1
/// Register: UCBxIFG
/// Field: UCTXIFG1 [9:9]
enum class EUSCI_B1_UCBXIFG_UCTXIFG1 : uint16_t {
    UCTXIFG1_0 = 0x0,
    UCTXIFG1_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 2
/// Register: UCBxIFG
/// Field: UCRXIFG2 [10:10]
enum class EUSCI_B1_UCBXIFG_UCRXIFG2 : uint16_t {
    UCRXIFG2_0 = 0x0,
    UCRXIFG2_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 2
/// Register: UCBxIFG
/// Field: UCTXIFG2 [11:11]
enum class EUSCI_B1_UCBXIFG_UCTXIFG2 : uint16_t {
    UCTXIFG2_0 = 0x0,
    UCTXIFG2_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 3
/// Register: UCBxIFG
/// Field: UCRXIFG3 [12:12]
enum class EUSCI_B1_UCBXIFG_UCRXIFG3 : uint16_t {
    UCRXIFG3_0 = 0x0,
    UCRXIFG3_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 3
/// Register: UCBxIFG
/// Field: UCTXIFG3 [13:13]
enum class EUSCI_B1_UCBXIFG_UCTXIFG3 : uint16_t {
    UCTXIFG3_0 = 0x0,
    UCTXIFG3_1 = 0x1,
};

/// Bit position 9 interrupt flag
/// Register: UCBxIFG
/// Field: UCBIT9IFG [14:14]
enum class EUSCI_B1_UCBXIFG_UCBIT9IFG : uint16_t {
    UCBIT9IFG_0 = 0x0,
    UCBIT9IFG_1 = 0x1,
};

/// eUSCI_B interrupt vector value
/// Register: UCBxIV
/// Field: UCIV [0:15]
enum class EUSCI_B1_UCBXIV_UCIV : uint16_t {
    UCIV_0 = 0x0,
    UCIV_2 = 0x2,
    UCIV_4 = 0x4,
    UCIV_6 = 0x6,
    UCIV_8 = 0x8,
    UCIV_10 = 0xA,
    UCIV_12 = 0xC,
    UCIV_14 = 0xE,
    UCIV_16 = 0x10,
    UCIV_18 = 0x12,
    UCIV_20 = 0x14,
    UCIV_22 = 0x16,
    UCIV_24 = 0x18,
    UCIV_26 = 0x1A,
    UCIV_28 = 0x1C,
    UCIV_30 = 0x1E,
};

// ----------------------------------------------------------------------------
// EUSCI_B2 - EUSCI_B2
// ----------------------------------------------------------------------------

/// Software reset enable
/// Register: UCBxCTLW0
/// Field: UCSWRST [0:0]
enum class EUSCI_B2_UCBXCTLW0_UCSWRST : uint16_t {
    UCSWRST_0 = 0x0,
    UCSWRST_1 = 0x1,
};

/// Transmit START condition in master mode
/// Register: UCBxCTLW0
/// Field: UCTXSTT [1:1]
enum class EUSCI_B2_UCBXCTLW0_UCTXSTT : uint16_t {
    UCTXSTT_0 = 0x0,
    UCTXSTT_1 = 0x1,
};

/// Transmit STOP condition in master mode
/// Register: UCBxCTLW0
/// Field: UCTXSTP [2:2]
enum class EUSCI_B2_UCBXCTLW0_UCTXSTP : uint16_t {
    UCTXSTP_0 = 0x0,
    UCTXSTP_1 = 0x1,
};

/// Transmit a NACK
/// Register: UCBxCTLW0
/// Field: UCTXNACK [3:3]
enum class EUSCI_B2_UCBXCTLW0_UCTXNACK : uint16_t {
    UCTXNACK_0 = 0x0,
    UCTXNACK_1 = 0x1,
};

/// Transmitter/receiver
/// Register: UCBxCTLW0
/// Field: UCTR [4:4]
enum class EUSCI_B2_UCBXCTLW0_UCTR : uint16_t {
    UCTR_0 = 0x0,
    UCTR_1 = 0x1,
};

/// Transmit ACK condition in slave mode
/// Register: UCBxCTLW0
/// Field: UCTXACK [5:5]
enum class EUSCI_B2_UCBXCTLW0_UCTXACK : uint16_t {
    UCTXACK_0 = 0x0,
    UCTXACK_1 = 0x1,
};

/// eUSCI_B clock source select
/// Register: UCBxCTLW0
/// Field: UCSSEL [6:7]
enum class EUSCI_B2_UCBXCTLW0_UCSSEL : uint16_t {
    UCSSEL_0 = 0x0,
    UCSSEL_1 = 0x1,
    UCSSEL_2 = 0x2,
    UCSSEL_3 = 0x3,
};

/// Synchronous mode enable
/// Register: UCBxCTLW0
/// Field: UCSYNC [8:8]
enum class EUSCI_B2_UCBXCTLW0_UCSYNC : uint16_t {
    UCSYNC_0 = 0x0,
    UCSYNC_1 = 0x1,
};

/// eUSCI_B mode
/// Register: UCBxCTLW0
/// Field: UCMODE [9:10]
enum class EUSCI_B2_UCBXCTLW0_UCMODE : uint16_t {
    UCMODE_0 = 0x0,
    UCMODE_1 = 0x1,
    UCMODE_2 = 0x2,
    UCMODE_3 = 0x3,
};

/// Master mode select
/// Register: UCBxCTLW0
/// Field: UCMST [11:11]
enum class EUSCI_B2_UCBXCTLW0_UCMST : uint16_t {
    UCMST_0 = 0x0,
    UCMST_1 = 0x1,
};

/// Multi-master environment select
/// Register: UCBxCTLW0
/// Field: UCMM [13:13]
enum class EUSCI_B2_UCBXCTLW0_UCMM : uint16_t {
    UCMM_0 = 0x0,
    UCMM_1 = 0x1,
};

/// Slave addressing mode select
/// Register: UCBxCTLW0
/// Field: UCSLA10 [14:14]
enum class EUSCI_B2_UCBXCTLW0_UCSLA10 : uint16_t {
    UCSLA10_0 = 0x0,
    UCSLA10_1 = 0x1,
};

/// Own addressing mode select
/// Register: UCBxCTLW0
/// Field: UCA10 [15:15]
enum class EUSCI_B2_UCBXCTLW0_UCA10 : uint16_t {
    UCA10_0 = 0x0,
    UCA10_1 = 0x1,
};

/// Deglitch time
/// Register: UCBxCTLW1
/// Field: UCGLIT [0:1]
enum class EUSCI_B2_UCBXCTLW1_UCGLIT : uint16_t {
    UCGLIT_0 = 0x0,
    UCGLIT_1 = 0x1,
    UCGLIT_2 = 0x2,
    UCGLIT_3 = 0x3,
};

/// Automatic STOP condition generation
/// Register: UCBxCTLW1
/// Field: UCASTP [2:3]
enum class EUSCI_B2_UCBXCTLW1_UCASTP : uint16_t {
    UCASTP_0 = 0x0,
    UCASTP_1 = 0x1,
    UCASTP_2 = 0x2,
};

/// SW or HW ACK control
/// Register: UCBxCTLW1
/// Field: UCSWACK [4:4]
enum class EUSCI_B2_UCBXCTLW1_UCSWACK : uint16_t {
    UCSWACK_0 = 0x0,
    UCSWACK_1 = 0x1,
};

/// ACK all master bytes
/// Register: UCBxCTLW1
/// Field: UCSTPNACK [5:5]
enum class EUSCI_B2_UCBXCTLW1_UCSTPNACK : uint16_t {
    UCSTPNACK_0 = 0x0,
    UCSTPNACK_1 = 0x1,
};

/// Clock low timeout select
/// Register: UCBxCTLW1
/// Field: UCCLTO [6:7]
enum class EUSCI_B2_UCBXCTLW1_UCCLTO : uint16_t {
    UCCLTO_0 = 0x0,
    UCCLTO_1 = 0x1,
    UCCLTO_2 = 0x2,
    UCCLTO_3 = 0x3,
};

/// Early UCTXIFG0
/// Register: UCBxCTLW1
/// Field: UCETXINT [8:8]
enum class EUSCI_B2_UCBXCTLW1_UCETXINT : uint16_t {
    UCETXINT_0 = 0x0,
    UCETXINT_1 = 0x1,
};

/// Bus busy
/// Register: UCBxSTATW
/// Field: UCBBUSY [4:4]
enum class EUSCI_B2_UCBXSTATW_UCBBUSY : uint16_t {
    UCBBUSY_0 = 0x0,
    UCBBUSY_1 = 0x1,
};

/// General call address received
/// Register: UCBxSTATW
/// Field: UCGC [5:5]
enum class EUSCI_B2_UCBXSTATW_UCGC : uint16_t {
    UCGC_0 = 0x0,
    UCGC_1 = 0x1,
};

/// SCL low
/// Register: UCBxSTATW
/// Field: UCSCLLOW [6:6]
enum class EUSCI_B2_UCBXSTATW_UCSCLLOW : uint16_t {
    UCSCLLOW_0 = 0x0,
    UCSCLLOW_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA0
/// Field: UCOAEN [10:10]
enum class EUSCI_B2_UCBXI2COA0_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// General call response enable
/// Register: UCBxI2COA0
/// Field: UCGCEN [15:15]
enum class EUSCI_B2_UCBXI2COA0_UCGCEN : uint16_t {
    UCGCEN_0 = 0x0,
    UCGCEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA1
/// Field: UCOAEN [10:10]
enum class EUSCI_B2_UCBXI2COA1_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA2
/// Field: UCOAEN [10:10]
enum class EUSCI_B2_UCBXI2COA2_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA3
/// Field: UCOAEN [10:10]
enum class EUSCI_B2_UCBXI2COA3_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Receive interrupt enable 0
/// Register: UCBxIE
/// Field: UCRXIE0 [0:0]
enum class EUSCI_B2_UCBXIE_UCRXIE0 : uint16_t {
    UCRXIE0_0 = 0x0,
    UCRXIE0_1 = 0x1,
};

/// Transmit interrupt enable 0
/// Register: UCBxIE
/// Field: UCTXIE0 [1:1]
enum class EUSCI_B2_UCBXIE_UCTXIE0 : uint16_t {
    UCTXIE0_0 = 0x0,
    UCTXIE0_1 = 0x1,
};

/// START condition interrupt enable
/// Register: UCBxIE
/// Field: UCSTTIE [2:2]
enum class EUSCI_B2_UCBXIE_UCSTTIE : uint16_t {
    UCSTTIE_0 = 0x0,
    UCSTTIE_1 = 0x1,
};

/// STOP condition interrupt enable
/// Register: UCBxIE
/// Field: UCSTPIE [3:3]
enum class EUSCI_B2_UCBXIE_UCSTPIE : uint16_t {
    UCSTPIE_0 = 0x0,
    UCSTPIE_1 = 0x1,
};

/// Arbitration lost interrupt enable
/// Register: UCBxIE
/// Field: UCALIE [4:4]
enum class EUSCI_B2_UCBXIE_UCALIE : uint16_t {
    UCALIE_0 = 0x0,
    UCALIE_1 = 0x1,
};

/// Not-acknowledge interrupt enable
/// Register: UCBxIE
/// Field: UCNACKIE [5:5]
enum class EUSCI_B2_UCBXIE_UCNACKIE : uint16_t {
    UCNACKIE_0 = 0x0,
    UCNACKIE_1 = 0x1,
};

/// Byte counter interrupt enable
/// Register: UCBxIE
/// Field: UCBCNTIE [6:6]
enum class EUSCI_B2_UCBXIE_UCBCNTIE : uint16_t {
    UCBCNTIE_0 = 0x0,
    UCBCNTIE_1 = 0x1,
};

/// Clock low timeout interrupt enable
/// Register: UCBxIE
/// Field: UCCLTOIE [7:7]
enum class EUSCI_B2_UCBXIE_UCCLTOIE : uint16_t {
    UCCLTOIE_0 = 0x0,
    UCCLTOIE_1 = 0x1,
};

/// Receive interrupt enable 1
/// Register: UCBxIE
/// Field: UCRXIE1 [8:8]
enum class EUSCI_B2_UCBXIE_UCRXIE1 : uint16_t {
    UCRXIE1_0 = 0x0,
    UCRXIE1_1 = 0x1,
};

/// Transmit interrupt enable 1
/// Register: UCBxIE
/// Field: UCTXIE1 [9:9]
enum class EUSCI_B2_UCBXIE_UCTXIE1 : uint16_t {
    UCTXIE1_0 = 0x0,
    UCTXIE1_1 = 0x1,
};

/// Receive interrupt enable 2
/// Register: UCBxIE
/// Field: UCRXIE2 [10:10]
enum class EUSCI_B2_UCBXIE_UCRXIE2 : uint16_t {
    UCRXIE2_0 = 0x0,
    UCRXIE2_1 = 0x1,
};

/// Transmit interrupt enable 2
/// Register: UCBxIE
/// Field: UCTXIE2 [11:11]
enum class EUSCI_B2_UCBXIE_UCTXIE2 : uint16_t {
    UCTXIE2_0 = 0x0,
    UCTXIE2_1 = 0x1,
};

/// Receive interrupt enable 3
/// Register: UCBxIE
/// Field: UCRXIE3 [12:12]
enum class EUSCI_B2_UCBXIE_UCRXIE3 : uint16_t {
    UCRXIE3_0 = 0x0,
    UCRXIE3_1 = 0x1,
};

/// Transmit interrupt enable 3
/// Register: UCBxIE
/// Field: UCTXIE3 [13:13]
enum class EUSCI_B2_UCBXIE_UCTXIE3 : uint16_t {
    UCTXIE3_0 = 0x0,
    UCTXIE3_1 = 0x1,
};

/// Bit position 9 interrupt enable
/// Register: UCBxIE
/// Field: UCBIT9IE [14:14]
enum class EUSCI_B2_UCBXIE_UCBIT9IE : uint16_t {
    UCBIT9IE_0 = 0x0,
    UCBIT9IE_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 0
/// Register: UCBxIFG
/// Field: UCRXIFG0 [0:0]
enum class EUSCI_B2_UCBXIFG_UCRXIFG0 : uint16_t {
    UCRXIFG0_0 = 0x0,
    UCRXIFG0_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 0
/// Register: UCBxIFG
/// Field: UCTXIFG0 [1:1]
enum class EUSCI_B2_UCBXIFG_UCTXIFG0 : uint16_t {
    UCTXIFG0_0 = 0x0,
    UCTXIFG0_1 = 0x1,
};

/// START condition interrupt flag
/// Register: UCBxIFG
/// Field: UCSTTIFG [2:2]
enum class EUSCI_B2_UCBXIFG_UCSTTIFG : uint16_t {
    UCSTTIFG_0 = 0x0,
    UCSTTIFG_1 = 0x1,
};

/// STOP condition interrupt flag
/// Register: UCBxIFG
/// Field: UCSTPIFG [3:3]
enum class EUSCI_B2_UCBXIFG_UCSTPIFG : uint16_t {
    UCSTPIFG_0 = 0x0,
    UCSTPIFG_1 = 0x1,
};

/// Arbitration lost interrupt flag
/// Register: UCBxIFG
/// Field: UCALIFG [4:4]
enum class EUSCI_B2_UCBXIFG_UCALIFG : uint16_t {
    UCALIFG_0 = 0x0,
    UCALIFG_1 = 0x1,
};

/// Not-acknowledge received interrupt flag
/// Register: UCBxIFG
/// Field: UCNACKIFG [5:5]
enum class EUSCI_B2_UCBXIFG_UCNACKIFG : uint16_t {
    UCNACKIFG_0 = 0x0,
    UCNACKIFG_1 = 0x1,
};

/// Byte counter interrupt flag
/// Register: UCBxIFG
/// Field: UCBCNTIFG [6:6]
enum class EUSCI_B2_UCBXIFG_UCBCNTIFG : uint16_t {
    UCBCNTIFG_0 = 0x0,
    UCBCNTIFG_1 = 0x1,
};

/// Clock low timeout interrupt flag
/// Register: UCBxIFG
/// Field: UCCLTOIFG [7:7]
enum class EUSCI_B2_UCBXIFG_UCCLTOIFG : uint16_t {
    UCCLTOIFG_0 = 0x0,
    UCCLTOIFG_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 1
/// Register: UCBxIFG
/// Field: UCRXIFG1 [8:8]
enum class EUSCI_B2_UCBXIFG_UCRXIFG1 : uint16_t {
    UCRXIFG1_0 = 0x0,
    UCRXIFG1_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 1
/// Register: UCBxIFG
/// Field: UCTXIFG1 [9:9]
enum class EUSCI_B2_UCBXIFG_UCTXIFG1 : uint16_t {
    UCTXIFG1_0 = 0x0,
    UCTXIFG1_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 2
/// Register: UCBxIFG
/// Field: UCRXIFG2 [10:10]
enum class EUSCI_B2_UCBXIFG_UCRXIFG2 : uint16_t {
    UCRXIFG2_0 = 0x0,
    UCRXIFG2_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 2
/// Register: UCBxIFG
/// Field: UCTXIFG2 [11:11]
enum class EUSCI_B2_UCBXIFG_UCTXIFG2 : uint16_t {
    UCTXIFG2_0 = 0x0,
    UCTXIFG2_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 3
/// Register: UCBxIFG
/// Field: UCRXIFG3 [12:12]
enum class EUSCI_B2_UCBXIFG_UCRXIFG3 : uint16_t {
    UCRXIFG3_0 = 0x0,
    UCRXIFG3_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 3
/// Register: UCBxIFG
/// Field: UCTXIFG3 [13:13]
enum class EUSCI_B2_UCBXIFG_UCTXIFG3 : uint16_t {
    UCTXIFG3_0 = 0x0,
    UCTXIFG3_1 = 0x1,
};

/// Bit position 9 interrupt flag
/// Register: UCBxIFG
/// Field: UCBIT9IFG [14:14]
enum class EUSCI_B2_UCBXIFG_UCBIT9IFG : uint16_t {
    UCBIT9IFG_0 = 0x0,
    UCBIT9IFG_1 = 0x1,
};

/// eUSCI_B interrupt vector value
/// Register: UCBxIV
/// Field: UCIV [0:15]
enum class EUSCI_B2_UCBXIV_UCIV : uint16_t {
    UCIV_0 = 0x0,
    UCIV_2 = 0x2,
    UCIV_4 = 0x4,
    UCIV_6 = 0x6,
    UCIV_8 = 0x8,
    UCIV_10 = 0xA,
    UCIV_12 = 0xC,
    UCIV_14 = 0xE,
    UCIV_16 = 0x10,
    UCIV_18 = 0x12,
    UCIV_20 = 0x14,
    UCIV_22 = 0x16,
    UCIV_24 = 0x18,
    UCIV_26 = 0x1A,
    UCIV_28 = 0x1C,
    UCIV_30 = 0x1E,
};

// ----------------------------------------------------------------------------
// EUSCI_B3 - EUSCI_B3
// ----------------------------------------------------------------------------

/// Software reset enable
/// Register: UCBxCTLW0
/// Field: UCSWRST [0:0]
enum class EUSCI_B3_UCBXCTLW0_UCSWRST : uint16_t {
    UCSWRST_0 = 0x0,
    UCSWRST_1 = 0x1,
};

/// Transmit START condition in master mode
/// Register: UCBxCTLW0
/// Field: UCTXSTT [1:1]
enum class EUSCI_B3_UCBXCTLW0_UCTXSTT : uint16_t {
    UCTXSTT_0 = 0x0,
    UCTXSTT_1 = 0x1,
};

/// Transmit STOP condition in master mode
/// Register: UCBxCTLW0
/// Field: UCTXSTP [2:2]
enum class EUSCI_B3_UCBXCTLW0_UCTXSTP : uint16_t {
    UCTXSTP_0 = 0x0,
    UCTXSTP_1 = 0x1,
};

/// Transmit a NACK
/// Register: UCBxCTLW0
/// Field: UCTXNACK [3:3]
enum class EUSCI_B3_UCBXCTLW0_UCTXNACK : uint16_t {
    UCTXNACK_0 = 0x0,
    UCTXNACK_1 = 0x1,
};

/// Transmitter/receiver
/// Register: UCBxCTLW0
/// Field: UCTR [4:4]
enum class EUSCI_B3_UCBXCTLW0_UCTR : uint16_t {
    UCTR_0 = 0x0,
    UCTR_1 = 0x1,
};

/// Transmit ACK condition in slave mode
/// Register: UCBxCTLW0
/// Field: UCTXACK [5:5]
enum class EUSCI_B3_UCBXCTLW0_UCTXACK : uint16_t {
    UCTXACK_0 = 0x0,
    UCTXACK_1 = 0x1,
};

/// eUSCI_B clock source select
/// Register: UCBxCTLW0
/// Field: UCSSEL [6:7]
enum class EUSCI_B3_UCBXCTLW0_UCSSEL : uint16_t {
    UCSSEL_0 = 0x0,
    UCSSEL_1 = 0x1,
    UCSSEL_2 = 0x2,
    UCSSEL_3 = 0x3,
};

/// Synchronous mode enable
/// Register: UCBxCTLW0
/// Field: UCSYNC [8:8]
enum class EUSCI_B3_UCBXCTLW0_UCSYNC : uint16_t {
    UCSYNC_0 = 0x0,
    UCSYNC_1 = 0x1,
};

/// eUSCI_B mode
/// Register: UCBxCTLW0
/// Field: UCMODE [9:10]
enum class EUSCI_B3_UCBXCTLW0_UCMODE : uint16_t {
    UCMODE_0 = 0x0,
    UCMODE_1 = 0x1,
    UCMODE_2 = 0x2,
    UCMODE_3 = 0x3,
};

/// Master mode select
/// Register: UCBxCTLW0
/// Field: UCMST [11:11]
enum class EUSCI_B3_UCBXCTLW0_UCMST : uint16_t {
    UCMST_0 = 0x0,
    UCMST_1 = 0x1,
};

/// Multi-master environment select
/// Register: UCBxCTLW0
/// Field: UCMM [13:13]
enum class EUSCI_B3_UCBXCTLW0_UCMM : uint16_t {
    UCMM_0 = 0x0,
    UCMM_1 = 0x1,
};

/// Slave addressing mode select
/// Register: UCBxCTLW0
/// Field: UCSLA10 [14:14]
enum class EUSCI_B3_UCBXCTLW0_UCSLA10 : uint16_t {
    UCSLA10_0 = 0x0,
    UCSLA10_1 = 0x1,
};

/// Own addressing mode select
/// Register: UCBxCTLW0
/// Field: UCA10 [15:15]
enum class EUSCI_B3_UCBXCTLW0_UCA10 : uint16_t {
    UCA10_0 = 0x0,
    UCA10_1 = 0x1,
};

/// Deglitch time
/// Register: UCBxCTLW1
/// Field: UCGLIT [0:1]
enum class EUSCI_B3_UCBXCTLW1_UCGLIT : uint16_t {
    UCGLIT_0 = 0x0,
    UCGLIT_1 = 0x1,
    UCGLIT_2 = 0x2,
    UCGLIT_3 = 0x3,
};

/// Automatic STOP condition generation
/// Register: UCBxCTLW1
/// Field: UCASTP [2:3]
enum class EUSCI_B3_UCBXCTLW1_UCASTP : uint16_t {
    UCASTP_0 = 0x0,
    UCASTP_1 = 0x1,
    UCASTP_2 = 0x2,
};

/// SW or HW ACK control
/// Register: UCBxCTLW1
/// Field: UCSWACK [4:4]
enum class EUSCI_B3_UCBXCTLW1_UCSWACK : uint16_t {
    UCSWACK_0 = 0x0,
    UCSWACK_1 = 0x1,
};

/// ACK all master bytes
/// Register: UCBxCTLW1
/// Field: UCSTPNACK [5:5]
enum class EUSCI_B3_UCBXCTLW1_UCSTPNACK : uint16_t {
    UCSTPNACK_0 = 0x0,
    UCSTPNACK_1 = 0x1,
};

/// Clock low timeout select
/// Register: UCBxCTLW1
/// Field: UCCLTO [6:7]
enum class EUSCI_B3_UCBXCTLW1_UCCLTO : uint16_t {
    UCCLTO_0 = 0x0,
    UCCLTO_1 = 0x1,
    UCCLTO_2 = 0x2,
    UCCLTO_3 = 0x3,
};

/// Early UCTXIFG0
/// Register: UCBxCTLW1
/// Field: UCETXINT [8:8]
enum class EUSCI_B3_UCBXCTLW1_UCETXINT : uint16_t {
    UCETXINT_0 = 0x0,
    UCETXINT_1 = 0x1,
};

/// Bus busy
/// Register: UCBxSTATW
/// Field: UCBBUSY [4:4]
enum class EUSCI_B3_UCBXSTATW_UCBBUSY : uint16_t {
    UCBBUSY_0 = 0x0,
    UCBBUSY_1 = 0x1,
};

/// General call address received
/// Register: UCBxSTATW
/// Field: UCGC [5:5]
enum class EUSCI_B3_UCBXSTATW_UCGC : uint16_t {
    UCGC_0 = 0x0,
    UCGC_1 = 0x1,
};

/// SCL low
/// Register: UCBxSTATW
/// Field: UCSCLLOW [6:6]
enum class EUSCI_B3_UCBXSTATW_UCSCLLOW : uint16_t {
    UCSCLLOW_0 = 0x0,
    UCSCLLOW_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA0
/// Field: UCOAEN [10:10]
enum class EUSCI_B3_UCBXI2COA0_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// General call response enable
/// Register: UCBxI2COA0
/// Field: UCGCEN [15:15]
enum class EUSCI_B3_UCBXI2COA0_UCGCEN : uint16_t {
    UCGCEN_0 = 0x0,
    UCGCEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA1
/// Field: UCOAEN [10:10]
enum class EUSCI_B3_UCBXI2COA1_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA2
/// Field: UCOAEN [10:10]
enum class EUSCI_B3_UCBXI2COA2_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Own Address enable register
/// Register: UCBxI2COA3
/// Field: UCOAEN [10:10]
enum class EUSCI_B3_UCBXI2COA3_UCOAEN : uint16_t {
    UCOAEN_0 = 0x0,
    UCOAEN_1 = 0x1,
};

/// Receive interrupt enable 0
/// Register: UCBxIE
/// Field: UCRXIE0 [0:0]
enum class EUSCI_B3_UCBXIE_UCRXIE0 : uint16_t {
    UCRXIE0_0 = 0x0,
    UCRXIE0_1 = 0x1,
};

/// Transmit interrupt enable 0
/// Register: UCBxIE
/// Field: UCTXIE0 [1:1]
enum class EUSCI_B3_UCBXIE_UCTXIE0 : uint16_t {
    UCTXIE0_0 = 0x0,
    UCTXIE0_1 = 0x1,
};

/// START condition interrupt enable
/// Register: UCBxIE
/// Field: UCSTTIE [2:2]
enum class EUSCI_B3_UCBXIE_UCSTTIE : uint16_t {
    UCSTTIE_0 = 0x0,
    UCSTTIE_1 = 0x1,
};

/// STOP condition interrupt enable
/// Register: UCBxIE
/// Field: UCSTPIE [3:3]
enum class EUSCI_B3_UCBXIE_UCSTPIE : uint16_t {
    UCSTPIE_0 = 0x0,
    UCSTPIE_1 = 0x1,
};

/// Arbitration lost interrupt enable
/// Register: UCBxIE
/// Field: UCALIE [4:4]
enum class EUSCI_B3_UCBXIE_UCALIE : uint16_t {
    UCALIE_0 = 0x0,
    UCALIE_1 = 0x1,
};

/// Not-acknowledge interrupt enable
/// Register: UCBxIE
/// Field: UCNACKIE [5:5]
enum class EUSCI_B3_UCBXIE_UCNACKIE : uint16_t {
    UCNACKIE_0 = 0x0,
    UCNACKIE_1 = 0x1,
};

/// Byte counter interrupt enable
/// Register: UCBxIE
/// Field: UCBCNTIE [6:6]
enum class EUSCI_B3_UCBXIE_UCBCNTIE : uint16_t {
    UCBCNTIE_0 = 0x0,
    UCBCNTIE_1 = 0x1,
};

/// Clock low timeout interrupt enable
/// Register: UCBxIE
/// Field: UCCLTOIE [7:7]
enum class EUSCI_B3_UCBXIE_UCCLTOIE : uint16_t {
    UCCLTOIE_0 = 0x0,
    UCCLTOIE_1 = 0x1,
};

/// Receive interrupt enable 1
/// Register: UCBxIE
/// Field: UCRXIE1 [8:8]
enum class EUSCI_B3_UCBXIE_UCRXIE1 : uint16_t {
    UCRXIE1_0 = 0x0,
    UCRXIE1_1 = 0x1,
};

/// Transmit interrupt enable 1
/// Register: UCBxIE
/// Field: UCTXIE1 [9:9]
enum class EUSCI_B3_UCBXIE_UCTXIE1 : uint16_t {
    UCTXIE1_0 = 0x0,
    UCTXIE1_1 = 0x1,
};

/// Receive interrupt enable 2
/// Register: UCBxIE
/// Field: UCRXIE2 [10:10]
enum class EUSCI_B3_UCBXIE_UCRXIE2 : uint16_t {
    UCRXIE2_0 = 0x0,
    UCRXIE2_1 = 0x1,
};

/// Transmit interrupt enable 2
/// Register: UCBxIE
/// Field: UCTXIE2 [11:11]
enum class EUSCI_B3_UCBXIE_UCTXIE2 : uint16_t {
    UCTXIE2_0 = 0x0,
    UCTXIE2_1 = 0x1,
};

/// Receive interrupt enable 3
/// Register: UCBxIE
/// Field: UCRXIE3 [12:12]
enum class EUSCI_B3_UCBXIE_UCRXIE3 : uint16_t {
    UCRXIE3_0 = 0x0,
    UCRXIE3_1 = 0x1,
};

/// Transmit interrupt enable 3
/// Register: UCBxIE
/// Field: UCTXIE3 [13:13]
enum class EUSCI_B3_UCBXIE_UCTXIE3 : uint16_t {
    UCTXIE3_0 = 0x0,
    UCTXIE3_1 = 0x1,
};

/// Bit position 9 interrupt enable
/// Register: UCBxIE
/// Field: UCBIT9IE [14:14]
enum class EUSCI_B3_UCBXIE_UCBIT9IE : uint16_t {
    UCBIT9IE_0 = 0x0,
    UCBIT9IE_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 0
/// Register: UCBxIFG
/// Field: UCRXIFG0 [0:0]
enum class EUSCI_B3_UCBXIFG_UCRXIFG0 : uint16_t {
    UCRXIFG0_0 = 0x0,
    UCRXIFG0_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 0
/// Register: UCBxIFG
/// Field: UCTXIFG0 [1:1]
enum class EUSCI_B3_UCBXIFG_UCTXIFG0 : uint16_t {
    UCTXIFG0_0 = 0x0,
    UCTXIFG0_1 = 0x1,
};

/// START condition interrupt flag
/// Register: UCBxIFG
/// Field: UCSTTIFG [2:2]
enum class EUSCI_B3_UCBXIFG_UCSTTIFG : uint16_t {
    UCSTTIFG_0 = 0x0,
    UCSTTIFG_1 = 0x1,
};

/// STOP condition interrupt flag
/// Register: UCBxIFG
/// Field: UCSTPIFG [3:3]
enum class EUSCI_B3_UCBXIFG_UCSTPIFG : uint16_t {
    UCSTPIFG_0 = 0x0,
    UCSTPIFG_1 = 0x1,
};

/// Arbitration lost interrupt flag
/// Register: UCBxIFG
/// Field: UCALIFG [4:4]
enum class EUSCI_B3_UCBXIFG_UCALIFG : uint16_t {
    UCALIFG_0 = 0x0,
    UCALIFG_1 = 0x1,
};

/// Not-acknowledge received interrupt flag
/// Register: UCBxIFG
/// Field: UCNACKIFG [5:5]
enum class EUSCI_B3_UCBXIFG_UCNACKIFG : uint16_t {
    UCNACKIFG_0 = 0x0,
    UCNACKIFG_1 = 0x1,
};

/// Byte counter interrupt flag
/// Register: UCBxIFG
/// Field: UCBCNTIFG [6:6]
enum class EUSCI_B3_UCBXIFG_UCBCNTIFG : uint16_t {
    UCBCNTIFG_0 = 0x0,
    UCBCNTIFG_1 = 0x1,
};

/// Clock low timeout interrupt flag
/// Register: UCBxIFG
/// Field: UCCLTOIFG [7:7]
enum class EUSCI_B3_UCBXIFG_UCCLTOIFG : uint16_t {
    UCCLTOIFG_0 = 0x0,
    UCCLTOIFG_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 1
/// Register: UCBxIFG
/// Field: UCRXIFG1 [8:8]
enum class EUSCI_B3_UCBXIFG_UCRXIFG1 : uint16_t {
    UCRXIFG1_0 = 0x0,
    UCRXIFG1_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 1
/// Register: UCBxIFG
/// Field: UCTXIFG1 [9:9]
enum class EUSCI_B3_UCBXIFG_UCTXIFG1 : uint16_t {
    UCTXIFG1_0 = 0x0,
    UCTXIFG1_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 2
/// Register: UCBxIFG
/// Field: UCRXIFG2 [10:10]
enum class EUSCI_B3_UCBXIFG_UCRXIFG2 : uint16_t {
    UCRXIFG2_0 = 0x0,
    UCRXIFG2_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 2
/// Register: UCBxIFG
/// Field: UCTXIFG2 [11:11]
enum class EUSCI_B3_UCBXIFG_UCTXIFG2 : uint16_t {
    UCTXIFG2_0 = 0x0,
    UCTXIFG2_1 = 0x1,
};

/// eUSCI_B receive interrupt flag 3
/// Register: UCBxIFG
/// Field: UCRXIFG3 [12:12]
enum class EUSCI_B3_UCBXIFG_UCRXIFG3 : uint16_t {
    UCRXIFG3_0 = 0x0,
    UCRXIFG3_1 = 0x1,
};

/// eUSCI_B transmit interrupt flag 3
/// Register: UCBxIFG
/// Field: UCTXIFG3 [13:13]
enum class EUSCI_B3_UCBXIFG_UCTXIFG3 : uint16_t {
    UCTXIFG3_0 = 0x0,
    UCTXIFG3_1 = 0x1,
};

/// Bit position 9 interrupt flag
/// Register: UCBxIFG
/// Field: UCBIT9IFG [14:14]
enum class EUSCI_B3_UCBXIFG_UCBIT9IFG : uint16_t {
    UCBIT9IFG_0 = 0x0,
    UCBIT9IFG_1 = 0x1,
};

/// eUSCI_B interrupt vector value
/// Register: UCBxIV
/// Field: UCIV [0:15]
enum class EUSCI_B3_UCBXIV_UCIV : uint16_t {
    UCIV_0 = 0x0,
    UCIV_2 = 0x2,
    UCIV_4 = 0x4,
    UCIV_6 = 0x6,
    UCIV_8 = 0x8,
    UCIV_10 = 0xA,
    UCIV_12 = 0xC,
    UCIV_14 = 0xE,
    UCIV_16 = 0x10,
    UCIV_18 = 0x12,
    UCIV_20 = 0x14,
    UCIV_22 = 0x16,
    UCIV_24 = 0x18,
    UCIV_26 = 0x1A,
    UCIV_28 = 0x1C,
    UCIV_30 = 0x1E,
};

// ----------------------------------------------------------------------------
// FLCTL_A - FLCTL_A
// ----------------------------------------------------------------------------

/// Flash power status
/// Register: FLCTL_POWER_STAT
/// Field: PSTAT [0:2]
enum class FLCTL_A_FLCTL_POWER_STAT_PSTAT : uint32_t {
    PSTAT_0 = 0x0,
    PSTAT_1 = 0x1,
    PSTAT_2 = 0x2,
    PSTAT_3 = 0x3,
    PSTAT_4 = 0x4,
    PSTAT_5 = 0x5,
    PSTAT_6 = 0x6,
    PSTAT_7 = 0x7,
};

/// PSS FLDO GOOD status
/// Register: FLCTL_POWER_STAT
/// Field: LDOSTAT [3:3]
enum class FLCTL_A_FLCTL_POWER_STAT_LDOSTAT : uint32_t {
    LDOSTAT_0 = 0x0,
    LDOSTAT_1 = 0x1,
};

/// PSS VREF stable status
/// Register: FLCTL_POWER_STAT
/// Field: VREFSTAT [4:4]
enum class FLCTL_A_FLCTL_POWER_STAT_VREFSTAT : uint32_t {
    VREFSTAT_0 = 0x0,
    VREFSTAT_1 = 0x1,
};

/// PSS IREF stable status
/// Register: FLCTL_POWER_STAT
/// Field: IREFSTAT [5:5]
enum class FLCTL_A_FLCTL_POWER_STAT_IREFSTAT : uint32_t {
    IREFSTAT_0 = 0x0,
    IREFSTAT_1 = 0x1,
};

/// PSS trim done status
/// Register: FLCTL_POWER_STAT
/// Field: TRIMSTAT [6:6]
enum class FLCTL_A_FLCTL_POWER_STAT_TRIMSTAT : uint32_t {
    TRIMSTAT_0 = 0x0,
    TRIMSTAT_1 = 0x1,
};

/// Indicates if Flash is being accessed in 2T mode
/// Register: FLCTL_POWER_STAT
/// Field: RD_2T [7:7]
enum class FLCTL_A_FLCTL_POWER_STAT_RD_2T : uint32_t {
    RD_2T_0 = 0x0,
    RD_2T_1 = 0x1,
};

/// Flash read mode control setting for Bank 0
/// Register: FLCTL_BANK0_RDCTL
/// Field: RD_MODE [0:3]
enum class FLCTL_A_FLCTL_BANK0_RDCTL_RD_MODE : uint32_t {
    RD_MODE_0 = 0x0,
    RD_MODE_1 = 0x1,
    RD_MODE_2 = 0x2,
    RD_MODE_3 = 0x3,
    RD_MODE_4 = 0x4,
    RD_MODE_5 = 0x5,
    RD_MODE_9 = 0x9,
    RD_MODE_10 = 0xA,
};

/// Number of wait states for read
/// Register: FLCTL_BANK0_RDCTL
/// Field: WAIT [12:15]
enum class FLCTL_A_FLCTL_BANK0_RDCTL_WAIT : uint32_t {
    WAIT_0 = 0x0,
    WAIT_1 = 0x1,
    WAIT_2 = 0x2,
    WAIT_3 = 0x3,
    WAIT_4 = 0x4,
    WAIT_5 = 0x5,
    WAIT_6 = 0x6,
    WAIT_7 = 0x7,
    WAIT_8 = 0x8,
    WAIT_9 = 0x9,
    WAIT_10 = 0xA,
    WAIT_11 = 0xB,
    WAIT_12 = 0xC,
    WAIT_13 = 0xD,
    WAIT_14 = 0xE,
    WAIT_15 = 0xF,
};

/// Read mode
/// Register: FLCTL_BANK0_RDCTL
/// Field: RD_MODE_STATUS [16:19]
enum class FLCTL_A_FLCTL_BANK0_RDCTL_RD_MODE_STATUS : uint32_t {
    RD_MODE_STATUS_0 = 0x0,
    RD_MODE_STATUS_1 = 0x1,
    RD_MODE_STATUS_2 = 0x2,
    RD_MODE_STATUS_3 = 0x3,
    RD_MODE_STATUS_4 = 0x4,
    RD_MODE_STATUS_5 = 0x5,
    RD_MODE_STATUS_9 = 0x9,
    RD_MODE_STATUS_10 = 0xA,
};

/// Flash read mode control setting for Bank 0
/// Register: FLCTL_BANK1_RDCTL
/// Field: RD_MODE [0:3]
enum class FLCTL_A_FLCTL_BANK1_RDCTL_RD_MODE : uint32_t {
    RD_MODE_0 = 0x0,
    RD_MODE_1 = 0x1,
    RD_MODE_2 = 0x2,
    RD_MODE_3 = 0x3,
    RD_MODE_4 = 0x4,
    RD_MODE_5 = 0x5,
    RD_MODE_9 = 0x9,
    RD_MODE_10 = 0xA,
};

/// Read mode
/// Register: FLCTL_BANK1_RDCTL
/// Field: RD_MODE_STATUS [16:19]
enum class FLCTL_A_FLCTL_BANK1_RDCTL_RD_MODE_STATUS : uint32_t {
    RD_MODE_STATUS_0 = 0x0,
    RD_MODE_STATUS_1 = 0x1,
    RD_MODE_STATUS_2 = 0x2,
    RD_MODE_STATUS_3 = 0x3,
    RD_MODE_STATUS_4 = 0x4,
    RD_MODE_STATUS_5 = 0x5,
    RD_MODE_STATUS_9 = 0x9,
    RD_MODE_STATUS_10 = 0xA,
};

/// Number of wait states for read
/// Register: FLCTL_BANK1_RDCTL
/// Field: WAIT [12:15]
enum class FLCTL_A_FLCTL_BANK1_RDCTL_WAIT : uint32_t {
    WAIT_0 = 0x0,
    WAIT_1 = 0x1,
    WAIT_2 = 0x2,
    WAIT_3 = 0x3,
    WAIT_4 = 0x4,
    WAIT_5 = 0x5,
    WAIT_6 = 0x6,
    WAIT_7 = 0x7,
    WAIT_8 = 0x8,
    WAIT_9 = 0x9,
    WAIT_10 = 0xA,
    WAIT_11 = 0xB,
    WAIT_12 = 0xC,
    WAIT_13 = 0xD,
    WAIT_14 = 0xE,
    WAIT_15 = 0xF,
};

/// Type of memory that burst is carried out on
/// Register: FLCTL_RDBRST_CTLSTAT
/// Field: MEM_TYPE [1:2]
enum class FLCTL_A_FLCTL_RDBRST_CTLSTAT_MEM_TYPE : uint32_t {
    MEM_TYPE_0 = 0x0,
    MEM_TYPE_1 = 0x1,
    MEM_TYPE_3 = 0x3,
};

/// Data pattern used for comparison against memory read data
/// Register: FLCTL_RDBRST_CTLSTAT
/// Field: DATA_CMP [4:4]
enum class FLCTL_A_FLCTL_RDBRST_CTLSTAT_DATA_CMP : uint32_t {
    DATA_CMP_0 = 0x0,
    DATA_CMP_1 = 0x1,
};

/// Status of Burst/Compare operation
/// Register: FLCTL_RDBRST_CTLSTAT
/// Field: BRST_STAT [16:17]
enum class FLCTL_A_FLCTL_RDBRST_CTLSTAT_BRST_STAT : uint32_t {
    BRST_STAT_0 = 0x0,
    BRST_STAT_1 = 0x1,
    BRST_STAT_2 = 0x2,
    BRST_STAT_3 = 0x3,
};

/// Master control for all word program operations
/// Register: FLCTL_PRG_CTLSTAT
/// Field: ENABLE [0:0]
enum class FLCTL_A_FLCTL_PRG_CTLSTAT_ENABLE : uint32_t {
    ENABLE_0 = 0x0,
    ENABLE_1 = 0x1,
};

/// Write mode
/// Register: FLCTL_PRG_CTLSTAT
/// Field: MODE [1:1]
enum class FLCTL_A_FLCTL_PRG_CTLSTAT_MODE : uint32_t {
    MODE_0 = 0x0,
    MODE_1 = 0x1,
};

/// Controls automatic pre program verify operations
/// Register: FLCTL_PRG_CTLSTAT
/// Field: VER_PRE [2:2]
enum class FLCTL_A_FLCTL_PRG_CTLSTAT_VER_PRE : uint32_t {
    VER_PRE_0 = 0x0,
    VER_PRE_1 = 0x1,
};

/// Controls automatic post program verify operations
/// Register: FLCTL_PRG_CTLSTAT
/// Field: VER_PST [3:3]
enum class FLCTL_A_FLCTL_PRG_CTLSTAT_VER_PST : uint32_t {
    VER_PST_0 = 0x0,
    VER_PST_1 = 0x1,
};

/// Status of program operations in the Flash memory
/// Register: FLCTL_PRG_CTLSTAT
/// Field: STATUS [16:17]
enum class FLCTL_A_FLCTL_PRG_CTLSTAT_STATUS : uint32_t {
    STATUS_0 = 0x0,
    STATUS_1 = 0x1,
    STATUS_2 = 0x2,
};

/// Bank active
/// Register: FLCTL_PRG_CTLSTAT
/// Field: BNK_ACT [18:18]
enum class FLCTL_A_FLCTL_PRG_CTLSTAT_BNK_ACT : uint32_t {
    BNK_ACT_0 = 0x0,
    BNK_ACT_1 = 0x1,
};

/// Type of memory that burst program is carried out on
/// Register: FLCTL_PRGBRST_CTLSTAT
/// Field: TYPE [1:2]
enum class FLCTL_A_FLCTL_PRGBRST_CTLSTAT_TYPE : uint32_t {
    TYPE_0 = 0x0,
    TYPE_1 = 0x1,
    TYPE_3 = 0x3,
};

/// Length of burst
/// Register: FLCTL_PRGBRST_CTLSTAT
/// Field: LEN [3:5]
enum class FLCTL_A_FLCTL_PRGBRST_CTLSTAT_LEN : uint32_t {
    LEN_0 = 0x0,
    LEN_1 = 0x1,
    LEN_2 = 0x2,
    LEN_3 = 0x3,
    LEN_4 = 0x4,
};

/// Auto-Verify operation before the Burst Program
/// Register: FLCTL_PRGBRST_CTLSTAT
/// Field: AUTO_PRE [6:6]
enum class FLCTL_A_FLCTL_PRGBRST_CTLSTAT_AUTO_PRE : uint32_t {
    AUTO_PRE_0 = 0x0,
    AUTO_PRE_1 = 0x1,
};

/// Auto-Verify operation after the Burst Program
/// Register: FLCTL_PRGBRST_CTLSTAT
/// Field: AUTO_PST [7:7]
enum class FLCTL_A_FLCTL_PRGBRST_CTLSTAT_AUTO_PST : uint32_t {
    AUTO_PST_0 = 0x0,
    AUTO_PST_1 = 0x1,
};

/// Status of a Burst Operation
/// Register: FLCTL_PRGBRST_CTLSTAT
/// Field: BURST_STATUS [16:18]
enum class FLCTL_A_FLCTL_PRGBRST_CTLSTAT_BURST_STATUS : uint32_t {
    BURST_STATUS_0 = 0x0,
    BURST_STATUS_1 = 0x1,
    BURST_STATUS_2 = 0x2,
    BURST_STATUS_3 = 0x3,
    BURST_STATUS_4 = 0x4,
    BURST_STATUS_5 = 0x5,
    BURST_STATUS_7 = 0x7,
};

/// Erase mode selected by application
/// Register: FLCTL_ERASE_CTLSTAT
/// Field: MODE [1:1]
enum class FLCTL_A_FLCTL_ERASE_CTLSTAT_MODE : uint32_t {
    MODE_0 = 0x0,
    MODE_1 = 0x1,
};

/// Type of memory that erase operation is carried out on
/// Register: FLCTL_ERASE_CTLSTAT
/// Field: TYPE [2:3]
enum class FLCTL_A_FLCTL_ERASE_CTLSTAT_TYPE : uint32_t {
    TYPE_0 = 0x0,
    TYPE_1 = 0x1,
    TYPE_3 = 0x3,
};

/// Status of erase operations in the Flash memory
/// Register: FLCTL_ERASE_CTLSTAT
/// Field: STATUS [16:17]
enum class FLCTL_A_FLCTL_ERASE_CTLSTAT_STATUS : uint32_t {
    STATUS_0 = 0x0,
    STATUS_1 = 0x1,
    STATUS_2 = 0x2,
    STATUS_3 = 0x3,
};

/// Selects which benchmark register should be compared against the threshold
/// Register: FLCTL_BMRK_CTLSTAT
/// Field: CMP_SEL [3:3]
enum class FLCTL_A_FLCTL_BMRK_CTLSTAT_CMP_SEL : uint32_t {
    en_1_0x0 = 0x0,
    en_2_0x1 = 0x1,
};

// ----------------------------------------------------------------------------
// FPB - FPB
// ----------------------------------------------------------------------------

/// Flash patch unit enable bit
/// Register: FP_CTRL
/// Field: ENABLE [0:0]
enum class FPB_FP_CTRL_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Number of code slots field.
/// Register: FP_CTRL
/// Field: NUM_CODE1 [4:7]
enum class FPB_FP_CTRL_NUM_CODE1 : uint32_t {
    en_0b0000 = 0x0,
    en_0b0010 = 0x2,
    en_0b0110 = 0x6,
};

/// Number of literal slots field.
/// Register: FP_CTRL
/// Field: NUM_LIT [8:11]
enum class FPB_FP_CTRL_NUM_LIT : uint32_t {
    en_0b0000 = 0x0,
    en_0b0010 = 0x2,
};

/// Compare and remap enable for Flash Patch Comparator Register 0. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
/// Register: FP_COMP0
/// Field: ENABLE [0:0]
enum class FPB_FP_COMP0_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
/// Register: FP_COMP0
/// Field: REPLACE [30:31]
enum class FPB_FP_COMP0_REPLACE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Compare and remap enable for Flash Patch Comparator Register 1. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
/// Register: FP_COMP1
/// Field: ENABLE [0:0]
enum class FPB_FP_COMP1_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
/// Register: FP_COMP1
/// Field: REPLACE [30:31]
enum class FPB_FP_COMP1_REPLACE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Compare and remap enable for Flash Patch Comparator Register 2. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
/// Register: FP_COMP2
/// Field: ENABLE [0:0]
enum class FPB_FP_COMP2_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
/// Register: FP_COMP2
/// Field: REPLACE [30:31]
enum class FPB_FP_COMP2_REPLACE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Compare and remap enable for Flash Patch Comparator Register 3. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
/// Register: FP_COMP3
/// Field: ENABLE [0:0]
enum class FPB_FP_COMP3_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
/// Register: FP_COMP3
/// Field: REPLACE [30:31]
enum class FPB_FP_COMP3_REPLACE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Compare and remap enable for Flash Patch Comparator Register 4. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
/// Register: FP_COMP4
/// Field: ENABLE [0:0]
enum class FPB_FP_COMP4_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
/// Register: FP_COMP4
/// Field: REPLACE [30:31]
enum class FPB_FP_COMP4_REPLACE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Compare and remap enable for Flash Patch Comparator Register 5. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
/// Register: FP_COMP5
/// Field: ENABLE [0:0]
enum class FPB_FP_COMP5_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
/// Register: FP_COMP5
/// Field: REPLACE [30:31]
enum class FPB_FP_COMP5_REPLACE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Compare and remap enable for Flash Patch Comparator Register 6. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
/// Register: FP_COMP6
/// Field: ENABLE [0:0]
enum class FPB_FP_COMP6_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
/// Register: FP_COMP6
/// Field: REPLACE [30:31]
enum class FPB_FP_COMP6_REPLACE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// Compare and remap enable for Flash Patch Comparator Register 7. The ENABLE bit of FP_CTRL must also be set to enable comparisons. Reset clears the ENABLE bit.
/// Register: FP_COMP7
/// Field: ENABLE [0:0]
enum class FPB_FP_COMP7_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// This selects what happens when the COMP address is matched. Settings other than b00 are only valid for instruction comparators. Literal comparators ignore non-b00 settings. Address remapping only takes place for the b00 setting.
/// Register: FP_COMP7
/// Field: REPLACE [30:31]
enum class FPB_FP_COMP7_REPLACE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

// ----------------------------------------------------------------------------
// ITM - ITM
// ----------------------------------------------------------------------------

/// TSPrescale Timestamp prescaler.
/// Register: ITM_TCR
/// Field: TSPRESCALE [8:9]
enum class ITM_ITM_TCR_TSPRESCALE : uint32_t {
    en_0b00 = 0x0,
    en_0b01 = 0x1,
    en_0b10 = 0x2,
    en_0b11 = 0x3,
};

/// When the integration mode is set: 0 = ATVALIDM clear. 1 = ATVALIDM set.
/// Register: ITM_IWR
/// Field: ATVALIDM [0:0]
enum class ITM_ITM_IWR_ATVALIDM : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// INTEGRATION
/// Register: ITM_IMCR
/// Field: INTEGRATION [0:0]
enum class ITM_ITM_IMCR_INTEGRATION : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

// ----------------------------------------------------------------------------
// LCD_F - LCD_F
// ----------------------------------------------------------------------------

/// LCD on
/// Register: LCDCTL
/// Field: LCDON [0:0]
enum class LCD_F_LCDCTL_LCDON : uint32_t {
    LCDON_0 = 0x0,
    LCDON_1 = 0x1,
};

/// LCD Low-power Waveform
/// Register: LCDCTL
/// Field: LCDLP [1:1]
enum class LCD_F_LCDCTL_LCDLP : uint32_t {
    LCDLP_0 = 0x0,
    LCDLP_1 = 0x1,
};

/// LCD segments on
/// Register: LCDCTL
/// Field: LCDSON [2:2]
enum class LCD_F_LCDCTL_LCDSON : uint32_t {
    LCDSON_0 = 0x0,
    LCDSON_1 = 0x1,
};

/// LCD mux rate
/// Register: LCDCTL
/// Field: LCDMXx [3:5]
enum class LCD_F_LCDCTL_LCDMXX : uint32_t {
    LCDMXx_0 = 0x0,
    LCDMXx_1 = 0x1,
    LCDMXx_2 = 0x2,
    LCDMXx_3 = 0x3,
    LCDMXx_4 = 0x4,
    LCDMXx_5 = 0x5,
    LCDMXx_6 = 0x6,
    LCDMXx_7 = 0x7,
};

/// LCD frequency pre-scaler
/// Register: LCDCTL
/// Field: LCDPREx [8:10]
enum class LCD_F_LCDCTL_LCDPREX : uint32_t {
    LCDPREx_0 = 0x0,
    LCDPREx_1 = 0x1,
    LCDPREx_2 = 0x2,
    LCDPREx_3 = 0x3,
    LCDPREx_4 = 0x4,
    LCDPREx_5 = 0x5,
};

/// LCD frequency divider
/// Register: LCDCTL
/// Field: LCDDIVx [11:15]
enum class LCD_F_LCDCTL_LCDDIVX : uint32_t {
    LCDDIVx_0 = 0x0,
    LCDDIVx_1 = 0x1,
    LCDDIVx_2 = 0x2,
    LCDDIVx_3 = 0x3,
    LCDDIVx_4 = 0x4,
    LCDDIVx_5 = 0x5,
    LCDDIVx_6 = 0x6,
    LCDDIVx_7 = 0x7,
    LCDDIVx_8 = 0x8,
    LCDDIVx_9 = 0x9,
    LCDDIVx_10 = 0xA,
    LCDDIVx_11 = 0xB,
    LCDDIVx_12 = 0xC,
    LCDDIVx_13 = 0xD,
    LCDDIVx_14 = 0xE,
    LCDDIVx_15 = 0xF,
    LCDDIVx_16 = 0x10,
    LCDDIVx_17 = 0x11,
    LCDDIVx_18 = 0x12,
    LCDDIVx_19 = 0x13,
    LCDDIVx_20 = 0x14,
    LCDDIVx_21 = 0x15,
    LCDDIVx_22 = 0x16,
    LCDDIVx_23 = 0x17,
    LCDDIVx_24 = 0x18,
    LCDDIVx_25 = 0x19,
    LCDDIVx_26 = 0x1A,
    LCDDIVx_27 = 0x1B,
    LCDDIVx_28 = 0x1C,
    LCDDIVx_29 = 0x1D,
    LCDDIVx_30 = 0x1E,
    LCDDIVx_31 = 0x1F,
};

/// Clock source select
/// Register: LCDCTL
/// Field: LCDSSEL [16:17]
enum class LCD_F_LCDCTL_LCDSSEL : uint32_t {
    LCDSSEL_0 = 0x0,
    LCDSSEL_1 = 0x1,
    LCDSSEL_2 = 0x2,
    LCDSSEL_3 = 0x3,
};

/// Blinking mode
/// Register: LCDBMCTL
/// Field: LCDBLKMODx [0:1]
enum class LCD_F_LCDBMCTL_LCDBLKMODX : uint32_t {
    LCDBLKMODx_0 = 0x0,
    LCDBLKMODx_1 = 0x1,
    LCDBLKMODx_2 = 0x2,
    LCDBLKMODx_3 = 0x3,
};

/// Clock pre-scaler for blinking frequency
/// Register: LCDBMCTL
/// Field: LCDBLKPREx [2:4]
enum class LCD_F_LCDBMCTL_LCDBLKPREX : uint32_t {
    LCDBLKPREx_0 = 0x0,
    LCDBLKPREx_1 = 0x1,
    LCDBLKPREx_2 = 0x2,
    LCDBLKPREx_3 = 0x3,
    LCDBLKPREx_4 = 0x4,
    LCDBLKPREx_5 = 0x5,
    LCDBLKPREx_6 = 0x6,
    LCDBLKPREx_7 = 0x7,
};

/// Clock divider for blinking frequency
/// Register: LCDBMCTL
/// Field: LCDBLKDIVx [5:7]
enum class LCD_F_LCDBMCTL_LCDBLKDIVX : uint32_t {
    LCDBLKDIVx_0 = 0x0,
    LCDBLKDIVx_1 = 0x1,
    LCDBLKDIVx_2 = 0x2,
    LCDBLKDIVx_3 = 0x3,
    LCDBLKDIVx_4 = 0x4,
    LCDBLKDIVx_5 = 0x5,
    LCDBLKDIVx_6 = 0x6,
    LCDBLKDIVx_7 = 0x7,
};

/// Select LCD memory registers for display
/// Register: LCDBMCTL
/// Field: LCDDISP [16:16]
enum class LCD_F_LCDBMCTL_LCDDISP : uint32_t {
    LCDDISP_0 = 0x0,
    LCDDISP_1 = 0x1,
};

/// Clear LCD memory
/// Register: LCDBMCTL
/// Field: LCDCLRM [17:17]
enum class LCD_F_LCDBMCTL_LCDCLRM : uint32_t {
    LCDCLRM_0 = 0x0,
    LCDCLRM_1 = 0x1,
};

/// Clear LCD blinking memory
/// Register: LCDBMCTL
/// Field: LCDCLRBM [18:18]
enum class LCD_F_LCDBMCTL_LCDCLRBM : uint32_t {
    LCDCLRBM_0 = 0x0,
    LCDCLRBM_1 = 0x1,
};

/// Bias select.
/// Register: LCDVCTL
/// Field: LCD2B [0:0]
enum class LCD_F_LCDVCTL_LCD2B : uint32_t {
    LCD2B_0 = 0x0,
    LCD2B_1 = 0x1,
};

/// V2 to V4 voltage select
/// Register: LCDVCTL
/// Field: LCDEXTBIAS [5:5]
enum class LCD_F_LCDVCTL_LCDEXTBIAS : uint32_t {
    LCDEXTBIAS_0 = 0x0,
    LCDEXTBIAS_1 = 0x1,
};

/// V5 voltage select
/// Register: LCDVCTL
/// Field: R03EXT [6:6]
enum class LCD_F_LCDVCTL_R03EXT : uint32_t {
    R03EXT_0 = 0x0,
    R03EXT_1 = 0x1,
};

/// V2 to V4 voltage on external Rx3 pins
/// Register: LCDVCTL
/// Field: LCDREXT [7:7]
enum class LCD_F_LCDVCTL_LCDREXT : uint32_t {
    LCDREXT_0 = 0x0,
    LCDREXT_1 = 0x1,
};

/// LCD pin 0 enable
/// Register: LCDPCTL0
/// Field: LCDS0 [0:0]
enum class LCD_F_LCDPCTL0_LCDS0 : uint32_t {
    LCDS0_0 = 0x0,
    LCDS0_1 = 0x1,
};

/// LCD pin 1 enable
/// Register: LCDPCTL0
/// Field: LCDS1 [1:1]
enum class LCD_F_LCDPCTL0_LCDS1 : uint32_t {
    LCDS1_0 = 0x0,
    LCDS1_1 = 0x1,
};

/// LCD pin 2 enable
/// Register: LCDPCTL0
/// Field: LCDS2 [2:2]
enum class LCD_F_LCDPCTL0_LCDS2 : uint32_t {
    LCDS2_0 = 0x0,
    LCDS2_1 = 0x1,
};

/// LCD pin 3 enable
/// Register: LCDPCTL0
/// Field: LCDS3 [3:3]
enum class LCD_F_LCDPCTL0_LCDS3 : uint32_t {
    LCDS3_0 = 0x0,
    LCDS3_1 = 0x1,
};

/// LCD pin 4 enable
/// Register: LCDPCTL0
/// Field: LCDS4 [4:4]
enum class LCD_F_LCDPCTL0_LCDS4 : uint32_t {
    LCDS4_0 = 0x0,
    LCDS4_1 = 0x1,
};

/// LCD pin 5 enable
/// Register: LCDPCTL0
/// Field: LCDS5 [5:5]
enum class LCD_F_LCDPCTL0_LCDS5 : uint32_t {
    LCDS5_0 = 0x0,
    LCDS5_1 = 0x1,
};

/// LCD pin 6 enable
/// Register: LCDPCTL0
/// Field: LCDS6 [6:6]
enum class LCD_F_LCDPCTL0_LCDS6 : uint32_t {
    LCDS6_0 = 0x0,
    LCDS6_1 = 0x1,
};

/// LCD pin 7 enable
/// Register: LCDPCTL0
/// Field: LCDS7 [7:7]
enum class LCD_F_LCDPCTL0_LCDS7 : uint32_t {
    LCDS7_0 = 0x0,
    LCDS7_1 = 0x1,
};

/// LCD pin 8 enable
/// Register: LCDPCTL0
/// Field: LCDS8 [8:8]
enum class LCD_F_LCDPCTL0_LCDS8 : uint32_t {
    LCDS8_0 = 0x0,
    LCDS8_1 = 0x1,
};

/// LCD pin 9 enable
/// Register: LCDPCTL0
/// Field: LCDS9 [9:9]
enum class LCD_F_LCDPCTL0_LCDS9 : uint32_t {
    LCDS9_0 = 0x0,
    LCDS9_1 = 0x1,
};

/// LCD pin 10 enable
/// Register: LCDPCTL0
/// Field: LCDS10 [10:10]
enum class LCD_F_LCDPCTL0_LCDS10 : uint32_t {
    LCDS10_0 = 0x0,
    LCDS10_1 = 0x1,
};

/// LCD pin 11 enable
/// Register: LCDPCTL0
/// Field: LCDS11 [11:11]
enum class LCD_F_LCDPCTL0_LCDS11 : uint32_t {
    LCDS11_0 = 0x0,
    LCDS11_1 = 0x1,
};

/// LCD pin 12 enable
/// Register: LCDPCTL0
/// Field: LCDS12 [12:12]
enum class LCD_F_LCDPCTL0_LCDS12 : uint32_t {
    LCDS12_0 = 0x0,
    LCDS12_1 = 0x1,
};

/// LCD pin 13 enable
/// Register: LCDPCTL0
/// Field: LCDS13 [13:13]
enum class LCD_F_LCDPCTL0_LCDS13 : uint32_t {
    LCDS13_0 = 0x0,
    LCDS13_1 = 0x1,
};

/// LCD pin 14 enable
/// Register: LCDPCTL0
/// Field: LCDS14 [14:14]
enum class LCD_F_LCDPCTL0_LCDS14 : uint32_t {
    LCDS14_0 = 0x0,
    LCDS14_1 = 0x1,
};

/// LCD pin 15 enable
/// Register: LCDPCTL0
/// Field: LCDS15 [15:15]
enum class LCD_F_LCDPCTL0_LCDS15 : uint32_t {
    LCDS15_0 = 0x0,
    LCDS15_1 = 0x1,
};

/// LCD pin 16 enable
/// Register: LCDPCTL0
/// Field: LCDS16 [16:16]
enum class LCD_F_LCDPCTL0_LCDS16 : uint32_t {
    LCDS16_0 = 0x0,
    LCDS16_1 = 0x1,
};

/// LCD pin 17 enable
/// Register: LCDPCTL0
/// Field: LCDS17 [17:17]
enum class LCD_F_LCDPCTL0_LCDS17 : uint32_t {
    LCDS17_0 = 0x0,
    LCDS17_1 = 0x1,
};

/// LCD pin 18 enable
/// Register: LCDPCTL0
/// Field: LCDS18 [18:18]
enum class LCD_F_LCDPCTL0_LCDS18 : uint32_t {
    LCDS18_0 = 0x0,
    LCDS18_1 = 0x1,
};

/// LCD pin 19 enable
/// Register: LCDPCTL0
/// Field: LCDS19 [19:19]
enum class LCD_F_LCDPCTL0_LCDS19 : uint32_t {
    LCDS19_0 = 0x0,
    LCDS19_1 = 0x1,
};

/// LCD pin 20 enable
/// Register: LCDPCTL0
/// Field: LCDS20 [20:20]
enum class LCD_F_LCDPCTL0_LCDS20 : uint32_t {
    LCDS20_0 = 0x0,
    LCDS20_1 = 0x1,
};

/// LCD pin 21 enable
/// Register: LCDPCTL0
/// Field: LCDS21 [21:21]
enum class LCD_F_LCDPCTL0_LCDS21 : uint32_t {
    LCDS21_0 = 0x0,
    LCDS21_1 = 0x1,
};

/// LCD pin 22 enable
/// Register: LCDPCTL0
/// Field: LCDS22 [22:22]
enum class LCD_F_LCDPCTL0_LCDS22 : uint32_t {
    LCDS22_0 = 0x0,
    LCDS22_1 = 0x1,
};

/// LCD pin 23 enable
/// Register: LCDPCTL0
/// Field: LCDS23 [23:23]
enum class LCD_F_LCDPCTL0_LCDS23 : uint32_t {
    LCDS23_0 = 0x0,
    LCDS23_1 = 0x1,
};

/// LCD pin 24 enable
/// Register: LCDPCTL0
/// Field: LCDS24 [24:24]
enum class LCD_F_LCDPCTL0_LCDS24 : uint32_t {
    LCDS24_0 = 0x0,
    LCDS24_1 = 0x1,
};

/// LCD pin 25 enable
/// Register: LCDPCTL0
/// Field: LCDS25 [25:25]
enum class LCD_F_LCDPCTL0_LCDS25 : uint32_t {
    LCDS25_0 = 0x0,
    LCDS25_1 = 0x1,
};

/// LCD pin 26 enable
/// Register: LCDPCTL0
/// Field: LCDS26 [26:26]
enum class LCD_F_LCDPCTL0_LCDS26 : uint32_t {
    LCDS26_0 = 0x0,
    LCDS26_1 = 0x1,
};

/// LCD pin 27 enable
/// Register: LCDPCTL0
/// Field: LCDS27 [27:27]
enum class LCD_F_LCDPCTL0_LCDS27 : uint32_t {
    LCDS27_0 = 0x0,
    LCDS27_1 = 0x1,
};

/// LCD pin 28 enable
/// Register: LCDPCTL0
/// Field: LCDS28 [28:28]
enum class LCD_F_LCDPCTL0_LCDS28 : uint32_t {
    LCDS28_0 = 0x0,
    LCDS28_1 = 0x1,
};

/// LCD pin 29 enable
/// Register: LCDPCTL0
/// Field: LCDS29 [29:29]
enum class LCD_F_LCDPCTL0_LCDS29 : uint32_t {
    LCDS29_0 = 0x0,
    LCDS29_1 = 0x1,
};

/// LCD pin 30 enable
/// Register: LCDPCTL0
/// Field: LCDS30 [30:30]
enum class LCD_F_LCDPCTL0_LCDS30 : uint32_t {
    LCDS30_0 = 0x0,
    LCDS30_1 = 0x1,
};

/// LCD pin 31 enable
/// Register: LCDPCTL0
/// Field: LCDS31 [31:31]
enum class LCD_F_LCDPCTL0_LCDS31 : uint32_t {
    LCDS31_0 = 0x0,
    LCDS31_1 = 0x1,
};

/// LCD pin 32 enable
/// Register: LCDPCTL1
/// Field: LCDS32 [0:0]
enum class LCD_F_LCDPCTL1_LCDS32 : uint32_t {
    LCDS32_0 = 0x0,
    LCDS32_1 = 0x1,
};

/// LCD pin 33 enable
/// Register: LCDPCTL1
/// Field: LCDS33 [1:1]
enum class LCD_F_LCDPCTL1_LCDS33 : uint32_t {
    LCDS33_0 = 0x0,
    LCDS33_1 = 0x1,
};

/// LCD pin 34 enable
/// Register: LCDPCTL1
/// Field: LCDS34 [2:2]
enum class LCD_F_LCDPCTL1_LCDS34 : uint32_t {
    LCDS34_0 = 0x0,
    LCDS34_1 = 0x1,
};

/// LCD pin 35 enable
/// Register: LCDPCTL1
/// Field: LCDS35 [3:3]
enum class LCD_F_LCDPCTL1_LCDS35 : uint32_t {
    LCDS35_0 = 0x0,
    LCDS35_1 = 0x1,
};

/// LCD pin 36 enable
/// Register: LCDPCTL1
/// Field: LCDS36 [4:4]
enum class LCD_F_LCDPCTL1_LCDS36 : uint32_t {
    LCDS36_0 = 0x0,
    LCDS36_1 = 0x1,
};

/// LCD pin 37 enable
/// Register: LCDPCTL1
/// Field: LCDS37 [5:5]
enum class LCD_F_LCDPCTL1_LCDS37 : uint32_t {
    LCDS37_0 = 0x0,
    LCDS37_1 = 0x1,
};

/// LCD pin 38 enable
/// Register: LCDPCTL1
/// Field: LCDS38 [6:6]
enum class LCD_F_LCDPCTL1_LCDS38 : uint32_t {
    LCDS38_0 = 0x0,
    LCDS38_1 = 0x1,
};

/// LCD pin 39 enable
/// Register: LCDPCTL1
/// Field: LCDS39 [7:7]
enum class LCD_F_LCDPCTL1_LCDS39 : uint32_t {
    LCDS39_0 = 0x0,
    LCDS39_1 = 0x1,
};

/// LCD pin 40 enable
/// Register: LCDPCTL1
/// Field: LCDS40 [8:8]
enum class LCD_F_LCDPCTL1_LCDS40 : uint32_t {
    LCDS40_0 = 0x0,
    LCDS40_1 = 0x1,
};

/// LCD pin 41 enable
/// Register: LCDPCTL1
/// Field: LCDS41 [9:9]
enum class LCD_F_LCDPCTL1_LCDS41 : uint32_t {
    LCDS41_0 = 0x0,
    LCDS41_1 = 0x1,
};

/// LCD pin 42 enable
/// Register: LCDPCTL1
/// Field: LCDS42 [10:10]
enum class LCD_F_LCDPCTL1_LCDS42 : uint32_t {
    LCDS42_0 = 0x0,
    LCDS42_1 = 0x1,
};

/// LCD pin 43 enable
/// Register: LCDPCTL1
/// Field: LCDS43 [11:11]
enum class LCD_F_LCDPCTL1_LCDS43 : uint32_t {
    LCDS43_0 = 0x0,
    LCDS43_1 = 0x1,
};

/// LCD pin 44 enable
/// Register: LCDPCTL1
/// Field: LCDS44 [12:12]
enum class LCD_F_LCDPCTL1_LCDS44 : uint32_t {
    LCDS44_0 = 0x0,
    LCDS44_1 = 0x1,
};

/// LCD pin 45 enable
/// Register: LCDPCTL1
/// Field: LCDS45 [13:13]
enum class LCD_F_LCDPCTL1_LCDS45 : uint32_t {
    LCDS45_0 = 0x0,
    LCDS45_1 = 0x1,
};

/// LCD pin 46 enable
/// Register: LCDPCTL1
/// Field: LCDS46 [14:14]
enum class LCD_F_LCDPCTL1_LCDS46 : uint32_t {
    LCDS46_0 = 0x0,
    LCDS46_1 = 0x1,
};

/// LCD pin 47 enable
/// Register: LCDPCTL1
/// Field: LCDS47 [15:15]
enum class LCD_F_LCDPCTL1_LCDS47 : uint32_t {
    LCDS47_0 = 0x0,
    LCDS47_1 = 0x1,
};

/// LCD pin 48 enable
/// Register: LCDPCTL1
/// Field: LCDS48 [16:16]
enum class LCD_F_LCDPCTL1_LCDS48 : uint32_t {
    LCDS48_0 = 0x0,
    LCDS48_1 = 0x1,
};

/// LCD pin 49 enable
/// Register: LCDPCTL1
/// Field: LCDS49 [17:17]
enum class LCD_F_LCDPCTL1_LCDS49 : uint32_t {
    LCDS49_0 = 0x0,
    LCDS49_1 = 0x1,
};

/// LCD pin 50 enable
/// Register: LCDPCTL1
/// Field: LCDS50 [18:18]
enum class LCD_F_LCDPCTL1_LCDS50 : uint32_t {
    LCDS50_0 = 0x0,
    LCDS50_1 = 0x1,
};

/// LCD pin 51 enable
/// Register: LCDPCTL1
/// Field: LCDS51 [19:19]
enum class LCD_F_LCDPCTL1_LCDS51 : uint32_t {
    LCDS51_0 = 0x0,
    LCDS51_1 = 0x1,
};

/// LCD pin 52 enable
/// Register: LCDPCTL1
/// Field: LCDS52 [20:20]
enum class LCD_F_LCDPCTL1_LCDS52 : uint32_t {
    LCDS52_0 = 0x0,
    LCDS52_1 = 0x1,
};

/// LCD pin 53 enable
/// Register: LCDPCTL1
/// Field: LCDS53 [21:21]
enum class LCD_F_LCDPCTL1_LCDS53 : uint32_t {
    LCDS53_0 = 0x0,
    LCDS53_1 = 0x1,
};

/// LCD pin 54 enable
/// Register: LCDPCTL1
/// Field: LCDS54 [22:22]
enum class LCD_F_LCDPCTL1_LCDS54 : uint32_t {
    LCDS54_0 = 0x0,
    LCDS54_1 = 0x1,
};

/// LCD pin 55 enable
/// Register: LCDPCTL1
/// Field: LCDS55 [23:23]
enum class LCD_F_LCDPCTL1_LCDS55 : uint32_t {
    LCDS55_0 = 0x0,
    LCDS55_1 = 0x1,
};

/// LCD pin 56 enable
/// Register: LCDPCTL1
/// Field: LCDS56 [24:24]
enum class LCD_F_LCDPCTL1_LCDS56 : uint32_t {
    LCDS56_0 = 0x0,
    LCDS56_1 = 0x1,
};

/// LCD pin 57 enable
/// Register: LCDPCTL1
/// Field: LCDS57 [25:25]
enum class LCD_F_LCDPCTL1_LCDS57 : uint32_t {
    LCDS57_0 = 0x0,
    LCDS57_1 = 0x1,
};

/// LCD pin 58 enable
/// Register: LCDPCTL1
/// Field: LCDS58 [26:26]
enum class LCD_F_LCDPCTL1_LCDS58 : uint32_t {
    LCDS58_0 = 0x0,
    LCDS58_1 = 0x1,
};

/// LCD pin 59 enable
/// Register: LCDPCTL1
/// Field: LCDS59 [27:27]
enum class LCD_F_LCDPCTL1_LCDS59 : uint32_t {
    LCDS59_0 = 0x0,
    LCDS59_1 = 0x1,
};

/// LCD pin 60 enable
/// Register: LCDPCTL1
/// Field: LCDS60 [28:28]
enum class LCD_F_LCDPCTL1_LCDS60 : uint32_t {
    LCDS60_0 = 0x0,
    LCDS60_1 = 0x1,
};

/// LCD pin 61 enable
/// Register: LCDPCTL1
/// Field: LCDS61 [29:29]
enum class LCD_F_LCDPCTL1_LCDS61 : uint32_t {
    LCDS61_0 = 0x0,
    LCDS61_1 = 0x1,
};

/// LCD pin 62 enable
/// Register: LCDPCTL1
/// Field: LCDS62 [30:30]
enum class LCD_F_LCDPCTL1_LCDS62 : uint32_t {
    LCDS62_0 = 0x0,
    LCDS62_1 = 0x1,
};

/// LCD pin 63 enable
/// Register: LCDPCTL1
/// Field: LCDS63 [31:31]
enum class LCD_F_LCDPCTL1_LCDS63 : uint32_t {
    LCDS63_0 = 0x0,
    LCDS63_1 = 0x1,
};

/// L0 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS0 [0:0]
enum class LCD_F_LCDCSSEL0_LCDCSS0 : uint32_t {
    LCDCSS0_0 = 0x0,
    LCDCSS0_1 = 0x1,
};

/// L1 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS1 [1:1]
enum class LCD_F_LCDCSSEL0_LCDCSS1 : uint32_t {
    LCDCSS1_0 = 0x0,
    LCDCSS1_1 = 0x1,
};

/// L2 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS2 [2:2]
enum class LCD_F_LCDCSSEL0_LCDCSS2 : uint32_t {
    LCDCSS2_0 = 0x0,
    LCDCSS2_1 = 0x1,
};

/// L3 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS3 [3:3]
enum class LCD_F_LCDCSSEL0_LCDCSS3 : uint32_t {
    LCDCSS3_0 = 0x0,
    LCDCSS3_1 = 0x1,
};

/// L4 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS4 [4:4]
enum class LCD_F_LCDCSSEL0_LCDCSS4 : uint32_t {
    LCDCSS4_0 = 0x0,
    LCDCSS4_1 = 0x1,
};

/// L5 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS5 [5:5]
enum class LCD_F_LCDCSSEL0_LCDCSS5 : uint32_t {
    LCDCSS5_0 = 0x0,
    LCDCSS5_1 = 0x1,
};

/// L6 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS6 [6:6]
enum class LCD_F_LCDCSSEL0_LCDCSS6 : uint32_t {
    LCDCSS6_0 = 0x0,
    LCDCSS6_1 = 0x1,
};

/// L7 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS7 [7:7]
enum class LCD_F_LCDCSSEL0_LCDCSS7 : uint32_t {
    LCDCSS7_0 = 0x0,
    LCDCSS7_1 = 0x1,
};

/// L8 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS8 [8:8]
enum class LCD_F_LCDCSSEL0_LCDCSS8 : uint32_t {
    LCDCSS8_0 = 0x0,
    LCDCSS8_1 = 0x1,
};

/// L9 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS9 [9:9]
enum class LCD_F_LCDCSSEL0_LCDCSS9 : uint32_t {
    LCDCSS9_0 = 0x0,
    LCDCSS9_1 = 0x1,
};

/// L10 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS10 [10:10]
enum class LCD_F_LCDCSSEL0_LCDCSS10 : uint32_t {
    LCDCSS10_0 = 0x0,
    LCDCSS10_1 = 0x1,
};

/// L11 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS11 [11:11]
enum class LCD_F_LCDCSSEL0_LCDCSS11 : uint32_t {
    LCDCSS11_0 = 0x0,
    LCDCSS11_1 = 0x1,
};

/// L12 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS12 [12:12]
enum class LCD_F_LCDCSSEL0_LCDCSS12 : uint32_t {
    LCDCSS12_0 = 0x0,
    LCDCSS12_1 = 0x1,
};

/// L13 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS13 [13:13]
enum class LCD_F_LCDCSSEL0_LCDCSS13 : uint32_t {
    LCDCSS13_0 = 0x0,
    LCDCSS13_1 = 0x1,
};

/// L14 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS14 [14:14]
enum class LCD_F_LCDCSSEL0_LCDCSS14 : uint32_t {
    LCDCSS14_0 = 0x0,
    LCDCSS14_1 = 0x1,
};

/// L15 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS15 [15:15]
enum class LCD_F_LCDCSSEL0_LCDCSS15 : uint32_t {
    LCDCSS15_0 = 0x0,
    LCDCSS15_1 = 0x1,
};

/// L16 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS16 [16:16]
enum class LCD_F_LCDCSSEL0_LCDCSS16 : uint32_t {
    LCDCSS16_0 = 0x0,
    LCDCSS16_1 = 0x1,
};

/// L17 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS17 [17:17]
enum class LCD_F_LCDCSSEL0_LCDCSS17 : uint32_t {
    LCDCSS17_0 = 0x0,
    LCDCSS17_1 = 0x1,
};

/// L18 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS18 [18:18]
enum class LCD_F_LCDCSSEL0_LCDCSS18 : uint32_t {
    LCDCSS18_0 = 0x0,
    LCDCSS18_1 = 0x1,
};

/// L19 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS19 [19:19]
enum class LCD_F_LCDCSSEL0_LCDCSS19 : uint32_t {
    LCDCSS19_0 = 0x0,
    LCDCSS19_1 = 0x1,
};

/// L20 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS20 [20:20]
enum class LCD_F_LCDCSSEL0_LCDCSS20 : uint32_t {
    LCDCSS20_0 = 0x0,
    LCDCSS20_1 = 0x1,
};

/// L21 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS21 [21:21]
enum class LCD_F_LCDCSSEL0_LCDCSS21 : uint32_t {
    LCDCSS21_0 = 0x0,
    LCDCSS21_1 = 0x1,
};

/// L22 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS22 [22:22]
enum class LCD_F_LCDCSSEL0_LCDCSS22 : uint32_t {
    LCDCSS22_0 = 0x0,
    LCDCSS22_1 = 0x1,
};

/// L23 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS23 [23:23]
enum class LCD_F_LCDCSSEL0_LCDCSS23 : uint32_t {
    LCDCSS23_0 = 0x0,
    LCDCSS23_1 = 0x1,
};

/// L24 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS24 [24:24]
enum class LCD_F_LCDCSSEL0_LCDCSS24 : uint32_t {
    LCDCSS24_0 = 0x0,
    LCDCSS24_1 = 0x1,
};

/// L25 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS25 [25:25]
enum class LCD_F_LCDCSSEL0_LCDCSS25 : uint32_t {
    LCDCSS25_0 = 0x0,
    LCDCSS25_1 = 0x1,
};

/// L26 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS26 [26:26]
enum class LCD_F_LCDCSSEL0_LCDCSS26 : uint32_t {
    LCDCSS26_0 = 0x0,
    LCDCSS26_1 = 0x1,
};

/// L27 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS27 [27:27]
enum class LCD_F_LCDCSSEL0_LCDCSS27 : uint32_t {
    LCDCSS27_0 = 0x0,
    LCDCSS27_1 = 0x1,
};

/// L28 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS28 [28:28]
enum class LCD_F_LCDCSSEL0_LCDCSS28 : uint32_t {
    LCDCSS28_0 = 0x0,
    LCDCSS28_1 = 0x1,
};

/// L29 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS29 [29:29]
enum class LCD_F_LCDCSSEL0_LCDCSS29 : uint32_t {
    LCDCSS29_0 = 0x0,
    LCDCSS29_1 = 0x1,
};

/// L30 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS30 [30:30]
enum class LCD_F_LCDCSSEL0_LCDCSS30 : uint32_t {
    LCDCSS30_0 = 0x0,
    LCDCSS30_1 = 0x1,
};

/// L31 Com Seg select
/// Register: LCDCSSEL0
/// Field: LCDCSS31 [31:31]
enum class LCD_F_LCDCSSEL0_LCDCSS31 : uint32_t {
    LCDCSS31_0 = 0x0,
    LCDCSS31_1 = 0x1,
};

/// L32 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS32 [0:0]
enum class LCD_F_LCDCSSEL1_LCDCSS32 : uint32_t {
    LCDCSS32_0 = 0x0,
    LCDCSS32_1 = 0x1,
};

/// L33 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS33 [1:1]
enum class LCD_F_LCDCSSEL1_LCDCSS33 : uint32_t {
    LCDCSS33_0 = 0x0,
    LCDCSS33_1 = 0x1,
};

/// L34 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS34 [2:2]
enum class LCD_F_LCDCSSEL1_LCDCSS34 : uint32_t {
    LCDCSS34_0 = 0x0,
    LCDCSS34_1 = 0x1,
};

/// L35 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS35 [3:3]
enum class LCD_F_LCDCSSEL1_LCDCSS35 : uint32_t {
    LCDCSS35_0 = 0x0,
    LCDCSS35_1 = 0x1,
};

/// L36 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS36 [4:4]
enum class LCD_F_LCDCSSEL1_LCDCSS36 : uint32_t {
    LCDCSS36_0 = 0x0,
    LCDCSS36_1 = 0x1,
};

/// L37 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS37 [5:5]
enum class LCD_F_LCDCSSEL1_LCDCSS37 : uint32_t {
    LCDCSS37_0 = 0x0,
    LCDCSS37_1 = 0x1,
};

/// L38 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS38 [6:6]
enum class LCD_F_LCDCSSEL1_LCDCSS38 : uint32_t {
    LCDCSS38_0 = 0x0,
    LCDCSS38_1 = 0x1,
};

/// L39 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS39 [7:7]
enum class LCD_F_LCDCSSEL1_LCDCSS39 : uint32_t {
    LCDCSS39_0 = 0x0,
    LCDCSS39_1 = 0x1,
};

/// L40 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS40 [8:8]
enum class LCD_F_LCDCSSEL1_LCDCSS40 : uint32_t {
    LCDCSS40_0 = 0x0,
    LCDCSS40_1 = 0x1,
};

/// L41 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS41 [9:9]
enum class LCD_F_LCDCSSEL1_LCDCSS41 : uint32_t {
    LCDCSS41_0 = 0x0,
    LCDCSS41_1 = 0x1,
};

/// L42 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS42 [10:10]
enum class LCD_F_LCDCSSEL1_LCDCSS42 : uint32_t {
    LCDCSS42_0 = 0x0,
    LCDCSS42_1 = 0x1,
};

/// L43 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS43 [11:11]
enum class LCD_F_LCDCSSEL1_LCDCSS43 : uint32_t {
    LCDCSS43_0 = 0x0,
    LCDCSS43_1 = 0x1,
};

/// L44 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS44 [12:12]
enum class LCD_F_LCDCSSEL1_LCDCSS44 : uint32_t {
    LCDCSS44_0 = 0x0,
    LCDCSS44_1 = 0x1,
};

/// L45 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS45 [13:13]
enum class LCD_F_LCDCSSEL1_LCDCSS45 : uint32_t {
    LCDCSS45_0 = 0x0,
    LCDCSS45_1 = 0x1,
};

/// L46 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS46 [14:14]
enum class LCD_F_LCDCSSEL1_LCDCSS46 : uint32_t {
    LCDCSS46_0 = 0x0,
    LCDCSS46_1 = 0x1,
};

/// L47 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS47 [15:15]
enum class LCD_F_LCDCSSEL1_LCDCSS47 : uint32_t {
    LCDCSS47_0 = 0x0,
    LCDCSS47_1 = 0x1,
};

/// L48 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS48 [16:16]
enum class LCD_F_LCDCSSEL1_LCDCSS48 : uint32_t {
    LCDCSS48_0 = 0x0,
    LCDCSS48_1 = 0x1,
};

/// L49 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS49 [17:17]
enum class LCD_F_LCDCSSEL1_LCDCSS49 : uint32_t {
    LCDCSS49_0 = 0x0,
    LCDCSS49_1 = 0x1,
};

/// L50 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS50 [18:18]
enum class LCD_F_LCDCSSEL1_LCDCSS50 : uint32_t {
    LCDCSS50_0 = 0x0,
    LCDCSS50_1 = 0x1,
};

/// L51 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS51 [19:19]
enum class LCD_F_LCDCSSEL1_LCDCSS51 : uint32_t {
    LCDCSS51_0 = 0x0,
    LCDCSS51_1 = 0x1,
};

/// L52 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS52 [20:20]
enum class LCD_F_LCDCSSEL1_LCDCSS52 : uint32_t {
    LCDCSS52_0 = 0x0,
    LCDCSS52_1 = 0x1,
};

/// L53 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS53 [21:21]
enum class LCD_F_LCDCSSEL1_LCDCSS53 : uint32_t {
    LCDCSS53_0 = 0x0,
    LCDCSS53_1 = 0x1,
};

/// L54 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS54 [22:22]
enum class LCD_F_LCDCSSEL1_LCDCSS54 : uint32_t {
    LCDCSS54_0 = 0x0,
    LCDCSS54_1 = 0x1,
};

/// L55 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS55 [23:23]
enum class LCD_F_LCDCSSEL1_LCDCSS55 : uint32_t {
    LCDCSS55_0 = 0x0,
    LCDCSS55_1 = 0x1,
};

/// L56 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS56 [24:24]
enum class LCD_F_LCDCSSEL1_LCDCSS56 : uint32_t {
    LCDCSS56_0 = 0x0,
    LCDCSS56_1 = 0x1,
};

/// L57 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS57 [25:25]
enum class LCD_F_LCDCSSEL1_LCDCSS57 : uint32_t {
    LCDCSS57_0 = 0x0,
    LCDCSS57_1 = 0x1,
};

/// L58 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS58 [26:26]
enum class LCD_F_LCDCSSEL1_LCDCSS58 : uint32_t {
    LCDCSS58_0 = 0x0,
    LCDCSS58_1 = 0x1,
};

/// L59 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS59 [27:27]
enum class LCD_F_LCDCSSEL1_LCDCSS59 : uint32_t {
    LCDCSS59_0 = 0x0,
    LCDCSS59_1 = 0x1,
};

/// L60 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS60 [28:28]
enum class LCD_F_LCDCSSEL1_LCDCSS60 : uint32_t {
    LCDCSS60_0 = 0x0,
    LCDCSS60_1 = 0x1,
};

/// L61 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS61 [29:29]
enum class LCD_F_LCDCSSEL1_LCDCSS61 : uint32_t {
    LCDCSS61_0 = 0x0,
    LCDCSS61_1 = 0x1,
};

/// L62 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS62 [30:30]
enum class LCD_F_LCDCSSEL1_LCDCSS62 : uint32_t {
    LCDCSS62_0 = 0x0,
    LCDCSS62_1 = 0x1,
};

/// L63 Com Seg select
/// Register: LCDCSSEL1
/// Field: LCDCSS63 [31:31]
enum class LCD_F_LCDCSSEL1_LCDCSS63 : uint32_t {
    LCDCSS63_0 = 0x0,
    LCDCSS63_1 = 0x1,
};

/// Enable Animation
/// Register: LCDANMCTL
/// Field: LCDANMEN [0:0]
enum class LCD_F_LCDANMCTL_LCDANMEN : uint32_t {
    LCDANMEN_0 = 0x0,
    LCDANMEN_1 = 0x1,
};

/// Number of Amimation frames
/// Register: LCDANMCTL
/// Field: LCDANMSTP [1:3]
enum class LCD_F_LCDANMCTL_LCDANMSTP : uint32_t {
    LCDANMSTP_0 = 0x0,
    LCDANMSTP_1 = 0x1,
    LCDANMSTP_2 = 0x2,
    LCDANMSTP_3 = 0x3,
    LCDANMSTP_4 = 0x4,
    LCDANMSTP_5 = 0x5,
    LCDANMSTP_6 = 0x6,
    LCDANMSTP_7 = 0x7,
};

/// Clear Animation Memory
/// Register: LCDANMCTL
/// Field: LCDANMCLR [7:7]
enum class LCD_F_LCDANMCTL_LCDANMCLR : uint32_t {
    LCDANMCLR_0 = 0x0,
    LCDANMCLR_1 = 0x1,
};

/// Clock pre-scaler for animation frequency
/// Register: LCDANMCTL
/// Field: LCDANMPREx [16:18]
enum class LCD_F_LCDANMCTL_LCDANMPREX : uint32_t {
    LCDANMPREx_0 = 0x0,
    LCDANMPREx_1 = 0x1,
    LCDANMPREx_2 = 0x2,
    LCDANMPREx_3 = 0x3,
    LCDANMPREx_4 = 0x4,
    LCDANMPREx_5 = 0x5,
    LCDANMPREx_6 = 0x6,
    LCDANMPREx_7 = 0x7,
};

/// Clock divider for animation frequency
/// Register: LCDANMCTL
/// Field: LCDANMDIVx [19:21]
enum class LCD_F_LCDANMCTL_LCDANMDIVX : uint32_t {
    LCDANMDIVx_0 = 0x0,
    LCDANMDIVx_1 = 0x1,
    LCDANMDIVx_2 = 0x2,
    LCDANMDIVx_3 = 0x3,
    LCDANMDIVx_4 = 0x4,
    LCDANMDIVx_5 = 0x5,
    LCDANMDIVx_6 = 0x6,
    LCDANMDIVx_7 = 0x7,
};

/// LCD Blink, segments off interrupt enable
/// Register: LCDIE
/// Field: LCDBLKOFFIE [1:1]
enum class LCD_F_LCDIE_LCDBLKOFFIE : uint32_t {
    LCDBLKOFFIE_0 = 0x0,
    LCDBLKOFFIE_1 = 0x1,
};

/// LCD Blink, segments on interrupt enable
/// Register: LCDIE
/// Field: LCDBLKONIE [2:2]
enum class LCD_F_LCDIE_LCDBLKONIE : uint32_t {
    LCDBLKONIE_0 = 0x0,
    LCDBLKONIE_1 = 0x1,
};

/// LCD Frame interrupt enable
/// Register: LCDIE
/// Field: LCDFRMIE [3:3]
enum class LCD_F_LCDIE_LCDFRMIE : uint32_t {
    LCDFRMIE_0 = 0x0,
    LCDFRMIE_1 = 0x1,
};

/// LCD Animation step interrupt enable
/// Register: LCDIE
/// Field: LCDANMSTPIE [8:8]
enum class LCD_F_LCDIE_LCDANMSTPIE : uint32_t {
    LCDANMSTPIE_0 = 0x0,
    LCDANMSTPIE_1 = 0x1,
};

/// LCD Animation loop interrupt enable
/// Register: LCDIE
/// Field: LCDANMLOOPIE [9:9]
enum class LCD_F_LCDIE_LCDANMLOOPIE : uint32_t {
    LCDANMLOOPIE_0 = 0x0,
    LCDANMLOOPIE_1 = 0x1,
};

/// LCD Blink, segments off interrupt flag
/// Register: LCDIFG
/// Field: LCDBLKOFFIFG [1:1]
enum class LCD_F_LCDIFG_LCDBLKOFFIFG : uint32_t {
    LCDBLKOFFIFG_0 = 0x0,
    LCDBLKOFFIFG_1 = 0x1,
};

/// LCD Blink, segments on interrupt flag
/// Register: LCDIFG
/// Field: LCDBLKONIFG [2:2]
enum class LCD_F_LCDIFG_LCDBLKONIFG : uint32_t {
    LCDBLKONIFG_0 = 0x0,
    LCDBLKONIFG_1 = 0x1,
};

/// LCD Frame interrupt flag
/// Register: LCDIFG
/// Field: LCDFRMIFG [3:3]
enum class LCD_F_LCDIFG_LCDFRMIFG : uint32_t {
    LCDFRMIFG_0 = 0x0,
    LCDFRMIFG_1 = 0x1,
};

/// LCD Animation step interrupt flag
/// Register: LCDIFG
/// Field: LCDANMSTPIFG [8:8]
enum class LCD_F_LCDIFG_LCDANMSTPIFG : uint32_t {
    LCDANMSTPIFG_0 = 0x0,
    LCDANMSTPIFG_1 = 0x1,
};

/// LCD Animation loop interrupt flag
/// Register: LCDIFG
/// Field: LCDANMLOOPIFG [9:9]
enum class LCD_F_LCDIFG_LCDANMLOOPIFG : uint32_t {
    LCDANMLOOPIFG_0 = 0x0,
    LCDANMLOOPIFG_1 = 0x1,
};

/// Sets LCDBLKOFFIFG
/// Register: LCDSETIFG
/// Field: SETLCDBLKOFFIFG [1:1]
enum class LCD_F_LCDSETIFG_SETLCDBLKOFFIFG : uint32_t {
    SETLCDBLKOFFIFG_0 = 0x0,
    SETLCDBLKOFFIFG_1 = 0x1,
};

/// Sets LCDBLKONIFG
/// Register: LCDSETIFG
/// Field: SETLCDBLKONIFG [2:2]
enum class LCD_F_LCDSETIFG_SETLCDBLKONIFG : uint32_t {
    SETLCDBLKONIFG_0 = 0x0,
    SETLCDBLKONIFG_1 = 0x1,
};

/// Sets LCDFRMIFG
/// Register: LCDSETIFG
/// Field: SETLCDFRMIFG [3:3]
enum class LCD_F_LCDSETIFG_SETLCDFRMIFG : uint32_t {
    SETLCDFRMIFG_0 = 0x0,
    SETLCDFRMIFG_1 = 0x1,
};

/// Sets LCDANMSTPIFG
/// Register: LCDSETIFG
/// Field: SETLCDANMSTPIFG [8:8]
enum class LCD_F_LCDSETIFG_SETLCDANMSTPIFG : uint32_t {
    SETLCDANMSTPIFG_0 = 0x0,
    SETLCDANMSTPIFG_1 = 0x1,
};

/// Sets LCDANMLOOPIFG
/// Register: LCDSETIFG
/// Field: SETLCDANMLOOPIFG [9:9]
enum class LCD_F_LCDSETIFG_SETLCDANMLOOPIFG : uint32_t {
    SETLCDANMLOOPIFG_0 = 0x0,
    SETLCDANMLOOPIFG_1 = 0x1,
};

/// Clears LCDBLKOFFIFG
/// Register: LCDCLRIFG
/// Field: CLRLCDBLKOFFIFG [1:1]
enum class LCD_F_LCDCLRIFG_CLRLCDBLKOFFIFG : uint32_t {
    CLRLCDBLKOFFIFG_0 = 0x0,
    CLRLCDBLKOFFIFG_1 = 0x1,
};

/// Clears LCDBLKONIFG
/// Register: LCDCLRIFG
/// Field: CLRLCDBLKONIFG [2:2]
enum class LCD_F_LCDCLRIFG_CLRLCDBLKONIFG : uint32_t {
    CLRLCDBLKONIFG_0 = 0x0,
    CLRLCDBLKONIFG_1 = 0x1,
};

/// Clears LCDFRMIFG
/// Register: LCDCLRIFG
/// Field: CLRLCDFRMIFG [3:3]
enum class LCD_F_LCDCLRIFG_CLRLCDFRMIFG : uint32_t {
    CLRLCDFRMIFG_0 = 0x0,
    CLRLCDFRMIFG_1 = 0x1,
};

/// Clears LCDANMSTPIFG
/// Register: LCDCLRIFG
/// Field: CLRLCDANMSTPIFG [8:8]
enum class LCD_F_LCDCLRIFG_CLRLCDANMSTPIFG : uint32_t {
    CLRLCDANMSTPIFG_0 = 0x0,
    CLRLCDANMSTPIFG_1 = 0x1,
};

/// Clears LCDANMLOOPIFG
/// Register: LCDCLRIFG
/// Field: CLRLCDANMLOOPIFG [9:9]
enum class LCD_F_LCDCLRIFG_CLRLCDANMLOOPIFG : uint32_t {
    CLRLCDANMLOOPIFG_0 = 0x0,
    CLRLCDANMLOOPIFG_1 = 0x1,
};

// ----------------------------------------------------------------------------
// PCM - PCM
// ----------------------------------------------------------------------------

/// Active Mode Request
/// Register: PCMCTL0
/// Field: AMR [0:3]
enum class PCM_PCMCTL0_AMR : uint32_t {
    AMR_0 = 0x0,
    AMR_1 = 0x1,
    AMR_4 = 0x4,
    AMR_5 = 0x5,
    AMR_8 = 0x8,
    AMR_9 = 0x9,
};

/// Low Power Mode Request
/// Register: PCMCTL0
/// Field: LPMR [4:7]
enum class PCM_PCMCTL0_LPMR : uint32_t {
    LPMR_0 = 0x0,
    LPMR_10 = 0xA,
    LPMR_12 = 0xC,
};

/// Current Power Mode
/// Register: PCMCTL0
/// Field: CPM [8:13]
enum class PCM_PCMCTL0_CPM : uint32_t {
    CPM_0 = 0x0,
    CPM_1 = 0x1,
    CPM_4 = 0x4,
    CPM_5 = 0x5,
    CPM_8 = 0x8,
    CPM_9 = 0x9,
    CPM_16 = 0x10,
    CPM_17 = 0x11,
    CPM_20 = 0x14,
    CPM_21 = 0x15,
    CPM_24 = 0x18,
    CPM_25 = 0x19,
    CPM_32 = 0x20,
};

/// Lock LPM5
/// Register: PCMCTL1
/// Field: LOCKLPM5 [0:0]
enum class PCM_PCMCTL1_LOCKLPM5 : uint32_t {
    LOCKLPM5_0 = 0x0,
    LOCKLPM5_1 = 0x1,
};

/// Lock Backup
/// Register: PCMCTL1
/// Field: LOCKBKUP [1:1]
enum class PCM_PCMCTL1_LOCKBKUP : uint32_t {
    LOCKBKUP_0 = 0x0,
    LOCKBKUP_1 = 0x1,
};

/// Force LPM entry
/// Register: PCMCTL1
/// Field: FORCE_LPM_ENTRY [2:2]
enum class PCM_PCMCTL1_FORCE_LPM_ENTRY : uint32_t {
    FORCE_LPM_ENTRY_0 = 0x0,
    FORCE_LPM_ENTRY_1 = 0x1,
};

/// LPM invalid transition interrupt enable
/// Register: PCMIE
/// Field: LPM_INVALID_TR_IE [0:0]
enum class PCM_PCMIE_LPM_INVALID_TR_IE : uint32_t {
    LPM_INVALID_TR_IE_0 = 0x0,
    LPM_INVALID_TR_IE_1 = 0x1,
};

/// LPM invalid clock interrupt enable
/// Register: PCMIE
/// Field: LPM_INVALID_CLK_IE [1:1]
enum class PCM_PCMIE_LPM_INVALID_CLK_IE : uint32_t {
    LPM_INVALID_CLK_IE_0 = 0x0,
    LPM_INVALID_CLK_IE_1 = 0x1,
};

/// Active mode invalid transition interrupt enable
/// Register: PCMIE
/// Field: AM_INVALID_TR_IE [2:2]
enum class PCM_PCMIE_AM_INVALID_TR_IE : uint32_t {
    AM_INVALID_TR_IE_0 = 0x0,
    AM_INVALID_TR_IE_1 = 0x1,
};

/// DC-DC error interrupt enable
/// Register: PCMIE
/// Field: DCDC_ERROR_IE [6:6]
enum class PCM_PCMIE_DCDC_ERROR_IE : uint32_t {
    DCDC_ERROR_IE_0 = 0x0,
    DCDC_ERROR_IE_1 = 0x1,
};

// ----------------------------------------------------------------------------
// PMAP - PMAP
// ----------------------------------------------------------------------------

/// Port mapping lock bit
/// Register: PMAPCTL
/// Field: PMAPLOCKED [0:0]
enum class PMAP_PMAPCTL_PMAPLOCKED : uint16_t {
    PMAPLOCKED_0 = 0x0,
    PMAPLOCKED_1 = 0x1,
};

/// Port mapping reconfiguration control bit
/// Register: PMAPCTL
/// Field: PMAPRECFG [1:1]
enum class PMAP_PMAPCTL_PMAPRECFG : uint16_t {
    PMAPRECFG_0 = 0x0,
    PMAPRECFG_1 = 0x1,
};

// ----------------------------------------------------------------------------
// PSS - PSS
// ----------------------------------------------------------------------------

/// SVSM high-side off
/// Register: PSSCTL0
/// Field: SVSMHOFF [0:0]
enum class PSS_PSSCTL0_SVSMHOFF : uint32_t {
    SVSMHOFF_0 = 0x0,
    SVSMHOFF_1 = 0x1,
};

/// SVSM high-side low power normal performance mode
/// Register: PSSCTL0
/// Field: SVSMHLP [1:1]
enum class PSS_PSSCTL0_SVSMHLP : uint32_t {
    SVSMHLP_0 = 0x0,
    SVSMHLP_1 = 0x1,
};

/// Supply supervisor or monitor selection for the high-side
/// Register: PSSCTL0
/// Field: SVSMHS [2:2]
enum class PSS_PSSCTL0_SVSMHS : uint32_t {
    SVSMHS_0 = 0x0,
    SVSMHS_1 = 0x1,
};

/// SVSM high-side output enable
/// Register: PSSCTL0
/// Field: SVMHOE [6:6]
enum class PSS_PSSCTL0_SVMHOE : uint32_t {
    SVMHOE_0 = 0x0,
    SVMHOE_1 = 0x1,
};

/// SVMHOUT pin polarity active low
/// Register: PSSCTL0
/// Field: SVMHOUTPOLAL [7:7]
enum class PSS_PSSCTL0_SVMHOUTPOLAL : uint32_t {
    SVMHOUTPOLAL_0 = 0x0,
    SVMHOUTPOLAL_1 = 0x1,
};

/// Force DC-DC regulator operation
/// Register: PSSCTL0
/// Field: DCDC_FORCE [10:10]
enum class PSS_PSSCTL0_DCDC_FORCE : uint32_t {
    DCDC_FORCE_0 = 0x0,
    DCDC_FORCE_1 = 0x1,
};

/// Controls core voltage level transition time
/// Register: PSSCTL0
/// Field: VCORETRAN [12:13]
enum class PSS_PSSCTL0_VCORETRAN : uint32_t {
    VCORETRAN_0 = 0x0,
    VCORETRAN_1 = 0x1,
    VCORETRAN_2 = 0x2,
    VCORETRAN_3 = 0x3,
};

/// High-side SVSM interrupt enable
/// Register: PSSIE
/// Field: SVSMHIE [1:1]
enum class PSS_PSSIE_SVSMHIE : uint32_t {
    SVSMHIE_0 = 0x0,
    SVSMHIE_1 = 0x1,
};

/// High-side SVSM interrupt flag
/// Register: PSSIFG
/// Field: SVSMHIFG [1:1]
enum class PSS_PSSIFG_SVSMHIFG : uint32_t {
    SVSMHIFG_0 = 0x0,
    SVSMHIFG_1 = 0x1,
};

/// SVSMH clear interrupt flag
/// Register: PSSCLRIFG
/// Field: CLRSVSMHIFG [1:1]
enum class PSS_PSSCLRIFG_CLRSVSMHIFG : uint32_t {
    CLRSVSMHIFG_0 = 0x0,
    CLRSVSMHIFG_1 = 0x1,
};

// ----------------------------------------------------------------------------
// REF_A - REF_A
// ----------------------------------------------------------------------------

/// Reference enable
/// Register: REFCTL0
/// Field: REFON [0:0]
enum class REF_A_REFCTL0_REFON : uint16_t {
    REFON_0 = 0x0,
    REFON_1 = 0x1,
};

/// Reference output buffer
/// Register: REFCTL0
/// Field: REFOUT [1:1]
enum class REF_A_REFCTL0_REFOUT : uint16_t {
    REFOUT_0 = 0x0,
    REFOUT_1 = 0x1,
};

/// Temperature sensor disabled
/// Register: REFCTL0
/// Field: REFTCOFF [3:3]
enum class REF_A_REFCTL0_REFTCOFF : uint16_t {
    REFTCOFF_0 = 0x0,
    REFTCOFF_1 = 0x1,
};

/// Reference voltage level select
/// Register: REFCTL0
/// Field: REFVSEL [4:5]
enum class REF_A_REFCTL0_REFVSEL : uint16_t {
    REFVSEL_0 = 0x0,
    REFVSEL_1 = 0x1,
    REFVSEL_3 = 0x3,
};

/// Reference generator one-time trigger
/// Register: REFCTL0
/// Field: REFGENOT [6:6]
enum class REF_A_REFCTL0_REFGENOT : uint16_t {
    REFGENOT_0 = 0x0,
    REFGENOT_1 = 0x1,
};

/// Bandgap and bandgap buffer one-time trigger
/// Register: REFCTL0
/// Field: REFBGOT [7:7]
enum class REF_A_REFCTL0_REFBGOT : uint16_t {
    REFBGOT_0 = 0x0,
    REFBGOT_1 = 0x1,
};

/// Reference generator active
/// Register: REFCTL0
/// Field: REFGENACT [8:8]
enum class REF_A_REFCTL0_REFGENACT : uint16_t {
    REFGENACT_0 = 0x0,
    REFGENACT_1 = 0x1,
};

/// Reference bandgap active
/// Register: REFCTL0
/// Field: REFBGACT [9:9]
enum class REF_A_REFCTL0_REFBGACT : uint16_t {
    REFBGACT_0 = 0x0,
    REFBGACT_1 = 0x1,
};

/// Reference generator busy
/// Register: REFCTL0
/// Field: REFGENBUSY [10:10]
enum class REF_A_REFCTL0_REFGENBUSY : uint16_t {
    REFGENBUSY_0 = 0x0,
    REFGENBUSY_1 = 0x1,
};

/// Bandgap mode
/// Register: REFCTL0
/// Field: BGMODE [11:11]
enum class REF_A_REFCTL0_BGMODE : uint16_t {
    BGMODE_0 = 0x0,
    BGMODE_1 = 0x1,
};

/// Variable reference voltage ready status
/// Register: REFCTL0
/// Field: REFGENRDY [12:12]
enum class REF_A_REFCTL0_REFGENRDY : uint16_t {
    REFGENRDY_0 = 0x0,
    REFGENRDY_1 = 0x1,
};

/// Buffered bandgap voltage ready status
/// Register: REFCTL0
/// Field: REFBGRDY [13:13]
enum class REF_A_REFCTL0_REFBGRDY : uint16_t {
    REFBGRDY_0 = 0x0,
    REFBGRDY_1 = 0x1,
};

// ----------------------------------------------------------------------------
// RTC_C - RTC_C
// ----------------------------------------------------------------------------

/// Real-time clock ready interrupt flag
/// Register: RTCCTL0
/// Field: RTCRDYIFG [0:0]
enum class RTC_C_RTCCTL0_RTCRDYIFG : uint16_t {
    RTCRDYIFG_0 = 0x0,
    RTCRDYIFG_1 = 0x1,
};

/// Real-time clock alarm interrupt flag
/// Register: RTCCTL0
/// Field: RTCAIFG [1:1]
enum class RTC_C_RTCCTL0_RTCAIFG : uint16_t {
    RTCAIFG_0 = 0x0,
    RTCAIFG_1 = 0x1,
};

/// Real-time clock time event interrupt flag
/// Register: RTCCTL0
/// Field: RTCTEVIFG [2:2]
enum class RTC_C_RTCCTL0_RTCTEVIFG : uint16_t {
    RTCTEVIFG_0 = 0x0,
    RTCTEVIFG_1 = 0x1,
};

/// 32-kHz crystal oscillator fault interrupt flag
/// Register: RTCCTL0
/// Field: RTCOFIFG [3:3]
enum class RTC_C_RTCCTL0_RTCOFIFG : uint16_t {
    RTCOFIFG_0 = 0x0,
    RTCOFIFG_1 = 0x1,
};

/// Real-time clock ready interrupt enable
/// Register: RTCCTL0
/// Field: RTCRDYIE [4:4]
enum class RTC_C_RTCCTL0_RTCRDYIE : uint16_t {
    RTCRDYIE_0 = 0x0,
    RTCRDYIE_1 = 0x1,
};

/// Real-time clock alarm interrupt enable
/// Register: RTCCTL0
/// Field: RTCAIE [5:5]
enum class RTC_C_RTCCTL0_RTCAIE : uint16_t {
    RTCAIE_0 = 0x0,
    RTCAIE_1 = 0x1,
};

/// Real-time clock time event interrupt enable
/// Register: RTCCTL0
/// Field: RTCTEVIE [6:6]
enum class RTC_C_RTCCTL0_RTCTEVIE : uint16_t {
    RTCTEVIE_0 = 0x0,
    RTCTEVIE_1 = 0x1,
};

/// 32-kHz crystal oscillator fault interrupt enable
/// Register: RTCCTL0
/// Field: RTCOFIE [7:7]
enum class RTC_C_RTCCTL0_RTCOFIE : uint16_t {
    RTCOFIE_0 = 0x0,
    RTCOFIE_1 = 0x1,
};

/// Real-time clock time event
/// Register: RTCCTL13
/// Field: RTCTEV [0:1]
enum class RTC_C_RTCCTL13_RTCTEV : uint16_t {
    RTCTEV_0 = 0x0,
    RTCTEV_1 = 0x1,
    RTCTEV_2 = 0x2,
    RTCTEV_3 = 0x3,
};

/// Real-time clock source select
/// Register: RTCCTL13
/// Field: RTCSSEL [2:3]
enum class RTC_C_RTCCTL13_RTCSSEL : uint16_t {
    RTCSSEL_0 = 0x0,
};

/// Real-time clock ready
/// Register: RTCCTL13
/// Field: RTCRDY [4:4]
enum class RTC_C_RTCCTL13_RTCRDY : uint16_t {
    RTCRDY_0 = 0x0,
    RTCRDY_1 = 0x1,
};

/// RTCMODE
/// Register: RTCCTL13
/// Field: RTCMODE [5:5]
enum class RTC_C_RTCCTL13_RTCMODE : uint16_t {
    RTCMODE_1 = 0x1,
};

/// Real-time clock hold
/// Register: RTCCTL13
/// Field: RTCHOLD [6:6]
enum class RTC_C_RTCCTL13_RTCHOLD : uint16_t {
    RTCHOLD_0 = 0x0,
    RTCHOLD_1 = 0x1,
};

/// Real-time clock BCD select
/// Register: RTCCTL13
/// Field: RTCBCD [7:7]
enum class RTC_C_RTCCTL13_RTCBCD : uint16_t {
    RTCBCD_0 = 0x0,
    RTCBCD_1 = 0x1,
};

/// Real-time clock calibration frequency
/// Register: RTCCTL13
/// Field: RTCCALF [8:9]
enum class RTC_C_RTCCTL13_RTCCALF : uint16_t {
    RTCCALF_0 = 0x0,
    RTCCALF_1 = 0x1,
    RTCCALF_2 = 0x2,
    RTCCALF_3 = 0x3,
};

/// Real-time clock offset error calibration sign
/// Register: RTCOCAL
/// Field: RTCOCALS [15:15]
enum class RTC_C_RTCOCAL_RTCOCALS : uint16_t {
    RTCOCALS_0 = 0x0,
    RTCOCALS_1 = 0x1,
};

/// Real-time clock temperature compensation write OK
/// Register: RTCTCMP
/// Field: RTCTCOK [13:13]
enum class RTC_C_RTCTCMP_RTCTCOK : uint16_t {
    RTCTCOK_0 = 0x0,
    RTCTCOK_1 = 0x1,
};

/// Real-time clock temperature compensation sign
/// Register: RTCTCMP
/// Field: RTCTCMPS [15:15]
enum class RTC_C_RTCTCMP_RTCTCMPS : uint16_t {
    RTCTCMPS_0 = 0x0,
    RTCTCMPS_1 = 0x1,
};

/// Prescale timer 0 interrupt flag
/// Register: RTCPS0CTL
/// Field: RT0PSIFG [0:0]
enum class RTC_C_RTCPS0CTL_RT0PSIFG : uint16_t {
    RT0PSIFG_0 = 0x0,
    RT0PSIFG_1 = 0x1,
};

/// Prescale timer 0 interrupt enable
/// Register: RTCPS0CTL
/// Field: RT0PSIE [1:1]
enum class RTC_C_RTCPS0CTL_RT0PSIE : uint16_t {
    RT0PSIE_0 = 0x0,
    RT0PSIE_1 = 0x1,
};

/// Prescale timer 0 interrupt interval
/// Register: RTCPS0CTL
/// Field: RT0IP [2:4]
enum class RTC_C_RTCPS0CTL_RT0IP : uint16_t {
    RT0IP_0 = 0x0,
    RT0IP_1 = 0x1,
    RT0IP_2 = 0x2,
    RT0IP_3 = 0x3,
    RT0IP_4 = 0x4,
    RT0IP_5 = 0x5,
    RT0IP_6 = 0x6,
    RT0IP_7 = 0x7,
};

/// Prescale timer 1 interrupt flag
/// Register: RTCPS1CTL
/// Field: RT1PSIFG [0:0]
enum class RTC_C_RTCPS1CTL_RT1PSIFG : uint16_t {
    RT1PSIFG_0 = 0x0,
    RT1PSIFG_1 = 0x1,
};

/// Prescale timer 1 interrupt enable
/// Register: RTCPS1CTL
/// Field: RT1PSIE [1:1]
enum class RTC_C_RTCPS1CTL_RT1PSIE : uint16_t {
    RT1PSIE_0 = 0x0,
    RT1PSIE_1 = 0x1,
};

/// Prescale timer 1 interrupt interval
/// Register: RTCPS1CTL
/// Field: RT1IP [2:4]
enum class RTC_C_RTCPS1CTL_RT1IP : uint16_t {
    RT1IP_0 = 0x0,
    RT1IP_1 = 0x1,
    RT1IP_2 = 0x2,
    RT1IP_3 = 0x3,
    RT1IP_4 = 0x4,
    RT1IP_5 = 0x5,
    RT1IP_6 = 0x6,
    RT1IP_7 = 0x7,
};

/// Real-time clock interrupt vector value
/// Register: RTCIV
/// Field: RTCIV [0:15]
enum class RTC_C_RTCIV_RTCIV : uint16_t {
    RTCIV_0 = 0x0,
    RTCIV_2 = 0x2,
    RTCIV_4 = 0x4,
    RTCIV_6 = 0x6,
    RTCIV_8 = 0x8,
    RTCIV_10 = 0xA,
    RTCIV_12 = 0xC,
};

// ----------------------------------------------------------------------------
// SYSCTL_A - SYSCTL_A
// ----------------------------------------------------------------------------

/// CS interrupt as a source of NMI
/// Register: SYS_NMI_CTLSTAT
/// Field: CS_SRC [0:0]
enum class SYSCTL_A_SYS_NMI_CTLSTAT_CS_SRC : uint32_t {
    CS_SRC_0 = 0x0,
    CS_SRC_1 = 0x1,
};

/// PSS interrupt as a source of NMI
/// Register: SYS_NMI_CTLSTAT
/// Field: PSS_SRC [1:1]
enum class SYSCTL_A_SYS_NMI_CTLSTAT_PSS_SRC : uint32_t {
    PSS_SRC_0 = 0x0,
    PSS_SRC_1 = 0x1,
};

/// PCM interrupt as a source of NMI
/// Register: SYS_NMI_CTLSTAT
/// Field: PCM_SRC [2:2]
enum class SYSCTL_A_SYS_NMI_CTLSTAT_PCM_SRC : uint32_t {
    PCM_SRC_0 = 0x0,
    PCM_SRC_1 = 0x1,
};

/// RSTn/NMI pin configuration

Note: When the device enters LPM3/LPM4 modes of operation, the functionality selected by this bit is retained. If selected as an NMI, activity on this pin in 

LPM3/LPM4 wakes the device and processes the interrupt, without causing a POR. If selected as a Reset, activity on this pin in LPM3/LPM4 causes a device-level POR

When the device enters LPM3.5/LPM4.5 modes of operation, this bit is always cleared to 0. In other words, the RSTn/NMI pin always assumes a reset functionality in LPM3.5/LPM4.5 modes.
/// Register: SYS_NMI_CTLSTAT
/// Field: PIN_SRC [3:3]
enum class SYSCTL_A_SYS_NMI_CTLSTAT_PIN_SRC : uint32_t {
    PIN_SRC_0 = 0x0,
    PIN_SRC_1 = 0x1,
};

/// CS interrupt was the source of NMI
/// Register: SYS_NMI_CTLSTAT
/// Field: CS_FLG [16:16]
enum class SYSCTL_A_SYS_NMI_CTLSTAT_CS_FLG : uint32_t {
    CS_FLG_0 = 0x0,
    CS_FLG_1 = 0x1,
};

/// PSS interrupt was the source of NMI
/// Register: SYS_NMI_CTLSTAT
/// Field: PSS_FLG [17:17]
enum class SYSCTL_A_SYS_NMI_CTLSTAT_PSS_FLG : uint32_t {
    PSS_FLG_0 = 0x0,
    PSS_FLG_1 = 0x1,
};

/// PCM interrupt was the source of NMI
/// Register: SYS_NMI_CTLSTAT
/// Field: PCM_FLG [18:18]
enum class SYSCTL_A_SYS_NMI_CTLSTAT_PCM_FLG : uint32_t {
    PCM_FLG_0 = 0x0,
    PCM_FLG_1 = 0x1,
};

/// RSTn/NMI pin was the source of NMI
/// Register: SYS_NMI_CTLSTAT
/// Field: PIN_FLG [19:19]
enum class SYSCTL_A_SYS_NMI_CTLSTAT_PIN_FLG : uint32_t {
    PIN_FLG_0 = 0x0,
    PIN_FLG_1 = 0x1,
};

/// WDT timeout reset type
/// Register: SYS_WDTRESET_CTL
/// Field: TIMEOUT [0:0]
enum class SYSCTL_A_SYS_WDTRESET_CTL_TIMEOUT : uint32_t {
    TIMEOUT_0 = 0x0,
    TIMEOUT_1 = 0x1,
};

/// WDT password violation reset type
/// Register: SYS_WDTRESET_CTL
/// Field: VIOLATION [1:1]
enum class SYSCTL_A_SYS_WDTRESET_CTL_VIOLATION : uint32_t {
    VIOLATION_0 = 0x0,
    VIOLATION_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_T16_0 [0:0]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_T16_0 : uint32_t {
    HALT_T16_0_0 = 0x0,
    HALT_T16_0_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_T16_1 [1:1]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_T16_1 : uint32_t {
    HALT_T16_1_0 = 0x0,
    HALT_T16_1_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_T16_2 [2:2]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_T16_2 : uint32_t {
    HALT_T16_2_0 = 0x0,
    HALT_T16_2_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_T16_3 [3:3]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_T16_3 : uint32_t {
    HALT_T16_3_0 = 0x0,
    HALT_T16_3_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_T32_0 [4:4]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_T32_0 : uint32_t {
    HALT_T32_0_0 = 0x0,
    HALT_T32_0_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_eUA0 [5:5]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_EUA0 : uint32_t {
    HALT_eUA0_0 = 0x0,
    HALT_eUA0_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_eUA1 [6:6]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_EUA1 : uint32_t {
    HALT_eUA1_0 = 0x0,
    HALT_eUA1_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_eUA2 [7:7]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_EUA2 : uint32_t {
    HALT_eUA2_0 = 0x0,
    HALT_eUA2_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_eUA3 [8:8]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_EUA3 : uint32_t {
    HALT_eUA3_0 = 0x0,
    HALT_eUA3_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_eUB0 [9:9]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_EUB0 : uint32_t {
    HALT_eUB0_0 = 0x0,
    HALT_eUB0_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_eUB1 [10:10]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_EUB1 : uint32_t {
    HALT_eUB1_0 = 0x0,
    HALT_eUB1_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_eUB2 [11:11]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_EUB2 : uint32_t {
    HALT_eUB2_0 = 0x0,
    HALT_eUB2_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_eUB3 [12:12]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_EUB3 : uint32_t {
    HALT_eUB3_0 = 0x0,
    HALT_eUB3_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_ADC [13:13]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_ADC : uint32_t {
    HALT_ADC_0 = 0x0,
    HALT_ADC_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_WDT [14:14]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_WDT : uint32_t {
    HALT_WDT_0 = 0x0,
    HALT_WDT_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_DMA [15:15]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_DMA : uint32_t {
    HALT_DMA_0 = 0x0,
    HALT_DMA_1 = 0x1,
};

/// Freezes IP operation when CPU is halted
/// Register: SYS_PERIHALT_CTL
/// Field: HALT_LCD [16:16]
enum class SYSCTL_A_SYS_PERIHALT_CTL_HALT_LCD : uint32_t {
    HALT_LCD_0 = 0x0,
    HALT_LCD_1 = 0x1,
};

/// Glitch filter enable
/// Register: SYS_DIO_GLTFLT_CTL
/// Field: GLTCH_EN [0:0]
enum class SYSCTL_A_SYS_DIO_GLTFLT_CTL_GLTCH_EN : uint32_t {
    GLTCH_EN_0 = 0x0,
    GLTCH_EN_1 = 0x1,
};

/// When 1, enables Bank1 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK1_EN [1:1]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK1_EN : uint32_t {
    BNK1_EN_0 = 0x0,
    BNK1_EN_1 = 0x1,
};

/// When 1, enables Bank2 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK2_EN [2:2]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK2_EN : uint32_t {
    BNK2_EN_0 = 0x0,
    BNK2_EN_1 = 0x1,
};

/// When 1, enables Bank3 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK3_EN [3:3]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK3_EN : uint32_t {
    BNK3_EN_0 = 0x0,
    BNK3_EN_1 = 0x1,
};

/// When 1, enables Bank4 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK4_EN [4:4]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK4_EN : uint32_t {
    BNK4_EN_0 = 0x0,
    BNK4_EN_1 = 0x1,
};

/// When 1, enables Bank5 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK5_EN [5:5]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK5_EN : uint32_t {
    BNK5_EN_0 = 0x0,
    BNK5_EN_1 = 0x1,
};

/// When 1, enables Bank6 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK6_EN [6:6]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK6_EN : uint32_t {
    BNK6_EN_0 = 0x0,
    BNK6_EN_1 = 0x1,
};

/// When 1, enables Bank7 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK7_EN [7:7]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK7_EN : uint32_t {
    BNK7_EN_0 = 0x0,
    BNK7_EN_1 = 0x1,
};

/// When 1, enables Bank8 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK8_EN [8:8]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK8_EN : uint32_t {
    BNK8_EN_0 = 0x0,
    BNK8_EN_1 = 0x1,
};

/// When 1, enables Bank9 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK9_EN [9:9]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK9_EN : uint32_t {
    BNK9_EN_0 = 0x0,
    BNK9_EN_1 = 0x1,
};

/// When 1, enables Bank10 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK10_EN [10:10]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK10_EN : uint32_t {
    BNK10_EN_0 = 0x0,
    BNK10_EN_1 = 0x1,
};

/// When 1, enables Bank11 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK11_EN [11:11]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK11_EN : uint32_t {
    BNK11_EN_0 = 0x0,
    BNK11_EN_1 = 0x1,
};

/// When 1, enables Bank12 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK12_EN [12:12]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK12_EN : uint32_t {
    BNK12_EN_0 = 0x0,
    BNK12_EN_1 = 0x1,
};

/// When 1, enables Bank13 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK13_EN [13:13]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK13_EN : uint32_t {
    BNK13_EN_0 = 0x0,
    BNK13_EN_1 = 0x1,
};

/// When 1, enables Bank14 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK14_EN [14:14]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK14_EN : uint32_t {
    BNK14_EN_0 = 0x0,
    BNK14_EN_1 = 0x1,
};

/// When 1, enables Bank15 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK15_EN [15:15]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK15_EN : uint32_t {
    BNK15_EN_0 = 0x0,
    BNK15_EN_1 = 0x1,
};

/// When 1, enables Bank16 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK16_EN [16:16]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK16_EN : uint32_t {
    BNK16_EN_0 = 0x0,
    BNK16_EN_1 = 0x1,
};

/// When 1, enables Bank17 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK17_EN [17:17]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK17_EN : uint32_t {
    BNK17_EN_0 = 0x0,
    BNK17_EN_1 = 0x1,
};

/// When 1, enables Bank18 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK18_EN [18:18]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK18_EN : uint32_t {
    BNK18_EN_0 = 0x0,
    BNK18_EN_1 = 0x1,
};

/// When 1, enables Bank19 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK19_EN [19:19]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK19_EN : uint32_t {
    BNK19_EN_0 = 0x0,
    BNK19_EN_1 = 0x1,
};

/// When 1, enables Bank20 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK20_EN [20:20]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK20_EN : uint32_t {
    BNK20_EN_0 = 0x0,
    BNK20_EN_1 = 0x1,
};

/// When 1, enables Bank21 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK21_EN [21:21]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK21_EN : uint32_t {
    BNK21_EN_0 = 0x0,
    BNK21_EN_1 = 0x1,
};

/// When 1, enables Bank22 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK22_EN [22:22]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK22_EN : uint32_t {
    BNK22_EN_0 = 0x0,
    BNK22_EN_1 = 0x1,
};

/// When 1, enables Bank23 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK23_EN [23:23]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK23_EN : uint32_t {
    BNK23_EN_0 = 0x0,
    BNK23_EN_1 = 0x1,
};

/// When 1, enables Bank24 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK24_EN [24:24]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK24_EN : uint32_t {
    BNK24_EN_0 = 0x0,
    BNK24_EN_1 = 0x1,
};

/// When 1, enables Bank25 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK25_EN [25:25]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK25_EN : uint32_t {
    BNK25_EN_0 = 0x0,
    BNK25_EN_1 = 0x1,
};

/// When 1, enables Bank26 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK26_EN [26:26]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK26_EN : uint32_t {
    BNK26_EN_0 = 0x0,
    BNK26_EN_1 = 0x1,
};

/// When 1, enables Bank27 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK27_EN [27:27]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK27_EN : uint32_t {
    BNK27_EN_0 = 0x0,
    BNK27_EN_1 = 0x1,
};

/// When 1, enables Bank28 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK28_EN [28:28]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK28_EN : uint32_t {
    BNK28_EN_0 = 0x0,
    BNK28_EN_1 = 0x1,
};

/// When 1, enables Bank29 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK29_EN [29:29]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK29_EN : uint32_t {
    BNK29_EN_0 = 0x0,
    BNK29_EN_1 = 0x1,
};

/// When 1, enables Bank30 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK30_EN [30:30]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK30_EN : uint32_t {
    BNK30_EN_0 = 0x0,
    BNK30_EN_1 = 0x1,
};

/// When 1, enables Bank31 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL0
/// Field: BNK31_EN [31:31]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL0_BNK31_EN : uint32_t {
    BNK31_EN_0 = 0x0,
    BNK31_EN_1 = 0x1,
};

/// When 1, enables Bank32 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK32_EN [0:0]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK32_EN : uint32_t {
    BNK32_EN_0 = 0x0,
    BNK32_EN_1 = 0x1,
};

/// When 1, enables Bank33 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK33_EN [1:1]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK33_EN : uint32_t {
    BNK33_EN_0 = 0x0,
    BNK33_EN_1 = 0x1,
};

/// When 1, enables Bank34 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK34_EN [2:2]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK34_EN : uint32_t {
    BNK34_EN_0 = 0x0,
    BNK34_EN_1 = 0x1,
};

/// When 1, enables Bank35 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK35_EN [3:3]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK35_EN : uint32_t {
    BNK35_EN_0 = 0x0,
    BNK35_EN_1 = 0x1,
};

/// When 1, enables Bank36 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK36_EN [4:4]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK36_EN : uint32_t {
    BNK36_EN_0 = 0x0,
    BNK36_EN_1 = 0x1,
};

/// When 1, enables Bank37 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK37_EN [5:5]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK37_EN : uint32_t {
    BNK37_EN_0 = 0x0,
    BNK37_EN_1 = 0x1,
};

/// When 1, enables Bank38 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK38_EN [6:6]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK38_EN : uint32_t {
    BNK38_EN_0 = 0x0,
    BNK38_EN_1 = 0x1,
};

/// When 1, enables Bank39 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK39_EN [7:7]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK39_EN : uint32_t {
    BNK39_EN_0 = 0x0,
    BNK39_EN_1 = 0x1,
};

/// When 1, enables Bank40 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK40_EN [8:8]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK40_EN : uint32_t {
    BNK40_EN_0 = 0x0,
    BNK40_EN_1 = 0x1,
};

/// When 1, enables Bank41 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK41_EN [9:9]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK41_EN : uint32_t {
    BNK41_EN_0 = 0x0,
    BNK41_EN_1 = 0x1,
};

/// When 1, enables Bank42 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK42_EN [10:10]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK42_EN : uint32_t {
    BNK42_EN_0 = 0x0,
    BNK42_EN_1 = 0x1,
};

/// When 1, enables Bank43 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK43_EN [11:11]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK43_EN : uint32_t {
    BNK43_EN_0 = 0x0,
    BNK43_EN_1 = 0x1,
};

/// When 1, enables Bank44 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK44_EN [12:12]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK44_EN : uint32_t {
    BNK44_EN_0 = 0x0,
    BNK44_EN_1 = 0x1,
};

/// When 1, enables Bank45 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK45_EN [13:13]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK45_EN : uint32_t {
    BNK45_EN_0 = 0x0,
    BNK45_EN_1 = 0x1,
};

/// When 1, enables Bank46 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK46_EN [14:14]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK46_EN : uint32_t {
    BNK46_EN_0 = 0x0,
    BNK46_EN_1 = 0x1,
};

/// When 1, enables Bank47 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK47_EN [15:15]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK47_EN : uint32_t {
    BNK47_EN_0 = 0x0,
    BNK47_EN_1 = 0x1,
};

/// When 1, enables Bank48 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK48_EN [16:16]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK48_EN : uint32_t {
    BNK48_EN_0 = 0x0,
    BNK48_EN_1 = 0x1,
};

/// When 1, enables Bank49 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK49_EN [17:17]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK49_EN : uint32_t {
    BNK49_EN_0 = 0x0,
    BNK49_EN_1 = 0x1,
};

/// When 1, enables Bank50 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK50_EN [18:18]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK50_EN : uint32_t {
    BNK50_EN_0 = 0x0,
    BNK50_EN_1 = 0x1,
};

/// When 1, enables Bank51 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK51_EN [19:19]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK51_EN : uint32_t {
    BNK51_EN_0 = 0x0,
    BNK51_EN_1 = 0x1,
};

/// When 1, enables Bank52 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK52_EN [20:20]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK52_EN : uint32_t {
    BNK52_EN_0 = 0x0,
    BNK52_EN_1 = 0x1,
};

/// When 1, enables Bank53 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK53_EN [21:21]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK53_EN : uint32_t {
    BNK53_EN_0 = 0x0,
    BNK53_EN_1 = 0x1,
};

/// When 1, enables Bank54 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK54_EN [22:22]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK54_EN : uint32_t {
    BNK54_EN_0 = 0x0,
    BNK54_EN_1 = 0x1,
};

/// When 1, enables Bank55 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK55_EN [23:23]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK55_EN : uint32_t {
    BNK55_EN_0 = 0x0,
    BNK55_EN_1 = 0x1,
};

/// When 1, enables Bank56 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK56_EN [24:24]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK56_EN : uint32_t {
    BNK56_EN_0 = 0x0,
    BNK56_EN_1 = 0x1,
};

/// When 1, enables Bank57 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK57_EN [25:25]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK57_EN : uint32_t {
    BNK57_EN_0 = 0x0,
    BNK57_EN_1 = 0x1,
};

/// When 1, enables Bank58 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK58_EN [26:26]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK58_EN : uint32_t {
    BNK58_EN_0 = 0x0,
    BNK58_EN_1 = 0x1,
};

/// When 1, enables Bank59 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK59_EN [27:27]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK59_EN : uint32_t {
    BNK59_EN_0 = 0x0,
    BNK59_EN_1 = 0x1,
};

/// When 1, enables Bank60 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK60_EN [28:28]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK60_EN : uint32_t {
    BNK60_EN_0 = 0x0,
    BNK60_EN_1 = 0x1,
};

/// When 1, enables Bank61 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK61_EN [29:29]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK61_EN : uint32_t {
    BNK61_EN_0 = 0x0,
    BNK61_EN_1 = 0x1,
};

/// When 1, enables Bank62 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK62_EN [30:30]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK62_EN : uint32_t {
    BNK62_EN_0 = 0x0,
    BNK62_EN_1 = 0x1,
};

/// When 1, enables Bank63 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL1
/// Field: BNK63_EN [31:31]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL1_BNK63_EN : uint32_t {
    BNK63_EN_0 = 0x0,
    BNK63_EN_1 = 0x1,
};

/// When 1, enables Bank64 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK64_EN [0:0]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK64_EN : uint32_t {
    BNK64_EN_0 = 0x0,
    BNK64_EN_1 = 0x1,
};

/// When 1, enables Bank65 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK65_EN [1:1]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK65_EN : uint32_t {
    BNK65_EN_0 = 0x0,
    BNK65_EN_1 = 0x1,
};

/// When 1, enables Bank66 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK66_EN [2:2]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK66_EN : uint32_t {
    BNK66_EN_0 = 0x0,
    BNK66_EN_1 = 0x1,
};

/// When 1, enables Bank67 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK67_EN [3:3]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK67_EN : uint32_t {
    BNK67_EN_0 = 0x0,
    BNK67_EN_1 = 0x1,
};

/// When 1, enables Bank68 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK68_EN [4:4]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK68_EN : uint32_t {
    BNK68_EN_0 = 0x0,
    BNK68_EN_1 = 0x1,
};

/// When 1, enables Bank69 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK69_EN [5:5]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK69_EN : uint32_t {
    BNK69_EN_0 = 0x0,
    BNK69_EN_1 = 0x1,
};

/// When 1, enables Bank70 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK70_EN [6:6]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK70_EN : uint32_t {
    BNK70_EN_0 = 0x0,
    BNK70_EN_1 = 0x1,
};

/// When 1, enables Bank71 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK71_EN [7:7]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK71_EN : uint32_t {
    BNK71_EN_0 = 0x0,
    BNK71_EN_1 = 0x1,
};

/// When 1, enables Bank72 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK72_EN [8:8]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK72_EN : uint32_t {
    BNK72_EN_0 = 0x0,
    BNK72_EN_1 = 0x1,
};

/// When 1, enables Bank73 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK73_EN [9:9]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK73_EN : uint32_t {
    BNK73_EN_0 = 0x0,
    BNK73_EN_1 = 0x1,
};

/// When 1, enables Bank74 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK74_EN [10:10]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK74_EN : uint32_t {
    BNK74_EN_0 = 0x0,
    BNK74_EN_1 = 0x1,
};

/// When 1, enables Bank75 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK75_EN [11:11]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK75_EN : uint32_t {
    BNK75_EN_0 = 0x0,
    BNK75_EN_1 = 0x1,
};

/// When 1, enables Bank76 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK76_EN [12:12]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK76_EN : uint32_t {
    BNK76_EN_0 = 0x0,
    BNK76_EN_1 = 0x1,
};

/// When 1, enables Bank77 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK77_EN [13:13]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK77_EN : uint32_t {
    BNK77_EN_0 = 0x0,
    BNK77_EN_1 = 0x1,
};

/// When 1, enables Bank78 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK78_EN [14:14]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK78_EN : uint32_t {
    BNK78_EN_0 = 0x0,
    BNK78_EN_1 = 0x1,
};

/// When 1, enables Bank79 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK79_EN [15:15]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK79_EN : uint32_t {
    BNK79_EN_0 = 0x0,
    BNK79_EN_1 = 0x1,
};

/// When 1, enables Bank80 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK80_EN [16:16]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK80_EN : uint32_t {
    BNK80_EN_0 = 0x0,
    BNK80_EN_1 = 0x1,
};

/// When 1, enables Bank81 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK81_EN [17:17]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK81_EN : uint32_t {
    BNK81_EN_0 = 0x0,
    BNK81_EN_1 = 0x1,
};

/// When 1, enables Bank82 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK82_EN [18:18]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK82_EN : uint32_t {
    BNK82_EN_0 = 0x0,
    BNK82_EN_1 = 0x1,
};

/// When 1, enables Bank83 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK83_EN [19:19]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK83_EN : uint32_t {
    BNK83_EN_0 = 0x0,
    BNK83_EN_1 = 0x1,
};

/// When 1, enables Bank84 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK84_EN [20:20]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK84_EN : uint32_t {
    BNK84_EN_0 = 0x0,
    BNK84_EN_1 = 0x1,
};

/// When 1, enables Bank85 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK85_EN [21:21]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK85_EN : uint32_t {
    BNK85_EN_0 = 0x0,
    BNK85_EN_1 = 0x1,
};

/// When 1, enables Bank86 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK86_EN [22:22]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK86_EN : uint32_t {
    BNK86_EN_0 = 0x0,
    BNK86_EN_1 = 0x1,
};

/// When 1, enables Bank87 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK87_EN [23:23]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK87_EN : uint32_t {
    BNK87_EN_0 = 0x0,
    BNK87_EN_1 = 0x1,
};

/// When 1, enables Bank88 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK88_EN [24:24]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK88_EN : uint32_t {
    BNK88_EN_0 = 0x0,
    BNK88_EN_1 = 0x1,
};

/// When 1, enables Bank89 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK89_EN [25:25]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK89_EN : uint32_t {
    BNK89_EN_0 = 0x0,
    BNK89_EN_1 = 0x1,
};

/// When 1, enables Bank90 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK90_EN [26:26]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK90_EN : uint32_t {
    BNK90_EN_0 = 0x0,
    BNK90_EN_1 = 0x1,
};

/// When 1, enables Bank91 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK91_EN [27:27]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK91_EN : uint32_t {
    BNK91_EN_0 = 0x0,
    BNK91_EN_1 = 0x1,
};

/// When 1, enables Bank92 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK92_EN [28:28]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK92_EN : uint32_t {
    BNK92_EN_0 = 0x0,
    BNK92_EN_1 = 0x1,
};

/// When 1, enables Bank93 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK93_EN [29:29]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK93_EN : uint32_t {
    BNK93_EN_0 = 0x0,
    BNK93_EN_1 = 0x1,
};

/// When 1, enables Bank94 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK94_EN [30:30]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK94_EN : uint32_t {
    BNK94_EN_0 = 0x0,
    BNK94_EN_1 = 0x1,
};

/// When 1, enables Bank95 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL2
/// Field: BNK95_EN [31:31]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL2_BNK95_EN : uint32_t {
    BNK95_EN_0 = 0x0,
    BNK95_EN_1 = 0x1,
};

/// When 1, enables Bank96 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK96_EN [0:0]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK96_EN : uint32_t {
    BNK96_EN_0 = 0x0,
    BNK96_EN_1 = 0x1,
};

/// When 1, enables Bank97 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK97_EN [1:1]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK97_EN : uint32_t {
    BNK97_EN_0 = 0x0,
    BNK97_EN_1 = 0x1,
};

/// When 1, enables Bank98 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK98_EN [2:2]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK98_EN : uint32_t {
    BNK98_EN_0 = 0x0,
    BNK98_EN_1 = 0x1,
};

/// When 1, enables Bank99 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK99_EN [3:3]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK99_EN : uint32_t {
    BNK99_EN_0 = 0x0,
    BNK99_EN_1 = 0x1,
};

/// When 1, enables Bank100 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK100_EN [4:4]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK100_EN : uint32_t {
    BNK100_EN_0 = 0x0,
    BNK100_EN_1 = 0x1,
};

/// When 1, enables Bank101 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK101_EN [5:5]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK101_EN : uint32_t {
    BNK101_EN_0 = 0x0,
    BNK101_EN_1 = 0x1,
};

/// When 1, enables Bank102 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK102_EN [6:6]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK102_EN : uint32_t {
    BNK102_EN_0 = 0x0,
    BNK102_EN_1 = 0x1,
};

/// When 1, enables Bank103 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK103_EN [7:7]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK103_EN : uint32_t {
    BNK103_EN_0 = 0x0,
    BNK103_EN_1 = 0x1,
};

/// When 1, enables Bank104 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK104_EN [8:8]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK104_EN : uint32_t {
    BNK104_EN_0 = 0x0,
    BNK104_EN_1 = 0x1,
};

/// When 1, enables Bank105 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK105_EN [9:9]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK105_EN : uint32_t {
    BNK105_EN_0 = 0x0,
    BNK105_EN_1 = 0x1,
};

/// When 1, enables Bank106 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK106_EN [10:10]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK106_EN : uint32_t {
    BNK106_EN_0 = 0x0,
    BNK106_EN_1 = 0x1,
};

/// When 1, enables Bank107 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK107_EN [11:11]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK107_EN : uint32_t {
    BNK107_EN_0 = 0x0,
    BNK107_EN_1 = 0x1,
};

/// When 1, enables Bank108 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK108_EN [12:12]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK108_EN : uint32_t {
    BNK108_EN_0 = 0x0,
    BNK108_EN_1 = 0x1,
};

/// When 1, enables Bank109 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK109_EN [13:13]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK109_EN : uint32_t {
    BNK109_EN_0 = 0x0,
    BNK109_EN_1 = 0x1,
};

/// When 1, enables Bank110 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK110_EN [14:14]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK110_EN : uint32_t {
    BNK110_EN_0 = 0x0,
    BNK110_EN_1 = 0x1,
};

/// When 1, enables Bank111 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK111_EN [15:15]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK111_EN : uint32_t {
    BNK111_EN_0 = 0x0,
    BNK111_EN_1 = 0x1,
};

/// When 1, enables Bank112 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK112_EN [16:16]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK112_EN : uint32_t {
    BNK112_EN_0 = 0x0,
    BNK112_EN_1 = 0x1,
};

/// When 1, enables Bank113 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK113_EN [17:17]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK113_EN : uint32_t {
    BNK113_EN_0 = 0x0,
    BNK113_EN_1 = 0x1,
};

/// When 1, enables Bank114 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK114_EN [18:18]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK114_EN : uint32_t {
    BNK114_EN_0 = 0x0,
    BNK114_EN_1 = 0x1,
};

/// When 1, enables Bank115 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK115_EN [19:19]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK115_EN : uint32_t {
    BNK115_EN_0 = 0x0,
    BNK115_EN_1 = 0x1,
};

/// When 1, enables Bank116 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK116_EN [20:20]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK116_EN : uint32_t {
    BNK116_EN_0 = 0x0,
    BNK116_EN_1 = 0x1,
};

/// When 1, enables Bank117 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK117_EN [21:21]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK117_EN : uint32_t {
    BNK117_EN_0 = 0x0,
    BNK117_EN_1 = 0x1,
};

/// When 1, enables Bank118 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK118_EN [22:22]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK118_EN : uint32_t {
    BNK118_EN_0 = 0x0,
    BNK118_EN_1 = 0x1,
};

/// When 1, enables Bank119 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK119_EN [23:23]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK119_EN : uint32_t {
    BNK119_EN_0 = 0x0,
    BNK119_EN_1 = 0x1,
};

/// When 1, enables Bank120 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK120_EN [24:24]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK120_EN : uint32_t {
    BNK120_EN_0 = 0x0,
    BNK120_EN_1 = 0x1,
};

/// When 1, enables Bank121 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK121_EN [25:25]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK121_EN : uint32_t {
    BNK121_EN_0 = 0x0,
    BNK121_EN_1 = 0x1,
};

/// When 1, enables Bank122 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK122_EN [26:26]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK122_EN : uint32_t {
    BNK122_EN_0 = 0x0,
    BNK122_EN_1 = 0x1,
};

/// When 1, enables Bank123 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK123_EN [27:27]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK123_EN : uint32_t {
    BNK123_EN_0 = 0x0,
    BNK123_EN_1 = 0x1,
};

/// When 1, enables Bank124 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK124_EN [28:28]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK124_EN : uint32_t {
    BNK124_EN_0 = 0x0,
    BNK124_EN_1 = 0x1,
};

/// When 1, enables Bank125 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK125_EN [29:29]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK125_EN : uint32_t {
    BNK125_EN_0 = 0x0,
    BNK125_EN_1 = 0x1,
};

/// When 1, enables Bank126 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK126_EN [30:30]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK126_EN : uint32_t {
    BNK126_EN_0 = 0x0,
    BNK126_EN_1 = 0x1,
};

/// When 1, enables Bank127 of the SRAM
/// Register: SYS_SRAM_BANKEN_CTL3
/// Field: BNK127_EN [31:31]
enum class SYSCTL_A_SYS_SRAM_BANKEN_CTL3_BNK127_EN : uint32_t {
    BNK127_EN_0 = 0x0,
    BNK127_EN_1 = 0x1,
};

/// When 1, Block1 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK1_EN [1:1]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK1_EN : uint32_t {
    BLK1_EN_0 = 0x0,
    BLK1_EN_1 = 0x1,
};

/// When 1, Block2 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK2_EN [2:2]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK2_EN : uint32_t {
    BLK2_EN_0 = 0x0,
    BLK2_EN_1 = 0x1,
};

/// When 1, Block3 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK3_EN [3:3]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK3_EN : uint32_t {
    BLK3_EN_0 = 0x0,
    BLK3_EN_1 = 0x1,
};

/// When 1, Block4 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK4_EN [4:4]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK4_EN : uint32_t {
    BLK4_EN_0 = 0x0,
    BLK4_EN_1 = 0x1,
};

/// When 1, Block5 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK5_EN [5:5]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK5_EN : uint32_t {
    BLK5_EN_0 = 0x0,
    BLK5_EN_1 = 0x1,
};

/// When 1, Block6 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK6_EN [6:6]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK6_EN : uint32_t {
    BLK6_EN_0 = 0x0,
    BLK6_EN_1 = 0x1,
};

/// When 1, Block7 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK7_EN [7:7]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK7_EN : uint32_t {
    BLK7_EN_0 = 0x0,
    BLK7_EN_1 = 0x1,
};

/// When 1, Block8 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK8_EN [8:8]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK8_EN : uint32_t {
    BLK8_EN_0 = 0x0,
    BLK8_EN_1 = 0x1,
};

/// When 1, Block9 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK9_EN [9:9]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK9_EN : uint32_t {
    BLK9_EN_0 = 0x0,
    BLK9_EN_1 = 0x1,
};

/// When 1, Block10 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK10_EN [10:10]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK10_EN : uint32_t {
    BLK10_EN_0 = 0x0,
    BLK10_EN_1 = 0x1,
};

/// When 1, Block11 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK11_EN [11:11]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK11_EN : uint32_t {
    BLK11_EN_0 = 0x0,
    BLK11_EN_1 = 0x1,
};

/// When 1, Block12 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK12_EN [12:12]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK12_EN : uint32_t {
    BLK12_EN_0 = 0x0,
    BLK12_EN_1 = 0x1,
};

/// When 1, Block13 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK13_EN [13:13]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK13_EN : uint32_t {
    BLK13_EN_0 = 0x0,
    BLK13_EN_1 = 0x1,
};

/// When 1, Block14 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK14_EN [14:14]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK14_EN : uint32_t {
    BLK14_EN_0 = 0x0,
    BLK14_EN_1 = 0x1,
};

/// When 1, Block15 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK15_EN [15:15]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK15_EN : uint32_t {
    BLK15_EN_0 = 0x0,
    BLK15_EN_1 = 0x1,
};

/// When 1, Block16 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK16_EN [16:16]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK16_EN : uint32_t {
    BLK16_EN_0 = 0x0,
    BLK16_EN_1 = 0x1,
};

/// When 1, Block17 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK17_EN [17:17]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK17_EN : uint32_t {
    BLK17_EN_0 = 0x0,
    BLK17_EN_1 = 0x1,
};

/// When 1, Block18 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK18_EN [18:18]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK18_EN : uint32_t {
    BLK18_EN_0 = 0x0,
    BLK18_EN_1 = 0x1,
};

/// When 1, Block19 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK19_EN [19:19]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK19_EN : uint32_t {
    BLK19_EN_0 = 0x0,
    BLK19_EN_1 = 0x1,
};

/// When 1, Block20 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK20_EN [20:20]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK20_EN : uint32_t {
    BLK20_EN_0 = 0x0,
    BLK20_EN_1 = 0x1,
};

/// When 1, Block21 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK21_EN [21:21]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK21_EN : uint32_t {
    BLK21_EN_0 = 0x0,
    BLK21_EN_1 = 0x1,
};

/// When 1, Block22 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK22_EN [22:22]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK22_EN : uint32_t {
    BLK22_EN_0 = 0x0,
    BLK22_EN_1 = 0x1,
};

/// When 1, Block23 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK23_EN [23:23]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK23_EN : uint32_t {
    BLK23_EN_0 = 0x0,
    BLK23_EN_1 = 0x1,
};

/// When 1, Block24 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK24_EN [24:24]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK24_EN : uint32_t {
    BLK24_EN_0 = 0x0,
    BLK24_EN_1 = 0x1,
};

/// When 1, Block25 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK25_EN [25:25]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK25_EN : uint32_t {
    BLK25_EN_0 = 0x0,
    BLK25_EN_1 = 0x1,
};

/// When 1, Block26 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK26_EN [26:26]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK26_EN : uint32_t {
    BLK26_EN_0 = 0x0,
    BLK26_EN_1 = 0x1,
};

/// When 1, Block27 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK27_EN [27:27]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK27_EN : uint32_t {
    BLK27_EN_0 = 0x0,
    BLK27_EN_1 = 0x1,
};

/// When 1, Block28 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK28_EN [28:28]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK28_EN : uint32_t {
    BLK28_EN_0 = 0x0,
    BLK28_EN_1 = 0x1,
};

/// When 1, Block29 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK29_EN [29:29]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK29_EN : uint32_t {
    BLK29_EN_0 = 0x0,
    BLK29_EN_1 = 0x1,
};

/// When 1, Block30 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK30_EN [30:30]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK30_EN : uint32_t {
    BLK30_EN_0 = 0x0,
    BLK30_EN_1 = 0x1,
};

/// When 1, Block31 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL0
/// Field: BLK31_EN [31:31]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL0_BLK31_EN : uint32_t {
    BLK31_EN_0 = 0x0,
    BLK31_EN_1 = 0x1,
};

/// When 1, Block32 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK32_EN [0:0]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK32_EN : uint32_t {
    BLK32_EN_0 = 0x0,
    BLK32_EN_1 = 0x1,
};

/// When 1, Block33 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK33_EN [1:1]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK33_EN : uint32_t {
    BLK33_EN_0 = 0x0,
    BLK33_EN_1 = 0x1,
};

/// When 1, Block34 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK34_EN [2:2]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK34_EN : uint32_t {
    BLK34_EN_0 = 0x0,
    BLK34_EN_1 = 0x1,
};

/// When 1, Block35 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK35_EN [3:3]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK35_EN : uint32_t {
    BLK35_EN_0 = 0x0,
    BLK35_EN_1 = 0x1,
};

/// When 1, Block36 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK36_EN [4:4]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK36_EN : uint32_t {
    BLK36_EN_0 = 0x0,
    BLK36_EN_1 = 0x1,
};

/// When 1, Block37 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK37_EN [5:5]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK37_EN : uint32_t {
    BLK37_EN_0 = 0x0,
    BLK37_EN_1 = 0x1,
};

/// When 1, Block38 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK38_EN [6:6]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK38_EN : uint32_t {
    BLK38_EN_0 = 0x0,
    BLK38_EN_1 = 0x1,
};

/// When 1, Block39 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK39_EN [7:7]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK39_EN : uint32_t {
    BLK39_EN_0 = 0x0,
    BLK39_EN_1 = 0x1,
};

/// When 1, Block40 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK40_EN [8:8]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK40_EN : uint32_t {
    BLK40_EN_0 = 0x0,
    BLK40_EN_1 = 0x1,
};

/// When 1, Block41 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK41_EN [9:9]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK41_EN : uint32_t {
    BLK41_EN_0 = 0x0,
    BLK41_EN_1 = 0x1,
};

/// When 1, Block42 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK42_EN [10:10]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK42_EN : uint32_t {
    BLK42_EN_0 = 0x0,
    BLK42_EN_1 = 0x1,
};

/// When 1, Block43 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK43_EN [11:11]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK43_EN : uint32_t {
    BLK43_EN_0 = 0x0,
    BLK43_EN_1 = 0x1,
};

/// When 1, Block44 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK44_EN [12:12]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK44_EN : uint32_t {
    BLK44_EN_0 = 0x0,
    BLK44_EN_1 = 0x1,
};

/// When 1, Block45 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK45_EN [13:13]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK45_EN : uint32_t {
    BLK45_EN_0 = 0x0,
    BLK45_EN_1 = 0x1,
};

/// When 1, Block46 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK46_EN [14:14]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK46_EN : uint32_t {
    BLK46_EN_0 = 0x0,
    BLK46_EN_1 = 0x1,
};

/// When 1, Block47 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK47_EN [15:15]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK47_EN : uint32_t {
    BLK47_EN_0 = 0x0,
    BLK47_EN_1 = 0x1,
};

/// When 1, Block48 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK48_EN [16:16]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK48_EN : uint32_t {
    BLK48_EN_0 = 0x0,
    BLK48_EN_1 = 0x1,
};

/// When 1, Block49 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK49_EN [17:17]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK49_EN : uint32_t {
    BLK49_EN_0 = 0x0,
    BLK49_EN_1 = 0x1,
};

/// When 1, Block50 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK50_EN [18:18]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK50_EN : uint32_t {
    BLK50_EN_0 = 0x0,
    BLK50_EN_1 = 0x1,
};

/// When 1, Block51 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK51_EN [19:19]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK51_EN : uint32_t {
    BLK51_EN_0 = 0x0,
    BLK51_EN_1 = 0x1,
};

/// When 1, Block52 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK52_EN [20:20]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK52_EN : uint32_t {
    BLK52_EN_0 = 0x0,
    BLK52_EN_1 = 0x1,
};

/// When 1, Block53 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK53_EN [21:21]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK53_EN : uint32_t {
    BLK53_EN_0 = 0x0,
    BLK53_EN_1 = 0x1,
};

/// When 1, Block54 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK54_EN [22:22]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK54_EN : uint32_t {
    BLK54_EN_0 = 0x0,
    BLK54_EN_1 = 0x1,
};

/// When 1, Block55 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK55_EN [23:23]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK55_EN : uint32_t {
    BLK55_EN_0 = 0x0,
    BLK55_EN_1 = 0x1,
};

/// When 1, Block56 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK56_EN [24:24]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK56_EN : uint32_t {
    BLK56_EN_0 = 0x0,
    BLK56_EN_1 = 0x1,
};

/// When 1, Block57 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK57_EN [25:25]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK57_EN : uint32_t {
    BLK57_EN_0 = 0x0,
    BLK57_EN_1 = 0x1,
};

/// When 1, Block58 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK58_EN [26:26]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK58_EN : uint32_t {
    BLK58_EN_0 = 0x0,
    BLK58_EN_1 = 0x1,
};

/// When 1, Block59 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK59_EN [27:27]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK59_EN : uint32_t {
    BLK59_EN_0 = 0x0,
    BLK59_EN_1 = 0x1,
};

/// When 1, Block60 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK60_EN [28:28]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK60_EN : uint32_t {
    BLK60_EN_0 = 0x0,
    BLK60_EN_1 = 0x1,
};

/// When 1, Block61 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK61_EN [29:29]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK61_EN : uint32_t {
    BLK61_EN_0 = 0x0,
    BLK61_EN_1 = 0x1,
};

/// When 1, Block62 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK62_EN [30:30]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK62_EN : uint32_t {
    BLK62_EN_0 = 0x0,
    BLK62_EN_1 = 0x1,
};

/// When 1, Block63 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL1
/// Field: BLK63_EN [31:31]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL1_BLK63_EN : uint32_t {
    BLK63_EN_0 = 0x0,
    BLK63_EN_1 = 0x1,
};

/// When 1, Block64 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK64_EN [0:0]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK64_EN : uint32_t {
    BLK64_EN_0 = 0x0,
    BLK64_EN_1 = 0x1,
};

/// When 1, Block65 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK65_EN [1:1]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK65_EN : uint32_t {
    BLK65_EN_0 = 0x0,
    BLK65_EN_1 = 0x1,
};

/// When 1, Block66 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK66_EN [2:2]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK66_EN : uint32_t {
    BLK66_EN_0 = 0x0,
    BLK66_EN_1 = 0x1,
};

/// When 1, Block67 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK67_EN [3:3]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK67_EN : uint32_t {
    BLK67_EN_0 = 0x0,
    BLK67_EN_1 = 0x1,
};

/// When 1, Block68 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK68_EN [4:4]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK68_EN : uint32_t {
    BLK68_EN_0 = 0x0,
    BLK68_EN_1 = 0x1,
};

/// When 1, Block69 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK69_EN [5:5]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK69_EN : uint32_t {
    BLK69_EN_0 = 0x0,
    BLK69_EN_1 = 0x1,
};

/// When 1, Block70 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK70_EN [6:6]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK70_EN : uint32_t {
    BLK70_EN_0 = 0x0,
    BLK70_EN_1 = 0x1,
};

/// When 1, Block71 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK71_EN [7:7]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK71_EN : uint32_t {
    BLK71_EN_0 = 0x0,
    BLK71_EN_1 = 0x1,
};

/// When 1, Block72 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK72_EN [8:8]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK72_EN : uint32_t {
    BLK72_EN_0 = 0x0,
    BLK72_EN_1 = 0x1,
};

/// When 1, Block73 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK73_EN [9:9]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK73_EN : uint32_t {
    BLK73_EN_0 = 0x0,
    BLK73_EN_1 = 0x1,
};

/// When 1, Block74 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK74_EN [10:10]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK74_EN : uint32_t {
    BLK74_EN_0 = 0x0,
    BLK74_EN_1 = 0x1,
};

/// When 1, Block75 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK75_EN [11:11]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK75_EN : uint32_t {
    BLK75_EN_0 = 0x0,
    BLK75_EN_1 = 0x1,
};

/// When 1, Block76 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK76_EN [12:12]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK76_EN : uint32_t {
    BLK76_EN_0 = 0x0,
    BLK76_EN_1 = 0x1,
};

/// When 1, Block77 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK77_EN [13:13]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK77_EN : uint32_t {
    BLK77_EN_0 = 0x0,
    BLK77_EN_1 = 0x1,
};

/// When 1, Block78 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK78_EN [14:14]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK78_EN : uint32_t {
    BLK78_EN_0 = 0x0,
    BLK78_EN_1 = 0x1,
};

/// When 1, Block79 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK79_EN [15:15]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK79_EN : uint32_t {
    BLK79_EN_0 = 0x0,
    BLK79_EN_1 = 0x1,
};

/// When 1, Block80 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK80_EN [16:16]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK80_EN : uint32_t {
    BLK80_EN_0 = 0x0,
    BLK80_EN_1 = 0x1,
};

/// When 1, Block81 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK81_EN [17:17]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK81_EN : uint32_t {
    BLK81_EN_0 = 0x0,
    BLK81_EN_1 = 0x1,
};

/// When 1, Block82 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK82_EN [18:18]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK82_EN : uint32_t {
    BLK82_EN_0 = 0x0,
    BLK82_EN_1 = 0x1,
};

/// When 1, Block83 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK83_EN [19:19]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK83_EN : uint32_t {
    BLK83_EN_0 = 0x0,
    BLK83_EN_1 = 0x1,
};

/// When 1, Block84 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK84_EN [20:20]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK84_EN : uint32_t {
    BLK84_EN_0 = 0x0,
    BLK84_EN_1 = 0x1,
};

/// When 1, Block85 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK85_EN [21:21]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK85_EN : uint32_t {
    BLK85_EN_0 = 0x0,
    BLK85_EN_1 = 0x1,
};

/// When 1, Block86 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK86_EN [22:22]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK86_EN : uint32_t {
    BLK86_EN_0 = 0x0,
    BLK86_EN_1 = 0x1,
};

/// When 1, Block87 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK87_EN [23:23]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK87_EN : uint32_t {
    BLK87_EN_0 = 0x0,
    BLK87_EN_1 = 0x1,
};

/// When 1, Block88 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK88_EN [24:24]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK88_EN : uint32_t {
    BLK88_EN_0 = 0x0,
    BLK88_EN_1 = 0x1,
};

/// When 1, Block89 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK89_EN [25:25]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK89_EN : uint32_t {
    BLK89_EN_0 = 0x0,
    BLK89_EN_1 = 0x1,
};

/// When 1, Block90 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK90_EN [26:26]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK90_EN : uint32_t {
    BLK90_EN_0 = 0x0,
    BLK90_EN_1 = 0x1,
};

/// When 1, Block91 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK91_EN [27:27]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK91_EN : uint32_t {
    BLK91_EN_0 = 0x0,
    BLK91_EN_1 = 0x1,
};

/// When 1, Block92 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK92_EN [28:28]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK92_EN : uint32_t {
    BLK92_EN_0 = 0x0,
    BLK92_EN_1 = 0x1,
};

/// When 1, Block93 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK93_EN [29:29]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK93_EN : uint32_t {
    BLK93_EN_0 = 0x0,
    BLK93_EN_1 = 0x1,
};

/// When 1, Block94 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK94_EN [30:30]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK94_EN : uint32_t {
    BLK94_EN_0 = 0x0,
    BLK94_EN_1 = 0x1,
};

/// When 1, Block95 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL2
/// Field: BLK95_EN [31:31]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL2_BLK95_EN : uint32_t {
    BLK95_EN_0 = 0x0,
    BLK95_EN_1 = 0x1,
};

/// When 1, Block96 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK96_EN [0:0]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK96_EN : uint32_t {
    BLK96_EN_0 = 0x0,
    BLK96_EN_1 = 0x1,
};

/// When 1, Block97 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK97_EN [1:1]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK97_EN : uint32_t {
    BLK97_EN_0 = 0x0,
    BLK97_EN_1 = 0x1,
};

/// When 1, Block98 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK98_EN [2:2]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK98_EN : uint32_t {
    BLK98_EN_0 = 0x0,
    BLK98_EN_1 = 0x1,
};

/// When 1, Block99 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK99_EN [3:3]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK99_EN : uint32_t {
    BLK99_EN_0 = 0x0,
    BLK99_EN_1 = 0x1,
};

/// When 1, Block100 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK100_EN [4:4]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK100_EN : uint32_t {
    BLK100_EN_0 = 0x0,
    BLK100_EN_1 = 0x1,
};

/// When 1, Block101 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK101_EN [5:5]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK101_EN : uint32_t {
    BLK101_EN_0 = 0x0,
    BLK101_EN_1 = 0x1,
};

/// When 1, Block102 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK102_EN [6:6]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK102_EN : uint32_t {
    BLK102_EN_0 = 0x0,
    BLK102_EN_1 = 0x1,
};

/// When 1, Block103 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK103_EN [7:7]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK103_EN : uint32_t {
    BLK103_EN_0 = 0x0,
    BLK103_EN_1 = 0x1,
};

/// When 1, Block104 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK104_EN [8:8]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK104_EN : uint32_t {
    BLK104_EN_0 = 0x0,
    BLK104_EN_1 = 0x1,
};

/// When 1, Block105 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK105_EN [9:9]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK105_EN : uint32_t {
    BLK105_EN_0 = 0x0,
    BLK105_EN_1 = 0x1,
};

/// When 1, Block106 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK106_EN [10:10]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK106_EN : uint32_t {
    BLK106_EN_0 = 0x0,
    BLK106_EN_1 = 0x1,
};

/// When 1, Block107 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK107_EN [11:11]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK107_EN : uint32_t {
    BLK107_EN_0 = 0x0,
    BLK107_EN_1 = 0x1,
};

/// When 1, Block108 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK108_EN [12:12]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK108_EN : uint32_t {
    BLK108_EN_0 = 0x0,
    BLK108_EN_1 = 0x1,
};

/// When 1, Block109 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK109_EN [13:13]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK109_EN : uint32_t {
    BLK109_EN_0 = 0x0,
    BLK109_EN_1 = 0x1,
};

/// When 1, Block110 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK110_EN [14:14]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK110_EN : uint32_t {
    BLK110_EN_0 = 0x0,
    BLK110_EN_1 = 0x1,
};

/// When 1, Block111 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK111_EN [15:15]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK111_EN : uint32_t {
    BLK111_EN_0 = 0x0,
    BLK111_EN_1 = 0x1,
};

/// When 1, Block112 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK112_EN [16:16]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK112_EN : uint32_t {
    BLK112_EN_0 = 0x0,
    BLK112_EN_1 = 0x1,
};

/// When 1, Block113 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK113_EN [17:17]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK113_EN : uint32_t {
    BLK113_EN_0 = 0x0,
    BLK113_EN_1 = 0x1,
};

/// When 1, Block114 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK114_EN [18:18]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK114_EN : uint32_t {
    BLK114_EN_0 = 0x0,
    BLK114_EN_1 = 0x1,
};

/// When 1, Block115 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK115_EN [19:19]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK115_EN : uint32_t {
    BLK115_EN_0 = 0x0,
    BLK115_EN_1 = 0x1,
};

/// When 1, Block116 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK116_EN [20:20]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK116_EN : uint32_t {
    BLK116_EN_0 = 0x0,
    BLK116_EN_1 = 0x1,
};

/// When 1, Block117 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK117_EN [21:21]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK117_EN : uint32_t {
    BLK117_EN_0 = 0x0,
    BLK117_EN_1 = 0x1,
};

/// When 1, Block118 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK118_EN [22:22]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK118_EN : uint32_t {
    BLK118_EN_0 = 0x0,
    BLK118_EN_1 = 0x1,
};

/// When 1, Block119 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK119_EN [23:23]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK119_EN : uint32_t {
    BLK119_EN_0 = 0x0,
    BLK119_EN_1 = 0x1,
};

/// When 1, Block120 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK120_EN [24:24]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK120_EN : uint32_t {
    BLK120_EN_0 = 0x0,
    BLK120_EN_1 = 0x1,
};

/// When 1, Block121 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK121_EN [25:25]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK121_EN : uint32_t {
    BLK121_EN_0 = 0x0,
    BLK121_EN_1 = 0x1,
};

/// When 1, Block122 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK122_EN [26:26]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK122_EN : uint32_t {
    BLK122_EN_0 = 0x0,
    BLK122_EN_1 = 0x1,
};

/// When 1, Block123 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK123_EN [27:27]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK123_EN : uint32_t {
    BLK123_EN_0 = 0x0,
    BLK123_EN_1 = 0x1,
};

/// When 1, Block124 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK124_EN [28:28]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK124_EN : uint32_t {
    BLK124_EN_0 = 0x0,
    BLK124_EN_1 = 0x1,
};

/// When 1, Block125 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK125_EN [29:29]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK125_EN : uint32_t {
    BLK125_EN_0 = 0x0,
    BLK125_EN_1 = 0x1,
};

/// When 1, Block126 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK126_EN [30:30]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK126_EN : uint32_t {
    BLK126_EN_0 = 0x0,
    BLK126_EN_1 = 0x1,
};

/// When 1, Block127 of the SRAM is retained in LPM3 and LPM4
/// Register: SYS_SRAM_BLKRET_CTL3
/// Field: BLK127_EN [31:31]
enum class SYSCTL_A_SYS_SRAM_BLKRET_CTL3_BLK127_EN : uint32_t {
    BLK127_EN_0 = 0x0,
    BLK127_EN_1 = 0x1,
};

/// When 1, indicates SRAM is ready for access and banks can be enabled/disabled.
/// Register: SYS_SRAM_STAT
/// Field: BNKEN_RDY [0:0]
enum class SYSCTL_A_SYS_SRAM_STAT_BNKEN_RDY : uint32_t {
    BNKEN_RDY_0 = 0x0,
    BNKEN_RDY_1 = 0x1,
};

/// When 1, indicates SRAM is ready for access and blocks can be enabled/disabled for retention.
/// Register: SYS_SRAM_STAT
/// Field: BLKRET_RDY [1:1]
enum class SYSCTL_A_SYS_SRAM_STAT_BLKRET_RDY : uint32_t {
    BLKRET_RDY_0 = 0x0,
    BLKRET_RDY_1 = 0x1,
};

// ----------------------------------------------------------------------------
// SystemControlSpace - System Control Space for ARM core: SCnSCB, SCB, SysTick, NVIC, CoreDebug, MPU, FPU
// ----------------------------------------------------------------------------

/// MPU enable bit. Reset clears the ENABLE bit.
/// Register: MPU_CTRL
/// Field: ENABLE [0:0]
enum class SYSTEMCONTROLSPACE_MPU_CTRL_ENABLE : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// MPU Region Number valid bit.
/// Register: MPU_RBAR
/// Field: VALID [4:4]
enum class SYSTEMCONTROLSPACE_MPU_RBAR_VALID : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// MPU Protection Region Size Field.
/// Register: MPU_RASR
/// Field: SIZE [1:5]
enum class SYSTEMCONTROLSPACE_MPU_RASR_SIZE : uint32_t {
    en_0b00100 = 0x4,
    en_0b00101 = 0x5,
    en_0b00110 = 0x6,
    en_0b00111 = 0x7,
    en_0b01000 = 0x8,
    en_0b01001 = 0x9,
    en_0b01010 = 0xA,
    en_0b01011 = 0xB,
    en_0b01100 = 0xC,
    en_0b01101 = 0xD,
    en_0b01110 = 0xE,
    en_0b01111 = 0xF,
    en_0b10000 = 0x10,
    en_0b10001 = 0x11,
    en_0b10010 = 0x12,
    en_0b10011 = 0x13,
    en_0b10100 = 0x14,
    en_0b10101 = 0x15,
    en_0b10110 = 0x16,
    en_0b10111 = 0x17,
    en_0b11000 = 0x18,
    en_0b11001 = 0x19,
    en_0b11010 = 0x1A,
    en_0b11011 = 0x1B,
    en_0b11100 = 0x1C,
    en_0b11101 = 0x1D,
    en_0b11110 = 0x1E,
    en_0b11111 = 0x1F,
};

/// Bufferable bit
/// Register: MPU_RASR
/// Field: B [16:16]
enum class SYSTEMCONTROLSPACE_MPU_RASR_B : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Cacheable bit
/// Register: MPU_RASR
/// Field: C [17:17]
enum class SYSTEMCONTROLSPACE_MPU_RASR_C : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Shareable bit
/// Register: MPU_RASR
/// Field: S [18:18]
enum class SYSTEMCONTROLSPACE_MPU_RASR_S : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Data access permission field
/// Register: MPU_RASR
/// Field: AP [24:26]
enum class SYSTEMCONTROLSPACE_MPU_RASR_AP : uint32_t {
    en_0b000 = 0x0,
    en_0b001 = 0x1,
    en_0b010 = 0x2,
    en_0b011 = 0x3,
    en_0b101 = 0x5,
    en_0b110 = 0x6,
    en_0b111 = 0x7,
};

/// Instruction access disable bit
/// Register: MPU_RASR
/// Field: XN [28:28]
enum class SYSTEMCONTROLSPACE_MPU_RASR_XN : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Register select
/// Register: DCRSR
/// Field: REGSEL [0:4]
enum class SYSTEMCONTROLSPACE_DCRSR_REGSEL : uint32_t {
    en_0b00000 = 0x0,
    en_0b00001 = 0x1,
    en_0b00010 = 0x2,
    en_0b00011 = 0x3,
    en_0b00100 = 0x4,
    en_0b00101 = 0x5,
    en_0b00110 = 0x6,
    en_0b00111 = 0x7,
    en_0b01000 = 0x8,
    en_0b01001 = 0x9,
    en_0b01010 = 0xA,
    en_0b01011 = 0xB,
    en_0b01100 = 0xC,
    en_0b01101 = 0xD,
    en_0b01110 = 0xE,
    en_0b01111 = 0xF,
    en_0b10000 = 0x10,
    en_0b10001 = 0x11,
    en_0b10010 = 0x12,
    en_0b10100 = 0x14,
};

/// This enables the monitor to identify how it wakes up. This bit clears on a Core Reset.
/// Register: DEMCR
/// Field: MON_REQ [19:19]
enum class SYSTEMCONTROLSPACE_DEMCR_MON_REQ : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Enable SysTick counter
/// Register: STCSR
/// Field: ENABLE [0:0]
enum class SYSTEMCONTROLSPACE_STCSR_ENABLE : uint32_t {
    First = 0x0,
};

/// TICKINT
/// Register: STCSR
/// Field: TICKINT [1:1]
enum class SYSTEMCONTROLSPACE_STCSR_TICKINT : uint32_t {
    VAL_0 = 0x0,
    VAL_1 = 0x1,
};

/// Clock source.
/// Register: STCSR
/// Field: CLKSOURCE [2:2]
enum class SYSTEMCONTROLSPACE_STCSR_CLKSOURCE : uint32_t {
    VAL_0 = 0x0,
    VAL_1 = 0x1,
};

/// Interrupt pending flag. Excludes NMI and faults.
/// Register: ICSR
/// Field: ISRPENDING [22:22]
enum class SYSTEMCONTROLSPACE_ICSR_ISRPENDING : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// You must only use this at debug time. It indicates that a pending interrupt is to be taken in the next running cycle. If C_MASKINTS is clear in the Debug Halting Control and Status Register, the interrupt is serviced.
/// Register: ICSR
/// Field: ISRPREEMPT [23:23]
enum class SYSTEMCONTROLSPACE_ICSR_ISRPREEMPT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Clear pending SysTick bit
/// Register: ICSR
/// Field: PENDSTCLR [25:25]
enum class SYSTEMCONTROLSPACE_ICSR_PENDSTCLR : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Set a pending SysTick bit.
/// Register: ICSR
/// Field: PENDSTSET [26:26]
enum class SYSTEMCONTROLSPACE_ICSR_PENDSTSET : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Clear pending pendSV bit
/// Register: ICSR
/// Field: PENDSVCLR [27:27]
enum class SYSTEMCONTROLSPACE_ICSR_PENDSVCLR : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Set pending pendSV bit.
/// Register: ICSR
/// Field: PENDSVSET [28:28]
enum class SYSTEMCONTROLSPACE_ICSR_PENDSVSET : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Set pending NMI bit. NMIPENDSET pends and activates an NMI. Because NMI is the highest-priority interrupt, it takes effect as soon as it registers.
/// Register: ICSR
/// Field: NMIPENDSET [31:31]
enum class SYSTEMCONTROLSPACE_ICSR_NMIPENDSET : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Data endianness bit. ENDIANNESS is sampled from the BIGEND input port during reset. You cannot change ENDIANNESS outside of reset.
/// Register: AIRCR
/// Field: ENDIANESS [15:15]
enum class SYSTEMCONTROLSPACE_AIRCR_ENDIANESS : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Sleep on exit when returning from Handler mode to Thread mode. Enables interrupt driven applications to avoid returning to empty main application.
/// Register: SCR
/// Field: SLEEPONEXIT [1:1]
enum class SYSTEMCONTROLSPACE_SCR_SLEEPONEXIT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Sleep deep bit.
/// Register: SCR
/// Field: SLEEPDEEP [2:2]
enum class SYSTEMCONTROLSPACE_SCR_SLEEPDEEP : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Stack alignment bit.
/// Register: CCR
/// Field: STKALIGN [9:9]
enum class SYSTEMCONTROLSPACE_CCR_STKALIGN : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// MemManage active flag.
/// Register: SHCSR
/// Field: MEMFAULTACT [0:0]
enum class SYSTEMCONTROLSPACE_SHCSR_MEMFAULTACT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// BusFault active flag.
/// Register: SHCSR
/// Field: BUSFAULTACT [1:1]
enum class SYSTEMCONTROLSPACE_SHCSR_BUSFAULTACT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// UsageFault active flag.
/// Register: SHCSR
/// Field: USGFAULTACT [3:3]
enum class SYSTEMCONTROLSPACE_SHCSR_USGFAULTACT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// SVCall active flag.
/// Register: SHCSR
/// Field: SVCALLACT [7:7]
enum class SYSTEMCONTROLSPACE_SHCSR_SVCALLACT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// the Monitor active flag.
/// Register: SHCSR
/// Field: MONITORACT [8:8]
enum class SYSTEMCONTROLSPACE_SHCSR_MONITORACT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// PendSV active flag.
/// Register: SHCSR
/// Field: PENDSVACT [10:10]
enum class SYSTEMCONTROLSPACE_SHCSR_PENDSVACT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// SysTick active flag.
/// Register: SHCSR
/// Field: SYSTICKACT [11:11]
enum class SYSTEMCONTROLSPACE_SHCSR_SYSTICKACT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// usage fault pended flag.
/// Register: SHCSR
/// Field: USGFAULTPENDED [12:12]
enum class SYSTEMCONTROLSPACE_SHCSR_USGFAULTPENDED : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// MemManage pended flag.
/// Register: SHCSR
/// Field: MEMFAULTPENDED [13:13]
enum class SYSTEMCONTROLSPACE_SHCSR_MEMFAULTPENDED : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// BusFault pended flag.
/// Register: SHCSR
/// Field: BUSFAULTPENDED [14:14]
enum class SYSTEMCONTROLSPACE_SHCSR_BUSFAULTPENDED : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// SVCall pended flag.
/// Register: SHCSR
/// Field: SVCALLPENDED [15:15]
enum class SYSTEMCONTROLSPACE_SHCSR_SVCALLPENDED : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// MemManage fault system handler enable
/// Register: SHCSR
/// Field: MEMFAULTENA [16:16]
enum class SYSTEMCONTROLSPACE_SHCSR_MEMFAULTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Bus fault system handler enable
/// Register: SHCSR
/// Field: BUSFAULTENA [17:17]
enum class SYSTEMCONTROLSPACE_SHCSR_BUSFAULTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Usage fault system handler enable
/// Register: SHCSR
/// Field: USGFAULTENA [18:18]
enum class SYSTEMCONTROLSPACE_SHCSR_USGFAULTENA : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Halt request flag. The processor is halted on the next instruction.
/// Register: DFSR
/// Field: HALTED [0:0]
enum class SYSTEMCONTROLSPACE_DFSR_HALTED : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// BKPT flag. The BKPT flag is set by a BKPT instruction in flash patch code, and also by normal code. Return PC points to breakpoint containing instruction.
/// Register: DFSR
/// Field: BKPT [1:1]
enum class SYSTEMCONTROLSPACE_DFSR_BKPT : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Data Watchpoint and Trace (DWT) flag. The processor stops at the current instruction or at the next instruction.
/// Register: DFSR
/// Field: DWTTRAP [2:2]
enum class SYSTEMCONTROLSPACE_DFSR_DWTTRAP : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// Vector catch flag. When the VCATCH flag is set, a flag in one of the local fault status registers is also set to indicate the type of fault.
/// Register: DFSR
/// Field: VCATCH [3:3]
enum class SYSTEMCONTROLSPACE_DFSR_VCATCH : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// External debug request flag. The processor stops on next instruction boundary.
/// Register: DFSR
/// Field: EXTERNAL [4:4]
enum class SYSTEMCONTROLSPACE_DFSR_EXTERNAL : uint32_t {
    en_0b0 = 0x0,
    en_0b1 = 0x1,
};

/// State0 (T-bit == 0)
/// Register: PFR0
/// Field: STATE0 [0:3]
enum class SYSTEMCONTROLSPACE_PFR0_STATE0 : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// State1 (T-bit == 1)
/// Register: PFR0
/// Field: STATE1 [4:7]
enum class SYSTEMCONTROLSPACE_PFR0_STATE1 : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
};

/// Microcontroller programmer's model
/// Register: PFR1
/// Field: MICROCONTROLLER_PROGRAMMERS_MODEL [8:11]
enum class SYSTEMCONTROLSPACE_PFR1_MICROCONTROLLER_PROGRAMMERS_MODEL : uint32_t {
    en_0b0000 = 0x0,
    en_0b0010 = 0x2,
};

/// Microcontroller Debug Model - memory mapped
/// Register: DFR0
/// Field: MICROCONTROLLER_DEBUG_MODEL [20:23]
enum class SYSTEMCONTROLSPACE_DFR0_MICROCONTROLLER_DEBUG_MODEL : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// PMSA support
/// Register: MMFR0
/// Field: PMSA_SUPPORT [4:7]
enum class SYSTEMCONTROLSPACE_MMFR0_PMSA_SUPPORT : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
};

/// Cache coherence support
/// Register: MMFR0
/// Field: CACHE_COHERENCE_SUPPORT [8:11]
enum class SYSTEMCONTROLSPACE_MMFR0_CACHE_COHERENCE_SUPPORT : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
};

/// Outer non-sharable support
/// Register: MMFR0
/// Field: OUTER_NON_SHARABLE_SUPPORT [12:15]
enum class SYSTEMCONTROLSPACE_MMFR0_OUTER_NON_SHARABLE_SUPPORT : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// Auxiliary register support
/// Register: MMFR0
/// Field: AUXILIARY_REGISTER_SUPPORT [20:23]
enum class SYSTEMCONTROLSPACE_MMFR0_AUXILIARY_REGISTER_SUPPORT : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// wait for interrupt stalling
/// Register: MMFR2
/// Field: WAIT_FOR_INTERRUPT_STALLING [24:27]
enum class SYSTEMCONTROLSPACE_MMFR2_WAIT_FOR_INTERRUPT_STALLING : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// BitCount instructions
/// Register: ISAR0
/// Field: BITCOUNT_INSTRS [4:7]
enum class SYSTEMCONTROLSPACE_ISAR0_BITCOUNT_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// BitField instructions
/// Register: ISAR0
/// Field: BITFIELD_INSTRS [8:11]
enum class SYSTEMCONTROLSPACE_ISAR0_BITFIELD_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// CmpBranch instructions
/// Register: ISAR0
/// Field: CMPBRANCH_INSTRS [12:15]
enum class SYSTEMCONTROLSPACE_ISAR0_CMPBRANCH_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// Coprocessor instructions
/// Register: ISAR0
/// Field: COPROC_INSTRS [16:19]
enum class SYSTEMCONTROLSPACE_ISAR0_COPROC_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
    en_0b0100 = 0x4,
};

/// Debug instructions
/// Register: ISAR0
/// Field: DEBUG_INSTRS [20:23]
enum class SYSTEMCONTROLSPACE_ISAR0_DEBUG_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// Divide instructions
/// Register: ISAR0
/// Field: DIVIDE_INSTRS [24:27]
enum class SYSTEMCONTROLSPACE_ISAR0_DIVIDE_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// Extend instructions. Note that the shift options on these instructions are also controlled by the WithShifts_instrs attribute.
/// Register: ISAR1
/// Field: EXTEND_INSRS [12:15]
enum class SYSTEMCONTROLSPACE_ISAR1_EXTEND_INSRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
};

/// IfThen instructions
/// Register: ISAR1
/// Field: IFTHEN_INSTRS [16:19]
enum class SYSTEMCONTROLSPACE_ISAR1_IFTHEN_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// Immediate instructions
/// Register: ISAR1
/// Field: IMMEDIATE_INSTRS [20:23]
enum class SYSTEMCONTROLSPACE_ISAR1_IMMEDIATE_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// Interwork instructions
/// Register: ISAR1
/// Field: INTERWORK_INSTRS [24:27]
enum class SYSTEMCONTROLSPACE_ISAR1_INTERWORK_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
};

/// LoadStore instructions
/// Register: ISAR2
/// Field: LOADSTORE_INSTRS [0:3]
enum class SYSTEMCONTROLSPACE_ISAR2_LOADSTORE_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// MemoryHint instructions
/// Register: ISAR2
/// Field: MEMHINT_INSTRS [4:7]
enum class SYSTEMCONTROLSPACE_ISAR2_MEMHINT_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
};

/// Multi-Access interruptible instructions
/// Register: ISAR2
/// Field: MULTIACCESSINT_INSTRS [8:11]
enum class SYSTEMCONTROLSPACE_ISAR2_MULTIACCESSINT_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
};

/// Multiply instructions
/// Register: ISAR2
/// Field: MULT_INSTRS [12:15]
enum class SYSTEMCONTROLSPACE_ISAR2_MULT_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
};

/// Multiply instructions (advanced, signed)
/// Register: ISAR2
/// Field: MULTS_INSTRS [16:19]
enum class SYSTEMCONTROLSPACE_ISAR2_MULTS_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
    en_0b0011 = 0x3,
};

/// Multiply instructions (advanced, unsigned)
/// Register: ISAR2
/// Field: MULTU_INSTRS [20:23]
enum class SYSTEMCONTROLSPACE_ISAR2_MULTU_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
};

/// Reversal instructions
/// Register: ISAR2
/// Field: REVERSAL_INSTRS [28:31]
enum class SYSTEMCONTROLSPACE_ISAR2_REVERSAL_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
};

/// Saturate instructions
/// Register: ISAR3
/// Field: SATRUATE_INSTRS [0:3]
enum class SYSTEMCONTROLSPACE_ISAR3_SATRUATE_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// SIMD instructions
/// Register: ISAR3
/// Field: SIMD_INSTRS [4:7]
enum class SYSTEMCONTROLSPACE_ISAR3_SIMD_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0011 = 0x3,
};

/// SVC instructions
/// Register: ISAR3
/// Field: SVC_INSTRS [8:11]
enum class SYSTEMCONTROLSPACE_ISAR3_SVC_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// SyncPrim instructions. Note there are no LDREXD or STREXD in ARMv7-M. This attribute is used in conjunction with the SyncPrim_instrs_frac attribute in ID_ISAR4[23:20].
/// Register: ISAR3
/// Field: SYNCPRIM_INSTRS [12:15]
enum class SYSTEMCONTROLSPACE_ISAR3_SYNCPRIM_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
};

/// TableBranch instructions
/// Register: ISAR3
/// Field: TABBRANCH_INSTRS [16:19]
enum class SYSTEMCONTROLSPACE_ISAR3_TABBRANCH_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// ThumbCopy instructions
/// Register: ISAR3
/// Field: THUMBCOPY_INSTRS [20:23]
enum class SYSTEMCONTROLSPACE_ISAR3_THUMBCOPY_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// TrueNOP instructions
/// Register: ISAR3
/// Field: TRUENOP_INSTRS [24:27]
enum class SYSTEMCONTROLSPACE_ISAR3_TRUENOP_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// Unprivileged instructions
/// Register: ISAR4
/// Field: UNPRIV_INSTRS [0:3]
enum class SYSTEMCONTROLSPACE_ISAR4_UNPRIV_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x2,
};

/// WithShift instructions. Note that all additions only apply in cases where the encoding supports them - e.g. there is no difference between levels 3 and 4 in the Thumb-2 instruction set. Also note that MOV instructions with shift options should instead be treated as ASR, LSL, LSR, ROR or RRX instructions.
/// Register: ISAR4
/// Field: WITHSHIFTS_INSTRS [4:7]
enum class SYSTEMCONTROLSPACE_ISAR4_WITHSHIFTS_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
    en_0b0010 = 0x3,
    en_0b0100 = 0x4,
};

/// Writeback instructions
/// Register: ISAR4
/// Field: WRITEBACK_INSTRS [8:11]
enum class SYSTEMCONTROLSPACE_ISAR4_WRITEBACK_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// Barrier instructions
/// Register: ISAR4
/// Field: BARRIER_INSTRS [16:19]
enum class SYSTEMCONTROLSPACE_ISAR4_BARRIER_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

/// SyncPrim_instrs_frac
/// Register: ISAR4
/// Field: SYNCPRIM_INSTRS_FRAC [20:23]
enum class SYSTEMCONTROLSPACE_ISAR4_SYNCPRIM_INSTRS_FRAC : uint32_t {
    en_0b0000 = 0x0,
    en_0b0011 = 0x3,
};

/// PSR_M_instrs
/// Register: ISAR4
/// Field: PSR_M_INSTRS [24:27]
enum class SYSTEMCONTROLSPACE_ISAR4_PSR_M_INSTRS : uint32_t {
    en_0b0000 = 0x0,
    en_0b0001 = 0x1,
};

// ----------------------------------------------------------------------------
// TIMER32 - TIMER32
// ----------------------------------------------------------------------------

/// Selects one-shot or wrapping counter mode
/// Register: T32CONTROL1
/// Field: ONESHOT [0:0]
enum class TIMER32_T32CONTROL1_ONESHOT : uint32_t {
    ONESHOT_0 = 0x0,
    ONESHOT_1 = 0x1,
};

/// Selects 16 or 32 bit counter operation
/// Register: T32CONTROL1
/// Field: SIZE [1:1]
enum class TIMER32_T32CONTROL1_SIZE : uint32_t {
    SIZE_0 = 0x0,
    SIZE_1 = 0x1,
};

/// Prescale bits
/// Register: T32CONTROL1
/// Field: PRESCALE [2:3]
enum class TIMER32_T32CONTROL1_PRESCALE : uint32_t {
    PRESCALE_0 = 0x0,
    PRESCALE_1 = 0x1,
    PRESCALE_2 = 0x2,
};

/// Interrupt enable bit
/// Register: T32CONTROL1
/// Field: IE [5:5]
enum class TIMER32_T32CONTROL1_IE : uint32_t {
    IE_0 = 0x0,
    IE_1 = 0x1,
};

/// Mode bit
/// Register: T32CONTROL1
/// Field: MODE [6:6]
enum class TIMER32_T32CONTROL1_MODE : uint32_t {
    MODE_0 = 0x0,
    MODE_1 = 0x1,
};

/// Enable bit
/// Register: T32CONTROL1
/// Field: ENABLE [7:7]
enum class TIMER32_T32CONTROL1_ENABLE : uint32_t {
    ENABLE_0 = 0x0,
    ENABLE_1 = 0x1,
};

/// Selects one-shot or wrapping counter mode
/// Register: T32CONTROL2
/// Field: ONESHOT [0:0]
enum class TIMER32_T32CONTROL2_ONESHOT : uint32_t {
    ONESHOT_0 = 0x0,
    ONESHOT_1 = 0x1,
};

/// Selects 16 or 32 bit counter operation
/// Register: T32CONTROL2
/// Field: SIZE [1:1]
enum class TIMER32_T32CONTROL2_SIZE : uint32_t {
    SIZE_0 = 0x0,
    SIZE_1 = 0x1,
};

/// Prescale bits
/// Register: T32CONTROL2
/// Field: PRESCALE [2:3]
enum class TIMER32_T32CONTROL2_PRESCALE : uint32_t {
    PRESCALE_0 = 0x0,
    PRESCALE_1 = 0x1,
    PRESCALE_2 = 0x2,
};

/// Interrupt enable bit
/// Register: T32CONTROL2
/// Field: IE [5:5]
enum class TIMER32_T32CONTROL2_IE : uint32_t {
    IE_0 = 0x0,
    IE_1 = 0x1,
};

/// Mode bit
/// Register: T32CONTROL2
/// Field: MODE [6:6]
enum class TIMER32_T32CONTROL2_MODE : uint32_t {
    MODE_0 = 0x0,
    MODE_1 = 0x1,
};

/// Enable bit
/// Register: T32CONTROL2
/// Field: ENABLE [7:7]
enum class TIMER32_T32CONTROL2_ENABLE : uint32_t {
    ENABLE_0 = 0x0,
    ENABLE_1 = 0x1,
};

// ----------------------------------------------------------------------------
// TIMER_A0 - TIMER_A0
// ----------------------------------------------------------------------------

/// TimerA interrupt flag
/// Register: TAxCTL
/// Field: TAIFG [0:0]
enum class TIMER_A0_TAXCTL_TAIFG : uint16_t {
    TAIFG_0 = 0x0,
    TAIFG_1 = 0x1,
};

/// TimerA interrupt enable
/// Register: TAxCTL
/// Field: TAIE [1:1]
enum class TIMER_A0_TAXCTL_TAIE : uint16_t {
    TAIE_0 = 0x0,
    TAIE_1 = 0x1,
};

/// Mode control
/// Register: TAxCTL
/// Field: MC [4:5]
enum class TIMER_A0_TAXCTL_MC : uint16_t {
    MC_0 = 0x0,
    MC_1 = 0x1,
    MC_2 = 0x2,
    MC_3 = 0x3,
};

/// Input divider
/// Register: TAxCTL
/// Field: ID [6:7]
enum class TIMER_A0_TAXCTL_ID : uint16_t {
    ID_0 = 0x0,
    ID_1 = 0x1,
    ID_2 = 0x2,
    ID_3 = 0x3,
};

/// TimerA clock source select
/// Register: TAxCTL
/// Field: TASSEL [8:9]
enum class TIMER_A0_TAXCTL_TASSEL : uint16_t {
    TASSEL_0 = 0x0,
    TASSEL_1 = 0x1,
    TASSEL_2 = 0x2,
    TASSEL_3 = 0x3,
};

/// Capture/compare interrupt flag
/// Register: TAxCCTL[%s]
/// Field: CCIFG [0:0]
enum class TIMER_A0_TAXCCTL[%S]_CCIFG : uint16_t {
    CCIFG_0 = 0x0,
    CCIFG_1 = 0x1,
};

/// Capture overflow
/// Register: TAxCCTL[%s]
/// Field: COV [1:1]
enum class TIMER_A0_TAXCCTL[%S]_COV : uint16_t {
    COV_0 = 0x0,
    COV_1 = 0x1,
};

/// Output
/// Register: TAxCCTL[%s]
/// Field: OUT [2:2]
enum class TIMER_A0_TAXCCTL[%S]_OUT : uint16_t {
    OUT_0 = 0x0,
    OUT_1 = 0x1,
};

/// Capture/compare interrupt enable
/// Register: TAxCCTL[%s]
/// Field: CCIE [4:4]
enum class TIMER_A0_TAXCCTL[%S]_CCIE : uint16_t {
    CCIE_0 = 0x0,
    CCIE_1 = 0x1,
};

/// Output mode
/// Register: TAxCCTL[%s]
/// Field: OUTMOD [5:7]
enum class TIMER_A0_TAXCCTL[%S]_OUTMOD : uint16_t {
    OUTMOD_0 = 0x0,
    OUTMOD_1 = 0x1,
    OUTMOD_2 = 0x2,
    OUTMOD_3 = 0x3,
    OUTMOD_4 = 0x4,
    OUTMOD_5 = 0x5,
    OUTMOD_6 = 0x6,
    OUTMOD_7 = 0x7,
};

/// Capture mode
/// Register: TAxCCTL[%s]
/// Field: CAP [8:8]
enum class TIMER_A0_TAXCCTL[%S]_CAP : uint16_t {
    CAP_0 = 0x0,
    CAP_1 = 0x1,
};

/// Synchronize capture source
/// Register: TAxCCTL[%s]
/// Field: SCS [11:11]
enum class TIMER_A0_TAXCCTL[%S]_SCS : uint16_t {
    SCS_0 = 0x0,
    SCS_1 = 0x1,
};

/// Capture/compare input select
/// Register: TAxCCTL[%s]
/// Field: CCIS [12:13]
enum class TIMER_A0_TAXCCTL[%S]_CCIS : uint16_t {
    CCIS_0 = 0x0,
    CCIS_1 = 0x1,
    CCIS_2 = 0x2,
    CCIS_3 = 0x3,
};

/// Capture mode
/// Register: TAxCCTL[%s]
/// Field: CM [14:15]
enum class TIMER_A0_TAXCCTL[%S]_CM : uint16_t {
    CM_0 = 0x0,
    CM_1 = 0x1,
    CM_2 = 0x2,
    CM_3 = 0x3,
};

/// Input divider expansion
/// Register: TAxEX0
/// Field: TAIDEX [0:2]
enum class TIMER_A0_TAXEX0_TAIDEX : uint16_t {
    TAIDEX_0 = 0x0,
    TAIDEX_1 = 0x1,
    TAIDEX_2 = 0x2,
    TAIDEX_3 = 0x3,
    TAIDEX_4 = 0x4,
    TAIDEX_5 = 0x5,
    TAIDEX_6 = 0x6,
    TAIDEX_7 = 0x7,
};

/// TimerA interrupt vector value
/// Register: TAxIV
/// Field: TAIV [0:15]
enum class TIMER_A0_TAXIV_TAIV : uint16_t {
    TAIV_0 = 0x0,
    TAIV_2 = 0x2,
    TAIV_4 = 0x4,
    TAIV_6 = 0x6,
    TAIV_8 = 0x8,
    TAIV_10 = 0xA,
    TAIV_12 = 0xC,
    TAIV_14 = 0xE,
};

// ----------------------------------------------------------------------------
// TIMER_A1 - TIMER_A1
// ----------------------------------------------------------------------------

/// TimerA interrupt flag
/// Register: TAxCTL
/// Field: TAIFG [0:0]
enum class TIMER_A1_TAXCTL_TAIFG : uint16_t {
    TAIFG_0 = 0x0,
    TAIFG_1 = 0x1,
};

/// TimerA interrupt enable
/// Register: TAxCTL
/// Field: TAIE [1:1]
enum class TIMER_A1_TAXCTL_TAIE : uint16_t {
    TAIE_0 = 0x0,
    TAIE_1 = 0x1,
};

/// Mode control
/// Register: TAxCTL
/// Field: MC [4:5]
enum class TIMER_A1_TAXCTL_MC : uint16_t {
    MC_0 = 0x0,
    MC_1 = 0x1,
    MC_2 = 0x2,
    MC_3 = 0x3,
};

/// Input divider
/// Register: TAxCTL
/// Field: ID [6:7]
enum class TIMER_A1_TAXCTL_ID : uint16_t {
    ID_0 = 0x0,
    ID_1 = 0x1,
    ID_2 = 0x2,
    ID_3 = 0x3,
};

/// TimerA clock source select
/// Register: TAxCTL
/// Field: TASSEL [8:9]
enum class TIMER_A1_TAXCTL_TASSEL : uint16_t {
    TASSEL_0 = 0x0,
    TASSEL_1 = 0x1,
    TASSEL_2 = 0x2,
    TASSEL_3 = 0x3,
};

/// Capture/compare interrupt flag
/// Register: TAxCCTL[%s]
/// Field: CCIFG [0:0]
enum class TIMER_A1_TAXCCTL[%S]_CCIFG : uint16_t {
    CCIFG_0 = 0x0,
    CCIFG_1 = 0x1,
};

/// Capture overflow
/// Register: TAxCCTL[%s]
/// Field: COV [1:1]
enum class TIMER_A1_TAXCCTL[%S]_COV : uint16_t {
    COV_0 = 0x0,
    COV_1 = 0x1,
};

/// Output
/// Register: TAxCCTL[%s]
/// Field: OUT [2:2]
enum class TIMER_A1_TAXCCTL[%S]_OUT : uint16_t {
    OUT_0 = 0x0,
    OUT_1 = 0x1,
};

/// Capture/compare interrupt enable
/// Register: TAxCCTL[%s]
/// Field: CCIE [4:4]
enum class TIMER_A1_TAXCCTL[%S]_CCIE : uint16_t {
    CCIE_0 = 0x0,
    CCIE_1 = 0x1,
};

/// Output mode
/// Register: TAxCCTL[%s]
/// Field: OUTMOD [5:7]
enum class TIMER_A1_TAXCCTL[%S]_OUTMOD : uint16_t {
    OUTMOD_0 = 0x0,
    OUTMOD_1 = 0x1,
    OUTMOD_2 = 0x2,
    OUTMOD_3 = 0x3,
    OUTMOD_4 = 0x4,
    OUTMOD_5 = 0x5,
    OUTMOD_6 = 0x6,
    OUTMOD_7 = 0x7,
};

/// Capture mode
/// Register: TAxCCTL[%s]
/// Field: CAP [8:8]
enum class TIMER_A1_TAXCCTL[%S]_CAP : uint16_t {
    CAP_0 = 0x0,
    CAP_1 = 0x1,
};

/// Synchronize capture source
/// Register: TAxCCTL[%s]
/// Field: SCS [11:11]
enum class TIMER_A1_TAXCCTL[%S]_SCS : uint16_t {
    SCS_0 = 0x0,
    SCS_1 = 0x1,
};

/// Capture/compare input select
/// Register: TAxCCTL[%s]
/// Field: CCIS [12:13]
enum class TIMER_A1_TAXCCTL[%S]_CCIS : uint16_t {
    CCIS_0 = 0x0,
    CCIS_1 = 0x1,
    CCIS_2 = 0x2,
    CCIS_3 = 0x3,
};

/// Capture mode
/// Register: TAxCCTL[%s]
/// Field: CM [14:15]
enum class TIMER_A1_TAXCCTL[%S]_CM : uint16_t {
    CM_0 = 0x0,
    CM_1 = 0x1,
    CM_2 = 0x2,
    CM_3 = 0x3,
};

/// Input divider expansion
/// Register: TAxEX0
/// Field: TAIDEX [0:2]
enum class TIMER_A1_TAXEX0_TAIDEX : uint16_t {
    TAIDEX_0 = 0x0,
    TAIDEX_1 = 0x1,
    TAIDEX_2 = 0x2,
    TAIDEX_3 = 0x3,
    TAIDEX_4 = 0x4,
    TAIDEX_5 = 0x5,
    TAIDEX_6 = 0x6,
    TAIDEX_7 = 0x7,
};

/// TimerA interrupt vector value
/// Register: TAxIV
/// Field: TAIV [0:15]
enum class TIMER_A1_TAXIV_TAIV : uint16_t {
    TAIV_0 = 0x0,
    TAIV_2 = 0x2,
    TAIV_4 = 0x4,
    TAIV_6 = 0x6,
    TAIV_8 = 0x8,
    TAIV_10 = 0xA,
    TAIV_12 = 0xC,
    TAIV_14 = 0xE,
};

// ----------------------------------------------------------------------------
// TIMER_A2 - TIMER_A2
// ----------------------------------------------------------------------------

/// TimerA interrupt flag
/// Register: TAxCTL
/// Field: TAIFG [0:0]
enum class TIMER_A2_TAXCTL_TAIFG : uint16_t {
    TAIFG_0 = 0x0,
    TAIFG_1 = 0x1,
};

/// TimerA interrupt enable
/// Register: TAxCTL
/// Field: TAIE [1:1]
enum class TIMER_A2_TAXCTL_TAIE : uint16_t {
    TAIE_0 = 0x0,
    TAIE_1 = 0x1,
};

/// Mode control
/// Register: TAxCTL
/// Field: MC [4:5]
enum class TIMER_A2_TAXCTL_MC : uint16_t {
    MC_0 = 0x0,
    MC_1 = 0x1,
    MC_2 = 0x2,
    MC_3 = 0x3,
};

/// Input divider
/// Register: TAxCTL
/// Field: ID [6:7]
enum class TIMER_A2_TAXCTL_ID : uint16_t {
    ID_0 = 0x0,
    ID_1 = 0x1,
    ID_2 = 0x2,
    ID_3 = 0x3,
};

/// TimerA clock source select
/// Register: TAxCTL
/// Field: TASSEL [8:9]
enum class TIMER_A2_TAXCTL_TASSEL : uint16_t {
    TASSEL_0 = 0x0,
    TASSEL_1 = 0x1,
    TASSEL_2 = 0x2,
    TASSEL_3 = 0x3,
};

/// Capture/compare interrupt flag
/// Register: TAxCCTL[%s]
/// Field: CCIFG [0:0]
enum class TIMER_A2_TAXCCTL[%S]_CCIFG : uint16_t {
    CCIFG_0 = 0x0,
    CCIFG_1 = 0x1,
};

/// Capture overflow
/// Register: TAxCCTL[%s]
/// Field: COV [1:1]
enum class TIMER_A2_TAXCCTL[%S]_COV : uint16_t {
    COV_0 = 0x0,
    COV_1 = 0x1,
};

/// Output
/// Register: TAxCCTL[%s]
/// Field: OUT [2:2]
enum class TIMER_A2_TAXCCTL[%S]_OUT : uint16_t {
    OUT_0 = 0x0,
    OUT_1 = 0x1,
};

/// Capture/compare interrupt enable
/// Register: TAxCCTL[%s]
/// Field: CCIE [4:4]
enum class TIMER_A2_TAXCCTL[%S]_CCIE : uint16_t {
    CCIE_0 = 0x0,
    CCIE_1 = 0x1,
};

/// Output mode
/// Register: TAxCCTL[%s]
/// Field: OUTMOD [5:7]
enum class TIMER_A2_TAXCCTL[%S]_OUTMOD : uint16_t {
    OUTMOD_0 = 0x0,
    OUTMOD_1 = 0x1,
    OUTMOD_2 = 0x2,
    OUTMOD_3 = 0x3,
    OUTMOD_4 = 0x4,
    OUTMOD_5 = 0x5,
    OUTMOD_6 = 0x6,
    OUTMOD_7 = 0x7,
};

/// Capture mode
/// Register: TAxCCTL[%s]
/// Field: CAP [8:8]
enum class TIMER_A2_TAXCCTL[%S]_CAP : uint16_t {
    CAP_0 = 0x0,
    CAP_1 = 0x1,
};

/// Synchronize capture source
/// Register: TAxCCTL[%s]
/// Field: SCS [11:11]
enum class TIMER_A2_TAXCCTL[%S]_SCS : uint16_t {
    SCS_0 = 0x0,
    SCS_1 = 0x1,
};

/// Capture/compare input select
/// Register: TAxCCTL[%s]
/// Field: CCIS [12:13]
enum class TIMER_A2_TAXCCTL[%S]_CCIS : uint16_t {
    CCIS_0 = 0x0,
    CCIS_1 = 0x1,
    CCIS_2 = 0x2,
    CCIS_3 = 0x3,
};

/// Capture mode
/// Register: TAxCCTL[%s]
/// Field: CM [14:15]
enum class TIMER_A2_TAXCCTL[%S]_CM : uint16_t {
    CM_0 = 0x0,
    CM_1 = 0x1,
    CM_2 = 0x2,
    CM_3 = 0x3,
};

/// Input divider expansion
/// Register: TAxEX0
/// Field: TAIDEX [0:2]
enum class TIMER_A2_TAXEX0_TAIDEX : uint16_t {
    TAIDEX_0 = 0x0,
    TAIDEX_1 = 0x1,
    TAIDEX_2 = 0x2,
    TAIDEX_3 = 0x3,
    TAIDEX_4 = 0x4,
    TAIDEX_5 = 0x5,
    TAIDEX_6 = 0x6,
    TAIDEX_7 = 0x7,
};

/// TimerA interrupt vector value
/// Register: TAxIV
/// Field: TAIV [0:15]
enum class TIMER_A2_TAXIV_TAIV : uint16_t {
    TAIV_0 = 0x0,
    TAIV_2 = 0x2,
    TAIV_4 = 0x4,
    TAIV_6 = 0x6,
    TAIV_8 = 0x8,
    TAIV_10 = 0xA,
    TAIV_12 = 0xC,
    TAIV_14 = 0xE,
};

// ----------------------------------------------------------------------------
// TIMER_A3 - TIMER_A3
// ----------------------------------------------------------------------------

/// TimerA interrupt flag
/// Register: TAxCTL
/// Field: TAIFG [0:0]
enum class TIMER_A3_TAXCTL_TAIFG : uint16_t {
    TAIFG_0 = 0x0,
    TAIFG_1 = 0x1,
};

/// TimerA interrupt enable
/// Register: TAxCTL
/// Field: TAIE [1:1]
enum class TIMER_A3_TAXCTL_TAIE : uint16_t {
    TAIE_0 = 0x0,
    TAIE_1 = 0x1,
};

/// Mode control
/// Register: TAxCTL
/// Field: MC [4:5]
enum class TIMER_A3_TAXCTL_MC : uint16_t {
    MC_0 = 0x0,
    MC_1 = 0x1,
    MC_2 = 0x2,
    MC_3 = 0x3,
};

/// Input divider
/// Register: TAxCTL
/// Field: ID [6:7]
enum class TIMER_A3_TAXCTL_ID : uint16_t {
    ID_0 = 0x0,
    ID_1 = 0x1,
    ID_2 = 0x2,
    ID_3 = 0x3,
};

/// TimerA clock source select
/// Register: TAxCTL
/// Field: TASSEL [8:9]
enum class TIMER_A3_TAXCTL_TASSEL : uint16_t {
    TASSEL_0 = 0x0,
    TASSEL_1 = 0x1,
    TASSEL_2 = 0x2,
    TASSEL_3 = 0x3,
};

/// Capture/compare interrupt flag
/// Register: TAxCCTL[%s]
/// Field: CCIFG [0:0]
enum class TIMER_A3_TAXCCTL[%S]_CCIFG : uint16_t {
    CCIFG_0 = 0x0,
    CCIFG_1 = 0x1,
};

/// Capture overflow
/// Register: TAxCCTL[%s]
/// Field: COV [1:1]
enum class TIMER_A3_TAXCCTL[%S]_COV : uint16_t {
    COV_0 = 0x0,
    COV_1 = 0x1,
};

/// Output
/// Register: TAxCCTL[%s]
/// Field: OUT [2:2]
enum class TIMER_A3_TAXCCTL[%S]_OUT : uint16_t {
    OUT_0 = 0x0,
    OUT_1 = 0x1,
};

/// Capture/compare interrupt enable
/// Register: TAxCCTL[%s]
/// Field: CCIE [4:4]
enum class TIMER_A3_TAXCCTL[%S]_CCIE : uint16_t {
    CCIE_0 = 0x0,
    CCIE_1 = 0x1,
};

/// Output mode
/// Register: TAxCCTL[%s]
/// Field: OUTMOD [5:7]
enum class TIMER_A3_TAXCCTL[%S]_OUTMOD : uint16_t {
    OUTMOD_0 = 0x0,
    OUTMOD_1 = 0x1,
    OUTMOD_2 = 0x2,
    OUTMOD_3 = 0x3,
    OUTMOD_4 = 0x4,
    OUTMOD_5 = 0x5,
    OUTMOD_6 = 0x6,
    OUTMOD_7 = 0x7,
};

/// Capture mode
/// Register: TAxCCTL[%s]
/// Field: CAP [8:8]
enum class TIMER_A3_TAXCCTL[%S]_CAP : uint16_t {
    CAP_0 = 0x0,
    CAP_1 = 0x1,
};

/// Synchronize capture source
/// Register: TAxCCTL[%s]
/// Field: SCS [11:11]
enum class TIMER_A3_TAXCCTL[%S]_SCS : uint16_t {
    SCS_0 = 0x0,
    SCS_1 = 0x1,
};

/// Capture/compare input select
/// Register: TAxCCTL[%s]
/// Field: CCIS [12:13]
enum class TIMER_A3_TAXCCTL[%S]_CCIS : uint16_t {
    CCIS_0 = 0x0,
    CCIS_1 = 0x1,
    CCIS_2 = 0x2,
    CCIS_3 = 0x3,
};

/// Capture mode
/// Register: TAxCCTL[%s]
/// Field: CM [14:15]
enum class TIMER_A3_TAXCCTL[%S]_CM : uint16_t {
    CM_0 = 0x0,
    CM_1 = 0x1,
    CM_2 = 0x2,
    CM_3 = 0x3,
};

/// Input divider expansion
/// Register: TAxEX0
/// Field: TAIDEX [0:2]
enum class TIMER_A3_TAXEX0_TAIDEX : uint16_t {
    TAIDEX_0 = 0x0,
    TAIDEX_1 = 0x1,
    TAIDEX_2 = 0x2,
    TAIDEX_3 = 0x3,
    TAIDEX_4 = 0x4,
    TAIDEX_5 = 0x5,
    TAIDEX_6 = 0x6,
    TAIDEX_7 = 0x7,
};

/// TimerA interrupt vector value
/// Register: TAxIV
/// Field: TAIV [0:15]
enum class TIMER_A3_TAXIV_TAIV : uint16_t {
    TAIV_0 = 0x0,
    TAIV_2 = 0x2,
    TAIV_4 = 0x4,
    TAIV_6 = 0x6,
    TAIV_8 = 0x8,
    TAIV_10 = 0xA,
    TAIV_12 = 0xC,
    TAIV_14 = 0xE,
};

// ----------------------------------------------------------------------------
// WDT_A - WDT_A
// ----------------------------------------------------------------------------

/// Watchdog timer interval select
/// Register: WDTCTL
/// Field: WDTIS [0:2]
enum class WDT_A_WDTCTL_WDTIS : uint16_t {
    WDTIS_0 = 0x0,
    WDTIS_1 = 0x1,
    WDTIS_2 = 0x2,
    WDTIS_3 = 0x3,
    WDTIS_4 = 0x4,
    WDTIS_5 = 0x5,
    WDTIS_6 = 0x6,
    WDTIS_7 = 0x7,
};

/// Watchdog timer counter clear
/// Register: WDTCTL
/// Field: WDTCNTCL [3:3]
enum class WDT_A_WDTCTL_WDTCNTCL : uint16_t {
    WDTCNTCL_0 = 0x0,
    WDTCNTCL_1 = 0x1,
};

/// Watchdog timer mode select
/// Register: WDTCTL
/// Field: WDTTMSEL [4:4]
enum class WDT_A_WDTCTL_WDTTMSEL : uint16_t {
    WDTTMSEL_0 = 0x0,
    WDTTMSEL_1 = 0x1,
};

/// Watchdog timer clock source select
/// Register: WDTCTL
/// Field: WDTSSEL [5:6]
enum class WDT_A_WDTCTL_WDTSSEL : uint16_t {
    WDTSSEL_0 = 0x0,
    WDTSSEL_1 = 0x1,
    WDTSSEL_2 = 0x2,
    WDTSSEL_3 = 0x3,
};

/// Watchdog timer hold
/// Register: WDTCTL
/// Field: WDTHOLD [7:7]
enum class WDT_A_WDTCTL_WDTHOLD : uint16_t {
    WDTHOLD_0 = 0x0,
    WDTHOLD_1 = 0x1,
};

/// Total enumerated types: 1517

}  // namespace alloy::hal::ti::msp432::msp432p411v::enums
