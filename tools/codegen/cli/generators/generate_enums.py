#!/usr/bin/env python3
"""
Generate Enumeration Definitions from SVD

This generator creates type-safe enum classes for register field enumerated values.
It extracts enumerated values from SVD files and generates scoped C++ enum classes
with proper underlying types and comprehensive documentation.

Part of Phase 2: Enumeration Generator
"""

import sys
from pathlib import Path
from typing import List, Dict, Set, Optional

# Add parent to path
CODEGEN_DIR = Path(__file__).parent.parent.parent
sys.path.insert(0, str(CODEGEN_DIR))

from cli.core.logger import print_header, print_success, print_error, print_info, logger
from cli.core.config import normalize_name
from cli.core.paths import get_mcu_output_dir, ensure_dir
from cli.parsers.generic_svd import parse_svd, SVDDevice, Peripheral, Register, RegisterField
from cli.core.progress import get_global_tracker


def get_enum_underlying_type(register_size: int) -> str:
    """
    Get appropriate C++ underlying type for enum based on register size.

    Args:
        register_size: Register size in bits (8, 16, or 32)

    Returns:
        C++ type string (uint8_t, uint16_t, or uint32_t)
    """
    if register_size <= 8:
        return "uint8_t"
    elif register_size <= 16:
        return "uint16_t"
    else:
        return "uint32_t"


def sanitize_identifier(name: str) -> str:
    """
    Sanitize a string to be a valid C++ identifier.

    Removes placeholder patterns like %s, [s], etc., and replaces
    invalid characters with underscores.

    Args:
        name: Original name from SVD

    Returns:
        Valid C++ identifier
    """
    import re

    # Remove common placeholder patterns used in register arrays
    sanitized = name.replace('%S', '').replace('%s', '').replace('[S]', '').replace('[s]', '')

    # Remove other invalid C++ identifier characters
    sanitized = re.sub(r'[^A-Za-z0-9_]', '_', sanitized)

    # Remove leading/trailing underscores
    sanitized = sanitized.strip('_')

    return sanitized


def make_enum_name(peripheral: Peripheral, register: Register, field: RegisterField) -> str:
    """
    Generate enum class name following convention: {Peripheral}_{Register}_{Field}

    Args:
        peripheral: Peripheral containing the register
        register: Register containing the field
        field: Field with enumerated values

    Returns:
        Formatted enum class name
    """
    periph_name = sanitize_identifier(peripheral.name).upper()
    reg_name = sanitize_identifier(register.name).upper()
    field_name = sanitize_identifier(field.name).upper()

    return f"{periph_name}_{reg_name}_{field_name}"


def validate_enum_values(field: RegisterField, register_size: int) -> bool:
    """
    Validate that all enum values fit within the field's bit width.

    Args:
        field: Field with enumerated values
        register_size: Register size in bits

    Returns:
        True if all values are valid
    """
    if not field.enum_values:
        return True

    max_value = (1 << field.bit_width) - 1

    for enum_name, enum_value in field.enum_values.items():
        if enum_value > max_value:
            logger.warning(
                f"Enum value {enum_name}={enum_value} exceeds field width "
                f"{field.bit_width} bits (max: {max_value})"
            )
            return False

    return True


def collect_enumerations(device: SVDDevice) -> List[tuple]:
    """
    Collect all enumerated fields from device peripherals.

    Args:
        device: Parsed device with peripherals

    Returns:
        List of tuples: (peripheral, register, field)
    """
    enumerations = []

    for peripheral in device.peripherals.values():
        for register in peripheral.registers:
            for field in register.fields:
                if field.enum_values:
                    # Validate before adding
                    if validate_enum_values(field, register.size):
                        enumerations.append((peripheral, register, field))

    return enumerations


def generate_enums_header(device: SVDDevice) -> str:
    """
    Generate complete enums.hpp header with all enumerated types.

    Args:
        device: Device with peripheral enumerations

    Returns:
        C++ header content
    """
    vendor_ns = device.vendor_normalized
    family_ns = normalize_name(device.family)
    mcu_ns = normalize_name(device.name)

    # Header
    content = f"""/// Auto-generated enumeration definitions
/// Device: {device.name}
/// Vendor: {device.vendor}
///
/// This file contains type-safe enum classes for all register field
/// enumerated values extracted from the CMSIS-SVD file.
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::enums {{

// ============================================================================
// ENUMERATED VALUE DEFINITIONS
// ============================================================================

"""

    # Collect all enumerations
    enumerations = collect_enumerations(device)

    if not enumerations:
        content += "// No enumerated values found in SVD file\n\n"
    else:
        # Group by peripheral for better organization
        peripheral_groups = {}
        for peripheral, register, field in enumerations:
            if peripheral.name not in peripheral_groups:
                peripheral_groups[peripheral.name] = []
            peripheral_groups[peripheral.name].append((register, field))

        # Track generated enum names to avoid duplicates
        generated_enums = set()

        # Generate enums grouped by peripheral
        for periph_name in sorted(peripheral_groups.keys()):
            peripheral = device.peripherals[periph_name]
            content += f"// {'-' * 76}\n"
            content += f"// {peripheral.name} - {peripheral.description or 'Peripheral Enumerations'}\n"
            content += f"// {'-' * 76}\n\n"

            for register, field in peripheral_groups[periph_name]:
                enum_name = make_enum_name(peripheral, register, field)

                # Skip if we've already generated this enum (handles duplicates from register arrays)
                if enum_name in generated_enums:
                    continue

                generated_enums.add(enum_name)
                underlying_type = get_enum_underlying_type(register.size)

                # Sanitize register/field names for comments (keep %s visible but safe)
                reg_name_comment = register.name.replace('*/', '* /')  # Prevent comment termination
                field_name_comment = field.name.replace('*/', '* /')

                # Enum class definition
                content += f"/// {field.description or field_name_comment}\n"
                content += f"/// Register: {reg_name_comment}\n"
                content += f"/// Field: {field_name_comment} [{field.bit_offset}:{field.bit_offset + field.bit_width - 1}]\n"
                content += f"enum class {enum_name} : {underlying_type} {{\n"

                # Enum values
                for enum_value_name, enum_value in sorted(field.enum_values.items(), key=lambda x: x[1]):
                    # Format enum value name to be a valid C++ identifier
                    cpp_enum_name = sanitize_identifier(enum_value_name)

                    # C++ identifiers cannot start with a digit
                    if cpp_enum_name and cpp_enum_name[0].isdigit():
                        cpp_enum_name = f"VAL_{cpp_enum_name}"

                    # Ensure we have a valid name
                    if not cpp_enum_name:
                        cpp_enum_name = f"VALUE_{enum_value:X}"

                    content += f"    {cpp_enum_name} = 0x{enum_value:X}"

                    # Add trailing comma
                    content += ","

                    # Add inline comment if name differs from original
                    if cpp_enum_name != enum_value_name:
                        content += f"  // {enum_value_name}"

                    content += "\n"

                content += "};\n\n"

        content += f"/// Total enumerated types: {len(enumerations)}\n\n"

    content += f"}}  // namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::enums\n"

    return content


def generate_for_device(svd_path: Path, tracker=None) -> bool:
    """
    Generate enums.hpp for a device.

    Args:
        svd_path: Path to SVD file
        tracker: Optional progress tracker

    Returns:
        True if successful
    """
    # Parse SVD
    device = parse_svd(svd_path, auto_classify=True)
    if not device:
        return False

    # Determine output directory
    output_dir = ensure_dir(
        get_mcu_output_dir(
            device.vendor_normalized,
            device.family,
            device.name.lower()
        )
    )

    logger.info(f"Generating enumerations for {device.name} -> {output_dir}")

    # Generate enums.hpp
    enums_file = output_dir / "enums.hpp"

    try:
        enums_content = generate_enums_header(device)
        enums_file.write_text(enums_content)

        # Count enumerations
        enum_count = len(collect_enumerations(device))
        logger.info(f"Generated enums.hpp with {enum_count} enumerated types")

        return True
    except Exception as e:
        logger.error(f"Failed to generate enums.hpp: {e}")
        return False


def discover_mcus_with_pins() -> List[str]:
    """
    Discover MCUs that have pin_functions.hpp generated.

    Returns:
        List of MCU names that have pin functions
    """
    from cli.core.config import HAL_VENDORS_DIR

    mcus_with_pins = []

    # Find all pin_functions.hpp files
    pin_files = HAL_VENDORS_DIR.rglob("**/pin_functions.hpp")

    for pin_file in pin_files:
        # Extract MCU name from path
        # Path structure: src/hal/vendors/{vendor}/{family}/{mcu}/pin_functions.hpp
        mcu_name = pin_file.parent.name
        if mcu_name not in mcus_with_pins:
            mcus_with_pins.append(mcu_name)

    return sorted(mcus_with_pins)


def generate_for_board_mcus(verbose: bool = False, tracker=None) -> int:
    """
    Generate enumeration headers for all MCUs with pin functions.

    This ensures enums are generated for every MCU that has
    pin_functions.hpp, not just board MCUs.

    Args:
        verbose: Enable verbose output
        tracker: Optional progress tracker

    Returns:
        Exit code (0 for success)
    """
    print_header("Generating Enumeration Definitions for MCUs with Pin Functions")

    if tracker:
        tracker.set_generator("enums")

    # Discover MCUs that have pin functions
    mcus_with_pins = discover_mcus_with_pins()

    if not mcus_with_pins:
        print_error("No MCUs with pin_functions.hpp found!")
        print_info("Run pin generation first: python3 codegen.py generate --pins")
        return 1

    print_info(f"Found {len(mcus_with_pins)} MCU(s) with pin functions:")
    if verbose:
        for mcu in mcus_with_pins:
            print_info(f"  • {mcu}")

    # Use SVD discovery
    from cli.parsers.svd_discovery import discover_all_svds

    print_info(f"Discovering SVD files...")
    all_svds = discover_all_svds()

    # Find SVD files for MCUs with pins by matching names
    from cli.parsers.svd_discovery import find_svd_for_mcu

    matching_files = []
    for mcu_name in mcus_with_pins:
        # Use smart matching helper
        svd_file = find_svd_for_mcu(mcu_name, all_svds)

        if svd_file:
            matching_files.append(svd_file.file_path)
            if verbose:
                print_info(f"  ✓ {mcu_name} → {svd_file.file_path.name}")
        else:
            if verbose:
                print_info(f"  ✗ {mcu_name} (no SVD found)")
            logger.warning(f"No SVD found for MCU with pins: {mcu_name}")

    print_info(f"Found SVD files for {len(matching_files)}/{len(mcus_with_pins)} MCU(s)")

    if not matching_files:
        print_error("No MCUs with SVD files found!")
        return 1

    # Generate for each MCU
    success_count = 0
    for svd_file in matching_files:
        if generate_for_device(svd_file, tracker):
            success_count += 1

    print_success(f"Generated enumerations for {success_count}/{len(matching_files)} MCU(s)")
    return 0 if success_count == len(matching_files) else 1


def main():
    """Main entry point"""
    import argparse
    from cli.core.config import SVD_DIR

    parser = argparse.ArgumentParser(description='Generate enumeration definitions from SVD')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    parser.add_argument('--svd', help='Generate for specific SVD file')
    args = parser.parse_args()

    if args.svd:
        # Generate for specific SVD
        svd_path = Path(args.svd)
        if not svd_path.is_absolute():
            svd_path = SVD_DIR / svd_path

        if not svd_path.exists():
            print_error(f"SVD file not found: {svd_path}")
            return 1

        success = generate_for_device(svd_path)
        return 0 if success else 1
    else:
        # Generate for all board MCUs
        return generate_for_board_mcus(args.verbose)


if __name__ == '__main__':
    sys.exit(main())
