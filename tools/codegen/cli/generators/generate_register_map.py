#!/usr/bin/env python3
"""
Generate Complete Register Map

This generator creates a single-include header file that provides access to
all generated register definitions, bit fields, enumerations, and pin functions
for an MCU. This is the convenience header that users typically include.

Part of Phase 4: Complete Register Map Generator
"""

import sys
from pathlib import Path
from typing import List, Set

# Add parent to path
CODEGEN_DIR = Path(__file__).parent.parent.parent
sys.path.insert(0, str(CODEGEN_DIR))

from cli.core.logger import print_header, print_success, print_error, print_info, logger
from cli.core.config import normalize_name, BOARD_MCUS
from cli.core.paths import get_mcu_output_dir, ensure_dir
from cli.parsers.generic_svd import parse_svd, SVDDevice
from cli.core.progress import get_global_tracker


def get_generated_peripheral_files(output_dir: Path) -> tuple[List[str], List[str]]:
    """
    Scan output directory for generated peripheral files.

    Returns:
        Tuple of (register_files, bitfield_files) lists with peripheral names
    """
    registers_dir = output_dir / "registers"
    bitfields_dir = output_dir / "bitfields"

    register_files = []
    bitfield_files = []

    if registers_dir.exists():
        for file in sorted(registers_dir.glob("*_registers.hpp")):
            # Extract peripheral name (e.g., "rcc_registers.hpp" -> "rcc")
            periph_name = file.stem.replace("_registers", "")
            register_files.append(periph_name)

    if bitfields_dir.exists():
        for file in sorted(bitfields_dir.glob("*_bitfields.hpp")):
            # Extract peripheral name
            periph_name = file.stem.replace("_bitfields", "")
            bitfield_files.append(periph_name)

    return register_files, bitfield_files


def generate_register_map_header(device: SVDDevice, output_dir: Path) -> str:
    """
    Generate complete register_map.hpp with all includes.

    Args:
        device: Parsed device information
        output_dir: Output directory to scan for generated files

    Returns:
        C++ header content
    """
    vendor_ns = device.vendor_normalized
    family_ns = normalize_name(device.family)
    mcu_ns = normalize_name(device.name)

    # Scan for generated files
    register_files, bitfield_files = get_generated_peripheral_files(output_dir)

    # Check for optional files
    has_enums = (output_dir / "enums.hpp").exists()
    has_pin_functions = (output_dir / "pin_functions.hpp").exists()
    has_bitfield_utils = (output_dir / "bitfield_utils.hpp").exists()

    # Header
    content = f"""/// Complete Register Map for {device.name}
/// Generated by Alloy Code Generator from CMSIS-SVD
///
/// Device:  {device.name}
/// Vendor:  {device.vendor}
/// Family:  {device.family}
/// CPU:     {device.cpu_name or 'N/A'}
///
/// This is the main convenience header that includes all generated
/// register definitions, bit fields, enumerations, and utilities.
///
/// Usage:
///   #include <hal/{vendor_ns}/{family_ns}/{mcu_ns}/register_map.hpp>
///
///   using namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns};
///
///   // Access registers
///   rcc::RCC->CR = rcc::cr::HSEON::set(rcc::RCC->CR);
///
/// DO NOT EDIT - Regenerate if SVD file changes

#pragma once

// ============================================================================
// Core utilities
// ============================================================================

"""

    # Include bitfield utilities first (needed by bitfields)
    if has_bitfield_utils:
        content += '#include "bitfield_utils.hpp"\n\n'

    # Include all peripheral registers
    if register_files:
        content += "// ============================================================================\n"
        content += "// Peripheral Register Structures\n"
        content += "// ============================================================================\n\n"

        for periph in register_files:
            content += f'#include "registers/{periph}_registers.hpp"\n'
        content += "\n"

    # Include all peripheral bitfields
    if bitfield_files:
        content += "// ============================================================================\n"
        content += "// Peripheral Bit Field Definitions\n"
        content += "// ============================================================================\n\n"

        for periph in bitfield_files:
            content += f'#include "bitfields/{periph}_bitfields.hpp"\n'
        content += "\n"

    # Include enumerations
    if has_enums:
        content += "// ============================================================================\n"
        content += "// Enumerated Value Definitions\n"
        content += "// ============================================================================\n\n"
        content += '#include "enums.hpp"\n\n'

    # Include pin functions
    if has_pin_functions:
        content += "// ============================================================================\n"
        content += "// Pin Alternate Function Mappings\n"
        content += "// ============================================================================\n\n"
        content += '#include "pin_functions.hpp"\n\n'

    # Namespace section
    content += f"""// ============================================================================
// Namespace Convenience Aliases
// ============================================================================

namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns} {{

/// Main namespace alias for this MCU
///
/// Usage:
///   using namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns};
///   // Now you can use rcc::RCC, gpio::GPIOA, etc.

}}  // namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}

// ============================================================================
// Global Namespace Aliases (Optional)
// ============================================================================

/// You can define shorter aliases if desired:
///
/// namespace mcu = alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns};
///
/// Then use:
///   mcu::rcc::RCC->CR = ...

"""

    # Add summary
    content += f"""// ============================================================================
// Generated File Summary
// ============================================================================
//
// This header includes:
//   - {len(register_files)} peripheral register structures
//   - {len(bitfield_files)} peripheral bit field definitions
"""

    if has_enums:
        content += "//   - Enumeration definitions\n"
    if has_pin_functions:
        content += "//   - Pin alternate function mappings\n"
    if has_bitfield_utils:
        content += "//   - BitField template utilities\n"

    content += f"""//
// Total peripherals with registers: {len(register_files)}
//
// For detailed documentation, see:
//   - REGISTER_USAGE.md (register access patterns)
//   - BITFIELD_USAGE.md (bit field operations)
//   - ENUM_USAGE.md (enumeration usage)
//   - PIN_FUNCTIONS_USAGE.md (pin configuration)
//
"""

    return content


def generate_for_device(svd_path: Path, tracker=None) -> bool:
    """
    Generate register_map.hpp for a device.

    Args:
        svd_path: Path to SVD file
        tracker: Optional progress tracker

    Returns:
        True if successful
    """
    # Parse SVD
    device = parse_svd(svd_path, auto_classify=True)
    if not device:
        return False

    # Determine output directory
    output_dir = ensure_dir(
        get_mcu_output_dir(
            device.vendor_normalized,
            device.family,
            device.name.lower()
        )
    )

    logger.info(f"Generating register map for {device.name} -> {output_dir}")

    # Generate register_map.hpp
    register_map_file = output_dir / "register_map.hpp"

    try:
        content = generate_register_map_header(device, output_dir)
        register_map_file.write_text(content)

        # Count included files
        register_files, bitfield_files = get_generated_peripheral_files(output_dir)
        total_files = len(register_files) + len(bitfield_files)

        logger.info(f"Generated register_map.hpp including {total_files} files")
        return True
    except Exception as e:
        logger.error(f"Failed to generate register_map.hpp: {e}")
        return False


def generate_for_board_mcus(verbose: bool = False, tracker=None) -> int:
    """
    Generate register map headers for all board MCUs.

    Args:
        verbose: Enable verbose output
        tracker: Optional progress tracker

    Returns:
        Exit code (0 for success)
    """
    print_header("Generating Complete Register Maps for Board MCUs")

    if tracker:
        tracker.set_generator("register_map")

    # Use SVD discovery
    from cli.parsers.svd_discovery import discover_all_svds

    print_info(f"Discovering SVD files for {len(BOARD_MCUS)} board MCUs...")
    all_svds = discover_all_svds()

    # Find SVD files for board MCUs
    matching_files = []
    for board_mcu in BOARD_MCUS:
        mcu_normalized = normalize_name(board_mcu)
        possible_names = [
            board_mcu,
            f"{board_mcu}xx",
            mcu_normalized,
            f"{mcu_normalized}xx",
        ]

        found = False
        for possible_name in possible_names:
            if possible_name in all_svds:
                matching_files.append(all_svds[possible_name].file_path)
                if verbose:
                    print_info(f"  ✓ {board_mcu} → {all_svds[possible_name].file_path.name}")
                found = True
                break

        if not found and verbose:
            print_info(f"  ✗ {board_mcu} (no SVD found)")

    print_info(f"Found SVD files for {len(matching_files)}/{len(BOARD_MCUS)} board MCU(s)")

    if not matching_files:
        print_error("No board MCUs found!")
        return 1

    # Generate for each MCU
    success_count = 0
    for svd_file in matching_files:
        if generate_for_device(svd_file, tracker):
            success_count += 1

    print_success(f"Generated register maps for {success_count}/{len(matching_files)} MCU(s)")
    return 0 if success_count == len(matching_files) else 1


def main():
    """Main entry point"""
    import argparse
    from cli.core.config import SVD_DIR

    parser = argparse.ArgumentParser(description='Generate complete register map')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    parser.add_argument('--svd', help='Generate for specific SVD file')
    args = parser.parse_args()

    if args.svd:
        # Generate for specific SVD
        svd_path = Path(args.svd)
        if not svd_path.is_absolute():
            svd_path = SVD_DIR / svd_path

        if not svd_path.exists():
            print_error(f"SVD file not found: {svd_path}")
            return 1

        success = generate_for_device(svd_path)
        return 0 if success else 1
    else:
        # Generate for all board MCUs
        return generate_for_board_mcus(args.verbose)


if __name__ == '__main__':
    sys.exit(main())
