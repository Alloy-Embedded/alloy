#!/usr/bin/env python3
"""
Generate Register Structure Headers from SVD

This generator creates type-safe register structure definitions from parsed SVD data.
It generates:
1. Register structures with volatile members
2. Peripheral-specific register definitions
3. Bit field constants for each register field

Part of Phase 1: Enhanced SVD Parser + Basic Register Generation
"""

import sys
from pathlib import Path
from typing import List, Optional, Set

# Add parent to path
CODEGEN_DIR = Path(__file__).parent.parent.parent
sys.path.insert(0, str(CODEGEN_DIR))

from cli.core.logger import print_header, print_success, print_error, print_info, logger
from cli.core.config import normalize_name
from cli.core.paths import get_mcu_output_dir, ensure_dir, get_family_dir
from cli.parsers.generic_svd import parse_svd, SVDDevice, Peripheral, Register, RegisterField
from cli.core.progress import get_global_tracker
import re


def sanitize_namespace_name(name: str) -> str:
    """
    Sanitize a register or field name to be a valid C++ namespace identifier.

    Handles register arrays by removing array syntax (e.g., "ABCDSR[2]" -> "abcdsr").
    This is necessary because C++ namespaces cannot contain brackets.
    Also sanitizes C++ reserved keywords by appending underscore.

    Args:
        name: Original register/field name from SVD (may contain array syntax)

    Returns:
        Valid C++ namespace identifier (lowercase, no array brackets, no reserved keywords)

    Examples:
        "ABCDSR[2]" -> "abcdsr"
        "GPIO_PINn[16]" -> "gpio_pinn"
        "NORMAL_REG" -> "normal_reg"
        "ASM" -> "asm_"
        "CLASS" -> "class_"
    """
    # C++ reserved keywords that cannot be used as identifiers
    CPP_KEYWORDS = {
        'alignas', 'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand', 'bitor',
        'bool', 'break', 'case', 'catch', 'char', 'char8_t', 'char16_t', 'char32_t',
        'class', 'compl', 'concept', 'const', 'consteval', 'constexpr', 'constinit',
        'const_cast', 'continue', 'co_await', 'co_return', 'co_yield', 'decltype',
        'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
        'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto',
        'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new', 'noexcept',
        'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 'private', 'protected',
        'public', 'register', 'reinterpret_cast', 'requires', 'return', 'short',
        'signed', 'sizeof', 'static', 'static_assert', 'static_cast', 'struct',
        'switch', 'template', 'this', 'thread_local', 'throw', 'true', 'try',
        'typedef', 'typeid', 'typename', 'union', 'unsigned', 'using', 'virtual',
        'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq'
    }

    # Remove array syntax: [2], [16], etc.
    sanitized = re.sub(r'\[\d+\]', '', name)

    # Remove any remaining bracket artifacts
    sanitized = sanitized.replace('[', '').replace(']', '')

    # Convert to lowercase for namespace convention
    sanitized = sanitized.lower()

    # Check if it's a reserved keyword and append underscore if so
    if sanitized in CPP_KEYWORDS:
        sanitized = sanitized + '_'

    return sanitized


def generate_register_struct(peripheral: Peripheral, device: SVDDevice) -> str:
    """
    Generate C++ register structure for a peripheral.

    Args:
        peripheral: Peripheral with registers
        device: Device information for namespace

    Returns:
        C++ header content with register struct
    """
    vendor_ns = device.vendor_normalized
    family_ns = normalize_name(device.family)
    mcu_ns = normalize_name(device.name)
    periph_ns = normalize_name(peripheral.name)

    # Header
    content = f"""/// Auto-generated register definitions for {peripheral.name}
/// Device: {device.name}
/// Vendor: {device.vendor}
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>

namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::{periph_ns} {{

// ============================================================================
// {peripheral.name} - {peripheral.description or 'Peripheral Registers'}
// Base Address: 0x{peripheral.base_address:08X}
// ============================================================================

"""

    # Generate register structure
    if peripheral.registers:
        content += f"/// {peripheral.name} Register Structure\n"
        content += f"struct {peripheral.name}_Registers {{\n"

        current_offset = 0
        for register in sorted(peripheral.registers, key=lambda r: r.offset):
            # Add padding if needed
            if register.offset > current_offset:
                padding_bytes = register.offset - current_offset
                padding_name = f"RESERVED_{current_offset:04X}"
                content += f"    uint8_t {padding_name}[{padding_bytes}]; ///< Reserved\n"

            # Register comment
            desc = register.description or register.name
            content += f"\n    /// {desc}\n"
            content += f"    /// Offset: 0x{register.offset:04X}\n"
            if register.reset_value is not None:
                content += f"    /// Reset value: 0x{register.reset_value:08X}\n"
            if register.access:
                content += f"    /// Access: {register.access}\n"

            # Register member
            reg_type = f"uint{register.size}_t"
            if register.dim and register.dim > 1:
                # Register array (e.g., ABCDSR[2])
                content += f"    volatile {reg_type} {register.name}[{register.dim}];\n"
                current_offset = register.offset + (register.size // 8) * register.dim
            else:
                # Single register
                content += f"    volatile {reg_type} {register.name};\n"
                current_offset = register.offset + (register.size // 8)

        content += "};\n\n"

        # Static assertion for struct size
        content += f"static_assert(sizeof({peripheral.name}_Registers) >= {current_offset}, "
        content += f"\"{peripheral.name}_Registers size mismatch\");\n\n"

        # Global pointer instance - use inline function instead of constexpr reinterpret_cast
        # (reinterpret_cast is not allowed in constexpr context in C++17)
        content += f"/// {peripheral.name} peripheral instance\n"
        content += f"inline {peripheral.name}_Registers* {peripheral.name}() {{\n"
        content += f"    return reinterpret_cast<{peripheral.name}_Registers*>(0x{peripheral.base_address:08X});\n"
        content += f"}}\n\n"
    else:
        content += f"// No registers defined for {peripheral.name}\n\n"

    content += f"}}  // namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::{periph_ns}\n"

    return content


def generate_bitfield_definitions(peripheral: Peripheral, device: SVDDevice) -> str:
    """
    Generate bit field definitions for a peripheral's registers.

    Args:
        peripheral: Peripheral with registers and fields
        device: Device information

    Returns:
        C++ header content with bit field definitions
    """
    vendor_ns = device.vendor_normalized
    family_ns = normalize_name(device.family)
    mcu_ns = normalize_name(device.name)
    periph_ns = normalize_name(peripheral.name)

    # Header
    content = f"""/// Auto-generated bit field definitions for {peripheral.name}
/// Device: {device.name}
/// Vendor: {device.vendor}
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <stdint.h>
#include "hal/utils/bitfield.hpp"

namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::{periph_ns} {{

using namespace alloy::hal::bitfields;

// ============================================================================
// {peripheral.name} Bit Field Definitions
// ============================================================================

"""

    # Generate bit fields for each register
    for register in sorted(peripheral.registers, key=lambda r: r.offset):
        if not register.fields:
            continue

        # Sanitize register name for namespace (removes array syntax like [2])
        reg_name_lower = sanitize_namespace_name(register.name)
        content += f"/// {register.name} - {register.description or register.name}\n"
        content += f"namespace {reg_name_lower} {{\n"

        for field in sorted(register.fields, key=lambda f: f.bit_offset):
            # Field comment
            if field.description:
                content += f"    /// {field.description}\n"
            content += f"    /// Position: {field.bit_offset}, Width: {field.bit_width}\n"
            if field.access:
                content += f"    /// Access: {field.access}\n"

            # BitField type alias
            content += f"    using {field.name} = BitField<{field.bit_offset}, {field.bit_width}>;\n"

            # CMSIS-compatible constants
            content += f"    constexpr uint32_t {field.name}_Pos = {field.bit_offset};\n"
            content += f"    constexpr uint32_t {field.name}_Msk = {field.name}::mask;\n"

            # Enumerated values if present
            if field.enum_values:
                field_name_sanitized = sanitize_namespace_name(field.name)
                content += f"    /// Enumerated values for {field.name}\n"
                content += f"    namespace {field_name_sanitized} {{\n"
                for enum_name, enum_value in field.enum_values.items():
                    content += f"        constexpr uint32_t {enum_name} = {enum_value};\n"
                content += "    }\n"

            content += "\n"

        content += f"}}  // namespace {reg_name_lower}\n\n"

    content += f"}}  // namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::{periph_ns}\n"

    return content


def generate_for_peripheral(peripheral: Peripheral, device: SVDDevice,
                            output_dir: Path, tracker=None) -> bool:
    """
    Generate register and bitfield headers for a single peripheral.

    Args:
        peripheral: Peripheral to generate for
        device: Device information
        output_dir: Output directory for generated files
        tracker: Optional progress tracker

    Returns:
        True if successful
    """
    # Skip peripherals with no registers
    if not peripheral.registers:
        logger.debug(f"Skipping {peripheral.name} (no registers)")
        return True

    periph_name_lower = peripheral.name.lower()
    success = True

    # Generate register structure
    registers_dir = ensure_dir(output_dir / "registers")
    register_file = registers_dir / f"{periph_name_lower}_registers.hpp"

    try:
        register_content = generate_register_struct(peripheral, device)
        register_file.write_text(register_content)
        logger.debug(f"Generated {register_file.name}")
    except Exception as e:
        logger.error(f"Failed to generate register struct for {peripheral.name}: {e}")
        success = False

    # Generate bit field definitions
    bitfields_dir = ensure_dir(output_dir / "bitfields")
    bitfield_file = bitfields_dir / f"{periph_name_lower}_bitfields.hpp"

    try:
        bitfield_content = generate_bitfield_definitions(peripheral, device)
        bitfield_file.write_text(bitfield_content)
        logger.debug(f"Generated {bitfield_file.name}")
    except Exception as e:
        logger.error(f"Failed to generate bitfields for {peripheral.name}: {e}")
        success = False

    return success


def generate_for_device(svd_path: Path, tracker=None) -> bool:
    """
    Generate register and bitfield headers for a device.

    Args:
        svd_path: Path to SVD file
        tracker: Optional progress tracker

    Returns:
        True if successful
    """
    # Parse SVD
    device = parse_svd(svd_path, auto_classify=True)
    if not device:
        return False

    # Determine output directory
    output_dir = ensure_dir(
        get_mcu_output_dir(
            device.vendor_normalized,
            device.family,
            device.name.lower()
        )
    )

    logger.info(f"Generating registers for {device.name} -> {output_dir}")

    # Note: bitfield_utils.hpp is now shared at src/hal/utils/bitfield.hpp
    # No need to copy per-MCU anymore

    # Generate for each peripheral
    success_count = 0
    total_count = 0

    for peripheral in device.peripherals.values():
        if peripheral.registers:  # Only count peripherals with registers
            total_count += 1
            if generate_for_peripheral(peripheral, device, output_dir, tracker):
                success_count += 1

    logger.info(f"Generated registers for {success_count}/{total_count} peripherals")
    return success_count == total_count


def discover_mcus_with_pins() -> List[str]:
    """
    Discover MCUs that have pin_functions.hpp generated.

    Returns:
        List of MCU names that have pin functions
    """
    from cli.core.config import HAL_VENDORS_DIR

    mcus_with_pins = []

    # Find all pin_functions.hpp files
    pin_files = HAL_VENDORS_DIR.rglob("**/pin_functions.hpp")

    for pin_file in pin_files:
        # Extract MCU name from path
        # Path structure: src/hal/vendors/{vendor}/{family}/{mcu}/pin_functions.hpp
        mcu_name = pin_file.parent.name
        if mcu_name not in mcus_with_pins:
            mcus_with_pins.append(mcu_name)

    return sorted(mcus_with_pins)


def generate_for_board_mcus(verbose: bool = False, tracker=None) -> int:
    """
    Generate register headers for all MCUs with pin functions.

    This ensures registers and bitfields are generated for every MCU that has
    pin_functions.hpp, not just board MCUs.

    Args:
        verbose: Enable verbose output
        tracker: Optional progress tracker

    Returns:
        Exit code (0 for success)
    """
    print_header("Generating Register Structures for MCUs with Pin Functions")

    if tracker:
        tracker.set_generator("registers")

    # Discover MCUs that have pin functions
    mcus_with_pins = discover_mcus_with_pins()

    if not mcus_with_pins:
        print_error("No MCUs with pin_functions.hpp found!")
        print_info("Run pin generation first: python3 codegen.py generate --pins")
        return 1

    print_info(f"Found {len(mcus_with_pins)} MCU(s) with pin functions:")
    if verbose:
        for mcu in mcus_with_pins:
            print_info(f"  • {mcu}")

    # Use SVD discovery
    from cli.parsers.svd_discovery import discover_all_svds

    print_info(f"Discovering SVD files...")
    all_svds = discover_all_svds()

    # Find SVD files for MCUs with pins by matching names
    matching_files = []
    for mcu_name in mcus_with_pins:
        # Try common SVD naming patterns
        mcu_upper = mcu_name.upper()
        mcu_normalized = normalize_name(mcu_name)
        possible_names = [
            mcu_name,
            mcu_upper,
            f"{mcu_upper}xx",
            mcu_normalized,
            f"{mcu_normalized}xx",
        ]

        found = False
        for possible_name in possible_names:
            if possible_name in all_svds:
                matching_files.append(all_svds[possible_name].file_path)
                if verbose:
                    print_info(f"  ✓ {mcu_name} → {all_svds[possible_name].file_path.name}")
                found = True
                break

        if not found:
            if verbose:
                print_info(f"  ✗ {mcu_name} (no SVD found)")
            logger.warning(f"No SVD found for MCU with pins: {mcu_name}")

    print_info(f"Found SVD files for {len(matching_files)}/{len(mcus_with_pins)} MCU(s)")

    if not matching_files:
        print_error("No MCUs with SVD files found!")
        return 1

    # Generate for each MCU
    success_count = 0
    for svd_file in matching_files:
        if generate_for_device(svd_file, tracker):
            success_count += 1

    print_success(f"Generated registers for {success_count}/{len(matching_files)} MCU(s)")
    return 0 if success_count == len(matching_files) else 1


def main():
    """Main entry point"""
    import argparse
    from cli.core.config import SVD_DIR

    parser = argparse.ArgumentParser(description='Generate register structures from SVD')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    parser.add_argument('--svd', help='Generate for specific SVD file')
    args = parser.parse_args()

    if args.svd:
        # Generate for specific SVD
        svd_path = Path(args.svd)
        if not svd_path.is_absolute():
            svd_path = SVD_DIR / svd_path

        if not svd_path.exists():
            print_error(f"SVD file not found: {svd_path}")
            return 1

        success = generate_for_device(svd_path)
        return 0 if success else 1
    else:
        # Generate for all board MCUs
        return generate_for_board_mcus(args.verbose)


if __name__ == '__main__':
    sys.exit(main())
