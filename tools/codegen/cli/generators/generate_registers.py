#!/usr/bin/env python3
"""
Generate Register Structure Headers from SVD

This generator creates type-safe register structure definitions from parsed SVD data.
It generates:
1. Register structures with volatile members
2. Peripheral-specific register definitions
3. Bit field constants for each register field

Part of Phase 1: Enhanced SVD Parser + Basic Register Generation
"""

import sys
from pathlib import Path
from typing import List, Optional, Set

# Add parent to path
CODEGEN_DIR = Path(__file__).parent.parent.parent
sys.path.insert(0, str(CODEGEN_DIR))

from cli.core.logger import print_header, print_success, print_error, print_info, logger
from cli.core.config import normalize_name, BOARD_MCUS
from cli.core.paths import get_mcu_output_dir, ensure_dir, get_family_dir
from cli.parsers.generic_svd import parse_svd, SVDDevice, Peripheral, Register, RegisterField
from cli.core.progress import get_global_tracker


def generate_register_struct(peripheral: Peripheral, device: SVDDevice) -> str:
    """
    Generate C++ register structure for a peripheral.

    Args:
        peripheral: Peripheral with registers
        device: Device information for namespace

    Returns:
        C++ header content with register struct
    """
    vendor_ns = device.vendor_normalized
    family_ns = normalize_name(device.family)
    mcu_ns = normalize_name(device.name)
    periph_ns = normalize_name(peripheral.name)

    # Header
    content = f"""/// Auto-generated register definitions for {peripheral.name}
/// Device: {device.name}
/// Vendor: {device.vendor}
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>

namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::{periph_ns} {{

// ============================================================================
// {peripheral.name} - {peripheral.description or 'Peripheral Registers'}
// Base Address: 0x{peripheral.base_address:08X}
// ============================================================================

"""

    # Generate register structure
    if peripheral.registers:
        content += f"/// {peripheral.name} Register Structure\n"
        content += f"struct {peripheral.name}_Registers {{\n"

        current_offset = 0
        for register in sorted(peripheral.registers, key=lambda r: r.offset):
            # Add padding if needed
            if register.offset > current_offset:
                padding_bytes = register.offset - current_offset
                padding_name = f"RESERVED_{current_offset:04X}"
                content += f"    uint8_t {padding_name}[{padding_bytes}]; ///< Reserved\n"

            # Register comment
            desc = register.description or register.name
            content += f"\n    /// {desc}\n"
            content += f"    /// Offset: 0x{register.offset:04X}\n"
            if register.reset_value is not None:
                content += f"    /// Reset value: 0x{register.reset_value:08X}\n"
            if register.access:
                content += f"    /// Access: {register.access}\n"

            # Register member
            reg_type = f"uint{register.size}_t"
            content += f"    volatile {reg_type} {register.name};\n"

            current_offset = register.offset + (register.size // 8)

        content += "};\n\n"

        # Static assertion for struct size
        content += f"static_assert(sizeof({peripheral.name}_Registers) >= {current_offset}, "
        content += f"\"{peripheral.name}_Registers size mismatch\");\n\n"

        # Global pointer instance
        content += f"/// {peripheral.name} peripheral instance\n"
        content += f"constexpr {peripheral.name}_Registers* {peripheral.name} = \n"
        content += f"    reinterpret_cast<{peripheral.name}_Registers*>(0x{peripheral.base_address:08X});\n\n"
    else:
        content += f"// No registers defined for {peripheral.name}\n\n"

    content += f"}}  // namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::{periph_ns}\n"

    return content


def generate_bitfield_definitions(peripheral: Peripheral, device: SVDDevice) -> str:
    """
    Generate bit field definitions for a peripheral's registers.

    Args:
        peripheral: Peripheral with registers and fields
        device: Device information

    Returns:
        C++ header content with bit field definitions
    """
    vendor_ns = device.vendor_normalized
    family_ns = normalize_name(device.family)
    mcu_ns = normalize_name(device.name)
    periph_ns = normalize_name(peripheral.name)

    # Header
    content = f"""/// Auto-generated bit field definitions for {peripheral.name}
/// Device: {device.name}
/// Vendor: {device.vendor}
///
/// DO NOT EDIT - Generated by Alloy Code Generator from CMSIS-SVD

#pragma once

#include <cstdint>
#include "bitfield_utils.hpp"

namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::{periph_ns} {{

using namespace alloy::hal::bitfields;

// ============================================================================
// {peripheral.name} Bit Field Definitions
// ============================================================================

"""

    # Generate bit fields for each register
    for register in sorted(peripheral.registers, key=lambda r: r.offset):
        if not register.fields:
            continue

        reg_name_lower = register.name.lower()
        content += f"/// {register.name} - {register.description or register.name}\n"
        content += f"namespace {reg_name_lower} {{\n"

        for field in sorted(register.fields, key=lambda f: f.bit_offset):
            # Field comment
            if field.description:
                content += f"    /// {field.description}\n"
            content += f"    /// Position: {field.bit_offset}, Width: {field.bit_width}\n"
            if field.access:
                content += f"    /// Access: {field.access}\n"

            # BitField type alias
            content += f"    using {field.name} = BitField<{field.bit_offset}, {field.bit_width}>;\n"

            # CMSIS-compatible constants
            content += f"    constexpr uint32_t {field.name}_Pos = {field.bit_offset};\n"
            content += f"    constexpr uint32_t {field.name}_Msk = {field.name}::mask;\n"

            # Enumerated values if present
            if field.enum_values:
                content += f"    /// Enumerated values for {field.name}\n"
                content += f"    namespace {field.name.lower()} {{\n"
                for enum_name, enum_value in field.enum_values.items():
                    content += f"        constexpr uint32_t {enum_name} = {enum_value};\n"
                content += "    }\n"

            content += "\n"

        content += f"}}  // namespace {reg_name_lower}\n\n"

    content += f"}}  // namespace alloy::hal::{vendor_ns}::{family_ns}::{mcu_ns}::{periph_ns}\n"

    return content


def generate_for_peripheral(peripheral: Peripheral, device: SVDDevice,
                            output_dir: Path, tracker=None) -> bool:
    """
    Generate register and bitfield headers for a single peripheral.

    Args:
        peripheral: Peripheral to generate for
        device: Device information
        output_dir: Output directory for generated files
        tracker: Optional progress tracker

    Returns:
        True if successful
    """
    # Skip peripherals with no registers
    if not peripheral.registers:
        logger.debug(f"Skipping {peripheral.name} (no registers)")
        return True

    periph_name_lower = peripheral.name.lower()
    success = True

    # Generate register structure
    registers_dir = ensure_dir(output_dir / "registers")
    register_file = registers_dir / f"{periph_name_lower}_registers.hpp"

    try:
        register_content = generate_register_struct(peripheral, device)
        register_file.write_text(register_content)
        logger.debug(f"Generated {register_file.name}")
    except Exception as e:
        logger.error(f"Failed to generate register struct for {peripheral.name}: {e}")
        success = False

    # Generate bit field definitions
    bitfields_dir = ensure_dir(output_dir / "bitfields")
    bitfield_file = bitfields_dir / f"{periph_name_lower}_bitfields.hpp"

    try:
        bitfield_content = generate_bitfield_definitions(peripheral, device)
        bitfield_file.write_text(bitfield_content)
        logger.debug(f"Generated {bitfield_file.name}")
    except Exception as e:
        logger.error(f"Failed to generate bitfields for {peripheral.name}: {e}")
        success = False

    return success


def generate_bitfield_utils(output_dir: Path) -> bool:
    """
    Copy bitfield_utils.hpp template to output directory.

    Args:
        output_dir: Output directory

    Returns:
        True if successful
    """
    import shutil

    template_path = CODEGEN_DIR / "templates" / "bitfield_utils.hpp"
    output_path = output_dir / "bitfield_utils.hpp"

    try:
        shutil.copy(template_path, output_path)
        logger.debug(f"Copied bitfield_utils.hpp to {output_path}")
        return True
    except Exception as e:
        logger.error(f"Failed to copy bitfield_utils.hpp: {e}")
        return False


def generate_for_device(svd_path: Path, tracker=None) -> bool:
    """
    Generate register and bitfield headers for a device.

    Args:
        svd_path: Path to SVD file
        tracker: Optional progress tracker

    Returns:
        True if successful
    """
    # Parse SVD
    device = parse_svd(svd_path, auto_classify=True)
    if not device:
        return False

    # Determine output directory
    output_dir = ensure_dir(
        get_mcu_output_dir(
            device.vendor_normalized,
            device.family,
            device.name.lower()
        )
    )

    logger.info(f"Generating registers for {device.name} -> {output_dir}")

    # Copy bitfield_utils.hpp template
    if not generate_bitfield_utils(output_dir):
        logger.warning("Failed to copy bitfield_utils.hpp, but continuing...")

    # Generate for each peripheral
    success_count = 0
    total_count = 0

    for peripheral in device.peripherals.values():
        if peripheral.registers:  # Only count peripherals with registers
            total_count += 1
            if generate_for_peripheral(peripheral, device, output_dir, tracker):
                success_count += 1

    logger.info(f"Generated registers for {success_count}/{total_count} peripherals")
    return success_count == total_count


def generate_for_board_mcus(verbose: bool = False, tracker=None) -> int:
    """
    Generate register headers for all board MCUs.

    Args:
        verbose: Enable verbose output
        tracker: Optional progress tracker

    Returns:
        Exit code (0 for success)
    """
    print_header("Generating Register Structures for Board MCUs")

    if tracker:
        tracker.set_generator("registers")

    # Use SVD discovery
    from cli.parsers.svd_discovery import discover_all_svds
    from cli.core.config import normalize_name

    print_info(f"Discovering SVD files for {len(BOARD_MCUS)} board MCUs...")
    all_svds = discover_all_svds()

    # Find SVD files for board MCUs
    matching_files = []
    for board_mcu in BOARD_MCUS:
        mcu_normalized = normalize_name(board_mcu)
        possible_names = [
            board_mcu,
            f"{board_mcu}xx",
            mcu_normalized,
            f"{mcu_normalized}xx",
        ]

        found = False
        for possible_name in possible_names:
            if possible_name in all_svds:
                matching_files.append(all_svds[possible_name].file_path)
                if verbose:
                    print_info(f"  ✓ {board_mcu} → {all_svds[possible_name].file_path.name}")
                found = True
                break

        if not found and verbose:
            print_info(f"  ✗ {board_mcu} (no SVD found)")

    print_info(f"Found SVD files for {len(matching_files)}/{len(BOARD_MCUS)} board MCU(s)")

    if not matching_files:
        print_error("No board MCUs found!")
        return 1

    # Generate for each MCU
    success_count = 0
    for svd_file in matching_files:
        if generate_for_device(svd_file, tracker):
            success_count += 1

    print_success(f"Generated registers for {success_count}/{len(matching_files)} MCU(s)")
    return 0 if success_count == len(matching_files) else 1


def main():
    """Main entry point"""
    import argparse
    from cli.core.config import SVD_DIR

    parser = argparse.ArgumentParser(description='Generate register structures from SVD')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    parser.add_argument('--svd', help='Generate for specific SVD file')
    args = parser.parse_args()

    if args.svd:
        # Generate for specific SVD
        svd_path = Path(args.svd)
        if not svd_path.is_absolute():
            svd_path = SVD_DIR / svd_path

        if not svd_path.exists():
            print_error(f"SVD file not found: {svd_path}")
            return 1

        success = generate_for_device(svd_path)
        return 0 if success else 1
    else:
        # Generate for all board MCUs
        return generate_for_board_mcus(args.verbose)


if __name__ == '__main__':
    sys.exit(main())
