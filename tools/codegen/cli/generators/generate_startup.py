"""
Generate startup.cpp and peripherals.hpp from SVD files

This module generates MCU-specific startup code and peripheral definitions
from CMSIS-SVD files using the new generic SVD parser.

Key improvements over previous version:
- Uses generic_svd.SVDParser for consistent parsing
- Uses centralized config for all settings
- Integrates with manifest system for file tracking
- Uses progress tracker for real-time feedback
"""

import sys
from pathlib import Path
from typing import Optional, List

# Add parent to path
CODEGEN_DIR = Path(__file__).parent.parent.parent
sys.path.insert(0, str(CODEGEN_DIR))

from cli.core.logger import print_header, print_success, print_error, print_info, logger
from cli.core.config import (
    SVD_DIR,
    BOARD_MCUS,
    is_board_mcu,
    normalize_name
)
from cli.core.paths import get_mcu_output_dir, ensure_dir
from cli.parsers.generic_svd import parse_svd, SVDDevice


def generate_startup_cpp(device: SVDDevice, output_path: Path) -> bool:
    """
    Generate startup.cpp file with vector table and reset handler.

    Args:
        device: Parsed device information
        output_path: Where to write startup.cpp

    Returns:
        True if generation succeeded
    """
    try:
        # Generate handler list (deduplicated)
        handlers_set = set()
        handlers = []
        vector_table = []

        for irq in device.interrupts:
            handler_name = f"{irq.name}_Handler"
            if handler_name not in handlers_set:
                handlers.append(handler_name)
                handlers_set.add(handler_name)

            comment = f"// IRQ {irq.value}: {irq.name}"
            if irq.description:
                comment += f" - {irq.description}"
            vector_table.append(f"    {handler_name}, {comment}")

        # Generate file content
        content = f'''/// Auto-generated startup code for {device.name}
/// Generated by Alloy Code Generator from CMSIS-SVD
///
/// Device:  {device.name}
/// Vendor:  {device.vendor}
/// Family:  {device.family}
/// CPU:     {device.cpu_name or "Unknown"}
///
/// DO NOT EDIT - Regenerate from SVD if needed

#include <cstdint>
#include <cstring>

// ============================================================================
// LINKER SCRIPT SYMBOLS
// ============================================================================

extern uint32_t _sidata;  // Start of .data section in flash
extern uint32_t _sdata;   // Start of .data section in RAM
extern uint32_t _edata;   // End of .data section in RAM
extern uint32_t _sbss;    // Start of .bss section
extern uint32_t _ebss;    // End of .bss section
extern uint32_t _estack;  // Stack top (defined in linker script)

// ============================================================================
// USER APPLICATION
// ============================================================================

extern "C" int main();

// System initialization (weak, can be overridden by user)
extern "C" void SystemInit() __attribute__((weak));
extern "C" void SystemInit() {{}}

// ============================================================================
// INTERRUPT HANDLERS
// ============================================================================

// Default handler for unhandled interrupts
extern "C" [[noreturn]] void Default_Handler() {{
    // Trap - infinite loop if an unhandled interrupt occurs
    while (true) {{
        __asm__ volatile("nop");
    }}
}}

// All interrupt handlers (weak, can be overridden by user)
'''

        # Add weak handler implementations (not using alias, for macOS compatibility)
        for handler in handlers:
            content += f'''extern "C" __attribute__((weak)) void {handler}() {{
    Default_Handler();
}}
'''

        content += '''
// ============================================================================
// RESET HANDLER
// ============================================================================

extern "C" [[noreturn]] void Reset_Handler() {
    // 1. Copy initialized data from Flash to RAM (.data section)
    const uint32_t* src = &_sidata;
    uint32_t* dest = &_sdata;
    while (dest < &_edata) {
        *dest++ = *src++;
    }

    // 2. Zero-initialize uninitialized data (.bss section)
    dest = &_sbss;
    while (dest < &_ebss) {
        *dest++ = 0;
    }

    // 3. Call system initialization (clock setup, etc.)
    SystemInit();

    // 4. Call C++ static constructors
    extern void (*__init_array_start[])();
    extern void (*__init_array_end[])();
    for (auto* ctor = __init_array_start; ctor < __init_array_end; ++ctor) {
        (*ctor)();
    }

    // 5. Call main application
    main();

    // 6. If main returns, loop forever
    while (true) {
        __asm__ volatile("nop");
    }
}

// ============================================================================
// VECTOR TABLE
// ============================================================================

__attribute__((section(".isr_vector"), used))
void (* const vector_table[])() = {
    // Core system handlers
    reinterpret_cast<void (*)()>(&_estack), // Initial stack pointer
    Reset_Handler, // Reset handler
'''

        # Add all interrupt vectors
        content += '\n'.join(vector_table)
        content += '\n};\n'

        # Write file
        output_path.write_text(content)
        logger.debug(f"Generated startup.cpp with {len(handlers)} interrupt handlers")
        return True

    except Exception as e:
        logger.error(f"Failed to generate startup.cpp: {e}")
        return False


def generate_peripherals_hpp(device: SVDDevice, output_path: Path) -> bool:
    """
    Generate peripherals.hpp with peripheral base addresses.

    Args:
        device: Parsed device information
        output_path: Where to write peripherals.hpp

    Returns:
        True if generation succeeded
    """
    try:
        namespace = normalize_name(device.name)

        # Sort peripherals by base address
        peripherals_sorted = sorted(
            device.peripherals.values(),
            key=lambda p: p.base_address
        )

        # Generate peripheral definitions
        peripheral_defs = []
        peripheral_ids = []

        for periph in peripherals_sorted:
            comment = f"  // {periph.description}" if periph.description else ""
            peripheral_defs.append(
                f"constexpr uintptr_t {periph.name:20s} = 0x{periph.base_address:08X};{comment}"
            )

            # Generate peripheral IDs from interrupt numbers
            if hasattr(periph, 'interrupts') and periph.interrupts:
                # Use the first interrupt as the peripheral ID
                interrupt = periph.interrupts[0]
                peripheral_ids.append({
                    'name': periph.name,
                    'id': interrupt.value,
                    'description': periph.description or f"{periph.name}"
                })

        content = f'''/// Auto-generated peripheral definitions for {device.name}
/// Generated by Alloy Code Generator from CMSIS-SVD
///
/// Device:  {device.name}
/// Vendor:  {device.vendor}
/// Family:  {device.family}
///
/// DO NOT EDIT - Regenerate from SVD if needed

#ifndef ALLOY_GENERATED_{device.name.upper()}_PERIPHERALS_HPP
#define ALLOY_GENERATED_{device.name.upper()}_PERIPHERALS_HPP

#include <cstdint>

namespace alloy::generated::{namespace} {{

// ============================================================================
// PERIPHERAL BASE ADDRESSES
// ============================================================================

namespace peripherals {{
{chr(10).join(peripheral_defs)}
}} // namespace peripherals

// ============================================================================
// PERIPHERAL IDs (for Clock Enable/Disable)
// ============================================================================

namespace id {{
'''

        # Sort peripheral IDs by value and generate
        if peripheral_ids:
            peripheral_ids_sorted = sorted(peripheral_ids, key=lambda p: p['id'])
            for periph in peripheral_ids_sorted:
                content += f"constexpr uint8_t {periph['name']:20s} = {periph['id']:3d};  // {periph['description']}\n"
        else:
            content += "// No peripheral IDs found in SVD\n"

        content += f'''}} // namespace id

// ============================================================================
// MEMORY MAP
// ============================================================================

namespace memory {{
'''

        # Add memory regions if available
        if device.memory_regions:
            for region in device.memory_regions:
                content += f"    constexpr uintptr_t {region.name:20s} = 0x{region.start:08X};\n"
                if region.size > 0:
                    content += f"    constexpr size_t    {region.name}_SIZE = 0x{region.size:08X};\n"
        else:
            content += "    // Memory regions not defined in SVD\n"

        content += f'''}} // namespace memory

}} // namespace alloy::generated::{namespace}

#endif // ALLOY_GENERATED_{device.name.upper()}_PERIPHERALS_HPP
'''

        # Write file
        output_path.write_text(content)
        logger.debug(f"Generated peripherals.hpp with {len(peripherals_sorted)} peripherals")
        return True

    except Exception as e:
        logger.error(f"Failed to generate peripherals.hpp: {e}")
        return False


def generate_for_device(svd_path: Path, tracker=None) -> bool:
    """
    Generate startup and peripherals files for a single device.

    Args:
        svd_path: Path to SVD file
        tracker: Optional ProgressTracker instance

    Returns:
        True if generation succeeded
    """
    # Parse SVD
    device = parse_svd(svd_path, auto_classify=True)
    if not device:
        return False

    # Determine output directory
    output_dir = ensure_dir(
        get_mcu_output_dir(
            device.vendor_normalized,
            device.family,
            device.name.lower()
        )
    )

    logger.info(f"Generating for {device.name} -> {device.vendor_normalized}/{device.family}/{device.name.lower()}")

    # Track with progress tracker if available
    if tracker:
        tracker.add_mcu_task(
            device.vendor_normalized,
            device.family,
            device.name.lower(),
            ["startup.cpp", "peripherals.hpp"]
        )
        tracker.mark_mcu_generating(device.vendor_normalized, device.family, device.name.lower())

    # Generate startup.cpp
    success = True
    if tracker:
        tracker.mark_file_generating(device.vendor_normalized, device.family, device.name.lower(), "startup.cpp")

    startup_path = output_dir / "startup.cpp"
    if generate_startup_cpp(device, startup_path):
        if tracker:
            tracker.mark_file_success(device.vendor_normalized, device.family, device.name.lower(), "startup.cpp", startup_path)
    else:
        if tracker:
            tracker.mark_file_failed(device.vendor_normalized, device.family, device.name.lower(), "startup.cpp", "Generation failed")
        success = False

    # Generate peripherals.hpp
    if tracker:
        tracker.mark_file_generating(device.vendor_normalized, device.family, device.name.lower(), "peripherals.hpp")

    peripherals_path = output_dir / "peripherals.hpp"
    if generate_peripherals_hpp(device, peripherals_path):
        if tracker:
            tracker.mark_file_success(device.vendor_normalized, device.family, device.name.lower(), "peripherals.hpp", peripherals_path)
    else:
        if tracker:
            tracker.mark_file_failed(device.vendor_normalized, device.family, device.name.lower(), "peripherals.hpp", "Generation failed")
        success = False

    if tracker:
        tracker.complete_mcu_generation(device.vendor_normalized, device.family, device.name.lower(), success)

    return success


def discover_mcus_with_pins() -> List[str]:
    """
    Discover MCUs that have pin_functions.hpp generated.

    Returns:
        List of MCU names that have pin functions
    """
    from cli.core.config import HAL_VENDORS_DIR

    mcus_with_pins = []

    # Find all pin_functions.hpp files
    pin_files = HAL_VENDORS_DIR.rglob("**/pin_functions.hpp")

    for pin_file in pin_files:
        # Extract MCU name from path
        # Path structure: src/hal/vendors/{vendor}/{family}/{mcu}/pin_functions.hpp
        mcu_name = pin_file.parent.name
        if mcu_name not in mcus_with_pins:
            mcus_with_pins.append(mcu_name)

    return sorted(mcus_with_pins)


def generate_for_board_mcus(verbose: bool = False, tracker=None) -> int:
    """
    Generate startup and peripheral files for all MCUs with pin functions.

    This ensures startup.cpp and register_map.hpp are generated for every
    MCU that has pin_functions.hpp, not just board MCUs.

    Args:
        verbose: Enable verbose output
        tracker: Optional ProgressTracker instance

    Returns:
        Exit code (0 for success)
    """
    print_header("Generating Startup Code for MCUs with Pin Functions")

    # Set generator ID for manifest tracking
    if tracker:
        tracker.set_generator("startup")

    # Discover MCUs that have pin functions
    mcus_with_pins = discover_mcus_with_pins()

    if not mcus_with_pins:
        print_error("No MCUs with pin_functions.hpp found!")
        print_info("Run pin generation first: python3 codegen.py generate --pins")
        return 1

    print_info(f"Found {len(mcus_with_pins)} MCU(s) with pin functions:")
    if verbose:
        for mcu in mcus_with_pins:
            print_info(f"  • {mcu}")

    # Optimization: Instead of parsing ALL SVD files, use the discovery system
    # which caches SVD locations and names
    from cli.parsers.svd_discovery import discover_all_svds

    print_info(f"Discovering SVD files...")
    all_svds = discover_all_svds()

    # Find SVD files for MCUs with pins by matching names
    from cli.parsers.svd_discovery import find_svd_for_mcu

    matching_files = []
    for mcu_name in mcus_with_pins:
        # Use smart matching helper
        svd_file = find_svd_for_mcu(mcu_name, all_svds)

        if svd_file:
            matching_files.append(svd_file.file_path)
            if verbose:
                print_info(f"  ✓ {mcu_name} → {svd_file.file_path.name}")
        else:
            if verbose:
                print_info(f"  ✗ {mcu_name} (no SVD found)")
            logger.warning(f"No SVD found for MCU with pins: {mcu_name}")

    print_info(f"Found SVD files for {len(matching_files)}/{len(mcus_with_pins)} MCU(s)")

    if not matching_files:
        print_error("No board MCUs found!")
        return 1

    # Generate for each matching MCU
    # Note: We keep sequential processing because tracker is not thread-safe
    # For speedup, we already optimized the SVD discovery phase
    success_count = 0
    for svd_file in matching_files:
        if generate_for_device(svd_file, tracker):
            success_count += 1

    print_success(f"Generated startup code for {success_count}/{len(matching_files)} MCU(s)")
    return 0 if success_count == len(matching_files) else 1


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(description='Generate startup and peripheral files from SVD')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    parser.add_argument('--svd', help='Generate for specific SVD file')
    args = parser.parse_args()

    if args.svd:
        # Generate for specific SVD
        svd_path = Path(args.svd)
        if not svd_path.is_absolute():
            svd_path = SVD_DIR / svd_path

        if not svd_path.exists():
            print_error(f"SVD file not found: {svd_path}")
            return 1

        success = generate_for_device(svd_path)
        return 0 if success else 1
    else:
        # Generate for all board MCUs
        return generate_for_board_mcus(args.verbose)


if __name__ == '__main__':
    sys.exit(main())
