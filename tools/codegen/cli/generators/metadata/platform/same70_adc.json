{
  "family": "same70",
  "mcu": "atsame70q21b",
  "vendor": "atmel",
  "peripheral_name": "ADC",
  "register_include": "hal/vendors/atmel/same70/registers/afec0_registers.hpp",
  "bitfield_include": "hal/vendors/atmel/same70/bitfields/afec0_bitfields.hpp",
  "register_namespace": "atmel::same70::afec0",
  "namespace_alias": "afec",
  "register_type": "AFEC0_Registers",
  "platform_namespace": "alloy::hal::same70",
  "vendor_namespace": "alloy::hal::atmel::same70",
  "requires_clock": true,

  "template_params": [
    {
      "name": "BASE_ADDR",
      "type": "uint32_t",
      "description": "AFEC peripheral base address"
    },
    {
      "name": "PERIPH_CLOCK_HZ",
      "type": "uint32_t",
      "description": "Peripheral clock frequency for timing calculations"
    }
  ],

  "constants": [
    {
      "name": "ADC_TIMEOUT",
      "type": "uint32_t",
      "value": "100000",
      "description": "ADC timeout in loop iterations"
    },
    {
      "name": "MAX_CHANNELS",
      "type": "uint8_t",
      "value": "12",
      "description": "Maximum number of ADC channels"
    }
  ],

  "policy_methods": {
    "description": "Hardware Policy methods for SAME70 AFEC (ADC)",
    "peripheral_clock_hz": 150000000,
    "mock_hook_prefix": "ALLOY_ADC_MOCK_HW",

    "hw_accessor": {
      "description": "Get pointer to hardware registers",
      "return_type": "volatile RegisterType*",
      "code": "return reinterpret_cast<volatile RegisterType*>(BASE_ADDR);"
    },

    "reset": {
      "description": "Reset AFEC peripheral",
      "return_type": "void",
      "code": "hw()->CR = afec::cr::SWRST::mask;",
      "test_hook": "ALLOY_ADC_TEST_HOOK_RESET"
    },

    "enable": {
      "description": "Enable AFEC peripheral",
      "return_type": "void",
      "code": "hw()->CR = afec::cr::START::mask;",
      "test_hook": "ALLOY_ADC_TEST_HOOK_ENABLE"
    },

    "disable": {
      "description": "Disable AFEC peripheral",
      "return_type": "void",
      "code": "hw()->MR &= ~afec::mr::FREERUN::mask;",
      "test_hook": "ALLOY_ADC_TEST_HOOK_DISABLE"
    },

    "configure_resolution": {
      "description": "Configure ADC resolution (12-bit)",
      "return_type": "void",
      "code": "hw()->EMR = (hw()->EMR & ~afec::emr::RES::mask) | afec::emr::RES::write(0, 0);",
      "test_hook": "ALLOY_ADC_TEST_HOOK_RESOLUTION"
    },

    "set_prescaler": {
      "description": "Set ADC prescaler for sampling clock",
      "parameters": [
        {"name": "prescaler", "type": "uint8_t", "description": "Prescaler value (0-255)"}
      ],
      "return_type": "void",
      "code": "hw()->MR = (hw()->MR & ~afec::mr::PRESCAL::mask) | afec::mr::PRESCAL::write(0, prescaler);",
      "test_hook": "ALLOY_ADC_TEST_HOOK_PRESCALER"
    },

    "enable_channel": {
      "description": "Enable ADC channel",
      "parameters": [
        {"name": "channel", "type": "uint8_t", "description": "Channel number (0-11)"}
      ],
      "return_type": "void",
      "code": "hw()->CHER = (1u << channel);",
      "test_hook": "ALLOY_ADC_TEST_HOOK_ENABLE_CH"
    },

    "disable_channel": {
      "description": "Disable ADC channel",
      "parameters": [
        {"name": "channel", "type": "uint8_t", "description": "Channel number (0-11)"}
      ],
      "return_type": "void",
      "code": "hw()->CHDR = (1u << channel);",
      "test_hook": "ALLOY_ADC_TEST_HOOK_DISABLE_CH"
    },

    "select_channel": {
      "description": "Select ADC channel for conversion",
      "parameters": [
        {"name": "channel", "type": "uint8_t", "description": "Channel number (0-11)"}
      ],
      "return_type": "void",
      "code": "hw()->CSELR = afec::cselr::CSEL::write(0, channel);",
      "test_hook": "ALLOY_ADC_TEST_HOOK_SELECT_CH"
    },

    "start_conversion": {
      "description": "Start ADC conversion",
      "return_type": "void",
      "code": "hw()->CR = afec::cr::START::mask;",
      "test_hook": "ALLOY_ADC_TEST_HOOK_START"
    },

    "is_conversion_done": {
      "description": "Check if conversion is complete",
      "parameters": [
        {"name": "channel", "type": "uint8_t", "description": "Channel number (0-11)"}
      ],
      "return_type": "bool",
      "const": true,
      "code": "return (hw()->ISR & (1u << channel)) != 0;",
      "test_hook": "ALLOY_ADC_TEST_HOOK_IS_DONE"
    },

    "read_value": {
      "description": "Read ADC conversion result",
      "return_type": "uint16_t",
      "const": true,
      "code": "return static_cast<uint16_t>(hw()->CDR & 0xFFF);",
      "test_hook": "ALLOY_ADC_TEST_HOOK_READ"
    },

    "read_last_value": {
      "description": "Read last converted data register",
      "return_type": "uint16_t",
      "const": true,
      "code": "return static_cast<uint16_t>(hw()->LCDR & 0xFFF);",
      "test_hook": "ALLOY_ADC_TEST_HOOK_READ_LAST"
    },

    "enable_freerun_mode": {
      "description": "Enable free-running mode",
      "return_type": "void",
      "code": "hw()->MR |= afec::mr::FREERUN::mask;",
      "test_hook": "ALLOY_ADC_TEST_HOOK_FREERUN"
    },

    "set_trigger": {
      "description": "Set conversion trigger source",
      "parameters": [
        {"name": "trigger", "type": "uint8_t", "description": "Trigger source (0-6)"}
      ],
      "return_type": "void",
      "code": "hw()->MR = (hw()->MR & ~afec::mr::TRGSEL::mask) | afec::mr::TRGSEL::write(0, trigger);",
      "test_hook": "ALLOY_ADC_TEST_HOOK_TRIGGER"
    },

    "wait_conversion": {
      "description": "Wait for conversion to complete",
      "parameters": [
        {"name": "channel", "type": "uint8_t", "description": "Channel number"},
        {"name": "timeout_loops", "type": "uint32_t", "description": "Timeout in loop iterations"}
      ],
      "return_type": "bool",
      "code": "uint32_t timeout = timeout_loops; while (!is_conversion_done(channel) && --timeout); return timeout != 0;",
      "test_hook": "ALLOY_ADC_TEST_HOOK_WAIT"
    }
  },

  "instances": [
    {"name": "Adc0", "peripheral_name": "AFEC0", "base": "0x4003C000", "clock": "150000000", "description": "AFEC0 instance"},
    {"name": "Adc1", "peripheral_name": "AFEC1", "base": "0x40064000", "clock": "150000000", "description": "AFEC1 instance"}
  ],

  "examples": {
    "basic_usage": {
      "description": "Basic ADC usage example",
      "code": "using MyAdc = Adc<AFEC0_BASE, 150000000>;\nauto adc = MyAdc{};\nadc.open();\nadc.setPrescaler(9);\nadc.enableChannel(0);\nadc.startConversion();\nuint16_t value = adc.readValue();\nadc.close();"
    }
  }
}
