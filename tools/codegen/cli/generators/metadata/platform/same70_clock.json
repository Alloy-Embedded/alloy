{
  "family": "same70",
  "vendor": "atmel",
  "device": "atsame70q21b",
  "peripheral_name": "Clock",
  "register_include": "hal/vendors/atmel/same70/registers/pmc_registers.hpp",
  "bitfield_include": "hal/vendors/atmel/same70/bitfields/pmc_bitfields.hpp",
  "peripherals_include": "hal/vendors/atmel/same70/atsame70q21b/peripherals.hpp",
  "peripherals_namespace": "alloy::generated::atsame70q21b::peripherals",
  "register_namespace": "alloy::hal::atmel::same70::pmc",
  "register_type": "PMC_Registers",
  "platform_namespace": "alloy::hal::same70",
  "vendor_namespace": "alloy::hal::atmel::same70",
  "namespace_alias": "pmc",
  "is_singleton": true,
  "requires_clock": false,

  "description": "Clock and Power Management Controller (PMC) for SAME70",
  "architecture_notes": [
    "Main Crystal Oscillator: 3-20 MHz (typically 12 MHz)",
    "Internal RC: 4/8/12 MHz",
    "PLLA: Up to 300 MHz PLL",
    "Master Clock (MCK): Up to 150 MHz",
    "Peripheral clocks: Individual enable/disable",
    "Programmable clocks: 8 configurable outputs",
    "",
    "Typical Clock Tree:",
    "Crystal (12 MHz) -> PLLA (300 MHz) -> MCK Divider (/2) -> MCK (150 MHz)"
  ],

  "additional_enums": [
    {
      "name": "MainClockSource",
      "type": "uint8_t",
      "description": "Main Clock Source",
      "enum_values": [
        {"name": "InternalRC_4MHz", "value": 0, "description": "Fast RC 4 MHz"},
        {"name": "InternalRC_8MHz", "value": 1, "description": "Fast RC 8 MHz"},
        {"name": "InternalRC_12MHz", "value": 2, "description": "Fast RC 12 MHz"},
        {"name": "ExternalCrystal", "value": 3, "description": "External crystal/oscillator"}
      ]
    },
    {
      "name": "MasterClockPrescaler",
      "type": "uint8_t",
      "description": "Master Clock Prescaler",
      "enum_values": [
        {"name": "DIV_1", "value": 0, "description": "No division"},
        {"name": "DIV_2", "value": 1, "description": "Divide by 2"},
        {"name": "DIV_3", "value": 2, "description": "Divide by 3"},
        {"name": "DIV_4", "value": 3, "description": "Divide by 4"}
      ]
    },
    {
      "name": "MasterClockSource",
      "type": "uint8_t",
      "description": "Master Clock Source",
      "enum_values": [
        {"name": "SlowClock", "value": 0, "description": "32 kHz slow clock"},
        {"name": "MainClock", "value": 1, "description": "Main clock (crystal or RC)"},
        {"name": "PLLAClock", "value": 2, "description": "PLLA output"},
        {"name": "UPLLClock", "value": 3, "description": "UPLL output (480 MHz for USB)"}
      ]
    }
  ],

  "additional_structs": [
    {
      "name": "PllaConfig",
      "description": "PLLA Multiplier\\n\\nPLLA_FREQ = (MAIN_CLK * (MUL + 1)) / DIV\\nFor 12 MHz crystal -> 300 MHz PLLA: MUL=24, DIV=1\\nResult: (12 * 25) / 1 = 300 MHz",
      "fields": [
        {"name": "multiplier", "type": "uint16_t", "default": "24", "description": "PLLA multiplier (0-62), actual = multiplier+1"},
        {"name": "divider", "type": "uint8_t", "default": "1", "description": "PLLA divider (1-255)"}
      ]
    }
  ],

  "config_struct": {
    "name": "ClockConfig",
    "description": "Complete Clock Configuration",
    "fields": [
      {"name": "main_source", "type": "MainClockSource", "default": "MainClockSource::ExternalCrystal", "description": "Main clock source"},
      {"name": "crystal_freq_hz", "type": "uint32_t", "default": "12000000", "description": "External crystal frequency"},
      {"name": "plla", "type": "PllaConfig", "default": "{24, 1}", "description": "PLLA config (12MHz * 25 / 1 = 300MHz)"},
      {"name": "mck_source", "type": "MasterClockSource", "default": "MasterClockSource::PLLAClock", "description": "Master clock source"},
      {"name": "mck_prescaler", "type": "MasterClockPrescaler", "default": "MasterClockPrescaler::DIV_2", "description": "300/2 = 150MHz"}
    ]
  },

  "constants": [
    {"name": "PMC_BASE", "type": "uintptr_t", "value": "alloy::generated::atsame70q21b::peripherals::PMC", "constexpr": true, "description": "PMC base address (using generated peripheral addresses)"},
    {"name": "SLOW_CLOCK_FREQ", "type": "uint32_t", "value": "32768", "constexpr": true, "description": "32.768 kHz"}
  ],

  "operations": {
    "initialize": {
      "description": "Initialize system clocks\\n\\nConfigures main oscillator, PLLA, and master clock.\\nThis should be called early in system initialization.",
      "parameters": [
        {"name": "config", "type": "const ClockConfig&", "description": "Clock configuration"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "static": true,
      "implementation": "custom",
      "steps": []
    },

    "enablePeripheralClock": {
      "description": "Enable peripheral clock",
      "parameters": [
        {"name": "peripheral_id", "type": "uint8_t", "description": "Peripheral ID (0-63)"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "static": true,
      "steps": [
        {
          "check_state": "if (!s_initialized)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "check_param": "if (peripheral_id >= 64)",
          "return_error": "ErrorCode::InvalidParameter"
        },
        {
          "custom_code": "auto* pmc = get_pmc();\n        if (peripheral_id < 32) {\n            pmc->PCER0 = (1u << peripheral_id);\n        } else {\n            pmc->PCER1 = (1u << (peripheral_id - 32));\n        }"
        }
      ],
      "always_succeeds": true
    },

    "disablePeripheralClock": {
      "description": "Disable peripheral clock",
      "parameters": [
        {"name": "peripheral_id", "type": "uint8_t", "description": "Peripheral ID (0-63)"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "static": true,
      "steps": [
        {
          "check_state": "if (!s_initialized)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "check_param": "if (peripheral_id >= 64)",
          "return_error": "ErrorCode::InvalidParameter"
        },
        {
          "custom_code": "auto* pmc = get_pmc();\n        if (peripheral_id < 32) {\n            pmc->PCDR0 = (1u << peripheral_id);\n        } else {\n            pmc->PCDR1 = (1u << (peripheral_id - 32));\n        }"
        }
      ],
      "always_succeeds": true
    },

    "getMasterClockFrequency": {
      "description": "Get master clock (MCK) frequency in Hz",
      "parameters": [],
      "return_type": "uint32_t",
      "const": false,
      "static": true,
      "implementation": "custom",
      "steps": []
    },

    "isInitialized": {
      "description": "Check if clocks are initialized",
      "parameters": [],
      "return_type": "bool",
      "const": false,
      "static": true,
      "returns": "s_initialized",
      "returns_type": "bool",
      "steps": []
    },

    "getConfig": {
      "description": "Get current clock configuration",
      "parameters": [],
      "return_type": "const ClockConfig&",
      "const": false,
      "static": true,
      "returns": "s_config",
      "returns_type": "const ClockConfig&",
      "steps": []
    }
  },

  "additional_methods": [
    {
      "name": "get_pmc",
      "visibility": "private",
      "static": true,
      "inline": true,
      "volatile": true,
      "return_type": "alloy::hal::atmel::same70::pmc::PMC_Registers*",
      "parameters": [],
      "body": "#ifdef ALLOY_CLOCK_MOCK_HW\n        return ALLOY_CLOCK_MOCK_HW();\n#else\n        return reinterpret_cast<volatile alloy::hal::atmel::same70::pmc::PMC_Registers*>(PMC_BASE);\n#endif"
    }
  ],

  "state_variables": [
    {"name": "s_initialized", "type": "bool", "initial_value": "false", "inline": true, "static": true, "description": "Tracks if clocks are initialized"},
    {"name": "s_config", "type": "ClockConfig", "initial_value": "{}", "inline": true, "static": true, "description": "Current clock configuration"}
  ],

  "predefined_configs": [
    {
      "name": "CLOCK_CONFIG_150MHZ",
      "description": "Default configuration: 12 MHz Crystal -> 300 MHz PLLA -> 150 MHz MCK",
      "constexpr": true,
      "fields": {
        "main_source": "MainClockSource::ExternalCrystal",
        "crystal_freq_hz": "12000000",
        "plla": "{24, 1}",
        "mck_source": "MasterClockSource::PLLAClock",
        "mck_prescaler": "MasterClockPrescaler::DIV_2"
      }
    },
    {
      "name": "CLOCK_CONFIG_120MHZ",
      "description": "Conservative configuration: 12 MHz Crystal -> 240 MHz PLLA -> 120 MHz MCK",
      "constexpr": true,
      "fields": {
        "main_source": "MainClockSource::ExternalCrystal",
        "crystal_freq_hz": "12000000",
        "plla": "{19, 1}",
        "mck_source": "MasterClockSource::PLLAClock",
        "mck_prescaler": "MasterClockPrescaler::DIV_2"
      }
    },
    {
      "name": "CLOCK_CONFIG_12MHZ_CRYSTAL",
      "description": "Low power configuration: 12 MHz Crystal direct (no PLL)",
      "constexpr": true,
      "fields": {
        "main_source": "MainClockSource::ExternalCrystal",
        "crystal_freq_hz": "12000000",
        "plla": "{24, 1}",
        "mck_source": "MasterClockSource::MainClock",
        "mck_prescaler": "MasterClockPrescaler::DIV_1"
      }
    }
  ],

  "custom_implementations": {
    "initialize": "auto* pmc = get_pmc();\n        s_config = config;\n\n        // Step 1: Configure main oscillator (Crystal or RC)\n        if (config.main_source == MainClockSource::ExternalCrystal) {\n            // Enable both RC (for safety) and Crystal\n            uint32_t mor = 0;\n            mor = pmc::ckgr_mor::KEY::write(mor, pmc::ckgr_mor::key::PASSWD);\n            mor = pmc::ckgr_mor::MOSCXTST::write(mor, 0xFF);\n            mor = pmc::ckgr_mor::MOSCRCEN::set(mor);\n            mor = pmc::ckgr_mor::MOSCXTEN::set(mor);\n            pmc->CKGR_MOR = mor;\n\n            // Wait for crystal stabilization\n            volatile uint32_t timeout = 0;\n            while (!(pmc->SR & pmc::sr::MOSCXTS::mask)) {\n                if (++timeout > 1000000) return Err(ErrorCode::HardwareError);\n            }\n\n            // Switch to crystal - set MOSCSEL\n            mor = 0;\n            mor = pmc::ckgr_mor::KEY::write(mor, pmc::ckgr_mor::key::PASSWD);\n            mor = pmc::ckgr_mor::MOSCXTST::write(mor, 0xFF);\n            mor = pmc::ckgr_mor::MOSCSEL::set(mor);\n            mor = pmc::ckgr_mor::MOSCRCEN::set(mor);\n            mor = pmc::ckgr_mor::MOSCXTEN::set(mor);\n            pmc->CKGR_MOR = mor;\n\n            // Wait for oscillator selection\n            timeout = 0;\n            while (!(pmc->SR & pmc::sr::MOSCSELS::mask)) {\n                if (++timeout > 100000) return Err(ErrorCode::HardwareError);\n            }\n        } else {\n            // Use RC oscillator\n            uint32_t rc_freq = (config.main_source == MainClockSource::InternalRC_4MHz) ? pmc::ckgr_mor::moscrcf::_4_MHz :\n                               (config.main_source == MainClockSource::InternalRC_8MHz) ? pmc::ckgr_mor::moscrcf::_8_MHz :\n                                                                                           pmc::ckgr_mor::moscrcf::_12_MHz;\n\n            uint32_t mor = 0;\n            mor = pmc::ckgr_mor::KEY::write(mor, pmc::ckgr_mor::key::PASSWD);\n            mor = pmc::ckgr_mor::MOSCXTST::write(mor, 0xFF);\n            mor = pmc::ckgr_mor::MOSCRCF::write(mor, rc_freq);\n            mor = pmc::ckgr_mor::MOSCRCEN::set(mor);\n            // MOSCSEL=0 (use RC) - default value, no need to clear\n            pmc->CKGR_MOR = mor;\n\n            for (volatile int i = 0; i < 100; i++);  // Small delay\n        }\n\n        // If using MainClock only (no PLL), we're done\n        if (config.mck_source == MasterClockSource::MainClock &&\n            config.mck_prescaler == MasterClockPrescaler::DIV_1) {\n            s_initialized = true;\n            return Ok();\n        }\n\n        // Step 2: Configure PLLA if needed\n        if (config.mck_source == MasterClockSource::PLLAClock) {\n            uint32_t pllar = 0;\n            pllar = pmc::ckgr_pllar::MULA::write(pllar, config.plla.multiplier);\n            pllar = pmc::ckgr_pllar::DIVA::write(pllar, config.plla.divider);\n            pllar = pmc::ckgr_pllar::PLLACOUNT::write(pllar, 0x3F);\n            pllar = pmc::ckgr_pllar::ONE::set(pllar);\n            pmc->CKGR_PLLAR = pllar;\n\n            // Wait for PLLA lock\n            volatile uint32_t timeout = 0;\n            while (!(pmc->SR & pmc::sr::LOCKA::mask)) {\n                if (++timeout > 1000000) return Err(ErrorCode::HardwareError);\n            }\n        }\n\n        // Step 3: Configure MCK - CRITICAL SEQUENCE per datasheet\n        // Must follow exact order: CSS -> wait -> PRES -> wait -> CSS -> wait\n\n        // 3.1: Switch to MAIN_CLK first (safe intermediate state)\n        uint32_t mckr = pmc->MCKR;\n        mckr = pmc::mckr::CSS::write(mckr, pmc::mckr::css::MAIN_CLK);\n        pmc->MCKR = mckr;\n\n        volatile uint32_t timeout = 0;\n        while (!(pmc->SR & pmc::sr::MCKRDY::mask)) {\n            if (++timeout > 100000) return Err(ErrorCode::HardwareError);\n        }\n\n        // 3.2: Set prescaler\n        uint32_t pres_value = (config.mck_prescaler == MasterClockPrescaler::DIV_1) ? pmc::mckr::pres::CLK_1 :\n                              (config.mck_prescaler == MasterClockPrescaler::DIV_2) ? pmc::mckr::pres::CLK_2 :\n                              (config.mck_prescaler == MasterClockPrescaler::DIV_3) ? pmc::mckr::pres::CLK_3 :\n                                                                                       pmc::mckr::pres::CLK_4;\n\n        mckr = pmc->MCKR;\n        mckr = pmc::mckr::PRES::write(mckr, pres_value);\n        pmc->MCKR = mckr;\n\n        timeout = 0;\n        while (!(pmc->SR & pmc::sr::MCKRDY::mask)) {\n            if (++timeout > 100000) return Err(ErrorCode::HardwareError);\n        }\n\n        // 3.3: Switch to final clock source (PLLA or MAIN)\n        uint32_t css_value = (config.mck_source == MasterClockSource::PLLAClock) ? pmc::mckr::css::PLLA_CLK :\n                             pmc::mckr::css::MAIN_CLK;\n\n        mckr = pmc->MCKR;\n        mckr = pmc::mckr::CSS::write(mckr, css_value);\n        pmc->MCKR = mckr;\n\n        timeout = 0;\n        while (!(pmc->SR & pmc::sr::MCKRDY::mask)) {\n            if (++timeout > 100000) return Err(ErrorCode::HardwareError);\n        }\n\n        s_initialized = true;\n        return Ok();",

    "getMasterClockFrequency": "if (!s_initialized) {\n            return 0;\n        }\n\n        uint32_t main_freq = 0;\n\n        // Get main clock frequency\n        switch (s_config.main_source) {\n            case MainClockSource::InternalRC_4MHz:\n                main_freq = 4000000;\n                break;\n            case MainClockSource::InternalRC_8MHz:\n                main_freq = 8000000;\n                break;\n            case MainClockSource::InternalRC_12MHz:\n                main_freq = 12000000;\n                break;\n            case MainClockSource::ExternalCrystal:\n                main_freq = s_config.crystal_freq_hz;\n                break;\n        }\n\n        uint32_t mck_freq = 0;\n\n        // Calculate MCK based on source\n        switch (s_config.mck_source) {\n            case MasterClockSource::SlowClock:\n                mck_freq = SLOW_CLOCK_FREQ;\n                break;\n\n            case MasterClockSource::MainClock:\n                mck_freq = main_freq;\n                break;\n\n            case MasterClockSource::PLLAClock: {\n                // PLLA = (MAIN_CLK * (MUL+1)) / DIV\n                uint32_t plla_freq = (main_freq * (s_config.plla.multiplier + 1)) / s_config.plla.divider;\n                mck_freq = plla_freq;\n                break;\n            }\n\n            case MasterClockSource::UPLLClock:\n                mck_freq = 480000000;  // UPLL is fixed at 480 MHz\n                break;\n        }\n\n        // Apply prescaler\n        uint32_t prescaler = 1;\n        switch (s_config.mck_prescaler) {\n            case MasterClockPrescaler::DIV_1: prescaler = 1; break;\n            case MasterClockPrescaler::DIV_2: prescaler = 2; break;\n            case MasterClockPrescaler::DIV_3: prescaler = 3; break;\n            case MasterClockPrescaler::DIV_4: prescaler = 4; break;\n        }\n\n        return mck_freq / prescaler;"
  }
}
