{
  "family": "same70",
  "mcu": "atsame70q21b",
  "vendor": "atmel",
  "peripheral_name": "SPI",
  "register_include": "hal/vendors/atmel/same70/registers/spi0_registers.hpp",
  "bitfield_include": "hal/vendors/atmel/same70/bitfields/spi0_bitfields.hpp",
  "register_namespace": "atmel::same70::spi0",
  "namespace_alias": "spi",
  "register_type": "SPI0_Registers",
  "platform_namespace": "alloy::hal::same70",
  "vendor_namespace": "alloy::hal::atmel::same70",
  "requires_clock": false,

  "template_params": [
    {
      "name": "BASE_ADDR",
      "type": "uint32_t",
      "description": "SPI peripheral base address"
    },
    {
      "name": "IRQ_ID",
      "type": "uint32_t",
      "description": "SPI interrupt ID for clock enable"
    }
  ],

  "additional_enums": [
    {
      "name": "SpiChipSelect",
      "type": "uint8_t",
      "description": "SPI Chip Select (SAME70-specific)",
      "values": [
        {"name": "CS0", "value": 0, "description": "Chip select 0"},
        {"name": "CS1", "value": 1, "description": "Chip select 1"},
        {"name": "CS2", "value": 2, "description": "Chip select 2"},
        {"name": "CS3", "value": 3, "description": "Chip select 3"}
      ]
    }
  ],

  "constants": [
    {
      "name": "SPI_TIMEOUT",
      "type": "uint32_t",
      "value": "100000",
      "description": "SPI timeout in loop iterations (~10ms at 150MHz)"
    },
    {
      "name": "STACK_BUFFER_SIZE",
      "type": "size_t",
      "value": "256",
      "description": "Stack buffer size for dummy data in write/read operations"
    }
  ],

  "registers": {
    "control": {"name": "CR", "description": "Control Register"},
    "mode": {"name": "MR", "description": "Mode Register"},
    "status": {"name": "SR", "description": "Status Register"},
    "transmit": {"name": "TDR", "description": "Transmit Data Register"},
    "receive": {"name": "RDR", "description": "Receive Data Register"},
    "chip_select": {"name": "CSR", "description": "Chip Select Register", "array": true, "array_size": 4}
  },

  "operations": {
    "open": {
      "description": "Initialize SPI peripheral",
      "parameters": [],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (m_opened)",
          "return_error": "ErrorCode::AlreadyInitialized"
        },
        {
          "comment": "Enable peripheral clock (PMC)",
          "custom_code": "// TODO: Enable peripheral clock via PMC"
        },
        {
          "comment": "Reset SPI",
          "register": "control",
          "operation": "write_bitfield",
          "bitfield": "SWRST",
          "value": "mask"
        },
        {
          "comment": "Configure Mode Register for master mode",
          "custom_code": "uint32_t mr = 0;\n        mr = spi::mr::MSTR::write(mr, spi::mr::mstr::MASTER);\n        mr = spi::mr::MODFDIS::set(mr);\n        hw->MR = mr;"
        },
        {
          "comment": "Enable SPI",
          "register": "control",
          "operation": "write_bitfield",
          "bitfield": "SPIEN",
          "value": "mask"
        },
        {
          "set_state": "m_opened = true"
        }
      ],
      "always_succeeds": true
    },

    "close": {
      "description": "Close SPI peripheral",
      "parameters": [],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "comment": "Disable SPI",
          "register": "control",
          "operation": "write_bitfield",
          "bitfield": "SPIDIS",
          "value": "mask"
        },
        {
          "set_state": "m_opened = false"
        }
      ],
      "always_succeeds": true
    },

    "configureChipSelect": {
      "description": "Configure chip select timing and mode",
      "parameters": [
        {"name": "cs", "type": "SpiChipSelect", "description": "Chip select to configure"},
        {"name": "clock_divider", "type": "uint8_t", "description": "SPI clock divider (1-255)"},
        {"name": "mode", "type": "SpiMode", "description": "SPI mode (polarity and phase)", "default": "SpiMode::Mode0"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "check_param": "if (clock_divider == 0)",
          "return_error": "ErrorCode::InvalidParameter"
        },
        {
          "comment": "Configure chip select register with mode and clock divider",
          "custom_code": "uint8_t cs_num = static_cast<uint8_t>(cs);\n        uint32_t csr_value = 0;\n        \n        // Configure SPI mode (CPOL and NCPHA)\n        uint8_t mode_val = static_cast<uint8_t>(mode);\n        if (mode_val & 0x02) {\n            csr_value = spi::csr::CPOL::set(csr_value);\n        }\n        if (!(mode_val & 0x01)) {\n            csr_value = spi::csr::NCPHA::set(csr_value);\n        }\n        \n        // Chip select active after transfer\n        csr_value = spi::csr::CSAAT::set(csr_value);\n        \n        // 8-bit transfers\n        csr_value = spi::csr::BITS::write(csr_value, spi::csr::bits::_8_BIT);\n        \n        // Serial clock baud rate\n        csr_value = spi::csr::SCBR::write(csr_value, clock_divider);\n        \n        hw->CSR[cs_num][0] = csr_value;"
        }
      ],
      "always_succeeds": true
    },

    "transfer": {
      "description": "Full-duplex SPI transfer (send and receive simultaneously)",
      "parameters": [
        {"name": "tx_data", "type": "const uint8_t*", "description": "Transmit data buffer"},
        {"name": "rx_data", "type": "uint8_t*", "description": "Receive data buffer"},
        {"name": "size", "type": "size_t", "description": "Number of bytes to transfer"},
        {"name": "cs", "type": "SpiChipSelect", "description": "Chip select to use"}
      ],
      "return_type": "Result<size_t, ErrorCode>",
      "returns": "size",
      "returns_type": "size_t",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "check_param": "if (tx_data == nullptr || rx_data == nullptr)",
          "return_error": "ErrorCode::InvalidParameter"
        },
        {
          "comment": "Transfer data byte by byte with timeout",
          "custom_code": "uint8_t cs_num = static_cast<uint8_t>(cs);\n        \n        for (size_t i = 0; i < size; ++i) {\n            // Wait for transmit data register empty\n            uint32_t timeout = 0;\n            while (!(hw->SR & spi::sr::TDRE::mask)) {\n                if (++timeout > SPI_TIMEOUT) {\n                    return Err(ErrorCode::Timeout);\n                }\n            }\n            \n            // Build TDR value with data and chip select\n            uint32_t tdr_value = 0;\n            tdr_value = spi::tdr::TD::write(tdr_value, tx_data[i]);\n            tdr_value = spi::tdr::PCS::write(tdr_value, cs_num);\n            hw->TDR = tdr_value;\n            \n            // Wait for receive data register full\n            timeout = 0;\n            while (!(hw->SR & spi::sr::RDRF::mask)) {\n                if (++timeout > SPI_TIMEOUT) {\n                    return Err(ErrorCode::Timeout);\n                }\n            }\n            \n            // Read received data\n            rx_data[i] = static_cast<uint8_t>(spi::rdr::RD::read(hw->RDR));\n        }"
        }
      ]
    },

    "write": {
      "description": "Write data to SPI (discard received data)",
      "parameters": [
        {"name": "data", "type": "const uint8_t*", "description": "Data to write"},
        {"name": "size", "type": "size_t", "description": "Number of bytes to write"},
        {"name": "cs", "type": "SpiChipSelect", "description": "Chip select to use"}
      ],
      "return_type": "Result<size_t, ErrorCode>",
      "returns": "size",
      "returns_type": "size_t",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "check_param": "if (data == nullptr)",
          "return_error": "ErrorCode::InvalidParameter"
        },
        {
          "comment": "Use stack buffer for dummy RX data, or transfer byte-by-byte for large transfers",
          "custom_code": "uint8_t stack_buffer[STACK_BUFFER_SIZE];\n        uint8_t* dummy = stack_buffer;\n        \n        if (size > STACK_BUFFER_SIZE) {\n            // For large transfers, transfer byte-by-byte to avoid allocation\n            for (size_t i = 0; i < size; ++i) {\n                uint8_t rx_dummy;\n                auto result = transfer(&data[i], &rx_dummy, 1, cs);\n                if (!result.is_ok()) {\n                    return Err(result.err());\n                }\n            }\n            return Ok(size_t(size));\n        }\n        \n        auto result = transfer(data, dummy, size, cs);\n        if (!result.is_ok()) {\n            return Err(result.err());\n        }"
        }
      ]
    },

    "read": {
      "description": "Read data from SPI (send 0xFF dummy bytes)",
      "parameters": [
        {"name": "data", "type": "uint8_t*", "description": "Buffer for received data"},
        {"name": "size", "type": "size_t", "description": "Number of bytes to read"},
        {"name": "cs", "type": "SpiChipSelect", "description": "Chip select to use"}
      ],
      "return_type": "Result<size_t, ErrorCode>",
      "returns": "size",
      "returns_type": "size_t",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "check_param": "if (data == nullptr)",
          "return_error": "ErrorCode::InvalidParameter"
        },
        {
          "comment": "Use stack buffer for dummy TX data (0xFF), or transfer byte-by-byte for large transfers",
          "custom_code": "uint8_t stack_buffer[STACK_BUFFER_SIZE];\n        uint8_t* dummy = stack_buffer;\n        \n        if (size > STACK_BUFFER_SIZE) {\n            // For large transfers, transfer byte-by-byte\n            for (size_t i = 0; i < size; ++i) {\n                uint8_t tx_dummy = 0xFF;\n                auto result = transfer(&tx_dummy, &data[i], 1, cs);\n                if (!result.is_ok()) {\n                    return Err(result.err());\n                }\n            }\n            return Ok(size_t(size));\n        }\n        \n        // Initialize dummy buffer with 0xFF for read\n        for (size_t i = 0; i < size; ++i) {\n            dummy[i] = 0xFF;\n        }\n        \n        auto result = transfer(dummy, data, size, cs);\n        if (!result.is_ok()) {\n            return Err(result.err());\n        }"
        }
      ]
    },

    "isOpen": {
      "description": "Check if SPI peripheral is open",
      "parameters": [],
      "return_type": "bool",
      "const": true,
      "returns": "m_opened",
      "returns_type": "bool",
      "steps": []
    }
  },

  "state_variables": [
    {"name": "m_opened", "type": "bool", "initial_value": "false", "description": "Tracks if peripheral is initialized"}
  ],

  "instances": [
    {"name": "Spi0", "base": "0x40008000", "irq": "21", "description": "SPI0 instance"},
    {"name": "Spi1", "base": "0x40058000", "irq": "42", "description": "SPI1 instance"}
  ],

  "examples": {
    "basic_usage": {
      "description": "Basic SPI usage example",
      "code": "using MySpi = Spi<SPI0_BASE, SPI0_IRQ>;\nauto spi = MySpi{};\nspi.open();\nspi.configureChipSelect(SpiChipSelect::CS0, 10, SpiMode::Mode0);\nuint8_t tx[] = {0x01, 0x02, 0x03};\nuint8_t rx[3];\nspi.transfer(tx, rx, 3, SpiChipSelect::CS0);\nspi.close();"
    }
  },

  "policy_methods": {
    "description": "Hardware Policy methods for Policy-Based Design pattern",
    "peripheral_clock_hz": 150000000,
    "mock_hook_prefix": "ALLOY_SPI_MOCK_HW",

    "hw_accessor": {
      "description": "Get pointer to hardware registers",
      "return_type": "volatile RegisterType*",
      "code": "return reinterpret_cast<volatile RegisterType*>(BASE_ADDR);"
    },

    "reset": {
      "description": "Reset SPI peripheral",
      "return_type": "void",
      "code": "hw()->CR = spi::cr::SWRST::mask;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_RESET"
    },

    "enable": {
      "description": "Enable SPI peripheral",
      "return_type": "void",
      "code": "hw()->CR = spi::cr::SPIEN::mask;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_ENABLE"
    },

    "disable": {
      "description": "Disable SPI peripheral",
      "return_type": "void",
      "code": "hw()->CR = spi::cr::SPIDIS::mask;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_DISABLE"
    },

    "configure_master": {
      "description": "Configure SPI in master mode",
      "return_type": "void",
      "code": "hw()->MR = spi::mr::MSTR::mask | spi::mr::MODFDIS::mask;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_MASTER"
    },

    "configure_chip_select": {
      "description": "Configure chip select parameters",
      "parameters": [
        {"name": "cs", "type": "uint8_t", "description": "Chip select number (0-3)"},
        {"name": "scbr", "type": "uint32_t", "description": "Serial Clock Baud Rate divider"},
        {"name": "mode", "type": "uint8_t", "description": "SPI mode (0-3)"}
      ],
      "return_type": "void",
      "code": "uint32_t csr_value = spi::csr::SCBR::write(0, scbr);\nif (mode & 0x01) csr_value |= spi::csr::NCPHA::mask;\nif (mode & 0x02) csr_value |= spi::csr::CPOL::mask;\nhw()->CSR[cs] = csr_value;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_CS_CONFIG"
    },

    "select_chip": {
      "description": "Select chip (assert CS)",
      "parameters": [
        {"name": "cs", "type": "uint8_t", "description": "Chip select number (0-3)"}
      ],
      "return_type": "void",
      "code": "hw()->MR = (hw()->MR & ~spi::mr::PCS::mask) | spi::mr::PCS::write(0, ~(1u << cs));",
      "test_hook": "ALLOY_SPI_TEST_HOOK_SELECT"
    },

    "is_tx_ready": {
      "description": "Check if transmit buffer is ready",
      "return_type": "bool",
      "const": true,
      "code": "return (hw()->SR & spi::sr::TDRE::mask) != 0;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_TX_READY"
    },

    "is_rx_ready": {
      "description": "Check if receive data is ready",
      "return_type": "bool",
      "const": true,
      "code": "return (hw()->SR & spi::sr::RDRF::mask) != 0;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_RX_READY"
    },

    "write_byte": {
      "description": "Write byte to transmit register",
      "parameters": [
        {"name": "byte", "type": "uint8_t", "description": "Byte to transmit"}
      ],
      "return_type": "void",
      "code": "hw()->TDR = byte;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_WRITE"
    },

    "read_byte": {
      "description": "Read byte from receive register",
      "return_type": "uint8_t",
      "const": true,
      "code": "return static_cast<uint8_t>(hw()->RDR & 0xFF);",
      "test_hook": "ALLOY_SPI_TEST_HOOK_READ"
    },

    "wait_tx_ready": {
      "description": "Wait for TX ready with timeout",
      "parameters": [
        {"name": "timeout_loops", "type": "uint32_t", "description": "Timeout in loop iterations"}
      ],
      "return_type": "bool",
      "code": "uint32_t timeout = timeout_loops;\nwhile (!is_tx_ready() && --timeout);\nreturn timeout != 0;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_WAIT_TX"
    },

    "wait_rx_ready": {
      "description": "Wait for RX ready with timeout",
      "parameters": [
        {"name": "timeout_loops", "type": "uint32_t", "description": "Timeout in loop iterations"}
      ],
      "return_type": "bool",
      "code": "uint32_t timeout = timeout_loops;\nwhile (!is_rx_ready() && --timeout);\nreturn timeout != 0;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_WAIT_RX"
    }
  }
}
