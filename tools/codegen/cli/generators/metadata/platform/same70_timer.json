{
  "family": "same70",
  "vendor": "atmel",
  "peripheral_name": "Timer",
  "register_include": "hal/vendors/atmel/same70/registers/tc0_registers.hpp",
  "bitfield_include": "hal/vendors/atmel/same70/bitfields/tc0_bitfields.hpp",
  "register_namespace": "alloy::hal::atmel::same70::tc0",
  "namespace_alias": "tc",
  "register_type": "tc0::TC0_Registers",
  "platform_namespace": "alloy::hal::same70",
  "vendor_namespace": "alloy::hal::atmel::same70",
  "requires_clock": false,

  "template_params": [
    {
      "name": "BASE_ADDR",
      "type": "uint32_t",
      "description": "TC peripheral base address"
    },
    {
      "name": "PERIPH_CLOCK_HZ",
      "type": "uint32_t",
      "description": "Peripheral clock frequency"
    }
  ],

  "constants": [],

  "policy_methods": {
    "description": "Hardware Policy methods for SAME70 Timer/Counter",
    "peripheral_clock_hz": 150000000,
    "mock_hook_prefix": "ALLOY_TIMER_MOCK_HW",

    "hw_accessor": {
      "description": "Get pointer to hardware registers",
      "return_type": "volatile RegisterType*",
      "code": "return reinterpret_cast<volatile RegisterType*>(BASE_ADDR);"
    },

    "enable_clock": {
      "description": "Enable timer clock",
      "return_type": "void",
      "code": "hw()->CCR = tc::ccr::CLKEN::mask;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_ENABLE_CLOCK"
    },

    "disable_clock": {
      "description": "Disable timer clock",
      "return_type": "void",
      "code": "hw()->CCR = tc::ccr::CLKDIS::mask;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_DISABLE_CLOCK"
    },

    "start": {
      "description": "Start timer (software trigger)",
      "return_type": "void",
      "code": "hw()->CCR = tc::ccr::SWTRG::mask;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_START"
    },

    "stop": {
      "description": "Stop timer",
      "return_type": "void",
      "code": "hw()->CCR = tc::ccr::CLKDIS::mask;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_STOP"
    },

    "set_waveform_mode": {
      "description": "Set waveform mode",
      "return_type": "void",
      "code": "hw()->CMR_WAVEFORM_MODE |= tc::cmr_waveform_mode::WAVE::mask;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_WAVEFORM"
    },

    "set_capture_mode": {
      "description": "Set capture mode",
      "return_type": "void",
      "code": "hw()->CMR_CAPTURE_MODE &= ~tc::cmr_waveform_mode::WAVE::mask;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_CAPTURE"
    },

    "set_clock_source": {
      "description": "Set clock source",
      "parameters": [
        {"name": "clock_source", "type": "uint8_t", "description": "Clock source (0-7)"}
      ],
      "return_type": "void",
      "code": "hw()->CMR_WAVEFORM_MODE = (hw()->CMR_WAVEFORM_MODE & ~tc::cmr_waveform_mode::TCCLKS::mask) | tc::cmr_waveform_mode::TCCLKS::write(0, clock_source);",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_CLOCK_SRC"
    },

    "set_ra": {
      "description": "Set register A value",
      "parameters": [
        {"name": "value", "type": "uint32_t", "description": "Register A value"}
      ],
      "return_type": "void",
      "code": "hw()->RA = value;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_SET_RA"
    },

    "set_rb": {
      "description": "Set register B value",
      "parameters": [
        {"name": "value", "type": "uint32_t", "description": "Register B value"}
      ],
      "return_type": "void",
      "code": "hw()->RB = value;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_SET_RB"
    },

    "set_rc": {
      "description": "Set register C value (period)",
      "parameters": [
        {"name": "value", "type": "uint32_t", "description": "Register C value"}
      ],
      "return_type": "void",
      "code": "hw()->RC = value;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_SET_RC"
    },

    "get_counter": {
      "description": "Get counter value",
      "return_type": "uint32_t",
      "const": true,
      "code": "return hw()->CV;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_GET_COUNT"
    },

    "is_overflow": {
      "description": "Check if counter overflow occurred",
      "return_type": "bool",
      "const": true,
      "code": "return (hw()->SR & tc::sr::COVFS::mask) != 0;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_OVERFLOW"
    },

    "enable_rc_interrupt": {
      "description": "Enable RC compare interrupt",
      "return_type": "void",
      "code": "hw()->IER = tc::ier::CPCS::mask;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_INT_EN"
    },

    "disable_rc_interrupt": {
      "description": "Disable RC compare interrupt",
      "return_type": "void",
      "code": "hw()->IDR = tc::idr::CPCS::mask;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_INT_DIS"
    },

    "is_rc_compare": {
      "description": "Check if RC compare event occurred",
      "return_type": "bool",
      "const": true,
      "code": "return (hw()->SR & tc::sr::CPCS::mask) != 0;",
      "test_hook": "ALLOY_TIMER_TEST_HOOK_RC_CMP"
    }
  },

  "instances": [
    {"name": "Timer0Ch0", "base": "0x4000C000", "clock": "150000000", "description": "TC0 Channel 0"},
    {"name": "Timer1Ch0", "base": "0x40010000", "clock": "150000000", "description": "TC1 Channel 0"},
    {"name": "Timer2Ch0", "base": "0x40014000", "clock": "150000000", "description": "TC2 Channel 0"},
    {"name": "Timer3Ch0", "base": "0x40054000", "clock": "150000000", "description": "TC3 Channel 0"}
  ]
}
