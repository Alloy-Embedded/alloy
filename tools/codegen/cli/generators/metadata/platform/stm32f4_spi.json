{
  "family": "stm32f4",
  "vendor": "st",
  "peripheral_name": "SPI",
  "register_include": "hal/vendors/st/stm32f4/registers/spi1_registers.hpp",
  "bitfield_include": "hal/vendors/st/stm32f4/bitfields/spi1_bitfields.hpp",
  "register_namespace": "st::stm32f4::spi1",
  "namespace_alias": "spi",
  "register_type": "SPI1_Registers",
  "platform_namespace": "alloy::hal::stm32f4",
  "vendor_namespace": "alloy::hal::st::stm32f4",
  "requires_clock": true,

  "template_params": [
    {
      "name": "BASE_ADDR",
      "type": "uint32_t",
      "description": "SPI peripheral base address"
    },
    {
      "name": "PERIPH_CLOCK_HZ",
      "type": "uint32_t",
      "description": "Peripheral clock frequency for baud rate calculation"
    }
  ],

  "constants": [
    {
      "name": "SPI_TIMEOUT",
      "type": "uint32_t",
      "value": "100000",
      "description": "SPI timeout in loop iterations"
    }
  ],

  "policy_methods": {
    "description": "Hardware Policy methods for STM32F4 SPI",
    "peripheral_clock_hz": 84000000,
    "mock_hook_prefix": "ALLOY_SPI_MOCK_HW",

    "hw_accessor": {
      "description": "Get pointer to hardware registers",
      "return_type": "volatile RegisterType*",
      "code": "return reinterpret_cast<volatile RegisterType*>(BASE_ADDR);"
    },

    "reset": {
      "description": "Reset SPI peripheral",
      "return_type": "void",
      "code": "hw()->CR1 &= ~spi::cr1::SPE::mask;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_RESET"
    },

    "enable": {
      "description": "Enable SPI peripheral",
      "return_type": "void",
      "code": "hw()->CR1 |= spi::cr1::SPE::mask;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_ENABLE"
    },

    "disable": {
      "description": "Disable SPI peripheral",
      "return_type": "void",
      "code": "hw()->CR1 &= ~spi::cr1::SPE::mask;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_DISABLE"
    },

    "configure_master": {
      "description": "Configure SPI in master mode",
      "parameters": [
        {"name": "clock_div", "type": "uint8_t", "description": "Clock divider"},
        {"name": "mode", "type": "uint8_t", "description": "SPI mode (0-3)"}
      ],
      "return_type": "void",
      "code": "uint32_t cr1 = spi::cr1::MSTR::mask | spi::cr1::SSM::mask | spi::cr1::SSI::mask | spi::cr1::BR::write(0, clock_div); if (mode & 0x01) cr1 |= spi::cr1::CPHA::mask; if (mode & 0x02) cr1 |= spi::cr1::CPOL::mask; hw()->CR1 = cr1;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_MASTER"
    },

    "is_tx_ready": {
      "description": "Check if TX buffer is empty",
      "return_type": "bool",
      "const": true,
      "code": "return (hw()->SR & spi::sr::TXE::mask) != 0;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_TX_READY"
    },

    "is_rx_ready": {
      "description": "Check if RX buffer has data",
      "return_type": "bool",
      "const": true,
      "code": "return (hw()->SR & spi::sr::RXNE::mask) != 0;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_RX_READY"
    },

    "write_byte": {
      "description": "Write byte to data register",
      "parameters": [
        {"name": "byte", "type": "uint8_t", "description": "Byte to transmit"}
      ],
      "return_type": "void",
      "code": "hw()->DR = byte;",
      "test_hook": "ALLOY_SPI_TEST_HOOK_WRITE"
    },

    "read_byte": {
      "description": "Read byte from data register",
      "return_type": "uint8_t",
      "const": true,
      "code": "return static_cast<uint8_t>(hw()->DR & 0xFF);",
      "test_hook": "ALLOY_SPI_TEST_HOOK_READ"
    }
  },

  "instances": [
    {"name": "Spi1", "base": "0x40013000", "clock": "84000000"},
    {"name": "Spi2", "base": "0x40003800", "clock": "42000000"},
    {"name": "Spi3", "base": "0x40003C00", "clock": "42000000"}
  ]
}
