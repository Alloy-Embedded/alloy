{
  "family": "stm32f4",
  "vendor": "st",
  "peripheral_name": "TIM",
  "register_include": "hal/vendors/st/stm32f4/registers/tim2_registers.hpp",
  "bitfield_include": "hal/vendors/st/stm32f4/bitfields/tim2_bitfields.hpp",
  "register_namespace": "alloy::hal::st::stm32f4::tim2",
  "register_type": "TIM2_Registers",
  "platform_namespace": "alloy::hal::stm32f4",
  "vendor_namespace": "alloy::hal::st::stm32f4",
  "namespace_alias": "tim",
  "requires_clock": false,

  "template_params": [
    {
      "name": "BASE_ADDR",
      "type": "uint32_t",
      "description": "Timer peripheral base address"
    },
    {
      "name": "IRQ_ID",
      "type": "uint32_t",
      "description": "Timer IRQ ID"
    }
  ],

  "additional_enums": [
    {
      "name": "TimerMode",
      "type": "uint8_t",
      "description": "Timer counting mode",
      "values": [
        {"name": "Up", "value": 0, "description": "Up counting mode"},
        {"name": "Down", "value": 1, "description": "Down counting mode"},
        {"name": "CenterAligned1", "value": 2, "description": "Center-aligned mode 1"},
        {"name": "CenterAligned2", "value": 3, "description": "Center-aligned mode 2"},
        {"name": "CenterAligned3", "value": 4, "description": "Center-aligned mode 3"}
      ]
    },
    {
      "name": "PwmMode",
      "type": "uint8_t",
      "description": "PWM mode selection",
      "values": [
        {"name": "Mode1", "value": 6, "description": "PWM mode 1 (active high)"},
        {"name": "Mode2", "value": 7, "description": "PWM mode 2 (active low)"}
      ]
    },
    {
      "name": "Channel",
      "type": "uint8_t",
      "description": "Timer channel selection",
      "values": [
        {"name": "CH1", "value": 1, "description": "Channel 1"},
        {"name": "CH2", "value": 2, "description": "Channel 2"},
        {"name": "CH3", "value": 3, "description": "Channel 3"},
        {"name": "CH4", "value": 4, "description": "Channel 4"}
      ]
    }
  ],

  "config_struct": {
    "name": "TimerConfig",
    "description": "Timer configuration structure",
    "fields": [
      {"name": "mode", "type": "TimerMode", "default": "TimerMode::Up", "description": "Counting mode"},
      {"name": "prescaler", "type": "uint16_t", "default": "0", "description": "Prescaler value (0-65535)"},
      {"name": "period", "type": "uint32_t", "default": "1000", "description": "Auto-reload period"},
      {"name": "clock_division", "type": "uint8_t", "default": "0", "description": "Clock division (0=1x, 1=2x, 2=4x)"}
    ]
  },

  "registers": {
    "control1": {"name": "CR1", "description": "Control Register 1"},
    "control2": {"name": "CR2", "description": "Control Register 2"},
    "interrupt_enable": {"name": "DIER", "description": "DMA/Interrupt Enable Register"},
    "status": {"name": "SR", "description": "Status Register"},
    "event_generation": {"name": "EGR", "description": "Event Generation Register"},
    "ccmr1_output": {"name": "CCMR1_Output", "description": "Capture/Compare Mode Register 1 (Output)"},
    "ccmr2_output": {"name": "CCMR2_Output", "description": "Capture/Compare Mode Register 2 (Output)"},
    "capture_compare_enable": {"name": "CCER", "description": "Capture/Compare Enable Register"},
    "counter": {"name": "CNT", "description": "Counter"},
    "prescaler_reg": {"name": "PSC", "description": "Prescaler"},
    "auto_reload": {"name": "ARR", "description": "Auto-Reload Register"},
    "ccr1": {"name": "CCR1", "description": "Capture/Compare Register 1"},
    "ccr2": {"name": "CCR2", "description": "Capture/Compare Register 2"},
    "ccr3": {"name": "CCR3", "description": "Capture/Compare Register 3"},
    "ccr4": {"name": "CCR4", "description": "Capture/Compare Register 4"}
  },

  "operations": {
    "open": {
      "description": "Initialize timer",
      "parameters": [],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (m_opened)",
          "return_error": "ErrorCode::AlreadyInitialized"
        },
        {
          "comment": "Enable timer clock (RCC)",
          "custom_code": "// TODO: Enable peripheral clock via RCC"
        },
        {
          "set_state": "m_opened = true"
        }
      ],
      "always_succeeds": true
    },

    "close": {
      "description": "Close timer",
      "parameters": [],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "comment": "Disable counter",
          "custom_code": "hw->CR1 &= ~tim::cr1::CEN::mask;"
        },
        {
          "set_state": "m_opened = false"
        }
      ],
      "always_succeeds": true
    },

    "configure": {
      "description": "Configure timer",
      "parameters": [
        {"name": "config", "type": "const TimerConfig&", "description": "Timer configuration"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "comment": "Disable counter during configuration",
          "custom_code": "hw->CR1 &= ~tim::cr1::CEN::mask;"
        },
        {
          "comment": "Configure CR1: counting mode and clock division",
          "custom_code": "uint32_t cr1 = hw->CR1 & ~(tim::cr1::DIR::mask | tim::cr1::CMS::mask | tim::cr1::CKD::mask);\n        \n        // Set counting direction/mode\n        if (config.mode == TimerMode::Down) {\n            cr1 = tim::cr1::DIR::set(cr1);\n        } else if (config.mode >= TimerMode::CenterAligned1 && config.mode <= TimerMode::CenterAligned3) {\n            uint32_t cms_val = static_cast<uint32_t>(config.mode) - 2;\n            cr1 = tim::cr1::CMS::write(cr1, cms_val);\n        }\n        \n        // Set clock division\n        cr1 = tim::cr1::CKD::write(cr1, config.clock_division);\n        hw->CR1 = cr1;"
        },
        {
          "comment": "Set prescaler and period",
          "custom_code": "hw->PSC = config.prescaler;\n        hw->ARR = config.period;"
        },
        {
          "comment": "Generate update event to load prescaler",
          "custom_code": "hw->EGR = tim::egr::UG::mask;"
        },
        {
          "custom_code": "m_config = config;"
        }
      ],
      "always_succeeds": true
    },

    "start": {
      "description": "Start timer",
      "parameters": [],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "comment": "Enable counter",
          "custom_code": "hw->CR1 |= tim::cr1::CEN::mask;"
        }
      ],
      "always_succeeds": true
    },

    "stop": {
      "description": "Stop timer",
      "parameters": [],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "comment": "Disable counter",
          "custom_code": "hw->CR1 &= ~tim::cr1::CEN::mask;"
        }
      ],
      "always_succeeds": true
    },

    "configurePwmChannel": {
      "description": "Configure PWM on a specific channel",
      "parameters": [
        {"name": "channel", "type": "Channel", "description": "Channel to configure"},
        {"name": "mode", "type": "PwmMode", "description": "PWM mode"},
        {"name": "duty", "type": "uint32_t", "description": "Duty cycle value (0 to period)"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "comment": "Configure channel mode and duty",
          "custom_code": "uint8_t ch = static_cast<uint8_t>(channel);\n        uint32_t mode_val = static_cast<uint32_t>(mode);\n        \n        if (ch == 1 || ch == 2) {\n            // Channel 1 or 2 - use CCMR1\n            uint32_t ccmr1 = hw->CCMR1_Output;\n            \n            if (ch == 1) {\n                // Configure CC1 as output\n                ccmr1 = tim::ccmr1_output::CC1S::write(ccmr1, 0);\n                ccmr1 = tim::ccmr1_output::OC1M::write(ccmr1, mode_val);\n                ccmr1 = tim::ccmr1_output::OC1PE::set(ccmr1);  // Preload enable\n                hw->CCR1 = duty;\n            } else {\n                // Configure CC2 as output\n                ccmr1 = tim::ccmr1_output::CC2S::write(ccmr1, 0);\n                ccmr1 = tim::ccmr1_output::OC2M::write(ccmr1, mode_val);\n                ccmr1 = tim::ccmr1_output::OC2PE::set(ccmr1);\n                hw->CCR2 = duty;\n            }\n            \n            hw->CCMR1_Output = ccmr1;\n        } else {\n            // Channel 3 or 4 - use CCMR2\n            uint32_t ccmr2 = hw->CCMR2_Output;\n            \n            if (ch == 3) {\n                ccmr2 = tim::ccmr2_output::CC3S::write(ccmr2, 0);\n                ccmr2 = tim::ccmr2_output::OC3M::write(ccmr2, mode_val);\n                ccmr2 = tim::ccmr2_output::OC3PE::set(ccmr2);\n                hw->CCR3 = duty;\n            } else {\n                ccmr2 = tim::ccmr2_output::CC4S::write(ccmr2, 0);\n                ccmr2 = tim::ccmr2_output::OC4M::write(ccmr2, mode_val);\n                ccmr2 = tim::ccmr2_output::OC4PE::set(ccmr2);\n                hw->CCR4 = duty;\n            }\n            \n            hw->CCMR2_Output = ccmr2;\n        }\n        \n        // Enable the channel output\n        uint32_t ccer = hw->CCER;\n        ccer |= (tim::ccer::CC1E::mask << ((ch - 1) * 4));\n        hw->CCER = ccer;"
        }
      ],
      "always_succeeds": true
    },

    "setDuty": {
      "description": "Set PWM duty cycle for a channel",
      "parameters": [
        {"name": "channel", "type": "Channel", "description": "Channel to update"},
        {"name": "duty", "type": "uint32_t", "description": "Duty cycle value (0 to period)"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "custom_code": "uint8_t ch = static_cast<uint8_t>(channel);\n        switch (ch) {\n            case 1: hw->CCR1 = duty; break;\n            case 2: hw->CCR2 = duty; break;\n            case 3: hw->CCR3 = duty; break;\n            case 4: hw->CCR4 = duty; break;\n            default: return Err(ErrorCode::InvalidParameter);\n        }"
        }
      ],
      "always_succeeds": true
    },

    "setPeriod": {
      "description": "Set period (frequency)",
      "parameters": [
        {"name": "period", "type": "uint32_t", "description": "Period value (ARR register)"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "custom_code": "hw->ARR = period;\n        m_config.period = period;"
        }
      ],
      "always_succeeds": true
    },

    "getCounter": {
      "description": "Get current counter value",
      "parameters": [],
      "return_type": "Result<uint32_t, ErrorCode>",
      "const": true,
      "returns": "hw->CNT",
      "returns_type": "uint32_t",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        }
      ]
    },

    "enableInterrupts": {
      "description": "Enable timer interrupts",
      "parameters": [
        {"name": "interrupt_mask", "type": "uint32_t", "description": "Interrupt mask (DIER register bits)"}
      ],
      "return_type": "Result<void, ErrorCode>",
      "steps": [
        {
          "check_state": "if (!m_opened)",
          "return_error": "ErrorCode::NotInitialized"
        },
        {
          "custom_code": "hw->DIER |= interrupt_mask;"
        }
      ],
      "always_succeeds": true
    },

    "isOpen": {
      "description": "Check if timer is open",
      "parameters": [],
      "return_type": "bool",
      "const": true,
      "returns": "m_opened",
      "returns_type": "bool",
      "steps": []
    }
  },

  "state_variables": [
    {"name": "m_opened", "type": "bool", "initial_value": "false", "description": "Tracks if peripheral is initialized"},
    {"name": "m_config", "type": "TimerConfig", "initial_value": "{}", "description": "Current configuration"}
  ],

  "instances": [
    {"name": "Timer1", "base": "0x40010000", "irq": "25", "description": "Advanced-control timer TIM1"},
    {"name": "Timer2", "base": "0x40000000", "irq": "28", "description": "General-purpose timer TIM2"},
    {"name": "Timer3", "base": "0x40000400", "irq": "29", "description": "General-purpose timer TIM3"},
    {"name": "Timer4", "base": "0x40000800", "irq": "30", "description": "General-purpose timer TIM4"},
    {"name": "Timer5", "base": "0x40000C00", "irq": "50", "description": "General-purpose timer TIM5"},
    {"name": "Timer9", "base": "0x40014000", "irq": "24", "description": "General-purpose timer TIM9"},
    {"name": "Timer10", "base": "0x40014400", "irq": "25", "description": "General-purpose timer TIM10"},
    {"name": "Timer11", "base": "0x40014800", "irq": "26", "description": "General-purpose timer TIM11"}
  ],

  "examples": {
    "basic_usage": {
      "description": "Basic timer PWM usage",
      "code": "using MyTimer = Timer<TIM2_BASE, TIM2_IRQ>;\nauto timer = MyTimer{};\nTimerConfig config;\nconfig.mode = TimerMode::Up;\nconfig.prescaler = 83;  // 84MHz / (83+1) = 1MHz\nconfig.period = 1000;   // 1kHz\ntimer.open();\ntimer.configure(config);\ntimer.configurePwmChannel(Channel::CH1, PwmMode::Mode1, 500);  // 50% duty\ntimer.start();"
    }
  }
}
