{
  "family": "stm32g0",
  "mcu": "stm32g0b1",
  "vendor": "st",
  "peripheral_name": "DMA",
  "description": "Direct Memory Access Controller",
  "register_type": "DMA1_Registers",
  "register_namespace": "dma1",
  "register_include": "hal/vendors/st/stm32g0/registers/dma1_registers.hpp",
  "bitfield_include": "hal/vendors/st/stm32g0/bitfields/dma1_bitfields.hpp",
  "platform_namespace": "alloy::hal::st::stm32g0",
  "vendor_namespace": "alloy::hal::st::stm32g0",

  "features": {
    "memory_to_memory": true,
    "peripheral_to_memory": true,
    "memory_to_peripheral": true,
    "circular_mode": true,
    "priority_levels": 4,
    "data_sizes": ["byte", "halfword", "word"]
  },

  "dma_bases": {
    "DMA1": "0x40020000",
    "DMA2": "0x40020400"
  },

  "template_params": [
    {
      "name": "BASE_ADDR",
      "type": "uint32_t",
      "description": "Peripheral base address"
    },
    {
      "name": "PERIPH_CLOCK_HZ",
      "type": "uint32_t",
      "description": "Peripheral clock frequency in Hz"
    }
  ],

  "policy_methods": {
    "description": "Hardware Policy methods for DMA on STM32G0",
    "peripheral_clock_hz": 64000000,
    "mock_hook_prefix": "ALLOY_DMA_MOCK_HW",

    "hw_accessor": {
      "description": "Get pointer to hardware registers",
      "return_type": "volatile RegisterType*",
      "code": "return reinterpret_cast<volatile RegisterType*>(BASE_ADDR);"
    },

    "enable_channel_1": {
      "description": "Enable DMA channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 |= (1U << 0);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_EN1",
      "notes": "EN bit in CCR1"
    },

    "disable_channel_1": {
      "description": "Disable DMA channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 &= ~(1U << 0);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_EN1"
    },

    "set_transfer_count_ch1": {
      "description": "Set number of data to transfer for channel 1",
      "parameters": [
        {"name": "count", "type": "uint16_t", "description": "Number of data items (1-65535)"}
      ],
      "return_type": "void",
      "code": "hw()->DMA_CNDTR1 = count & 0xFFFF;",
      "test_hook": "ALLOY_DMA_TEST_HOOK_NDT1"
    },

    "set_peripheral_address_ch1": {
      "description": "Set peripheral address for channel 1",
      "parameters": [
        {"name": "address", "type": "uint32_t", "description": "Peripheral register address"}
      ],
      "return_type": "void",
      "code": "hw()->DMA_CPAR1 = address;",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PA1"
    },

    "set_memory_address_ch1": {
      "description": "Set memory address for channel 1",
      "parameters": [
        {"name": "address", "type": "uint32_t", "description": "Memory buffer address"}
      ],
      "return_type": "void",
      "code": "hw()->DMA_CMAR1 = address;",
      "test_hook": "ALLOY_DMA_TEST_HOOK_MA1"
    },

    "set_direction_periph_to_mem_ch1": {
      "description": "Set transfer direction peripheral-to-memory for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 &= ~(1U << 4);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_DIR1",
      "notes": "DIR=0 (read from peripheral)"
    },

    "set_direction_mem_to_periph_ch1": {
      "description": "Set transfer direction memory-to-peripheral for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 |= (1U << 4);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_DIR1",
      "notes": "DIR=1 (read from memory)"
    },

    "enable_circular_mode_ch1": {
      "description": "Enable circular mode for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 |= (1U << 5);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_CIRC1",
      "notes": "CIRC bit in CCR1"
    },

    "disable_circular_mode_ch1": {
      "description": "Disable circular mode for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 &= ~(1U << 5);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_CIRC1"
    },

    "enable_memory_increment_ch1": {
      "description": "Enable memory address increment for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 |= (1U << 7);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_MINC1",
      "notes": "MINC bit in CCR1"
    },

    "disable_memory_increment_ch1": {
      "description": "Disable memory address increment for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 &= ~(1U << 7);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_MINC1"
    },

    "enable_peripheral_increment_ch1": {
      "description": "Enable peripheral address increment for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 |= (1U << 6);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PINC1",
      "notes": "PINC bit in CCR1"
    },

    "set_memory_size_8bit_ch1": {
      "description": "Set memory data size to 8-bit for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 &= ~(0x3U << 10);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_MSIZE1",
      "notes": "MSIZE=00 (8-bit)"
    },

    "set_memory_size_16bit_ch1": {
      "description": "Set memory data size to 16-bit for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 = (hw()->DMA_CCR1 & ~(0x3U << 10)) | (0x1U << 10);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_MSIZE1",
      "notes": "MSIZE=01 (16-bit)"
    },

    "set_memory_size_32bit_ch1": {
      "description": "Set memory data size to 32-bit for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 = (hw()->DMA_CCR1 & ~(0x3U << 10)) | (0x2U << 10);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_MSIZE1",
      "notes": "MSIZE=10 (32-bit)"
    },

    "set_peripheral_size_8bit_ch1": {
      "description": "Set peripheral data size to 8-bit for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 &= ~(0x3U << 8);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PSIZE1",
      "notes": "PSIZE=00 (8-bit)"
    },

    "set_peripheral_size_16bit_ch1": {
      "description": "Set peripheral data size to 16-bit for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 = (hw()->DMA_CCR1 & ~(0x3U << 8)) | (0x1U << 8);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PSIZE1",
      "notes": "PSIZE=01 (16-bit)"
    },

    "set_peripheral_size_32bit_ch1": {
      "description": "Set peripheral data size to 32-bit for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 = (hw()->DMA_CCR1 & ~(0x3U << 8)) | (0x2U << 8);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PSIZE1",
      "notes": "PSIZE=10 (32-bit)"
    },

    "set_priority_low_ch1": {
      "description": "Set low priority for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 &= ~(0x3U << 12);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PL1",
      "notes": "PL=00 (low)"
    },

    "set_priority_medium_ch1": {
      "description": "Set medium priority for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 = (hw()->DMA_CCR1 & ~(0x3U << 12)) | (0x1U << 12);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PL1",
      "notes": "PL=01 (medium)"
    },

    "set_priority_high_ch1": {
      "description": "Set high priority for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 = (hw()->DMA_CCR1 & ~(0x3U << 12)) | (0x2U << 12);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PL1",
      "notes": "PL=10 (high)"
    },

    "set_priority_very_high_ch1": {
      "description": "Set very high priority for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 |= (0x3U << 12);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_PL1",
      "notes": "PL=11 (very high)"
    },

    "enable_transfer_complete_interrupt_ch1": {
      "description": "Enable transfer complete interrupt for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_CCR1 |= (1U << 1);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_TCIE1",
      "notes": "TCIE bit in CCR1"
    },

    "is_transfer_complete_ch1": {
      "description": "Check if transfer is complete for channel 1",
      "parameters": [],
      "return_type": "bool",
      "code": "return (hw()->DMA_ISR & (1U << 1)) != 0;",
      "test_hook": "ALLOY_DMA_TEST_HOOK_TCIF1",
      "notes": "TCIF1 bit in ISR"
    },

    "clear_transfer_complete_flag_ch1": {
      "description": "Clear transfer complete flag for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_IFCR = (1U << 1);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_CTCIF1",
      "notes": "CTCIF1 bit in IFCR"
    },

    "is_transfer_error_ch1": {
      "description": "Check if transfer error occurred for channel 1",
      "parameters": [],
      "return_type": "bool",
      "code": "return (hw()->DMA_ISR & (1U << 3)) != 0;",
      "test_hook": "ALLOY_DMA_TEST_HOOK_TEIF1",
      "notes": "TEIF1 bit in ISR"
    },

    "clear_transfer_error_flag_ch1": {
      "description": "Clear transfer error flag for channel 1",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->DMA_IFCR = (1U << 3);",
      "test_hook": "ALLOY_DMA_TEST_HOOK_CTEIF1",
      "notes": "CTEIF1 bit in IFCR"
    }
  }
}
