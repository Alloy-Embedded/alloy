{
  "family": "stm32g0",
  "mcu": "stm32g0b1",
  "vendor": "st",
  "peripheral_name": "I2C",
  "description": "Inter-Integrated Circuit",
  "register_type": "I2C1_Registers",
  "register_namespace": "i2c1",
  "register_include": "hal/vendors/st/stm32g0/registers/i2c1_registers.hpp",
  "bitfield_include": "hal/vendors/st/stm32g0/bitfields/i2c1_bitfields.hpp",
  "platform_namespace": "alloy::hal::st::stm32g0",
  "vendor_namespace": "alloy::hal::st::stm32g0",

  "features": {
    "master_mode": true,
    "slave_mode": true,
    "fast_mode_plus": true,
    "smbus": true,
    "10bit_addressing": true,
    "dma_support": true,
    "wakeup_from_stop": true
  },

  "i2c_bases": {
    "I2C1": "0x40005400",
    "I2C2": "0x40005800"
  },

  "template_params": [
    {
      "name": "BASE_ADDR",
      "type": "uint32_t",
      "description": "Peripheral base address"
    },
    {
      "name": "PERIPH_CLOCK_HZ",
      "type": "uint32_t",
      "description": "Peripheral clock frequency in Hz"
    }
  ],

  "policy_methods": {
    "description": "Hardware Policy methods for I2C on STM32G0",
    "peripheral_clock_hz": 64000000,
    "mock_hook_prefix": "ALLOY_I2C_MOCK_HW",

    "hw_accessor": {
      "description": "Get pointer to hardware registers",
      "return_type": "volatile RegisterType*",
      "code": "return reinterpret_cast<volatile RegisterType*>(BASE_ADDR);"
    },

    "enable_i2c": {
      "description": "Enable I2C peripheral",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR1 |= (1U << 0);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_PE",
      "notes": "PE bit in CR1"
    },

    "disable_i2c": {
      "description": "Disable I2C peripheral",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR1 &= ~(1U << 0);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_PE"
    },

    "set_timing": {
      "description": "Set I2C timing register for clock configuration",
      "parameters": [
        {"name": "timing", "type": "uint32_t", "description": "Timing value (PRESC:SCLDEL:SDADEL:SCLH:SCLL)"}
      ],
      "return_type": "void",
      "code": "hw()->I2C_TIMINGR = timing;",
      "test_hook": "ALLOY_I2C_TEST_HOOK_TIMINGR"
    },

    "set_slave_address_7bit": {
      "description": "Set 7-bit slave address",
      "parameters": [
        {"name": "address", "type": "uint8_t", "description": "7-bit slave address"}
      ],
      "return_type": "void",
      "code": "hw()->I2C_CR2 = (hw()->I2C_CR2 & ~(0x3FFU << 0)) | ((address & 0x7FU) << 1);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_SADD",
      "notes": "SADD[7:1] for 7-bit addressing"
    },

    "set_transfer_direction_write": {
      "description": "Set transfer direction to write (master transmitter)",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR2 &= ~(1U << 10);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_RD_WRN",
      "notes": "RD_WRN=0 (write)"
    },

    "set_transfer_direction_read": {
      "description": "Set transfer direction to read (master receiver)",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR2 |= (1U << 10);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_RD_WRN",
      "notes": "RD_WRN=1 (read)"
    },

    "set_number_of_bytes": {
      "description": "Set number of bytes to transfer",
      "parameters": [
        {"name": "nbytes", "type": "uint8_t", "description": "Number of bytes (0-255)"}
      ],
      "return_type": "void",
      "code": "hw()->I2C_CR2 = (hw()->I2C_CR2 & ~(0xFFU << 16)) | ((nbytes & 0xFFU) << 16);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_NBYTES",
      "notes": "NBYTES[7:0] in CR2"
    },

    "generate_start": {
      "description": "Generate START condition",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR2 |= (1U << 13);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_START",
      "notes": "START bit in CR2"
    },

    "generate_stop": {
      "description": "Generate STOP condition",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR2 |= (1U << 14);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_STOP",
      "notes": "STOP bit in CR2"
    },

    "write_data": {
      "description": "Write data to transmit register",
      "parameters": [
        {"name": "data", "type": "uint8_t", "description": "Data byte to transmit"}
      ],
      "return_type": "void",
      "code": "hw()->I2C_TXDR = data;",
      "test_hook": "ALLOY_I2C_TEST_HOOK_TXDR"
    },

    "read_data": {
      "description": "Read data from receive register",
      "parameters": [],
      "return_type": "uint8_t",
      "code": "return static_cast<uint8_t>(hw()->I2C_RXDR & 0xFF);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_RXDR"
    },

    "is_tx_empty": {
      "description": "Check if transmit data register is empty",
      "parameters": [],
      "return_type": "bool",
      "code": "return (hw()->I2C_ISR & (1U << 0)) != 0;",
      "test_hook": "ALLOY_I2C_TEST_HOOK_TXE",
      "notes": "TXE bit in ISR"
    },

    "is_rx_not_empty": {
      "description": "Check if receive data register has data",
      "parameters": [],
      "return_type": "bool",
      "code": "return (hw()->I2C_ISR & (1U << 2)) != 0;",
      "test_hook": "ALLOY_I2C_TEST_HOOK_RXNE",
      "notes": "RXNE bit in ISR"
    },

    "is_transfer_complete": {
      "description": "Check if transfer is complete",
      "parameters": [],
      "return_type": "bool",
      "code": "return (hw()->I2C_ISR & (1U << 6)) != 0;",
      "test_hook": "ALLOY_I2C_TEST_HOOK_TC",
      "notes": "TC bit in ISR"
    },

    "is_stop_detected": {
      "description": "Check if STOP condition detected",
      "parameters": [],
      "return_type": "bool",
      "code": "return (hw()->I2C_ISR & (1U << 5)) != 0;",
      "test_hook": "ALLOY_I2C_TEST_HOOK_STOPF",
      "notes": "STOPF bit in ISR"
    },

    "is_nack_received": {
      "description": "Check if NACK received",
      "parameters": [],
      "return_type": "bool",
      "code": "return (hw()->I2C_ISR & (1U << 4)) != 0;",
      "test_hook": "ALLOY_I2C_TEST_HOOK_NACKF",
      "notes": "NACKF bit in ISR"
    },

    "clear_stop_flag": {
      "description": "Clear STOP detection flag",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_ICR = (1U << 5);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_STOPCF",
      "notes": "STOPCF bit in ICR"
    },

    "clear_nack_flag": {
      "description": "Clear NACK detection flag",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_ICR = (1U << 4);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_NACKCF",
      "notes": "NACKCF bit in ICR"
    },

    "enable_rx_dma": {
      "description": "Enable DMA for reception",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR1 |= (1U << 15);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_RXDMAEN",
      "notes": "RXDMAEN bit in CR1"
    },

    "enable_tx_dma": {
      "description": "Enable DMA for transmission",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR1 |= (1U << 14);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_TXDMAEN",
      "notes": "TXDMAEN bit in CR1"
    },

    "disable_rx_dma": {
      "description": "Disable DMA for reception",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR1 &= ~(1U << 15);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_RXDMAEN"
    },

    "disable_tx_dma": {
      "description": "Disable DMA for transmission",
      "parameters": [],
      "return_type": "void",
      "code": "hw()->I2C_CR1 &= ~(1U << 14);",
      "test_hook": "ALLOY_I2C_TEST_HOOK_TXDMAEN"
    }
  }
}
