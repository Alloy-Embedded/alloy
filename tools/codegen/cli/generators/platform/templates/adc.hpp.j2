/**
 * @file adc.hpp
 * @brief Template-based ADC implementation for {{ family.upper() }} (Platform Layer)
 *
 * This file implements ADC peripheral using templates with ZERO virtual
 * functions and ZERO runtime overhead.
 *
 * Design Principles:
 * - Template-based: Peripheral address and IRQ resolved at compile-time
 * - Zero overhead: Fully inlined, identical assembly to manual register access
 * - Type-safe: Strong typing prevents errors
 * - Error handling: Uses Result<T, ErrorCode> for robust error handling
 * - DMA support: Can work with DMA for continuous high-speed conversion
 * - Testable: Includes test hooks for unit testing
 *
 * Auto-generated from: {{ metadata.family }}
 * Generator: generate_platform_adc.py
 * Generated: {{ generation_date }}
 *
 * @note Part of Alloy HAL Platform Abstraction Layer
 */

#pragma once

// ============================================================================
// Core Types
// ============================================================================

#include "core/error.hpp"
#include "core/error_code.hpp"
#include "core/result.hpp"
#include "core/types.hpp"
#include "hal/types.hpp"

// ============================================================================
// Vendor-Specific Includes (Auto-Generated)
// ============================================================================

// Register definitions from vendor (family-level)
#include "{{ metadata.register_include }}"

{% if metadata.bitfield_include %}
// Bitfields (family-level)
#include "{{ metadata.bitfield_include }}"
{% endif %}

{% if metadata.requires_clock %}
// Clock management
#include "{{ metadata.clock_include }}"
{% endif %}

namespace {{ metadata.platform_namespace }} {

using namespace alloy::core;
using namespace alloy::hal;

// Import vendor-specific register types
using namespace {{ metadata.vendor_namespace }};

{% if metadata.namespace_alias %}
// Namespace alias for bitfield access
namespace {{ metadata.namespace_alias }} = {{ metadata.register_namespace }};
{% endif %}

{% if metadata.additional_enums %}
// ============================================================================
// Platform-Specific Enums
// ============================================================================

{% for enum in metadata.additional_enums %}
{% set enum_values = enum['values'] %}
/**
 * @brief {{ enum.description }}
 */
enum class {{ enum.name }} : {{ enum.type }} {
{% for enum_value in enum_values %}
    {{ enum_value.name }} = {{ enum_value.value }},  ///< {{ enum_value.description }}
{% endfor %}
};

{% endfor %}
{% endif %}

{% if metadata.config_struct %}
/**
 * @brief {{ metadata.config_struct.description }}
 */
struct {{ metadata.config_struct.name }} {
{% for field in metadata.config_struct.fields %}
    {{ field.type }} {{ field.name }} = {{ field.default }};  ///< {{ field.description }}
{% endfor %}
};

{% endif %}
/**
 * @brief Template-based ADC peripheral for {{ family.upper() }}
 *
 * This class provides a template-based ADC implementation with ZERO runtime
 * overhead. All peripheral configuration is resolved at compile-time.
 *
 * Template Parameters:
{% for param in metadata.template_params %}
 * - {{ param.name }}: {{ param.description }}
{% endfor %}
 *
 * Example usage:
 * @code
{% for example_name, example in metadata.examples.items() %}
 * // {{ example.description }}
{% for line in example.code.split('\n') %}
 * {{ line }}
{% endfor %}
{% endfor %}
 * @endcode
 *
{% for param in metadata.template_params %}
 * @tparam {{ param.name }} {{ param.description }}
{% endfor %}
 */
template <{% for param in metadata.template_params %}{{ param.type }} {{ param.name }}{% if not loop.last %}, {% endif %}{% endfor %}>
class Adc {
{% if metadata.static_asserts %}
{% for assert in metadata.static_asserts %}
    static_assert({{ assert.condition }}, "{{ assert.message }}");
{% endfor %}
{% endif %}
public:
    // Compile-time constants
{% for param in metadata.template_params %}
    static constexpr {{ param.type }} {{ param.name|lower }} = {{ param.name }};
{% endfor %}

{% if metadata.constants %}
    // Configuration constants
{% for constant in metadata.constants %}
    static constexpr {{ constant.type }} {{ constant.name }} = {{ constant.value }};  ///< {{ constant.description }}
{% endfor %}
{% endif %}

    /**
     * @brief Get {{ metadata.peripheral_name }} peripheral registers
     *
     * Returns pointer to {{ metadata.peripheral_name }} registers. Uses conditional compilation
     * for test hook injection.
     */
    static inline volatile {{ metadata.register_namespace }}::{{ metadata.register_type }}* get_hw() {
#ifdef ALLOY_ADC_MOCK_HW
        // In tests, use the mock hardware pointer
        return ALLOY_ADC_MOCK_HW();
#else
        return reinterpret_cast<volatile {{ metadata.register_namespace }}::{{ metadata.register_type }}*>(BASE_ADDR);
#endif
    }

    constexpr Adc() = default;

{% for operation_name, operation in metadata.operations.items() %}
    /**
     * @brief {{ operation.description }}
     *
{% if operation.parameters %}
{% for param in operation.parameters %}
     * @param {{ param.name }} {{ param.description }}
{% endfor %}
{% endif %}
     * @return {{ operation.return_type }}{% if operation.returns %} {{ operation.description }}{% endif %}
{% if operation.note %}
     *
     * @note {{ operation.note }}
{% endif %}
     */
    {{ operation.return_type }} {{ operation_name }}({% if operation.parameters %}{% for param in operation.parameters %}{{ param.type }} {{ param.name }}{% if param.default %} = {{ param.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}{% endif %}){% if operation.const %} const{% endif %} {
{% if operation.steps %}
        auto* hw = get_hw();

{% for step in operation.steps %}
{% if step.check_state %}
        {{ step.check_state }} {
            return Err({{ step.return_error }});
        }

{% elif step.check_param %}
        {{ step.check_param }} {
            return Err({{ step.return_error }});
        }

{% elif step.custom_code %}
        // {{ step.comment }}
        {{ step.custom_code }}

{% elif step.set_state %}
        {{ step.set_state }};

{% elif step.register %}
{% if step.operation == 'write_bitfield' %}
        hw->{{ metadata.registers[step.register].name }} = {{ metadata.namespace_alias }}::{{ metadata.registers[step.register].name|lower }}::{{ step.bitfield }}::{{ step.value }};  // {{ step.comment }}
{% elif step.operation == 'read' %}
        auto {{ step.store_as }} = hw->{{ metadata.registers[step.register].name }};  // {{ step.comment }}
{% elif step.operation == 'write' %}
        hw->{{ metadata.registers[step.register].name }} = {{ step.value }};  // {{ step.comment }}
{% endif %}

{% endif %}
{% endfor %}
{% endif %}
{% if operation.returns %}
{% if 'Result' in operation.return_type %}
        return Ok({{ operation.returns_type }}({{ operation.returns }}));
{% else %}
        return {{ operation.returns }};
{% endif %}
{% elif operation.always_succeeds %}
        return Ok();
{% endif %}
    }

{% endfor %}
{% if metadata.static_methods %}
    // ========================================================================
    // Static Utility Methods
    // ========================================================================

{% for method in metadata.static_methods %}
    /**
     * @brief {{ method.description }}
     *
{% for param in method.parameters %}
     * @param {{ param.name }} {{ param.description }}
{% endfor %}
     * @return {{ method.return_type }}
     */
    static {% if method.constexpr %}constexpr {% endif %}{{ method.return_type }} {{ method.name }}({% for param in method.parameters %}{{ param.type }} {{ param.name }}{% if param.default %} = {{ param.default }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}) {
        {{ method.body }}
    }

{% endfor %}
{% endif %}

private:
{% if metadata.state_variables %}
{% for var in metadata.state_variables %}
    {{ var.type }} {{ var.name }} = {{ var.initial_value }};  ///< {{ var.description }}
{% endfor %}
{% endif %}
};

// ==============================================================================
// Predefined ADC Instances
// ==============================================================================

{% for instance in metadata.instances %}
constexpr uint32_t {{ instance.name.upper() }}_BASE = {{ instance.base }};
constexpr uint32_t {{ instance.name.upper() }}_IRQ = {{ instance.irq }};

{% endfor %}
{% for instance in metadata.instances %}
using {{ instance.name }} = Adc<{{ instance.name.upper() }}_BASE, {{ instance.name.upper() }}_IRQ>;  ///< {{ instance.description }}
{% endfor %}

} // namespace {{ metadata.platform_namespace }}
