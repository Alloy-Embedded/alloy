{
  "family": "RP2350",
  "architecture": "arm-cortex-m3",
  "vendor": "Raspberry Pi",
  "mcus": {
    "RP2350": {
      "flash": {
        "size_kb": 64,
        "base_address": "0x08000000",
        "page_size_kb": 1
      },
      "ram": {
        "size_kb": 20,
        "base_address": "0x20000000"
      },
      "peripherals": {
        "RESETS": {
          "instances": [
            {
              "name": "RESETS",
              "base": "0x40020000"
            }
          ],
          "registers": {
            "RESET": {
              "offset": "0x00",
              "size": 32
            },
            "WDSEL": {
              "offset": "0x04",
              "size": 32
            },
            "RESET_DONE": {
              "offset": "0x08",
              "size": 32
            }
          }
        },
        "PSM": {
          "instances": [
            {
              "name": "PSM",
              "base": "0x40018000"
            }
          ],
          "registers": {
            "FRCE_ON": {
              "offset": "0x00",
              "size": 32,
              "description": "Force block out of reset (i.e. power it on)"
            },
            "FRCE_OFF": {
              "offset": "0x04",
              "size": 32,
              "description": "Force into reset (i.e. power it off)"
            },
            "WDSEL": {
              "offset": "0x08",
              "size": 32,
              "description": "Set to 1 if the watchdog should reset this"
            },
            "DONE": {
              "offset": "0x0C",
              "size": 32,
              "description": "Is the subsystem ready?"
            }
          }
        },
        "RCC": {
          "instances": [
            {
              "name": "CLOCKS",
              "base": "0x40010000",
              "irq": 30
            }
          ],
          "registers": {
            "CLK_GPOUT0_CTRL": {
              "offset": "0x00",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_GPOUT0_DIV": {
              "offset": "0x04",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_GPOUT0_SELECTED": {
              "offset": "0x08",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_GPOUT1_CTRL": {
              "offset": "0x0C",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_GPOUT1_DIV": {
              "offset": "0x10",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_GPOUT1_SELECTED": {
              "offset": "0x14",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_GPOUT2_CTRL": {
              "offset": "0x18",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_GPOUT2_DIV": {
              "offset": "0x1C",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_GPOUT2_SELECTED": {
              "offset": "0x20",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_GPOUT3_CTRL": {
              "offset": "0x24",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_GPOUT3_DIV": {
              "offset": "0x28",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_GPOUT3_SELECTED": {
              "offset": "0x2C",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_REF_CTRL": {
              "offset": "0x30",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_REF_DIV": {
              "offset": "0x34",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_REF_SELECTED": {
              "offset": "0x38",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_SYS_CTRL": {
              "offset": "0x3C",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_SYS_DIV": {
              "offset": "0x40",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_SYS_SELECTED": {
              "offset": "0x44",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_PERI_CTRL": {
              "offset": "0x48",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_PERI_DIV": {
              "offset": "0x4C",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_PERI_SELECTED": {
              "offset": "0x50",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_HSTX_CTRL": {
              "offset": "0x54",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_HSTX_DIV": {
              "offset": "0x58",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_HSTX_SELECTED": {
              "offset": "0x5C",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_USB_CTRL": {
              "offset": "0x60",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_USB_DIV": {
              "offset": "0x64",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_USB_SELECTED": {
              "offset": "0x68",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "CLK_ADC_CTRL": {
              "offset": "0x6C",
              "size": 32,
              "description": "Clock control, can be changed on-the-fly (except for auxsrc)"
            },
            "CLK_ADC_DIV": {
              "offset": "0x70",
              "size": 32,
              "description": "Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly"
            },
            "CLK_ADC_SELECTED": {
              "offset": "0x74",
              "size": 32,
              "description": "Indicates which src is currently selected (one-hot)"
            },
            "DFTCLK_XOSC_CTRL": {
              "offset": "0x78",
              "size": 32
            },
            "DFTCLK_ROSC_CTRL": {
              "offset": "0x7C",
              "size": 32
            },
            "DFTCLK_LPOSC_CTRL": {
              "offset": "0x80",
              "size": 32
            },
            "CLK_SYS_RESUS_CTRL": {
              "offset": "0x84",
              "size": 32,
              "description": "For clearing the resus after the fault that triggered it has been corrected"
            },
            "CLK_SYS_RESUS_STATUS": {
              "offset": "0x88",
              "size": 32,
              "description": "Clock has been resuscitated, correct the error then send ctrl_clear=1"
            },
            "FC0_REF_KHZ": {
              "offset": "0x8C",
              "size": 32,
              "description": "Reference clock frequency in kHz"
            },
            "FC0_MIN_KHZ": {
              "offset": "0x90",
              "size": 32,
              "description": "Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags"
            },
            "FC0_MAX_KHZ": {
              "offset": "0x94",
              "size": 32,
              "description": "Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags"
            },
            "FC0_DELAY": {
              "offset": "0x98",
              "size": 32,
              "description": "Delays the start of frequency counting to allow the mux to settle \n                    Delay is measured in multiples of the reference clock period"
            },
            "FC0_INTERVAL": {
              "offset": "0x9C",
              "size": 32,
              "description": "The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval \n                    The default gives a test interval of 250us"
            },
            "FC0_SRC": {
              "offset": "0xA0",
              "size": 32,
              "description": "Clock sent to frequency counter, set to 0 when not required \n                    Writing to this register initiates the frequency count"
            },
            "FC0_STATUS": {
              "offset": "0xA4",
              "size": 32,
              "description": "Frequency counter status"
            },
            "FC0_RESULT": {
              "offset": "0xA8",
              "size": 32,
              "description": "Result of frequency measurement, only valid when status_done=1"
            },
            "WAKE_EN0": {
              "offset": "0xAC",
              "size": 32,
              "description": "enable clock in wake mode"
            },
            "WAKE_EN1": {
              "offset": "0xB0",
              "size": 32,
              "description": "enable clock in wake mode"
            },
            "SLEEP_EN0": {
              "offset": "0xB4",
              "size": 32,
              "description": "enable clock in sleep mode"
            },
            "SLEEP_EN1": {
              "offset": "0xB8",
              "size": 32,
              "description": "enable clock in sleep mode"
            },
            "ENABLED0": {
              "offset": "0xBC",
              "size": 32,
              "description": "indicates the state of the clock enable"
            },
            "ENABLED1": {
              "offset": "0xC0",
              "size": 32,
              "description": "indicates the state of the clock enable"
            },
            "INTR": {
              "offset": "0xC4",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTE": {
              "offset": "0xC8",
              "size": 32,
              "description": "Interrupt Enable"
            },
            "INTF": {
              "offset": "0xCC",
              "size": 32,
              "description": "Interrupt Force"
            },
            "INTS": {
              "offset": "0xD0",
              "size": 32,
              "description": "Interrupt status after masking & forcing"
            }
          }
        },
        "TICKS": {
          "instances": [
            {
              "name": "TICKS",
              "base": "0x40108000"
            }
          ],
          "registers": {
            "PROC0_CTRL": {
              "offset": "0x00",
              "size": 32,
              "description": "Controls the tick generator"
            },
            "PROC0_CYCLES": {
              "offset": "0x04",
              "size": 32,
              "description": "Total number of clk_tick cycles before the next tick."
            },
            "PROC0_COUNT": {
              "offset": "0x08",
              "size": 32,
              "description": "Count down timer: the remaining number clk_tick cycles before the next tick is generated."
            },
            "PROC1_CTRL": {
              "offset": "0x0C",
              "size": 32,
              "description": "Controls the tick generator"
            },
            "PROC1_CYCLES": {
              "offset": "0x10",
              "size": 32,
              "description": "Total number of clk_tick cycles before the next tick."
            },
            "PROC1_COUNT": {
              "offset": "0x14",
              "size": 32,
              "description": "Count down timer: the remaining number clk_tick cycles before the next tick is generated."
            },
            "TIMER0_CTRL": {
              "offset": "0x18",
              "size": 32,
              "description": "Controls the tick generator"
            },
            "TIMER0_CYCLES": {
              "offset": "0x1C",
              "size": 32,
              "description": "Total number of clk_tick cycles before the next tick."
            },
            "TIMER0_COUNT": {
              "offset": "0x20",
              "size": 32,
              "description": "Count down timer: the remaining number clk_tick cycles before the next tick is generated."
            },
            "TIMER1_CTRL": {
              "offset": "0x24",
              "size": 32,
              "description": "Controls the tick generator"
            },
            "TIMER1_CYCLES": {
              "offset": "0x28",
              "size": 32,
              "description": "Total number of clk_tick cycles before the next tick."
            },
            "TIMER1_COUNT": {
              "offset": "0x2C",
              "size": 32,
              "description": "Count down timer: the remaining number clk_tick cycles before the next tick is generated."
            },
            "WATCHDOG_CTRL": {
              "offset": "0x30",
              "size": 32,
              "description": "Controls the tick generator"
            },
            "WATCHDOG_CYCLES": {
              "offset": "0x34",
              "size": 32,
              "description": "Total number of clk_tick cycles before the next tick."
            },
            "WATCHDOG_COUNT": {
              "offset": "0x38",
              "size": 32,
              "description": "Count down timer: the remaining number clk_tick cycles before the next tick is generated."
            },
            "RISCV_CTRL": {
              "offset": "0x3C",
              "size": 32,
              "description": "Controls the tick generator"
            },
            "RISCV_CYCLES": {
              "offset": "0x40",
              "size": 32,
              "description": "Total number of clk_tick cycles before the next tick."
            },
            "RISCV_COUNT": {
              "offset": "0x44",
              "size": 32,
              "description": "Count down timer: the remaining number clk_tick cycles before the next tick is generated."
            }
          }
        },
        "PADS": {
          "instances": [
            {
              "name": "PADS_BANK0",
              "base": "0x40038000"
            }
          ],
          "registers": {
            "VOLTAGE_SELECT": {
              "offset": "0x00",
              "size": 32,
              "description": "Voltage select. Per bank control"
            },
            "GPIO0": {
              "offset": "0x04",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO1": {
              "offset": "0x08",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO2": {
              "offset": "0x0C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO3": {
              "offset": "0x10",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO4": {
              "offset": "0x14",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO5": {
              "offset": "0x18",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO6": {
              "offset": "0x1C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO7": {
              "offset": "0x20",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO8": {
              "offset": "0x24",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO9": {
              "offset": "0x28",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO10": {
              "offset": "0x2C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO11": {
              "offset": "0x30",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO12": {
              "offset": "0x34",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO13": {
              "offset": "0x38",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO14": {
              "offset": "0x3C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO15": {
              "offset": "0x40",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO16": {
              "offset": "0x44",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO17": {
              "offset": "0x48",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO18": {
              "offset": "0x4C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO19": {
              "offset": "0x50",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO20": {
              "offset": "0x54",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO21": {
              "offset": "0x58",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO22": {
              "offset": "0x5C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO23": {
              "offset": "0x60",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO24": {
              "offset": "0x64",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO25": {
              "offset": "0x68",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO26": {
              "offset": "0x6C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO27": {
              "offset": "0x70",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO28": {
              "offset": "0x74",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO29": {
              "offset": "0x78",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO30": {
              "offset": "0x7C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO31": {
              "offset": "0x80",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO32": {
              "offset": "0x84",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO33": {
              "offset": "0x88",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO34": {
              "offset": "0x8C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO35": {
              "offset": "0x90",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO36": {
              "offset": "0x94",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO37": {
              "offset": "0x98",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO38": {
              "offset": "0x9C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO39": {
              "offset": "0xA0",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO40": {
              "offset": "0xA4",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO41": {
              "offset": "0xA8",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO42": {
              "offset": "0xAC",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO43": {
              "offset": "0xB0",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO44": {
              "offset": "0xB4",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO45": {
              "offset": "0xB8",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO46": {
              "offset": "0xBC",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO47": {
              "offset": "0xC0",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "SWCLK": {
              "offset": "0xC4",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "SWD": {
              "offset": "0xC8",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            }
          }
        },
        "SPI": {
          "instances": [
            {
              "name": "PADS_QSPI",
              "base": "0x40040000"
            },
            {
              "name": "IO_QSPI",
              "base": "0x40030000",
              "irq": 23
            },
            {
              "name": "SPI0",
              "base": "0x40080000",
              "irq": 31
            },
            {
              "name": "SPI1",
              "base": "0x40088000",
              "irq": 32
            }
          ],
          "registers": {
            "VOLTAGE_SELECT": {
              "offset": "0x00",
              "size": 32,
              "description": "Voltage select. Per bank control"
            },
            "GPIO_QSPI_SCLK": {
              "offset": "0x04",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO_QSPI_SD0": {
              "offset": "0x08",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO_QSPI_SD1": {
              "offset": "0x0C",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO_QSPI_SD2": {
              "offset": "0x10",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO_QSPI_SD3": {
              "offset": "0x14",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            },
            "GPIO_QSPI_SS": {
              "offset": "0x18",
              "size": 32,
              "description": "Pad isolation control. Remove this once the pad is configured by software."
            }
          }
        },
        "IO": {
          "instances": [
            {
              "name": "IO_BANK0",
              "base": "0x40028000",
              "irq": 21
            }
          ],
          "registers": {
            "GPIO0_STATUS": {
              "offset": "0x00",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO0_CTRL": {
              "offset": "0x04",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO1_STATUS": {
              "offset": "0x08",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO1_CTRL": {
              "offset": "0x0C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO2_STATUS": {
              "offset": "0x10",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO2_CTRL": {
              "offset": "0x14",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO3_STATUS": {
              "offset": "0x18",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO3_CTRL": {
              "offset": "0x1C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO4_STATUS": {
              "offset": "0x20",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO4_CTRL": {
              "offset": "0x24",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO5_STATUS": {
              "offset": "0x28",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO5_CTRL": {
              "offset": "0x2C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO6_STATUS": {
              "offset": "0x30",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO6_CTRL": {
              "offset": "0x34",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO7_STATUS": {
              "offset": "0x38",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO7_CTRL": {
              "offset": "0x3C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO8_STATUS": {
              "offset": "0x40",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO8_CTRL": {
              "offset": "0x44",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO9_STATUS": {
              "offset": "0x48",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO9_CTRL": {
              "offset": "0x4C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO10_STATUS": {
              "offset": "0x50",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO10_CTRL": {
              "offset": "0x54",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO11_STATUS": {
              "offset": "0x58",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO11_CTRL": {
              "offset": "0x5C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO12_STATUS": {
              "offset": "0x60",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO12_CTRL": {
              "offset": "0x64",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO13_STATUS": {
              "offset": "0x68",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO13_CTRL": {
              "offset": "0x6C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO14_STATUS": {
              "offset": "0x70",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO14_CTRL": {
              "offset": "0x74",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO15_STATUS": {
              "offset": "0x78",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO15_CTRL": {
              "offset": "0x7C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO16_STATUS": {
              "offset": "0x80",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO16_CTRL": {
              "offset": "0x84",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO17_STATUS": {
              "offset": "0x88",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO17_CTRL": {
              "offset": "0x8C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO18_STATUS": {
              "offset": "0x90",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO18_CTRL": {
              "offset": "0x94",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO19_STATUS": {
              "offset": "0x98",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO19_CTRL": {
              "offset": "0x9C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO20_STATUS": {
              "offset": "0xA0",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO20_CTRL": {
              "offset": "0xA4",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO21_STATUS": {
              "offset": "0xA8",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO21_CTRL": {
              "offset": "0xAC",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO22_STATUS": {
              "offset": "0xB0",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO22_CTRL": {
              "offset": "0xB4",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO23_STATUS": {
              "offset": "0xB8",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO23_CTRL": {
              "offset": "0xBC",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO24_STATUS": {
              "offset": "0xC0",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO24_CTRL": {
              "offset": "0xC4",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO25_STATUS": {
              "offset": "0xC8",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO25_CTRL": {
              "offset": "0xCC",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO26_STATUS": {
              "offset": "0xD0",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO26_CTRL": {
              "offset": "0xD4",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO27_STATUS": {
              "offset": "0xD8",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO27_CTRL": {
              "offset": "0xDC",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO28_STATUS": {
              "offset": "0xE0",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO28_CTRL": {
              "offset": "0xE4",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO29_STATUS": {
              "offset": "0xE8",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO29_CTRL": {
              "offset": "0xEC",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO30_STATUS": {
              "offset": "0xF0",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO30_CTRL": {
              "offset": "0xF4",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO31_STATUS": {
              "offset": "0xF8",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO31_CTRL": {
              "offset": "0xFC",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO32_STATUS": {
              "offset": "0x100",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO32_CTRL": {
              "offset": "0x104",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO33_STATUS": {
              "offset": "0x108",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO33_CTRL": {
              "offset": "0x10C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO34_STATUS": {
              "offset": "0x110",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO34_CTRL": {
              "offset": "0x114",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO35_STATUS": {
              "offset": "0x118",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO35_CTRL": {
              "offset": "0x11C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO36_STATUS": {
              "offset": "0x120",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO36_CTRL": {
              "offset": "0x124",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO37_STATUS": {
              "offset": "0x128",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO37_CTRL": {
              "offset": "0x12C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO38_STATUS": {
              "offset": "0x130",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO38_CTRL": {
              "offset": "0x134",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO39_STATUS": {
              "offset": "0x138",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO39_CTRL": {
              "offset": "0x13C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO40_STATUS": {
              "offset": "0x140",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO40_CTRL": {
              "offset": "0x144",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO41_STATUS": {
              "offset": "0x148",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO41_CTRL": {
              "offset": "0x14C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO42_STATUS": {
              "offset": "0x150",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO42_CTRL": {
              "offset": "0x154",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO43_STATUS": {
              "offset": "0x158",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO43_CTRL": {
              "offset": "0x15C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO44_STATUS": {
              "offset": "0x160",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO44_CTRL": {
              "offset": "0x164",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO45_STATUS": {
              "offset": "0x168",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO45_CTRL": {
              "offset": "0x16C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO46_STATUS": {
              "offset": "0x170",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO46_CTRL": {
              "offset": "0x174",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "GPIO47_STATUS": {
              "offset": "0x178",
              "size": 32,
              "description": "interrupt to processors, after override is applied"
            },
            "GPIO47_CTRL": {
              "offset": "0x17C",
              "size": 32,
              "description": "don't invert the interrupt"
            },
            "IRQSUMMARY_PROC0_SECURE0": {
              "offset": "0x200",
              "size": 32
            },
            "IRQSUMMARY_PROC0_SECURE1": {
              "offset": "0x204",
              "size": 32
            },
            "IRQSUMMARY_PROC0_NONSECURE0": {
              "offset": "0x208",
              "size": 32
            },
            "IRQSUMMARY_PROC0_NONSECURE1": {
              "offset": "0x20C",
              "size": 32
            },
            "IRQSUMMARY_PROC1_SECURE0": {
              "offset": "0x210",
              "size": 32
            },
            "IRQSUMMARY_PROC1_SECURE1": {
              "offset": "0x214",
              "size": 32
            },
            "IRQSUMMARY_PROC1_NONSECURE0": {
              "offset": "0x218",
              "size": 32
            },
            "IRQSUMMARY_PROC1_NONSECURE1": {
              "offset": "0x21C",
              "size": 32
            },
            "IRQSUMMARY_DORMANT_WAKE_SECURE0": {
              "offset": "0x220",
              "size": 32
            },
            "IRQSUMMARY_DORMANT_WAKE_SECURE1": {
              "offset": "0x224",
              "size": 32
            },
            "IRQSUMMARY_DORMANT_WAKE_NONSECURE0": {
              "offset": "0x228",
              "size": 32
            },
            "IRQSUMMARY_DORMANT_WAKE_NONSECURE1": {
              "offset": "0x22C",
              "size": 32
            },
            "INTR0": {
              "offset": "0x230",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTR1": {
              "offset": "0x234",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTR2": {
              "offset": "0x238",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTR3": {
              "offset": "0x23C",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTR4": {
              "offset": "0x240",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTR5": {
              "offset": "0x244",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "PROC0_INTE0": {
              "offset": "0x248",
              "size": 32,
              "description": "Interrupt Enable for proc0"
            },
            "PROC0_INTE1": {
              "offset": "0x24C",
              "size": 32,
              "description": "Interrupt Enable for proc0"
            },
            "PROC0_INTE2": {
              "offset": "0x250",
              "size": 32,
              "description": "Interrupt Enable for proc0"
            },
            "PROC0_INTE3": {
              "offset": "0x254",
              "size": 32,
              "description": "Interrupt Enable for proc0"
            },
            "PROC0_INTE4": {
              "offset": "0x258",
              "size": 32,
              "description": "Interrupt Enable for proc0"
            },
            "PROC0_INTE5": {
              "offset": "0x25C",
              "size": 32,
              "description": "Interrupt Enable for proc0"
            },
            "PROC0_INTF0": {
              "offset": "0x260",
              "size": 32,
              "description": "Interrupt Force for proc0"
            },
            "PROC0_INTF1": {
              "offset": "0x264",
              "size": 32,
              "description": "Interrupt Force for proc0"
            },
            "PROC0_INTF2": {
              "offset": "0x268",
              "size": 32,
              "description": "Interrupt Force for proc0"
            },
            "PROC0_INTF3": {
              "offset": "0x26C",
              "size": 32,
              "description": "Interrupt Force for proc0"
            },
            "PROC0_INTF4": {
              "offset": "0x270",
              "size": 32,
              "description": "Interrupt Force for proc0"
            },
            "PROC0_INTF5": {
              "offset": "0x274",
              "size": 32,
              "description": "Interrupt Force for proc0"
            },
            "PROC0_INTS0": {
              "offset": "0x278",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc0"
            },
            "PROC0_INTS1": {
              "offset": "0x27C",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc0"
            },
            "PROC0_INTS2": {
              "offset": "0x280",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc0"
            },
            "PROC0_INTS3": {
              "offset": "0x284",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc0"
            },
            "PROC0_INTS4": {
              "offset": "0x288",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc0"
            },
            "PROC0_INTS5": {
              "offset": "0x28C",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc0"
            },
            "PROC1_INTE0": {
              "offset": "0x290",
              "size": 32,
              "description": "Interrupt Enable for proc1"
            },
            "PROC1_INTE1": {
              "offset": "0x294",
              "size": 32,
              "description": "Interrupt Enable for proc1"
            },
            "PROC1_INTE2": {
              "offset": "0x298",
              "size": 32,
              "description": "Interrupt Enable for proc1"
            },
            "PROC1_INTE3": {
              "offset": "0x29C",
              "size": 32,
              "description": "Interrupt Enable for proc1"
            },
            "PROC1_INTE4": {
              "offset": "0x2A0",
              "size": 32,
              "description": "Interrupt Enable for proc1"
            },
            "PROC1_INTE5": {
              "offset": "0x2A4",
              "size": 32,
              "description": "Interrupt Enable for proc1"
            },
            "PROC1_INTF0": {
              "offset": "0x2A8",
              "size": 32,
              "description": "Interrupt Force for proc1"
            },
            "PROC1_INTF1": {
              "offset": "0x2AC",
              "size": 32,
              "description": "Interrupt Force for proc1"
            },
            "PROC1_INTF2": {
              "offset": "0x2B0",
              "size": 32,
              "description": "Interrupt Force for proc1"
            },
            "PROC1_INTF3": {
              "offset": "0x2B4",
              "size": 32,
              "description": "Interrupt Force for proc1"
            },
            "PROC1_INTF4": {
              "offset": "0x2B8",
              "size": 32,
              "description": "Interrupt Force for proc1"
            },
            "PROC1_INTF5": {
              "offset": "0x2BC",
              "size": 32,
              "description": "Interrupt Force for proc1"
            },
            "PROC1_INTS0": {
              "offset": "0x2C0",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc1"
            },
            "PROC1_INTS1": {
              "offset": "0x2C4",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc1"
            },
            "PROC1_INTS2": {
              "offset": "0x2C8",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc1"
            },
            "PROC1_INTS3": {
              "offset": "0x2CC",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc1"
            },
            "PROC1_INTS4": {
              "offset": "0x2D0",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc1"
            },
            "PROC1_INTS5": {
              "offset": "0x2D4",
              "size": 32,
              "description": "Interrupt status after masking & forcing for proc1"
            },
            "DORMANT_WAKE_INTE0": {
              "offset": "0x2D8",
              "size": 32,
              "description": "Interrupt Enable for dormant_wake"
            },
            "DORMANT_WAKE_INTE1": {
              "offset": "0x2DC",
              "size": 32,
              "description": "Interrupt Enable for dormant_wake"
            },
            "DORMANT_WAKE_INTE2": {
              "offset": "0x2E0",
              "size": 32,
              "description": "Interrupt Enable for dormant_wake"
            },
            "DORMANT_WAKE_INTE3": {
              "offset": "0x2E4",
              "size": 32,
              "description": "Interrupt Enable for dormant_wake"
            },
            "DORMANT_WAKE_INTE4": {
              "offset": "0x2E8",
              "size": 32,
              "description": "Interrupt Enable for dormant_wake"
            },
            "DORMANT_WAKE_INTE5": {
              "offset": "0x2EC",
              "size": 32,
              "description": "Interrupt Enable for dormant_wake"
            },
            "DORMANT_WAKE_INTF0": {
              "offset": "0x2F0",
              "size": 32,
              "description": "Interrupt Force for dormant_wake"
            },
            "DORMANT_WAKE_INTF1": {
              "offset": "0x2F4",
              "size": 32,
              "description": "Interrupt Force for dormant_wake"
            },
            "DORMANT_WAKE_INTF2": {
              "offset": "0x2F8",
              "size": 32,
              "description": "Interrupt Force for dormant_wake"
            },
            "DORMANT_WAKE_INTF3": {
              "offset": "0x2FC",
              "size": 32,
              "description": "Interrupt Force for dormant_wake"
            },
            "DORMANT_WAKE_INTF4": {
              "offset": "0x300",
              "size": 32,
              "description": "Interrupt Force for dormant_wake"
            },
            "DORMANT_WAKE_INTF5": {
              "offset": "0x304",
              "size": 32,
              "description": "Interrupt Force for dormant_wake"
            },
            "DORMANT_WAKE_INTS0": {
              "offset": "0x308",
              "size": 32,
              "description": "Interrupt status after masking & forcing for dormant_wake"
            },
            "DORMANT_WAKE_INTS1": {
              "offset": "0x30C",
              "size": 32,
              "description": "Interrupt status after masking & forcing for dormant_wake"
            },
            "DORMANT_WAKE_INTS2": {
              "offset": "0x310",
              "size": 32,
              "description": "Interrupt status after masking & forcing for dormant_wake"
            },
            "DORMANT_WAKE_INTS3": {
              "offset": "0x314",
              "size": 32,
              "description": "Interrupt status after masking & forcing for dormant_wake"
            },
            "DORMANT_WAKE_INTS4": {
              "offset": "0x318",
              "size": 32,
              "description": "Interrupt status after masking & forcing for dormant_wake"
            },
            "DORMANT_WAKE_INTS5": {
              "offset": "0x31C",
              "size": 32,
              "description": "Interrupt status after masking & forcing for dormant_wake"
            }
          }
        },
        "SYSINFO": {
          "instances": [
            {
              "name": "SYSINFO",
              "base": "0x40000000"
            }
          ],
          "registers": {
            "CHIP_ID": {
              "offset": "0x00",
              "size": 32,
              "description": "JEDEC JEP-106 compliant chip identifier."
            },
            "PACKAGE_SEL": {
              "offset": "0x04",
              "size": 32
            },
            "PLATFORM": {
              "offset": "0x08",
              "size": 32,
              "description": "Platform register. Allows software to know what environment it is running in during pre-production development. Post-production, the PLATFORM is always ASIC, non-SIM."
            },
            "GITREF_RP2350": {
              "offset": "0x14",
              "size": 32,
              "description": "Git hash of the chip source. Used to identify chip version."
            }
          }
        },
        "CRYPTO": {
          "instances": [
            {
              "name": "SHA256",
              "base": "0x400F8000"
            }
          ],
          "registers": {
            "CSR": {
              "offset": "0x00",
              "size": 32,
              "description": "Control and status register"
            },
            "WDATA": {
              "offset": "0x04",
              "size": 32,
              "description": "Write data register"
            },
            "SUM0": {
              "offset": "0x08",
              "size": 32,
              "description": "256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0."
            },
            "SUM1": {
              "offset": "0x0C",
              "size": 32,
              "description": "256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0."
            },
            "SUM2": {
              "offset": "0x10",
              "size": 32,
              "description": "256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0."
            },
            "SUM3": {
              "offset": "0x14",
              "size": 32,
              "description": "256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0."
            },
            "SUM4": {
              "offset": "0x18",
              "size": 32,
              "description": "256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0."
            },
            "SUM5": {
              "offset": "0x1C",
              "size": 32,
              "description": "256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0."
            },
            "SUM6": {
              "offset": "0x20",
              "size": 32,
              "description": "256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0."
            },
            "SUM7": {
              "offset": "0x24",
              "size": 32,
              "description": "256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0."
            }
          }
        },
        "HSTX": {
          "instances": [
            {
              "name": "HSTX_FIFO",
              "base": "0x50600000"
            },
            {
              "name": "HSTX_CTRL",
              "base": "0x400C0000"
            }
          ],
          "registers": {
            "STAT": {
              "offset": "0x00",
              "size": 32,
              "description": "FIFO status"
            },
            "FIFO": {
              "offset": "0x04",
              "size": 32,
              "description": "Write access to FIFO"
            }
          }
        },
        "EPPB": {
          "instances": [
            {
              "name": "EPPB",
              "base": "0xE0080000"
            }
          ],
          "registers": {
            "NMI_MASK0": {
              "offset": "0x00",
              "size": 32,
              "description": "NMI mask for IRQs 0 through 31. This register is core-local, and is reset by a processor warm reset."
            },
            "NMI_MASK1": {
              "offset": "0x04",
              "size": 32,
              "description": "NMI mask for IRQs 0 though 51. This register is core-local, and is reset by a processor warm reset."
            },
            "SLEEPCTRL": {
              "offset": "0x08",
              "size": 32,
              "description": "Nonstandard sleep control register"
            }
          }
        },
        "PPB": {
          "instances": [
            {
              "name": "PPB",
              "base": "0xE0000000"
            },
            {
              "name": "PPB_NS",
              "base": "0xE0020000"
            }
          ],
          "registers": {
            "ITM_STIM0": {
              "offset": "0x00",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM1": {
              "offset": "0x04",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM2": {
              "offset": "0x08",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM3": {
              "offset": "0x0C",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM4": {
              "offset": "0x10",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM5": {
              "offset": "0x14",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM6": {
              "offset": "0x18",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM7": {
              "offset": "0x1C",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM8": {
              "offset": "0x20",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM9": {
              "offset": "0x24",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM10": {
              "offset": "0x28",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM11": {
              "offset": "0x2C",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM12": {
              "offset": "0x30",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM13": {
              "offset": "0x34",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM14": {
              "offset": "0x38",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM15": {
              "offset": "0x3C",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM16": {
              "offset": "0x40",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM17": {
              "offset": "0x44",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM18": {
              "offset": "0x48",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM19": {
              "offset": "0x4C",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM20": {
              "offset": "0x50",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM21": {
              "offset": "0x54",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM22": {
              "offset": "0x58",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM23": {
              "offset": "0x5C",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM24": {
              "offset": "0x60",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM25": {
              "offset": "0x64",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM26": {
              "offset": "0x68",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM27": {
              "offset": "0x6C",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM28": {
              "offset": "0x70",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM29": {
              "offset": "0x74",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM30": {
              "offset": "0x78",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_STIM31": {
              "offset": "0x7C",
              "size": 32,
              "description": "Provides the interface for generating Instrumentation packets"
            },
            "ITM_TER0": {
              "offset": "0xE00",
              "size": 32,
              "description": "Provide an individual enable bit for each ITM_STIM register"
            },
            "ITM_TPR": {
              "offset": "0xE40",
              "size": 32,
              "description": "Controls which stimulus ports can be accessed by unprivileged code"
            },
            "ITM_TCR": {
              "offset": "0xE80",
              "size": 32,
              "description": "Configures and controls transfers through the ITM interface"
            },
            "INT_ATREADY": {
              "offset": "0xEF0",
              "size": 32,
              "description": "Integration Mode: Read ATB Ready"
            },
            "INT_ATVALID": {
              "offset": "0xEF8",
              "size": 32,
              "description": "Integration Mode: Write ATB Valid"
            },
            "ITM_ITCTRL": {
              "offset": "0xF00",
              "size": 32,
              "description": "Integration Mode Control Register"
            },
            "ITM_DEVARCH": {
              "offset": "0xFBC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_DEVTYPE": {
              "offset": "0xFCC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_PIDR4": {
              "offset": "0xFD0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_PIDR5": {
              "offset": "0xFD4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_PIDR6": {
              "offset": "0xFD8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_PIDR7": {
              "offset": "0xFDC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_PIDR0": {
              "offset": "0xFE0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_PIDR1": {
              "offset": "0xFE4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_PIDR2": {
              "offset": "0xFE8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_PIDR3": {
              "offset": "0xFEC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_CIDR0": {
              "offset": "0xFF0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_CIDR1": {
              "offset": "0xFF4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_CIDR2": {
              "offset": "0xFF8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "ITM_CIDR3": {
              "offset": "0xFFC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the ITM"
            },
            "DWT_CTRL": {
              "offset": "0x1000",
              "size": 32,
              "description": "Provides configuration and status information for the DWT unit, and used to control features of the unit"
            },
            "DWT_CYCCNT": {
              "offset": "0x1004",
              "size": 32,
              "description": "Shows or sets the value of the processor cycle counter, CYCCNT"
            },
            "DWT_EXCCNT": {
              "offset": "0x100C",
              "size": 32,
              "description": "Counts the total cycles spent in exception processing"
            },
            "DWT_LSUCNT": {
              "offset": "0x1014",
              "size": 32,
              "description": "Increments on the additional cycles required to execute all load or store instructions"
            },
            "DWT_FOLDCNT": {
              "offset": "0x1018",
              "size": 32,
              "description": "Increments on the additional cycles required to execute all load or store instructions"
            },
            "DWT_COMP0": {
              "offset": "0x1020",
              "size": 32,
              "description": "Provides a reference value for use by watchpoint comparator 0"
            },
            "DWT_FUNCTION0": {
              "offset": "0x1028",
              "size": 32,
              "description": "Controls the operation of watchpoint comparator 0"
            },
            "DWT_COMP1": {
              "offset": "0x1030",
              "size": 32,
              "description": "Provides a reference value for use by watchpoint comparator 1"
            },
            "DWT_FUNCTION1": {
              "offset": "0x1038",
              "size": 32,
              "description": "Controls the operation of watchpoint comparator 1"
            },
            "DWT_COMP2": {
              "offset": "0x1040",
              "size": 32,
              "description": "Provides a reference value for use by watchpoint comparator 2"
            },
            "DWT_FUNCTION2": {
              "offset": "0x1048",
              "size": 32,
              "description": "Controls the operation of watchpoint comparator 2"
            },
            "DWT_COMP3": {
              "offset": "0x1050",
              "size": 32,
              "description": "Provides a reference value for use by watchpoint comparator 3"
            },
            "DWT_FUNCTION3": {
              "offset": "0x1058",
              "size": 32,
              "description": "Controls the operation of watchpoint comparator 3"
            },
            "DWT_DEVARCH": {
              "offset": "0x1FBC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_DEVTYPE": {
              "offset": "0x1FCC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_PIDR4": {
              "offset": "0x1FD0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_PIDR5": {
              "offset": "0x1FD4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_PIDR6": {
              "offset": "0x1FD8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_PIDR7": {
              "offset": "0x1FDC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_PIDR0": {
              "offset": "0x1FE0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_PIDR1": {
              "offset": "0x1FE4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_PIDR2": {
              "offset": "0x1FE8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_PIDR3": {
              "offset": "0x1FEC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_CIDR0": {
              "offset": "0x1FF0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_CIDR1": {
              "offset": "0x1FF4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_CIDR2": {
              "offset": "0x1FF8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "DWT_CIDR3": {
              "offset": "0x1FFC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the DWT"
            },
            "FP_CTRL": {
              "offset": "0x2000",
              "size": 32,
              "description": "Provides FPB implementation information, and the global enable for the FPB unit"
            },
            "FP_REMAP": {
              "offset": "0x2004",
              "size": 32,
              "description": "Indicates whether the implementation supports Flash Patch remap and, if it does, holds the target address for remap"
            },
            "FP_COMP0": {
              "offset": "0x2008",
              "size": 32,
              "description": "Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator"
            },
            "FP_COMP1": {
              "offset": "0x200C",
              "size": 32,
              "description": "Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator"
            },
            "FP_COMP2": {
              "offset": "0x2010",
              "size": 32,
              "description": "Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator"
            },
            "FP_COMP3": {
              "offset": "0x2014",
              "size": 32,
              "description": "Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator"
            },
            "FP_COMP4": {
              "offset": "0x2018",
              "size": 32,
              "description": "Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator"
            },
            "FP_COMP5": {
              "offset": "0x201C",
              "size": 32,
              "description": "Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator"
            },
            "FP_COMP6": {
              "offset": "0x2020",
              "size": 32,
              "description": "Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator"
            },
            "FP_COMP7": {
              "offset": "0x2024",
              "size": 32,
              "description": "Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator"
            },
            "FP_DEVARCH": {
              "offset": "0x2FBC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FPB"
            },
            "FP_DEVTYPE": {
              "offset": "0x2FCC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FPB"
            },
            "FP_PIDR4": {
              "offset": "0x2FD0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_PIDR5": {
              "offset": "0x2FD4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_PIDR6": {
              "offset": "0x2FD8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_PIDR7": {
              "offset": "0x2FDC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_PIDR0": {
              "offset": "0x2FE0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_PIDR1": {
              "offset": "0x2FE4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_PIDR2": {
              "offset": "0x2FE8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_PIDR3": {
              "offset": "0x2FEC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_CIDR0": {
              "offset": "0x2FF0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_CIDR1": {
              "offset": "0x2FF4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_CIDR2": {
              "offset": "0x2FF8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "FP_CIDR3": {
              "offset": "0x2FFC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the FP"
            },
            "ICTR": {
              "offset": "0xE004",
              "size": 32,
              "description": "Provides information about the interrupt controller"
            },
            "ACTLR": {
              "offset": "0xE008",
              "size": 32,
              "description": "Provides IMPLEMENTATION DEFINED configuration and control options"
            },
            "SYST_CSR": {
              "offset": "0xE010",
              "size": 32,
              "description": "Use the SysTick Control and Status Register to enable the SysTick features."
            },
            "SYST_RVR": {
              "offset": "0xE014",
              "size": 32,
              "description": "Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN. \n                    To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99."
            },
            "SYST_CVR": {
              "offset": "0xE018",
              "size": 32,
              "description": "Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN."
            },
            "SYST_CALIB": {
              "offset": "0xE01C",
              "size": 32,
              "description": "Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply."
            },
            "NVIC_ISER0": {
              "offset": "0xE100",
              "size": 32,
              "description": "Enables or reads the enabled state of each group of 32 interrupts"
            },
            "NVIC_ISER1": {
              "offset": "0xE104",
              "size": 32,
              "description": "Enables or reads the enabled state of each group of 32 interrupts"
            },
            "NVIC_ICER0": {
              "offset": "0xE180",
              "size": 32,
              "description": "Clears or reads the enabled state of each group of 32 interrupts"
            },
            "NVIC_ICER1": {
              "offset": "0xE184",
              "size": 32,
              "description": "Clears or reads the enabled state of each group of 32 interrupts"
            },
            "NVIC_ISPR0": {
              "offset": "0xE200",
              "size": 32,
              "description": "Enables or reads the pending state of each group of 32 interrupts"
            },
            "NVIC_ISPR1": {
              "offset": "0xE204",
              "size": 32,
              "description": "Enables or reads the pending state of each group of 32 interrupts"
            },
            "NVIC_ICPR0": {
              "offset": "0xE280",
              "size": 32,
              "description": "Clears or reads the pending state of each group of 32 interrupts"
            },
            "NVIC_ICPR1": {
              "offset": "0xE284",
              "size": 32,
              "description": "Clears or reads the pending state of each group of 32 interrupts"
            },
            "NVIC_IABR0": {
              "offset": "0xE300",
              "size": 32,
              "description": "For each group of 32 interrupts, shows the active state of each interrupt"
            },
            "NVIC_IABR1": {
              "offset": "0xE304",
              "size": 32,
              "description": "For each group of 32 interrupts, shows the active state of each interrupt"
            },
            "NVIC_ITNS0": {
              "offset": "0xE380",
              "size": 32,
              "description": "For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state"
            },
            "NVIC_ITNS1": {
              "offset": "0xE384",
              "size": 32,
              "description": "For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state"
            },
            "NVIC_IPR0": {
              "offset": "0xE400",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR1": {
              "offset": "0xE404",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR2": {
              "offset": "0xE408",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR3": {
              "offset": "0xE40C",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR4": {
              "offset": "0xE410",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR5": {
              "offset": "0xE414",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR6": {
              "offset": "0xE418",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR7": {
              "offset": "0xE41C",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR8": {
              "offset": "0xE420",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR9": {
              "offset": "0xE424",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR10": {
              "offset": "0xE428",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR11": {
              "offset": "0xE42C",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR12": {
              "offset": "0xE430",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR13": {
              "offset": "0xE434",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR14": {
              "offset": "0xE438",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "NVIC_IPR15": {
              "offset": "0xE43C",
              "size": 32,
              "description": "Sets or reads interrupt priorities"
            },
            "CPUID": {
              "offset": "0xED00",
              "size": 32,
              "description": "Provides identification information for the PE, including an implementer code for the device and a device ID number"
            },
            "ICSR": {
              "offset": "0xED04",
              "size": 32,
              "description": "Controls and provides status information for NMI, PendSV, SysTick and interrupts"
            },
            "VTOR": {
              "offset": "0xED08",
              "size": 32,
              "description": "The VTOR indicates the offset of the vector table base address from memory address 0x00000000."
            },
            "AIRCR": {
              "offset": "0xED0C",
              "size": 32,
              "description": "Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset."
            },
            "SCR": {
              "offset": "0xED10",
              "size": 32,
              "description": "System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states."
            },
            "CCR": {
              "offset": "0xED14",
              "size": 32,
              "description": "Sets or returns configuration and control data"
            },
            "SHPR1": {
              "offset": "0xED18",
              "size": 32,
              "description": "Sets or returns priority for system handlers 4 - 7"
            },
            "SHPR2": {
              "offset": "0xED1C",
              "size": 32,
              "description": "Sets or returns priority for system handlers 8 - 11"
            },
            "SHPR3": {
              "offset": "0xED20",
              "size": 32,
              "description": "Sets or returns priority for system handlers 12 - 15"
            },
            "SHCSR": {
              "offset": "0xED24",
              "size": 32,
              "description": "Provides access to the active and pending status of system exceptions"
            },
            "CFSR": {
              "offset": "0xED28",
              "size": 32,
              "description": "Contains the three Configurable Fault Status Registers.\n\n                    31:16 UFSR: Provides information on UsageFault exceptions\n\n                    15:8 BFSR: Provides information on BusFault exceptions\n\n                    7:0 MMFSR: Provides information on MemManage exceptions"
            },
            "HFSR": {
              "offset": "0xED2C",
              "size": 32,
              "description": "Shows the cause of any HardFaults"
            },
            "DFSR": {
              "offset": "0xED30",
              "size": 32,
              "description": "Shows which debug event occurred"
            },
            "MMFAR": {
              "offset": "0xED34",
              "size": 32,
              "description": "Shows the address of the memory location that caused an MPU fault"
            },
            "BFAR": {
              "offset": "0xED38",
              "size": 32,
              "description": "Shows the address associated with a precise data access BusFault"
            },
            "ID_PFR0": {
              "offset": "0xED40",
              "size": 32,
              "description": "Gives top-level information about the instruction set supported by the PE"
            },
            "ID_PFR1": {
              "offset": "0xED44",
              "size": 32,
              "description": "Gives information about the programmers' model and Extensions support"
            },
            "ID_DFR0": {
              "offset": "0xED48",
              "size": 32,
              "description": "Provides top level information about the debug system"
            },
            "ID_AFR0": {
              "offset": "0xED4C",
              "size": 32,
              "description": "Provides information about the IMPLEMENTATION DEFINED features of the PE"
            },
            "ID_MMFR0": {
              "offset": "0xED50",
              "size": 32,
              "description": "Provides information about the implemented memory model and memory management support"
            },
            "ID_MMFR1": {
              "offset": "0xED54",
              "size": 32,
              "description": "Provides information about the implemented memory model and memory management support"
            },
            "ID_MMFR2": {
              "offset": "0xED58",
              "size": 32,
              "description": "Provides information about the implemented memory model and memory management support"
            },
            "ID_MMFR3": {
              "offset": "0xED5C",
              "size": 32,
              "description": "Provides information about the implemented memory model and memory management support"
            },
            "ID_ISAR0": {
              "offset": "0xED60",
              "size": 32,
              "description": "Provides information about the instruction set implemented by the PE"
            },
            "ID_ISAR1": {
              "offset": "0xED64",
              "size": 32,
              "description": "Provides information about the instruction set implemented by the PE"
            },
            "ID_ISAR2": {
              "offset": "0xED68",
              "size": 32,
              "description": "Provides information about the instruction set implemented by the PE"
            },
            "ID_ISAR3": {
              "offset": "0xED6C",
              "size": 32,
              "description": "Provides information about the instruction set implemented by the PE"
            },
            "ID_ISAR4": {
              "offset": "0xED70",
              "size": 32,
              "description": "Provides information about the instruction set implemented by the PE"
            },
            "ID_ISAR5": {
              "offset": "0xED74",
              "size": 32,
              "description": "Provides information about the instruction set implemented by the PE"
            },
            "CTR": {
              "offset": "0xED7C",
              "size": 32,
              "description": "Provides information about the architecture of the caches. CTR is RES0 if CLIDR is zero."
            },
            "CPACR": {
              "offset": "0xED88",
              "size": 32,
              "description": "Specifies the access privileges for coprocessors and the FP Extension"
            },
            "NSACR": {
              "offset": "0xED8C",
              "size": 32,
              "description": "Defines the Non-secure access permissions for both the FP Extension and coprocessors CP0 to CP7"
            },
            "MPU_TYPE": {
              "offset": "0xED90",
              "size": 32,
              "description": "The MPU Type Register indicates how many regions the MPU `FTSSS supports"
            },
            "MPU_CTRL": {
              "offset": "0xED94",
              "size": 32,
              "description": "Enables the MPU and, when the MPU is enabled, controls whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1"
            },
            "MPU_RNR": {
              "offset": "0xED98",
              "size": 32,
              "description": "Selects the region currently accessed by MPU_RBAR and MPU_RLAR"
            },
            "MPU_RBAR": {
              "offset": "0xED9C",
              "size": 32,
              "description": "Provides indirect read and write access to the base address of the currently selected MPU region `FTSSS"
            },
            "MPU_RLAR": {
              "offset": "0xEDA0",
              "size": 32,
              "description": "Provides indirect read and write access to the limit address of the currently selected MPU region `FTSSS"
            },
            "MPU_RBAR_A1": {
              "offset": "0xEDA4",
              "size": 32,
              "description": "Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS"
            },
            "MPU_RLAR_A1": {
              "offset": "0xEDA8",
              "size": 32,
              "description": "Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS"
            },
            "MPU_RBAR_A2": {
              "offset": "0xEDAC",
              "size": 32,
              "description": "Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS"
            },
            "MPU_RLAR_A2": {
              "offset": "0xEDB0",
              "size": 32,
              "description": "Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS"
            },
            "MPU_RBAR_A3": {
              "offset": "0xEDB4",
              "size": 32,
              "description": "Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS"
            },
            "MPU_RLAR_A3": {
              "offset": "0xEDB8",
              "size": 32,
              "description": "Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS"
            },
            "MPU_MAIR0": {
              "offset": "0xEDC0",
              "size": 32,
              "description": "Along with MPU_MAIR1, provides the memory attribute encodings corresponding to the AttrIndex values"
            },
            "MPU_MAIR1": {
              "offset": "0xEDC4",
              "size": 32,
              "description": "Along with MPU_MAIR0, provides the memory attribute encodings corresponding to the AttrIndex values"
            },
            "SAU_CTRL": {
              "offset": "0xEDD0",
              "size": 32,
              "description": "Allows enabling of the Security Attribution Unit"
            },
            "SAU_TYPE": {
              "offset": "0xEDD4",
              "size": 32,
              "description": "Indicates the number of regions implemented by the Security Attribution Unit"
            },
            "SAU_RNR": {
              "offset": "0xEDD8",
              "size": 32,
              "description": "Selects the region currently accessed by SAU_RBAR and SAU_RLAR"
            },
            "SAU_RBAR": {
              "offset": "0xEDDC",
              "size": 32,
              "description": "Provides indirect read and write access to the base address of the currently selected SAU region"
            },
            "SAU_RLAR": {
              "offset": "0xEDE0",
              "size": 32,
              "description": "Provides indirect read and write access to the limit address of the currently selected SAU region"
            },
            "SFSR": {
              "offset": "0xEDE4",
              "size": 32,
              "description": "Provides information about any security related faults"
            },
            "SFAR": {
              "offset": "0xEDE8",
              "size": 32,
              "description": "Shows the address of the memory location that caused a Security violation"
            },
            "DHCSR": {
              "offset": "0xEDF0",
              "size": 32,
              "description": "Controls halting debug"
            },
            "DCRSR": {
              "offset": "0xEDF4",
              "size": 32,
              "description": "With the DCRDR, provides debug access to the general-purpose registers, special-purpose registers, and the FP extension registers. A write to the DCRSR specifies the register to transfer, whether the transfer is a read or write, and starts the transfer"
            },
            "DCRDR": {
              "offset": "0xEDF8",
              "size": 32,
              "description": "With the DCRSR, provides debug access to the general-purpose registers, special-purpose registers, and the FP Extension registers. If the Main Extension is implemented, it can also be used for message passing between an external debugger and a debug agent running on the PE"
            },
            "DEMCR": {
              "offset": "0xEDFC",
              "size": 32,
              "description": "Manages vector catch behavior and DebugMonitor handling when debugging"
            },
            "DSCSR": {
              "offset": "0xEE08",
              "size": 32,
              "description": "Provides control and status information for Secure debug"
            },
            "STIR": {
              "offset": "0xEF00",
              "size": 32,
              "description": "Provides a mechanism for software to generate an interrupt"
            },
            "FPCCR": {
              "offset": "0xEF34",
              "size": 32,
              "description": "Holds control data for the Floating-point extension"
            },
            "FPCAR": {
              "offset": "0xEF38",
              "size": 32,
              "description": "Holds the location of the unpopulated floating-point register space allocated on an exception stack frame"
            },
            "FPDSCR": {
              "offset": "0xEF3C",
              "size": 32,
              "description": "Holds the default values for the floating-point status control data that the PE assigns to the FPSCR when it creates a new floating-point context"
            },
            "MVFR0": {
              "offset": "0xEF40",
              "size": 32,
              "description": "Describes the features provided by the Floating-point Extension"
            },
            "MVFR1": {
              "offset": "0xEF44",
              "size": 32,
              "description": "Describes the features provided by the Floating-point Extension"
            },
            "MVFR2": {
              "offset": "0xEF48",
              "size": 32,
              "description": "Describes the features provided by the Floating-point Extension"
            },
            "DDEVARCH": {
              "offset": "0xEFBC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DDEVTYPE": {
              "offset": "0xEFCC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DPIDR4": {
              "offset": "0xEFD0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DPIDR5": {
              "offset": "0xEFD4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DPIDR6": {
              "offset": "0xEFD8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DPIDR7": {
              "offset": "0xEFDC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DPIDR0": {
              "offset": "0xEFE0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DPIDR1": {
              "offset": "0xEFE4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DPIDR2": {
              "offset": "0xEFE8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DPIDR3": {
              "offset": "0xEFEC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DCIDR0": {
              "offset": "0xEFF0",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DCIDR1": {
              "offset": "0xEFF4",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DCIDR2": {
              "offset": "0xEFF8",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "DCIDR3": {
              "offset": "0xEFFC",
              "size": 32,
              "description": "Provides CoreSight discovery information for the SCS"
            },
            "TRCPRGCTLR": {
              "offset": "0x41004",
              "size": 32,
              "description": "Programming Control Register"
            },
            "TRCSTATR": {
              "offset": "0x4100C",
              "size": 32,
              "description": "The TRCSTATR indicates the ETM-Teal status"
            },
            "TRCCONFIGR": {
              "offset": "0x41010",
              "size": 32,
              "description": "The TRCCONFIGR sets the basic tracing options for the trace unit"
            },
            "TRCEVENTCTL0R": {
              "offset": "0x41020",
              "size": 32,
              "description": "The TRCEVENTCTL0R controls the tracing of events in the trace stream. The events also drive the ETM-Teal external outputs."
            },
            "TRCEVENTCTL1R": {
              "offset": "0x41024",
              "size": 32,
              "description": "The TRCEVENTCTL1R controls how the events selected by TRCEVENTCTL0R behave"
            },
            "TRCSTALLCTLR": {
              "offset": "0x4102C",
              "size": 32,
              "description": "The TRCSTALLCTLR enables ETM-Teal to stall the processor if the ETM-Teal FIFO goes over the programmed level to minimize risk of overflow"
            },
            "TRCTSCTLR": {
              "offset": "0x41030",
              "size": 32,
              "description": "The TRCTSCTLR controls the insertion of global timestamps into the trace stream. A timestamp is always inserted into the instruction trace stream"
            },
            "TRCSYNCPR": {
              "offset": "0x41034",
              "size": 32,
              "description": "The TRCSYNCPR specifies the period of trace synchronization of the trace streams. TRCSYNCPR defines a number of bytes of trace between requests for trace synchronization. This value is always a power of two"
            },
            "TRCCCCTLR": {
              "offset": "0x41038",
              "size": 32,
              "description": "The TRCCCCTLR sets the threshold value for instruction trace cycle counting. The threshold represents the minimum interval between cycle count trace packets"
            },
            "TRCVICTLR": {
              "offset": "0x41080",
              "size": 32,
              "description": "The TRCVICTLR controls instruction trace filtering"
            },
            "TRCCNTRLDVR0": {
              "offset": "0x41140",
              "size": 32,
              "description": "The TRCCNTRLDVR defines the reload value for the reduced function counter"
            },
            "TRCIDR8": {
              "offset": "0x41180",
              "size": 32,
              "description": "TRCIDR8"
            },
            "TRCIDR9": {
              "offset": "0x41184",
              "size": 32,
              "description": "TRCIDR9"
            },
            "TRCIDR10": {
              "offset": "0x41188",
              "size": 32,
              "description": "TRCIDR10"
            },
            "TRCIDR11": {
              "offset": "0x4118C",
              "size": 32,
              "description": "TRCIDR11"
            },
            "TRCIDR12": {
              "offset": "0x41190",
              "size": 32,
              "description": "TRCIDR12"
            },
            "TRCIDR13": {
              "offset": "0x41194",
              "size": 32,
              "description": "TRCIDR13"
            },
            "TRCIMSPEC": {
              "offset": "0x411C0",
              "size": 32,
              "description": "The TRCIMSPEC shows the presence of any IMPLEMENTATION SPECIFIC features, and enables any features that are provided"
            },
            "TRCIDR0": {
              "offset": "0x411E0",
              "size": 32,
              "description": "TRCIDR0"
            },
            "TRCIDR1": {
              "offset": "0x411E4",
              "size": 32,
              "description": "TRCIDR1"
            },
            "TRCIDR2": {
              "offset": "0x411E8",
              "size": 32,
              "description": "TRCIDR2"
            },
            "TRCIDR3": {
              "offset": "0x411EC",
              "size": 32,
              "description": "TRCIDR3"
            },
            "TRCIDR4": {
              "offset": "0x411F0",
              "size": 32,
              "description": "TRCIDR4"
            },
            "TRCIDR5": {
              "offset": "0x411F4",
              "size": 32,
              "description": "TRCIDR5"
            },
            "TRCIDR6": {
              "offset": "0x411F8",
              "size": 32,
              "description": "TRCIDR6"
            },
            "TRCIDR7": {
              "offset": "0x411FC",
              "size": 32,
              "description": "TRCIDR7"
            },
            "TRCRSCTLR2": {
              "offset": "0x41208",
              "size": 32,
              "description": "The TRCRSCTLR controls the trace resources"
            },
            "TRCRSCTLR3": {
              "offset": "0x4120C",
              "size": 32,
              "description": "The TRCRSCTLR controls the trace resources"
            },
            "TRCSSCSR": {
              "offset": "0x412A0",
              "size": 32,
              "description": "Controls the corresponding single-shot comparator resource"
            },
            "TRCSSPCICR": {
              "offset": "0x412C0",
              "size": 32,
              "description": "Selects the PE comparator inputs for Single-shot control"
            },
            "TRCPDCR": {
              "offset": "0x41310",
              "size": 32,
              "description": "Requests the system to provide power to the trace unit"
            },
            "TRCPDSR": {
              "offset": "0x41314",
              "size": 32,
              "description": "Returns the following information about the trace unit: - OS Lock status.  - Core power domain status.  - Power interruption status"
            },
            "TRCITATBIDR": {
              "offset": "0x41EE4",
              "size": 32,
              "description": "Trace Integration ATB Identification Register"
            },
            "TRCITIATBINR": {
              "offset": "0x41EF4",
              "size": 32,
              "description": "Trace Integration Instruction ATB In Register"
            },
            "TRCITIATBOUTR": {
              "offset": "0x41EFC",
              "size": 32,
              "description": "Trace Integration Instruction ATB Out Register"
            },
            "TRCCLAIMSET": {
              "offset": "0x41FA0",
              "size": 32,
              "description": "Claim Tag Set Register"
            },
            "TRCCLAIMCLR": {
              "offset": "0x41FA4",
              "size": 32,
              "description": "Claim Tag Clear Register"
            },
            "TRCAUTHSTATUS": {
              "offset": "0x41FB8",
              "size": 32,
              "description": "Returns the level of tracing that the trace unit can support"
            },
            "TRCDEVARCH": {
              "offset": "0x41FBC",
              "size": 32,
              "description": "TRCDEVARCH"
            },
            "TRCDEVID": {
              "offset": "0x41FC8",
              "size": 32,
              "description": "TRCDEVID"
            },
            "TRCDEVTYPE": {
              "offset": "0x41FCC",
              "size": 32,
              "description": "TRCDEVTYPE"
            },
            "TRCPIDR4": {
              "offset": "0x41FD0",
              "size": 32,
              "description": "TRCPIDR4"
            },
            "TRCPIDR5": {
              "offset": "0x41FD4",
              "size": 32,
              "description": "TRCPIDR5"
            },
            "TRCPIDR6": {
              "offset": "0x41FD8",
              "size": 32,
              "description": "TRCPIDR6"
            },
            "TRCPIDR7": {
              "offset": "0x41FDC",
              "size": 32,
              "description": "TRCPIDR7"
            },
            "TRCPIDR0": {
              "offset": "0x41FE0",
              "size": 32,
              "description": "TRCPIDR0"
            },
            "TRCPIDR1": {
              "offset": "0x41FE4",
              "size": 32,
              "description": "TRCPIDR1"
            },
            "TRCPIDR2": {
              "offset": "0x41FE8",
              "size": 32,
              "description": "TRCPIDR2"
            },
            "TRCPIDR3": {
              "offset": "0x41FEC",
              "size": 32,
              "description": "TRCPIDR3"
            },
            "TRCCIDR0": {
              "offset": "0x41FF0",
              "size": 32,
              "description": "TRCCIDR0"
            },
            "TRCCIDR1": {
              "offset": "0x41FF4",
              "size": 32,
              "description": "TRCCIDR1"
            },
            "TRCCIDR2": {
              "offset": "0x41FF8",
              "size": 32,
              "description": "TRCCIDR2"
            },
            "TRCCIDR3": {
              "offset": "0x41FFC",
              "size": 32,
              "description": "TRCCIDR3"
            },
            "CTICONTROL": {
              "offset": "0x42000",
              "size": 32,
              "description": "CTI Control Register"
            },
            "CTIINTACK": {
              "offset": "0x42010",
              "size": 32,
              "description": "CTI Interrupt Acknowledge Register"
            },
            "CTIAPPSET": {
              "offset": "0x42014",
              "size": 32,
              "description": "CTI Application Trigger Set Register"
            },
            "CTIAPPCLEAR": {
              "offset": "0x42018",
              "size": 32,
              "description": "CTI Application Trigger Clear Register"
            },
            "CTIAPPPULSE": {
              "offset": "0x4201C",
              "size": 32,
              "description": "CTI Application Pulse Register"
            },
            "CTIINEN0": {
              "offset": "0x42020",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIINEN1": {
              "offset": "0x42024",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIINEN2": {
              "offset": "0x42028",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIINEN3": {
              "offset": "0x4202C",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIINEN4": {
              "offset": "0x42030",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIINEN5": {
              "offset": "0x42034",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIINEN6": {
              "offset": "0x42038",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIINEN7": {
              "offset": "0x4203C",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIOUTEN0": {
              "offset": "0x420A0",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIOUTEN1": {
              "offset": "0x420A4",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIOUTEN2": {
              "offset": "0x420A8",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIOUTEN3": {
              "offset": "0x420AC",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIOUTEN4": {
              "offset": "0x420B0",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIOUTEN5": {
              "offset": "0x420B4",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIOUTEN6": {
              "offset": "0x420B8",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTIOUTEN7": {
              "offset": "0x420BC",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTITRIGINSTATUS": {
              "offset": "0x42130",
              "size": 32,
              "description": "CTI Trigger to Channel Enable Registers"
            },
            "CTITRIGOUTSTATUS": {
              "offset": "0x42134",
              "size": 32,
              "description": "CTI Trigger In Status Register"
            },
            "CTICHINSTATUS": {
              "offset": "0x42138",
              "size": 32,
              "description": "CTI Channel In Status Register"
            },
            "CTIGATE": {
              "offset": "0x42140",
              "size": 32,
              "description": "Enable CTI Channel Gate register"
            },
            "ASICCTL": {
              "offset": "0x42144",
              "size": 32,
              "description": "External Multiplexer Control register"
            },
            "ITCHOUT": {
              "offset": "0x42EE4",
              "size": 32,
              "description": "Integration Test Channel Output register"
            },
            "ITTRIGOUT": {
              "offset": "0x42EE8",
              "size": 32,
              "description": "Integration Test Trigger Output register"
            },
            "ITCHIN": {
              "offset": "0x42EF4",
              "size": 32,
              "description": "Integration Test Channel Input register"
            },
            "ITCTRL": {
              "offset": "0x42F00",
              "size": 32,
              "description": "Integration Mode Control register"
            },
            "DEVARCH": {
              "offset": "0x42FBC",
              "size": 32,
              "description": "Device Architecture register"
            },
            "DEVID": {
              "offset": "0x42FC8",
              "size": 32,
              "description": "Device Configuration register"
            },
            "DEVTYPE": {
              "offset": "0x42FCC",
              "size": 32,
              "description": "Device Type Identifier register"
            },
            "PIDR4": {
              "offset": "0x42FD0",
              "size": 32,
              "description": "CoreSight Peripheral ID4"
            },
            "PIDR5": {
              "offset": "0x42FD4",
              "size": 32,
              "description": "CoreSight Peripheral ID5"
            },
            "PIDR6": {
              "offset": "0x42FD8",
              "size": 32,
              "description": "CoreSight Peripheral ID6"
            },
            "PIDR7": {
              "offset": "0x42FDC",
              "size": 32,
              "description": "CoreSight Peripheral ID7"
            },
            "PIDR0": {
              "offset": "0x42FE0",
              "size": 32,
              "description": "CoreSight Peripheral ID0"
            },
            "PIDR1": {
              "offset": "0x42FE4",
              "size": 32,
              "description": "CoreSight Peripheral ID1"
            },
            "PIDR2": {
              "offset": "0x42FE8",
              "size": 32,
              "description": "CoreSight Peripheral ID2"
            },
            "PIDR3": {
              "offset": "0x42FEC",
              "size": 32,
              "description": "CoreSight Peripheral ID3"
            },
            "CIDR0": {
              "offset": "0x42FF0",
              "size": 32,
              "description": "CoreSight Component ID0"
            },
            "CIDR1": {
              "offset": "0x42FF4",
              "size": 32,
              "description": "CoreSight Component ID1"
            },
            "CIDR2": {
              "offset": "0x42FF8",
              "size": 32,
              "description": "CoreSight Component ID2"
            },
            "CIDR3": {
              "offset": "0x42FFC",
              "size": 32,
              "description": "CoreSight Component ID3"
            }
          }
        },
        "QMI": {
          "instances": [
            {
              "name": "QMI",
              "base": "0x400D0000"
            }
          ],
          "registers": {
            "DIRECT_CSR": {
              "offset": "0x00",
              "size": 32,
              "description": "Control and status for direct serial mode\n\n                    Direct serial mode allows the processor to send and receive raw serial frames, for programming, configuration and control of the external memory devices. Only SPI mode 0 (CPOL=0 CPHA=0) is supported."
            },
            "DIRECT_TX": {
              "offset": "0x04",
              "size": 32,
              "description": "Transmit FIFO for direct mode"
            },
            "DIRECT_RX": {
              "offset": "0x08",
              "size": 32,
              "description": "Receive FIFO for direct mode"
            },
            "M0_TIMING": {
              "offset": "0x0C",
              "size": 32,
              "description": "Timing configuration register for memory address window 0."
            },
            "M0_RFMT": {
              "offset": "0x10",
              "size": 32,
              "description": "Read transfer format configuration for memory address window 0.\n\n                    Configure the bus width of each transfer phase individually, and configure the length or presence of the command prefix, command suffix and dummy/turnaround transfer phases. Only 24-bit addresses are supported.\n\n                    The reset value of the M0_RFMT register is configured to support a basic 03h serial read transfer with no additional configuration."
            },
            "M0_RCMD": {
              "offset": "0x14",
              "size": 32,
              "description": "Command constants used for reads from memory address window 0.\n\n                    The reset value of the M0_RCMD register is configured to support a basic 03h serial read transfer with no additional configuration."
            },
            "M0_WFMT": {
              "offset": "0x18",
              "size": 32,
              "description": "Write transfer format configuration for memory address window 0.\n\n                    Configure the bus width of each transfer phase individually, and configure the length or presence of the command prefix, command suffix and dummy/turnaround transfer phases. Only 24-bit addresses are supported.\n\n                    The reset value of the M0_WFMT register is configured to support a basic 02h serial write transfer. However, writes to this window must first be enabled via the XIP_CTRL_WRITABLE_M0 bit, as XIP memory is read-only by default."
            },
            "M0_WCMD": {
              "offset": "0x1C",
              "size": 32,
              "description": "Command constants used for writes to memory address window 0.\n\n                    The reset value of the M0_WCMD register is configured to support a basic 02h serial write transfer with no additional configuration."
            },
            "M1_TIMING": {
              "offset": "0x20",
              "size": 32,
              "description": "Timing configuration register for memory address window 1."
            },
            "M1_RFMT": {
              "offset": "0x24",
              "size": 32,
              "description": "Read transfer format configuration for memory address window 1.\n\n                    Configure the bus width of each transfer phase individually, and configure the length or presence of the command prefix, command suffix and dummy/turnaround transfer phases. Only 24-bit addresses are supported.\n\n                    The reset value of the M1_RFMT register is configured to support a basic 03h serial read transfer with no additional configuration."
            },
            "M1_RCMD": {
              "offset": "0x28",
              "size": 32,
              "description": "Command constants used for reads from memory address window 1.\n\n                    The reset value of the M1_RCMD register is configured to support a basic 03h serial read transfer with no additional configuration."
            },
            "M1_WFMT": {
              "offset": "0x2C",
              "size": 32,
              "description": "Write transfer format configuration for memory address window 1.\n\n                    Configure the bus width of each transfer phase individually, and configure the length or presence of the command prefix, command suffix and dummy/turnaround transfer phases. Only 24-bit addresses are supported.\n\n                    The reset value of the M1_WFMT register is configured to support a basic 02h serial write transfer. However, writes to this window must first be enabled via the XIP_CTRL_WRITABLE_M1 bit, as XIP memory is read-only by default."
            },
            "M1_WCMD": {
              "offset": "0x30",
              "size": 32,
              "description": "Command constants used for writes to memory address window 1.\n\n                    The reset value of the M1_WCMD register is configured to support a basic 02h serial write transfer with no additional configuration."
            },
            "ATRANS0": {
              "offset": "0x34",
              "size": 32,
              "description": "Configure address translation for XIP virtual addresses 0x000000 through 0x3fffff (a 4 MiB window starting at +0 MiB).\n\n                    Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.\n\n                    At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.\n\n                    Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation."
            },
            "ATRANS1": {
              "offset": "0x38",
              "size": 32,
              "description": "Configure address translation for XIP virtual addresses 0x400000 through 0x7fffff (a 4 MiB window starting at +4 MiB).\n\n                    Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.\n\n                    At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.\n\n                    Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation."
            },
            "ATRANS2": {
              "offset": "0x3C",
              "size": 32,
              "description": "Configure address translation for XIP virtual addresses 0x800000 through 0xbfffff (a 4 MiB window starting at +8 MiB).\n\n                    Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.\n\n                    At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.\n\n                    Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation."
            },
            "ATRANS3": {
              "offset": "0x40",
              "size": 32,
              "description": "Configure address translation for XIP virtual addresses 0xc00000 through 0xffffff (a 4 MiB window starting at +12 MiB).\n\n                    Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.\n\n                    At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.\n\n                    Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation."
            },
            "ATRANS4": {
              "offset": "0x44",
              "size": 32,
              "description": "Configure address translation for XIP virtual addresses 0x1000000 through 0x13fffff (a 4 MiB window starting at +16 MiB).\n\n                    Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.\n\n                    At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.\n\n                    Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation."
            },
            "ATRANS5": {
              "offset": "0x48",
              "size": 32,
              "description": "Configure address translation for XIP virtual addresses 0x1400000 through 0x17fffff (a 4 MiB window starting at +20 MiB).\n\n                    Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.\n\n                    At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.\n\n                    Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation."
            },
            "ATRANS6": {
              "offset": "0x4C",
              "size": 32,
              "description": "Configure address translation for XIP virtual addresses 0x1800000 through 0x1bfffff (a 4 MiB window starting at +24 MiB).\n\n                    Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.\n\n                    At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.\n\n                    Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation."
            },
            "ATRANS7": {
              "offset": "0x50",
              "size": 32,
              "description": "Configure address translation for XIP virtual addresses 0x1c00000 through 0x1ffffff (a 4 MiB window starting at +28 MiB).\n\n                    Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code.\n\n                    At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required.\n\n                    Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation."
            }
          }
        },
        "XIP": {
          "instances": [
            {
              "name": "XIP_CTRL",
              "base": "0x400C8000"
            },
            {
              "name": "XIP_AUX",
              "base": "0x50500000"
            }
          ],
          "registers": {
            "CTRL": {
              "offset": "0x00",
              "size": 32,
              "description": "Cache control register. Read-only from a Non-secure context."
            },
            "STAT": {
              "offset": "0x08",
              "size": 32,
              "description": "When 1, indicates the XIP streaming FIFO is completely full. \n                            The streaming FIFO is 2 entries deep, so the full and empty \n                            flag allow its level to be ascertained."
            },
            "CTR_HIT": {
              "offset": "0x0C",
              "size": 32,
              "description": "Cache Hit counter"
            },
            "CTR_ACC": {
              "offset": "0x10",
              "size": 32,
              "description": "Cache Access counter"
            },
            "STREAM_ADDR": {
              "offset": "0x14",
              "size": 32,
              "description": "FIFO stream address"
            },
            "STREAM_CTR": {
              "offset": "0x18",
              "size": 32,
              "description": "FIFO stream control"
            },
            "STREAM_FIFO": {
              "offset": "0x1C",
              "size": 32,
              "description": "FIFO stream data"
            }
          }
        },
        "SYSCFG": {
          "instances": [
            {
              "name": "SYSCFG",
              "base": "0x40008000"
            }
          ],
          "registers": {
            "PROC_CONFIG": {
              "offset": "0x00",
              "size": 32,
              "description": "Configuration for processors"
            },
            "PROC_IN_SYNC_BYPASS": {
              "offset": "0x04",
              "size": 32,
              "description": "For each bit, if 1, bypass the input synchronizer between that GPIO \n                    and the GPIO input register in the SIO. The input synchronizers should \n                    generally be unbypassed, to avoid injecting metastabilities into processors. \n                    If you're feeling brave, you can bypass to save two cycles of input \n                    latency. This register applies to GPIO 0...31."
            },
            "PROC_IN_SYNC_BYPASS_HI": {
              "offset": "0x08",
              "size": 32,
              "description": "For each bit, if 1, bypass the input synchronizer between that GPIO \n                    and the GPIO input register in the SIO. The input synchronizers should \n                    generally be unbypassed, to avoid injecting metastabilities into processors. \n                    If you're feeling brave, you can bypass to save two cycles of input \n                    latency. This register applies to GPIO 32...47. USB GPIO 56..57 QSPI GPIO 58..63"
            },
            "DBGFORCE": {
              "offset": "0x0C",
              "size": 32,
              "description": "Directly control the chip SWD debug port"
            },
            "MEMPOWERDOWN": {
              "offset": "0x10",
              "size": 32,
              "description": "Control PD pins to memories. \n                    Set high to put memories to a low power state. In this state the memories will retain contents but not be accessible \n                    Use with caution"
            },
            "AUXCTRL": {
              "offset": "0x14",
              "size": 32,
              "description": "Auxiliary system control register"
            }
          }
        },
        "XOSC": {
          "instances": [
            {
              "name": "XOSC",
              "base": "0x40048000"
            }
          ],
          "registers": {
            "CTRL": {
              "offset": "0x00",
              "size": 32,
              "description": "Crystal Oscillator Control"
            },
            "STATUS": {
              "offset": "0x04",
              "size": 32,
              "description": "Crystal Oscillator Status"
            },
            "DORMANT": {
              "offset": "0x08",
              "size": 32,
              "description": "Crystal Oscillator pause control"
            },
            "STARTUP": {
              "offset": "0x0C",
              "size": 32,
              "description": "Controls the startup delay"
            },
            "COUNT": {
              "offset": "0x10",
              "size": 32,
              "description": "A down counter running at the xosc frequency which counts to zero and stops. \n                    Can be used for short software pauses when setting up time sensitive hardware. \n                    To start the counter, write a non-zero value. Reads will return 1 while the count is running and 0 when it has finished. \n                    Minimum count value is 4. Count values <4 will be treated as count value =4. \n                    Note that synchronisation to the register clock domain costs 2 register clock cycles and the counter cannot compensate for that."
            }
          }
        },
        "PLL": {
          "instances": [
            {
              "name": "PLL_SYS",
              "base": "0x40050000",
              "irq": 42
            }
          ],
          "registers": {
            "CS": {
              "offset": "0x00",
              "size": 32,
              "description": "Control and Status \n                    GENERAL CONSTRAINTS: \n                    Reference clock frequency min=5MHz, max=800MHz \n                    Feedback divider min=16, max=320 \n                    VCO frequency min=750MHz, max=1600MHz"
            },
            "PWR": {
              "offset": "0x04",
              "size": 32,
              "description": "Controls the PLL power modes."
            },
            "FBDIV_INT": {
              "offset": "0x08",
              "size": 32,
              "description": "Feedback divisor \n                    (note: this PLL does not support fractional division)"
            },
            "PRIM": {
              "offset": "0x0C",
              "size": 32,
              "description": "Controls the PLL post dividers for the primary output \n                    (note: this PLL does not have a secondary output) \n                    the primary output is driven from VCO divided by postdiv1*postdiv2"
            },
            "INTR": {
              "offset": "0x10",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTE": {
              "offset": "0x14",
              "size": 32,
              "description": "Interrupt Enable"
            },
            "INTF": {
              "offset": "0x18",
              "size": 32,
              "description": "Interrupt Force"
            },
            "INTS": {
              "offset": "0x1C",
              "size": 32,
              "description": "Interrupt status after masking & forcing"
            }
          }
        },
        "USB": {
          "instances": [
            {
              "name": "PLL_USB",
              "base": "0x40058000",
              "irq": 43
            },
            {
              "name": "USB",
              "base": "0x50110000",
              "irq": 14
            },
            {
              "name": "USB_DPRAM",
              "base": "0x50100000"
            }
          ],
          "registers": {
            "ADDR_ENDP": {
              "offset": "0x00",
              "size": 32,
              "description": "Device address and endpoint control"
            },
            "ADDR_ENDP1": {
              "offset": "0x04",
              "size": 32,
              "description": "Interrupt endpoint 1. Only valid for HOST mode."
            },
            "ADDR_ENDP2": {
              "offset": "0x08",
              "size": 32,
              "description": "Interrupt endpoint 2. Only valid for HOST mode."
            },
            "ADDR_ENDP3": {
              "offset": "0x0C",
              "size": 32,
              "description": "Interrupt endpoint 3. Only valid for HOST mode."
            },
            "ADDR_ENDP4": {
              "offset": "0x10",
              "size": 32,
              "description": "Interrupt endpoint 4. Only valid for HOST mode."
            },
            "ADDR_ENDP5": {
              "offset": "0x14",
              "size": 32,
              "description": "Interrupt endpoint 5. Only valid for HOST mode."
            },
            "ADDR_ENDP6": {
              "offset": "0x18",
              "size": 32,
              "description": "Interrupt endpoint 6. Only valid for HOST mode."
            },
            "ADDR_ENDP7": {
              "offset": "0x1C",
              "size": 32,
              "description": "Interrupt endpoint 7. Only valid for HOST mode."
            },
            "ADDR_ENDP8": {
              "offset": "0x20",
              "size": 32,
              "description": "Interrupt endpoint 8. Only valid for HOST mode."
            },
            "ADDR_ENDP9": {
              "offset": "0x24",
              "size": 32,
              "description": "Interrupt endpoint 9. Only valid for HOST mode."
            },
            "ADDR_ENDP10": {
              "offset": "0x28",
              "size": 32,
              "description": "Interrupt endpoint 10. Only valid for HOST mode."
            },
            "ADDR_ENDP11": {
              "offset": "0x2C",
              "size": 32,
              "description": "Interrupt endpoint 11. Only valid for HOST mode."
            },
            "ADDR_ENDP12": {
              "offset": "0x30",
              "size": 32,
              "description": "Interrupt endpoint 12. Only valid for HOST mode."
            },
            "ADDR_ENDP13": {
              "offset": "0x34",
              "size": 32,
              "description": "Interrupt endpoint 13. Only valid for HOST mode."
            },
            "ADDR_ENDP14": {
              "offset": "0x38",
              "size": 32,
              "description": "Interrupt endpoint 14. Only valid for HOST mode."
            },
            "ADDR_ENDP15": {
              "offset": "0x3C",
              "size": 32,
              "description": "Interrupt endpoint 15. Only valid for HOST mode."
            },
            "MAIN_CTRL": {
              "offset": "0x40",
              "size": 32,
              "description": "Main control register"
            },
            "SOF_WR": {
              "offset": "0x44",
              "size": 32,
              "description": "Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time."
            },
            "SOF_RD": {
              "offset": "0x48",
              "size": 32,
              "description": "Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host."
            },
            "SIE_CTRL": {
              "offset": "0x4C",
              "size": 32,
              "description": "SIE control register"
            },
            "SIE_STATUS": {
              "offset": "0x50",
              "size": 32,
              "description": "SIE status register"
            },
            "INT_EP_CTRL": {
              "offset": "0x54",
              "size": 32,
              "description": "interrupt endpoint control register"
            },
            "BUFF_STATUS": {
              "offset": "0x58",
              "size": 32,
              "description": "Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle."
            },
            "BUFF_CPU_SHOULD_HANDLE": {
              "offset": "0x5C",
              "size": 32,
              "description": "Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered."
            },
            "EP_ABORT": {
              "offset": "0x60",
              "size": 32,
              "description": "Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register."
            },
            "EP_ABORT_DONE": {
              "offset": "0x64",
              "size": 32,
              "description": "Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register."
            },
            "EP_STALL_ARM": {
              "offset": "0x68",
              "size": 32,
              "description": "Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received."
            },
            "NAK_POLL": {
              "offset": "0x6C",
              "size": 32,
              "description": "Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK."
            },
            "EP_STATUS_STALL_NAK": {
              "offset": "0x70",
              "size": 32,
              "description": "Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register."
            },
            "USB_MUXING": {
              "offset": "0x74",
              "size": 32,
              "description": "Where to connect the USB controller. Should be to_phy by default."
            },
            "USB_PWR": {
              "offset": "0x78",
              "size": 32,
              "description": "Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value."
            },
            "USBPHY_DIRECT": {
              "offset": "0x7C",
              "size": 32,
              "description": "This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit."
            },
            "USBPHY_DIRECT_OVERRIDE": {
              "offset": "0x80",
              "size": 32,
              "description": "Override enable for each control in usbphy_direct"
            },
            "USBPHY_TRIM": {
              "offset": "0x84",
              "size": 32,
              "description": "Used to adjust trim values of USB phy pull down resistors."
            },
            "LINESTATE_TUNING": {
              "offset": "0x88",
              "size": 32,
              "description": "Used for debug only."
            },
            "INTR": {
              "offset": "0x8C",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTE": {
              "offset": "0x90",
              "size": 32,
              "description": "Interrupt Enable"
            },
            "INTF": {
              "offset": "0x94",
              "size": 32,
              "description": "Interrupt Force"
            },
            "INTS": {
              "offset": "0x98",
              "size": 32,
              "description": "Interrupt status after masking & forcing"
            },
            "SOF_TIMESTAMP_RAW": {
              "offset": "0x100",
              "size": 32,
              "description": "Device only. Raw value of free-running PHY clock counter @48MHz. Used to calculate time between SOF events."
            },
            "SOF_TIMESTAMP_LAST": {
              "offset": "0x104",
              "size": 32,
              "description": "Device only. Value of free-running PHY clock counter @48MHz when last SOF event occurred."
            },
            "SM_STATE": {
              "offset": "0x108",
              "size": 32
            },
            "EP_TX_ERROR": {
              "offset": "0x10C",
              "size": 32,
              "description": "TX error count for each endpoint. Write to each field to reset the counter to 0."
            },
            "EP_RX_ERROR": {
              "offset": "0x110",
              "size": 32,
              "description": "RX error count for each endpoint. Write to each field to reset the counter to 0."
            },
            "DEV_SM_WATCHDOG": {
              "offset": "0x114",
              "size": 32,
              "description": "Watchdog that forces the device state machine to idle and raises an interrupt if the device stays in a state that isn't idle for the configured limit. The counter is reset on every state transition. \n                    Set limit while enable is low and then set the enable."
            }
          }
        },
        "ACCESSCTRL": {
          "instances": [
            {
              "name": "ACCESSCTRL",
              "base": "0x40060000"
            }
          ],
          "registers": {
            "LOCK": {
              "offset": "0x00",
              "size": 32,
              "description": "Once a LOCK bit is written to 1, ACCESSCTRL silently ignores writes from that master. LOCK is writable only by a Secure, Privileged processor or debugger.\n\n                    LOCK bits are only writable when their value is zero. Once set, they can never be cleared, except by a full reset of ACCESSCTRL\n\n                    Setting the LOCK bit does not affect whether an access raises a bus error. Unprivileged writes, or writes from the DMA, will continue to raise bus errors. All other accesses will continue not to."
            },
            "FORCE_CORE_NS": {
              "offset": "0x04",
              "size": 32,
              "description": "Force core 1's bus accesses to always be Non-secure, no matter the core's internal state.\n\n                    Useful for schemes where one core is designated as the Non-secure core, since some peripherals may filter individual registers internally based on security state but not on master ID."
            },
            "CFGRESET": {
              "offset": "0x08",
              "size": 32,
              "description": "Write 1 to reset all ACCESSCTRL configuration, except for the LOCK and FORCE_CORE_NS registers.\n\n                    This bit is used in the RP2350 bootrom to quickly restore ACCESSCTRL to a known state during the boot path.\n\n                    Note that, like all registers in ACCESSCTRL, this register is not writable when the writer's corresponding LOCK bit is set, therefore a master which has been locked out of ACCESSCTRL can not use the CFGRESET register to disturb its contents."
            },
            "GPIO_NSMASK0": {
              "offset": "0x0C",
              "size": 32,
              "description": "Control whether GPIO0...31 are accessible to Non-secure code. Writable only by a Secure, Privileged processor or debugger.\n\n                    0 -> Secure access only\n\n                    1 -> Secure + Non-secure access"
            },
            "GPIO_NSMASK1": {
              "offset": "0x10",
              "size": 32,
              "description": "Control whether GPIO32..47 are accessible to Non-secure code, and whether QSPI and USB bitbang are accessible through the Non-secure SIO. Writable only by a Secure, Privileged processor or debugger."
            },
            "ROM": {
              "offset": "0x14",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access ROM, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "XIP_MAIN": {
              "offset": "0x18",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access XIP_MAIN, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM0": {
              "offset": "0x1C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM0, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM1": {
              "offset": "0x20",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM1, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM2": {
              "offset": "0x24",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM2, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM3": {
              "offset": "0x28",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM3, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM4": {
              "offset": "0x2C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM4, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM5": {
              "offset": "0x30",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM5, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM6": {
              "offset": "0x34",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM6, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM7": {
              "offset": "0x38",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM7, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM8": {
              "offset": "0x3C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM8, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SRAM9": {
              "offset": "0x40",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SRAM9, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "DMA": {
              "offset": "0x44",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access DMA, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "USBCTRL": {
              "offset": "0x48",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access USBCTRL, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "PIO0": {
              "offset": "0x4C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access PIO0, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "PIO1": {
              "offset": "0x50",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access PIO1, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "PIO2": {
              "offset": "0x54",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access PIO2, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "CORESIGHT_TRACE": {
              "offset": "0x58",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access CORESIGHT_TRACE, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "CORESIGHT_PERIPH": {
              "offset": "0x5C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access CORESIGHT_PERIPH, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SYSINFO": {
              "offset": "0x60",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SYSINFO, and at what security/privilege levels they can do so.\n\n                    Defaults to fully open access.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "RESETS": {
              "offset": "0x64",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access RESETS, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "IO_BANK0": {
              "offset": "0x68",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access IO_BANK0, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "IO_BANK1": {
              "offset": "0x6C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access IO_BANK1, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "PADS_BANK0": {
              "offset": "0x70",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access PADS_BANK0, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "PADS_QSPI": {
              "offset": "0x74",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access PADS_QSPI, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "BUSCTRL": {
              "offset": "0x78",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access BUSCTRL, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "ADC0": {
              "offset": "0x7C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access ADC0, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "HSTX": {
              "offset": "0x80",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access HSTX, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "I2C0": {
              "offset": "0x84",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access I2C0, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "I2C1": {
              "offset": "0x88",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access I2C1, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "PWM": {
              "offset": "0x8C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access PWM, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SPI0": {
              "offset": "0x90",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SPI0, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SPI1": {
              "offset": "0x94",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SPI1, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "TIMER0": {
              "offset": "0x98",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access TIMER0, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "TIMER1": {
              "offset": "0x9C",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access TIMER1, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "UART0": {
              "offset": "0xA0",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access UART0, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "UART1": {
              "offset": "0xA4",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access UART1, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "OTP": {
              "offset": "0xA8",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access OTP, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "TBMAN": {
              "offset": "0xAC",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access TBMAN, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure access from any master.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "POWMAN": {
              "offset": "0xB0",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access POWMAN, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "TRNG": {
              "offset": "0xB4",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access TRNG, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SHA256": {
              "offset": "0xB8",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SHA256, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "SYSCFG": {
              "offset": "0xBC",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access SYSCFG, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "CLOCKS": {
              "offset": "0xC0",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access CLOCKS, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "XOSC": {
              "offset": "0xC4",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access XOSC, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "ROSC": {
              "offset": "0xC8",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access ROSC, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "PLL_SYS": {
              "offset": "0xCC",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access PLL_SYS, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "PLL_USB": {
              "offset": "0xD0",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access PLL_USB, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "TICKS": {
              "offset": "0xD4",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access TICKS, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "WATCHDOG": {
              "offset": "0xD8",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access WATCHDOG, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "RSM": {
              "offset": "0xDC",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access RSM, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "XIP_CTRL": {
              "offset": "0xE0",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access XIP_CTRL, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "XIP_QMI": {
              "offset": "0xE4",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access XIP_QMI, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged processor or debug access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            },
            "XIP_AUX": {
              "offset": "0xE8",
              "size": 32,
              "description": "Control whether debugger, DMA, core 0 and core 1 can access XIP_AUX, and at what security/privilege levels they can do so.\n\n                    Defaults to Secure, Privileged access only.\n\n                    This register is writable only from a Secure, Privileged processor or debugger, with the exception of the NSU bit, which becomes Non-secure-Privileged-writable when the NSP bit is set."
            }
          }
        },
        "USART": {
          "instances": [
            {
              "name": "UART0",
              "base": "0x40070000",
              "irq": 33
            },
            {
              "name": "UART1",
              "base": "0x40078000",
              "irq": 34
            }
          ],
          "registers": {
            "UARTDR": {
              "offset": "0x00",
              "size": 32,
              "description": "Data Register, UARTDR"
            },
            "UARTRSR": {
              "offset": "0x04",
              "size": 32,
              "description": "Receive Status Register/Error Clear Register, UARTRSR/UARTECR"
            },
            "UARTFR": {
              "offset": "0x18",
              "size": 32,
              "description": "Flag Register, UARTFR"
            },
            "UARTILPR": {
              "offset": "0x20",
              "size": 32,
              "description": "IrDA Low-Power Counter Register, UARTILPR"
            },
            "UARTIBRD": {
              "offset": "0x24",
              "size": 32,
              "description": "Integer Baud Rate Register, UARTIBRD"
            },
            "UARTFBRD": {
              "offset": "0x28",
              "size": 32,
              "description": "Fractional Baud Rate Register, UARTFBRD"
            },
            "UARTLCR_H": {
              "offset": "0x2C",
              "size": 32,
              "description": "Line Control Register, UARTLCR_H"
            },
            "UARTCR": {
              "offset": "0x30",
              "size": 32,
              "description": "Control Register, UARTCR"
            },
            "UARTIFLS": {
              "offset": "0x34",
              "size": 32,
              "description": "Interrupt FIFO Level Select Register, UARTIFLS"
            },
            "UARTIMSC": {
              "offset": "0x38",
              "size": 32,
              "description": "Interrupt Mask Set/Clear Register, UARTIMSC"
            },
            "UARTRIS": {
              "offset": "0x3C",
              "size": 32,
              "description": "Raw Interrupt Status Register, UARTRIS"
            },
            "UARTMIS": {
              "offset": "0x40",
              "size": 32,
              "description": "Masked Interrupt Status Register, UARTMIS"
            },
            "UARTICR": {
              "offset": "0x44",
              "size": 32,
              "description": "Interrupt Clear Register, UARTICR"
            },
            "UARTDMACR": {
              "offset": "0x48",
              "size": 32,
              "description": "DMA Control Register, UARTDMACR"
            },
            "UARTPERIPHID0": {
              "offset": "0xFE0",
              "size": 32,
              "description": "UARTPeriphID0 Register"
            },
            "UARTPERIPHID1": {
              "offset": "0xFE4",
              "size": 32,
              "description": "UARTPeriphID1 Register"
            },
            "UARTPERIPHID2": {
              "offset": "0xFE8",
              "size": 32,
              "description": "UARTPeriphID2 Register"
            },
            "UARTPERIPHID3": {
              "offset": "0xFEC",
              "size": 32,
              "description": "UARTPeriphID3 Register"
            },
            "UARTPCELLID0": {
              "offset": "0xFF0",
              "size": 32,
              "description": "UARTPCellID0 Register"
            },
            "UARTPCELLID1": {
              "offset": "0xFF4",
              "size": 32,
              "description": "UARTPCellID1 Register"
            },
            "UARTPCELLID2": {
              "offset": "0xFF8",
              "size": 32,
              "description": "UARTPCellID2 Register"
            },
            "UARTPCELLID3": {
              "offset": "0xFFC",
              "size": 32,
              "description": "UARTPCellID3 Register"
            }
          }
        },
        "ROSC": {
          "instances": [
            {
              "name": "ROSC",
              "base": "0x400E8000"
            }
          ],
          "registers": {
            "CTRL": {
              "offset": "0x00",
              "size": 32,
              "description": "Ring Oscillator control"
            },
            "FREQA": {
              "offset": "0x04",
              "size": 32,
              "description": "The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage \n                    The drive strength has 4 levels determined by the number of bits set \n                    Increasing the number of bits set increases the drive strength and increases the oscillation frequency \n                    0 bits set is the default drive strength \n                    1 bit set doubles the drive strength \n                    2 bits set triples drive strength \n                    3 bits set quadruples drive strength \n                    For frequency randomisation set both DS0_RANDOM=1 & DS1_RANDOM=1"
            },
            "FREQB": {
              "offset": "0x08",
              "size": 32,
              "description": "For a detailed description see freqa register"
            },
            "RANDOM": {
              "offset": "0x0C",
              "size": 32,
              "description": "Loads a value to the LFSR randomiser"
            },
            "DORMANT": {
              "offset": "0x10",
              "size": 32,
              "description": "Ring Oscillator pause control"
            },
            "DIV": {
              "offset": "0x14",
              "size": 32,
              "description": "Controls the output divider"
            },
            "PHASE": {
              "offset": "0x18",
              "size": 32,
              "description": "Controls the phase shifted output"
            },
            "STATUS": {
              "offset": "0x1C",
              "size": 32,
              "description": "Ring Oscillator Status"
            },
            "RANDOMBIT": {
              "offset": "0x20",
              "size": 32,
              "description": "This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency"
            },
            "COUNT": {
              "offset": "0x24",
              "size": 32,
              "description": "A down counter running at the ROSC frequency which counts to zero and stops. \n                    To start the counter write a non-zero value. \n                    Can be used for short software pauses when setting up time sensitive hardware."
            }
          }
        },
        "POWMAN": {
          "instances": [
            {
              "name": "POWMAN",
              "base": "0x40100000",
              "irq": 44
            }
          ],
          "registers": {
            "BADPASSWD": {
              "offset": "0x00",
              "size": 32,
              "description": "Indicates a bad password has been used"
            },
            "VREG_CTRL": {
              "offset": "0x04",
              "size": 32,
              "description": "Voltage Regulator Control"
            },
            "VREG_STS": {
              "offset": "0x08",
              "size": 32,
              "description": "Voltage Regulator Status"
            },
            "VREG": {
              "offset": "0x0C",
              "size": 32,
              "description": "Voltage Regulator Settings"
            },
            "VREG_LP_ENTRY": {
              "offset": "0x10",
              "size": 32,
              "description": "Voltage Regulator Low Power Entry Settings"
            },
            "VREG_LP_EXIT": {
              "offset": "0x14",
              "size": 32,
              "description": "Voltage Regulator Low Power Exit Settings"
            },
            "BOD_CTRL": {
              "offset": "0x18",
              "size": 32,
              "description": "Brown-out Detection Control"
            },
            "BOD": {
              "offset": "0x1C",
              "size": 32,
              "description": "Brown-out Detection Settings"
            },
            "BOD_LP_ENTRY": {
              "offset": "0x20",
              "size": 32,
              "description": "Brown-out Detection Low Power Entry Settings"
            },
            "BOD_LP_EXIT": {
              "offset": "0x24",
              "size": 32,
              "description": "Brown-out Detection Low Power Exit Settings"
            },
            "LPOSC": {
              "offset": "0x28",
              "size": 32,
              "description": "Low power oscillator control register."
            },
            "CHIP_RESET": {
              "offset": "0x2C",
              "size": 32,
              "description": "Chip reset control and status"
            },
            "WDSEL": {
              "offset": "0x30",
              "size": 32,
              "description": "Allows a watchdog reset to reset the internal state of powman in addition to the power-on state machine (PSM). \n                    Note that powman ignores watchdog resets that do not select at least the CLOCKS stage or earlier stages in the PSM. If using these bits, it's recommended to set PSM_WDSEL to all-ones in addition to the desired bits in this register. Failing to select CLOCKS or earlier will result in the POWMAN_WDSEL register having no effect."
            },
            "SEQ_CFG": {
              "offset": "0x34",
              "size": 32,
              "description": "For configuration of the power sequencer \n                    Writes are ignored while POWMAN_STATE_CHANGING=1"
            },
            "STATE": {
              "offset": "0x38",
              "size": 32,
              "description": "This register controls the power state of the 4 power domains. \n                    The current power state is indicated in POWMAN_STATE_CURRENT which is read-only. \n                    To change the state, write to POWMAN_STATE_REQ. \n                    The coding of POWMAN_STATE_CURRENT & POWMAN_STATE_REQ corresponds to the power states \n                    defined in the datasheet: \n                    bit 3 = SWCORE \n                    bit 2 = XIP cache \n                    bit 1 = SRAM0 \n                    bit 0 = SRAM1 \n                    0 = powered up \n                    1 = powered down \n                    When POWMAN_STATE_REQ is written, the POWMAN_STATE_WAITING flag is set while the Power Manager determines what is required. If an invalid transition is requested the Power Manager will still register the request in POWMAN_STATE_REQ but will also set the POWMAN_BAD_REQ flag. It will then implement the power-up requests and ignore the power down requests. To do nothing would risk entering an unrecoverable lock-up state. Invalid requests are: any combination of power up and power down requests any request that results in swcore boing powered and xip unpowered If the request is to power down the switched-core domain then POWMAN_STATE_WAITING stays active until the processors halt. During this time the POWMAN_STATE_REQ field can be re-written to change or cancel the request. When the power state transition begins the POWMAN_STATE_WAITING_flag is cleared, the POWMAN_STATE_CHANGING flag is set and POWMAN register writes are ignored until the transition completes."
            },
            "POW_FASTDIV": {
              "offset": "0x3C",
              "size": 32,
              "description": "divides the POWMAN clock to provide a tick for the delay module and state machines \n                            when clk_pow is running from the slow clock it is not divided \n                            when clk_pow is running from the fast clock it is divided by tick_div"
            },
            "POW_DELAY": {
              "offset": "0x40",
              "size": 32,
              "description": "power state machine delays"
            },
            "EXT_CTRL0": {
              "offset": "0x44",
              "size": 32,
              "description": "Configures a gpio as a power mode aware control output"
            },
            "EXT_CTRL1": {
              "offset": "0x48",
              "size": 32,
              "description": "Configures a gpio as a power mode aware control output"
            },
            "EXT_TIME_REF": {
              "offset": "0x4C",
              "size": 32,
              "description": "Select a GPIO to use as a time reference, the source can be used to drive the low power clock at 32kHz, or to provide a 1ms tick to the timer, or provide a 1Hz tick to the timer. The tick selection is controlled by the POWMAN_TIMER register."
            },
            "LPOSC_FREQ_KHZ_INT": {
              "offset": "0x50",
              "size": 32,
              "description": "Informs the AON Timer of the integer component of the clock frequency when running off the LPOSC."
            },
            "LPOSC_FREQ_KHZ_FRAC": {
              "offset": "0x54",
              "size": 32,
              "description": "Informs the AON Timer of the fractional component of the clock frequency when running off the LPOSC."
            },
            "XOSC_FREQ_KHZ_INT": {
              "offset": "0x58",
              "size": 32,
              "description": "Informs the AON Timer of the integer component of the clock frequency when running off the XOSC."
            },
            "XOSC_FREQ_KHZ_FRAC": {
              "offset": "0x5C",
              "size": 32,
              "description": "Informs the AON Timer of the fractional component of the clock frequency when running off the XOSC."
            },
            "SET_TIME_63TO48": {
              "offset": "0x60",
              "size": 32,
              "description": "For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0"
            },
            "SET_TIME_47TO32": {
              "offset": "0x64",
              "size": 32,
              "description": "For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0"
            },
            "SET_TIME_31TO16": {
              "offset": "0x68",
              "size": 32,
              "description": "For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0"
            },
            "SET_TIME_15TO0": {
              "offset": "0x6C",
              "size": 32,
              "description": "For setting the time, do not use for reading the time, use POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field must only be written when POWMAN_TIMER_RUN=0"
            },
            "READ_TIME_UPPER": {
              "offset": "0x70",
              "size": 32,
              "description": "For reading bits 63:32 of the timer. When reading all 64 bits it is possible for the LOWER count to rollover during the read. It is recommended to read UPPER, then LOWER, then re-read UPPER and, if it has changed, re-read LOWER."
            },
            "READ_TIME_LOWER": {
              "offset": "0x74",
              "size": 32,
              "description": "For reading bits 31:0 of the timer."
            },
            "ALARM_TIME_63TO48": {
              "offset": "0x78",
              "size": 32,
              "description": "This field must only be written when POWMAN_ALARM_ENAB=0"
            },
            "ALARM_TIME_47TO32": {
              "offset": "0x7C",
              "size": 32,
              "description": "This field must only be written when POWMAN_ALARM_ENAB=0"
            },
            "ALARM_TIME_31TO16": {
              "offset": "0x80",
              "size": 32,
              "description": "This field must only be written when POWMAN_ALARM_ENAB=0"
            },
            "ALARM_TIME_15TO0": {
              "offset": "0x84",
              "size": 32,
              "description": "This field must only be written when POWMAN_ALARM_ENAB=0"
            },
            "TIMER": {
              "offset": "0x88",
              "size": 32,
              "description": "Timer is synchronised to a 1hz gpio source"
            },
            "PWRUP0": {
              "offset": "0x8C",
              "size": 32,
              "description": "4 GPIO powerup events can be configured to wake the chip up from a low power state. \n                    The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event \n                    The number of gpios available depends on the package option. An invalid selection will be ignored \n                    source = 0 selects gpio0 \n                    . \n                    . \n                    source = 47 selects gpio47 \n                    source = 48 selects qspi_ss \n                    source = 49 selects qspi_sd0 \n                    source = 50 selects qspi_sd1 \n                    source = 51 selects qspi_sd2 \n                    source = 52 selects qspi_sd3 \n                    source = 53 selects qspi_sclk \n                    level  = 0 triggers the pwrup when the source is low \n                    level  = 1 triggers the pwrup when the source is high"
            },
            "PWRUP1": {
              "offset": "0x90",
              "size": 32,
              "description": "4 GPIO powerup events can be configured to wake the chip up from a low power state. \n                    The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event \n                    The number of gpios available depends on the package option. An invalid selection will be ignored \n                    source = 0 selects gpio0 \n                    . \n                    . \n                    source = 47 selects gpio47 \n                    source = 48 selects qspi_ss \n                    source = 49 selects qspi_sd0 \n                    source = 50 selects qspi_sd1 \n                    source = 51 selects qspi_sd2 \n                    source = 52 selects qspi_sd3 \n                    source = 53 selects qspi_sclk \n                    level  = 0 triggers the pwrup when the source is low \n                    level  = 1 triggers the pwrup when the source is high"
            },
            "PWRUP2": {
              "offset": "0x94",
              "size": 32,
              "description": "4 GPIO powerup events can be configured to wake the chip up from a low power state. \n                    The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event \n                    The number of gpios available depends on the package option. An invalid selection will be ignored \n                    source = 0 selects gpio0 \n                    . \n                    . \n                    source = 47 selects gpio47 \n                    source = 48 selects qspi_ss \n                    source = 49 selects qspi_sd0 \n                    source = 50 selects qspi_sd1 \n                    source = 51 selects qspi_sd2 \n                    source = 52 selects qspi_sd3 \n                    source = 53 selects qspi_sclk \n                    level  = 0 triggers the pwrup when the source is low \n                    level  = 1 triggers the pwrup when the source is high"
            },
            "PWRUP3": {
              "offset": "0x98",
              "size": 32,
              "description": "4 GPIO powerup events can be configured to wake the chip up from a low power state. \n                    The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event \n                    The number of gpios available depends on the package option. An invalid selection will be ignored \n                    source = 0 selects gpio0 \n                    . \n                    . \n                    source = 47 selects gpio47 \n                    source = 48 selects qspi_ss \n                    source = 49 selects qspi_sd0 \n                    source = 50 selects qspi_sd1 \n                    source = 51 selects qspi_sd2 \n                    source = 52 selects qspi_sd3 \n                    source = 53 selects qspi_sclk \n                    level  = 0 triggers the pwrup when the source is low \n                    level  = 1 triggers the pwrup when the source is high"
            },
            "CURRENT_PWRUP_REQ": {
              "offset": "0x9C",
              "size": 32,
              "description": "Indicates current powerup request state \n                    pwrup events can be cleared by removing the enable from the pwrup register. The alarm pwrup req can be cleared by clearing timer.alarm_enab \n                    0 = chip reset, for the source of the last reset see POWMAN_CHIP_RESET \n                    1 = pwrup0 \n                    2 = pwrup1 \n                    3 = pwrup2 \n                    4 = pwrup3 \n                    5 = coresight_pwrup \n                    6 = alarm_pwrup"
            },
            "LAST_SWCORE_PWRUP": {
              "offset": "0xA0",
              "size": 32,
              "description": "Indicates which pwrup source triggered the last switched-core power up \n                    0 = chip reset, for the source of the last reset see POWMAN_CHIP_RESET \n                    1 = pwrup0 \n                    2 = pwrup1 \n                    3 = pwrup2 \n                    4 = pwrup3 \n                    5 = coresight_pwrup \n                    6 = alarm_pwrup"
            },
            "DBG_PWRCFG": {
              "offset": "0xA4",
              "size": 32,
              "description": "Ignore pwrup req from debugger. If pwrup req is asserted then this will prevent power down and set powerdown blocked. Set ignore to stop paying attention to pwrup_req"
            },
            "BOOTDIS": {
              "offset": "0xA8",
              "size": 32,
              "description": "Tell the bootrom to ignore the BOOT0..3 registers following the next RSM reset (e.g. the next core power down/up).\n\n                    If an early boot stage has soft-locked some OTP pages in order to protect their contents from later stages, there is a risk that Secure code running at a later stage can unlock the pages by powering the core up and down.\n\n                    This register can be used to ensure that the bootloader runs as normal on the next power up, preventing Secure code at a later stage from accessing OTP in its unlocked state.\n\n                    Should be used in conjunction with the OTP BOOTDIS register."
            },
            "DBGCONFIG": {
              "offset": "0xAC",
              "size": 32,
              "description": "Configure DP instance ID for SWD multidrop selection. \n                            Recommend that this is NOT changed until you require debug access in multi-chip environment"
            },
            "SCRATCH0": {
              "offset": "0xB0",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "SCRATCH1": {
              "offset": "0xB4",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "SCRATCH2": {
              "offset": "0xB8",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "SCRATCH3": {
              "offset": "0xBC",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "SCRATCH4": {
              "offset": "0xC0",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "SCRATCH5": {
              "offset": "0xC4",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "SCRATCH6": {
              "offset": "0xC8",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "SCRATCH7": {
              "offset": "0xCC",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "BOOT0": {
              "offset": "0xD0",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "BOOT1": {
              "offset": "0xD4",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "BOOT2": {
              "offset": "0xD8",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "BOOT3": {
              "offset": "0xDC",
              "size": 32,
              "description": "Scratch register. Information persists in low power mode"
            },
            "INTR": {
              "offset": "0xE0",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTE": {
              "offset": "0xE4",
              "size": 32,
              "description": "Interrupt Enable"
            },
            "INTF": {
              "offset": "0xE8",
              "size": 32,
              "description": "Interrupt Force"
            },
            "INTS": {
              "offset": "0xEC",
              "size": 32,
              "description": "Interrupt status after masking & forcing"
            }
          }
        },
        "WATCHDOG": {
          "instances": [
            {
              "name": "WATCHDOG",
              "base": "0x400D8000"
            }
          ],
          "registers": {
            "CTRL": {
              "offset": "0x00",
              "size": 32,
              "description": "Watchdog control \n                    The rst_wdsel register determines which subsystems are reset when the watchdog is triggered. \n                    The watchdog can be triggered in software."
            },
            "LOAD": {
              "offset": "0x04",
              "size": 32,
              "description": "Load the watchdog timer. The maximum setting is 0xffffff which corresponds to approximately 16 seconds."
            },
            "REASON": {
              "offset": "0x08",
              "size": 32,
              "description": "Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.\n\n                    Additionally, as of RP2350, a debugger warm reset of either core (SYSRESETREQ or hartreset) will also clear the watchdog reason register, so that software loaded under the debugger following a watchdog timeout will not continue to see the timeout condition."
            },
            "SCRATCH0": {
              "offset": "0x0C",
              "size": 32,
              "description": "Scratch register. Information persists through soft reset of the chip."
            },
            "SCRATCH1": {
              "offset": "0x10",
              "size": 32,
              "description": "Scratch register. Information persists through soft reset of the chip."
            },
            "SCRATCH2": {
              "offset": "0x14",
              "size": 32,
              "description": "Scratch register. Information persists through soft reset of the chip."
            },
            "SCRATCH3": {
              "offset": "0x18",
              "size": 32,
              "description": "Scratch register. Information persists through soft reset of the chip."
            },
            "SCRATCH4": {
              "offset": "0x1C",
              "size": 32,
              "description": "Scratch register. Information persists through soft reset of the chip."
            },
            "SCRATCH5": {
              "offset": "0x20",
              "size": 32,
              "description": "Scratch register. Information persists through soft reset of the chip."
            },
            "SCRATCH6": {
              "offset": "0x24",
              "size": 32,
              "description": "Scratch register. Information persists through soft reset of the chip."
            },
            "SCRATCH7": {
              "offset": "0x28",
              "size": 32,
              "description": "Scratch register. Information persists through soft reset of the chip."
            }
          }
        },
        "DMA": {
          "instances": [
            {
              "name": "DMA",
              "base": "0x50000000",
              "irq": 10
            }
          ],
          "registers": {
            "CH0_READ_ADDR": {
              "offset": "0x00",
              "size": 32,
              "description": "DMA Channel 0 Read Address pointer"
            },
            "CH0_WRITE_ADDR": {
              "offset": "0x04",
              "size": 32,
              "description": "DMA Channel 0 Write Address pointer"
            },
            "CH0_TRANS_COUNT": {
              "offset": "0x08",
              "size": 32,
              "description": "DMA Channel 0 Transfer Count"
            },
            "CH0_CTRL_TRIG": {
              "offset": "0x0C",
              "size": 32,
              "description": "DMA Channel 0 Control and Status"
            },
            "CH0_AL1_CTRL": {
              "offset": "0x10",
              "size": 32,
              "description": "Alias for channel 0 CTRL register"
            },
            "CH0_AL1_READ_ADDR": {
              "offset": "0x14",
              "size": 32,
              "description": "Alias for channel 0 READ_ADDR register"
            },
            "CH0_AL1_WRITE_ADDR": {
              "offset": "0x18",
              "size": 32,
              "description": "Alias for channel 0 WRITE_ADDR register"
            },
            "CH0_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x1C",
              "size": 32,
              "description": "Alias for channel 0 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH0_AL2_CTRL": {
              "offset": "0x20",
              "size": 32,
              "description": "Alias for channel 0 CTRL register"
            },
            "CH0_AL2_TRANS_COUNT": {
              "offset": "0x24",
              "size": 32,
              "description": "Alias for channel 0 TRANS_COUNT register"
            },
            "CH0_AL2_READ_ADDR": {
              "offset": "0x28",
              "size": 32,
              "description": "Alias for channel 0 READ_ADDR register"
            },
            "CH0_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x2C",
              "size": 32,
              "description": "Alias for channel 0 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH0_AL3_CTRL": {
              "offset": "0x30",
              "size": 32,
              "description": "Alias for channel 0 CTRL register"
            },
            "CH0_AL3_WRITE_ADDR": {
              "offset": "0x34",
              "size": 32,
              "description": "Alias for channel 0 WRITE_ADDR register"
            },
            "CH0_AL3_TRANS_COUNT": {
              "offset": "0x38",
              "size": 32,
              "description": "Alias for channel 0 TRANS_COUNT register"
            },
            "CH0_AL3_READ_ADDR_TRIG": {
              "offset": "0x3C",
              "size": 32,
              "description": "Alias for channel 0 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH1_READ_ADDR": {
              "offset": "0x40",
              "size": 32,
              "description": "DMA Channel 1 Read Address pointer"
            },
            "CH1_WRITE_ADDR": {
              "offset": "0x44",
              "size": 32,
              "description": "DMA Channel 1 Write Address pointer"
            },
            "CH1_TRANS_COUNT": {
              "offset": "0x48",
              "size": 32,
              "description": "DMA Channel 1 Transfer Count"
            },
            "CH1_CTRL_TRIG": {
              "offset": "0x4C",
              "size": 32,
              "description": "DMA Channel 1 Control and Status"
            },
            "CH1_AL1_CTRL": {
              "offset": "0x50",
              "size": 32,
              "description": "Alias for channel 1 CTRL register"
            },
            "CH1_AL1_READ_ADDR": {
              "offset": "0x54",
              "size": 32,
              "description": "Alias for channel 1 READ_ADDR register"
            },
            "CH1_AL1_WRITE_ADDR": {
              "offset": "0x58",
              "size": 32,
              "description": "Alias for channel 1 WRITE_ADDR register"
            },
            "CH1_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x5C",
              "size": 32,
              "description": "Alias for channel 1 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH1_AL2_CTRL": {
              "offset": "0x60",
              "size": 32,
              "description": "Alias for channel 1 CTRL register"
            },
            "CH1_AL2_TRANS_COUNT": {
              "offset": "0x64",
              "size": 32,
              "description": "Alias for channel 1 TRANS_COUNT register"
            },
            "CH1_AL2_READ_ADDR": {
              "offset": "0x68",
              "size": 32,
              "description": "Alias for channel 1 READ_ADDR register"
            },
            "CH1_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x6C",
              "size": 32,
              "description": "Alias for channel 1 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH1_AL3_CTRL": {
              "offset": "0x70",
              "size": 32,
              "description": "Alias for channel 1 CTRL register"
            },
            "CH1_AL3_WRITE_ADDR": {
              "offset": "0x74",
              "size": 32,
              "description": "Alias for channel 1 WRITE_ADDR register"
            },
            "CH1_AL3_TRANS_COUNT": {
              "offset": "0x78",
              "size": 32,
              "description": "Alias for channel 1 TRANS_COUNT register"
            },
            "CH1_AL3_READ_ADDR_TRIG": {
              "offset": "0x7C",
              "size": 32,
              "description": "Alias for channel 1 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH2_READ_ADDR": {
              "offset": "0x80",
              "size": 32,
              "description": "DMA Channel 2 Read Address pointer"
            },
            "CH2_WRITE_ADDR": {
              "offset": "0x84",
              "size": 32,
              "description": "DMA Channel 2 Write Address pointer"
            },
            "CH2_TRANS_COUNT": {
              "offset": "0x88",
              "size": 32,
              "description": "DMA Channel 2 Transfer Count"
            },
            "CH2_CTRL_TRIG": {
              "offset": "0x8C",
              "size": 32,
              "description": "DMA Channel 2 Control and Status"
            },
            "CH2_AL1_CTRL": {
              "offset": "0x90",
              "size": 32,
              "description": "Alias for channel 2 CTRL register"
            },
            "CH2_AL1_READ_ADDR": {
              "offset": "0x94",
              "size": 32,
              "description": "Alias for channel 2 READ_ADDR register"
            },
            "CH2_AL1_WRITE_ADDR": {
              "offset": "0x98",
              "size": 32,
              "description": "Alias for channel 2 WRITE_ADDR register"
            },
            "CH2_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x9C",
              "size": 32,
              "description": "Alias for channel 2 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH2_AL2_CTRL": {
              "offset": "0xA0",
              "size": 32,
              "description": "Alias for channel 2 CTRL register"
            },
            "CH2_AL2_TRANS_COUNT": {
              "offset": "0xA4",
              "size": 32,
              "description": "Alias for channel 2 TRANS_COUNT register"
            },
            "CH2_AL2_READ_ADDR": {
              "offset": "0xA8",
              "size": 32,
              "description": "Alias for channel 2 READ_ADDR register"
            },
            "CH2_AL2_WRITE_ADDR_TRIG": {
              "offset": "0xAC",
              "size": 32,
              "description": "Alias for channel 2 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH2_AL3_CTRL": {
              "offset": "0xB0",
              "size": 32,
              "description": "Alias for channel 2 CTRL register"
            },
            "CH2_AL3_WRITE_ADDR": {
              "offset": "0xB4",
              "size": 32,
              "description": "Alias for channel 2 WRITE_ADDR register"
            },
            "CH2_AL3_TRANS_COUNT": {
              "offset": "0xB8",
              "size": 32,
              "description": "Alias for channel 2 TRANS_COUNT register"
            },
            "CH2_AL3_READ_ADDR_TRIG": {
              "offset": "0xBC",
              "size": 32,
              "description": "Alias for channel 2 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH3_READ_ADDR": {
              "offset": "0xC0",
              "size": 32,
              "description": "DMA Channel 3 Read Address pointer"
            },
            "CH3_WRITE_ADDR": {
              "offset": "0xC4",
              "size": 32,
              "description": "DMA Channel 3 Write Address pointer"
            },
            "CH3_TRANS_COUNT": {
              "offset": "0xC8",
              "size": 32,
              "description": "DMA Channel 3 Transfer Count"
            },
            "CH3_CTRL_TRIG": {
              "offset": "0xCC",
              "size": 32,
              "description": "DMA Channel 3 Control and Status"
            },
            "CH3_AL1_CTRL": {
              "offset": "0xD0",
              "size": 32,
              "description": "Alias for channel 3 CTRL register"
            },
            "CH3_AL1_READ_ADDR": {
              "offset": "0xD4",
              "size": 32,
              "description": "Alias for channel 3 READ_ADDR register"
            },
            "CH3_AL1_WRITE_ADDR": {
              "offset": "0xD8",
              "size": 32,
              "description": "Alias for channel 3 WRITE_ADDR register"
            },
            "CH3_AL1_TRANS_COUNT_TRIG": {
              "offset": "0xDC",
              "size": 32,
              "description": "Alias for channel 3 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH3_AL2_CTRL": {
              "offset": "0xE0",
              "size": 32,
              "description": "Alias for channel 3 CTRL register"
            },
            "CH3_AL2_TRANS_COUNT": {
              "offset": "0xE4",
              "size": 32,
              "description": "Alias for channel 3 TRANS_COUNT register"
            },
            "CH3_AL2_READ_ADDR": {
              "offset": "0xE8",
              "size": 32,
              "description": "Alias for channel 3 READ_ADDR register"
            },
            "CH3_AL2_WRITE_ADDR_TRIG": {
              "offset": "0xEC",
              "size": 32,
              "description": "Alias for channel 3 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH3_AL3_CTRL": {
              "offset": "0xF0",
              "size": 32,
              "description": "Alias for channel 3 CTRL register"
            },
            "CH3_AL3_WRITE_ADDR": {
              "offset": "0xF4",
              "size": 32,
              "description": "Alias for channel 3 WRITE_ADDR register"
            },
            "CH3_AL3_TRANS_COUNT": {
              "offset": "0xF8",
              "size": 32,
              "description": "Alias for channel 3 TRANS_COUNT register"
            },
            "CH3_AL3_READ_ADDR_TRIG": {
              "offset": "0xFC",
              "size": 32,
              "description": "Alias for channel 3 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH4_READ_ADDR": {
              "offset": "0x100",
              "size": 32,
              "description": "DMA Channel 4 Read Address pointer"
            },
            "CH4_WRITE_ADDR": {
              "offset": "0x104",
              "size": 32,
              "description": "DMA Channel 4 Write Address pointer"
            },
            "CH4_TRANS_COUNT": {
              "offset": "0x108",
              "size": 32,
              "description": "DMA Channel 4 Transfer Count"
            },
            "CH4_CTRL_TRIG": {
              "offset": "0x10C",
              "size": 32,
              "description": "DMA Channel 4 Control and Status"
            },
            "CH4_AL1_CTRL": {
              "offset": "0x110",
              "size": 32,
              "description": "Alias for channel 4 CTRL register"
            },
            "CH4_AL1_READ_ADDR": {
              "offset": "0x114",
              "size": 32,
              "description": "Alias for channel 4 READ_ADDR register"
            },
            "CH4_AL1_WRITE_ADDR": {
              "offset": "0x118",
              "size": 32,
              "description": "Alias for channel 4 WRITE_ADDR register"
            },
            "CH4_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x11C",
              "size": 32,
              "description": "Alias for channel 4 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH4_AL2_CTRL": {
              "offset": "0x120",
              "size": 32,
              "description": "Alias for channel 4 CTRL register"
            },
            "CH4_AL2_TRANS_COUNT": {
              "offset": "0x124",
              "size": 32,
              "description": "Alias for channel 4 TRANS_COUNT register"
            },
            "CH4_AL2_READ_ADDR": {
              "offset": "0x128",
              "size": 32,
              "description": "Alias for channel 4 READ_ADDR register"
            },
            "CH4_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x12C",
              "size": 32,
              "description": "Alias for channel 4 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH4_AL3_CTRL": {
              "offset": "0x130",
              "size": 32,
              "description": "Alias for channel 4 CTRL register"
            },
            "CH4_AL3_WRITE_ADDR": {
              "offset": "0x134",
              "size": 32,
              "description": "Alias for channel 4 WRITE_ADDR register"
            },
            "CH4_AL3_TRANS_COUNT": {
              "offset": "0x138",
              "size": 32,
              "description": "Alias for channel 4 TRANS_COUNT register"
            },
            "CH4_AL3_READ_ADDR_TRIG": {
              "offset": "0x13C",
              "size": 32,
              "description": "Alias for channel 4 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH5_READ_ADDR": {
              "offset": "0x140",
              "size": 32,
              "description": "DMA Channel 5 Read Address pointer"
            },
            "CH5_WRITE_ADDR": {
              "offset": "0x144",
              "size": 32,
              "description": "DMA Channel 5 Write Address pointer"
            },
            "CH5_TRANS_COUNT": {
              "offset": "0x148",
              "size": 32,
              "description": "DMA Channel 5 Transfer Count"
            },
            "CH5_CTRL_TRIG": {
              "offset": "0x14C",
              "size": 32,
              "description": "DMA Channel 5 Control and Status"
            },
            "CH5_AL1_CTRL": {
              "offset": "0x150",
              "size": 32,
              "description": "Alias for channel 5 CTRL register"
            },
            "CH5_AL1_READ_ADDR": {
              "offset": "0x154",
              "size": 32,
              "description": "Alias for channel 5 READ_ADDR register"
            },
            "CH5_AL1_WRITE_ADDR": {
              "offset": "0x158",
              "size": 32,
              "description": "Alias for channel 5 WRITE_ADDR register"
            },
            "CH5_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x15C",
              "size": 32,
              "description": "Alias for channel 5 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH5_AL2_CTRL": {
              "offset": "0x160",
              "size": 32,
              "description": "Alias for channel 5 CTRL register"
            },
            "CH5_AL2_TRANS_COUNT": {
              "offset": "0x164",
              "size": 32,
              "description": "Alias for channel 5 TRANS_COUNT register"
            },
            "CH5_AL2_READ_ADDR": {
              "offset": "0x168",
              "size": 32,
              "description": "Alias for channel 5 READ_ADDR register"
            },
            "CH5_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x16C",
              "size": 32,
              "description": "Alias for channel 5 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH5_AL3_CTRL": {
              "offset": "0x170",
              "size": 32,
              "description": "Alias for channel 5 CTRL register"
            },
            "CH5_AL3_WRITE_ADDR": {
              "offset": "0x174",
              "size": 32,
              "description": "Alias for channel 5 WRITE_ADDR register"
            },
            "CH5_AL3_TRANS_COUNT": {
              "offset": "0x178",
              "size": 32,
              "description": "Alias for channel 5 TRANS_COUNT register"
            },
            "CH5_AL3_READ_ADDR_TRIG": {
              "offset": "0x17C",
              "size": 32,
              "description": "Alias for channel 5 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH6_READ_ADDR": {
              "offset": "0x180",
              "size": 32,
              "description": "DMA Channel 6 Read Address pointer"
            },
            "CH6_WRITE_ADDR": {
              "offset": "0x184",
              "size": 32,
              "description": "DMA Channel 6 Write Address pointer"
            },
            "CH6_TRANS_COUNT": {
              "offset": "0x188",
              "size": 32,
              "description": "DMA Channel 6 Transfer Count"
            },
            "CH6_CTRL_TRIG": {
              "offset": "0x18C",
              "size": 32,
              "description": "DMA Channel 6 Control and Status"
            },
            "CH6_AL1_CTRL": {
              "offset": "0x190",
              "size": 32,
              "description": "Alias for channel 6 CTRL register"
            },
            "CH6_AL1_READ_ADDR": {
              "offset": "0x194",
              "size": 32,
              "description": "Alias for channel 6 READ_ADDR register"
            },
            "CH6_AL1_WRITE_ADDR": {
              "offset": "0x198",
              "size": 32,
              "description": "Alias for channel 6 WRITE_ADDR register"
            },
            "CH6_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x19C",
              "size": 32,
              "description": "Alias for channel 6 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH6_AL2_CTRL": {
              "offset": "0x1A0",
              "size": 32,
              "description": "Alias for channel 6 CTRL register"
            },
            "CH6_AL2_TRANS_COUNT": {
              "offset": "0x1A4",
              "size": 32,
              "description": "Alias for channel 6 TRANS_COUNT register"
            },
            "CH6_AL2_READ_ADDR": {
              "offset": "0x1A8",
              "size": 32,
              "description": "Alias for channel 6 READ_ADDR register"
            },
            "CH6_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x1AC",
              "size": 32,
              "description": "Alias for channel 6 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH6_AL3_CTRL": {
              "offset": "0x1B0",
              "size": 32,
              "description": "Alias for channel 6 CTRL register"
            },
            "CH6_AL3_WRITE_ADDR": {
              "offset": "0x1B4",
              "size": 32,
              "description": "Alias for channel 6 WRITE_ADDR register"
            },
            "CH6_AL3_TRANS_COUNT": {
              "offset": "0x1B8",
              "size": 32,
              "description": "Alias for channel 6 TRANS_COUNT register"
            },
            "CH6_AL3_READ_ADDR_TRIG": {
              "offset": "0x1BC",
              "size": 32,
              "description": "Alias for channel 6 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH7_READ_ADDR": {
              "offset": "0x1C0",
              "size": 32,
              "description": "DMA Channel 7 Read Address pointer"
            },
            "CH7_WRITE_ADDR": {
              "offset": "0x1C4",
              "size": 32,
              "description": "DMA Channel 7 Write Address pointer"
            },
            "CH7_TRANS_COUNT": {
              "offset": "0x1C8",
              "size": 32,
              "description": "DMA Channel 7 Transfer Count"
            },
            "CH7_CTRL_TRIG": {
              "offset": "0x1CC",
              "size": 32,
              "description": "DMA Channel 7 Control and Status"
            },
            "CH7_AL1_CTRL": {
              "offset": "0x1D0",
              "size": 32,
              "description": "Alias for channel 7 CTRL register"
            },
            "CH7_AL1_READ_ADDR": {
              "offset": "0x1D4",
              "size": 32,
              "description": "Alias for channel 7 READ_ADDR register"
            },
            "CH7_AL1_WRITE_ADDR": {
              "offset": "0x1D8",
              "size": 32,
              "description": "Alias for channel 7 WRITE_ADDR register"
            },
            "CH7_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x1DC",
              "size": 32,
              "description": "Alias for channel 7 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH7_AL2_CTRL": {
              "offset": "0x1E0",
              "size": 32,
              "description": "Alias for channel 7 CTRL register"
            },
            "CH7_AL2_TRANS_COUNT": {
              "offset": "0x1E4",
              "size": 32,
              "description": "Alias for channel 7 TRANS_COUNT register"
            },
            "CH7_AL2_READ_ADDR": {
              "offset": "0x1E8",
              "size": 32,
              "description": "Alias for channel 7 READ_ADDR register"
            },
            "CH7_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x1EC",
              "size": 32,
              "description": "Alias for channel 7 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH7_AL3_CTRL": {
              "offset": "0x1F0",
              "size": 32,
              "description": "Alias for channel 7 CTRL register"
            },
            "CH7_AL3_WRITE_ADDR": {
              "offset": "0x1F4",
              "size": 32,
              "description": "Alias for channel 7 WRITE_ADDR register"
            },
            "CH7_AL3_TRANS_COUNT": {
              "offset": "0x1F8",
              "size": 32,
              "description": "Alias for channel 7 TRANS_COUNT register"
            },
            "CH7_AL3_READ_ADDR_TRIG": {
              "offset": "0x1FC",
              "size": 32,
              "description": "Alias for channel 7 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH8_READ_ADDR": {
              "offset": "0x200",
              "size": 32,
              "description": "DMA Channel 8 Read Address pointer"
            },
            "CH8_WRITE_ADDR": {
              "offset": "0x204",
              "size": 32,
              "description": "DMA Channel 8 Write Address pointer"
            },
            "CH8_TRANS_COUNT": {
              "offset": "0x208",
              "size": 32,
              "description": "DMA Channel 8 Transfer Count"
            },
            "CH8_CTRL_TRIG": {
              "offset": "0x20C",
              "size": 32,
              "description": "DMA Channel 8 Control and Status"
            },
            "CH8_AL1_CTRL": {
              "offset": "0x210",
              "size": 32,
              "description": "Alias for channel 8 CTRL register"
            },
            "CH8_AL1_READ_ADDR": {
              "offset": "0x214",
              "size": 32,
              "description": "Alias for channel 8 READ_ADDR register"
            },
            "CH8_AL1_WRITE_ADDR": {
              "offset": "0x218",
              "size": 32,
              "description": "Alias for channel 8 WRITE_ADDR register"
            },
            "CH8_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x21C",
              "size": 32,
              "description": "Alias for channel 8 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH8_AL2_CTRL": {
              "offset": "0x220",
              "size": 32,
              "description": "Alias for channel 8 CTRL register"
            },
            "CH8_AL2_TRANS_COUNT": {
              "offset": "0x224",
              "size": 32,
              "description": "Alias for channel 8 TRANS_COUNT register"
            },
            "CH8_AL2_READ_ADDR": {
              "offset": "0x228",
              "size": 32,
              "description": "Alias for channel 8 READ_ADDR register"
            },
            "CH8_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x22C",
              "size": 32,
              "description": "Alias for channel 8 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH8_AL3_CTRL": {
              "offset": "0x230",
              "size": 32,
              "description": "Alias for channel 8 CTRL register"
            },
            "CH8_AL3_WRITE_ADDR": {
              "offset": "0x234",
              "size": 32,
              "description": "Alias for channel 8 WRITE_ADDR register"
            },
            "CH8_AL3_TRANS_COUNT": {
              "offset": "0x238",
              "size": 32,
              "description": "Alias for channel 8 TRANS_COUNT register"
            },
            "CH8_AL3_READ_ADDR_TRIG": {
              "offset": "0x23C",
              "size": 32,
              "description": "Alias for channel 8 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH9_READ_ADDR": {
              "offset": "0x240",
              "size": 32,
              "description": "DMA Channel 9 Read Address pointer"
            },
            "CH9_WRITE_ADDR": {
              "offset": "0x244",
              "size": 32,
              "description": "DMA Channel 9 Write Address pointer"
            },
            "CH9_TRANS_COUNT": {
              "offset": "0x248",
              "size": 32,
              "description": "DMA Channel 9 Transfer Count"
            },
            "CH9_CTRL_TRIG": {
              "offset": "0x24C",
              "size": 32,
              "description": "DMA Channel 9 Control and Status"
            },
            "CH9_AL1_CTRL": {
              "offset": "0x250",
              "size": 32,
              "description": "Alias for channel 9 CTRL register"
            },
            "CH9_AL1_READ_ADDR": {
              "offset": "0x254",
              "size": 32,
              "description": "Alias for channel 9 READ_ADDR register"
            },
            "CH9_AL1_WRITE_ADDR": {
              "offset": "0x258",
              "size": 32,
              "description": "Alias for channel 9 WRITE_ADDR register"
            },
            "CH9_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x25C",
              "size": 32,
              "description": "Alias for channel 9 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH9_AL2_CTRL": {
              "offset": "0x260",
              "size": 32,
              "description": "Alias for channel 9 CTRL register"
            },
            "CH9_AL2_TRANS_COUNT": {
              "offset": "0x264",
              "size": 32,
              "description": "Alias for channel 9 TRANS_COUNT register"
            },
            "CH9_AL2_READ_ADDR": {
              "offset": "0x268",
              "size": 32,
              "description": "Alias for channel 9 READ_ADDR register"
            },
            "CH9_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x26C",
              "size": 32,
              "description": "Alias for channel 9 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH9_AL3_CTRL": {
              "offset": "0x270",
              "size": 32,
              "description": "Alias for channel 9 CTRL register"
            },
            "CH9_AL3_WRITE_ADDR": {
              "offset": "0x274",
              "size": 32,
              "description": "Alias for channel 9 WRITE_ADDR register"
            },
            "CH9_AL3_TRANS_COUNT": {
              "offset": "0x278",
              "size": 32,
              "description": "Alias for channel 9 TRANS_COUNT register"
            },
            "CH9_AL3_READ_ADDR_TRIG": {
              "offset": "0x27C",
              "size": 32,
              "description": "Alias for channel 9 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH10_READ_ADDR": {
              "offset": "0x280",
              "size": 32,
              "description": "DMA Channel 10 Read Address pointer"
            },
            "CH10_WRITE_ADDR": {
              "offset": "0x284",
              "size": 32,
              "description": "DMA Channel 10 Write Address pointer"
            },
            "CH10_TRANS_COUNT": {
              "offset": "0x288",
              "size": 32,
              "description": "DMA Channel 10 Transfer Count"
            },
            "CH10_CTRL_TRIG": {
              "offset": "0x28C",
              "size": 32,
              "description": "DMA Channel 10 Control and Status"
            },
            "CH10_AL1_CTRL": {
              "offset": "0x290",
              "size": 32,
              "description": "Alias for channel 10 CTRL register"
            },
            "CH10_AL1_READ_ADDR": {
              "offset": "0x294",
              "size": 32,
              "description": "Alias for channel 10 READ_ADDR register"
            },
            "CH10_AL1_WRITE_ADDR": {
              "offset": "0x298",
              "size": 32,
              "description": "Alias for channel 10 WRITE_ADDR register"
            },
            "CH10_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x29C",
              "size": 32,
              "description": "Alias for channel 10 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH10_AL2_CTRL": {
              "offset": "0x2A0",
              "size": 32,
              "description": "Alias for channel 10 CTRL register"
            },
            "CH10_AL2_TRANS_COUNT": {
              "offset": "0x2A4",
              "size": 32,
              "description": "Alias for channel 10 TRANS_COUNT register"
            },
            "CH10_AL2_READ_ADDR": {
              "offset": "0x2A8",
              "size": 32,
              "description": "Alias for channel 10 READ_ADDR register"
            },
            "CH10_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x2AC",
              "size": 32,
              "description": "Alias for channel 10 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH10_AL3_CTRL": {
              "offset": "0x2B0",
              "size": 32,
              "description": "Alias for channel 10 CTRL register"
            },
            "CH10_AL3_WRITE_ADDR": {
              "offset": "0x2B4",
              "size": 32,
              "description": "Alias for channel 10 WRITE_ADDR register"
            },
            "CH10_AL3_TRANS_COUNT": {
              "offset": "0x2B8",
              "size": 32,
              "description": "Alias for channel 10 TRANS_COUNT register"
            },
            "CH10_AL3_READ_ADDR_TRIG": {
              "offset": "0x2BC",
              "size": 32,
              "description": "Alias for channel 10 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH11_READ_ADDR": {
              "offset": "0x2C0",
              "size": 32,
              "description": "DMA Channel 11 Read Address pointer"
            },
            "CH11_WRITE_ADDR": {
              "offset": "0x2C4",
              "size": 32,
              "description": "DMA Channel 11 Write Address pointer"
            },
            "CH11_TRANS_COUNT": {
              "offset": "0x2C8",
              "size": 32,
              "description": "DMA Channel 11 Transfer Count"
            },
            "CH11_CTRL_TRIG": {
              "offset": "0x2CC",
              "size": 32,
              "description": "DMA Channel 11 Control and Status"
            },
            "CH11_AL1_CTRL": {
              "offset": "0x2D0",
              "size": 32,
              "description": "Alias for channel 11 CTRL register"
            },
            "CH11_AL1_READ_ADDR": {
              "offset": "0x2D4",
              "size": 32,
              "description": "Alias for channel 11 READ_ADDR register"
            },
            "CH11_AL1_WRITE_ADDR": {
              "offset": "0x2D8",
              "size": 32,
              "description": "Alias for channel 11 WRITE_ADDR register"
            },
            "CH11_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x2DC",
              "size": 32,
              "description": "Alias for channel 11 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH11_AL2_CTRL": {
              "offset": "0x2E0",
              "size": 32,
              "description": "Alias for channel 11 CTRL register"
            },
            "CH11_AL2_TRANS_COUNT": {
              "offset": "0x2E4",
              "size": 32,
              "description": "Alias for channel 11 TRANS_COUNT register"
            },
            "CH11_AL2_READ_ADDR": {
              "offset": "0x2E8",
              "size": 32,
              "description": "Alias for channel 11 READ_ADDR register"
            },
            "CH11_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x2EC",
              "size": 32,
              "description": "Alias for channel 11 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH11_AL3_CTRL": {
              "offset": "0x2F0",
              "size": 32,
              "description": "Alias for channel 11 CTRL register"
            },
            "CH11_AL3_WRITE_ADDR": {
              "offset": "0x2F4",
              "size": 32,
              "description": "Alias for channel 11 WRITE_ADDR register"
            },
            "CH11_AL3_TRANS_COUNT": {
              "offset": "0x2F8",
              "size": 32,
              "description": "Alias for channel 11 TRANS_COUNT register"
            },
            "CH11_AL3_READ_ADDR_TRIG": {
              "offset": "0x2FC",
              "size": 32,
              "description": "Alias for channel 11 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH12_READ_ADDR": {
              "offset": "0x300",
              "size": 32,
              "description": "DMA Channel 12 Read Address pointer"
            },
            "CH12_WRITE_ADDR": {
              "offset": "0x304",
              "size": 32,
              "description": "DMA Channel 12 Write Address pointer"
            },
            "CH12_TRANS_COUNT": {
              "offset": "0x308",
              "size": 32,
              "description": "DMA Channel 12 Transfer Count"
            },
            "CH12_CTRL_TRIG": {
              "offset": "0x30C",
              "size": 32,
              "description": "DMA Channel 12 Control and Status"
            },
            "CH12_AL1_CTRL": {
              "offset": "0x310",
              "size": 32,
              "description": "Alias for channel 12 CTRL register"
            },
            "CH12_AL1_READ_ADDR": {
              "offset": "0x314",
              "size": 32,
              "description": "Alias for channel 12 READ_ADDR register"
            },
            "CH12_AL1_WRITE_ADDR": {
              "offset": "0x318",
              "size": 32,
              "description": "Alias for channel 12 WRITE_ADDR register"
            },
            "CH12_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x31C",
              "size": 32,
              "description": "Alias for channel 12 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH12_AL2_CTRL": {
              "offset": "0x320",
              "size": 32,
              "description": "Alias for channel 12 CTRL register"
            },
            "CH12_AL2_TRANS_COUNT": {
              "offset": "0x324",
              "size": 32,
              "description": "Alias for channel 12 TRANS_COUNT register"
            },
            "CH12_AL2_READ_ADDR": {
              "offset": "0x328",
              "size": 32,
              "description": "Alias for channel 12 READ_ADDR register"
            },
            "CH12_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x32C",
              "size": 32,
              "description": "Alias for channel 12 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH12_AL3_CTRL": {
              "offset": "0x330",
              "size": 32,
              "description": "Alias for channel 12 CTRL register"
            },
            "CH12_AL3_WRITE_ADDR": {
              "offset": "0x334",
              "size": 32,
              "description": "Alias for channel 12 WRITE_ADDR register"
            },
            "CH12_AL3_TRANS_COUNT": {
              "offset": "0x338",
              "size": 32,
              "description": "Alias for channel 12 TRANS_COUNT register"
            },
            "CH12_AL3_READ_ADDR_TRIG": {
              "offset": "0x33C",
              "size": 32,
              "description": "Alias for channel 12 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH13_READ_ADDR": {
              "offset": "0x340",
              "size": 32,
              "description": "DMA Channel 13 Read Address pointer"
            },
            "CH13_WRITE_ADDR": {
              "offset": "0x344",
              "size": 32,
              "description": "DMA Channel 13 Write Address pointer"
            },
            "CH13_TRANS_COUNT": {
              "offset": "0x348",
              "size": 32,
              "description": "DMA Channel 13 Transfer Count"
            },
            "CH13_CTRL_TRIG": {
              "offset": "0x34C",
              "size": 32,
              "description": "DMA Channel 13 Control and Status"
            },
            "CH13_AL1_CTRL": {
              "offset": "0x350",
              "size": 32,
              "description": "Alias for channel 13 CTRL register"
            },
            "CH13_AL1_READ_ADDR": {
              "offset": "0x354",
              "size": 32,
              "description": "Alias for channel 13 READ_ADDR register"
            },
            "CH13_AL1_WRITE_ADDR": {
              "offset": "0x358",
              "size": 32,
              "description": "Alias for channel 13 WRITE_ADDR register"
            },
            "CH13_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x35C",
              "size": 32,
              "description": "Alias for channel 13 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH13_AL2_CTRL": {
              "offset": "0x360",
              "size": 32,
              "description": "Alias for channel 13 CTRL register"
            },
            "CH13_AL2_TRANS_COUNT": {
              "offset": "0x364",
              "size": 32,
              "description": "Alias for channel 13 TRANS_COUNT register"
            },
            "CH13_AL2_READ_ADDR": {
              "offset": "0x368",
              "size": 32,
              "description": "Alias for channel 13 READ_ADDR register"
            },
            "CH13_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x36C",
              "size": 32,
              "description": "Alias for channel 13 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH13_AL3_CTRL": {
              "offset": "0x370",
              "size": 32,
              "description": "Alias for channel 13 CTRL register"
            },
            "CH13_AL3_WRITE_ADDR": {
              "offset": "0x374",
              "size": 32,
              "description": "Alias for channel 13 WRITE_ADDR register"
            },
            "CH13_AL3_TRANS_COUNT": {
              "offset": "0x378",
              "size": 32,
              "description": "Alias for channel 13 TRANS_COUNT register"
            },
            "CH13_AL3_READ_ADDR_TRIG": {
              "offset": "0x37C",
              "size": 32,
              "description": "Alias for channel 13 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH14_READ_ADDR": {
              "offset": "0x380",
              "size": 32,
              "description": "DMA Channel 14 Read Address pointer"
            },
            "CH14_WRITE_ADDR": {
              "offset": "0x384",
              "size": 32,
              "description": "DMA Channel 14 Write Address pointer"
            },
            "CH14_TRANS_COUNT": {
              "offset": "0x388",
              "size": 32,
              "description": "DMA Channel 14 Transfer Count"
            },
            "CH14_CTRL_TRIG": {
              "offset": "0x38C",
              "size": 32,
              "description": "DMA Channel 14 Control and Status"
            },
            "CH14_AL1_CTRL": {
              "offset": "0x390",
              "size": 32,
              "description": "Alias for channel 14 CTRL register"
            },
            "CH14_AL1_READ_ADDR": {
              "offset": "0x394",
              "size": 32,
              "description": "Alias for channel 14 READ_ADDR register"
            },
            "CH14_AL1_WRITE_ADDR": {
              "offset": "0x398",
              "size": 32,
              "description": "Alias for channel 14 WRITE_ADDR register"
            },
            "CH14_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x39C",
              "size": 32,
              "description": "Alias for channel 14 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH14_AL2_CTRL": {
              "offset": "0x3A0",
              "size": 32,
              "description": "Alias for channel 14 CTRL register"
            },
            "CH14_AL2_TRANS_COUNT": {
              "offset": "0x3A4",
              "size": 32,
              "description": "Alias for channel 14 TRANS_COUNT register"
            },
            "CH14_AL2_READ_ADDR": {
              "offset": "0x3A8",
              "size": 32,
              "description": "Alias for channel 14 READ_ADDR register"
            },
            "CH14_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x3AC",
              "size": 32,
              "description": "Alias for channel 14 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH14_AL3_CTRL": {
              "offset": "0x3B0",
              "size": 32,
              "description": "Alias for channel 14 CTRL register"
            },
            "CH14_AL3_WRITE_ADDR": {
              "offset": "0x3B4",
              "size": 32,
              "description": "Alias for channel 14 WRITE_ADDR register"
            },
            "CH14_AL3_TRANS_COUNT": {
              "offset": "0x3B8",
              "size": 32,
              "description": "Alias for channel 14 TRANS_COUNT register"
            },
            "CH14_AL3_READ_ADDR_TRIG": {
              "offset": "0x3BC",
              "size": 32,
              "description": "Alias for channel 14 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH15_READ_ADDR": {
              "offset": "0x3C0",
              "size": 32,
              "description": "DMA Channel 15 Read Address pointer"
            },
            "CH15_WRITE_ADDR": {
              "offset": "0x3C4",
              "size": 32,
              "description": "DMA Channel 15 Write Address pointer"
            },
            "CH15_TRANS_COUNT": {
              "offset": "0x3C8",
              "size": 32,
              "description": "DMA Channel 15 Transfer Count"
            },
            "CH15_CTRL_TRIG": {
              "offset": "0x3CC",
              "size": 32,
              "description": "DMA Channel 15 Control and Status"
            },
            "CH15_AL1_CTRL": {
              "offset": "0x3D0",
              "size": 32,
              "description": "Alias for channel 15 CTRL register"
            },
            "CH15_AL1_READ_ADDR": {
              "offset": "0x3D4",
              "size": 32,
              "description": "Alias for channel 15 READ_ADDR register"
            },
            "CH15_AL1_WRITE_ADDR": {
              "offset": "0x3D8",
              "size": 32,
              "description": "Alias for channel 15 WRITE_ADDR register"
            },
            "CH15_AL1_TRANS_COUNT_TRIG": {
              "offset": "0x3DC",
              "size": 32,
              "description": "Alias for channel 15 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH15_AL2_CTRL": {
              "offset": "0x3E0",
              "size": 32,
              "description": "Alias for channel 15 CTRL register"
            },
            "CH15_AL2_TRANS_COUNT": {
              "offset": "0x3E4",
              "size": 32,
              "description": "Alias for channel 15 TRANS_COUNT register"
            },
            "CH15_AL2_READ_ADDR": {
              "offset": "0x3E8",
              "size": 32,
              "description": "Alias for channel 15 READ_ADDR register"
            },
            "CH15_AL2_WRITE_ADDR_TRIG": {
              "offset": "0x3EC",
              "size": 32,
              "description": "Alias for channel 15 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "CH15_AL3_CTRL": {
              "offset": "0x3F0",
              "size": 32,
              "description": "Alias for channel 15 CTRL register"
            },
            "CH15_AL3_WRITE_ADDR": {
              "offset": "0x3F4",
              "size": 32,
              "description": "Alias for channel 15 WRITE_ADDR register"
            },
            "CH15_AL3_TRANS_COUNT": {
              "offset": "0x3F8",
              "size": 32,
              "description": "Alias for channel 15 TRANS_COUNT register"
            },
            "CH15_AL3_READ_ADDR_TRIG": {
              "offset": "0x3FC",
              "size": 32,
              "description": "Alias for channel 15 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."
            },
            "INTR": {
              "offset": "0x400",
              "size": 32,
              "description": "Interrupt Status (raw)"
            },
            "INTE0": {
              "offset": "0x404",
              "size": 32,
              "description": "Interrupt Enables for IRQ 0"
            },
            "INTF0": {
              "offset": "0x408",
              "size": 32,
              "description": "Force Interrupts"
            },
            "INTS0": {
              "offset": "0x40C",
              "size": 32,
              "description": "Interrupt Status for IRQ 0"
            },
            "INTR1": {
              "offset": "0x410",
              "size": 32,
              "description": "Interrupt Status (raw)"
            },
            "INTE1": {
              "offset": "0x414",
              "size": 32,
              "description": "Interrupt Enables for IRQ 1"
            },
            "INTF1": {
              "offset": "0x418",
              "size": 32,
              "description": "Force Interrupts"
            },
            "INTS1": {
              "offset": "0x41C",
              "size": 32,
              "description": "Interrupt Status for IRQ 1"
            },
            "INTR2": {
              "offset": "0x420",
              "size": 32,
              "description": "Interrupt Status (raw)"
            },
            "INTE2": {
              "offset": "0x424",
              "size": 32,
              "description": "Interrupt Enables for IRQ 2"
            },
            "INTF2": {
              "offset": "0x428",
              "size": 32,
              "description": "Force Interrupts"
            },
            "INTS2": {
              "offset": "0x42C",
              "size": 32,
              "description": "Interrupt Status for IRQ 2"
            },
            "INTR3": {
              "offset": "0x430",
              "size": 32,
              "description": "Interrupt Status (raw)"
            },
            "INTE3": {
              "offset": "0x434",
              "size": 32,
              "description": "Interrupt Enables for IRQ 3"
            },
            "INTF3": {
              "offset": "0x438",
              "size": 32,
              "description": "Force Interrupts"
            },
            "INTS3": {
              "offset": "0x43C",
              "size": 32,
              "description": "Interrupt Status for IRQ 3"
            },
            "TIMER0": {
              "offset": "0x440",
              "size": 32,
              "description": "Pacing (X/Y) fractional timer \n                    The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less."
            },
            "TIMER1": {
              "offset": "0x444",
              "size": 32,
              "description": "Pacing (X/Y) fractional timer \n                    The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less."
            },
            "TIMER2": {
              "offset": "0x448",
              "size": 32,
              "description": "Pacing (X/Y) fractional timer \n                    The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less."
            },
            "TIMER3": {
              "offset": "0x44C",
              "size": 32,
              "description": "Pacing (X/Y) fractional timer \n                    The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less."
            },
            "MULTI_CHAN_TRIGGER": {
              "offset": "0x450",
              "size": 32,
              "description": "Trigger one or more channels simultaneously"
            },
            "SNIFF_CTRL": {
              "offset": "0x454",
              "size": 32,
              "description": "Sniffer Control"
            },
            "SNIFF_DATA": {
              "offset": "0x458",
              "size": 32,
              "description": "Data accumulator for sniff hardware"
            },
            "FIFO_LEVELS": {
              "offset": "0x460",
              "size": 32,
              "description": "Debug RAF, WAF, TDF levels"
            },
            "CHAN_ABORT": {
              "offset": "0x464",
              "size": 32,
              "description": "Abort an in-progress transfer sequence on one or more channels"
            },
            "N_CHANNELS": {
              "offset": "0x468",
              "size": 32,
              "description": "The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area."
            },
            "SECCFG_CH0": {
              "offset": "0x480",
              "size": 32,
              "description": "Security configuration for channel 0. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH1": {
              "offset": "0x484",
              "size": 32,
              "description": "Security configuration for channel 1. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH2": {
              "offset": "0x488",
              "size": 32,
              "description": "Security configuration for channel 2. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH3": {
              "offset": "0x48C",
              "size": 32,
              "description": "Security configuration for channel 3. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH4": {
              "offset": "0x490",
              "size": 32,
              "description": "Security configuration for channel 4. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH5": {
              "offset": "0x494",
              "size": 32,
              "description": "Security configuration for channel 5. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH6": {
              "offset": "0x498",
              "size": 32,
              "description": "Security configuration for channel 6. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH7": {
              "offset": "0x49C",
              "size": 32,
              "description": "Security configuration for channel 7. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH8": {
              "offset": "0x4A0",
              "size": 32,
              "description": "Security configuration for channel 8. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH9": {
              "offset": "0x4A4",
              "size": 32,
              "description": "Security configuration for channel 9. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH10": {
              "offset": "0x4A8",
              "size": 32,
              "description": "Security configuration for channel 10. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH11": {
              "offset": "0x4AC",
              "size": 32,
              "description": "Security configuration for channel 11. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH12": {
              "offset": "0x4B0",
              "size": 32,
              "description": "Security configuration for channel 12. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH13": {
              "offset": "0x4B4",
              "size": 32,
              "description": "Security configuration for channel 13. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH14": {
              "offset": "0x4B8",
              "size": 32,
              "description": "Security configuration for channel 14. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_CH15": {
              "offset": "0x4BC",
              "size": 32,
              "description": "Security configuration for channel 15. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses.\n\n                    If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel.\n\n                    This register automatically locks down (becomes read-only) once software starts to configure the channel.\n\n                    This register is world-readable, but is writable only from a Secure, Privileged context."
            },
            "SECCFG_IRQ0": {
              "offset": "0x4C0",
              "size": 32,
              "description": "Security configuration for IRQ 0. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags."
            },
            "SECCFG_IRQ1": {
              "offset": "0x4C4",
              "size": 32,
              "description": "Security configuration for IRQ 1. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags."
            },
            "SECCFG_IRQ2": {
              "offset": "0x4C8",
              "size": 32,
              "description": "Security configuration for IRQ 2. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags."
            },
            "SECCFG_IRQ3": {
              "offset": "0x4CC",
              "size": 32,
              "description": "Security configuration for IRQ 3. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags."
            },
            "SECCFG_MISC": {
              "offset": "0x4D0",
              "size": 32,
              "description": "Miscellaneous security configuration"
            },
            "MPU_CTRL": {
              "offset": "0x500",
              "size": 32,
              "description": "Control register for DMA MPU. Accessible only from a Privileged context."
            },
            "MPU_BAR0": {
              "offset": "0x504",
              "size": 32,
              "description": "Base address register for MPU region 0. Writable only from a Secure, Privileged context."
            },
            "MPU_LAR0": {
              "offset": "0x508",
              "size": 32,
              "description": "Limit address register for MPU region 0. Writable only from a Secure, Privileged context, with the exception of the P bit."
            },
            "MPU_BAR1": {
              "offset": "0x50C",
              "size": 32,
              "description": "Base address register for MPU region 1. Writable only from a Secure, Privileged context."
            },
            "MPU_LAR1": {
              "offset": "0x510",
              "size": 32,
              "description": "Limit address register for MPU region 1. Writable only from a Secure, Privileged context, with the exception of the P bit."
            },
            "MPU_BAR2": {
              "offset": "0x514",
              "size": 32,
              "description": "Base address register for MPU region 2. Writable only from a Secure, Privileged context."
            },
            "MPU_LAR2": {
              "offset": "0x518",
              "size": 32,
              "description": "Limit address register for MPU region 2. Writable only from a Secure, Privileged context, with the exception of the P bit."
            },
            "MPU_BAR3": {
              "offset": "0x51C",
              "size": 32,
              "description": "Base address register for MPU region 3. Writable only from a Secure, Privileged context."
            },
            "MPU_LAR3": {
              "offset": "0x520",
              "size": 32,
              "description": "Limit address register for MPU region 3. Writable only from a Secure, Privileged context, with the exception of the P bit."
            },
            "MPU_BAR4": {
              "offset": "0x524",
              "size": 32,
              "description": "Base address register for MPU region 4. Writable only from a Secure, Privileged context."
            },
            "MPU_LAR4": {
              "offset": "0x528",
              "size": 32,
              "description": "Limit address register for MPU region 4. Writable only from a Secure, Privileged context, with the exception of the P bit."
            },
            "MPU_BAR5": {
              "offset": "0x52C",
              "size": 32,
              "description": "Base address register for MPU region 5. Writable only from a Secure, Privileged context."
            },
            "MPU_LAR5": {
              "offset": "0x530",
              "size": 32,
              "description": "Limit address register for MPU region 5. Writable only from a Secure, Privileged context, with the exception of the P bit."
            },
            "MPU_BAR6": {
              "offset": "0x534",
              "size": 32,
              "description": "Base address register for MPU region 6. Writable only from a Secure, Privileged context."
            },
            "MPU_LAR6": {
              "offset": "0x538",
              "size": 32,
              "description": "Limit address register for MPU region 6. Writable only from a Secure, Privileged context, with the exception of the P bit."
            },
            "MPU_BAR7": {
              "offset": "0x53C",
              "size": 32,
              "description": "Base address register for MPU region 7. Writable only from a Secure, Privileged context."
            },
            "MPU_LAR7": {
              "offset": "0x540",
              "size": 32,
              "description": "Limit address register for MPU region 7. Writable only from a Secure, Privileged context, with the exception of the P bit."
            },
            "CH0_DBG_CTDREQ": {
              "offset": "0x800",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH0_DBG_TCR": {
              "offset": "0x804",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH1_DBG_CTDREQ": {
              "offset": "0x840",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH1_DBG_TCR": {
              "offset": "0x844",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH2_DBG_CTDREQ": {
              "offset": "0x880",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH2_DBG_TCR": {
              "offset": "0x884",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH3_DBG_CTDREQ": {
              "offset": "0x8C0",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH3_DBG_TCR": {
              "offset": "0x8C4",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH4_DBG_CTDREQ": {
              "offset": "0x900",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH4_DBG_TCR": {
              "offset": "0x904",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH5_DBG_CTDREQ": {
              "offset": "0x940",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH5_DBG_TCR": {
              "offset": "0x944",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH6_DBG_CTDREQ": {
              "offset": "0x980",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH6_DBG_TCR": {
              "offset": "0x984",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH7_DBG_CTDREQ": {
              "offset": "0x9C0",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH7_DBG_TCR": {
              "offset": "0x9C4",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH8_DBG_CTDREQ": {
              "offset": "0xA00",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH8_DBG_TCR": {
              "offset": "0xA04",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH9_DBG_CTDREQ": {
              "offset": "0xA40",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH9_DBG_TCR": {
              "offset": "0xA44",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH10_DBG_CTDREQ": {
              "offset": "0xA80",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH10_DBG_TCR": {
              "offset": "0xA84",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH11_DBG_CTDREQ": {
              "offset": "0xAC0",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH11_DBG_TCR": {
              "offset": "0xAC4",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH12_DBG_CTDREQ": {
              "offset": "0xB00",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH12_DBG_TCR": {
              "offset": "0xB04",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH13_DBG_CTDREQ": {
              "offset": "0xB40",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH13_DBG_TCR": {
              "offset": "0xB44",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH14_DBG_CTDREQ": {
              "offset": "0xB80",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH14_DBG_TCR": {
              "offset": "0xB84",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            },
            "CH15_DBG_CTDREQ": {
              "offset": "0xBC0",
              "size": 32,
              "description": "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."
            },
            "CH15_DBG_TCR": {
              "offset": "0xBC4",
              "size": 32,
              "description": "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"
            }
          }
        },
        "TIM": {
          "instances": [
            {
              "name": "TIMER0",
              "base": "0x400B0000",
              "irq": 0
            },
            {
              "name": "TIMER1",
              "base": "0x400B8000",
              "irq": 4
            }
          ],
          "registers": {
            "TIMEHW": {
              "offset": "0x00",
              "size": 32,
              "description": "Write to bits 63:32 of time always write timelw before timehw"
            },
            "TIMELW": {
              "offset": "0x04",
              "size": 32,
              "description": "Write to bits 31:0 of time writes do not get copied to time until timehw is written"
            },
            "TIMEHR": {
              "offset": "0x08",
              "size": 32,
              "description": "Read from bits 63:32 of time always read timelr before timehr"
            },
            "TIMELR": {
              "offset": "0x0C",
              "size": 32,
              "description": "Read from bits 31:0 of time"
            },
            "ALARM0": {
              "offset": "0x10",
              "size": 32,
              "description": "Arm alarm 0, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register."
            },
            "ALARM1": {
              "offset": "0x14",
              "size": 32,
              "description": "Arm alarm 1, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register."
            },
            "ALARM2": {
              "offset": "0x18",
              "size": 32,
              "description": "Arm alarm 2, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register."
            },
            "ALARM3": {
              "offset": "0x1C",
              "size": 32,
              "description": "Arm alarm 3, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register."
            },
            "ARMED": {
              "offset": "0x20",
              "size": 32,
              "description": "Indicates the armed/disarmed status of each alarm. A write to the corresponding ALARMx register arms the alarm. Alarms automatically disarm upon firing, but writing ones here will disarm immediately without waiting to fire."
            },
            "TIMERAWH": {
              "offset": "0x24",
              "size": 32,
              "description": "Raw read from bits 63:32 of time (no side effects)"
            },
            "TIMERAWL": {
              "offset": "0x28",
              "size": 32,
              "description": "Raw read from bits 31:0 of time (no side effects)"
            },
            "DBGPAUSE": {
              "offset": "0x2C",
              "size": 32,
              "description": "Set bits high to enable pause when the corresponding debug ports are active"
            },
            "PAUSE": {
              "offset": "0x30",
              "size": 32,
              "description": "Set high to pause the timer"
            },
            "LOCKED": {
              "offset": "0x34",
              "size": 32,
              "description": "Set locked bit to disable write access to timer Once set, cannot be cleared (without a reset)"
            },
            "SOURCE": {
              "offset": "0x38",
              "size": 32,
              "description": "Selects the source for the timer. Defaults to the normal tick configured in the ticks block (typically configured to 1 microsecond). Writing to 1 will ignore the tick and count clk_sys cycles instead."
            },
            "INTR": {
              "offset": "0x3C",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTE": {
              "offset": "0x40",
              "size": 32,
              "description": "Interrupt Enable"
            },
            "INTF": {
              "offset": "0x44",
              "size": 32,
              "description": "Interrupt Force"
            },
            "INTS": {
              "offset": "0x48",
              "size": 32,
              "description": "Interrupt status after masking & forcing"
            }
          }
        },
        "PWM": {
          "instances": [
            {
              "name": "PWM",
              "base": "0x400A8000",
              "irq": 8
            }
          ],
          "registers": {
            "CH0_CSR": {
              "offset": "0x00",
              "size": 32,
              "description": "Control and status register"
            },
            "CH0_DIV": {
              "offset": "0x04",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH0_CTR": {
              "offset": "0x08",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH0_CC": {
              "offset": "0x0C",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH0_TOP": {
              "offset": "0x10",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH1_CSR": {
              "offset": "0x14",
              "size": 32,
              "description": "Control and status register"
            },
            "CH1_DIV": {
              "offset": "0x18",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH1_CTR": {
              "offset": "0x1C",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH1_CC": {
              "offset": "0x20",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH1_TOP": {
              "offset": "0x24",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH2_CSR": {
              "offset": "0x28",
              "size": 32,
              "description": "Control and status register"
            },
            "CH2_DIV": {
              "offset": "0x2C",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH2_CTR": {
              "offset": "0x30",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH2_CC": {
              "offset": "0x34",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH2_TOP": {
              "offset": "0x38",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH3_CSR": {
              "offset": "0x3C",
              "size": 32,
              "description": "Control and status register"
            },
            "CH3_DIV": {
              "offset": "0x40",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH3_CTR": {
              "offset": "0x44",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH3_CC": {
              "offset": "0x48",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH3_TOP": {
              "offset": "0x4C",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH4_CSR": {
              "offset": "0x50",
              "size": 32,
              "description": "Control and status register"
            },
            "CH4_DIV": {
              "offset": "0x54",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH4_CTR": {
              "offset": "0x58",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH4_CC": {
              "offset": "0x5C",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH4_TOP": {
              "offset": "0x60",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH5_CSR": {
              "offset": "0x64",
              "size": 32,
              "description": "Control and status register"
            },
            "CH5_DIV": {
              "offset": "0x68",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH5_CTR": {
              "offset": "0x6C",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH5_CC": {
              "offset": "0x70",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH5_TOP": {
              "offset": "0x74",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH6_CSR": {
              "offset": "0x78",
              "size": 32,
              "description": "Control and status register"
            },
            "CH6_DIV": {
              "offset": "0x7C",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH6_CTR": {
              "offset": "0x80",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH6_CC": {
              "offset": "0x84",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH6_TOP": {
              "offset": "0x88",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH7_CSR": {
              "offset": "0x8C",
              "size": 32,
              "description": "Control and status register"
            },
            "CH7_DIV": {
              "offset": "0x90",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH7_CTR": {
              "offset": "0x94",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH7_CC": {
              "offset": "0x98",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH7_TOP": {
              "offset": "0x9C",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH8_CSR": {
              "offset": "0xA0",
              "size": 32,
              "description": "Control and status register"
            },
            "CH8_DIV": {
              "offset": "0xA4",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH8_CTR": {
              "offset": "0xA8",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH8_CC": {
              "offset": "0xAC",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH8_TOP": {
              "offset": "0xB0",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH9_CSR": {
              "offset": "0xB4",
              "size": 32,
              "description": "Control and status register"
            },
            "CH9_DIV": {
              "offset": "0xB8",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH9_CTR": {
              "offset": "0xBC",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH9_CC": {
              "offset": "0xC0",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH9_TOP": {
              "offset": "0xC4",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH10_CSR": {
              "offset": "0xC8",
              "size": 32,
              "description": "Control and status register"
            },
            "CH10_DIV": {
              "offset": "0xCC",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH10_CTR": {
              "offset": "0xD0",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH10_CC": {
              "offset": "0xD4",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH10_TOP": {
              "offset": "0xD8",
              "size": 32,
              "description": "Counter wrap value"
            },
            "CH11_CSR": {
              "offset": "0xDC",
              "size": 32,
              "description": "Control and status register"
            },
            "CH11_DIV": {
              "offset": "0xE0",
              "size": 32,
              "description": "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."
            },
            "CH11_CTR": {
              "offset": "0xE4",
              "size": 32,
              "description": "Direct access to the PWM counter"
            },
            "CH11_CC": {
              "offset": "0xE8",
              "size": 32,
              "description": "Counter compare values"
            },
            "CH11_TOP": {
              "offset": "0xEC",
              "size": 32,
              "description": "Counter wrap value"
            },
            "EN": {
              "offset": "0xF0",
              "size": 32,
              "description": "This register aliases the CSR_EN bits for all channels. \n                    Writing to this register allows multiple channels to be enabled \n                    or disabled simultaneously, so they can run in perfect sync. \n                    For each channel, there is only one physical EN register bit, \n                    which can be accessed through here or CHx_CSR."
            },
            "INTR": {
              "offset": "0xF4",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "IRQ0_INTE": {
              "offset": "0xF8",
              "size": 32,
              "description": "Interrupt Enable for irq0"
            },
            "IRQ0_INTF": {
              "offset": "0xFC",
              "size": 32,
              "description": "Interrupt Force for irq0"
            },
            "IRQ0_INTS": {
              "offset": "0x100",
              "size": 32,
              "description": "Interrupt status after masking & forcing for irq0"
            },
            "IRQ1_INTE": {
              "offset": "0x104",
              "size": 32,
              "description": "Interrupt Enable for irq1"
            },
            "IRQ1_INTF": {
              "offset": "0x108",
              "size": 32,
              "description": "Interrupt Force for irq1"
            },
            "IRQ1_INTS": {
              "offset": "0x10C",
              "size": 32,
              "description": "Interrupt status after masking & forcing for irq1"
            }
          }
        },
        "ADC": {
          "instances": [
            {
              "name": "ADC",
              "base": "0x400A0000",
              "irq": 35
            }
          ],
          "registers": {
            "CS": {
              "offset": "0x00",
              "size": 32,
              "description": "ADC Control and Status"
            },
            "RESULT": {
              "offset": "0x04",
              "size": 32,
              "description": "Result of most recent ADC conversion"
            },
            "FCS": {
              "offset": "0x08",
              "size": 32,
              "description": "FIFO control and status"
            },
            "FIFO": {
              "offset": "0x0C",
              "size": 32,
              "description": "Conversion result FIFO"
            },
            "DIV": {
              "offset": "0x10",
              "size": 32,
              "description": "Clock divider. If non-zero, CS_START_MANY will start conversions \n                    at regular intervals rather than back-to-back. \n                    The divider is reset when either of these fields are written. \n                    Total period is 1 + INT + FRAC / 256"
            },
            "INTR": {
              "offset": "0x14",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTE": {
              "offset": "0x18",
              "size": 32,
              "description": "Interrupt Enable"
            },
            "INTF": {
              "offset": "0x1C",
              "size": 32,
              "description": "Interrupt Force"
            },
            "INTS": {
              "offset": "0x20",
              "size": 32,
              "description": "Interrupt status after masking & forcing"
            }
          }
        },
        "I2C": {
          "instances": [
            {
              "name": "I2C0",
              "base": "0x40090000",
              "irq": 36
            },
            {
              "name": "I2C1",
              "base": "0x40098000",
              "irq": 37
            }
          ],
          "registers": {
            "IC_CON": {
              "offset": "0x00",
              "size": 32,
              "description": "I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                    Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only."
            },
            "IC_TAR": {
              "offset": "0x04",
              "size": 32,
              "description": "I2C Target Address Register\n\n                    This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n\n                    Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only."
            },
            "IC_SAR": {
              "offset": "0x08",
              "size": 32,
              "description": "I2C Slave Address Register"
            },
            "IC_DATA_CMD": {
              "offset": "0x10",
              "size": 32,
              "description": "I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n\n                    The size of the register changes as follows:\n\n                    Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging."
            },
            "IC_SS_SCL_HCNT": {
              "offset": "0x14",
              "size": 32,
              "description": "Standard Speed I2C Clock SCL High Count Register"
            },
            "IC_SS_SCL_LCNT": {
              "offset": "0x18",
              "size": 32,
              "description": "Standard Speed I2C Clock SCL Low Count Register"
            },
            "IC_FS_SCL_HCNT": {
              "offset": "0x1C",
              "size": 32,
              "description": "Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register"
            },
            "IC_FS_SCL_LCNT": {
              "offset": "0x20",
              "size": 32,
              "description": "Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register"
            },
            "IC_INTR_STAT": {
              "offset": "0x2C",
              "size": 32,
              "description": "I2C Interrupt Status Register\n\n                    Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register."
            },
            "IC_INTR_MASK": {
              "offset": "0x30",
              "size": 32,
              "description": "I2C Interrupt Mask Register.\n\n                    These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt."
            },
            "IC_RAW_INTR_STAT": {
              "offset": "0x34",
              "size": 32,
              "description": "I2C Raw Interrupt Status Register\n\n                    Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c."
            },
            "IC_RX_TL": {
              "offset": "0x38",
              "size": 32,
              "description": "I2C Receive FIFO Threshold Register"
            },
            "IC_TX_TL": {
              "offset": "0x3C",
              "size": 32,
              "description": "I2C Transmit FIFO Threshold Register"
            },
            "IC_CLR_INTR": {
              "offset": "0x40",
              "size": 32,
              "description": "Clear Combined and Individual Interrupt Register"
            },
            "IC_CLR_RX_UNDER": {
              "offset": "0x44",
              "size": 32,
              "description": "Clear RX_UNDER Interrupt Register"
            },
            "IC_CLR_RX_OVER": {
              "offset": "0x48",
              "size": 32,
              "description": "Clear RX_OVER Interrupt Register"
            },
            "IC_CLR_TX_OVER": {
              "offset": "0x4C",
              "size": 32,
              "description": "Clear TX_OVER Interrupt Register"
            },
            "IC_CLR_RD_REQ": {
              "offset": "0x50",
              "size": 32,
              "description": "Clear RD_REQ Interrupt Register"
            },
            "IC_CLR_TX_ABRT": {
              "offset": "0x54",
              "size": 32,
              "description": "Clear TX_ABRT Interrupt Register"
            },
            "IC_CLR_RX_DONE": {
              "offset": "0x58",
              "size": 32,
              "description": "Clear RX_DONE Interrupt Register"
            },
            "IC_CLR_ACTIVITY": {
              "offset": "0x5C",
              "size": 32,
              "description": "Clear ACTIVITY Interrupt Register"
            },
            "IC_CLR_STOP_DET": {
              "offset": "0x60",
              "size": 32,
              "description": "Clear STOP_DET Interrupt Register"
            },
            "IC_CLR_START_DET": {
              "offset": "0x64",
              "size": 32,
              "description": "Clear START_DET Interrupt Register"
            },
            "IC_CLR_GEN_CALL": {
              "offset": "0x68",
              "size": 32,
              "description": "Clear GEN_CALL Interrupt Register"
            },
            "IC_ENABLE": {
              "offset": "0x6C",
              "size": 32,
              "description": "I2C Enable Register"
            },
            "IC_STATUS": {
              "offset": "0x70",
              "size": 32,
              "description": "I2C Status Register\n\n                    This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n\n                    When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0"
            },
            "IC_TXFLR": {
              "offset": "0x74",
              "size": 32,
              "description": "I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO."
            },
            "IC_RXFLR": {
              "offset": "0x78",
              "size": 32,
              "description": "I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO."
            },
            "IC_SDA_HOLD": {
              "offset": "0x7C",
              "size": 32,
              "description": "I2C SDA Hold Time Length Register\n\n                    The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n                    The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n\n                    Writes to this register succeed only when IC_ENABLE[0]=0.\n\n                    The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented.\n\n                    The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles."
            },
            "IC_TX_ABRT_SOURCE": {
              "offset": "0x80",
              "size": 32,
              "description": "I2C Transmit Abort Source Register\n\n                    This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n\n                    Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted."
            },
            "IC_SLV_DATA_NACK_ONLY": {
              "offset": "0x84",
              "size": 32,
              "description": "Generate Slave Data NACK Register\n\n                    The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n\n                    A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit."
            },
            "IC_DMA_CR": {
              "offset": "0x88",
              "size": 32,
              "description": "DMA Control Register\n\n                    The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE."
            },
            "IC_DMA_TDLR": {
              "offset": "0x8C",
              "size": 32,
              "description": "DMA Transmit Data Level Register"
            },
            "IC_DMA_RDLR": {
              "offset": "0x90",
              "size": 32,
              "description": "I2C Receive Data Level Register"
            },
            "IC_SDA_SETUP": {
              "offset": "0x94",
              "size": 32,
              "description": "I2C SDA Setup Register\n\n                    This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n\n                    Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n                    Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter."
            },
            "IC_ACK_GENERAL_CALL": {
              "offset": "0x98",
              "size": 32,
              "description": "I2C ACK General Call Register\n\n                    The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n\n                    This register is applicable only when the DW_apb_i2c is in slave mode."
            },
            "IC_ENABLE_STATUS": {
              "offset": "0x9C",
              "size": 32,
              "description": "I2C Enable Status Register\n\n                    The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n\n                    If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n\n                    If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n\n                    Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities."
            },
            "IC_FS_SPKLEN": {
              "offset": "0xA0",
              "size": 32,
              "description": "I2C SS, FS or FM+ spike suppression limit\n\n                    This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1."
            },
            "IC_CLR_RESTART_DET": {
              "offset": "0xA8",
              "size": 32,
              "description": "Clear RESTART_DET Interrupt Register"
            },
            "IC_COMP_PARAM_1": {
              "offset": "0xF4",
              "size": 32,
              "description": "Component Parameter Register 1\n\n                    Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters"
            },
            "IC_COMP_VERSION": {
              "offset": "0xF8",
              "size": 32,
              "description": "I2C Component Version Register"
            },
            "IC_COMP_TYPE": {
              "offset": "0xFC",
              "size": 32,
              "description": "I2C Component Type Register"
            }
          }
        },
        "PIO0": {
          "instances": [
            {
              "name": "PIO0",
              "base": "0x50200000",
              "irq": 15
            }
          ],
          "registers": {
            "CTRL": {
              "offset": "0x00",
              "size": 32,
              "description": "PIO control register"
            },
            "FSTAT": {
              "offset": "0x04",
              "size": 32,
              "description": "FIFO status register"
            },
            "FDEBUG": {
              "offset": "0x08",
              "size": 32,
              "description": "FIFO debug register"
            },
            "FLEVEL": {
              "offset": "0x0C",
              "size": 32,
              "description": "FIFO levels"
            },
            "TXF0": {
              "offset": "0x10",
              "size": 32,
              "description": "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."
            },
            "TXF1": {
              "offset": "0x14",
              "size": 32,
              "description": "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."
            },
            "TXF2": {
              "offset": "0x18",
              "size": 32,
              "description": "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."
            },
            "TXF3": {
              "offset": "0x1C",
              "size": 32,
              "description": "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."
            },
            "RXF0": {
              "offset": "0x20",
              "size": 32,
              "description": "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."
            },
            "RXF1": {
              "offset": "0x24",
              "size": 32,
              "description": "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."
            },
            "RXF2": {
              "offset": "0x28",
              "size": 32,
              "description": "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."
            },
            "RXF3": {
              "offset": "0x2C",
              "size": 32,
              "description": "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."
            },
            "IRQ": {
              "offset": "0x30",
              "size": 32,
              "description": "State machine IRQ flags register. Write 1 to clear. There are eight state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There's no fixed association between flags and state machines -- any state machine can use any flag.\n\n                    Any of the eight flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. Any combination of the eight flags can also routed out to either of the two system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE."
            },
            "IRQ_FORCE": {
              "offset": "0x34",
              "size": 32,
              "description": "Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines."
            },
            "INPUT_SYNC_BYPASS": {
              "offset": "0x38",
              "size": 32,
              "description": "There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. \n                    0 -> input is synchronized (default) \n                    1 -> synchronizer is bypassed \n                    If in doubt, leave this register as all zeroes."
            },
            "DBG_PADOUT": {
              "offset": "0x3C",
              "size": 32,
              "description": "Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0."
            },
            "DBG_PADOE": {
              "offset": "0x40",
              "size": 32,
              "description": "Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0."
            },
            "DBG_CFGINFO": {
              "offset": "0x44",
              "size": 32,
              "description": "The PIO hardware has some free parameters that may vary between chip products. \n                    These should be provided in the chip datasheet, but are also exposed here."
            },
            "INSTR_MEM0": {
              "offset": "0x48",
              "size": 32,
              "description": "Write-only access to instruction memory location 0"
            },
            "INSTR_MEM1": {
              "offset": "0x4C",
              "size": 32,
              "description": "Write-only access to instruction memory location 1"
            },
            "INSTR_MEM2": {
              "offset": "0x50",
              "size": 32,
              "description": "Write-only access to instruction memory location 2"
            },
            "INSTR_MEM3": {
              "offset": "0x54",
              "size": 32,
              "description": "Write-only access to instruction memory location 3"
            },
            "INSTR_MEM4": {
              "offset": "0x58",
              "size": 32,
              "description": "Write-only access to instruction memory location 4"
            },
            "INSTR_MEM5": {
              "offset": "0x5C",
              "size": 32,
              "description": "Write-only access to instruction memory location 5"
            },
            "INSTR_MEM6": {
              "offset": "0x60",
              "size": 32,
              "description": "Write-only access to instruction memory location 6"
            },
            "INSTR_MEM7": {
              "offset": "0x64",
              "size": 32,
              "description": "Write-only access to instruction memory location 7"
            },
            "INSTR_MEM8": {
              "offset": "0x68",
              "size": 32,
              "description": "Write-only access to instruction memory location 8"
            },
            "INSTR_MEM9": {
              "offset": "0x6C",
              "size": 32,
              "description": "Write-only access to instruction memory location 9"
            },
            "INSTR_MEM10": {
              "offset": "0x70",
              "size": 32,
              "description": "Write-only access to instruction memory location 10"
            },
            "INSTR_MEM11": {
              "offset": "0x74",
              "size": 32,
              "description": "Write-only access to instruction memory location 11"
            },
            "INSTR_MEM12": {
              "offset": "0x78",
              "size": 32,
              "description": "Write-only access to instruction memory location 12"
            },
            "INSTR_MEM13": {
              "offset": "0x7C",
              "size": 32,
              "description": "Write-only access to instruction memory location 13"
            },
            "INSTR_MEM14": {
              "offset": "0x80",
              "size": 32,
              "description": "Write-only access to instruction memory location 14"
            },
            "INSTR_MEM15": {
              "offset": "0x84",
              "size": 32,
              "description": "Write-only access to instruction memory location 15"
            },
            "INSTR_MEM16": {
              "offset": "0x88",
              "size": 32,
              "description": "Write-only access to instruction memory location 16"
            },
            "INSTR_MEM17": {
              "offset": "0x8C",
              "size": 32,
              "description": "Write-only access to instruction memory location 17"
            },
            "INSTR_MEM18": {
              "offset": "0x90",
              "size": 32,
              "description": "Write-only access to instruction memory location 18"
            },
            "INSTR_MEM19": {
              "offset": "0x94",
              "size": 32,
              "description": "Write-only access to instruction memory location 19"
            },
            "INSTR_MEM20": {
              "offset": "0x98",
              "size": 32,
              "description": "Write-only access to instruction memory location 20"
            },
            "INSTR_MEM21": {
              "offset": "0x9C",
              "size": 32,
              "description": "Write-only access to instruction memory location 21"
            },
            "INSTR_MEM22": {
              "offset": "0xA0",
              "size": 32,
              "description": "Write-only access to instruction memory location 22"
            },
            "INSTR_MEM23": {
              "offset": "0xA4",
              "size": 32,
              "description": "Write-only access to instruction memory location 23"
            },
            "INSTR_MEM24": {
              "offset": "0xA8",
              "size": 32,
              "description": "Write-only access to instruction memory location 24"
            },
            "INSTR_MEM25": {
              "offset": "0xAC",
              "size": 32,
              "description": "Write-only access to instruction memory location 25"
            },
            "INSTR_MEM26": {
              "offset": "0xB0",
              "size": 32,
              "description": "Write-only access to instruction memory location 26"
            },
            "INSTR_MEM27": {
              "offset": "0xB4",
              "size": 32,
              "description": "Write-only access to instruction memory location 27"
            },
            "INSTR_MEM28": {
              "offset": "0xB8",
              "size": 32,
              "description": "Write-only access to instruction memory location 28"
            },
            "INSTR_MEM29": {
              "offset": "0xBC",
              "size": 32,
              "description": "Write-only access to instruction memory location 29"
            },
            "INSTR_MEM30": {
              "offset": "0xC0",
              "size": 32,
              "description": "Write-only access to instruction memory location 30"
            },
            "INSTR_MEM31": {
              "offset": "0xC4",
              "size": 32,
              "description": "Write-only access to instruction memory location 31"
            },
            "SM0_CLKDIV": {
              "offset": "0xC8",
              "size": 32,
              "description": "Clock divisor register for state machine 0 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"
            },
            "SM0_EXECCTRL": {
              "offset": "0xCC",
              "size": 32,
              "description": "Execution/behavioural settings for state machine 0"
            },
            "SM0_SHIFTCTRL": {
              "offset": "0xD0",
              "size": 32,
              "description": "Control behaviour of the input/output shift registers for state machine 0"
            },
            "SM0_ADDR": {
              "offset": "0xD4",
              "size": 32,
              "description": "Current instruction address of state machine 0"
            },
            "SM0_INSTR": {
              "offset": "0xD8",
              "size": 32,
              "description": "Read to see the instruction currently addressed by state machine 0's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."
            },
            "SM0_PINCTRL": {
              "offset": "0xDC",
              "size": 32,
              "description": "State machine pin control"
            },
            "SM1_CLKDIV": {
              "offset": "0xE0",
              "size": 32,
              "description": "Clock divisor register for state machine 1 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"
            },
            "SM1_EXECCTRL": {
              "offset": "0xE4",
              "size": 32,
              "description": "Execution/behavioural settings for state machine 1"
            },
            "SM1_SHIFTCTRL": {
              "offset": "0xE8",
              "size": 32,
              "description": "Control behaviour of the input/output shift registers for state machine 1"
            },
            "SM1_ADDR": {
              "offset": "0xEC",
              "size": 32,
              "description": "Current instruction address of state machine 1"
            },
            "SM1_INSTR": {
              "offset": "0xF0",
              "size": 32,
              "description": "Read to see the instruction currently addressed by state machine 1's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."
            },
            "SM1_PINCTRL": {
              "offset": "0xF4",
              "size": 32,
              "description": "State machine pin control"
            },
            "SM2_CLKDIV": {
              "offset": "0xF8",
              "size": 32,
              "description": "Clock divisor register for state machine 2 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"
            },
            "SM2_EXECCTRL": {
              "offset": "0xFC",
              "size": 32,
              "description": "Execution/behavioural settings for state machine 2"
            },
            "SM2_SHIFTCTRL": {
              "offset": "0x100",
              "size": 32,
              "description": "Control behaviour of the input/output shift registers for state machine 2"
            },
            "SM2_ADDR": {
              "offset": "0x104",
              "size": 32,
              "description": "Current instruction address of state machine 2"
            },
            "SM2_INSTR": {
              "offset": "0x108",
              "size": 32,
              "description": "Read to see the instruction currently addressed by state machine 2's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."
            },
            "SM2_PINCTRL": {
              "offset": "0x10C",
              "size": 32,
              "description": "State machine pin control"
            },
            "SM3_CLKDIV": {
              "offset": "0x110",
              "size": 32,
              "description": "Clock divisor register for state machine 3 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"
            },
            "SM3_EXECCTRL": {
              "offset": "0x114",
              "size": 32,
              "description": "Execution/behavioural settings for state machine 3"
            },
            "SM3_SHIFTCTRL": {
              "offset": "0x118",
              "size": 32,
              "description": "Control behaviour of the input/output shift registers for state machine 3"
            },
            "SM3_ADDR": {
              "offset": "0x11C",
              "size": 32,
              "description": "Current instruction address of state machine 3"
            },
            "SM3_INSTR": {
              "offset": "0x120",
              "size": 32,
              "description": "Read to see the instruction currently addressed by state machine 3's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."
            },
            "SM3_PINCTRL": {
              "offset": "0x124",
              "size": 32,
              "description": "State machine pin control"
            },
            "RXF0_PUTGET0": {
              "offset": "0x128",
              "size": 32,
              "description": "Direct read/write access to entry 0 of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF0_PUTGET1": {
              "offset": "0x12C",
              "size": 32,
              "description": "Direct read/write access to entry 1 of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF0_PUTGET2": {
              "offset": "0x130",
              "size": 32,
              "description": "Direct read/write access to entry 2 of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF0_PUTGET3": {
              "offset": "0x134",
              "size": 32,
              "description": "Direct read/write access to entry 3 of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF1_PUTGET0": {
              "offset": "0x138",
              "size": 32,
              "description": "Direct read/write access to entry 0 of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF1_PUTGET1": {
              "offset": "0x13C",
              "size": 32,
              "description": "Direct read/write access to entry 1 of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF1_PUTGET2": {
              "offset": "0x140",
              "size": 32,
              "description": "Direct read/write access to entry 2 of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF1_PUTGET3": {
              "offset": "0x144",
              "size": 32,
              "description": "Direct read/write access to entry 3 of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF2_PUTGET0": {
              "offset": "0x148",
              "size": 32,
              "description": "Direct read/write access to entry 0 of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF2_PUTGET1": {
              "offset": "0x14C",
              "size": 32,
              "description": "Direct read/write access to entry 1 of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF2_PUTGET2": {
              "offset": "0x150",
              "size": 32,
              "description": "Direct read/write access to entry 2 of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF2_PUTGET3": {
              "offset": "0x154",
              "size": 32,
              "description": "Direct read/write access to entry 3 of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF3_PUTGET0": {
              "offset": "0x158",
              "size": 32,
              "description": "Direct read/write access to entry 0 of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF3_PUTGET1": {
              "offset": "0x15C",
              "size": 32,
              "description": "Direct read/write access to entry 1 of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF3_PUTGET2": {
              "offset": "0x160",
              "size": 32,
              "description": "Direct read/write access to entry 2 of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "RXF3_PUTGET3": {
              "offset": "0x164",
              "size": 32,
              "description": "Direct read/write access to entry 3 of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set."
            },
            "GPIOBASE": {
              "offset": "0x168",
              "size": 32,
              "description": "Relocate GPIO 0 (from PIO's point of view) in the system GPIO numbering, to access more than 32 GPIOs from PIO.\n\n                    Only the values 0 and 16 are supported (only bit 4 is writable)."
            },
            "INTR": {
              "offset": "0x16C",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "IRQ0_INTE": {
              "offset": "0x170",
              "size": 32,
              "description": "Interrupt Enable for irq0"
            },
            "IRQ0_INTF": {
              "offset": "0x174",
              "size": 32,
              "description": "Interrupt Force for irq0"
            },
            "IRQ0_INTS": {
              "offset": "0x178",
              "size": 32,
              "description": "Interrupt status after masking & forcing for irq0"
            },
            "IRQ1_INTE": {
              "offset": "0x17C",
              "size": 32,
              "description": "Interrupt Enable for irq1"
            },
            "IRQ1_INTF": {
              "offset": "0x180",
              "size": 32,
              "description": "Interrupt Force for irq1"
            },
            "IRQ1_INTS": {
              "offset": "0x184",
              "size": 32,
              "description": "Interrupt status after masking & forcing for irq1"
            }
          }
        },
        "PIO1": {
          "instances": [
            {
              "name": "PIO1",
              "base": "0x50300000",
              "irq": 17
            }
          ],
          "registers": {}
        },
        "PIO2": {
          "instances": [
            {
              "name": "PIO2",
              "base": "0x50400000",
              "irq": 19
            }
          ],
          "registers": {}
        },
        "BUSCTRL": {
          "instances": [
            {
              "name": "BUSCTRL",
              "base": "0x40068000"
            }
          ],
          "registers": {
            "BUS_PRIORITY": {
              "offset": "0x00",
              "size": 32,
              "description": "Set the priority of each master for bus arbitration."
            },
            "BUS_PRIORITY_ACK": {
              "offset": "0x04",
              "size": 32,
              "description": "Bus priority acknowledge"
            },
            "PERFCTR_EN": {
              "offset": "0x08",
              "size": 32,
              "description": "Enable the performance counters. If 0, the performance counters do not increment. This can be used to precisely start/stop event sampling around the profiled section of code.\n\n                    The performance counters are initially disabled, to save energy."
            },
            "PERFCTR0": {
              "offset": "0x0C",
              "size": 32,
              "description": "Bus fabric performance counter 0"
            },
            "PERFSEL0": {
              "offset": "0x10",
              "size": 32,
              "description": "Bus fabric performance event select for PERFCTR0"
            },
            "PERFCTR1": {
              "offset": "0x14",
              "size": 32,
              "description": "Bus fabric performance counter 1"
            },
            "PERFSEL1": {
              "offset": "0x18",
              "size": 32,
              "description": "Bus fabric performance event select for PERFCTR1"
            },
            "PERFCTR2": {
              "offset": "0x1C",
              "size": 32,
              "description": "Bus fabric performance counter 2"
            },
            "PERFSEL2": {
              "offset": "0x20",
              "size": 32,
              "description": "Bus fabric performance event select for PERFCTR2"
            },
            "PERFCTR3": {
              "offset": "0x24",
              "size": 32,
              "description": "Bus fabric performance counter 3"
            },
            "PERFSEL3": {
              "offset": "0x28",
              "size": 32,
              "description": "Bus fabric performance event select for PERFCTR3"
            }
          }
        },
        "SIO": {
          "instances": [
            {
              "name": "SIO",
              "base": "0xD0000000",
              "irq": 25
            },
            {
              "name": "SIO_NS",
              "base": "0xD0020000"
            }
          ],
          "registers": {
            "CPUID": {
              "offset": "0x00",
              "size": 32,
              "description": "Processor core identifier"
            },
            "GPIO_IN": {
              "offset": "0x04",
              "size": 32,
              "description": "Input value for GPIO0...31.\n\n                    In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero."
            },
            "GPIO_HI_IN": {
              "offset": "0x08",
              "size": 32,
              "description": "Input value on GPIO32...47, QSPI IOs and USB pins\n\n                    In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero."
            },
            "GPIO_OUT": {
              "offset": "0x10",
              "size": 32,
              "description": "GPIO0...31 output value"
            },
            "GPIO_HI_OUT": {
              "offset": "0x14",
              "size": 32,
              "description": "Output value for GPIO32...47, QSPI IOs and USB pins.\n\n                    Write to set output level (1/0 -> high/low). Reading back gives the last value written, NOT the input value from the pins. If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.\n\n                    In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register."
            },
            "GPIO_OUT_SET": {
              "offset": "0x18",
              "size": 32,
              "description": "GPIO0...31 output value set"
            },
            "GPIO_HI_OUT_SET": {
              "offset": "0x1C",
              "size": 32,
              "description": "Output value set for GPIO32..47, QSPI IOs and USB pins. \n                    Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`"
            },
            "GPIO_OUT_CLR": {
              "offset": "0x20",
              "size": 32,
              "description": "GPIO0...31 output value clear"
            },
            "GPIO_HI_OUT_CLR": {
              "offset": "0x24",
              "size": 32,
              "description": "Output value clear for GPIO32..47, QSPI IOs and USB pins. \n                    Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &= ~wdata`"
            },
            "GPIO_OUT_XOR": {
              "offset": "0x28",
              "size": 32,
              "description": "GPIO0...31 output value XOR"
            },
            "GPIO_HI_OUT_XOR": {
              "offset": "0x2C",
              "size": 32,
              "description": "Output value XOR for GPIO32..47, QSPI IOs and USB pins. \n                    Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata`"
            },
            "GPIO_OE": {
              "offset": "0x30",
              "size": 32,
              "description": "GPIO0...31 output enable"
            },
            "GPIO_HI_OE": {
              "offset": "0x34",
              "size": 32,
              "description": "Output enable value for GPIO32...47, QSPI IOs and USB pins.\n\n                    Write output enable (1/0 -> output/input). Reading back gives the last value written. If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.\n\n                    In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register."
            },
            "GPIO_OE_SET": {
              "offset": "0x38",
              "size": 32,
              "description": "GPIO0...31 output enable set"
            },
            "GPIO_HI_OE_SET": {
              "offset": "0x3C",
              "size": 32,
              "description": "Output enable set for GPIO32...47, QSPI IOs and USB pins. \n                    Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`"
            },
            "GPIO_OE_CLR": {
              "offset": "0x40",
              "size": 32,
              "description": "GPIO0...31 output enable clear"
            },
            "GPIO_HI_OE_CLR": {
              "offset": "0x44",
              "size": 32,
              "description": "Output enable clear for GPIO32...47, QSPI IOs and USB pins. \n                    Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata`"
            },
            "GPIO_OE_XOR": {
              "offset": "0x48",
              "size": 32,
              "description": "GPIO0...31 output enable XOR"
            },
            "GPIO_HI_OE_XOR": {
              "offset": "0x4C",
              "size": 32,
              "description": "Output enable XOR for GPIO32...47, QSPI IOs and USB pins. \n                    Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata`"
            },
            "FIFO_ST": {
              "offset": "0x50",
              "size": 32,
              "description": "Status register for inter-core FIFOs (mailboxes). \n                    There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep. \n                    Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX). \n                    Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX). \n                    The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register."
            },
            "FIFO_WR": {
              "offset": "0x54",
              "size": 32,
              "description": "Write access to this core's TX FIFO"
            },
            "FIFO_RD": {
              "offset": "0x58",
              "size": 32,
              "description": "Read access to this core's RX FIFO"
            },
            "SPINLOCK_ST": {
              "offset": "0x5C",
              "size": 32,
              "description": "Spinlock state \n                    A bitmap containing the state of all 32 spinlocks (1=locked). \n                    Mainly intended for debugging."
            },
            "INTERP0_ACCUM0": {
              "offset": "0x80",
              "size": 32,
              "description": "Read/write access to accumulator 0"
            },
            "INTERP0_ACCUM1": {
              "offset": "0x84",
              "size": 32,
              "description": "Read/write access to accumulator 1"
            },
            "INTERP0_BASE0": {
              "offset": "0x88",
              "size": 32,
              "description": "Read/write access to BASE0 register."
            },
            "INTERP0_BASE1": {
              "offset": "0x8C",
              "size": 32,
              "description": "Read/write access to BASE1 register."
            },
            "INTERP0_BASE2": {
              "offset": "0x90",
              "size": 32,
              "description": "Read/write access to BASE2 register."
            },
            "INTERP0_POP_LANE0": {
              "offset": "0x94",
              "size": 32,
              "description": "Read LANE0 result, and simultaneously write lane results to both accumulators (POP)."
            },
            "INTERP0_POP_LANE1": {
              "offset": "0x98",
              "size": 32,
              "description": "Read LANE1 result, and simultaneously write lane results to both accumulators (POP)."
            },
            "INTERP0_POP_FULL": {
              "offset": "0x9C",
              "size": 32,
              "description": "Read FULL result, and simultaneously write lane results to both accumulators (POP)."
            },
            "INTERP0_PEEK_LANE0": {
              "offset": "0xA0",
              "size": 32,
              "description": "Read LANE0 result, without altering any internal state (PEEK)."
            },
            "INTERP0_PEEK_LANE1": {
              "offset": "0xA4",
              "size": 32,
              "description": "Read LANE1 result, without altering any internal state (PEEK)."
            },
            "INTERP0_PEEK_FULL": {
              "offset": "0xA8",
              "size": 32,
              "description": "Read FULL result, without altering any internal state (PEEK)."
            },
            "INTERP0_CTRL_LANE0": {
              "offset": "0xAC",
              "size": 32,
              "description": "Control register for lane 0"
            },
            "INTERP0_CTRL_LANE1": {
              "offset": "0xB0",
              "size": 32,
              "description": "Control register for lane 1"
            },
            "INTERP0_ACCUM0_ADD": {
              "offset": "0xB4",
              "size": 32,
              "description": "Values written here are atomically added to ACCUM0 \n                    Reading yields lane 0's raw shift and mask value (BASE0 not added)."
            },
            "INTERP0_ACCUM1_ADD": {
              "offset": "0xB8",
              "size": 32,
              "description": "Values written here are atomically added to ACCUM1 \n                    Reading yields lane 1's raw shift and mask value (BASE1 not added)."
            },
            "INTERP0_BASE_1AND0": {
              "offset": "0xBC",
              "size": 32,
              "description": "On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. \n                    Each half is sign-extended to 32 bits if that lane's SIGNED flag is set."
            },
            "INTERP1_ACCUM0": {
              "offset": "0xC0",
              "size": 32,
              "description": "Read/write access to accumulator 0"
            },
            "INTERP1_ACCUM1": {
              "offset": "0xC4",
              "size": 32,
              "description": "Read/write access to accumulator 1"
            },
            "INTERP1_BASE0": {
              "offset": "0xC8",
              "size": 32,
              "description": "Read/write access to BASE0 register."
            },
            "INTERP1_BASE1": {
              "offset": "0xCC",
              "size": 32,
              "description": "Read/write access to BASE1 register."
            },
            "INTERP1_BASE2": {
              "offset": "0xD0",
              "size": 32,
              "description": "Read/write access to BASE2 register."
            },
            "INTERP1_POP_LANE0": {
              "offset": "0xD4",
              "size": 32,
              "description": "Read LANE0 result, and simultaneously write lane results to both accumulators (POP)."
            },
            "INTERP1_POP_LANE1": {
              "offset": "0xD8",
              "size": 32,
              "description": "Read LANE1 result, and simultaneously write lane results to both accumulators (POP)."
            },
            "INTERP1_POP_FULL": {
              "offset": "0xDC",
              "size": 32,
              "description": "Read FULL result, and simultaneously write lane results to both accumulators (POP)."
            },
            "INTERP1_PEEK_LANE0": {
              "offset": "0xE0",
              "size": 32,
              "description": "Read LANE0 result, without altering any internal state (PEEK)."
            },
            "INTERP1_PEEK_LANE1": {
              "offset": "0xE4",
              "size": 32,
              "description": "Read LANE1 result, without altering any internal state (PEEK)."
            },
            "INTERP1_PEEK_FULL": {
              "offset": "0xE8",
              "size": 32,
              "description": "Read FULL result, without altering any internal state (PEEK)."
            },
            "INTERP1_CTRL_LANE0": {
              "offset": "0xEC",
              "size": 32,
              "description": "Control register for lane 0"
            },
            "INTERP1_CTRL_LANE1": {
              "offset": "0xF0",
              "size": 32,
              "description": "Control register for lane 1"
            },
            "INTERP1_ACCUM0_ADD": {
              "offset": "0xF4",
              "size": 32,
              "description": "Values written here are atomically added to ACCUM0 \n                    Reading yields lane 0's raw shift and mask value (BASE0 not added)."
            },
            "INTERP1_ACCUM1_ADD": {
              "offset": "0xF8",
              "size": 32,
              "description": "Values written here are atomically added to ACCUM1 \n                    Reading yields lane 1's raw shift and mask value (BASE1 not added)."
            },
            "INTERP1_BASE_1AND0": {
              "offset": "0xFC",
              "size": 32,
              "description": "On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. \n                    Each half is sign-extended to 32 bits if that lane's SIGNED flag is set."
            },
            "SPINLOCK0": {
              "offset": "0x100",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK1": {
              "offset": "0x104",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK2": {
              "offset": "0x108",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK3": {
              "offset": "0x10C",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK4": {
              "offset": "0x110",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK5": {
              "offset": "0x114",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK6": {
              "offset": "0x118",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK7": {
              "offset": "0x11C",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK8": {
              "offset": "0x120",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK9": {
              "offset": "0x124",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK10": {
              "offset": "0x128",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK11": {
              "offset": "0x12C",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK12": {
              "offset": "0x130",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK13": {
              "offset": "0x134",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK14": {
              "offset": "0x138",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK15": {
              "offset": "0x13C",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK16": {
              "offset": "0x140",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK17": {
              "offset": "0x144",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK18": {
              "offset": "0x148",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK19": {
              "offset": "0x14C",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK20": {
              "offset": "0x150",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK21": {
              "offset": "0x154",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK22": {
              "offset": "0x158",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK23": {
              "offset": "0x15C",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK24": {
              "offset": "0x160",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK25": {
              "offset": "0x164",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK26": {
              "offset": "0x168",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK27": {
              "offset": "0x16C",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK28": {
              "offset": "0x170",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK29": {
              "offset": "0x174",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK30": {
              "offset": "0x178",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "SPINLOCK31": {
              "offset": "0x17C",
              "size": 32,
              "description": "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."
            },
            "DOORBELL_OUT_SET": {
              "offset": "0x180",
              "size": 32,
              "description": "Trigger a doorbell interrupt on the opposite core.\n\n                    Write 1 to a bit to set the corresponding bit in DOORBELL_IN on the opposite core. This raises the opposite core's doorbell interrupt.\n\n                    Read to get the status of the doorbells currently asserted on the opposite core. This is equivalent to that core reading its own DOORBELL_IN status."
            },
            "DOORBELL_OUT_CLR": {
              "offset": "0x184",
              "size": 32,
              "description": "Clear doorbells which have been posted to the opposite core. This register is intended for debugging and initialisation purposes.\n\n                    Writing 1 to a bit in DOORBELL_OUT_CLR clears the corresponding bit in DOORBELL_IN on the opposite core. Clearing all bits will cause that core's doorbell interrupt to deassert. Since the usual order of events is for software to send events using DOORBELL_OUT_SET, and acknowledge incoming events by writing to DOORBELL_IN_CLR, this register should be used with caution to avoid race conditions.\n\n                    Reading returns the status of the doorbells currently asserted on the other core, i.e. is equivalent to that core reading its own DOORBELL_IN status."
            },
            "DOORBELL_IN_SET": {
              "offset": "0x188",
              "size": 32,
              "description": "Write 1s to trigger doorbell interrupts on this core. Read to get status of doorbells currently asserted on this core."
            },
            "DOORBELL_IN_CLR": {
              "offset": "0x18C",
              "size": 32,
              "description": "Check and acknowledge doorbells posted to this core. This core's doorbell interrupt is asserted when any bit in this register is 1.\n\n                    Write 1 to each bit to clear that bit. The doorbell interrupt deasserts once all bits are cleared. Read to get status of doorbells currently asserted on this core."
            },
            "PERI_NONSEC": {
              "offset": "0x190",
              "size": 32,
              "description": "Detach certain core-local peripherals from Secure SIO, and attach them to Non-secure SIO, so that Non-secure software can use them. Attempting to access one of these peripherals from the Secure SIO when it is attached to the Non-secure SIO, or vice versa, will generate a bus error.\n\n                    This register is per-core, and is only present on the Secure SIO.\n\n                    Most SIO hardware is duplicated across the Secure and Non-secure SIO, so is not listed in this register."
            },
            "RISCV_SOFTIRQ": {
              "offset": "0x1A0",
              "size": 32,
              "description": "Control the assertion of the standard software interrupt (MIP.MSIP) on the RISC-V cores.\n\n                    Unlike the RISC-V timer, this interrupt is not routed to a normal system-level interrupt line, so can not be used by the Arm cores.\n\n                    It is safe for both cores to write to this register on the same cycle. The set/clear effect is accumulated across both cores, and then applied. If a flag is both set and cleared on the same cycle, only the set takes effect."
            },
            "MTIME_CTRL": {
              "offset": "0x1A4",
              "size": 32,
              "description": "Control register for the RISC-V 64-bit Machine-mode timer. This timer is only present in the Secure SIO, so is only accessible to an Arm core in Secure mode or a RISC-V core in Machine mode.\n\n                    Note whilst this timer follows the RISC-V privileged specification, it is equally usable by the Arm cores. The interrupts are routed to normal system-level interrupt lines as well as to the MIP.MTIP inputs on the RISC-V cores."
            },
            "MTIME": {
              "offset": "0x1B0",
              "size": 32,
              "description": "Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence."
            },
            "MTIMEH": {
              "offset": "0x1B4",
              "size": 32,
              "description": "Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence."
            },
            "MTIMECMP": {
              "offset": "0x1B8",
              "size": 32,
              "description": "Low half of RISC-V Machine-mode timer comparator. This register is core-local, i.e., each core gets a copy of this register, with the comparison result routed to its own interrupt line.\n\n                    The timer interrupt is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and performed on the full 64-bit values."
            },
            "MTIMECMPH": {
              "offset": "0x1BC",
              "size": 32,
              "description": "High half of RISC-V Machine-mode timer comparator. This register is core-local.\n\n                    The timer interrupt is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and performed on the full 64-bit values."
            },
            "TMDS_CTRL": {
              "offset": "0x1C0",
              "size": 32,
              "description": "Control register for TMDS encoder."
            },
            "TMDS_WDATA": {
              "offset": "0x1C4",
              "size": 32,
              "description": "Write-only access to the TMDS colour data register."
            },
            "TMDS_PEEK_SINGLE": {
              "offset": "0x1C8",
              "size": 32,
              "description": "Get the encoding of one pixel's worth of colour data, packed into a 32-bit value (3x10-bit symbols).\n\n                    The PEEK alias does not shift the colour register when read, but still advances the running DC balance state of each encoder. This is useful for pixel doubling."
            },
            "TMDS_POP_SINGLE": {
              "offset": "0x1CC",
              "size": 32,
              "description": "Get the encoding of one pixel's worth of colour data, packed into a 32-bit value. The packing is 5 chunks of 3 lanes times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per lane. This format is intended for shifting out with the HSTX peripheral on RP2350.\n\n                    The POP alias shifts the colour register when read, as well as advancing the running DC balance state of each encoder."
            },
            "TMDS_PEEK_DOUBLE_L0": {
              "offset": "0x1D0",
              "size": 32,
              "description": "Get lane 0 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n                    The PEEK alias does not shift the colour register when read, but still advances the lane 0 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane."
            },
            "TMDS_POP_DOUBLE_L0": {
              "offset": "0x1D4",
              "size": 32,
              "description": "Get lane 0 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n                    The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT."
            },
            "TMDS_PEEK_DOUBLE_L1": {
              "offset": "0x1D8",
              "size": 32,
              "description": "Get lane 1 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n                    The PEEK alias does not shift the colour register when read, but still advances the lane 1 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane."
            },
            "TMDS_POP_DOUBLE_L1": {
              "offset": "0x1DC",
              "size": 32,
              "description": "Get lane 1 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n                    The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT."
            },
            "TMDS_PEEK_DOUBLE_L2": {
              "offset": "0x1E0",
              "size": 32,
              "description": "Get lane 2 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n                    The PEEK alias does not shift the colour register when read, but still advances the lane 2 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane."
            },
            "TMDS_POP_DOUBLE_L2": {
              "offset": "0x1E4",
              "size": 32,
              "description": "Get lane 2 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word.\n\n                    The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT."
            }
          }
        },
        "BOOTRAM": {
          "instances": [
            {
              "name": "BOOTRAM",
              "base": "0x400E0000"
            }
          ],
          "registers": {
            "WRITE_ONCE0": {
              "offset": "0x800",
              "size": 32,
              "description": "This registers always ORs writes into its current contents. Once a bit is set, it can only be cleared by a reset."
            },
            "WRITE_ONCE1": {
              "offset": "0x804",
              "size": 32,
              "description": "This registers always ORs writes into its current contents. Once a bit is set, it can only be cleared by a reset."
            },
            "BOOTLOCK_STAT": {
              "offset": "0x808",
              "size": 32,
              "description": "Bootlock status register. 1=unclaimed, 0=claimed. These locks function identically to the SIO spinlocks, but are reserved for bootrom use."
            },
            "BOOTLOCK0": {
              "offset": "0x80C",
              "size": 32,
              "description": "Read to claim and check. Write to unclaim. The value returned on successful claim is 1 << n, and on failed claim is zero."
            },
            "BOOTLOCK1": {
              "offset": "0x810",
              "size": 32,
              "description": "Read to claim and check. Write to unclaim. The value returned on successful claim is 1 << n, and on failed claim is zero."
            },
            "BOOTLOCK2": {
              "offset": "0x814",
              "size": 32,
              "description": "Read to claim and check. Write to unclaim. The value returned on successful claim is 1 << n, and on failed claim is zero."
            },
            "BOOTLOCK3": {
              "offset": "0x818",
              "size": 32,
              "description": "Read to claim and check. Write to unclaim. The value returned on successful claim is 1 << n, and on failed claim is zero."
            },
            "BOOTLOCK4": {
              "offset": "0x81C",
              "size": 32,
              "description": "Read to claim and check. Write to unclaim. The value returned on successful claim is 1 << n, and on failed claim is zero."
            },
            "BOOTLOCK5": {
              "offset": "0x820",
              "size": 32,
              "description": "Read to claim and check. Write to unclaim. The value returned on successful claim is 1 << n, and on failed claim is zero."
            },
            "BOOTLOCK6": {
              "offset": "0x824",
              "size": 32,
              "description": "Read to claim and check. Write to unclaim. The value returned on successful claim is 1 << n, and on failed claim is zero."
            },
            "BOOTLOCK7": {
              "offset": "0x828",
              "size": 32,
              "description": "Read to claim and check. Write to unclaim. The value returned on successful claim is 1 << n, and on failed claim is zero."
            }
          }
        },
        "CORESIGHT": {
          "instances": [
            {
              "name": "CORESIGHT_TRACE",
              "base": "0x50700000"
            }
          ],
          "registers": {
            "CTRL_STATUS": {
              "offset": "0x00",
              "size": 32,
              "description": "Control and status register"
            },
            "TRACE_CAPTURE_FIFO": {
              "offset": "0x04",
              "size": 32,
              "description": "FIFO for trace data captured from the TPIU"
            }
          }
        },
        "RNG": {
          "instances": [
            {
              "name": "TRNG",
              "base": "0x400F0000",
              "irq": 39
            }
          ],
          "registers": {
            "RNG_IMR": {
              "offset": "0x100",
              "size": 32,
              "description": "Interrupt masking."
            },
            "RNG_ISR": {
              "offset": "0x104",
              "size": 32,
              "description": "RNG status register. If corresponding RNG_IMR bit is unmasked, an interrupt will be generated."
            },
            "RNG_ICR": {
              "offset": "0x108",
              "size": 32,
              "description": "Interrupt/status bit clear Register."
            },
            "TRNG_CONFIG": {
              "offset": "0x10C",
              "size": 32,
              "description": "Selecting the inverter-chain length."
            },
            "TRNG_VALID": {
              "offset": "0x110",
              "size": 32,
              "description": "192 bit collection indication."
            },
            "EHR_DATA0": {
              "offset": "0x114",
              "size": 32,
              "description": "RNG collected bits."
            },
            "EHR_DATA1": {
              "offset": "0x118",
              "size": 32,
              "description": "RNG collected bits."
            },
            "EHR_DATA2": {
              "offset": "0x11C",
              "size": 32,
              "description": "RNG collected bits."
            },
            "EHR_DATA3": {
              "offset": "0x120",
              "size": 32,
              "description": "RNG collected bits."
            },
            "EHR_DATA4": {
              "offset": "0x124",
              "size": 32,
              "description": "RNG collected bits."
            },
            "EHR_DATA5": {
              "offset": "0x128",
              "size": 32,
              "description": "RNG collected bits."
            },
            "RND_SOURCE_ENABLE": {
              "offset": "0x12C",
              "size": 32,
              "description": "Enable signal for the random source."
            },
            "SAMPLE_CNT1": {
              "offset": "0x130",
              "size": 32,
              "description": "Counts clocks between sampling of random bit."
            },
            "AUTOCORR_STATISTIC": {
              "offset": "0x134",
              "size": 32,
              "description": "Statistic about Autocorrelation test activations."
            },
            "TRNG_DEBUG_CONTROL": {
              "offset": "0x138",
              "size": 32,
              "description": "Debug register."
            },
            "TRNG_SW_RESET": {
              "offset": "0x140",
              "size": 32,
              "description": "Generate internal SW reset within the RNG block."
            },
            "RNG_DEBUG_EN_INPUT": {
              "offset": "0x1B4",
              "size": 32,
              "description": "Enable the RNG debug mode"
            },
            "TRNG_BUSY": {
              "offset": "0x1B8",
              "size": 32,
              "description": "RNG Busy indication."
            },
            "RST_BITS_COUNTER": {
              "offset": "0x1BC",
              "size": 32,
              "description": "Reset the counter of collected bits in the RNG."
            },
            "RNG_VERSION": {
              "offset": "0x1C0",
              "size": 32,
              "description": "Displays the version settings of the TRNG."
            },
            "RNG_BIST_CNTR_0": {
              "offset": "0x1E0",
              "size": 32,
              "description": "Collected BIST results."
            },
            "RNG_BIST_CNTR_1": {
              "offset": "0x1E4",
              "size": 32,
              "description": "Collected BIST results."
            },
            "RNG_BIST_CNTR_2": {
              "offset": "0x1E8",
              "size": 32,
              "description": "Collected BIST results."
            }
          }
        },
        "GLITCH": {
          "instances": [
            {
              "name": "GLITCH_DETECTOR",
              "base": "0x40158000"
            }
          ],
          "registers": {
            "ARM": {
              "offset": "0x00",
              "size": 32,
              "description": "Forcibly arm the glitch detectors, if they are not already armed by OTP. When armed, any individual detector trigger will cause a restart of the switched core power domain's power-on reset state machine.\n\n                    Glitch detector triggers are recorded accumulatively in TRIG_STATUS. If the system is reset by a glitch detector trigger, this is recorded in POWMAN_CHIP_RESET.\n\n                    This register is Secure read/write only."
            },
            "DISARM": {
              "offset": "0x04",
              "size": 32,
              "description": "Forcibly disarm the glitch detectors, if they are armed by OTP. Ignored if ARM is YES.\n\n                            This register is Secure read/write only."
            },
            "SENSITIVITY": {
              "offset": "0x08",
              "size": 32,
              "description": "Adjust the sensitivity of glitch detectors to values other than their OTP-provided defaults.\n\n                    This register is Secure read/write only."
            },
            "LOCK": {
              "offset": "0x0C",
              "size": 32,
              "description": "Write any nonzero value to disable writes to ARM, DISARM, SENSITIVITY and LOCK. This register is Secure read/write only."
            },
            "TRIG_STATUS": {
              "offset": "0x10",
              "size": 32,
              "description": "Set when a detector output triggers. Write-1-clear.\n\n                    (May immediately return high if the detector remains in a failed state. Detectors can only be cleared by a full reset of the switched core power domain.)\n\n                    This register is Secure read/write only."
            },
            "TRIG_FORCE": {
              "offset": "0x14",
              "size": 32,
              "description": "Simulate the firing of one or more detectors. Writing ones to this register will set the matching bits in STATUS_TRIG.\n\n                    If the glitch detectors are currently armed, writing ones will also immediately reset the switched core power domain, and set the reset reason latches in POWMAN_CHIP_RESET to indicate a glitch detector resets.\n\n                    This register is Secure read/write only."
            }
          }
        },
        "OTP": {
          "instances": [
            {
              "name": "OTP",
              "base": "0x40120000",
              "irq": 38
            },
            {
              "name": "OTP_DATA",
              "base": "0x40130000"
            },
            {
              "name": "OTP_DATA_RAW",
              "base": "0x40134000"
            }
          ],
          "registers": {
            "SW_LOCK0": {
              "offset": "0x00",
              "size": 32,
              "description": "Software lock register for page 0.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK1": {
              "offset": "0x04",
              "size": 32,
              "description": "Software lock register for page 1.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK2": {
              "offset": "0x08",
              "size": 32,
              "description": "Software lock register for page 2.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK3": {
              "offset": "0x0C",
              "size": 32,
              "description": "Software lock register for page 3.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK4": {
              "offset": "0x10",
              "size": 32,
              "description": "Software lock register for page 4.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK5": {
              "offset": "0x14",
              "size": 32,
              "description": "Software lock register for page 5.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK6": {
              "offset": "0x18",
              "size": 32,
              "description": "Software lock register for page 6.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK7": {
              "offset": "0x1C",
              "size": 32,
              "description": "Software lock register for page 7.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK8": {
              "offset": "0x20",
              "size": 32,
              "description": "Software lock register for page 8.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK9": {
              "offset": "0x24",
              "size": 32,
              "description": "Software lock register for page 9.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK10": {
              "offset": "0x28",
              "size": 32,
              "description": "Software lock register for page 10.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK11": {
              "offset": "0x2C",
              "size": 32,
              "description": "Software lock register for page 11.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK12": {
              "offset": "0x30",
              "size": 32,
              "description": "Software lock register for page 12.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK13": {
              "offset": "0x34",
              "size": 32,
              "description": "Software lock register for page 13.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK14": {
              "offset": "0x38",
              "size": 32,
              "description": "Software lock register for page 14.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK15": {
              "offset": "0x3C",
              "size": 32,
              "description": "Software lock register for page 15.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK16": {
              "offset": "0x40",
              "size": 32,
              "description": "Software lock register for page 16.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK17": {
              "offset": "0x44",
              "size": 32,
              "description": "Software lock register for page 17.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK18": {
              "offset": "0x48",
              "size": 32,
              "description": "Software lock register for page 18.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK19": {
              "offset": "0x4C",
              "size": 32,
              "description": "Software lock register for page 19.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK20": {
              "offset": "0x50",
              "size": 32,
              "description": "Software lock register for page 20.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK21": {
              "offset": "0x54",
              "size": 32,
              "description": "Software lock register for page 21.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK22": {
              "offset": "0x58",
              "size": 32,
              "description": "Software lock register for page 22.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK23": {
              "offset": "0x5C",
              "size": 32,
              "description": "Software lock register for page 23.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK24": {
              "offset": "0x60",
              "size": 32,
              "description": "Software lock register for page 24.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK25": {
              "offset": "0x64",
              "size": 32,
              "description": "Software lock register for page 25.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK26": {
              "offset": "0x68",
              "size": 32,
              "description": "Software lock register for page 26.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK27": {
              "offset": "0x6C",
              "size": 32,
              "description": "Software lock register for page 27.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK28": {
              "offset": "0x70",
              "size": 32,
              "description": "Software lock register for page 28.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK29": {
              "offset": "0x74",
              "size": 32,
              "description": "Software lock register for page 29.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK30": {
              "offset": "0x78",
              "size": 32,
              "description": "Software lock register for page 30.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK31": {
              "offset": "0x7C",
              "size": 32,
              "description": "Software lock register for page 31.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK32": {
              "offset": "0x80",
              "size": 32,
              "description": "Software lock register for page 32.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK33": {
              "offset": "0x84",
              "size": 32,
              "description": "Software lock register for page 33.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK34": {
              "offset": "0x88",
              "size": 32,
              "description": "Software lock register for page 34.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK35": {
              "offset": "0x8C",
              "size": 32,
              "description": "Software lock register for page 35.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK36": {
              "offset": "0x90",
              "size": 32,
              "description": "Software lock register for page 36.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK37": {
              "offset": "0x94",
              "size": 32,
              "description": "Software lock register for page 37.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK38": {
              "offset": "0x98",
              "size": 32,
              "description": "Software lock register for page 38.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK39": {
              "offset": "0x9C",
              "size": 32,
              "description": "Software lock register for page 39.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK40": {
              "offset": "0xA0",
              "size": 32,
              "description": "Software lock register for page 40.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK41": {
              "offset": "0xA4",
              "size": 32,
              "description": "Software lock register for page 41.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK42": {
              "offset": "0xA8",
              "size": 32,
              "description": "Software lock register for page 42.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK43": {
              "offset": "0xAC",
              "size": 32,
              "description": "Software lock register for page 43.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK44": {
              "offset": "0xB0",
              "size": 32,
              "description": "Software lock register for page 44.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK45": {
              "offset": "0xB4",
              "size": 32,
              "description": "Software lock register for page 45.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK46": {
              "offset": "0xB8",
              "size": 32,
              "description": "Software lock register for page 46.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK47": {
              "offset": "0xBC",
              "size": 32,
              "description": "Software lock register for page 47.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK48": {
              "offset": "0xC0",
              "size": 32,
              "description": "Software lock register for page 48.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK49": {
              "offset": "0xC4",
              "size": 32,
              "description": "Software lock register for page 49.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK50": {
              "offset": "0xC8",
              "size": 32,
              "description": "Software lock register for page 50.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK51": {
              "offset": "0xCC",
              "size": 32,
              "description": "Software lock register for page 51.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK52": {
              "offset": "0xD0",
              "size": 32,
              "description": "Software lock register for page 52.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK53": {
              "offset": "0xD4",
              "size": 32,
              "description": "Software lock register for page 53.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK54": {
              "offset": "0xD8",
              "size": 32,
              "description": "Software lock register for page 54.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK55": {
              "offset": "0xDC",
              "size": 32,
              "description": "Software lock register for page 55.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK56": {
              "offset": "0xE0",
              "size": 32,
              "description": "Software lock register for page 56.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK57": {
              "offset": "0xE4",
              "size": 32,
              "description": "Software lock register for page 57.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK58": {
              "offset": "0xE8",
              "size": 32,
              "description": "Software lock register for page 58.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK59": {
              "offset": "0xEC",
              "size": 32,
              "description": "Software lock register for page 59.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK60": {
              "offset": "0xF0",
              "size": 32,
              "description": "Software lock register for page 60.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK61": {
              "offset": "0xF4",
              "size": 32,
              "description": "Software lock register for page 61.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK62": {
              "offset": "0xF8",
              "size": 32,
              "description": "Software lock register for page 62.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SW_LOCK63": {
              "offset": "0xFC",
              "size": 32,
              "description": "Software lock register for page 63.\n\n                    Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page."
            },
            "SBPI_INSTR": {
              "offset": "0x100",
              "size": 32,
              "description": "Dispatch instructions to the SBPI interface, used for programming the OTP fuses."
            },
            "SBPI_WDATA_0": {
              "offset": "0x104",
              "size": 32,
              "description": "SBPI write payload bytes 3..0"
            },
            "SBPI_WDATA_1": {
              "offset": "0x108",
              "size": 32,
              "description": "SBPI write payload bytes 7..4"
            },
            "SBPI_WDATA_2": {
              "offset": "0x10C",
              "size": 32,
              "description": "SBPI write payload bytes 11..8"
            },
            "SBPI_WDATA_3": {
              "offset": "0x110",
              "size": 32,
              "description": "SBPI write payload bytes 15..12"
            },
            "SBPI_RDATA_0": {
              "offset": "0x114",
              "size": 32,
              "description": "Read payload bytes 3..0. Once read, the data in the register will automatically clear to 0."
            },
            "SBPI_RDATA_1": {
              "offset": "0x118",
              "size": 32,
              "description": "Read payload bytes 7..4. Once read, the data in the register will automatically clear to 0."
            },
            "SBPI_RDATA_2": {
              "offset": "0x11C",
              "size": 32,
              "description": "Read payload bytes 11..8. Once read, the data in the register will automatically clear to 0."
            },
            "SBPI_RDATA_3": {
              "offset": "0x120",
              "size": 32,
              "description": "Read payload bytes 15..12. Once read, the data in the register will automatically clear to 0."
            },
            "SBPI_STATUS": {
              "offset": "0x124",
              "size": 32,
              "description": "SBPI MISO (master in - slave out): response from SBPI"
            },
            "USR": {
              "offset": "0x128",
              "size": 32,
              "description": "Controls for APB data read interface (USER interface)"
            },
            "DBG": {
              "offset": "0x12C",
              "size": 32,
              "description": "Debug for OTP power-on state machine"
            },
            "BIST": {
              "offset": "0x134",
              "size": 32,
              "description": "During BIST, count address locations that have at least one leaky bit"
            },
            "CRT_KEY_W0": {
              "offset": "0x138",
              "size": 32,
              "description": "Word 0 (bits 31..0) of the key. Write only, read returns 0x0"
            },
            "CRT_KEY_W1": {
              "offset": "0x13C",
              "size": 32,
              "description": "Word 1 (bits 63..32) of the key. Write only, read returns 0x0"
            },
            "CRT_KEY_W2": {
              "offset": "0x140",
              "size": 32,
              "description": "Word 2 (bits 95..64) of the key. Write only, read returns 0x0"
            },
            "CRT_KEY_W3": {
              "offset": "0x144",
              "size": 32,
              "description": "Word 3 (bits 127..96) of the key. Write only, read returns 0x0"
            },
            "CRITICAL": {
              "offset": "0x148",
              "size": 32,
              "description": "Quickly check values of critical flags read during boot up"
            },
            "KEY_VALID": {
              "offset": "0x14C",
              "size": 32,
              "description": "Which keys were valid (enrolled) at boot time"
            },
            "DEBUGEN": {
              "offset": "0x150",
              "size": 32,
              "description": "Enable a debug feature that has been disabled. Debug features are disabled if one of the relevant critical boot flags is set in OTP (DEBUG_DISABLE or SECURE_DEBUG_DISABLE), OR if a debug key is marked valid in OTP, and the matching key value has not been supplied over SWD.\n\n                    Specifically:\n\n                    - The DEBUG_DISABLE flag disables all debug features. This can be fully overridden by setting all bits of this register.\n\n                    - The SECURE_DEBUG_DISABLE flag disables secure processor debug. This can be fully overridden by setting the PROC0_SECURE and PROC1_SECURE bits of this register.\n\n                    - If a single debug key has been registered, and no matching key value has been supplied over SWD, then all debug features are disabled. This can be fully overridden by setting all bits of this register.\n\n                    - If both debug keys have been registered, and the Non-secure key's value (key 6) has been supplied over SWD, secure processor debug is disabled. This can be fully overridden by setting the PROC0_SECURE and PROC1_SECURE bits of this register.\n\n                    - If both debug keys have been registered, and the Secure key's value (key 5) has been supplied over SWD, then no debug features are disabled by the key mechanism. However, note that in this case debug features may still be disabled by the critical boot flags."
            },
            "DEBUGEN_LOCK": {
              "offset": "0x154",
              "size": 32,
              "description": "Write 1s to lock corresponding bits in DEBUGEN. This register is reset by the processor cold reset."
            },
            "ARCHSEL": {
              "offset": "0x158",
              "size": 32,
              "description": "Architecture select (Arm/RISC-V). The default and allowable values of this register are constrained by the critical boot flags.\n\n                    This register is reset by the earliest reset in the switched core power domain (before a processor cold reset).\n\n                    Cores sample their architecture select signal on a warm reset. The source of the warm reset could be the system power-up state machine, the watchdog timer, Arm SYSRESETREQ or from RISC-V hartresetreq.\n\n                    Note that when an Arm core is deselected, its cold reset domain is also held in reset, since in particular the SYSRESETREQ bit becomes inaccessible once the core is deselected. Note also the RISC-V cores do not have a cold reset domain, since their corresponding controls are located in the Debug Module."
            },
            "ARCHSEL_STATUS": {
              "offset": "0x15C",
              "size": 32,
              "description": "Get the current architecture select state of each core. Cores sample the current value of the ARCHSEL register when their warm reset is released, at which point the corresponding bit in this register will also update."
            },
            "BOOTDIS": {
              "offset": "0x160",
              "size": 32,
              "description": "Tell the bootrom to ignore scratch register boot vectors (both power manager and watchdog) on the next power up.\n\n                    If an early boot stage has soft-locked some OTP pages in order to protect their contents from later stages, there is a risk that Secure code running at a later stage can unlock the pages by performing a watchdog reset that resets the OTP.\n\n                    This register can be used to ensure that the bootloader runs as normal on the next power up, preventing Secure code at a later stage from accessing OTP in its unlocked state.\n\n                    Should be used in conjunction with the power manager BOOTDIS register."
            },
            "INTR": {
              "offset": "0x164",
              "size": 32,
              "description": "Raw Interrupts"
            },
            "INTE": {
              "offset": "0x168",
              "size": 32,
              "description": "Interrupt Enable"
            },
            "INTF": {
              "offset": "0x16C",
              "size": 32,
              "description": "Interrupt Force"
            },
            "INTS": {
              "offset": "0x170",
              "size": 32,
              "description": "Interrupt status after masking & forcing"
            }
          }
        },
        "TBMAN": {
          "instances": [
            {
              "name": "TBMAN",
              "base": "0x40160000"
            }
          ],
          "registers": {
            "PLATFORM": {
              "offset": "0x00",
              "size": 32,
              "description": "Indicates the type of platform in use"
            }
          }
        }
      },
      "interrupts": {
        "count": 62,
        "vectors": [
          {
            "number": 0,
            "name": "Initial_SP"
          },
          {
            "number": 1,
            "name": "Reset_Handler"
          },
          {
            "number": 2,
            "name": "NMI_Handler"
          },
          {
            "number": 3,
            "name": "HardFault_Handler"
          },
          {
            "number": 4,
            "name": "MemManage_Handler"
          },
          {
            "number": 5,
            "name": "BusFault_Handler"
          },
          {
            "number": 6,
            "name": "UsageFault_Handler"
          },
          {
            "number": 11,
            "name": "SVC_Handler"
          },
          {
            "number": 12,
            "name": "DebugMon_Handler"
          },
          {
            "number": 14,
            "name": "PendSV_Handler"
          },
          {
            "number": 15,
            "name": "SysTick_Handler"
          },
          {
            "number": 16,
            "name": "TIMER0_IRQ_0_IRQHandler"
          },
          {
            "number": 17,
            "name": "TIMER0_IRQ_1_IRQHandler"
          },
          {
            "number": 18,
            "name": "TIMER0_IRQ_2_IRQHandler"
          },
          {
            "number": 19,
            "name": "TIMER0_IRQ_3_IRQHandler"
          },
          {
            "number": 20,
            "name": "TIMER1_IRQ_0_IRQHandler"
          },
          {
            "number": 21,
            "name": "TIMER1_IRQ_1_IRQHandler"
          },
          {
            "number": 22,
            "name": "TIMER1_IRQ_2_IRQHandler"
          },
          {
            "number": 23,
            "name": "TIMER1_IRQ_3_IRQHandler"
          },
          {
            "number": 24,
            "name": "PWM_IRQ_WRAP_0_IRQHandler"
          },
          {
            "number": 25,
            "name": "PWM_IRQ_WRAP_1_IRQHandler"
          },
          {
            "number": 26,
            "name": "DMA_IRQ_0_IRQHandler"
          },
          {
            "number": 27,
            "name": "DMA_IRQ_1_IRQHandler"
          },
          {
            "number": 28,
            "name": "DMA_IRQ_2_IRQHandler"
          },
          {
            "number": 29,
            "name": "DMA_IRQ_3_IRQHandler"
          },
          {
            "number": 30,
            "name": "USBCTRL_IRQ_IRQHandler"
          },
          {
            "number": 31,
            "name": "PIO0_IRQ_0_IRQHandler"
          },
          {
            "number": 32,
            "name": "PIO0_IRQ_1_IRQHandler"
          },
          {
            "number": 33,
            "name": "PIO1_IRQ_0_IRQHandler"
          },
          {
            "number": 34,
            "name": "PIO1_IRQ_1_IRQHandler"
          },
          {
            "number": 35,
            "name": "PIO2_IRQ_0_IRQHandler"
          },
          {
            "number": 36,
            "name": "PIO2_IRQ_1_IRQHandler"
          },
          {
            "number": 37,
            "name": "IO_IRQ_BANK0_IRQHandler"
          },
          {
            "number": 38,
            "name": "IO_IRQ_BANK0_NS_IRQHandler"
          },
          {
            "number": 39,
            "name": "IO_IRQ_QSPI_IRQHandler"
          },
          {
            "number": 40,
            "name": "IO_IRQ_QSPI_NS_IRQHandler"
          },
          {
            "number": 41,
            "name": "SIO_IRQ_FIFO_IRQHandler"
          },
          {
            "number": 42,
            "name": "SIO_IRQ_BELL_IRQHandler"
          },
          {
            "number": 43,
            "name": "SIO_IRQ_FIFO_NS_IRQHandler"
          },
          {
            "number": 44,
            "name": "SIO_IRQ_BELL_NS_IRQHandler"
          },
          {
            "number": 45,
            "name": "SIO_IRQ_MTIMECMP_IRQHandler"
          },
          {
            "number": 46,
            "name": "CLOCKS_IRQ_IRQHandler"
          },
          {
            "number": 47,
            "name": "SPI0_IRQ_IRQHandler"
          },
          {
            "number": 48,
            "name": "SPI1_IRQ_IRQHandler"
          },
          {
            "number": 49,
            "name": "UART0_IRQ_IRQHandler"
          },
          {
            "number": 50,
            "name": "UART1_IRQ_IRQHandler"
          },
          {
            "number": 51,
            "name": "ADC_IRQ_FIFO_IRQHandler"
          },
          {
            "number": 52,
            "name": "I2C0_IRQ_IRQHandler"
          },
          {
            "number": 53,
            "name": "I2C1_IRQ_IRQHandler"
          },
          {
            "number": 54,
            "name": "OTP_IRQ_IRQHandler"
          },
          {
            "number": 55,
            "name": "TRNG_IRQ_IRQHandler"
          },
          {
            "number": 58,
            "name": "PLL_SYS_IRQ_IRQHandler"
          },
          {
            "number": 59,
            "name": "PLL_USB_IRQ_IRQHandler"
          },
          {
            "number": 60,
            "name": "POWMAN_IRQ_POW_IRQHandler"
          },
          {
            "number": 61,
            "name": "POWMAN_IRQ_TIMER_IRQHandler"
          }
        ]
      }
    }
  }
}