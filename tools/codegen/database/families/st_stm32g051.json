{
  "family": "STM32G0",
  "architecture": "arm-cortex-m0",
  "vendor": "Unknown",
  "mcus": {
    "STM32G051": {
      "flash": {
        "size_kb": 64,
        "base_address": "0x08000000",
        "page_size_kb": 1
      },
      "ram": {
        "size_kb": 20,
        "base_address": "0x20000000"
      },
      "peripherals": {
        "ADC": {
          "instances": [
            {
              "name": "ADC",
              "base": "0x40012400",
              "irq": 12
            }
          ],
          "registers": {
            "ADC_ISR": {
              "offset": "0x00",
              "size": 32,
              "description": "ADC interrupt and status register"
            },
            "ADC_IER": {
              "offset": "0x04",
              "size": 32,
              "description": "ADC interrupt enable register"
            },
            "ADC_CR": {
              "offset": "0x08",
              "size": 32,
              "description": "ADC control register"
            },
            "ADC_CFGR1": {
              "offset": "0x0C",
              "size": 32,
              "description": "ADC configuration register 1"
            },
            "ADC_CFGR2": {
              "offset": "0x10",
              "size": 32,
              "description": "ADC configuration register 2"
            },
            "ADC_SMPR": {
              "offset": "0x14",
              "size": 32,
              "description": "ADC sampling time register"
            },
            "ADC_AWD1TR": {
              "offset": "0x20",
              "size": 32,
              "description": "ADC watchdog threshold register"
            },
            "ADC_AWD2TR": {
              "offset": "0x24",
              "size": 32,
              "description": "ADC watchdog threshold register"
            },
            "ADC_CHSELRMOD0": {
              "offset": "0x28",
              "size": 32,
              "description": "ADC channel selection register"
            },
            "ADC_CHSELRMOD1": {
              "offset": "0x28",
              "size": 32,
              "description": "ADC channel selection register"
            },
            "ADC_AWD3TR": {
              "offset": "0x2C",
              "size": 32,
              "description": "ADC watchdog threshold register"
            },
            "ADC_DR": {
              "offset": "0x40",
              "size": 32,
              "description": "ADC data register"
            },
            "ADC_AWD2CR": {
              "offset": "0xA0",
              "size": 32,
              "description": "ADC Analog Watchdog 2 Configuration register"
            },
            "ADC_AWD3CR": {
              "offset": "0xA4",
              "size": 32,
              "description": "ADC Analog Watchdog 3 Configuration register"
            },
            "ADC_CALFACT": {
              "offset": "0xB4",
              "size": 32,
              "description": "ADC Calibration factor"
            },
            "ADC_CCR": {
              "offset": "0x308",
              "size": 32,
              "description": "ADC common configuration register"
            }
          },
          "bits": {
            "ADC_ISR": {
              "ADRDY": {
                "bit": 0,
                "description": "ADC ready\n\tThis bit is set by hardware after the ADC has been enabled (ADEN\u00c2\u00a0=\u00c2\u00a01) and when the ADC reaches a state where it is ready to accept conversion requests.\n\tIt is cleared by software writing 1 to it."
              },
              "EOSMP": {
                "bit": 1,
                "description": "End of sampling flag\n\tThis bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to '1\u00e2\u0080\u0099."
              },
              "EOC": {
                "bit": 2,
                "description": "End of conversion flag\n\tThis bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register."
              },
              "EOS": {
                "bit": 3,
                "description": "End of sequence flag\n\tThis bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it."
              },
              "OVR": {
                "bit": 4,
                "description": "ADC overrun\n\tThis bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it."
              },
              "AWD1": {
                "bit": 7,
                "description": "Analog watchdog 1 flag\n\tThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1."
              },
              "AWD2": {
                "bit": 8,
                "description": "Analog watchdog 2 flag\n\tThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it."
              },
              "AWD3": {
                "bit": 9,
                "description": "Analog watchdog 3 flag\n\tThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1."
              },
              "EOCAL": {
                "bit": 11,
                "description": "End Of Calibration flag\n\tThis bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it."
              },
              "CCRDY": {
                "bit": 13,
                "description": "Channel Configuration Ready flag\n\tThis flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it.\n\tNote: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration."
              }
            },
            "ADC_IER": {
              "ADRDYIE": {
                "bit": 0,
                "description": "ADC ready interrupt enable\n\tThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "EOSMPIE": {
                "bit": 1,
                "description": "End of sampling flag interrupt enable\n\tThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "EOCIE": {
                "bit": 2,
                "description": "End of conversion interrupt enable\n\tThis bit is set and cleared by software to enable/disable the end of conversion interrupt.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "EOSIE": {
                "bit": 3,
                "description": "End of conversion sequence interrupt enable\n\tThis bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "OVRIE": {
                "bit": 4,
                "description": "Overrun interrupt enable\n\tThis bit is set and cleared by software to enable/disable the overrun interrupt.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "AWD1IE": {
                "bit": 7,
                "description": "Analog watchdog 1 interrupt enable\n\tThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\n\tNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "AWD2IE": {
                "bit": 8,
                "description": "Analog watchdog 2 interrupt enable\n\tThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\n\tNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "AWD3IE": {
                "bit": 9,
                "description": "Analog watchdog 3 interrupt enable\n\tThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\n\tNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "EOCALIE": {
                "bit": 11,
                "description": "End of calibration interrupt enable\n\tThis bit is set and cleared by software to enable/disable the end of calibration interrupt.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "CCRDYIE": {
                "bit": 13,
                "description": "Channel Configuration Ready Interrupt enable\n\tThis bit is set and cleared by software to enable/disable the channel configuration ready interrupt.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              }
            },
            "ADC_CR": {
              "ADEN": {
                "bit": 0,
                "description": "ADC enable command\n\tThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.\n\tIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.\n\tNote: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL\u00c2\u00a0=\u00c2\u00a00, ADSTP\u00c2\u00a0=\u00c2\u00a00, ADSTART\u00c2\u00a0=\u00c2\u00a00, ADDIS\u00c2\u00a0=\u00c2\u00a00 and ADEN\u00c2\u00a0=\u00c2\u00a00)"
              },
              "ADDIS": {
                "bit": 1,
                "description": "ADC disable command\n\tThis bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).\n\tIt is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).\n\tNote: Setting ADDIS to '1\u00e2\u0080\u0099 is only effective when ADEN\u00c2\u00a0=\u00c2\u00a01 and ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)"
              },
              "ADSTART": {
                "bit": 2,
                "description": "ADC start conversion command\n\tThis bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration).\n\tIt is cleared by hardware:\n\tIn single conversion mode (CONT\u00c2\u00a0=\u00c2\u00a00, DISCEN\u00c2\u00a0=\u00c2\u00a00), when software trigger is selected (EXTEN\u00c2\u00a0=\u00c2\u00a000): at the assertion of the end of Conversion Sequence (EOS) flag.\n\tIn discontinuous conversion mode(CONT\u00c2\u00a0=\u00c2\u00a00, DISCEN\u00c2\u00a0=\u00c2\u00a01), when the software trigger is selected (EXTEN\u00c2\u00a0=\u00c2\u00a000): at the assertion of the end of Conversion (EOC) flag.\n\tIn all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware.\n\tNote: The software is allowed to set ADSTART only when ADEN\u00c2\u00a0=\u00c2\u00a01 and ADDIS\u00c2\u00a0=\u00c2\u00a00 (ADC is enabled and there is no pending request to disable the ADC).\n\tAfter writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored."
              },
              "ADSTP": {
                "bit": 4,
                "description": "ADC stop conversion command\n\tThis bit is set by software to stop and discard an ongoing conversion (ADSTP Command).\n\tIt is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command.\n\tNote: Setting ADSTP to '1\u00e2\u0080\u0099 is only effective when ADSTART\u00c2\u00a0=\u00c2\u00a01 and ADDIS\u00c2\u00a0=\u00c2\u00a00 (ADC is enabled and may be converting and there is no pending request to disable the ADC)"
              },
              "ADVREGEN": {
                "bit": 28,
                "description": "ADC Voltage Regulator Enable\n\tThis bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP.\n\tIt is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0.\n\tNote: The software is allowed to program this bit field only when the ADC is disabled (ADCAL\u00c2\u00a0=\u00c2\u00a00, ADSTART\u00c2\u00a0=\u00c2\u00a00, ADSTP\u00c2\u00a0=\u00c2\u00a00, ADDIS\u00c2\u00a0=\u00c2\u00a00 and ADEN\u00c2\u00a0=\u00c2\u00a00)."
              },
              "ADCAL": {
                "bit": 31,
                "description": "ADC calibration\n\tThis bit is set by software to start the calibration of the ADC.\n\tIt is cleared by hardware after calibration is complete.\n\tNote: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL\u00c2\u00a0=\u00c2\u00a00, ADSTART\u00c2\u00a0=\u00c2\u00a00, ADSTP\u00c2\u00a0=\u00c2\u00a00, ADDIS\u00c2\u00a0=\u00c2\u00a00 and ADEN\u00c2\u00a0=\u00c2\u00a00).\n\tThe software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN\u00c2\u00a0=\u00c2\u00a01 and ADSTART\u00c2\u00a0=\u00c2\u00a00 (ADC enabled and no conversion is ongoing)."
              }
            },
            "ADC_CFGR1": {
              "DMAEN": {
                "bit": 0,
                "description": "Direct memory access enable\n\tThis bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to .\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "DMACFG": {
                "bit": 1,
                "description": "Direct memory access configuration\n\tThis bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN\u00c2\u00a0=\u00c2\u00a01.\n\tFor more details, refer to page\u00c2\u00a0391\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "SCANDIR": {
                "bit": 2,
                "description": "Scan sequence direction\n\tThis bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "RES": {
                "bit": 3,
                "description": "Data resolution\n\tThese bits are written by software to select the resolution of the conversion.\n\tNote: The software is allowed to write these bits only when ADEN\u00c2\u00a0=\u00c2\u00a00.",
                "width": 2
              },
              "ALIGN": {
                "bit": 5,
                "description": "Data alignment\n\tThis bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on page\u00c2\u00a0389\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "EXTSEL": {
                "bit": 6,
                "description": "External trigger selection\n\tThese bits select the external event used to trigger the start of conversion (refer to External triggers for details):\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).",
                "width": 3
              },
              "EXTEN": {
                "bit": 10,
                "description": "External trigger enable and polarity selection\n\tThese bits are set and cleared by software to select the external trigger polarity and enable the trigger.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).",
                "width": 2
              },
              "OVRMOD": {
                "bit": 12,
                "description": "Overrun management mode\n\tThis bit is set and cleared by software and configure the way data overruns are managed.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "CONT": {
                "bit": 13,
                "description": "Single / continuous conversion mode\n\tThis bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.\n\tNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN\u00c2\u00a0=\u00c2\u00a01 and CONT\u00c2\u00a0=\u00c2\u00a01.\n\tThe software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "WAIT": {
                "bit": 14,
                "description": "Wait conversion mode\n\tThis bit is set and cleared by software to enable/disable wait conversion mode..\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "AUTOFF": {
                "bit": 15,
                "description": "Auto-off mode\n\tThis bit is set and cleared by software to enable/disable auto-off mode..\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "DISCEN": {
                "bit": 16,
                "description": "Discontinuous mode\n\tThis bit is set and cleared by software to enable/disable discontinuous mode.\n\tNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN\u00c2\u00a0=\u00c2\u00a01 and CONT\u00c2\u00a0=\u00c2\u00a01.\n\tThe software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "CHSELRMOD": {
                "bit": 21,
                "description": "Mode selection of the ADC_CHSELR register\n\tThis bit is set and cleared by software to control the ADC_CHSELR feature:\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "AWD1SGL": {
                "bit": 22,
                "description": "Enable the watchdog on a single channel or on all channels\n\tThis bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "AWD1EN": {
                "bit": 23,
                "description": "Analog watchdog enable\n\tThis bit is set and cleared by software.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "AWD1CH": {
                "bit": 26,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.\n\t.....\n\tOthers: Reserved\n\tNote: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register.\n\tThe software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).",
                "width": 5
              }
            },
            "ADC_CFGR2": {
              "OVSE": {
                "bit": 0,
                "description": "Oversampler Enable\n\tThis bit is set and cleared by software.\n\tNote: Software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "OVSR": {
                "bit": 2,
                "description": "Oversampling ratio\n\tThis bit filed defines the number of oversampling ratio.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 3
              },
              "OVSS": {
                "bit": 5,
                "description": "Oversampling shift\n\tThis bit is set and cleared by software.\n\tOthers: Reserved\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              },
              "TOVS": {
                "bit": 9,
                "description": "Triggered Oversampling\n\tThis bit is set and cleared by software.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "LFTRIG": {
                "bit": 29,
                "description": "Low frequency trigger mode enable\n\tThis bit is set and cleared by software.\n\tNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
              },
              "CKMODE": {
                "bit": 30,
                "description": "ADC clock mode\n\tThese bits are set and cleared by software to define how the analog ADC is clocked:\n\tIn all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.\n\tNote: The software is allowed to write these bits only when the ADC is disabled (ADCAL\u00c2\u00a0=\u00c2\u00a00, ADSTART\u00c2\u00a0=\u00c2\u00a00, ADSTP\u00c2\u00a0=\u00c2\u00a00, ADDIS\u00c2\u00a0=\u00c2\u00a00 and ADEN\u00c2\u00a0=\u00c2\u00a00).",
                "width": 2
              }
            },
            "ADC_SMPR": {
              "SMP1": {
                "bit": 0,
                "description": "Sampling time selection 1\n\tThese bits are written by software to select the sampling time that applies to all channels.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 3
              },
              "SMP2": {
                "bit": 4,
                "description": "Sampling time selection 2\n\tThese bits are written by software to select the sampling time that applies to all channels.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 3
              },
              "SMPSEL0": {
                "bit": 8,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL1": {
                "bit": 9,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL2": {
                "bit": 10,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL3": {
                "bit": 11,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL4": {
                "bit": 12,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL5": {
                "bit": 13,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL6": {
                "bit": 14,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL7": {
                "bit": 15,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL8": {
                "bit": 16,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL9": {
                "bit": 17,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL10": {
                "bit": 18,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL11": {
                "bit": 19,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL12": {
                "bit": 20,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL13": {
                "bit": 21,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL14": {
                "bit": 22,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL15": {
                "bit": 23,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL16": {
                "bit": 24,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL17": {
                "bit": 25,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "SMPSEL18": {
                "bit": 26,
                "description": "Channel-x sampling time selection\n\tThese bits are written by software to define which sampling time is used.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              }
            },
            "ADC_AWD1TR": {
              "LT1": {
                "bit": 0,
                "description": "Analog watchdog 1 lower threshold\n\tThese bits are written by software to define the lower threshold for the analog watchdog.\n\tRefer to ADC_AWDxTR) on page\u00c2\u00a0395.",
                "width": 12
              },
              "HT1": {
                "bit": 16,
                "description": "Analog watchdog 1 higher threshold\n\tThese bits are written by software to define the higher threshold for the analog watchdog.\n\tRefer to ADC_AWDxTR) on page\u00c2\u00a0395.",
                "width": 12
              }
            },
            "ADC_AWD2TR": {
              "LT2": {
                "bit": 0,
                "description": "Analog watchdog 2 lower threshold\n\tThese bits are written by software to define the lower threshold for the analog watchdog.\n\tRefer to ADC_AWDxTR) on page\u00c2\u00a0395.",
                "width": 12
              },
              "HT2": {
                "bit": 16,
                "description": "Analog watchdog 2 higher threshold\n\tThese bits are written by software to define the higher threshold for the analog watchdog.\n\tRefer to ADC_AWDxTR) on page\u00c2\u00a0395.",
                "width": 12
              }
            },
            "ADC_CHSELRMOD0": {
              "CHSEL0": {
                "bit": 0,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL1": {
                "bit": 1,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL2": {
                "bit": 2,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL3": {
                "bit": 3,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL4": {
                "bit": 4,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL5": {
                "bit": 5,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL6": {
                "bit": 6,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL7": {
                "bit": 7,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL8": {
                "bit": 8,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL9": {
                "bit": 9,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL10": {
                "bit": 10,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL11": {
                "bit": 11,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL12": {
                "bit": 12,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL13": {
                "bit": 13,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL14": {
                "bit": 14,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL15": {
                "bit": 15,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL16": {
                "bit": 16,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL17": {
                "bit": 17,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              },
              "CHSEL18": {
                "bit": 18,
                "description": "Channel-x selection\n\tThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).\n\tIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
              }
            },
            "ADC_CHSELRMOD1": {
              "SQ1": {
                "bit": 0,
                "description": "1st conversion of the sequence\n\tThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\n\tWhen 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.\n\tRefer to SQ8[3:0] for a definition of channel selection.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              },
              "SQ2": {
                "bit": 4,
                "description": "2nd conversion of the sequence\n\tThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\n\tWhen 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.\n\tRefer to SQ8[3:0] for a definition of channel selection.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              },
              "SQ3": {
                "bit": 8,
                "description": "3rd conversion of the sequence\n\tThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\n\tWhen 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.\n\tRefer to SQ8[3:0] for a definition of channel selection.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              },
              "SQ4": {
                "bit": 12,
                "description": "4th conversion of the sequence\n\tThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\n\tWhen 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.\n\tRefer to SQ8[3:0] for a definition of channel selection.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              },
              "SQ5": {
                "bit": 16,
                "description": "5th conversion of the sequence\n\tThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\n\tWhen 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.\n\tRefer to SQ8[3:0] for a definition of channel selection.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              },
              "SQ6": {
                "bit": 20,
                "description": "6th conversion of the sequence\n\tThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\n\tWhen 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.\n\tRefer to SQ8[3:0] for a definition of channel selection.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              },
              "SQ7": {
                "bit": 24,
                "description": "7th conversion of the sequence\n\tThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\n\tWhen 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.\n\tRefer to SQ8[3:0] for a definition of channel selection.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              },
              "SQ8": {
                "bit": 28,
                "description": "8th conversion of the sequence\n\tThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence.\n\tWhen 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.\n\t...\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing).",
                "width": 4
              }
            },
            "ADC_AWD3TR": {
              "LT3": {
                "bit": 0,
                "description": "Analog watchdog 3lower threshold\n\tThese bits are written by software to define the lower threshold for the analog watchdog.\n\tRefer to ADC_AWDxTR) on page\u00c2\u00a0395.",
                "width": 12
              },
              "HT3": {
                "bit": 16,
                "description": "Analog watchdog 3 higher threshold\n\tThese bits are written by software to define the higher threshold for the analog watchdog.\n\tRefer to ADC_AWDxTR) on page\u00c2\u00a0395.",
                "width": 12
              }
            },
            "ADC_DR": {
              "DATA": {
                "bit": 0,
                "description": "Converted data\n\tThese bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on page\u00c2\u00a0389.\n\tJust after a calibration is complete, DATA[6:0] contains the calibration factor.",
                "width": 16
              }
            },
            "ADC_AWD2CR": {
              "AWD2CH0": {
                "bit": 0,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH1": {
                "bit": 1,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH2": {
                "bit": 2,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH3": {
                "bit": 3,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH4": {
                "bit": 4,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH5": {
                "bit": 5,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH6": {
                "bit": 6,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH7": {
                "bit": 7,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH8": {
                "bit": 8,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH9": {
                "bit": 9,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH10": {
                "bit": 10,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH11": {
                "bit": 11,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH12": {
                "bit": 12,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH13": {
                "bit": 13,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH14": {
                "bit": 14,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH15": {
                "bit": 15,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH16": {
                "bit": 16,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH17": {
                "bit": 17,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "AWD2CH18": {
                "bit": 18,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\tNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              }
            },
            "ADC_AWD3CR": {
              "AWD3CH0": {
                "bit": 0,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH1": {
                "bit": 1,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH2": {
                "bit": 2,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH3": {
                "bit": 3,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH4": {
                "bit": 4,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH5": {
                "bit": 5,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH6": {
                "bit": 6,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH7": {
                "bit": 7,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH8": {
                "bit": 8,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH9": {
                "bit": 9,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH10": {
                "bit": 10,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH11": {
                "bit": 11,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH12": {
                "bit": 12,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH13": {
                "bit": 13,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH14": {
                "bit": 14,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH15": {
                "bit": 15,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH16": {
                "bit": 16,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH17": {
                "bit": 17,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              },
              "AWD3CH18": {
                "bit": 18,
                "description": "Analog watchdog channel selection\n\tThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\tNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
              }
            },
            "ADC_CALFACT": {
              "CALFACT": {
                "bit": 0,
                "description": "Calibration factor\n\tThese bits are written by hardware or by software.\n\tOnce a calibration is complete,\u00c2\u00a0they are updated by hardware with the calibration factors.\n\tSoftware can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched.\n\tJust after a calibration is complete, DATA[6:0] contains the calibration factor.\n\tNote: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection.",
                "width": 7
              }
            },
            "ADC_CCR": {
              "PRESC": {
                "bit": 18,
                "description": "ADC prescaler\nSet and cleared by software to select the frequency of the clock to the ADC.\nOther: Reserved\nNote: Software is allowed to write these bits only when the ADC is disabled (ADCAL\u00c2\u00a0=\u00c2\u00a00, ADSTART\u00c2\u00a0=\u00c2\u00a00, ADSTP\u00c2\u00a0=\u00c2\u00a00, ADDIS\u00c2\u00a0=\u00c2\u00a00 and ADEN\u00c2\u00a0=\u00c2\u00a00).",
                "width": 4
              },
              "VREFEN": {
                "bit": 22,
                "description": "VREFINT enable\n\tThis bit is set and cleared by software to enable/disable the VREFINT.\n\tNote: Software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "TSEN": {
                "bit": 23,
                "description": "Temperature sensor enable\n\tThis bit is set and cleared by software to enable/disable the temperature sensor.\n\tNote: Software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)."
              },
              "VBATEN": {
                "bit": 24,
                "description": "VBAT enable\n\tThis bit is set and cleared by software to enable/disable the VBAT channel.\n\tNote: The software is allowed to write this bit only when ADSTART\u00c2\u00a0=\u00c2\u00a00 (which ensures that no conversion is ongoing)"
              }
            }
          }
        },
        "COMP": {
          "instances": [
            {
              "name": "COMP",
              "base": "0x40010200"
            }
          ],
          "registers": {
            "COMP1_CSR": {
              "offset": "0x00",
              "size": 32,
              "description": "Comparator 1 control and status register"
            },
            "COMP2_CSR": {
              "offset": "0x04",
              "size": 32,
              "description": "Comparator 2 control and status register"
            },
            "COMP3_CSR": {
              "offset": "0x08",
              "size": 32,
              "description": "Comparator 2 control and status register"
            }
          },
          "bits": {
            "COMP1_CSR": {
              "EN": {
                "bit": 0,
                "description": "Comparator 1 enable bit\nThis bit is controlled by software (if not locked). It enables the comparator 1:"
              },
              "INMSEL": {
                "bit": 4,
                "description": "Comparator 1 signal selector for inverting input INM\nThis bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP1_INM of the comparator 1:\n> 1000: 1/4 VREFINT",
                "width": 4
              },
              "INPSEL": {
                "bit": 8,
                "description": "Comparator 1 signal selector for non-inverting input\nThis bitfield is controlled by software (if not locked). It selects the signal for the non-inverting input COMP1_INP of the comparator 1 (also see the WINMODE bit):",
                "width": 2
              },
              "WINMODE": {
                "bit": 11,
                "description": "Comparator 1 non-inverting input selector for window mode\nThis bit is controlled by software (if not locked). It selects the signal for COMP1_INP input of the comparator 1:"
              },
              "WINOUT": {
                "bit": 14,
                "description": "Comparator 1 output selector\nThis bit is controlled by software (if not locked). It selects the comparator 1 output:"
              },
              "POLARITY": {
                "bit": 15,
                "description": "Comparator 1 polarity selector\nThis bit is controlled by software (if not locked). It selects the comparator 1 output polarity:"
              },
              "HYST": {
                "bit": 16,
                "description": "Comparator 1 hysteresis selector\nThis bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 1:",
                "width": 2
              },
              "PWRMODE": {
                "bit": 18,
                "description": "Comparator 1 power mode selector\nThis bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 1:\nothers: Reserved",
                "width": 2
              },
              "BLANKSEL": {
                "bit": 20,
                "description": "Comparator 1 blanking source selector\nThis bitfield is controlled by software (if not locked). It selects the blanking source:\nxxxx1: TIM1 OC4\nxxx1x: TIM1 OC5\nxx1xx: TIM2 OC3\nx1xxx: TIM3 OC3\n1xxxx: TIM15 OC2",
                "width": 5
              },
              "VALUE": {
                "bit": 30,
                "description": "Comparator 1 output status\nThis bit is read-only. It reflects the level of the comparator 1 output after the polarity selector and blanking, as indicated in ."
              },
              "LOCK": {
                "bit": 31,
                "description": "COMP1_CSR register lock\nThis bit is set by software and cleared by a system reset. It locks the whole content of the comparator 1 control register COMP1_CSR[31:0]:"
              }
            },
            "COMP2_CSR": {
              "EN": {
                "bit": 0,
                "description": "Comparator 2 enable bit\nThis bit is controlled by software (if not locked). It enables the comparator 2:"
              },
              "INMSEL": {
                "bit": 4,
                "description": "Comparator 2 signal selector for inverting input INM\nThis bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP2_INM of the comparator 2:\n> 1000: 1/4 VREFINT",
                "width": 4
              },
              "INPSEL": {
                "bit": 8,
                "description": "Comparator 2 signal selector for non-inverting input\nThis bitfield is controlled by software (if not locked). It selects the signal for the non-inverting input COMP2_INP of the comparator 2 (also see the WINMODE bit):",
                "width": 2
              },
              "WINMODE": {
                "bit": 11,
                "description": "Comparator 2 non-inverting input selector for window mode\nThis bit is controlled by software (if not locked). It selects the signal for COMP2_INP input of the comparator 2:"
              },
              "WINOUT": {
                "bit": 14,
                "description": "Comparator 2 output selector\nThis bit is controlled by software (if not locked). It selects the comparator 2 output:"
              },
              "POLARITY": {
                "bit": 15,
                "description": "Comparator 2 polarity selector\nThis bit is controlled by software (if not locked). It selects the comparator 2 output polarity:"
              },
              "HYST": {
                "bit": 16,
                "description": "Comparator 2 hysteresis selector\nThis bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 2:",
                "width": 2
              },
              "PWRMODE": {
                "bit": 18,
                "description": "Comparator 2 power mode selector\nThis bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 2:\nothers: Reserved",
                "width": 2
              },
              "BLANKSEL": {
                "bit": 20,
                "description": "Comparator 2 blanking source selector\nThis bitfield is controlled by software (if not locked). It selects the blanking source:\nxxxx1: TIM1 OC4\nxxx1x: TIM1 OC5\nxx1xx: TIM2 OC3\nx1xxx: TIM3 OC3\n1xxxx: TIM15 OC2",
                "width": 5
              },
              "VALUE": {
                "bit": 30,
                "description": "Comparator 2 output status\nThis bit is read-only. It reflects the level of the comparator 2 output after the polarity selector and blanking, as indicated in ."
              },
              "LOCK": {
                "bit": 31,
                "description": "COMP2_CSR register lock\nThis bit is set by software and cleared by a system reset. It locks the whole content of the comparator 2 control register COMP2_CSR[31:0]:"
              }
            },
            "COMP3_CSR": {
              "EN": {
                "bit": 0,
                "description": "Comparator 3 enable bit\nThis bit is controlled by software (if not locked). It enables the comparator 3:"
              },
              "INMSEL": {
                "bit": 4,
                "description": "Comparator 3 signal selector for inverting input INM\nThis bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP3_INM of the comparator 3:\n> 1000: 1/4 VREFINT",
                "width": 4
              },
              "INPSEL": {
                "bit": 8,
                "description": "Comparator 3 signal selector for non-inverting input\nThis bitfield is controlled by software (if not locked). It selects the signal for the non-inverting input COMP3_INP of the comparator 3 (also see the WINMODE bit):",
                "width": 2
              },
              "WINMODE": {
                "bit": 11,
                "description": "Comparator 3 non-inverting input selector for window mode\nThis bit is controlled by software (if not locked). It selects the signal for COMP3_INP input of the comparator 3:"
              },
              "WINOUT": {
                "bit": 14,
                "description": "Comparator 3 output selector\nThis bit is controlled by software (if not locked). It selects the comparator 3 output:"
              },
              "POLARITY": {
                "bit": 15,
                "description": "Comparator 2 polarity selector\nThis bit is controlled by software (if not locked). It selects the comparator 3 output polarity:"
              },
              "HYST": {
                "bit": 16,
                "description": "Comparator 3 hysteresis selector\nThis bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 3:",
                "width": 2
              },
              "PWRMODE": {
                "bit": 18,
                "description": "Comparator 3 power mode selector\nThis bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 3:\nothers: Reserved",
                "width": 2
              },
              "BLANKSEL": {
                "bit": 20,
                "description": "Comparator 3 blanking source selector\nThis bitfield is controlled by software (if not locked). It selects the blanking source:\nxxxx1: TIM1 OC4\nxxx1x: TIM1 OC5\nxx1xx: TIM2 OC3\nx1xxx: TIM3 OC3\n1xxxx: TIM15 OC2",
                "width": 5
              },
              "VALUE": {
                "bit": 30,
                "description": "Comparator 3 output status\nThis bit is read-only. It reflects the level of the comparator 2 output after the polarity selector and blanking, as indicated in ."
              },
              "LOCK": {
                "bit": 31,
                "description": "COMP3_CSR register lock\nThis bit is set by software and cleared by a system reset. It locks the whole content of the comparator 3 control register COMP3_CSR[31:0]:"
              }
            }
          }
        },
        "CRC": {
          "instances": [
            {
              "name": "CRC",
              "base": "0x40023000"
            }
          ],
          "registers": {
            "CRC_DR": {
              "offset": "0x00",
              "size": 32,
              "description": "Data register"
            },
            "CRC_IDR": {
              "offset": "0x04",
              "size": 32,
              "description": "Independent data register"
            },
            "CRC_CR": {
              "offset": "0x08",
              "size": 32,
              "description": "Control register"
            },
            "CRC_INIT": {
              "offset": "0x10",
              "size": 32,
              "description": "Initial CRC value"
            },
            "CRC_POL": {
              "offset": "0x14",
              "size": 32,
              "description": "polynomial"
            }
          },
          "bits": {
            "CRC_DR": {
              "DR": {
                "bit": 0,
                "description": "Data register bits",
                "width": 32
              }
            },
            "CRC_IDR": {
              "IDR": {
                "bit": 0,
                "description": "General-purpose 32-bit data register\n              bits",
                "width": 32
              }
            },
            "CRC_CR": {
              "REV_OUT": {
                "bit": 7,
                "description": "Reverse output data\nThis bit controls the reversal of the bit order of the output data."
              },
              "REV_IN": {
                "bit": 5,
                "description": "Reverse input data\nThese bits control the reversal of the bit order of the input data",
                "width": 2
              },
              "POLYSIZE": {
                "bit": 3,
                "description": "Polynomial size\nThese bits control the size of the polynomial.",
                "width": 2
              },
              "RESET": {
                "bit": 0,
                "description": "RESET bit"
              }
            },
            "CRC_INIT": {
              "CRC_INIT": {
                "bit": 0,
                "description": "Programmable initial CRC\n              value",
                "width": 32
              }
            },
            "CRC_POL": {
              "POL": {
                "bit": 0,
                "description": "Programmable polynomial",
                "width": 32
              }
            }
          }
        },
        "DAC": {
          "instances": [
            {
              "name": "DAC",
              "base": "0x40007400",
              "irq": 17
            }
          ],
          "registers": {
            "DAC_CR": {
              "offset": "0x00",
              "size": 32,
              "description": "DAC control register"
            },
            "DAC_SWTRGR": {
              "offset": "0x04",
              "size": 32,
              "description": "DAC software trigger register"
            },
            "DAC_DHR12R1": {
              "offset": "0x08",
              "size": 32,
              "description": "DAC channel1 12-bit right-aligned data\n          holding register"
            },
            "DAC_DHR12L1": {
              "offset": "0x0C",
              "size": 32,
              "description": "DAC channel1 12-bit left aligned data\n          holding register"
            },
            "DAC_DHR8R1": {
              "offset": "0x10",
              "size": 32,
              "description": "DAC channel1 8-bit right aligned data\n          holding register"
            },
            "DAC_DHR12R2": {
              "offset": "0x14",
              "size": 32,
              "description": "DAC channel2 12-bit right aligned data\n          holding register"
            },
            "DAC_DHR12L2": {
              "offset": "0x18",
              "size": 32,
              "description": "DAC channel2 12-bit left aligned data\n          holding register"
            },
            "DAC_DHR8R2": {
              "offset": "0x1C",
              "size": 32,
              "description": "DAC channel2 8-bit right-aligned data\n          holding register"
            },
            "DAC_DHR12RD": {
              "offset": "0x20",
              "size": 32,
              "description": "Dual DAC 12-bit right-aligned data holding\n          register"
            },
            "DAC_DHR12LD": {
              "offset": "0x24",
              "size": 32,
              "description": "DUAL DAC 12-bit left aligned data holding\n          register"
            },
            "DAC_DHR8RD": {
              "offset": "0x28",
              "size": 32,
              "description": "DUAL DAC 8-bit right aligned data holding\n          register"
            },
            "DAC_DOR1": {
              "offset": "0x2C",
              "size": 32,
              "description": "DAC channel1 data output\n          register"
            },
            "DAC_DOR2": {
              "offset": "0x30",
              "size": 32,
              "description": "DAC channel2 data output\n          register"
            },
            "DAC_SR": {
              "offset": "0x34",
              "size": 32,
              "description": "DAC status register"
            },
            "DAC_CCR": {
              "offset": "0x38",
              "size": 32,
              "description": "DAC calibration control\n          register"
            },
            "DAC_MCR": {
              "offset": "0x3C",
              "size": 32,
              "description": "DAC mode control register"
            },
            "DAC_SHSR1": {
              "offset": "0x40",
              "size": 32,
              "description": "DAC Sample and Hold sample time register\n          1"
            },
            "DAC_SHSR2": {
              "offset": "0x44",
              "size": 32,
              "description": "DAC Sample and Hold sample time register\n          2"
            },
            "DAC_SHHR": {
              "offset": "0x48",
              "size": 32,
              "description": "DAC Sample and Hold hold time\n          register"
            },
            "DAC_SHRR": {
              "offset": "0x4C",
              "size": 32,
              "description": "DAC Sample and Hold refresh time\n          register"
            }
          },
          "bits": {
            "DAC_CR": {
              "EN1": {
                "bit": 0,
                "description": "DAC channel1 enable\nThis bit is set and cleared by software to enable/disable DAC channel1."
              },
              "TEN1": {
                "bit": 1,
                "description": "DAC channel1 trigger enable\nThis bit is set and cleared by software to enable/disable DAC channel1 trigger.\nNote: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_pclk clock cycle."
              },
              "TSEL1": {
                "bit": 2,
                "description": "DAC channel1 trigger selection\nThese bits select the external event used to trigger DAC channel1\n...\nRefer to the trigger selection tables in  for details on trigger configuration and mapping.\nNote: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).",
                "width": 4
              },
              "WAVE1": {
                "bit": 6,
                "description": "DAC channel1 noise/triangle wave generation enable\nThese bits are set and cleared by software.\n1x: Triangle wave generation enabled\nOnly used if bit TEN1 = 1 (DAC channel1 trigger enabled).",
                "width": 2
              },
              "MAMP1": {
                "bit": 8,
                "description": "DAC channel1 mask/amplitude selector\nThese bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.\n\u2265 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095",
                "width": 4
              },
              "DMAEN1": {
                "bit": 12,
                "description": "DAC channel1 DMA enable\nThis bit is set and cleared by software."
              },
              "DMAUDRIE1": {
                "bit": 13,
                "description": "DAC channel1 DMA Underrun Interrupt enable\nThis bit is set and cleared by software."
              },
              "CEN1": {
                "bit": 14,
                "description": "DAC channel1 calibration enable\nThis bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored."
              },
              "EN2": {
                "bit": 16,
                "description": "DAC channel2 enable\nThis bit is set and cleared by software to enable/disable DAC channel2.\nNote: These bits are available only on dual-channel DACs. Refer to implementation."
              },
              "TEN2": {
                "bit": 17,
                "description": "DAC channel2 trigger enable\nThis bit is set and cleared by software to enable/disable DAC channel2 trigger\nNote: When software trigger is selected, the transfer from the DAC_DHR2 register to the DAC_DOR2 register takes only one dac_pclk clock cycle.\nThese bits are available only on dual-channel DACs. Refer to implementation."
              },
              "TSEL2": {
                "bit": 18,
                "description": "DAC channel2 trigger selection\nThese bits select the external event used to trigger DAC channel2\n...\nRefer to the trigger selection tables in  for details on trigger configuration and mapping.\nNote: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).\nThese bits are available only on dual-channel DACs. Refer to implementation.",
                "width": 4
              },
              "WAVE2": {
                "bit": 22,
                "description": "DAC channel2 noise/triangle wave generation enable\nThese bits are set/reset by software.\n1x: Triangle wave generation enabled\nNote: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)\nThese bits are available only on dual-channel DACs. Refer to implementation.",
                "width": 2
              },
              "MAMP2": {
                "bit": 24,
                "description": "DAC channel2 mask/amplitude selector\nThese bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.\n\u2265 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095\nNote: These bits are available only on dual-channel DACs. Refer to implementation.",
                "width": 4
              },
              "DMAEN2": {
                "bit": 28,
                "description": "DAC channel2 DMA enable\nThis bit is set and cleared by software.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
              },
              "DMAUDRIE2": {
                "bit": 29,
                "description": "DAC channel2 DMA underrun interrupt enable\nThis bit is set and cleared by software.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
              },
              "CEN2": {
                "bit": 30,
                "description": "DAC channel2 calibration enable\nThis bit is set and cleared by software to enable/disable DAC channel2 calibration, it can be written only if EN2 bit is set to 0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
              }
            },
            "DAC_SWTRGR": {
              "SWTRIG1": {
                "bit": 0,
                "description": "DAC channel1 software trigger\nThis bit is set by software to trigger the DAC in software trigger mode.\nNote: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register."
              },
              "SWTRIG2": {
                "bit": 1,
                "description": "DAC channel2 software trigger\nThis bit is set by software to trigger the DAC in software trigger mode.\nNote: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.\nThis bit is available only on dual-channel DACs. Refer to implementation."
              }
            },
            "DAC_DHR12R1": {
              "DACC1DHR": {
                "bit": 0,
                "description": "DAC channel1 12-bit right-aligned data\nThese bits are written by software. They specify 12-bit data for DAC channel1.",
                "width": 12
              }
            },
            "DAC_DHR12L1": {
              "DACC1DHR": {
                "bit": 4,
                "description": "DAC channel1 12-bit left-aligned data\nThese bits are written by software.\nThey specify 12-bit data for DAC channel1.",
                "width": 12
              }
            },
            "DAC_DHR8R1": {
              "DACC1DHR": {
                "bit": 0,
                "description": "DAC channel1 8-bit right-aligned data\nThese bits are written by software. They specify 8-bit data for DAC channel1.",
                "width": 8
              }
            },
            "DAC_DHR12R2": {
              "DACC2DHR": {
                "bit": 0,
                "description": "DAC channel2 12-bit right-aligned data\nThese bits are written by software. They specify 12-bit data for DAC channel2.",
                "width": 12
              }
            },
            "DAC_DHR12L2": {
              "DACC2DHR": {
                "bit": 4,
                "description": "DAC channel2 12-bit left-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel2.",
                "width": 12
              }
            },
            "DAC_DHR8R2": {
              "DACC2DHR": {
                "bit": 0,
                "description": "DAC channel2 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel2.",
                "width": 8
              }
            },
            "DAC_DHR12RD": {
              "DACC1DHR": {
                "bit": 0,
                "description": "DAC channel1 12-bit right-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel1.",
                "width": 12
              },
              "DACC2DHR": {
                "bit": 16,
                "description": "DAC channel2 12-bit right-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel2.",
                "width": 12
              }
            },
            "DAC_DHR12LD": {
              "DACC1DHR": {
                "bit": 4,
                "description": "DAC channel1 12-bit left-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel1.",
                "width": 12
              },
              "DACC2DHR": {
                "bit": 20,
                "description": "DAC channel2 12-bit left-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel2.",
                "width": 12
              }
            },
            "DAC_DHR8RD": {
              "DACC1DHR": {
                "bit": 0,
                "description": "DAC channel1 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel1.",
                "width": 8
              },
              "DACC2DHR": {
                "bit": 8,
                "description": "DAC channel2 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel2.",
                "width": 8
              }
            },
            "DAC_DOR1": {
              "DACC1DOR": {
                "bit": 0,
                "description": "DAC channel1 data output\nThese bits are read-only, they contain data output for DAC channel1.",
                "width": 12
              }
            },
            "DAC_DOR2": {
              "DACC2DOR": {
                "bit": 0,
                "description": "DAC channel2 data output\nThese bits are read-only, they contain data output for DAC channel2.",
                "width": 12
              }
            },
            "DAC_SR": {
              "DMAUDR1": {
                "bit": 13,
                "description": "DAC channel1 DMA underrun flag\nThis bit is set by hardware and cleared by software (by writing it to 1)."
              },
              "CAL_FLAG1": {
                "bit": 14,
                "description": "DAC channel1 calibration offset status\nThis bit is set and cleared by hardware"
              },
              "BWST1": {
                "bit": 15,
                "description": "DAC channel1 busy writing sample time flag\nThis bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI periods of synchronization)."
              },
              "DMAUDR2": {
                "bit": 29,
                "description": "DAC channel2 DMA underrun flag\nThis bit is set by hardware and cleared by software (by writing it to 1).\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
              },
              "CAL_FLAG2": {
                "bit": 30,
                "description": "DAC channel2 calibration offset status\nThis bit is set and cleared by hardware\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
              },
              "BWST2": {
                "bit": 31,
                "description": "DAC channel2 busy writing sample time flag\nThis bit is systematically set just after Sample and hold mode enable. It is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
              }
            },
            "DAC_CCR": {
              "OTRIM1": {
                "bit": 0,
                "description": "DAC channel1 offset trimming value",
                "width": 5
              },
              "OTRIM2": {
                "bit": 16,
                "description": "DAC channel2 offset trimming value\nThese bits are available only on dual-channel DACs. Refer to implementation.",
                "width": 5
              }
            },
            "DAC_MCR": {
              "MODE1": {
                "bit": 0,
                "description": "DAC channel1 mode\nThese bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored.\nThey can be set and cleared by software to select the DAC channel1 mode:\nDAC channel1 in Normal mode\nDAC channel1 in sample & hold mode\nNote: This register can be modified only when EN1=0.",
                "width": 3
              },
              "MODE2": {
                "bit": 16,
                "description": "DAC channel2 mode\nThese bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored.\nThey can be set and cleared by software to select the DAC channel2 mode:\nDAC channel2 in Normal mode\nDAC channel2 in Sample and hold mode\nNote: This register can be modified only when EN2=0.\nRefer to  for the availability of DAC channel2.",
                "width": 3
              }
            },
            "DAC_SHSR1": {
              "TSAMPLE1": {
                "bit": 0,
                "description": "DAC channel1 sample time (only valid in Sample and hold mode)\nThese bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST1=1, the write operation is ignored.",
                "width": 10
              }
            },
            "DAC_SHSR2": {
              "TSAMPLE2": {
                "bit": 0,
                "description": "DAC channel2 sample time (only valid in Sample and hold mode)\nThese bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWST2 of DAC_SR register is low, if BWST2=1, the write operation is ignored.",
                "width": 10
              }
            },
            "DAC_SHHR": {
              "THOLD1": {
                "bit": 0,
                "description": "DAC channel1 hold time (only valid in Sample and hold mode)\nHold time= (THOLD[9:0]) x LSI clock period\nNote: This register can be modified only when EN1=0.",
                "width": 10
              },
              "THOLD2": {
                "bit": 16,
                "description": "DAC channel2 hold time (only valid in Sample and hold mode).\nHold time= (THOLD[9:0]) x LSI clock period\nNote: This register can be modified only when EN2=0.\nThese bits are available only on dual-channel DACs. Refer to implementation.",
                "width": 10
              }
            },
            "DAC_SHRR": {
              "TREFRESH1": {
                "bit": 0,
                "description": "DAC channel1 refresh time (only valid in Sample and hold mode)\nRefresh time= (TREFRESH[7:0]) x LSI clock period\nNote: This register can be modified only when EN1=0.",
                "width": 8
              },
              "TREFRESH2": {
                "bit": 16,
                "description": "DAC channel2 refresh time (only valid in Sample and hold mode)\nRefresh time= (TREFRESH[7:0]) x LSI clock period\nNote: This register can be modified only when EN2=0.\nThese bits are available only on dual-channel DACs. Refer to implementation.",
                "width": 8
              }
            }
          }
        },
        "DBG": {
          "instances": [
            {
              "name": "DBG",
              "base": "0x40015800"
            }
          ],
          "registers": {
            "IDCODE": {
              "offset": "0x00",
              "size": 32,
              "description": "MCU Device ID Code Register"
            },
            "DBG_CR": {
              "offset": "0x04",
              "size": 32,
              "description": "DBG configuration register"
            },
            "DBG_APB_FZ1": {
              "offset": "0x08",
              "size": 32,
              "description": "DBG APB freeze register 1"
            },
            "DBG_APB_FZ2": {
              "offset": "0x0C",
              "size": 32,
              "description": "DBG APB freeze register 2"
            }
          },
          "bits": {
            "IDCODE": {
              "DEV_ID": {
                "bit": 0,
                "description": "Device Identifier",
                "width": 12
              },
              "REV_ID": {
                "bit": 16,
                "description": "Revision Identifier",
                "width": 16
              }
            },
            "DBG_CR": {
              "DBG_STOP": {
                "bit": 1,
                "description": "Debug Stop mode\nDebug options in Stop mode.\nUpon Stop mode exit, the software must re-establish the desired clock configuration."
              },
              "DBG_STANDBY": {
                "bit": 2,
                "description": "Debug Standby and Shutdown modes\nDebug options in Standby or Shutdown mode."
              }
            },
            "DBG_APB_FZ1": {
              "DBG_TIM2_STOP": {
                "bit": 0,
                "description": "Clocking of TIM2 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM2 when the core is halted:"
              },
              "DBG_TIM3_STOP": {
                "bit": 1,
                "description": "Clocking of TIM3 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM3 when the core is halted:"
              },
              "DBG_TIM6_STOP": {
                "bit": 4,
                "description": "Clocking of TIM6 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM6 when the core is halted:"
              },
              "DBG_TIM7_STOP": {
                "bit": 5,
                "description": "Clocking of TIM7 counter when the core is halted.\nThis bit enables/disables the clock to the counter of ITIM7 when the core is halted:"
              },
              "DBG_RTC_STOP": {
                "bit": 10,
                "description": "Clocking of RTC counter when the core is halted\nThis bit enables/disables the clock to the counter of RTC when the core is halted:"
              },
              "DBG_WWDG_STOP": {
                "bit": 11,
                "description": "Clocking of WWDG counter when the core is halted\nThis bit enables/disables the clock to the counter of WWDG when the core is halted:"
              },
              "DBG_IWDG_STOP": {
                "bit": 12,
                "description": "Clocking of IWDG counter when the core is halted\nThis bit enables/disables the clock to the counter of IWDG when the core is halted:"
              },
              "DBG_I2C1_SMBUS_TIMEOUT": {
                "bit": 21,
                "description": "SMBUS timeout when core is halted"
              },
              "DBG_LPTIM2_STOP": {
                "bit": 30,
                "description": "Clocking of LPTIMER2 counter when the core is halted\nThis bit enables/disables the clock to the counter of LPTIMER2 when the core is halted:"
              },
              "DBG_LPTIM1_STOP": {
                "bit": 31,
                "description": "Clocking of LPTIMER1 counter when the core is halted\nThis bit enables/disables the clock to the counter of LPTIMER1 when the core is halted:"
              }
            },
            "DBG_APB_FZ2": {
              "DBG_TIM1_STOP": {
                "bit": 11,
                "description": "Clocking of TIM1 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM1 when the core is halted:"
              },
              "DBG_TIM14_STOP": {
                "bit": 15,
                "description": "Clocking of TIM14 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM14 when the core is halted:"
              },
              "DBG_TIM15_STOP": {
                "bit": 16,
                "description": "Clocking of TIM15 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM15 when the core is halted:\nOnly available on STM32G071xx and STM32G081xx, reserved on STM32G031xx and STM32G041xx."
              },
              "DBG_TIM16_STOP": {
                "bit": 17,
                "description": "Clocking of TIM16 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM16 when the core is halted:"
              },
              "DBG_TIM17_STOP": {
                "bit": 18,
                "description": "Clocking of TIM17 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM17 when the core is halted:"
              }
            }
          }
        },
        "DMA": {
          "instances": [
            {
              "name": "DMA",
              "base": "0x40020000",
              "irq": 9
            },
            {
              "name": "DMAMUX",
              "base": "0x40020800",
              "irq": 11
            }
          ],
          "registers": {
            "DMA_ISR": {
              "offset": "0x00",
              "size": 32,
              "description": "DMA interrupt status register"
            },
            "DMA_IFCR": {
              "offset": "0x04",
              "size": 32,
              "description": "DMA interrupt flag clear register"
            },
            "DMA_CCR1": {
              "offset": "0x08",
              "size": 32,
              "description": "DMA channel 1 configuration register"
            },
            "DMA_CNDTR1": {
              "offset": "0x0C",
              "size": 32,
              "description": "DMA channel 1 number of data to transfer register"
            },
            "DMA_CPAR1": {
              "offset": "0x10",
              "size": 32,
              "description": "DMA channel 1 peripheral address register"
            },
            "DMA_CMAR1": {
              "offset": "0x14",
              "size": 32,
              "description": "DMA channel 1 memory address register"
            },
            "DMA_CCR2": {
              "offset": "0x1C",
              "size": 32,
              "description": "DMA channel 2 configuration register"
            },
            "DMA_CNDTR2": {
              "offset": "0x20",
              "size": 32,
              "description": "DMA channel 2 number of data to transfer register"
            },
            "DMA_CPAR2": {
              "offset": "0x24",
              "size": 32,
              "description": "DMA channel 2 peripheral address register"
            },
            "DMA_CMAR2": {
              "offset": "0x28",
              "size": 32,
              "description": "DMA channel 2 memory address register"
            },
            "DMA_CCR3": {
              "offset": "0x30",
              "size": 32,
              "description": "DMA channel 3 configuration register"
            },
            "DMA_CNDTR3": {
              "offset": "0x34",
              "size": 32,
              "description": "DMA channel 3 number of data to transfer register"
            },
            "DMA_CPAR3": {
              "offset": "0x38",
              "size": 32,
              "description": "DMA channel 3 peripheral address register"
            },
            "DMA_CMAR3": {
              "offset": "0x3C",
              "size": 32,
              "description": "DMA channel 3 memory address register"
            },
            "DMA_CCR4": {
              "offset": "0x44",
              "size": 32,
              "description": "DMA channel 4 configuration register"
            },
            "DMA_CNDTR4": {
              "offset": "0x48",
              "size": 32,
              "description": "DMA channel 4 number of data to transfer register"
            },
            "DMA_CPAR4": {
              "offset": "0x4C",
              "size": 32,
              "description": "DMA channel 4 peripheral address register"
            },
            "DMA_CMAR4": {
              "offset": "0x50",
              "size": 32,
              "description": "DMA channel 4 memory address register"
            },
            "DMA_CCR5": {
              "offset": "0x58",
              "size": 32,
              "description": "DMA channel 5 configuration register"
            },
            "DMA_CNDTR5": {
              "offset": "0x5C",
              "size": 32,
              "description": "DMA channel 5 number of data to transfer register"
            },
            "DMA_CPAR5": {
              "offset": "0x60",
              "size": 32,
              "description": "DMA channel 5 peripheral address register"
            },
            "DMA_CMAR5": {
              "offset": "0x64",
              "size": 32,
              "description": "DMA channel 5 memory address register"
            },
            "DMA_CCR6": {
              "offset": "0x6C",
              "size": 32,
              "description": "DMA channel 6 configuration register"
            },
            "DMA_CNDTR6": {
              "offset": "0x70",
              "size": 32,
              "description": "DMA channel 6 number of data to transfer register"
            },
            "DMA_CPAR6": {
              "offset": "0x74",
              "size": 32,
              "description": "DMA channel 6 peripheral address register"
            },
            "DMA_CMAR6": {
              "offset": "0x78",
              "size": 32,
              "description": "DMA channel 6 memory address register"
            },
            "DMA_CCR7": {
              "offset": "0x80",
              "size": 32,
              "description": "DMA channel 7 configuration register"
            },
            "DMA_CNDTR7": {
              "offset": "0x84",
              "size": 32,
              "description": "DMA channel 7 number of data to transfer register"
            },
            "DMA_CPAR7": {
              "offset": "0x88",
              "size": 32,
              "description": "DMA channel 7 peripheral address register"
            },
            "DMA_CMAR7": {
              "offset": "0x8C",
              "size": 32,
              "description": "DMA channel 7 memory address register"
            }
          },
          "bits": {
            "DMA_ISR": {
              "GIF1": {
                "bit": 0,
                "description": "global interrupt flag for channel 1"
              },
              "TCIF1": {
                "bit": 1,
                "description": "transfer complete (TC) flag for channel 1"
              },
              "HTIF1": {
                "bit": 2,
                "description": "half transfer (HT) flag for channel 1"
              },
              "TEIF1": {
                "bit": 3,
                "description": "transfer error (TE) flag for channel 1"
              },
              "GIF2": {
                "bit": 4,
                "description": "global interrupt flag for channel 2"
              },
              "TCIF2": {
                "bit": 5,
                "description": "transfer complete (TC) flag for channel 2"
              },
              "HTIF2": {
                "bit": 6,
                "description": "half transfer (HT) flag for channel 2"
              },
              "TEIF2": {
                "bit": 7,
                "description": "transfer error (TE) flag for channel 2"
              },
              "GIF3": {
                "bit": 8,
                "description": "global interrupt flag for channel 3"
              },
              "TCIF3": {
                "bit": 9,
                "description": "transfer complete (TC) flag for channel 3"
              },
              "HTIF3": {
                "bit": 10,
                "description": "half transfer (HT) flag for channel 3"
              },
              "TEIF3": {
                "bit": 11,
                "description": "transfer error (TE) flag for channel 3"
              },
              "GIF4": {
                "bit": 12,
                "description": "global interrupt flag for channel 4"
              },
              "TCIF4": {
                "bit": 13,
                "description": "transfer complete (TC) flag for channel 4"
              },
              "HTIF4": {
                "bit": 14,
                "description": "half transfer (HT) flag for channel 4"
              },
              "TEIF4": {
                "bit": 15,
                "description": "transfer error (TE) flag for channel 4"
              },
              "GIF5": {
                "bit": 16,
                "description": "global interrupt flag for channel 5"
              },
              "TCIF5": {
                "bit": 17,
                "description": "transfer complete (TC) flag for channel 5"
              },
              "HTIF5": {
                "bit": 18,
                "description": "half transfer (HT) flag for channel 5"
              },
              "TEIF5": {
                "bit": 19,
                "description": "transfer error (TE) flag for channel 5"
              },
              "GIF6": {
                "bit": 20,
                "description": "global interrupt flag for channel 6"
              },
              "TCIF6": {
                "bit": 21,
                "description": "transfer complete (TC) flag for channel 6"
              },
              "HTIF6": {
                "bit": 22,
                "description": "half transfer (HT) flag for channel 6"
              },
              "TEIF6": {
                "bit": 23,
                "description": "transfer error (TE) flag for channel 6"
              },
              "GIF7": {
                "bit": 24,
                "description": "global interrupt flag for channel 7"
              },
              "TCIF7": {
                "bit": 25,
                "description": "transfer complete (TC) flag for channel 7"
              },
              "HTIF7": {
                "bit": 26,
                "description": "half transfer (HT) flag for channel 7"
              },
              "TEIF7": {
                "bit": 27,
                "description": "transfer error (TE) flag for channel 7"
              }
            },
            "DMA_IFCR": {
              "CGIF1": {
                "bit": 0,
                "description": "global interrupt flag clear for channel 1"
              },
              "CTCIF1": {
                "bit": 1,
                "description": "transfer complete flag clear for channel 1"
              },
              "CHTIF1": {
                "bit": 2,
                "description": "half transfer flag clear for channel 1"
              },
              "CTEIF1": {
                "bit": 3,
                "description": "transfer error flag clear for channel 1"
              },
              "CGIF2": {
                "bit": 4,
                "description": "global interrupt flag clear for channel 2"
              },
              "CTCIF2": {
                "bit": 5,
                "description": "transfer complete flag clear for channel 2"
              },
              "CHTIF2": {
                "bit": 6,
                "description": "half transfer flag clear for channel 2"
              },
              "CTEIF2": {
                "bit": 7,
                "description": "transfer error flag clear for channel 2"
              },
              "CGIF3": {
                "bit": 8,
                "description": "global interrupt flag clear for channel 3"
              },
              "CTCIF3": {
                "bit": 9,
                "description": "transfer complete flag clear for channel 3"
              },
              "CHTIF3": {
                "bit": 10,
                "description": "half transfer flag clear for channel 3"
              },
              "CTEIF3": {
                "bit": 11,
                "description": "transfer error flag clear for channel 3"
              },
              "CGIF4": {
                "bit": 12,
                "description": "global interrupt flag clear for channel 4"
              },
              "CTCIF4": {
                "bit": 13,
                "description": "transfer complete flag clear for channel 4"
              },
              "CHTIF4": {
                "bit": 14,
                "description": "half transfer flag clear for channel 4"
              },
              "CTEIF4": {
                "bit": 15,
                "description": "transfer error flag clear for channel 4"
              },
              "CGIF5": {
                "bit": 16,
                "description": "global interrupt flag clear for channel 5"
              },
              "CTCIF5": {
                "bit": 17,
                "description": "transfer complete flag clear for channel 5"
              },
              "CHTIF5": {
                "bit": 18,
                "description": "half transfer flag clear for channel 5"
              },
              "CTEIF5": {
                "bit": 19,
                "description": "transfer error flag clear for channel 5"
              },
              "CGIF6": {
                "bit": 20,
                "description": "global interrupt flag clear for channel 6"
              },
              "CTCIF6": {
                "bit": 21,
                "description": "transfer complete flag clear for channel 6"
              },
              "CHTIF6": {
                "bit": 22,
                "description": "half transfer flag clear for channel 6"
              },
              "CTEIF6": {
                "bit": 23,
                "description": "transfer error flag clear for channel 6"
              },
              "CGIF7": {
                "bit": 24,
                "description": "global interrupt flag clear for channel 7"
              },
              "CTCIF7": {
                "bit": 25,
                "description": "transfer complete flag clear for channel 7"
              },
              "CHTIF7": {
                "bit": 26,
                "description": "half transfer flag clear for channel 7"
              },
              "CTEIF7": {
                "bit": 27,
                "description": "transfer error flag clear for channel 7"
              }
            },
            "DMA_CCR1": {
              "EN": {
                "bit": 0,
                "description": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 1,
                "description": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "HTIE": {
                "bit": 2,
                "description": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "TEIE": {
                "bit": 3,
                "description": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "DIR": {
                "bit": 4,
                "description": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "CIRC": {
                "bit": 5,
                "description": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PINC": {
                "bit": 6,
                "description": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "MINC": {
                "bit": 7,
                "description": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PSIZE": {
                "bit": 8,
                "description": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MSIZE": {
                "bit": 10,
                "description": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "PL": {
                "bit": 12,
                "description": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MEM2MEM": {
                "bit": 14,
                "description": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              }
            },
            "DMA_CNDTR1": {
              "NDT": {
                "bit": 0,
                "description": "number of data to transfer (0 to 216\u00c2\u00a0-\u00c2\u00a01)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write\u00e2\u0080\u0099 transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a00 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a01).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 16
              }
            },
            "DMA_CPAR1": {
              "PA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CMAR1": {
              "MA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CCR2": {
              "EN": {
                "bit": 0,
                "description": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 1,
                "description": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "HTIE": {
                "bit": 2,
                "description": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "TEIE": {
                "bit": 3,
                "description": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "DIR": {
                "bit": 4,
                "description": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "CIRC": {
                "bit": 5,
                "description": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PINC": {
                "bit": 6,
                "description": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "MINC": {
                "bit": 7,
                "description": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PSIZE": {
                "bit": 8,
                "description": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MSIZE": {
                "bit": 10,
                "description": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "PL": {
                "bit": 12,
                "description": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MEM2MEM": {
                "bit": 14,
                "description": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              }
            },
            "DMA_CNDTR2": {
              "NDT": {
                "bit": 0,
                "description": "number of data to transfer (0 to 216\u00c2\u00a0-\u00c2\u00a01)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write\u00e2\u0080\u0099 transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a00 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a01).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 16
              }
            },
            "DMA_CPAR2": {
              "PA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CMAR2": {
              "MA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CCR3": {
              "EN": {
                "bit": 0,
                "description": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 1,
                "description": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "HTIE": {
                "bit": 2,
                "description": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "TEIE": {
                "bit": 3,
                "description": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "DIR": {
                "bit": 4,
                "description": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "CIRC": {
                "bit": 5,
                "description": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PINC": {
                "bit": 6,
                "description": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "MINC": {
                "bit": 7,
                "description": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PSIZE": {
                "bit": 8,
                "description": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MSIZE": {
                "bit": 10,
                "description": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "PL": {
                "bit": 12,
                "description": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MEM2MEM": {
                "bit": 14,
                "description": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              }
            },
            "DMA_CNDTR3": {
              "NDT": {
                "bit": 0,
                "description": "number of data to transfer (0 to 216\u00c2\u00a0-\u00c2\u00a01)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write\u00e2\u0080\u0099 transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a00 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a01).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 16
              }
            },
            "DMA_CPAR3": {
              "PA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CMAR3": {
              "MA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CCR4": {
              "EN": {
                "bit": 0,
                "description": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 1,
                "description": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "HTIE": {
                "bit": 2,
                "description": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "TEIE": {
                "bit": 3,
                "description": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "DIR": {
                "bit": 4,
                "description": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "CIRC": {
                "bit": 5,
                "description": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PINC": {
                "bit": 6,
                "description": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "MINC": {
                "bit": 7,
                "description": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PSIZE": {
                "bit": 8,
                "description": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MSIZE": {
                "bit": 10,
                "description": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "PL": {
                "bit": 12,
                "description": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MEM2MEM": {
                "bit": 14,
                "description": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              }
            },
            "DMA_CNDTR4": {
              "NDT": {
                "bit": 0,
                "description": "number of data to transfer (0 to 216\u00c2\u00a0-\u00c2\u00a01)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write\u00e2\u0080\u0099 transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a00 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a01).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 16
              }
            },
            "DMA_CPAR4": {
              "PA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CMAR4": {
              "MA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CCR5": {
              "EN": {
                "bit": 0,
                "description": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 1,
                "description": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "HTIE": {
                "bit": 2,
                "description": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "TEIE": {
                "bit": 3,
                "description": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "DIR": {
                "bit": 4,
                "description": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "CIRC": {
                "bit": 5,
                "description": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PINC": {
                "bit": 6,
                "description": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "MINC": {
                "bit": 7,
                "description": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PSIZE": {
                "bit": 8,
                "description": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MSIZE": {
                "bit": 10,
                "description": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "PL": {
                "bit": 12,
                "description": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MEM2MEM": {
                "bit": 14,
                "description": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              }
            },
            "DMA_CNDTR5": {
              "NDT": {
                "bit": 0,
                "description": "number of data to transfer (0 to 216\u00c2\u00a0-\u00c2\u00a01)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write\u00e2\u0080\u0099 transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a00 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a01).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 16
              }
            },
            "DMA_CPAR5": {
              "PA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CMAR5": {
              "MA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CCR6": {
              "EN": {
                "bit": 0,
                "description": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 1,
                "description": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "HTIE": {
                "bit": 2,
                "description": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "TEIE": {
                "bit": 3,
                "description": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "DIR": {
                "bit": 4,
                "description": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "CIRC": {
                "bit": 5,
                "description": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PINC": {
                "bit": 6,
                "description": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "MINC": {
                "bit": 7,
                "description": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PSIZE": {
                "bit": 8,
                "description": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MSIZE": {
                "bit": 10,
                "description": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "PL": {
                "bit": 12,
                "description": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MEM2MEM": {
                "bit": 14,
                "description": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              }
            },
            "DMA_CNDTR6": {
              "NDT": {
                "bit": 0,
                "description": "number of data to transfer (0 to 216\u00c2\u00a0-\u00c2\u00a01)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write\u00e2\u0080\u0099 transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a00 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a01).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 16
              }
            },
            "DMA_CPAR6": {
              "PA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CMAR6": {
              "MA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CCR7": {
              "EN": {
                "bit": 0,
                "description": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 1,
                "description": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "HTIE": {
                "bit": 2,
                "description": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "TEIE": {
                "bit": 3,
                "description": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "DIR": {
                "bit": 4,
                "description": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "CIRC": {
                "bit": 5,
                "description": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PINC": {
                "bit": 6,
                "description": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "MINC": {
                "bit": 7,
                "description": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              },
              "PSIZE": {
                "bit": 8,
                "description": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MSIZE": {
                "bit": 10,
                "description": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "PL": {
                "bit": 12,
                "description": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 2
              },
              "MEM2MEM": {
                "bit": 14,
                "description": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01)."
              }
            },
            "DMA_CNDTR7": {
              "NDT": {
                "bit": 0,
                "description": "number of data to transfer (0 to 216\u00c2\u00a0-\u00c2\u00a01)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write\u00e2\u0080\u0099 transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a00 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC\u00c2\u00a0=\u00c2\u00a01).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 16
              }
            },
            "DMA_CPAR7": {
              "PA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral source address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            },
            "DMA_CMAR7": {
              "MA": {
                "bit": 0,
                "description": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]\u00c2\u00a0=\u00c2\u00a001 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE\u00c2\u00a0=\u00c2\u00a010 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR\u00c2\u00a0=\u00c2\u00a01 and the memory destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR\u00c2\u00a0=\u00c2\u00a01 and the peripheral destination address if DIR\u00c2\u00a0=\u00c2\u00a00.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN\u00c2\u00a0=\u00c2\u00a01).",
                "width": 32
              }
            }
          }
        },
        "FLASH": {
          "instances": [
            {
              "name": "FLASH",
              "base": "0x40022000",
              "irq": 3
            }
          ],
          "registers": {
            "ACR": {
              "offset": "0x00",
              "size": 32,
              "description": "Access control register"
            },
            "KEYR": {
              "offset": "0x08",
              "size": 32,
              "description": "Flash key register"
            },
            "OPTKEYR": {
              "offset": "0x0C",
              "size": 32,
              "description": "Option byte key register"
            },
            "SR": {
              "offset": "0x10",
              "size": 32,
              "description": "Status register"
            },
            "CR": {
              "offset": "0x14",
              "size": 32,
              "description": "Flash control register"
            },
            "ECCR": {
              "offset": "0x18",
              "size": 32,
              "description": "Flash ECC register"
            },
            "OPTR": {
              "offset": "0x20",
              "size": 32,
              "description": "Flash option register"
            },
            "PCROP1ASR": {
              "offset": "0x24",
              "size": 32,
              "description": "Flash PCROP zone A Start address\n          register"
            },
            "PCROP1AER": {
              "offset": "0x28",
              "size": 32,
              "description": "Flash PCROP zone A End address\n          register"
            },
            "WRP1AR": {
              "offset": "0x2C",
              "size": 32,
              "description": "Flash WRP area A address\n          register"
            },
            "WRP1BR": {
              "offset": "0x30",
              "size": 32,
              "description": "Flash WRP area B address\n          register"
            },
            "PCROP1BSR": {
              "offset": "0x34",
              "size": 32,
              "description": "Flash PCROP zone B Start address\n          register"
            },
            "PCROP1BER": {
              "offset": "0x38",
              "size": 32,
              "description": "Flash PCROP area B End address\n          register"
            },
            "PCROP2ASR": {
              "offset": "0x44",
              "size": 32,
              "description": "Flash PCROP2 area A start address register"
            },
            "PCROP2AER": {
              "offset": "0x48",
              "size": 32,
              "description": "Flash PCROP2 area A end address register"
            },
            "WRP2AR": {
              "offset": "0x4C",
              "size": 32,
              "description": "Flash WRP2 area A address register"
            },
            "WRP2BR": {
              "offset": "0x50",
              "size": 32,
              "description": "Flash WRP2 area B address register"
            },
            "PCROP2BSR": {
              "offset": "0x54",
              "size": 32,
              "description": "FLASH PCROP2 area B start address register"
            },
            "PCROP2BER": {
              "offset": "0x58",
              "size": 32,
              "description": "FLASH PCROP2 area B end address register"
            },
            "SECR": {
              "offset": "0x80",
              "size": 32,
              "description": "Flash Security register"
            }
          },
          "bits": {
            "ACR": {
              "LATENCY": {
                "bit": 0,
                "description": "Latency",
                "width": 3
              },
              "PRFTEN": {
                "bit": 8,
                "description": "Prefetch enable"
              },
              "ICEN": {
                "bit": 9,
                "description": "Instruction cache enable"
              },
              "ICRST": {
                "bit": 11,
                "description": "Instruction cache reset"
              },
              "EMPTY": {
                "bit": 16,
                "description": "Flash User area empty"
              },
              "DBG_SWEN": {
                "bit": 18,
                "description": "Debug access software\n              enable"
              }
            },
            "KEYR": {
              "KEYR": {
                "bit": 0,
                "description": "KEYR",
                "width": 32
              }
            },
            "OPTKEYR": {
              "OPTKEYR": {
                "bit": 0,
                "description": "Option byte key",
                "width": 32
              }
            },
            "SR": {
              "EOP": {
                "bit": 0,
                "description": "End of operation"
              },
              "OPERR": {
                "bit": 1,
                "description": "Operation error"
              },
              "PROGERR": {
                "bit": 3,
                "description": "Programming error"
              },
              "WRPERR": {
                "bit": 4,
                "description": "Write protected error"
              },
              "PGAERR": {
                "bit": 5,
                "description": "Programming alignment\n              error"
              },
              "SIZERR": {
                "bit": 6,
                "description": "Size error"
              },
              "PGSERR": {
                "bit": 7,
                "description": "Programming sequence error"
              },
              "MISERR": {
                "bit": 8,
                "description": "Fast programming data miss\n              error"
              },
              "FASTERR": {
                "bit": 9,
                "description": "Fast programming error"
              },
              "RDERR": {
                "bit": 14,
                "description": "PCROP read error"
              },
              "OPTVERR": {
                "bit": 15,
                "description": "Option and Engineering bits loading\n              validity error"
              },
              "BSY": {
                "bit": 16,
                "description": "Busy"
              },
              "CFGBSY": {
                "bit": 18,
                "description": "Programming or erase configuration\n              busy."
              }
            },
            "CR": {
              "PG": {
                "bit": 0,
                "description": "Programming"
              },
              "PER": {
                "bit": 1,
                "description": "Page erase"
              },
              "MER": {
                "bit": 2,
                "description": "Mass erase"
              },
              "PNB": {
                "bit": 3,
                "description": "Page number",
                "width": 6
              },
              "STRT": {
                "bit": 16,
                "description": "Start"
              },
              "OPTSTRT": {
                "bit": 17,
                "description": "Options modification start"
              },
              "FSTPG": {
                "bit": 18,
                "description": "Fast programming"
              },
              "EOPIE": {
                "bit": 24,
                "description": "End of operation interrupt\n              enable"
              },
              "ERRIE": {
                "bit": 25,
                "description": "Error interrupt enable"
              },
              "RDERRIE": {
                "bit": 26,
                "description": "PCROP read error interrupt\n              enable"
              },
              "OBL_LAUNCH": {
                "bit": 27,
                "description": "Force the option byte\n              loading"
              },
              "SEC_PROT": {
                "bit": 28,
                "description": "Securable memory area protection\n              enable"
              },
              "OPTLOCK": {
                "bit": 30,
                "description": "Options Lock"
              },
              "LOCK": {
                "bit": 31,
                "description": "FLASH_CR Lock"
              }
            },
            "ECCR": {
              "ADDR_ECC": {
                "bit": 0,
                "description": "ECC fail address",
                "width": 14
              },
              "SYSF_ECC": {
                "bit": 20,
                "description": "ECC fail for Corrected ECC Error or\n              Double ECC Error in info block"
              },
              "ECCIE": {
                "bit": 24,
                "description": "ECC correction interrupt\n              enable"
              },
              "ECCC": {
                "bit": 30,
                "description": "ECC correction"
              },
              "ECCD": {
                "bit": 31,
                "description": "ECC detection"
              }
            },
            "OPTR": {
              "RDP": {
                "bit": 0,
                "description": "Read protection level",
                "width": 8
              },
              "BOREN": {
                "bit": 8,
                "description": "BOR reset Level"
              },
              "BORF_LEV": {
                "bit": 9,
                "description": "These bits contain the VDD supply level\n              threshold that activates the reset",
                "width": 2
              },
              "BORR_LEV": {
                "bit": 11,
                "description": "These bits contain the VDD supply level\n              threshold that releases the reset.",
                "width": 2
              },
              "nRST_STOP": {
                "bit": 13,
                "description": "nRST_STOP"
              },
              "nRST_STDBY": {
                "bit": 14,
                "description": "nRST_STDBY"
              },
              "nRSTS_HDW": {
                "bit": 15,
                "description": "nRSTS_HDW"
              },
              "IDWG_SW": {
                "bit": 16,
                "description": "Independent watchdog\n              selection"
              },
              "IWDG_STOP": {
                "bit": 17,
                "description": "Independent watchdog counter freeze in\n              Stop mode"
              },
              "IWDG_STDBY": {
                "bit": 18,
                "description": "Independent watchdog counter freeze in\n              Standby mode"
              },
              "WWDG_SW": {
                "bit": 19,
                "description": "Window watchdog selection"
              },
              "RAM_PARITY_CHECK": {
                "bit": 22,
                "description": "SRAM parity check control"
              },
              "nBOOT_SEL": {
                "bit": 24,
                "description": "nBOOT_SEL"
              },
              "nBOOT1": {
                "bit": 25,
                "description": "Boot configuration"
              },
              "nBOOT0": {
                "bit": 26,
                "description": "nBOOT0 option bit"
              },
              "NRST_MODE": {
                "bit": 27,
                "description": "NRST_MODE",
                "width": 2
              },
              "IRHEN": {
                "bit": 29,
                "description": "Internal reset holder enable\n              bit"
              }
            },
            "PCROP1ASR": {
              "PCROP1A_STRT": {
                "bit": 0,
                "description": "PCROP1A area start offset",
                "width": 8
              }
            },
            "PCROP1AER": {
              "PCROP1A_END": {
                "bit": 0,
                "description": "PCROP1A area end offset",
                "width": 8
              },
              "PCROP_RDP": {
                "bit": 31,
                "description": "PCROP area preserved when RDP level\n              decreased"
              }
            },
            "WRP1AR": {
              "WRP1A_STRT": {
                "bit": 0,
                "description": "WRP area A start offset",
                "width": 6
              },
              "WRP1A_END": {
                "bit": 16,
                "description": "WRP area A end offset",
                "width": 6
              }
            },
            "WRP1BR": {
              "WRP1B_STRT": {
                "bit": 0,
                "description": "WRP area B start offset",
                "width": 6
              },
              "WRP1B_END": {
                "bit": 16,
                "description": "WRP area B end offset",
                "width": 6
              }
            },
            "PCROP1BSR": {
              "PCROP1B_STRT": {
                "bit": 0,
                "description": "PCROP1B area start offset",
                "width": 8
              }
            },
            "PCROP1BER": {
              "PCROP1B_END": {
                "bit": 0,
                "description": "PCROP1B area end offset",
                "width": 9
              }
            },
            "PCROP2ASR": {
              "PCROP2A_STRT": {
                "bit": 0,
                "description": "PCROP2A area start offset, bank2",
                "width": 9
              }
            },
            "PCROP2AER": {
              "PCROP2A_END": {
                "bit": 0,
                "description": "PCROP2A area end offset, bank2",
                "width": 9
              }
            },
            "WRP2AR": {
              "WRP2A_STRT": {
                "bit": 0,
                "description": "WRP area A start offset, Bank 2",
                "width": 7
              },
              "WRP2A_END": {
                "bit": 16,
                "description": "WRP area A end offset, Bank 2",
                "width": 7
              }
            },
            "WRP2BR": {
              "WRP2B_STRT": {
                "bit": 0,
                "description": "WRP area B start offset, Bank 2",
                "width": 7
              },
              "WRP2B_END": {
                "bit": 16,
                "description": "WRP area B end offset, Bank 2",
                "width": 7
              }
            },
            "PCROP2BSR": {
              "PCROP2B_STRT": {
                "bit": 0,
                "description": "PCROP2B area start offset, Bank 2",
                "width": 9
              }
            },
            "PCROP2BER": {
              "PCROP2B_END": {
                "bit": 0,
                "description": "PCROP2B area end offset, Bank 2",
                "width": 9
              }
            },
            "SECR": {
              "SEC_SIZE": {
                "bit": 0,
                "description": "Securable memory area size",
                "width": 8
              },
              "BOOT_LOCK": {
                "bit": 16,
                "description": "used to force boot from user\n              area"
              },
              "SEC_SIZE2": {
                "bit": 20,
                "description": "Securable memory area size",
                "width": 8
              }
            }
          }
        },
        "GPIO": {
          "instances": [
            {
              "name": "GPIOA",
              "base": "0x50000000"
            },
            {
              "name": "GPIOB",
              "base": "0x50000400"
            },
            {
              "name": "GPIOC",
              "base": "0x50000800"
            },
            {
              "name": "GPIOD",
              "base": "0x50000C00"
            },
            {
              "name": "GPIOE",
              "base": "0x50001000"
            },
            {
              "name": "GPIOF",
              "base": "0x50001400"
            }
          ],
          "registers": {
            "MODER": {
              "offset": "0x00",
              "size": 32,
              "description": "GPIO port mode register"
            },
            "OTYPER": {
              "offset": "0x04",
              "size": 32,
              "description": "GPIO port output type register"
            },
            "OSPEEDR": {
              "offset": "0x08",
              "size": 32,
              "description": "GPIO port output speed\n          register"
            },
            "PUPDR": {
              "offset": "0x0C",
              "size": 32,
              "description": "GPIO port pull-up/pull-down\n          register"
            },
            "IDR": {
              "offset": "0x10",
              "size": 32,
              "description": "GPIO port input data register"
            },
            "ODR": {
              "offset": "0x14",
              "size": 32,
              "description": "GPIO port output data register"
            },
            "BSRR": {
              "offset": "0x18",
              "size": 32,
              "description": "GPIO port bit set/reset\n          register"
            },
            "LCKR": {
              "offset": "0x1C",
              "size": 32,
              "description": "GPIO port configuration lock\n          register"
            },
            "AFRL": {
              "offset": "0x20",
              "size": 32,
              "description": "GPIO alternate function low\n          register"
            },
            "AFRH": {
              "offset": "0x24",
              "size": 32,
              "description": "GPIO alternate function high\n          register"
            },
            "BRR": {
              "offset": "0x28",
              "size": 32,
              "description": "port bit reset register"
            }
          },
          "bits": {
            "MODER": {
              "MODER15": {
                "bit": 30,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER14": {
                "bit": 28,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER13": {
                "bit": 26,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER12": {
                "bit": 24,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER11": {
                "bit": 22,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER10": {
                "bit": 20,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER9": {
                "bit": 18,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER8": {
                "bit": 16,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER7": {
                "bit": 14,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER6": {
                "bit": 12,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER5": {
                "bit": 10,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER4": {
                "bit": 8,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER3": {
                "bit": 6,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER2": {
                "bit": 4,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER1": {
                "bit": 2,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "MODER0": {
                "bit": 0,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              }
            },
            "OTYPER": {
              "OT15": {
                "bit": 15,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT14": {
                "bit": 14,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT13": {
                "bit": 13,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT12": {
                "bit": 12,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT11": {
                "bit": 11,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT10": {
                "bit": 10,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT9": {
                "bit": 9,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT8": {
                "bit": 8,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT7": {
                "bit": 7,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT6": {
                "bit": 6,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT5": {
                "bit": 5,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT4": {
                "bit": 4,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT3": {
                "bit": 3,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT2": {
                "bit": 2,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT1": {
                "bit": 1,
                "description": "Port x configuration bits (y =\n              0..15)"
              },
              "OT0": {
                "bit": 0,
                "description": "Port x configuration bits (y =\n              0..15)"
              }
            },
            "OSPEEDR": {
              "OSPEEDR15": {
                "bit": 30,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR14": {
                "bit": 28,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR13": {
                "bit": 26,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR12": {
                "bit": 24,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR11": {
                "bit": 22,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR10": {
                "bit": 20,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR9": {
                "bit": 18,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR8": {
                "bit": 16,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR7": {
                "bit": 14,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR6": {
                "bit": 12,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR5": {
                "bit": 10,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR4": {
                "bit": 8,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR3": {
                "bit": 6,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR2": {
                "bit": 4,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR1": {
                "bit": 2,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "OSPEEDR0": {
                "bit": 0,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              }
            },
            "PUPDR": {
              "PUPDR15": {
                "bit": 30,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR14": {
                "bit": 28,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR13": {
                "bit": 26,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR12": {
                "bit": 24,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR11": {
                "bit": 22,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR10": {
                "bit": 20,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR9": {
                "bit": 18,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR8": {
                "bit": 16,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR7": {
                "bit": 14,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR6": {
                "bit": 12,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR5": {
                "bit": 10,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR4": {
                "bit": 8,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR3": {
                "bit": 6,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR2": {
                "bit": 4,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR1": {
                "bit": 2,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              },
              "PUPDR0": {
                "bit": 0,
                "description": "Port x configuration bits (y =\n              0..15)",
                "width": 2
              }
            },
            "IDR": {
              "IDR15": {
                "bit": 15,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR14": {
                "bit": 14,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR13": {
                "bit": 13,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR12": {
                "bit": 12,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR11": {
                "bit": 11,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR10": {
                "bit": 10,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR9": {
                "bit": 9,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR8": {
                "bit": 8,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR7": {
                "bit": 7,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR6": {
                "bit": 6,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR5": {
                "bit": 5,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR4": {
                "bit": 4,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR3": {
                "bit": 3,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR2": {
                "bit": 2,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR1": {
                "bit": 1,
                "description": "Port input data (y =\n              0..15)"
              },
              "IDR0": {
                "bit": 0,
                "description": "Port input data (y =\n              0..15)"
              }
            },
            "ODR": {
              "ODR15": {
                "bit": 15,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR14": {
                "bit": 14,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR13": {
                "bit": 13,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR12": {
                "bit": 12,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR11": {
                "bit": 11,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR10": {
                "bit": 10,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR9": {
                "bit": 9,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR8": {
                "bit": 8,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR7": {
                "bit": 7,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR6": {
                "bit": 6,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR5": {
                "bit": 5,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR4": {
                "bit": 4,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR3": {
                "bit": 3,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR2": {
                "bit": 2,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR1": {
                "bit": 1,
                "description": "Port output data (y =\n              0..15)"
              },
              "ODR0": {
                "bit": 0,
                "description": "Port output data (y =\n              0..15)"
              }
            },
            "BSRR": {
              "BR15": {
                "bit": 31,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR14": {
                "bit": 30,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR13": {
                "bit": 29,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR12": {
                "bit": 28,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR11": {
                "bit": 27,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR10": {
                "bit": 26,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR9": {
                "bit": 25,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR8": {
                "bit": 24,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR7": {
                "bit": 23,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR6": {
                "bit": 22,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR5": {
                "bit": 21,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR4": {
                "bit": 20,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR3": {
                "bit": 19,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR2": {
                "bit": 18,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR1": {
                "bit": 17,
                "description": "Port x reset bit y (y =\n              0..15)"
              },
              "BR0": {
                "bit": 16,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS15": {
                "bit": 15,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS14": {
                "bit": 14,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS13": {
                "bit": 13,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS12": {
                "bit": 12,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS11": {
                "bit": 11,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS10": {
                "bit": 10,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS9": {
                "bit": 9,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS8": {
                "bit": 8,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS7": {
                "bit": 7,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS6": {
                "bit": 6,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS5": {
                "bit": 5,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS4": {
                "bit": 4,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS3": {
                "bit": 3,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS2": {
                "bit": 2,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS1": {
                "bit": 1,
                "description": "Port x set bit y (y=\n              0..15)"
              },
              "BS0": {
                "bit": 0,
                "description": "Port x set bit y (y=\n              0..15)"
              }
            },
            "LCKR": {
              "LCKK": {
                "bit": 16,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK15": {
                "bit": 15,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK14": {
                "bit": 14,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK13": {
                "bit": 13,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK12": {
                "bit": 12,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK11": {
                "bit": 11,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK10": {
                "bit": 10,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK9": {
                "bit": 9,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK8": {
                "bit": 8,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK7": {
                "bit": 7,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK6": {
                "bit": 6,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK5": {
                "bit": 5,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK4": {
                "bit": 4,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK3": {
                "bit": 3,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK2": {
                "bit": 2,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK1": {
                "bit": 1,
                "description": "Port x lock bit y (y=\n              0..15)"
              },
              "LCK0": {
                "bit": 0,
                "description": "Port x lock bit y (y=\n              0..15)"
              }
            },
            "AFRL": {
              "AFSEL7": {
                "bit": 28,
                "description": "Alternate function selection for port x\n              bit y (y = 0..7)",
                "width": 4
              },
              "AFSEL6": {
                "bit": 24,
                "description": "Alternate function selection for port x\n              bit y (y = 0..7)",
                "width": 4
              },
              "AFSEL5": {
                "bit": 20,
                "description": "Alternate function selection for port x\n              bit y (y = 0..7)",
                "width": 4
              },
              "AFSEL4": {
                "bit": 16,
                "description": "Alternate function selection for port x\n              bit y (y = 0..7)",
                "width": 4
              },
              "AFSEL3": {
                "bit": 12,
                "description": "Alternate function selection for port x\n              bit y (y = 0..7)",
                "width": 4
              },
              "AFSEL2": {
                "bit": 8,
                "description": "Alternate function selection for port x\n              bit y (y = 0..7)",
                "width": 4
              },
              "AFSEL1": {
                "bit": 4,
                "description": "Alternate function selection for port x\n              bit y (y = 0..7)",
                "width": 4
              },
              "AFSEL0": {
                "bit": 0,
                "description": "Alternate function selection for port x\n              bit y (y = 0..7)",
                "width": 4
              }
            },
            "AFRH": {
              "AFSEL15": {
                "bit": 28,
                "description": "Alternate function selection for port x\n              bit y (y = 8..15)",
                "width": 4
              },
              "AFSEL14": {
                "bit": 24,
                "description": "Alternate function selection for port x\n              bit y (y = 8..15)",
                "width": 4
              },
              "AFSEL13": {
                "bit": 20,
                "description": "Alternate function selection for port x\n              bit y (y = 8..15)",
                "width": 4
              },
              "AFSEL12": {
                "bit": 16,
                "description": "Alternate function selection for port x\n              bit y (y = 8..15)",
                "width": 4
              },
              "AFSEL11": {
                "bit": 12,
                "description": "Alternate function selection for port x\n              bit y (y = 8..15)",
                "width": 4
              },
              "AFSEL10": {
                "bit": 8,
                "description": "Alternate function selection for port x\n              bit y (y = 8..15)",
                "width": 4
              },
              "AFSEL9": {
                "bit": 4,
                "description": "Alternate function selection for port x\n              bit y (y = 8..15)",
                "width": 4
              },
              "AFSEL8": {
                "bit": 0,
                "description": "Alternate function selection for port x\n              bit y (y = 8..15)",
                "width": 4
              }
            },
            "BRR": {
              "BR0": {
                "bit": 0,
                "description": "Port Reset bit"
              },
              "BR1": {
                "bit": 1,
                "description": "Port Reset bit"
              },
              "BR2": {
                "bit": 2,
                "description": "Port Reset bit"
              },
              "BR3": {
                "bit": 3,
                "description": "Port Reset bit"
              },
              "BR4": {
                "bit": 4,
                "description": "Port Reset bit"
              },
              "BR5": {
                "bit": 5,
                "description": "Port Reset bit"
              },
              "BR6": {
                "bit": 6,
                "description": "Port Reset bit"
              },
              "BR7": {
                "bit": 7,
                "description": "Port Reset bit"
              },
              "BR8": {
                "bit": 8,
                "description": "Port Reset bit"
              },
              "BR9": {
                "bit": 9,
                "description": "Port Reset bit"
              },
              "BR10": {
                "bit": 10,
                "description": "Port Reset bit"
              },
              "BR11": {
                "bit": 11,
                "description": "Port Reset bit"
              },
              "BR12": {
                "bit": 12,
                "description": "Port Reset bit"
              },
              "BR13": {
                "bit": 13,
                "description": "Port Reset bit"
              },
              "BR14": {
                "bit": 14,
                "description": "Port Reset bit"
              },
              "BR15": {
                "bit": 15,
                "description": "Port Reset bit"
              }
            }
          }
        },
        "HDMI": {
          "instances": [
            {
              "name": "HDMI_CEC",
              "base": "0x40007800",
              "irq": 30
            }
          ],
          "registers": {
            "CEC_CR": {
              "offset": "0x00",
              "size": 32,
              "description": "CEC control register"
            },
            "CEC_CFGR": {
              "offset": "0x04",
              "size": 32,
              "description": "This register is used to configure the\n          HDMI-CEC controller. It is mandatory to write CEC_CFGR\n          only when CECEN=0."
            },
            "CEC_TXDR": {
              "offset": "0x08",
              "size": 32,
              "description": "CEC Tx data register"
            },
            "CEC_RXDR": {
              "offset": "0x0C",
              "size": 32,
              "description": "CEC Rx Data Register"
            },
            "CEC_ISR": {
              "offset": "0x10",
              "size": 32,
              "description": "CEC Interrupt and Status\n          Register"
            },
            "CEC_IER": {
              "offset": "0x14",
              "size": 32,
              "description": "CEC interrupt enable register"
            }
          },
          "bits": {
            "CEC_CR": {
              "CECEN": {
                "bit": 0,
                "description": "CEC enable\nThe CECEN bit is set and cleared by software. CECEN\u00a0=\u00a01 starts message reception and enables the TXSOM control. CECEN\u00a0=\u00a00 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission."
              },
              "TXSOM": {
                "bit": 1,
                "description": "Tx start of message\nTXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM.\nStart-bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission starts after the end of reception.\nTXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND\u00a0=\u00a01), in case of transmission underrun (TXUDR\u00a0=\u00a01), negative acknowledge (TXACKE\u00a0=\u00a01), and transmission error (TXERR\u00a0=\u00a01). It is also cleared by CECEN\u00a0=\u00a00. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST\u00a0=\u00a01).\nTXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit.\nNote: TXSOM must be set when CECEN\u00a0=\u00a01.\nTXSOM must be set when transmission data is available into TXDR.\nHEADER first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR that is used only for reception."
              },
              "TXEOM": {
                "bit": 2,
                "description": "Tx end of message\nThe TXEOM bit is set by software to command transmission of the last byte of a CEC message.\nTXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM.\nNote: TXEOM must be set when CECEN\u00a0=\u00a01.\nTXEOM must be set before writing transmission data to TXDR.\nIf TXEOM is set when TXSOM\u00a0=\u00a00, transmitted message consists of 1 byte (HEADER) only (PING message)."
              }
            },
            "CEC_CFGR": {
              "SFT": {
                "bit": 0,
                "description": "Signal free time\nSFT bits are set by software. In the SFT\u00a0=\u00a00x0 configuration, the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software.\n0x0\n2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST\u00a0=\u00a01, TXERR\u00a0=\u00a01, TXUDR\u00a0=\u00a01 or TXACKE\u00a0=\u00a01)\n4 data-bit periods if CEC is the new bus initiator\n6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM\u00a0=\u00a01)",
                "width": 3
              },
              "RXTOL": {
                "bit": 3,
                "description": "Rx-tolerance\nThe RXTOL bit is set and cleared by software.\nStart-bit, +/- 200 \u00b5s rise, +/- 200 \u00b5s fall\nData-bit: +/- 200 \u00b5s rise. +/- 350 \u00b5s fall\nStart-bit: +/- 400 \u00b5s rise, +/- 400 \u00b5s fall\nData-bit: +/-300 \u00b5s rise, +/- 500 \u00b5s fall"
              },
              "BRESTP": {
                "bit": 4,
                "description": "Rx-stop on bit rising error\nThe BRESTP bit is set and cleared by software."
              },
              "BREGEN": {
                "bit": 5,
                "description": "Generate error-bit on bit rising error\nThe BREGEN bit is set and cleared by software.\nNote: If BRDNOGEN\u00a0=\u00a00, an error-bit is generated upon BRE detection with BRESTP\u00a0=\u00a01 in broadcast even if BREGEN\u00a0=\u00a00."
              },
              "LBPEGEN": {
                "bit": 6,
                "description": "Generate error-bit on long bit period error\nThe LBPEGEN bit is set and cleared by software.\nNote: If BRDNOGEN\u00a0=\u00a00, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN\u00a0=\u00a00."
              },
              "BRDNOGEN": {
                "bit": 7,
                "description": "Avoid error-bit generation in broadcast\nThe BRDNOGEN bit is set and cleared by software.\nerror-bit on the CEC line. LBPE detection with LBPEGEN\u00a0=\u00a00 on a broadcast message generates an error-bit on the CEC line."
              },
              "SFTOP": {
                "bit": 8,
                "description": "SFT option bit\nThe SFTOPT bit is set and cleared by software."
              },
              "OAR": {
                "bit": 16,
                "description": "Own addresses configuration\nThe OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position.\nAt the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN\u00a0=\u00a01), but without acknowledge sent. Broadcast messages are always received.\nExample:\nOAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.",
                "width": 15
              },
              "LSTN": {
                "bit": 31,
                "description": "Listen mode\nLSTN bit is set and cleared by software."
              }
            },
            "CEC_TXDR": {
              "TXD": {
                "bit": 0,
                "description": "Tx Data register. TXD is a write-only\n              register containing the data byte to be transmitted.\n              Note: TXD must be written when\n              TXSTART=1",
                "width": 8
              }
            },
            "CEC_RXDR": {
              "RXD": {
                "bit": 0,
                "description": "Rx Data register. RXD is read-only and\n              contains the last data byte which has been received\n              from the CEC line.",
                "width": 8
              }
            },
            "CEC_ISR": {
              "RXBR": {
                "bit": 0,
                "description": "Rx-Byte Received The RXBR bit is set by\n              hardware to inform application that a new byte has\n              been received from the CEC line and stored into the\n              RXD buffer. RXBR is cleared by software write at\n              1."
              },
              "RXEND": {
                "bit": 1,
                "description": "End Of Reception RXEND is set by\n              hardware to inform application that the last byte of\n              a CEC message is received from the CEC line and\n              stored into the RXD buffer. RXEND is set at the same\n              time of RXBR. RXEND is cleared by software write at\n              1."
              },
              "RXOVR": {
                "bit": 2,
                "description": "Rx-Overrun RXOVR is set by hardware if\n              RXBR is not yet cleared at the time a new byte is\n              received on the CEC line and stored into RXD. RXOVR\n              assertion stops message reception so that no\n              acknowledge is sent. In case of broadcast, a negative\n              acknowledge is sent. RXOVR is cleared by software\n              write at 1."
              },
              "BRE": {
                "bit": 3,
                "description": "Rx-Bit Rising Error BRE is set by\n              hardware in case a Data-Bit waveform is detected with\n              Bit Rising Error. BRE is set either at the time the\n              misplaced rising edge occurs, or at the end of the\n              maximum BRE tolerance allowed by RXTOL, in case\n              rising edge is still longing. BRE stops message\n              reception if BRESTP=1. BRE generates an Error-Bit on\n              the CEC line if BREGEN=1. BRE is cleared by software\n              write at 1."
              },
              "SBPE": {
                "bit": 4,
                "description": "Rx-Short Bit Period Error SBPE is set by\n              hardware in case a Data-Bit waveform is detected with\n              Short Bit Period Error. SBPE is set at the time the\n              anticipated falling edge occurs. SBPE generates an\n              Error-Bit on the CEC line. SBPE is cleared by\n              software write at 1."
              },
              "LBPE": {
                "bit": 5,
                "description": "Rx-Long Bit Period Error LBPE is set by\n              hardware in case a Data-Bit waveform is detected with\n              Long Bit Period Error. LBPE is set at the end of the\n              maximum bit-extension tolerance allowed by RXTOL, in\n              case falling edge is still longing. LBPE always stops\n              reception of the CEC message. LBPE generates an\n              Error-Bit on the CEC line if LBPEGEN=1. In case of\n              broadcast, Error-Bit is generated even in case of\n              LBPEGEN=0. LBPE is cleared by software write at\n              1."
              },
              "RXACKE": {
                "bit": 6,
                "description": "Rx-Missing Acknowledge In receive mode,\n              RXACKE is set by hardware to inform application that\n              no acknowledge was seen on the CEC line. RXACKE\n              applies only for broadcast messages and in listen\n              mode also for not directly addressed messages\n              (destination address not enabled in OAR). RXACKE\n              aborts message reception. RXACKE is cleared by\n              software write at 1."
              },
              "ARBLST": {
                "bit": 7,
                "description": "Arbitration Lost ARBLST is set by\n              hardware to inform application that CEC device is\n              switching to reception due to arbitration lost event\n              following the TXSOM command. ARBLST can be due either\n              to a contending CEC device starting earlier or\n              starting at the same time but with higher HEADER\n              priority. After ARBLST assertion TXSOM bit keeps\n              pending for next transmission attempt. ARBLST is\n              cleared by software write at 1."
              },
              "TXBR": {
                "bit": 8,
                "description": "Tx-Byte Request TXBR is set by hardware\n              to inform application that the next transmission data\n              has to be written to TXDR. TXBR is set when the 4th\n              bit of currently transmitted byte is sent.\n              Application must write the next byte to TXDR within 6\n              nominal data-bit periods before transmission underrun\n              error occurs (TXUDR). TXBR is cleared by software\n              write at 1."
              },
              "TXEND": {
                "bit": 9,
                "description": "End of Transmission TXEND is set by\n              hardware to inform application that the last byte of\n              the CEC message has been successfully transmitted.\n              TXEND clears the TXSOM and TXEOM control bits. TXEND\n              is cleared by software write at 1."
              },
              "TXUDR": {
                "bit": 10,
                "description": "Tx-Buffer Underrun In transmission mode,\n              TXUDR is set by hardware if application was not in\n              time to load TXDR before of next byte transmission.\n              TXUDR aborts message transmission and clears TXSOM\n              and TXEOM control bits. TXUDR is cleared by software\n              write at 1"
              },
              "TXERR": {
                "bit": 11,
                "description": "Tx-Error In transmission mode, TXERR is\n              set by hardware if the CEC initiator detects low\n              impedance on the CEC line while it is released. TXERR\n              aborts message transmission and clears TXSOM and\n              TXEOM controls. TXERR is cleared by software write at\n              1."
              },
              "TXACKE": {
                "bit": 12,
                "description": "Tx-Missing Acknowledge Error In\n              transmission mode, TXACKE is set by hardware to\n              inform application that no acknowledge was received.\n              In case of broadcast transmission, TXACKE informs\n              application that a negative acknowledge was received.\n              TXACKE aborts message transmission and clears TXSOM\n              and TXEOM controls. TXACKE is cleared by software\n              write at 1."
              }
            },
            "CEC_IER": {
              "RXBRIE": {
                "bit": 0,
                "description": "Rx-byte received interrupt enable\nThe RXBRIE bit is set and cleared by software."
              },
              "RXENDIE": {
                "bit": 1,
                "description": "End of reception interrupt enable\nThe RXENDIE bit is set and cleared by software."
              },
              "RXOVRIE": {
                "bit": 2,
                "description": "Rx-buffer overrun interrupt enable\nThe RXOVRIE bit is set and cleared by software."
              },
              "BREIE": {
                "bit": 3,
                "description": "Bit rising error interrupt enable\nThe BREIE bit is set and cleared by software."
              },
              "SBPEIE": {
                "bit": 4,
                "description": "Short bit period error interrupt enable\nThe SBPEIE bit is set and cleared by software."
              },
              "LBPEIE": {
                "bit": 5,
                "description": "Long bit period error interrupt enable\nThe LBPEIE bit is set and cleared by software."
              },
              "RXACKIE": {
                "bit": 6,
                "description": "Rx-missing acknowledge error interrupt enable\nThe RXACKIE bit is set and cleared by software."
              },
              "ARBLSTIE": {
                "bit": 7,
                "description": "Arbitration lost interrupt enable\nThe ARBLSTIE bit is set and cleared by software."
              },
              "TXBRIE": {
                "bit": 8,
                "description": "Tx-byte request interrupt enable\nThe TXBRIE bit is set and cleared by software."
              },
              "TXENDIE": {
                "bit": 9,
                "description": "Tx-end of message interrupt enable\nThe TXENDIE bit is set and cleared by software."
              },
              "TXUDRIE": {
                "bit": 10,
                "description": "Tx-underrun interrupt enable\nThe TXUDRIE bit is set and cleared by software."
              },
              "TXERRIE": {
                "bit": 11,
                "description": "Tx-error interrupt enable\nThe TXERRIE bit is set and cleared by software."
              },
              "TXACKIE": {
                "bit": 12,
                "description": "Tx-missing acknowledge error interrupt enable\nThe TXACKEIE bit is set and cleared by software."
              }
            }
          }
        },
        "I2C": {
          "instances": [
            {
              "name": "I2C1",
              "base": "0x40005400",
              "irq": 23
            },
            {
              "name": "I2C2",
              "base": "0x40005800",
              "irq": 24
            }
          ],
          "registers": {
            "I2C_CR1": {
              "offset": "0x00",
              "size": 32,
              "description": "Control register 1"
            },
            "I2C_CR2": {
              "offset": "0x04",
              "size": 32,
              "description": "Control register 2"
            },
            "I2C_OAR1": {
              "offset": "0x08",
              "size": 32,
              "description": "Own address register 1"
            },
            "I2C_OAR2": {
              "offset": "0x0C",
              "size": 32,
              "description": "Own address register 2"
            },
            "I2C_TIMINGR": {
              "offset": "0x10",
              "size": 32,
              "description": "Timing register"
            },
            "I2C_TIMEOUTR": {
              "offset": "0x14",
              "size": 32,
              "description": "Status register 1"
            },
            "I2C_ISR": {
              "offset": "0x18",
              "size": 32,
              "description": "Interrupt and Status register"
            },
            "I2C_ICR": {
              "offset": "0x1C",
              "size": 32,
              "description": "Interrupt clear register"
            },
            "I2C_PECR": {
              "offset": "0x20",
              "size": 32,
              "description": "PEC register"
            },
            "I2C_RXDR": {
              "offset": "0x24",
              "size": 32,
              "description": "Receive data register"
            },
            "I2C_TXDR": {
              "offset": "0x28",
              "size": 32,
              "description": "Transmit data register"
            }
          },
          "bits": {
            "I2C_CR1": {
              "PE": {
                "bit": 0,
                "description": "Peripheral enable\nNote: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles."
              },
              "TXIE": {
                "bit": 1,
                "description": "TX Interrupt enable"
              },
              "RXIE": {
                "bit": 2,
                "description": "RX Interrupt enable"
              },
              "ADDRIE": {
                "bit": 3,
                "description": "Address match Interrupt enable (slave only)"
              },
              "NACKIE": {
                "bit": 4,
                "description": "Not acknowledge received Interrupt enable"
              },
              "STOPIE": {
                "bit": 5,
                "description": "Stop detection Interrupt enable"
              },
              "TCIE": {
                "bit": 6,
                "description": "Transfer Complete interrupt enable\nNote: Any of these events generate an interrupt:\nTransfer Complete (TC)\nTransfer Complete Reload (TCR)"
              },
              "ERRIE": {
                "bit": 7,
                "description": "Error interrupts enable\nNote: Any of these errors generate an interrupt:\nArbitration Loss (ARLO)\nBus Error detection (BERR)\nOverrun/Underrun (OVR)\nTimeout detection (TIMEOUT)\nPEC error detection (PECERR)\nAlert pin event detection (ALERT)"
              },
              "DNF": {
                "bit": 8,
                "description": "Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK\n...\nNote: If the analog filter is also enabled, the digital filter is added to the analog filter.\nThis filter can only be programmed when the I2C is disabled (PE = 0).",
                "width": 4
              },
              "ANFOFF": {
                "bit": 12,
                "description": "Analog noise filter OFF\nNote: This bit can only be programmed when the I2C is disabled (PE = 0)."
              },
              "TXDMAEN": {
                "bit": 14,
                "description": "DMA transmission requests enable"
              },
              "RXDMAEN": {
                "bit": 15,
                "description": "DMA reception requests enable"
              },
              "SBC": {
                "bit": 16,
                "description": "Slave byte control\nThis bit is used to enable hardware byte control in slave mode."
              },
              "NOSTRETCH": {
                "bit": 17,
                "description": "Clock stretching disable\nThis bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.\nNote: This bit can only be programmed when the I2C is disabled (PE = 0)."
              },
              "WUPEN": {
                "bit": 18,
                "description": "Wakeup from Stop mode enable\nNote: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0\u00e2\u0080\u0099. Refer to .\nNote: WUPEN can be set only when DNF = '0000\u00e2\u0080\u0099"
              },
              "GCEN": {
                "bit": 19,
                "description": "General call enable"
              },
              "SMBHEN": {
                "bit": 20,
                "description": "SMBus Host Address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0\u00e2\u0080\u0099. Refer to ."
              },
              "SMBDEN": {
                "bit": 21,
                "description": "SMBus Device Default Address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0\u00e2\u0080\u0099. Refer to ."
              },
              "ALERTEN": {
                "bit": 22,
                "description": "SMBus alert enable\nNote: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0\u00e2\u0080\u0099. Refer to ."
              },
              "PECEN": {
                "bit": 23,
                "description": "PEC enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0\u00e2\u0080\u0099. Refer to ."
              }
            },
            "I2C_CR2": {
              "SADD": {
                "bit": 0,
                "description": "Slave address (master mode)\nIn 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.\nIn 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] should be written with the 10-bit slave address to be sent.\nNote: Changing these bits when the START bit is set is not allowed.",
                "width": 10
              },
              "RD_WRN": {
                "bit": 10,
                "description": "Transfer direction (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
              },
              "ADD10": {
                "bit": 11,
                "description": "10-bit addressing mode (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
              },
              "HEAD10R": {
                "bit": 12,
                "description": "10-bit address header only read direction (master receiver mode)\nNote: Changing this bit when the START bit is set is not allowed."
              },
              "START": {
                "bit": 13,
                "description": "Start generation\nThis bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing '1\u00e2\u0080\u0099 to the ADDRCF bit in the I2C_ICR register.\nIf the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer.\nOtherwise setting this bit generates a START condition once the bus is free.\nNote: Writing '0\u00e2\u0080\u0099 to this bit has no effect.\nThe START bit can be set even if the bus is BUSY or I2C is in slave mode.\nThis bit has no effect when RELOAD is set."
              },
              "STOP": {
                "bit": 14,
                "description": "Stop generation (master mode)\nThe bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.\nIn Master Mode:\nNote: Writing '0\u00e2\u0080\u0099 to this bit has no effect."
              },
              "NACK": {
                "bit": 15,
                "description": "NACK generation (slave mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0.\nNote: Writing '0\u00e2\u0080\u0099 to this bit has no effect.\nThis bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.\nWhen an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.\nWhen hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value."
              },
              "NBYTES": {
                "bit": 16,
                "description": "Number of bytes\nThe number of bytes to be transmitted/received is programmed there. This field is don\u00e2\u0080\u0099t care in slave mode with SBC=0.\nNote: Changing these bits when the START bit is set is not allowed.",
                "width": 8
              },
              "RELOAD": {
                "bit": 24,
                "description": "NBYTES reload mode\nThis bit is set and cleared by software."
              },
              "AUTOEND": {
                "bit": 25,
                "description": "Automatic end mode (master mode)\nThis bit is set and cleared by software.\nNote: This bit has no effect in slave mode or when the RELOAD bit is set."
              },
              "PECBYTE": {
                "bit": 26,
                "description": "Packet error checking byte\nThis bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0.\nNote: Writing '0\u00e2\u0080\u0099 to this bit has no effect.\nThis bit has no effect when RELOAD is set.\nThis bit has no effect is slave mode when SBC=0.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0\u00e2\u0080\u0099. Refer to ."
              }
            },
            "I2C_OAR1": {
              "OA1": {
                "bit": 0,
                "description": "Interface own slave address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.\nNote: These bits can be written only when OA1EN=0.",
                "width": 10
              },
              "OA1MODE": {
                "bit": 10,
                "description": "Own Address 1 10-bit mode\nNote: This bit can be written only when OA1EN=0."
              },
              "OA1EN": {
                "bit": 15,
                "description": "Own Address 1 enable"
              }
            },
            "I2C_OAR2": {
              "OA2": {
                "bit": 1,
                "description": "Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN=0.",
                "width": 7
              },
              "OA2MSK": {
                "bit": 8,
                "description": "Own Address 2 masks\nNote: These bits can be written only when OA2EN=0.\nAs soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.",
                "width": 3
              },
              "OA2EN": {
                "bit": 15,
                "description": "Own Address 2 enable"
              }
            },
            "I2C_TIMINGR": {
              "SCLL": {
                "bit": 0,
                "description": "SCL low period (master\n              mode)",
                "width": 8
              },
              "SCLH": {
                "bit": 8,
                "description": "SCL high period (master\n              mode)",
                "width": 8
              },
              "SDADEL": {
                "bit": 16,
                "description": "Data hold time",
                "width": 4
              },
              "SCLDEL": {
                "bit": 20,
                "description": "Data setup time",
                "width": 4
              },
              "PRESC": {
                "bit": 28,
                "description": "Timing prescaler",
                "width": 4
              }
            },
            "I2C_TIMEOUTR": {
              "TIMEOUTA": {
                "bit": 0,
                "description": "Bus Timeout A\nThis field is used to configure:\nThe SCL low timeout condition tTIMEOUT when TIDLE=0\ntTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK\nThe bus idle condition (both SCL and SDA high) when TIDLE=1\ntIDLE= (TIMEOUTA+1) x 4 x tI2CCLK\nNote: These bits can be written only when TIMOUTEN=0.",
                "width": 12
              },
              "TIDLE": {
                "bit": 12,
                "description": "Idle clock timeout detection\nNote: This bit can be written only when TIMOUTEN=0."
              },
              "TIMOUTEN": {
                "bit": 15,
                "description": "Clock timeout enable"
              },
              "TIMEOUTB": {
                "bit": 16,
                "description": "Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nIn master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected\nIn slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected\ntLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK\nNote: These bits can be written only when TEXTEN=0.",
                "width": 12
              },
              "TEXTEN": {
                "bit": 31,
                "description": "Extended clock timeout enable"
              }
            },
            "I2C_ISR": {
              "ADDCODE": {
                "bit": 17,
                "description": "Address match code (Slave\n              mode)",
                "width": 7
              },
              "DIR": {
                "bit": 16,
                "description": "Transfer direction (Slave mode)\nThis flag is updated when an address match event occurs (ADDR=1)."
              },
              "BUSY": {
                "bit": 15,
                "description": "Bus busy"
              },
              "ALERT": {
                "bit": 13,
                "description": "SMBus alert"
              },
              "TIMEOUT": {
                "bit": 12,
                "description": "Timeout or t_low detection\n              flag"
              },
              "PECERR": {
                "bit": 11,
                "description": "PEC Error in reception"
              },
              "OVR": {
                "bit": 10,
                "description": "Overrun/Underrun (slave\n              mode)"
              },
              "ARLO": {
                "bit": 9,
                "description": "Arbitration lost"
              },
              "BERR": {
                "bit": 8,
                "description": "Bus error"
              },
              "TCR": {
                "bit": 7,
                "description": "Transfer Complete Reload"
              },
              "TC": {
                "bit": 6,
                "description": "Transfer Complete (master\n              mode)"
              },
              "STOPF": {
                "bit": 5,
                "description": "Stop detection flag"
              },
              "NACKF": {
                "bit": 4,
                "description": "Not acknowledge received\n              flag"
              },
              "ADDR": {
                "bit": 3,
                "description": "Address matched (slave\n              mode)"
              },
              "RXNE": {
                "bit": 2,
                "description": "Receive data register not empty\n              (receivers)"
              },
              "TXIS": {
                "bit": 1,
                "description": "Transmit interrupt status\n              (transmitters)"
              },
              "TXE": {
                "bit": 0,
                "description": "Transmit data register empty\n              (transmitters)"
              }
            },
            "I2C_ICR": {
              "ALERTCF": {
                "bit": 13,
                "description": "Alert flag clear"
              },
              "TIMOUTCF": {
                "bit": 12,
                "description": "Timeout detection flag\n              clear"
              },
              "PECCF": {
                "bit": 11,
                "description": "PEC Error flag clear"
              },
              "OVRCF": {
                "bit": 10,
                "description": "Overrun/Underrun flag\n              clear"
              },
              "ARLOCF": {
                "bit": 9,
                "description": "Arbitration lost flag\n              clear"
              },
              "BERRCF": {
                "bit": 8,
                "description": "Bus error flag clear"
              },
              "STOPCF": {
                "bit": 5,
                "description": "Stop detection flag clear"
              },
              "NACKCF": {
                "bit": 4,
                "description": "Not Acknowledge flag clear"
              },
              "ADDRCF": {
                "bit": 3,
                "description": "Address Matched flag clear"
              }
            },
            "I2C_PECR": {
              "PEC": {
                "bit": 0,
                "description": "Packet error checking\n              register",
                "width": 8
              }
            },
            "I2C_RXDR": {
              "RXDATA": {
                "bit": 0,
                "description": "8-bit receive data",
                "width": 8
              }
            },
            "I2C_TXDR": {
              "TXDATA": {
                "bit": 0,
                "description": "8-bit transmit data",
                "width": 8
              }
            }
          }
        },
        "WDG": {
          "instances": [
            {
              "name": "IWDG",
              "base": "0x40003000"
            },
            {
              "name": "WWDG",
              "base": "0x40002C00",
              "irq": 0
            }
          ],
          "registers": {
            "IWDG_KR": {
              "offset": "0x00",
              "size": 32,
              "description": "Key register"
            },
            "IWDG_PR": {
              "offset": "0x04",
              "size": 32,
              "description": "Prescaler register"
            },
            "IWDG_RLR": {
              "offset": "0x08",
              "size": 32,
              "description": "Reload register"
            },
            "IWDG_SR": {
              "offset": "0x0C",
              "size": 32,
              "description": "Status register"
            },
            "IWDG_WINR": {
              "offset": "0x10",
              "size": 32,
              "description": "Window register"
            }
          },
          "bits": {
            "IWDG_KR": {
              "KEY": {
                "bit": 0,
                "description": "Key value (write only, read\n              0x0000)",
                "width": 16
              }
            },
            "IWDG_PR": {
              "PR": {
                "bit": 0,
                "description": "Prescaler divider\nThese bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the  must be reset in order to be able to change the prescaler divider.\nNote: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset.",
                "width": 3
              }
            },
            "IWDG_RLR": {
              "RL": {
                "bit": 0,
                "description": "Watchdog counter reload\n              value",
                "width": 12
              }
            },
            "IWDG_SR": {
              "PVU": {
                "bit": 0,
                "description": "Watchdog prescaler value update\nThis bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to five LSI cycles).\nPrescaler value can be updated only when PVU bit is reset."
              },
              "RVU": {
                "bit": 1,
                "description": "Watchdog counter reload value update\nThis bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles).\nReload value can be updated only when RVU bit is reset."
              },
              "WVU": {
                "bit": 2,
                "description": "Watchdog counter window value update\nThis bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles).\nWindow value can be updated only when WVU bit is reset."
              }
            },
            "IWDG_WINR": {
              "WIN": {
                "bit": 0,
                "description": "Watchdog counter window\n              value",
                "width": 12
              }
            }
          }
        },
        "TIM": {
          "instances": [
            {
              "name": "LPTIM1",
              "base": "0x40007C00"
            },
            {
              "name": "LPTIM2",
              "base": "0x40009400"
            },
            {
              "name": "TIM1",
              "base": "0x40012C00",
              "irq": 13
            },
            {
              "name": "TIM2",
              "base": "0x40000000",
              "irq": 15
            },
            {
              "name": "TIM3",
              "base": "0x40000400",
              "irq": 16
            },
            {
              "name": "TIM6",
              "base": "0x40001000",
              "irq": 17
            },
            {
              "name": "TIM7",
              "base": "0x40001400",
              "irq": 18
            },
            {
              "name": "TIM14",
              "base": "0x40002000",
              "irq": 19
            },
            {
              "name": "TIM15",
              "base": "0x40014000",
              "irq": 20
            },
            {
              "name": "TIM16",
              "base": "0x40014400",
              "irq": 21
            },
            {
              "name": "TIM17",
              "base": "0x40014800",
              "irq": 22
            }
          ],
          "registers": {
            "LPTIM_ISR": {
              "offset": "0x00",
              "size": 32,
              "description": "Interrupt and Status Register"
            },
            "LPTIM_ICR": {
              "offset": "0x04",
              "size": 32,
              "description": "Interrupt Clear Register"
            },
            "LPTIM_IER": {
              "offset": "0x08",
              "size": 32,
              "description": "Interrupt Enable Register"
            },
            "LPTIM_CFGR": {
              "offset": "0x0C",
              "size": 32,
              "description": "Configuration Register"
            },
            "LPTIM_CR": {
              "offset": "0x10",
              "size": 32,
              "description": "Control Register"
            },
            "LPTIM_CMP": {
              "offset": "0x14",
              "size": 32,
              "description": "Compare Register"
            },
            "LPTIM_ARR": {
              "offset": "0x18",
              "size": 32,
              "description": "Autoreload Register"
            },
            "LPTIM_CNT": {
              "offset": "0x1C",
              "size": 32,
              "description": "Counter Register"
            },
            "LPTIM_CFGR2": {
              "offset": "0x24",
              "size": 32,
              "description": "LPTIM configuration register 2"
            }
          },
          "bits": {
            "LPTIM_ISR": {
              "CMPM": {
                "bit": 0,
                "description": "Compare match\nThe CMPM bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP register\u00e2\u0080\u0099s value."
              },
              "ARRM": {
                "bit": 1,
                "description": "Autoreload match\nARRM is set by hardware to inform application that LPTIM_CNT register\u00e2\u0080\u0099s value reached the LPTIM_ARR register\u00e2\u0080\u0099s value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register."
              },
              "EXTTRIG": {
                "bit": 2,
                "description": "External trigger edge event\nEXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register."
              },
              "CMPOK": {
                "bit": 3,
                "description": "Compare register update OK\nCMPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_CMP register has been successfully completed."
              },
              "ARROK": {
                "bit": 4,
                "description": "Autoreload register update OK\nARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register."
              },
              "UP": {
                "bit": 5,
                "description": "Counter direction change down to up\nIn Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
              },
              "DOWN": {
                "bit": 6,
                "description": "Counter direction change up to down\nIn Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
              }
            },
            "LPTIM_ICR": {
              "CMPMCF": {
                "bit": 0,
                "description": "Compare match clear flag\nWriting 1 to this bit clears the CMP flag in the LPTIM_ISR register"
              },
              "ARRMCF": {
                "bit": 1,
                "description": "Autoreload match clear flag\nWriting 1 to this bit clears the ARRM flag in the LPTIM_ISR register"
              },
              "EXTTRIGCF": {
                "bit": 2,
                "description": "External trigger valid edge clear flag\nWriting 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register"
              },
              "CMPOKCF": {
                "bit": 3,
                "description": "Compare register update OK clear flag\nWriting 1 to this bit clears the CMPOK flag in the LPTIM_ISR register"
              },
              "ARROKCF": {
                "bit": 4,
                "description": "Autoreload register update OK clear flag\nWriting 1 to this bit clears the ARROK flag in the LPTIM_ISR register"
              },
              "UPCF": {
                "bit": 5,
                "description": "Direction change to UP clear flag\nWriting 1 to this bit clear the UP flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
              },
              "DOWNCF": {
                "bit": 6,
                "description": "Direction change to down clear flag\nWriting 1 to this bit clear the DOWN flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
              }
            },
            "LPTIM_IER": {
              "CMPMIE": {
                "bit": 0,
                "description": "Compare match Interrupt Enable"
              },
              "ARRMIE": {
                "bit": 1,
                "description": "Autoreload match Interrupt Enable"
              },
              "EXTTRIGIE": {
                "bit": 2,
                "description": "External trigger valid edge Interrupt Enable"
              },
              "CMPOKIE": {
                "bit": 3,
                "description": "Compare register update OK Interrupt Enable"
              },
              "ARROKIE": {
                "bit": 4,
                "description": "Autoreload register update OK Interrupt Enable"
              },
              "UPIE": {
                "bit": 5,
                "description": "Direction change to UP Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
              },
              "DOWNIE": {
                "bit": 6,
                "description": "Direction change to down Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
              }
            },
            "LPTIM_CFGR": {
              "CKSEL": {
                "bit": 0,
                "description": "Clock selector\nThe CKSEL bit selects which clock source the LPTIM will use:"
              },
              "CKPOL": {
                "bit": 1,
                "description": "Clock Polarity\nIf LPTIM is clocked by an external clock source:\nWhen the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active.\nRefer to  for more details about Encoder mode sub-modes.",
                "width": 2
              },
              "CKFLT": {
                "bit": 3,
                "description": "Configurable digital filter for external clock\nThe CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature",
                "width": 2
              },
              "TRGFLT": {
                "bit": 6,
                "description": "Configurable digital filter for trigger\nThe TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature",
                "width": 2
              },
              "PRESC": {
                "bit": 9,
                "description": "Clock prescaler\nThe PRESC bits configure the prescaler division factor. It can be one among the following division factors:",
                "width": 3
              },
              "TRIGSEL": {
                "bit": 13,
                "description": "Trigger selector\nThe TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:\nSee  for details.",
                "width": 3
              },
              "TRIGEN": {
                "bit": 17,
                "description": "Trigger enable and polarity\nThe TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:",
                "width": 2
              },
              "TIMOUT": {
                "bit": 19,
                "description": "Timeout enable\nThe TIMOUT bit controls the Timeout feature"
              },
              "WAVE": {
                "bit": 20,
                "description": "Waveform shape\nThe WAVE bit controls the output shape"
              },
              "WAVPOL": {
                "bit": 21,
                "description": "Waveform shape polarity\nThe WAVEPOL bit controls the output polarity"
              },
              "PRELOAD": {
                "bit": 22,
                "description": "Registers update mode\nThe PRELOAD bit controls the LPTIM_ARR and the LPTIM_CMP registers update modality"
              },
              "COUNTMODE": {
                "bit": 23,
                "description": "counter mode enabled\nThe COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:"
              },
              "ENC": {
                "bit": 24,
                "description": "Encoder mode enable\nThe ENC bit controls the Encoder mode\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
              }
            },
            "LPTIM_CR": {
              "ENABLE": {
                "bit": 0,
                "description": "LPTIM enable\nThe ENABLE bit is set and cleared by software."
              },
              "SNGSTRT": {
                "bit": 1,
                "description": "LPTIM start in Single mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = '00\u00e2\u0080\u0099), setting this bit starts the LPTIM in single pulse mode.\nIf the software start is disabled (TRIGEN[1:0] different than '00\u00e2\u0080\u0099), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.\nIf this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between LPTIM_ARR and LPTIM_CNT registers.\nThis bit can only be set when the LPTIM is enabled. It will be automatically reset by hardware."
              },
              "CNTSTRT": {
                "bit": 2,
                "description": "Timer start in Continuous mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = '00\u00e2\u0080\u0099), setting this bit starts the LPTIM in Continuous mode.\nIf the software start is disabled (TRIGEN[1:0] different than '00\u00e2\u0080\u0099), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.\nIf this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between the LPTIM_ARR and LPTIM_CNT registers and the LPTIM counter keeps counting in Continuous mode.\nThis bit can be set only when the LPTIM is enabled. It will be automatically reset by hardware."
              },
              "COUNTRST": {
                "bit": 3,
                "description": "Counter reset\nThis bit is set by software and cleared by hardware. When set to '1' this bit will trigger a synchronous reset of the LPTIM_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock).\nCOUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software should consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'."
              },
              "RSTARE": {
                "bit": 4,
                "description": "Reset after read enable\nThis bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM_CNT register will asynchronously reset LPTIM_CNT register content."
              }
            },
            "LPTIM_CMP": {
              "CMP": {
                "bit": 0,
                "description": "Compare value",
                "width": 16
              }
            },
            "LPTIM_ARR": {
              "ARR": {
                "bit": 0,
                "description": "Auto reload value",
                "width": 16
              }
            },
            "LPTIM_CNT": {
              "CNT": {
                "bit": 0,
                "description": "Counter value",
                "width": 16
              }
            },
            "LPTIM_CFGR2": {
              "IN1SEL": {
                "bit": 0,
                "description": "LPTIM input 1 selection\nThe IN1SEL bits control the LPTIM Input 1 multiplexer, which connects LPTIM Input 1 to one of the available inputs.\nFor connection details refer to .",
                "width": 2
              },
              "IN2SEL": {
                "bit": 4,
                "description": "LPTIM input 2 selection\nThe IN2SEL bits control the LPTIM Input 2 multiplexer, which connect LPTIM Input 2 to one of the available inputs.\nFor connection details refer to .\nNote: If the LPTIM does not support encoder mode feature, these bits are reserved. Please refer to .",
                "width": 2
              }
            }
          }
        },
        "USART": {
          "instances": [
            {
              "name": "LPUART1",
              "base": "0x40008000"
            },
            {
              "name": "USART1",
              "base": "0x40013800",
              "irq": 27
            },
            {
              "name": "USART2",
              "base": "0x40004400",
              "irq": 28
            }
          ],
          "registers": {
            "LPUART_CR1_enabled": {
              "offset": "0x00",
              "size": 32,
              "description": "LPUART control register 1 [alternate]"
            },
            "LPUART_CR1_disabled": {
              "offset": "0x00",
              "size": 32,
              "description": "LPUART control register 1 [alternate]"
            },
            "LPUART_CR2": {
              "offset": "0x04",
              "size": 32,
              "description": "LPUART control register 2"
            },
            "LPUART_CR3": {
              "offset": "0x08",
              "size": 32,
              "description": "LPUART control register 3"
            },
            "LPUART_BRR": {
              "offset": "0x0C",
              "size": 32,
              "description": "LPUART baud rate register"
            },
            "LPUART_RQR": {
              "offset": "0x18",
              "size": 32,
              "description": "LPUART request register"
            },
            "LPUART_ISR_enabled": {
              "offset": "0x1C",
              "size": 32,
              "description": "LPUART interrupt and status register [alternate]"
            },
            "LPUART_ISR_disabled": {
              "offset": "0x1C",
              "size": 32,
              "description": "LPUART interrupt and status register [alternate]"
            },
            "LPUART_ICR": {
              "offset": "0x20",
              "size": 32,
              "description": "LPUART interrupt flag clear register"
            },
            "LPUART_RDR": {
              "offset": "0x24",
              "size": 32,
              "description": "LPUART receive data register"
            },
            "LPUART_TDR": {
              "offset": "0x28",
              "size": 32,
              "description": "LPUART transmit data register"
            },
            "LPUART_PRESC": {
              "offset": "0x2C",
              "size": 32,
              "description": "LPUART prescaler register"
            }
          },
          "bits": {
            "LPUART_CR1_enabled": {
              "UE": {
                "bit": 0,
                "description": "USART enable\n\tWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.\n\tNote: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.\n\tThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.\n\tIn Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value."
              },
              "UESM": {
                "bit": 1,
                "description": "USART enable in low-power mode\n\tWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\n\tWhen this bit is set, the USART can wake up the MCU from low-power mode.\n\tThis bit is set and cleared by software.\n\tNote: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode.\n\tIf the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to ."
              },
              "RE": {
                "bit": 2,
                "description": "Receiver enable\n\tThis bit enables the receiver. It is set and cleared by software."
              },
              "TE": {
                "bit": 3,
                "description": "Transmitter enable\n\tThis bit enables the transmitter. It is set and cleared by software.\n\tNote: During transmission, a low pulse on the TE bit ('0\u00e2\u0080\u0099 followed by '1\u00e2\u0080\u0099) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1\u00e2\u0080\u0099. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.\n\tIn Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
              },
              "IDLEIE": {
                "bit": 4,
                "description": "IDLE interrupt enable\n\tThis bit is set and cleared by software."
              },
              "RXFNEIE": {
                "bit": 5,
                "description": "RXFIFO not empty interrupt enable\n\tThis bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 6,
                "description": "Transmission complete interrupt enable\n\tThis bit is set and cleared by software."
              },
              "TXFNFIE": {
                "bit": 7,
                "description": "TXFIFO not full interrupt enable\n\tThis bit is set and cleared by software."
              },
              "PEIE": {
                "bit": 8,
                "description": "PE interrupt enable\n\tThis bit is set and cleared by software."
              },
              "PS": {
                "bit": 9,
                "description": "Parity selection\n\tThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\n\tThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "PCE": {
                "bit": 10,
                "description": "Parity control enable\n\tThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M\u00c2\u00a0=\u00c2\u00a01; 8th bit if M\u00c2\u00a0=\u00c2\u00a00) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\n\tThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "WAKE": {
                "bit": 11,
                "description": "Receiver wakeup method\n\tThis bit determines the USART wakeup method from Mute mode. It is set or cleared by software.\n\tThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "M0": {
                "bit": 12,
                "description": "Word length\n\tThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\n\tThis bit can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "MME": {
                "bit": 13,
                "description": "Mute mode enable\n\tThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software."
              },
              "CMIE": {
                "bit": 14,
                "description": "Character match interrupt enable\n\tThis bit is set and cleared by software."
              },
              "OVER8": {
                "bit": 15,
                "description": "Oversampling mode\n\tThis bit can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\n\tNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared."
              },
              "DEDT": {
                "bit": 16,
                "description": "Driver Enable deassertion time\n\tThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\n\tIf the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\n\tThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\n\tNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .",
                "width": 5
              },
              "DEAT": {
                "bit": 21,
                "description": "Driver Enable assertion time\n\tThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\n\tThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\n\tNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .",
                "width": 5
              },
              "RTOIE": {
                "bit": 26,
                "description": "Receiver timeout interrupt enable\n\tThis bit is set and cleared by software.\n\tNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. ."
              },
              "EOBIE": {
                "bit": 27,
                "description": "End of Block interrupt enable\n\tThis bit is set and cleared by software.\n\tNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
              },
              "M1": {
                "bit": 28,
                "description": "Word length\n\tThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\n\tM[1:0] = '00\u00e2\u0080\u0099: 1 start bit, 8 Data bits, n Stop bit\n\tM[1:0] = '01\u00e2\u0080\u0099: 1 start bit, 9 Data bits, n Stop bit\n\tM[1:0] = '10\u00e2\u0080\u0099: 1 start bit, 7 Data bits, n Stop bit\n\tThis bit can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\n\tNote: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported."
              },
              "FIFOEN": {
                "bit": 29,
                "description": "FIFO mode enable\n\tThis bit is set and cleared by software.\n\tThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\n\tNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes."
              },
              "TXFEIE": {
                "bit": 30,
                "description": "TXFIFO empty interrupt enable\n\tThis bit is set and cleared by software."
              },
              "RXFFIE": {
                "bit": 31,
                "description": "RXFIFO Full interrupt enable\n\tThis bit is set and cleared by software."
              }
            },
            "LPUART_CR1_disabled": {
              "UE": {
                "bit": 0,
                "description": "USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.\nNote: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.\nIn Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value."
              },
              "UESM": {
                "bit": 1,
                "description": "USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to ."
              },
              "RE": {
                "bit": 2,
                "description": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software."
              },
              "TE": {
                "bit": 3,
                "description": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ('0\u00e2\u0080\u0099 followed by '1\u00e2\u0080\u0099) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1\u00e2\u0080\u0099. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.\nIn Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
              },
              "IDLEIE": {
                "bit": 4,
                "description": "IDLE interrupt enable\nThis bit is set and cleared by software."
              },
              "RXNEIE": {
                "bit": 5,
                "description": "Receive data register not empty\nThis bit is set and cleared by software."
              },
              "TCIE": {
                "bit": 6,
                "description": "Transmission complete interrupt enable\nThis bit is set and cleared by software."
              },
              "TXEIE": {
                "bit": 7,
                "description": "Transmit data register empty\nThis bit is set and cleared by software."
              },
              "PEIE": {
                "bit": 8,
                "description": "PE interrupt enable\nThis bit is set and cleared by software."
              },
              "PS": {
                "bit": 9,
                "description": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "PCE": {
                "bit": 10,
                "description": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M\u00c2\u00a0=\u00c2\u00a01; 8th bit if M\u00c2\u00a0=\u00c2\u00a00) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\nThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "WAKE": {
                "bit": 11,
                "description": "Receiver wakeup method\nThis bit determines the USART wakeup method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "M0": {
                "bit": 12,
                "description": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "MME": {
                "bit": 13,
                "description": "Mute mode enable\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software."
              },
              "CMIE": {
                "bit": 14,
                "description": "Character match interrupt enable\nThis bit is set and cleared by software."
              },
              "OVER8": {
                "bit": 15,
                "description": "Oversampling mode\nThis bit can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared."
              },
              "DEDT": {
                "bit": 16,
                "description": "Driver Enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .",
                "width": 5
              },
              "DEAT": {
                "bit": 21,
                "description": "Driver Enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .",
                "width": 5
              },
              "RTOIE": {
                "bit": 26,
                "description": "Receiver timeout interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. ."
              },
              "EOBIE": {
                "bit": 27,
                "description": "End of Block interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
              },
              "M1": {
                "bit": 28,
                "description": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] = '00\u00e2\u0080\u0099: 1 start bit, 8 Data bits, n Stop bit\nM[1:0] = '01\u00e2\u0080\u0099: 1 start bit, 9 Data bits, n Stop bit\nM[1:0] = '10\u00e2\u0080\u0099: 1 start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\nNote: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported."
              },
              "FIFOEN": {
                "bit": 29,
                "description": "FIFO mode enable\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes."
              }
            },
            "LPUART_CR2": {
              "ADDM7": {
                "bit": 4,
                "description": "7-bit Address Detection/4-bit Address Detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
              },
              "STOP": {
                "bit": 12,
                "description": "STOP bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).",
                "width": 2
              },
              "SWAP": {
                "bit": 15,
                "description": "Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "RXINV": {
                "bit": 16,
                "description": "RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "TXINV": {
                "bit": 17,
                "description": "TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "DATAINV": {
                "bit": 18,
                "description": "Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "MSBFIRST": {
                "bit": 19,
                "description": "Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "ADD": {
                "bit": 24,
                "description": "Address of the LPUART node\nADD[7:4]:\nThese bits give the address of the LPUART node or a character code to be recognized.\nThey are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or Stop mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match.\nThese bits can only be written when reception is disabled (RE = 0) or the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)\nADD[3:0]:\nThese bits give the address of the LPUART node or a character code to be recognized.\nThey are used for wakeup with address mark detection in multiprocessor communication during Mute mode or low-power mode.\nThese bits can only be written when reception is disabled (RE = 0) or the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)",
                "width": 8
              }
            },
            "LPUART_CR3": {
              "EIE": {
                "bit": 0,
                "description": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE\u00c2\u00a0=\u00c2\u00a01 or ORE\u00c2\u00a0=\u00c2\u00a01 or NE\u00c2\u00a0=\u00c2\u00a01 in the LPUART_ISR register)."
              },
              "HDSEL": {
                "bit": 3,
                "description": "Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "DMAR": {
                "bit": 6,
                "description": "DMA enable receiver\nThis bit is set/reset by software"
              },
              "DMAT": {
                "bit": 7,
                "description": "DMA enable transmitter\nThis bit is set/reset by software"
              },
              "RTSE": {
                "bit": 8,
                "description": "RTS enable\nThis bit can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "CTSE": {
                "bit": 9,
                "description": "CTS enable\nThis bit can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)"
              },
              "CTSIE": {
                "bit": 10,
                "description": "CTS interrupt enable"
              },
              "OVRDIS": {
                "bit": 12,
                "description": "Overrun Disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register.\nThis bit can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\nNote: This control bit enables checking the communication flow w/o reading the data."
              },
              "DDRE": {
                "bit": 13,
                "description": "DMA Disable on Reception Error\nThis bit can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\nNote: The reception errors are: parity error, framing error or noise error."
              },
              "DEM": {
                "bit": 14,
                "description": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "DEP": {
                "bit": 15,
                "description": "Driver enable polarity selection\nThis bit can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00)."
              },
              "WUS": {
                "bit": 20,
                "description": "Wakeup from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).\nThis bitfield can only be written when the LPUART is disabled (UE\u00c2\u00a0=\u00c2\u00a00).\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .",
                "width": 2
              },
              "WUFIE": {
                "bit": 22,
                "description": "Wakeup from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nIf the LPUART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to ."
              },
              "TXFTIE": {
                "bit": 23,
                "description": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
              },
              "RXFTCFG": {
                "bit": 25,
                "description": "Receive FIFO threshold configuration\nRemaining combinations: Reserved.",
                "width": 3
              },
              "RXFTIE": {
                "bit": 28,
                "description": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
              },
              "TXFTCFG": {
                "bit": 29,
                "description": "TXFIFO threshold configuration\nRemaining combinations: Reserved.",
                "width": 3
              }
            },
            "LPUART_BRR": {
              "BRR": {
                "bit": 0,
                "description": "LPUART baud rate",
                "width": 20
              }
            },
            "LPUART_RQR": {
              "SBKRQ": {
                "bit": 1,
                "description": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit."
              },
              "MMRQ": {
                "bit": 2,
                "description": "Mute mode request\nWriting 1 to this bit puts the LPUART in Mute mode and resets the RWU flag."
              },
              "RXFRQ": {
                "bit": 3,
                "description": "Receive data flush request\nWriting 1 to this bit clears the RXNE flag.\nThis enables discarding the received data without reading it, and avoid an overrun condition."
              },
              "TXFRQ": {
                "bit": 4,
                "description": "Transmit data flush request\nThis bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register).\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
              }
            },
            "LPUART_ISR_enabled": {
              "PE": {
                "bit": 0,
                "description": "Parity error\n\tThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\n\tAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\n\tNote: This error is associated with the character in the USART_RDR."
              },
              "FE": {
                "bit": 1,
                "description": "Framing error\n\tThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\n\tWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\n\tAn interrupt is generated if EIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register.\n\tNote: This error is associated with the character in the USART_RDR."
              },
              "NE": {
                "bit": 2,
                "description": "Noise detection flag\n\tThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.\n\tNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\n\tWhen the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page\u00c2\u00a0903).\n\tThis error is associated with the character in the USART_RDR."
              },
              "ORE": {
                "bit": 3,
                "description": "Overrun error\n\tThis bit is set by hardware when the data currently being received in the shift register is\n\tready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\n\tAn interrupt is generated if RXFNEIE\u00c2\u00a0=\u00c2\u00a01 or EIE = 1 in the USART_CR1 register.\n\tNote: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\n\tThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register."
              },
              "IDLE": {
                "bit": 4,
                "description": "Idle line detected\n\tThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\n\tNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\n\tIf Mute mode is enabled (MME\u00c2\u00a0=\u00c2\u00a01), IDLE is set if the USART is not mute (RWU\u00c2\u00a0=\u00c2\u00a00), whatever the Mute mode selected by the WAKE bit. If RWU\u00c2\u00a0=\u00c2\u00a01, IDLE is not set."
              },
              "RXFNE": {
                "bit": 5,
                "description": "RXFIFO not empty\n\tRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.\n\tRXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.\n\tAn interrupt is generated if RXFNEIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register."
              },
              "TC": {
                "bit": 6,
                "description": "Transmission complete\n\tThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.\n\tIt is set by hardware when the transmission of a frame containing data is complete and when TXFE is set.\n\tAn interrupt is generated if TCIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register.\n\tTC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register.\n\tNote: If TE bit is reset and no transmission is on going, the TC bit is immediately set."
              },
              "TXFNF": {
                "bit": 7,
                "description": "TXFIFO not full\n\tTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR.\n\tAn interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.\n\tNote: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).\n\tThis bit is used during single buffer transmission."
              },
              "LBDF": {
                "bit": 8,
                "description": "LIN break detection flag\n\tThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\n\tAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\n\tNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to ."
              },
              "CTSIF": {
                "bit": 9,
                "description": "CTS interrupt flag\n\tThis bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\n\tAn interrupt is generated if CTSIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR3 register.\n\tNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
              },
              "CTS": {
                "bit": 10,
                "description": "CTS flag\n\tThis bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.\n\tNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
              },
              "RTOF": {
                "bit": 11,
                "description": "Receiver timeout\n\tThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\n\tAn interrupt is generated if RTOIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR2 register.\n\tIn Smartcard mode, the timeout corresponds to the CWT or BWT timings.\n\tNote: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.\n\tThe counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.\n\tIf the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value."
              },
              "EOBF": {
                "bit": 12,
                "description": "End of block flag\n\tThis bit is set by hardware when a complete block has been received (for example T\u00c2\u00a0=\u00c2\u00a01 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.\n\tAn interrupt is generated if the EOBIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR2 register.\n\tIt is cleared by software, writing 1 to the EOBCF in the USART_ICR register.\n\tNote: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to ."
              },
              "UDR": {
                "bit": 13,
                "description": "SPI slave underrun error flag\n\tIn slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.\n\tNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to ."
              },
              "ABRE": {
                "bit": 14,
                "description": "Auto baud rate error\n\tThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\n\tIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register.\n\tNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
              },
              "ABRF": {
                "bit": 15,
                "description": "Auto baud rate flag\n\tThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE\u00c2\u00a0=\u00c2\u00a01) (ABRE, RXFNE and FE are also set in this case)\n\tIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.\n\tNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
              },
              "BUSY": {
                "bit": 16,
                "description": "Busy flag\n\tThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
              },
              "CMF": {
                "bit": 17,
                "description": "Character match flag\n\tThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\n\tAn interrupt is generated if CMIE\u00c2\u00a0=\u00c2\u00a01in the USART_CR1 register."
              },
              "SBKF": {
                "bit": 18,
                "description": "Send break flag\n\tThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
              },
              "RWU": {
                "bit": 19,
                "description": "Receiver wakeup from Mute mode\n\tThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.\n\tWhen wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.\n\tNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
              },
              "WUF": {
                "bit": 20,
                "description": "Wakeup from low-power mode flag\n\tThis bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\n\tAn interrupt is generated if WUFIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR3 register.\n\tNote: When UESM is cleared, WUF flag is also cleared.\n\tIf the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
              },
              "TEACK": {
                "bit": 21,
                "description": "Transmit enable acknowledge flag\n\tThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\n\tIt can be used when an idle frame request is generated by writing TE\u00c2\u00a0=\u00c2\u00a00, followed by TE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register, in order to respect the TE\u00c2\u00a0=\u00c2\u00a00 minimum period."
              },
              "REACK": {
                "bit": 22,
                "description": "Receive enable acknowledge flag\n\tThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\n\tIt can be used to verify that the USART is ready for reception before entering low-power mode.\n\tNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
              },
              "TXFE": {
                "bit": 23,
                "description": "TXFIFO empty\n\tThis bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.\n\tAn interrupt is generated if the TXFEIE bit \u00c2\u00a0=\u00c2\u00a01 (bit 30) in the USART_CR1 register."
              },
              "RXFF": {
                "bit": 24,
                "description": "RXFIFO full\n\tThis bit is set by hardware when the number of received data corresponds to RXFIFO\u00c2\u00a0size\u00c2\u00a0+\u00c2\u00a01 (RXFIFO full + 1 data in the USART_RDR register.\n\tAn interrupt is generated if the RXFFIE bit \u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register."
              },
              "TCBGT": {
                "bit": 25,
                "description": "Transmission complete before guard time flag\n\tThis bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.\n\tIt is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR3 register.\n\tThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.\n\tNote: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1\u00e2\u0080\u0099. Refer to on page\u00c2\u00a0877."
              },
              "RXFT": {
                "bit": 26,
                "description": "RXFIFO threshold flag\n\tThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit \u00c2\u00a0=\u00c2\u00a01 (bit 27) in the USART_CR3 register.\n\tNote: When the RXFTCFG threshold is configured to '101\u00e2\u0080\u0099, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data."
              },
              "TXFT": {
                "bit": 27,
                "description": "TXFIFO threshold flag\n\tThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit \u00c2\u00a0=\u00c2\u00a01 (bit 31) in the USART_CR3 register."
              }
            },
            "LPUART_ISR_disabled": {
              "PE": {
                "bit": 0,
                "description": "Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register."
              },
              "FE": {
                "bit": 1,
                "description": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register."
              },
              "NE": {
                "bit": 2,
                "description": "Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\nWhen the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page\u00c2\u00a0903)."
              },
              "ORE": {
                "bit": 3,
                "description": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXNE\u00c2\u00a0=\u00c2\u00a01. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\nAn interrupt is generated if RXNEIE\u00c2\u00a0=\u00c2\u00a01 or EIE \u00c2\u00a0=\u00c2\u00a0 1 in the USART_CR1 register.\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register."
              },
              "IDLE": {
                "bit": 4,
                "description": "Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\nNote: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs).\nIf Mute mode is enabled (MME\u00c2\u00a0=\u00c2\u00a01), IDLE is set if the USART is not mute (RWU\u00c2\u00a0=\u00c2\u00a00), whatever the Mute mode selected by the WAKE bit. If RWU\u00c2\u00a0=\u00c2\u00a01, IDLE is not set."
              },
              "RXNE": {
                "bit": 5,
                "description": "Read data register not empty\nRXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.\nAn interrupt is generated if RXNEIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register."
              },
              "TC": {
                "bit": 6,
                "description": "Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and when TXE is set.\nAn interrupt is generated if TCIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register.\nTC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register.\nNote: If TE bit is reset and no transmission is on going, the TC bit is set immediately."
              },
              "TXE": {
                "bit": 7,
                "description": "Transmit data register empty\nTXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard T\u00c2\u00a0=\u00c2\u00a00 mode, in case of transmission failure).\nAn interrupt is generated if the TXEIE bit \u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register."
              },
              "LBDF": {
                "bit": 8,
                "description": "LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to ."
              },
              "CTSIF": {
                "bit": 9,
                "description": "CTS interrupt flag\nThis bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR3 register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
              },
              "CTS": {
                "bit": 10,
                "description": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
              },
              "RTOF": {
                "bit": 11,
                "description": "Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\nAn interrupt is generated if RTOIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR2 register.\nIn Smartcard mode, the timeout corresponds to the CWT or BWT timings.\nNote: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.\nThe counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.\nIf the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value."
              },
              "EOBF": {
                "bit": 12,
                "description": "End of block flag\nThis bit is set by hardware when a complete block has been received (for example T\u00c2\u00a0=\u00c2\u00a01 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.\nAn interrupt is generated if the EOBIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR2 register.\nIt is cleared by software, writing 1 to the EOBCF in the USART_ICR register.\nNote: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to ."
              },
              "UDR": {
                "bit": 13,
                "description": "SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to ."
              },
              "ABRE": {
                "bit": 14,
                "description": "Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
              },
              "ABRF": {
                "bit": 15,
                "description": "Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE\u00c2\u00a0=\u00c2\u00a01) (ABRE, RXNE and FE are also set in this case)\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
              },
              "BUSY": {
                "bit": 16,
                "description": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
              },
              "CMF": {
                "bit": 17,
                "description": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE\u00c2\u00a0=\u00c2\u00a01in the USART_CR1 register."
              },
              "SBKF": {
                "bit": 18,
                "description": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
              },
              "RWU": {
                "bit": 19,
                "description": "Receiver wakeup from Mute mode\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.\nWhen wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
              },
              "WUF": {
                "bit": 20,
                "description": "Wakeup from low-power mode flag\nThis bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
              },
              "TEACK": {
                "bit": 21,
                "description": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\nIt can be used when an idle frame request is generated by writing TE\u00c2\u00a0=\u00c2\u00a00, followed by TE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR1 register, in order to respect the TE\u00c2\u00a0=\u00c2\u00a00 minimum period."
              },
              "REACK": {
                "bit": 22,
                "description": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
              },
              "TCBGT": {
                "bit": 25,
                "description": "Transmission complete before guard time flag\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.\nIt is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE\u00c2\u00a0=\u00c2\u00a01 in the USART_CR3 register.\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1\u00e2\u0080\u0099. Refer to on page\u00c2\u00a0877."
              }
            },
            "LPUART_ICR": {
              "PECF": {
                "bit": 0,
                "description": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the LPUART_ISR register."
              },
              "FECF": {
                "bit": 1,
                "description": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the LPUART_ISR register."
              },
              "NECF": {
                "bit": 2,
                "description": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the LPUART_ISR register."
              },
              "ORECF": {
                "bit": 3,
                "description": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the LPUART_ISR register."
              },
              "IDLECF": {
                "bit": 4,
                "description": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the LPUART_ISR register."
              },
              "TCCF": {
                "bit": 6,
                "description": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the LPUART_ISR register."
              },
              "CTSCF": {
                "bit": 9,
                "description": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the LPUART_ISR register."
              },
              "CMCF": {
                "bit": 17,
                "description": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the LPUART_ISR register."
              },
              "WUCF": {
                "bit": 20,
                "description": "Wakeup from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the LPUART_ISR register.\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
              }
            },
            "LPUART_RDR": {
              "RDR": {
                "bit": 0,
                "description": "Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see ).\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity bit.",
                "width": 9
              }
            },
            "LPUART_TDR": {
              "TDR": {
                "bit": 0,
                "description": "Transmit data value\nContains the data character to be transmitted.\nThe TDR register provides the parallel interface between the internal bus and the output shift register (see ).\nWhen transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.\nNote: This register must be written only when TXE/TXFNF\u00c2\u00a0=\u00c2\u00a01.",
                "width": 9
              }
            },
            "LPUART_PRESC": {
              "PRESCALER": {
                "bit": 0,
                "description": "Clock prescaler\nThe LPUART input clock can be divided by a prescaler:\nRemaining combinations: Reserved.\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.",
                "width": 4
              }
            }
          }
        },
        "RNG": {
          "instances": [
            {
              "name": "RNG",
              "base": "0x40025000"
            }
          ],
          "registers": {
            "RNG_CR": {
              "offset": "0x00",
              "size": 32,
              "description": "control register"
            },
            "RNG_SR": {
              "offset": "0x04",
              "size": 32,
              "description": "status register"
            },
            "RNG_DR": {
              "offset": "0x08",
              "size": 32,
              "description": "RNG data register"
            }
          },
          "bits": {
            "RNG_CR": {
              "RNGEN": {
                "bit": 2,
                "description": "True random number generator enable"
              },
              "IE": {
                "bit": 3,
                "description": "Interrupt Enable"
              },
              "CED": {
                "bit": 5,
                "description": "Clock error detection\nThe clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, i.e. to enable or disable CED the RNG must be disabled."
              }
            },
            "RNG_SR": {
              "DRDY": {
                "bit": 0,
                "description": "Data Ready\nOnce the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated.\nNote: The DRDY bit can rise when the peripheral is disabled (RNGEN=0 in the RNG_CR register).\nIf IE=1 in the RNG_CR register, an interrupt is generated when DRDY=1."
              },
              "CECS": {
                "bit": 1,
                "description": "Clock error current status\nNote: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0."
              },
              "SECS": {
                "bit": 2,
                "description": "Seed error current status\nOne of the noise source has provided more than 64 consecutive bits at a constant value (\u00e2\u0080\u009c0\u00e2\u0080\u009d or \u00e2\u0080\u009c1\u00e2\u0080\u009d), or more than 32 consecutive occurrence of two bit patterns (\u00e2\u0080\u009c01\u00e2\u0080\u009d or \u00e2\u0080\u009c10\u00e2\u0080\u009d)\nBoth noise sources have delivered more than 32 consecutive bits at a constant value (\u00e2\u0080\u009c0\u00e2\u0080\u009d or \u00e2\u0080\u009c1\u00e2\u0080\u009d), or more than 16 consecutive occurrence of two bit patterns (\u00e2\u0080\u009c01\u00e2\u0080\u009d or \u00e2\u0080\u009c10\u00e2\u0080\u009d)"
              },
              "CEIS": {
                "bit": 5,
                "description": "Clock error interrupt status\nThis bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect.\nAn interrupt is pending if IE = 1 in the RNG_CR register."
              },
              "SEIS": {
                "bit": 6,
                "description": "Seed error interrupt status\nThis bit is set at the same time as SECS. It is cleared by writing 0. Writing 1 has no effect.\nAn interrupt is pending if IE = 1 in the RNG_CR register."
              }
            },
            "RNG_DR": {
              "RNDATA": {
                "bit": 0,
                "description": "Random data\n32-bit random data which are valid when DRDY=1. When DRDY=0 RNDATA value is zero.\nIt is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event).",
                "width": 32
              }
            }
          }
        },
        "RTC": {
          "instances": [
            {
              "name": "RTC",
              "base": "0x40002800",
              "irq": 2
            }
          ],
          "registers": {
            "RTC_TR": {
              "offset": "0x00",
              "size": 32,
              "description": "RTC time register"
            },
            "RTC_DR": {
              "offset": "0x04",
              "size": 32,
              "description": "RTC date register"
            },
            "RTC_SSR": {
              "offset": "0x08",
              "size": 32,
              "description": "RTC sub second register"
            },
            "RTC_ICSR": {
              "offset": "0x0C",
              "size": 32,
              "description": "RTC initialization control and status register"
            },
            "RTC_PRER": {
              "offset": "0x10",
              "size": 32,
              "description": "RTC prescaler register"
            },
            "RTC_WUTR": {
              "offset": "0x14",
              "size": 32,
              "description": "RTC wakeup timer register"
            },
            "RTC_CR": {
              "offset": "0x18",
              "size": 32,
              "description": "RTC control register"
            },
            "RTC_WPR": {
              "offset": "0x24",
              "size": 32,
              "description": "RTC write protection register"
            },
            "RTC_CALR": {
              "offset": "0x28",
              "size": 32,
              "description": "RTC calibration register"
            },
            "RTC_SHIFTR": {
              "offset": "0x2C",
              "size": 32,
              "description": "RTC shift control register"
            },
            "RTC_TSTR": {
              "offset": "0x30",
              "size": 32,
              "description": "RTC timestamp time register"
            },
            "RTC_TSDR": {
              "offset": "0x34",
              "size": 32,
              "description": "RTC timestamp date register"
            },
            "RTC_TSSSR": {
              "offset": "0x38",
              "size": 32,
              "description": "RTC timestamp sub second register"
            },
            "RTC_ALRMAR": {
              "offset": "0x40",
              "size": 32,
              "description": "RTC alarm A register"
            },
            "RTC_ALRMASSR": {
              "offset": "0x44",
              "size": 32,
              "description": "RTC alarm A sub second register"
            },
            "RTC_ALRMBR": {
              "offset": "0x48",
              "size": 32,
              "description": "RTC alarm B register"
            },
            "RTC_ALRMBSSR": {
              "offset": "0x4C",
              "size": 32,
              "description": "RTC alarm B sub second register"
            },
            "RTC_SR": {
              "offset": "0x50",
              "size": 32,
              "description": "RTC status register"
            },
            "RTC_MISR": {
              "offset": "0x54",
              "size": 32,
              "description": "RTC masked interrupt status register"
            },
            "RTC_SCR": {
              "offset": "0x5C",
              "size": 32,
              "description": "RTC status clear register"
            }
          },
          "bits": {
            "RTC_TR": {
              "SU": {
                "bit": 0,
                "description": "Second units in BCD format",
                "width": 4
              },
              "ST": {
                "bit": 4,
                "description": "Second tens in BCD format",
                "width": 3
              },
              "MNU": {
                "bit": 8,
                "description": "Minute units in BCD format",
                "width": 4
              },
              "MNT": {
                "bit": 12,
                "description": "Minute tens in BCD format",
                "width": 3
              },
              "HU": {
                "bit": 16,
                "description": "Hour units in BCD format",
                "width": 4
              },
              "HT": {
                "bit": 20,
                "description": "Hour tens in BCD format",
                "width": 2
              },
              "PM": {
                "bit": 22,
                "description": "AM/PM notation"
              }
            },
            "RTC_DR": {
              "DU": {
                "bit": 0,
                "description": "Date units in BCD format",
                "width": 4
              },
              "DT": {
                "bit": 4,
                "description": "Date tens in BCD format",
                "width": 2
              },
              "MU": {
                "bit": 8,
                "description": "Month units in BCD format",
                "width": 4
              },
              "MT": {
                "bit": 12,
                "description": "Month tens in BCD format"
              },
              "WDU": {
                "bit": 13,
                "description": "Week day units\n...",
                "width": 3
              },
              "YU": {
                "bit": 16,
                "description": "Year units in BCD format",
                "width": 4
              },
              "YT": {
                "bit": 20,
                "description": "Year tens in BCD format",
                "width": 4
              }
            },
            "RTC_SSR": {
              "SS": {
                "bit": 0,
                "description": "Sub second value\nSS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:\nSecond fraction = (PREDIV_S - SS) / (PREDIV_S + 1)\nNote: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.",
                "width": 16
              }
            },
            "RTC_ICSR": {
              "ALRAWF": {
                "bit": 0,
                "description": "Alarm A write flag\nThis bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
              },
              "ALRBWF": {
                "bit": 1,
                "description": "Alarm B write flag\nThis bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
              },
              "WUTWF": {
                "bit": 2,
                "description": "Wakeup timer write flag\nThis bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
              },
              "SHPF": {
                "bit": 3,
                "description": "Shift operation pending\nThis flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect."
              },
              "INITS": {
                "bit": 4,
                "description": "Initialization status flag\nThis bit is set by hardware when the calendar year field is different from 0 (RTC domain reset state)."
              },
              "RSF": {
                "bit": 5,
                "description": "Registers synchronization flag\nThis bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software.\nIt is cleared either by software or by hardware in initialization mode."
              },
              "INITF": {
                "bit": 6,
                "description": "Initialization flag\nWhen this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated."
              },
              "INIT": {
                "bit": 7,
                "description": "Initialization mode"
              },
              "RECALPF": {
                "bit": 16,
                "description": "Recalibration pending Flag\nThe RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to ."
              }
            },
            "RTC_PRER": {
              "PREDIV_S": {
                "bit": 0,
                "description": "Synchronous prescaler factor\nThis is the synchronous division factor:\nck_spre frequency = ck_apre frequency/(PREDIV_S+1)",
                "width": 15
              },
              "PREDIV_A": {
                "bit": 16,
                "description": "Asynchronous prescaler factor\nThis is the asynchronous division factor:\nck_apre frequency = RTCCLK frequency/(PREDIV_A+1)",
                "width": 7
              }
            },
            "RTC_WUTR": {
              "WUT": {
                "bit": 0,
                "description": "Wakeup auto-reload value bits\nWhen the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]\u00c2\u00a0+\u00c2\u00a01) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register.\nWhen WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer.\nThe first assertion of WUTF occurs between WUT and (WUT + 1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden.",
                "width": 16
              }
            },
            "RTC_CR": {
              "WUCKSEL": {
                "bit": 0,
                "description": "ck_wut wakeup clock selection\n10x: ck_spre (usually 1\u00c2\u00a0Hz) clock is selected\n11x: ck_spre (usually 1\u00c2\u00a0Hz) clock is selected and 216\u00c2\u00a0is added to the WUT counter value",
                "width": 3
              },
              "TSEDGE": {
                "bit": 3,
                "description": "Timestamp event active edge\nTSE must be reset when TSEDGE is changed to avoid unwanted TSF setting."
              },
              "REFCKON": {
                "bit": 4,
                "description": "RTC_REFIN reference clock detection enable (50 or 60\u00c2\u00a0Hz)\nNote: PREDIV_S must be 0x00FF."
              },
              "BYPSHAD": {
                "bit": 5,
                "description": "Bypass the shadow registers\nNote: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1."
              },
              "FMT": {
                "bit": 6,
                "description": "Hour format"
              },
              "ALRAE": {
                "bit": 8,
                "description": "Alarm A enable"
              },
              "ALRBE": {
                "bit": 9,
                "description": "Alarm B enable"
              },
              "WUTE": {
                "bit": 10,
                "description": "Wakeup timer enable\nNote: When the wakeup timer is disabled, wait for WUTWF=1 before enabling it again."
              },
              "TSE": {
                "bit": 11,
                "description": "timestamp enable"
              },
              "ALRAIE": {
                "bit": 12,
                "description": "Alarm A interrupt enable"
              },
              "ALRBIE": {
                "bit": 13,
                "description": "Alarm B interrupt enable"
              },
              "WUTIE": {
                "bit": 14,
                "description": "Wakeup timer interrupt enable"
              },
              "TSIE": {
                "bit": 15,
                "description": "Timestamp interrupt enable"
              },
              "ADD1H": {
                "bit": 16,
                "description": "Add 1 hour (summer time change)\nWhen this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0."
              },
              "SUB1H": {
                "bit": 17,
                "description": "Subtract 1 hour (winter time change)\nWhen this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.\nSetting this bit has no effect when current hour is 0."
              },
              "BKP": {
                "bit": 18,
                "description": "Backup\nThis bit can be written by the user to memorize whether the daylight saving time change has been performed or not."
              },
              "COSEL": {
                "bit": 19,
                "description": "Calibration output selection\nWhen COE = 1, this bit selects which signal is output on CALIB.\nThese frequencies are valid for RTCCLK at 32.768\u00c2\u00a0kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to ."
              },
              "POL": {
                "bit": 20,
                "description": "Output polarity\nThis bit is used to configure the polarity of TAMPALRM output."
              },
              "OSEL": {
                "bit": 21,
                "description": "Output selection\nThese bits are used to select the flag to be routed to TAMPALRM output.",
                "width": 2
              },
              "COE": {
                "bit": 23,
                "description": "Calibration output enable\nThis bit enables the CALIB output"
              },
              "ITSE": {
                "bit": 24,
                "description": "timestamp on internal event enable"
              },
              "TAMPTS": {
                "bit": 25,
                "description": "Activate timestamp on tamper detection event\nTAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set after the tamper flags, therefore if TAMPTS and TSIE are set, it is recommended to disable the tamper interrupts in order to avoid servicing 2 interrupts."
              },
              "TAMPOE": {
                "bit": 26,
                "description": "Tamper detection output enable on TAMPALRM"
              },
              "TAMPALRM_PU": {
                "bit": 29,
                "description": "TAMPALRM pull-up enable"
              },
              "TAMPALRM_TYPE": {
                "bit": 30,
                "description": "TAMPALRM output type"
              },
              "OUT2EN": {
                "bit": 31,
                "description": "RTC_OUT2 output enable\nSetting this bit allows to remap the RTC outputs on RTC_OUT2 as follows:\nOUT2EN = 0: RTC output 2 disable\nIf OSEL \u00e2\u0089\u00a0 00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1\nIf OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1\nOUT2EN = 1: RTC output 2 enable\nIf (OSEL \u00e2\u0089\u00a0 00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2\nIf OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2\nIf (OSEL\u00e2\u0089\u00a0 00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1."
              }
            },
            "RTC_WPR": {
              "KEY": {
                "bit": 0,
                "description": "Write protection key\nThis byte is written by software.\nReading this byte always returns 0x00.\nRefer to  for a description of how to unlock RTC register write protection.",
                "width": 8
              }
            },
            "RTC_CALR": {
              "CALM": {
                "bit": 0,
                "description": "Calibration minus\nThe frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768\u00c2\u00a0Hz). This decreases the frequency of the calendar with a resolution of 0.9537\u00c2\u00a0ppm.\nTo increase the frequency of the calendar, this feature should be used in conjunction with CALP. See .",
                "width": 9
              },
              "CALW16": {
                "bit": 13,
                "description": "Use a 16-second calibration cycle period\nWhen CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.\nNote: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration."
              },
              "CALW8": {
                "bit": 14,
                "description": "Use an 8-second calibration cycle period\nWhen CALW8 is set to 1, the 8-second calibration cycle period is selected.\nNote: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration."
              },
              "CALP": {
                "bit": 15,
                "description": "Increase frequency of RTC by 488.5\u00c2\u00a0ppm\nThis feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768\u00c2\u00a0Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 \u00c3\u0097 CALP) - CALM.\nRefer to ."
              }
            },
            "RTC_SHIFTR": {
              "SUBFS": {
                "bit": 0,
                "description": "Subtract a fraction of a second\nThese bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThe value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by:\nDelay (seconds) = SUBFS / (PREDIV_S + 1)\nA fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by:\nAdvance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))).\nNote: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.",
                "width": 15
              },
              "ADD1S": {
                "bit": 31,
                "description": "Add one second\nThis bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThis function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation."
              }
            },
            "RTC_TSTR": {
              "SU": {
                "bit": 0,
                "description": "Second units in BCD format.",
                "width": 4
              },
              "ST": {
                "bit": 4,
                "description": "Second tens in BCD format.",
                "width": 3
              },
              "MNU": {
                "bit": 8,
                "description": "Minute units in BCD format.",
                "width": 4
              },
              "MNT": {
                "bit": 12,
                "description": "Minute tens in BCD format.",
                "width": 3
              },
              "HU": {
                "bit": 16,
                "description": "Hour units in BCD format.",
                "width": 4
              },
              "HT": {
                "bit": 20,
                "description": "Hour tens in BCD format.",
                "width": 2
              },
              "PM": {
                "bit": 22,
                "description": "AM/PM notation"
              }
            },
            "RTC_TSDR": {
              "DU": {
                "bit": 0,
                "description": "Date units in BCD format",
                "width": 4
              },
              "DT": {
                "bit": 4,
                "description": "Date tens in BCD format",
                "width": 2
              },
              "MU": {
                "bit": 8,
                "description": "Month units in BCD format",
                "width": 4
              },
              "MT": {
                "bit": 12,
                "description": "Month tens in BCD format"
              },
              "WDU": {
                "bit": 13,
                "description": "Week day units",
                "width": 3
              }
            },
            "RTC_TSSSR": {
              "SS": {
                "bit": 0,
                "description": "Sub second value\nSS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.",
                "width": 16
              }
            },
            "RTC_ALRMAR": {
              "SU": {
                "bit": 0,
                "description": "Second units in BCD format.",
                "width": 4
              },
              "ST": {
                "bit": 4,
                "description": "Second tens in BCD format.",
                "width": 3
              },
              "MSK1": {
                "bit": 7,
                "description": "Alarm A seconds mask"
              },
              "MNU": {
                "bit": 8,
                "description": "Minute units in BCD format",
                "width": 4
              },
              "MNT": {
                "bit": 12,
                "description": "Minute tens in BCD format",
                "width": 3
              },
              "MSK2": {
                "bit": 15,
                "description": "Alarm A minutes mask"
              },
              "HU": {
                "bit": 16,
                "description": "Hour units in BCD format",
                "width": 4
              },
              "HT": {
                "bit": 20,
                "description": "Hour tens in BCD format",
                "width": 2
              },
              "PM": {
                "bit": 22,
                "description": "AM/PM notation"
              },
              "MSK3": {
                "bit": 23,
                "description": "Alarm A hours mask"
              },
              "DU": {
                "bit": 24,
                "description": "Date units or day in BCD format",
                "width": 4
              },
              "DT": {
                "bit": 28,
                "description": "Date tens in BCD format",
                "width": 2
              },
              "WDSEL": {
                "bit": 30,
                "description": "Week day selection"
              },
              "MSK4": {
                "bit": 31,
                "description": "Alarm A date mask"
              }
            },
            "RTC_ALRMASSR": {
              "SS": {
                "bit": 0,
                "description": "Sub seconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.",
                "width": 15
              },
              "MASKSS": {
                "bit": 24,
                "description": "Mask the most-significant bits starting at this bit\n2:\tSS[14:2] are don't care in alarm A comparison. Only SS[1:0] are compared.\n3:\tSS[14:3] are don't care in alarm A comparison. Only SS[2:0] are compared.\n...\n12:\tSS[14:12] are don't care in alarm A comparison. SS[11:0] are compared.\n13:\tSS[14:13] are don't care in alarm A comparison. SS[12:0] are compared.\n14:\tSS[14] is don't care in alarm A comparison. SS[13:0] are compared.\n15:\tAll 15 SS bits are compared and must match to activate alarm.\nThe overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.\nNote: The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.",
                "width": 4
              }
            },
            "RTC_ALRMBR": {
              "SU": {
                "bit": 0,
                "description": "Second units in BCD format",
                "width": 4
              },
              "ST": {
                "bit": 4,
                "description": "Second tens in BCD format",
                "width": 3
              },
              "MSK1": {
                "bit": 7,
                "description": "Alarm B seconds mask"
              },
              "MNU": {
                "bit": 8,
                "description": "Minute units in BCD format",
                "width": 4
              },
              "MNT": {
                "bit": 12,
                "description": "Minute tens in BCD format",
                "width": 3
              },
              "MSK2": {
                "bit": 15,
                "description": "Alarm B minutes mask"
              },
              "HU": {
                "bit": 16,
                "description": "Hour units in BCD format",
                "width": 4
              },
              "HT": {
                "bit": 20,
                "description": "Hour tens in BCD format",
                "width": 2
              },
              "PM": {
                "bit": 22,
                "description": "AM/PM notation"
              },
              "MSK3": {
                "bit": 23,
                "description": "Alarm B hours mask"
              },
              "DU": {
                "bit": 24,
                "description": "Date units or day in BCD format",
                "width": 4
              },
              "DT": {
                "bit": 28,
                "description": "Date tens in BCD format",
                "width": 2
              },
              "WDSEL": {
                "bit": 30,
                "description": "Week day selection"
              },
              "MSK4": {
                "bit": 31,
                "description": "Alarm B date mask"
              }
            },
            "RTC_ALRMBSSR": {
              "SS": {
                "bit": 0,
                "description": "Sub seconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.",
                "width": 15
              },
              "MASKSS": {
                "bit": 24,
                "description": "Mask the most-significant bits starting at this bit\n...\nThe overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.",
                "width": 4
              }
            },
            "RTC_SR": {
              "ALRAF": {
                "bit": 0,
                "description": "Alarm A flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR)."
              },
              "ALRBF": {
                "bit": 1,
                "description": "Alarm B flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR)."
              },
              "WUTF": {
                "bit": 2,
                "description": "Wakeup timer flag\nThis flag is set by hardware when the wakeup auto-reload counter reaches 0.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
              },
              "TSF": {
                "bit": 3,
                "description": "Timestamp flag\nThis flag is set by hardware when a timestamp event occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF."
              },
              "TSOVF": {
                "bit": 4,
                "description": "Timestamp overflow flag\nThis flag is set by hardware when a timestamp event occurs while TSF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
              },
              "ITSF": {
                "bit": 5,
                "description": "Internal timestamp flag\nThis flag is set by hardware when a timestamp on the internal event occurs."
              }
            },
            "RTC_MISR": {
              "ALRAMF": {
                "bit": 0,
                "description": "Alarm A masked flag\nThis flag is set by hardware when the alarm A interrupt occurs."
              },
              "ALRBMF": {
                "bit": 1,
                "description": "Alarm B masked flag\nThis flag is set by hardware when the alarm B interrupt occurs."
              },
              "WUTMF": {
                "bit": 2,
                "description": "Wakeup timer masked flag\nThis flag is set by hardware when the wakeup timer interrupt occurs.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
              },
              "TSMF": {
                "bit": 3,
                "description": "Timestamp masked flag\nThis flag is set by hardware when a timestamp interrupt occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF."
              },
              "TSOVMF": {
                "bit": 4,
                "description": "Timestamp overflow masked flag\nThis flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
              },
              "ITSMF": {
                "bit": 5,
                "description": "Internal timestamp masked flag\nThis flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised."
              }
            },
            "RTC_SCR": {
              "CALRAF": {
                "bit": 0,
                "description": "Clear alarm A flag\nWriting 1 in this bit clears the ALRBF bit in the RTC_SR register."
              },
              "CALRBF": {
                "bit": 1,
                "description": "Clear alarm B flag\nWriting 1 in this bit clears the ALRBF bit in the RTC_SR register."
              },
              "CWUTF": {
                "bit": 2,
                "description": "Clear wakeup timer flag\nWriting 1 in this bit clears the WUTF bit in the RTC_SR register."
              },
              "CTSF": {
                "bit": 3,
                "description": "Clear timestamp flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIf ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF."
              },
              "CTSOVF": {
                "bit": 4,
                "description": "Clear timestamp overflow flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
              },
              "CITSF": {
                "bit": 5,
                "description": "Clear internal timestamp flag\nWriting 1 in this bit clears the ITSF bit in the RTC_SR register."
              }
            }
          }
        },
        "SPI": {
          "instances": [
            {
              "name": "SPI1",
              "base": "0x40013000",
              "irq": 25
            },
            {
              "name": "SPI2",
              "base": "0x40003800",
              "irq": 26
            }
          ],
          "registers": {
            "SPI_CR1": {
              "offset": "0x00",
              "size": 16,
              "description": "SPI control register 1"
            },
            "SPI_CR2": {
              "offset": "0x04",
              "size": 16,
              "description": "SPI control register 2"
            },
            "SPI_SR": {
              "offset": "0x08",
              "size": 16,
              "description": "SPI status register"
            },
            "SPI_DR": {
              "offset": "0x0C",
              "size": 16,
              "description": "SPI data register"
            },
            "SPI_CRCPR": {
              "offset": "0x10",
              "size": 16,
              "description": "SPI CRC polynomial register"
            },
            "SPI_RXCRCR": {
              "offset": "0x14",
              "size": 16,
              "description": "SPI Rx CRC register"
            },
            "SPI_TXCRCR": {
              "offset": "0x18",
              "size": 16,
              "description": "SPI Tx CRC register"
            },
            "SPI_I2SCFGR": {
              "offset": "0x1C",
              "size": 16,
              "description": "SPI_I2S configuration register"
            },
            "SPI_I2SPR": {
              "offset": "0x20",
              "size": 16,
              "description": "SPI_I2S prescaler register"
            }
          },
          "bits": {
            "SPI_CR1": {
              "CPHA": {
                "bit": 0,
                "description": "Clock phase\nNote: This bit should not be changed when communication is ongoing.\nThis bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode."
              },
              "CPOL": {
                "bit": 1,
                "description": "Clock polarity\nNote: This bit should not be changed when communication is ongoing.\nThis bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode."
              },
              "MSTR": {
                "bit": 2,
                "description": "Master selection\nNote: This bit should not be changed when communication is ongoing.\nThis bit is not used in I2S mode."
              },
              "BR": {
                "bit": 3,
                "description": "Baud rate control\nNote: These bits should not be changed when communication is ongoing.\nThese bits are not used in I2S mode.",
                "width": 3
              },
              "SPE": {
                "bit": 6,
                "description": "SPI enable\nNote: When disabling the SPI, follow the procedure described in SPI on page\u00c2\u00a01021.\nThis bit is not used in I2S mode."
              },
              "LSBFIRST": {
                "bit": 7,
                "description": "Frame format\nNote: 1. This bit should not be changed when communication is ongoing.\n2. This bit is not used in I2S mode and SPI TI mode."
              },
              "SSI": {
                "bit": 8,
                "description": "Internal slave select\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored.\nNote: This bit is not used in I2S mode and SPI TI mode."
              },
              "SSM": {
                "bit": 9,
                "description": "Software slave management\nWhen the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.\nNote: This bit is not used in I2S mode and SPI TI mode."
              },
              "RXONLY": {
                "bit": 10,
                "description": "Receive only mode enabled.\nThis bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted.\nNote: This bit is not used in I2S mode."
              },
              "CRCL": {
                "bit": 11,
                "description": "CRC length\nThis bit is set and cleared by software to select the CRC length.\nNote: This bit should be written only when SPI is disabled (SPE = '0\u00e2\u0080\u0099) for correct operation.\nThis bit is not used in I2S mode."
              },
              "CRCNEXT": {
                "bit": 12,
                "description": "Transmit CRC next\nNote: This bit has to be written as soon as the last data is written in the SPI_DR register.\nThis bit is not used in I2S mode."
              },
              "CRCEN": {
                "bit": 13,
                "description": "Hardware CRC calculation enable\nNote: This bit should be written only when SPI is disabled (SPE = '0\u00e2\u0080\u0099) for correct operation.\nThis bit is not used in I2S mode."
              },
              "BIDIOE": {
                "bit": 14,
                "description": "Output enable in bidirectional mode\nThis bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode.\nNote: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used.\nThis bit is not used in I2S mode."
              },
              "BIDIMODE": {
                "bit": 15,
                "description": "Bidirectional data mode enable.\nThis bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active.\nNote: This bit is not used in I2S mode."
              }
            },
            "SPI_CR2": {
              "RXDMAEN": {
                "bit": 0,
                "description": "Rx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the RXNE flag is set."
              },
              "TXDMAEN": {
                "bit": 1,
                "description": "Tx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the TXE flag is set."
              },
              "SSOE": {
                "bit": 2,
                "description": "SS output enable\nNote: This bit is not used in I2S mode and SPI TI mode."
              },
              "NSSP": {
                "bit": 3,
                "description": "NSS pulse management\nThis bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer.\nIt has no meaning if CPHA = \u00e2\u0080\u00991\u00e2\u0080\u0099, or FRF = \u00e2\u0080\u00991\u00e2\u0080\u0099.\nNote: 1. This bit must be written only when the SPI is disabled (SPE=0).\n2. This bit is not used in I2S mode and SPI TI mode."
              },
              "FRF": {
                "bit": 4,
                "description": "Frame format\n1 SPI TI mode\nNote: This bit must be written only when the SPI is disabled (SPE=0).\nThis bit is not used in I2S mode."
              },
              "ERRIE": {
                "bit": 5,
                "description": "Error interrupt enable\nThis bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode and UDR, OVR, and FRE in I2S mode)."
              },
              "RXNEIE": {
                "bit": 6,
                "description": "RX buffer not empty interrupt enable"
              },
              "TXEIE": {
                "bit": 7,
                "description": "Tx buffer empty interrupt enable"
              },
              "DS": {
                "bit": 8,
                "description": "Data size\nThese bits configure the data length for SPI transfers.\nIf software attempts to write one of the \u00e2\u0080\u009cNot used\u00e2\u0080\u009d values, they are forced to the value \u00e2\u0080\u009c0111\u00e2\u0080\u009d\n(8-bit)\nNote: These bits are not used in I2S mode.",
                "width": 4
              },
              "FRXTH": {
                "bit": 12,
                "description": "FIFO reception threshold\nThis bit is used to set the threshold of the RXFIFO that triggers an RXNE event\nNote: This bit is not used in I2S mode."
              },
              "LDMA_RX": {
                "bit": 13,
                "description": "Last DMA transfer for reception\nThis bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register).\nNote: Refer to  if the CRCEN bit is set.\nThis bit is not used in I\u00c2\u00b2S mode."
              },
              "LDMA_TX": {
                "bit": 14,
                "description": "Last DMA transfer for transmission\nThis bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register).\nNote: Refer to  if the CRCEN bit is set.\nThis bit is not used in I\u00c2\u00b2S mode."
              }
            },
            "SPI_SR": {
              "RXNE": {
                "bit": 0,
                "description": "Receive buffer not empty"
              },
              "TXE": {
                "bit": 1,
                "description": "Transmit buffer empty"
              },
              "CHSIDE": {
                "bit": 2,
                "description": "Channel side\nNote: This bit is not used in SPI mode. It has no significance in PCM mode."
              },
              "UDR": {
                "bit": 3,
                "description": "Underrun flag\nThis flag is set by hardware and reset by a software sequence. Refer to page\u00c2\u00a01057 for the software sequence.\nNote: This bit is not used in SPI mode."
              },
              "CRCERR": {
                "bit": 4,
                "description": "CRC error flag\nNote: This flag is set by hardware and cleared by software writing 0.\nThis bit is not used in I2S mode."
              },
              "MODF": {
                "bit": 5,
                "description": "Mode fault\nThis flag is set by hardware and reset by a software sequence. Refer to (MODF) on page\u00c2\u00a01031 for the software sequence.\nNote: This bit is not used in I2S mode."
              },
              "OVR": {
                "bit": 6,
                "description": "Overrun flag\nThis flag is set by hardware and reset by a software sequence. Refer to page\u00c2\u00a01057 for the software sequence."
              },
              "BSY": {
                "bit": 7,
                "description": "Busy flag\nThis flag is set and cleared by hardware.\nNote: The BSY flag must be used with caution: refer to  and ."
              },
              "FRE": {
                "bit": 8,
                "description": "Frame format error\nThis flag is used for SPI in TI slave mode and I2S slave mode. Refer to error flags and .\nThis flag is set by hardware and reset when SPI_SR is read by software."
              },
              "FRLVL": {
                "bit": 9,
                "description": "FIFO reception level\nThese bits are set and cleared by hardware.\nNote: These bits are not used in I\u00c2\u00b2S mode and in SPI receive-only mode while CRC calculation is enabled.",
                "width": 2
              },
              "FTLVL": {
                "bit": 11,
                "description": "FIFO transmission level\nThese bits are set and cleared by hardware.\nNote: This bit is not used in I2S mode.",
                "width": 2
              }
            },
            "SPI_DR": {
              "DR": {
                "bit": 0,
                "description": "Data register\nData received or to be transmitted\nThe data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See ).\nNote: Data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. The Rx threshold setting must always correspond with the read access currently used.",
                "width": 16
              }
            },
            "SPI_CRCPR": {
              "CRCPOLY": {
                "bit": 0,
                "description": "CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required.",
                "width": 16
              }
            },
            "SPI_RXCRCR": {
              "RXCRC": {
                "bit": 0,
                "description": "Rx CRC register\nWhen CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.\nOnly the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.\nThe entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.\nNote: A read to this register when the BSY Flag is set could return an incorrect value.\nThese bits are not used in I2S mode.",
                "width": 16
              }
            },
            "SPI_TXCRCR": {
              "TXCRC": {
                "bit": 0,
                "description": "Tx CRC register\nWhen CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPI_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.\nOnly the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.\nThe entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.\nNote: A read to this register when the BSY flag is set could return an incorrect value.\nThese bits are not used in I2S mode.",
                "width": 16
              }
            },
            "SPI_I2SCFGR": {
              "CHLEN": {
                "bit": 0,
                "description": "Channel length (number of bits per audio channel)\nThe bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.\nNote: For correct operation, this bit should be configured when the I2S is disabled.\nIt is not used in SPI mode."
              },
              "DATLEN": {
                "bit": 1,
                "description": "Data length to be transferred\nNote: For correct operation, these bits should be configured when the I2S is disabled.\nThey are not used in SPI mode.",
                "width": 2
              },
              "CKPOL": {
                "bit": 3,
                "description": "Inactive state clock polarity\nNote: For correct operation, this bit should be configured when the I2S is disabled.\nIt is not used in SPI mode.\nThe bit CKPOL does not affect the CK edge sensitivity used to receive or transmit the SD and WS signals."
              },
              "I2SSTD": {
                "bit": 4,
                "description": "I2S standard selection\nFor more details on I2S standards, refer to\nNote: For correct operation, these bits should be configured when the I2S is disabled.\nThey are not used in SPI mode.",
                "width": 2
              },
              "PCMSYNC": {
                "bit": 7,
                "description": "PCM frame synchronization\nNote: This bit has a meaning only if I2SSTD = 11 (PCM standard is used).\nIt is not used in SPI mode."
              },
              "I2SCFG": {
                "bit": 8,
                "description": "I2S configuration mode\nNote: These bits should be configured when the I2S is disabled.\nThey are not used in SPI mode.",
                "width": 2
              },
              "I2SE": {
                "bit": 10,
                "description": "I2S enable\nNote: This bit is not used in SPI mode."
              },
              "I2SMOD": {
                "bit": 11,
                "description": "I2S mode selection\nNote: This bit should be configured when the SPI is disabled."
              },
              "ASTRTEN": {
                "bit": 12,
                "description": "Asynchronous start enable.\nWhen the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and an appropriate transition is detected on the WS signal.\nWhen the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and the appropriate level is detected on the WS signal.\nNote: The appropriate transition is a falling edge on WS signal when I2S Philips Standard is used, or a rising edge for other standards.\nThe appropriate level is a low level on WS signal when I2S Philips Standard is used, or a high level for other standards.\nPlease refer to  for additional information."
              }
            },
            "SPI_I2SPR": {
              "I2SDIV": {
                "bit": 0,
                "description": "I2S linear prescaler\nI2SDIV [7:0] = 0 or I2SDIV [7:0] = 1 are forbidden values.\nRefer to .\nNote: These bits should be configured when the I2S is disabled. They are used only when the I2S is in master mode.\nThey are not used in SPI mode.",
                "width": 8
              },
              "ODD": {
                "bit": 8,
                "description": "Odd factor for the prescaler\nRefer to .\nNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.\nIt is not used in SPI mode."
              },
              "MCKOE": {
                "bit": 9,
                "description": "Master clock output enable\nNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.\nIt is not used in SPI mode."
              }
            }
          }
        },
        "TAMP": {
          "instances": [
            {
              "name": "TAMP",
              "base": "0x4000B000"
            }
          ],
          "registers": {
            "TAMP_CR1": {
              "offset": "0x00",
              "size": 32,
              "description": "TAMP control register 1"
            },
            "TAMP_CR2": {
              "offset": "0x04",
              "size": 32,
              "description": "TAMP control register 2"
            },
            "TAMP_FLTCR": {
              "offset": "0x0C",
              "size": 32,
              "description": "TAMP filter control register"
            },
            "TAMP_IER": {
              "offset": "0x2C",
              "size": 32,
              "description": "TAMP interrupt enable register"
            },
            "TAMP_SR": {
              "offset": "0x30",
              "size": 32,
              "description": "TAMP status register"
            },
            "TAMP_MISR": {
              "offset": "0x34",
              "size": 32,
              "description": "TAMP masked interrupt status register"
            },
            "TAMP_SCR": {
              "offset": "0x3C",
              "size": 32,
              "description": "TAMP status clear register"
            },
            "TAMP_BKP0R": {
              "offset": "0x100",
              "size": 32,
              "description": "TAMP backup 0 register"
            },
            "TAMP_BKP1R": {
              "offset": "0x104",
              "size": 32,
              "description": "TAMP backup 1 register"
            },
            "TAMP_BKP2R": {
              "offset": "0x108",
              "size": 32,
              "description": "TAMP backup 2 register"
            },
            "TAMP_BKP3R": {
              "offset": "0x10C",
              "size": 32,
              "description": "TAMP backup 3 register"
            },
            "TAMP_BKP4R": {
              "offset": "0x110",
              "size": 32,
              "description": "TAMP backup 4 register"
            }
          },
          "bits": {
            "TAMP_CR1": {
              "TAMP1E": {
                "bit": 0,
                "description": "Tamper detection on TAMP_IN1 enable"
              },
              "TAMP2E": {
                "bit": 1,
                "description": "Tamper detection on TAMP_IN2 enable"
              },
              "ITAMP3E": {
                "bit": 18,
                "description": "Internal tamper 3 enable: LSE monitoring"
              },
              "ITAMP4E": {
                "bit": 19,
                "description": "Internal tamper 4 enable: HSE monitoring"
              },
              "ITAMP5E": {
                "bit": 20,
                "description": "Internal tamper 5 enable: RTC calendar overflow"
              },
              "ITAMP6E": {
                "bit": 21,
                "description": "Internal tamper 6 enable: ST manufacturer readout"
              }
            },
            "TAMP_CR2": {
              "TAMP1NOER": {
                "bit": 0,
                "description": "Tamper 1 no erase"
              },
              "TAMP2NOER": {
                "bit": 1,
                "description": "Tamper 2 no erase"
              },
              "TAMP1MSK": {
                "bit": 16,
                "description": "Tamper 1 mask\nThe tamper 1 interrupt must not be enabled when TAMP1MSK is set."
              },
              "TAMP2MSK": {
                "bit": 17,
                "description": "Tamper 2 mask\nThe tamper 2 interrupt must not be enabled when TAMP2MSK is set."
              },
              "TAMP1TRG": {
                "bit": 24,
                "description": "Active level for tamper 1 input (active mode disabled)\nIf TAMPFLT = 00 Tamper 1 input rising edge and high level triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 1 input falling edge and low level triggers a tamper detection event."
              },
              "TAMP2TRG": {
                "bit": 25,
                "description": "Active level for tamper 2 input (active mode disabled)\nIf TAMPFLT = 00 Tamper 2 input rising edge and high level triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 2 input falling edge and low level triggers a tamper detection event."
              }
            },
            "TAMP_FLTCR": {
              "TAMPFREQ": {
                "bit": 0,
                "description": "Tamper sampling frequency\nDetermines the frequency at which each of the TAMP_INx inputs are sampled.",
                "width": 3
              },
              "TAMPFLT": {
                "bit": 3,
                "description": "TAMP_INx filter count\nThese bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.",
                "width": 2
              },
              "TAMPPRCH": {
                "bit": 5,
                "description": "TAMP_INx precharge duration\nThese bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.",
                "width": 2
              },
              "TAMPPUDIS": {
                "bit": 7,
                "description": "TAMP_INx pull-up disable\nThis bit determines if each of the TAMPx pins are precharged before each sample."
              }
            },
            "TAMP_IER": {
              "TAMP1IE": {
                "bit": 0,
                "description": "Tamper 1 interrupt enable"
              },
              "TAMP2IE": {
                "bit": 1,
                "description": "Tamper 2 interrupt enable"
              },
              "ITAMP3IE": {
                "bit": 18,
                "description": "Internal tamper 3 interrupt enable: LSE monitoring"
              },
              "ITAMP4IE": {
                "bit": 19,
                "description": "Internal tamper 4 interrupt enable: HSE monitoring"
              },
              "ITAMP5IE": {
                "bit": 20,
                "description": "Internal tamper 5 interrupt enable: RTC calendar overflow"
              },
              "ITAMP6IE": {
                "bit": 21,
                "description": "Internal tamper 6 interrupt enable: ST manufacturer readout"
              }
            },
            "TAMP_SR": {
              "TAMP1F": {
                "bit": 0,
                "description": "TAMP1 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP1 input."
              },
              "TAMP2F": {
                "bit": 1,
                "description": "TAMP2 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP2 input."
              },
              "ITAMP3F": {
                "bit": 18,
                "description": "LSE monitoring tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 3."
              },
              "ITAMP4F": {
                "bit": 19,
                "description": "HSE monitoring tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 4."
              },
              "ITAMP5F": {
                "bit": 20,
                "description": "RTC calendar overflow tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 5."
              },
              "ITAMP6F": {
                "bit": 21,
                "description": "ST manufacturer readout tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 6."
              }
            },
            "TAMP_MISR": {
              "TAMP1MF": {
                "bit": 0,
                "description": "TAMP1 interrupt masked flag\nThis flag is set by hardware when the tamper 1 interrupt is raised."
              },
              "TAMP2MF": {
                "bit": 1,
                "description": "TAMP2 interrupt masked flag\nThis flag is set by hardware when the tamper 2 interrupt is raised."
              },
              "ITAMP3MF": {
                "bit": 18,
                "description": "LSE monitoring tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 3 interrupt is raised."
              },
              "ITAMP4MF": {
                "bit": 19,
                "description": "HSE monitoring tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 4 interrupt is raised."
              },
              "ITAMP5MF": {
                "bit": 20,
                "description": "RTC calendar overflow tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 5 interrupt is raised."
              },
              "ITAMP6MF": {
                "bit": 21,
                "description": "ST manufacturer readout tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 6 interrupt is raised."
              }
            },
            "TAMP_SCR": {
              "CTAMP1F": {
                "bit": 0,
                "description": "Clear TAMP1 detection flag\nWriting 1 in this bit clears the TAMP1F bit in the TAMP_SR register."
              },
              "CTAMP2F": {
                "bit": 1,
                "description": "Clear TAMP2 detection flag\nWriting 1 in this bit clears the TAMP2F bit in the TAMP_SR register."
              },
              "CITAMP3F": {
                "bit": 18,
                "description": "Clear ITAMP3 detection flag\nWriting 1 in this bit clears the ITAMP3F bit in the TAMP_SR register."
              },
              "CITAMP4F": {
                "bit": 19,
                "description": "Clear ITAMP4 detection flag\nWriting 1 in this bit clears the ITAMP4F bit in the TAMP_SR register."
              },
              "CITAMP5F": {
                "bit": 20,
                "description": "Clear ITAMP5 detection flag\nWriting 1 in this bit clears the ITAMP5F bit in the TAMP_SR register."
              },
              "CITAMP6F": {
                "bit": 21,
                "description": "Clear ITAMP6 detection flag\nWriting 1 in this bit clears the ITAMP6F bit in the TAMP_SR register."
              }
            },
            "TAMP_BKP0R": {
              "BKP": {
                "bit": 0,
                "description": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.",
                "width": 32
              }
            },
            "TAMP_BKP1R": {
              "BKP": {
                "bit": 0,
                "description": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.",
                "width": 32
              }
            },
            "TAMP_BKP2R": {
              "BKP": {
                "bit": 0,
                "description": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.",
                "width": 32
              }
            },
            "TAMP_BKP3R": {
              "BKP": {
                "bit": 0,
                "description": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.",
                "width": 32
              }
            },
            "TAMP_BKP4R": {
              "BKP": {
                "bit": 0,
                "description": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled.",
                "width": 32
              }
            }
          }
        },
        "VREFBUF": {
          "instances": [
            {
              "name": "VREFBUF",
              "base": "0x40010030"
            }
          ],
          "registers": {
            "VREFBUF_CSR": {
              "offset": "0x00",
              "size": 32,
              "description": "VREFBUF control and status\n          register"
            },
            "VREFBUF_CCR": {
              "offset": "0x04",
              "size": 32,
              "description": "VREFBUF calibration control\n          register"
            }
          },
          "bits": {
            "VREFBUF_CSR": {
              "ENVR": {
                "bit": 0,
                "description": "Voltage reference buffer mode enable\nThis bit is used to enable the voltage reference buffer mode."
              },
              "HIZ": {
                "bit": 1,
                "description": "High impedance mode\nThis bit controls the analog switch to connect or not the VREF+ pin.\nRefer to  for the mode descriptions depending on ENVR bit configuration."
              },
              "VRS": {
                "bit": 2,
                "description": "Voltage reference scale\nThis bit selects the value generated by the voltage reference buffer."
              },
              "VRR": {
                "bit": 3,
                "description": "Voltage reference buffer ready"
              }
            },
            "VREFBUF_CCR": {
              "TRIM": {
                "bit": 0,
                "description": "Trimming code\nThese bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows the tuning of the internal reference buffer voltage.",
                "width": 6
              }
            }
          }
        }
      },
      "interrupts": {
        "count": 47,
        "vectors": [
          {
            "number": 0,
            "name": "Initial_SP"
          },
          {
            "number": 1,
            "name": "Reset_Handler"
          },
          {
            "number": 2,
            "name": "NMI_Handler"
          },
          {
            "number": 3,
            "name": "HardFault_Handler"
          },
          {
            "number": 4,
            "name": "MemManage_Handler"
          },
          {
            "number": 5,
            "name": "BusFault_Handler"
          },
          {
            "number": 6,
            "name": "UsageFault_Handler"
          },
          {
            "number": 11,
            "name": "SVC_Handler"
          },
          {
            "number": 12,
            "name": "DebugMon_Handler"
          },
          {
            "number": 14,
            "name": "PendSV_Handler"
          },
          {
            "number": 15,
            "name": "SysTick_Handler"
          },
          {
            "number": 16,
            "name": "WWDG_IRQHandler"
          },
          {
            "number": 18,
            "name": "RTC_TAMP_IRQHandler"
          },
          {
            "number": 19,
            "name": "FLASH_IRQHandler"
          },
          {
            "number": 25,
            "name": "DMA1_Channel1_IRQHandler"
          },
          {
            "number": 26,
            "name": "DMA1_Channel2_3_IRQHandler"
          },
          {
            "number": 27,
            "name": "DMA1_Channel4_5_6_7_DMAMUX_IRQHandler"
          },
          {
            "number": 28,
            "name": "ADC_COMP_IRQHandler"
          },
          {
            "number": 29,
            "name": "TIM1_BRK_UP_TRG_COM_IRQHandler"
          },
          {
            "number": 30,
            "name": "TIM1_CC_IRQHandler"
          },
          {
            "number": 31,
            "name": "TIM2_IRQHandler"
          },
          {
            "number": 32,
            "name": "TIM3_IRQHandler"
          },
          {
            "number": 33,
            "name": "TIM6_DAC_LPTIM1_IRQHandler"
          },
          {
            "number": 34,
            "name": "TIM7_IRQHandler"
          },
          {
            "number": 35,
            "name": "TIM14_IRQHandler"
          },
          {
            "number": 36,
            "name": "TIM15_IRQHandler"
          },
          {
            "number": 37,
            "name": "TIM16_IRQHandler"
          },
          {
            "number": 38,
            "name": "TIM17_IRQHandler"
          },
          {
            "number": 39,
            "name": "I2C1_IRQHandler"
          },
          {
            "number": 40,
            "name": "I2C2_IRQHandler"
          },
          {
            "number": 41,
            "name": "SPI1_IRQHandler"
          },
          {
            "number": 42,
            "name": "SPI2_SPI3_IRQHandler"
          },
          {
            "number": 43,
            "name": "USART1_IRQHandler"
          },
          {
            "number": 44,
            "name": "USART2_IRQHandler"
          },
          {
            "number": 46,
            "name": "CEC_IRQHandler"
          }
        ]
      }
    }
  }
}