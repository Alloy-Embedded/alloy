# Template Customization Guide

The Alloy code generator uses Jinja2 templates to generate C++ code. This guide shows how to customize templates or create new ones.

## Template Directory Structure

```
tools/codegen/templates/
├── common/
│   ├── header.j2           # Common file header
│   └── macros.j2           # Reusable macros (future)
└── startup/
    └── cortex_m_startup.cpp.j2  # ARM Cortex-M startup code
```

## Basic Template Syntax

Jinja2 uses:
- `{{ variable }}` - Variable substitution
- `{% for ... %}` - Loops
- `{% if ... %}` - Conditionals
- `{# comment #}` - Comments

## Available Context Variables

When rendering templates, the generator provides these variables:

| Variable | Type | Description | Example |
|----------|------|-------------|---------|
| `mcu_name` | string | Target MCU name | `"STM32F103C8"` |
| `source_file` | string | Database filename | `"stm32f1xx.json"` |
| `timestamp` | string | Generation timestamp | `"2025-10-30 21:15:03"` |
| `mcu` | dict | Complete MCU configuration | See below |
| `interrupts` | dict | Interrupt vectors | `mcu.interrupts` |
| `architecture` | string | CPU architecture | `"arm-cortex-m3"` |

### `mcu` Dictionary Structure

```python
{
  "flash": {
    "size_kb": 64,
    "base_address": "0x08000000"
  },
  "ram": {
    "size_kb": 20,
    "base_address": "0x20000000"
  },
  "peripherals": {
    "GPIO": {
      "instances": [...],
      "registers": {...}
    }
  },
  "interrupts": {
    "count": 68,
    "vectors": [...]
  }
}
```

## Custom Jinja2 Filters

### `hex` Filter

Converts integers to hex format:

```jinja2
{{ 255 | hex }}
{# Output: 0x000000FF #}

{{ mcu.flash.base_address | hex }}
{# Already a string "0x08000000", passes through #}
```

**Implementation:**
```python
def hex_filter(value):
    if isinstance(value, int):
        return f"0x{value:08X}"
    return value

jinja_env.filters['hex'] = hex_filter
```

## Existing Templates

### 1. Header Template (`common/header.j2`)

**Purpose:** Standard file header for generated code.

**Template:**
```jinja2
/// Auto-generated code for {{ mcu_name }}
/// Generated by Alloy Code Generator
/// Source: {{ source_file }}
/// DO NOT EDIT - Changes will be overwritten
///
/// Generated: {{ timestamp }}
```

**Usage:**
```jinja2
{% include 'common/header.j2' %}

// Your code here
```

### 2. Startup Template (`startup/cortex_m_startup.cpp.j2`)

**Purpose:** ARM Cortex-M startup code with vector table.

**Key sections:**

#### Includes
```jinja2
#include <cstdint>
#include <cstring>
```

#### Reset Handler
```jinja2
extern "C" [[noreturn]] void Reset_Handler() {
    // 1. Copy .data section from Flash to RAM
    uint32_t* src = &_sidata;
    uint32_t* dest = &_sdata;
    while (dest < &_edata) {
        *dest++ = *src++;
    }

    // 2. Zero out .bss section
    dest = &_sbss;
    while (dest < &_ebss) {
        *dest++ = 0;
    }

    // 3. Call system initialization
    SystemInit();

    // 4. Call static constructors
    extern void (*__init_array_start[])();
    extern void (*__init_array_end[])();
    for (auto ctor = __init_array_start; ctor < __init_array_end; ++ctor) {
        (*ctor)();
    }

    // 5. Call main
    main();

    // 6. If main returns, loop forever
    while (true) {
        __asm__ volatile("wfi");
    }
}
```

#### Interrupt Handlers
```jinja2
// Device-specific interrupt handlers
{% for vector in interrupts.vectors %}
{% if vector.number >= 16 %}
void {{ vector.name }}() __attribute__((weak, alias("Default_Handler")));
{% endif %}
{% endfor %}
```

## Creating Custom Templates

### Example: Register Definitions Template

Let's create a template for peripheral register definitions.

**`templates/peripherals/registers.h.j2`:**
```jinja2
{% include 'common/header.j2' %}

#ifndef {{ mcu_name | upper }}_REGISTERS_H
#define {{ mcu_name | upper }}_REGISTERS_H

#include <cstdint>

{% for periph_type, periph in mcu.peripherals.items() %}
// {{ periph_type }} Peripheral
{% for instance in periph.instances %}
#define {{ instance.name }}_BASE    {{ instance.base }}
{% endfor %}

// {{ periph_type }} Registers
typedef struct {
{% for reg_name, reg in periph.registers.items() %}
    volatile uint32_t {{ reg_name }};  // {{ reg.description }}
{% endfor %}
} {{ periph_type }}_TypeDef;

{% for instance in periph.instances %}
#define {{ instance.name }}    (({{ periph_type }}_TypeDef*){{ instance.base }})
{% endfor %}

{% endfor %}

#endif // {{ mcu_name | upper }}_REGISTERS_H
```

**Add to generator (`generator.py`):**
```python
def generate_registers(self):
    """Generate register definitions header"""
    if self.verbose:
        print_info("Generating register definitions...")

    context = {
        'mcu_name': self.mcu_name,
        'source_file': str(self.database_path.name),
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'mcu': self.mcu
    }

    content = self._render_template('peripherals/registers.h.j2', context)
    self._write_file('registers.h', content)
```

**Call in `generate_all()`:**
```python
def generate_all(self):
    print_info(f"Generating code for {self.mcu_name}...")

    self.generate_startup()
    self.generate_registers()  # Add this

    print_success(f"Code generation complete in {self.output_dir}")
```

### Example: Linker Script Template

**`templates/linker/cortex_m.ld.j2`:**
```jinja2
{# Linker script for ARM Cortex-M #}
MEMORY
{
    FLASH (rx)  : ORIGIN = {{ mcu.flash.base_address }}, LENGTH = {{ mcu.flash.size_kb }}K
    RAM (rwx)   : ORIGIN = {{ mcu.ram.base_address }}, LENGTH = {{ mcu.ram.size_kb }}K
}

ENTRY(Reset_Handler)

SECTIONS
{
    .text :
    {
        KEEP(*(.isr_vector))
        *(.text*)
        *(.rodata*)
        . = ALIGN(4);
        _sidata = LOADADDR(.data);
    } > FLASH

    .data :
    {
        . = ALIGN(4);
        _sdata = .;
        *(.data*)
        . = ALIGN(4);
        _edata = .;
    } > RAM AT> FLASH

    .bss :
    {
        . = ALIGN(4);
        _sbss = .;
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        _ebss = .;
    } > RAM

    /DISCARD/ :
    {
        libc.a ( * )
        libm.a ( * )
        libgcc.a ( * )
    }
}
```

## Template Best Practices

### 1. Use Includes for Common Code

✅ **Good:**
```jinja2
{% include 'common/header.j2' %}

{% include 'common/macros.j2' %}
```

❌ **Bad:**
```jinja2
/// Auto-generated code for {{ mcu_name }}
/// Generated by Alloy Code Generator
{# Duplicated in every template #}
```

### 2. Add Comments

```jinja2
{# This loop generates interrupt handlers for all device-specific IRQs #}
{% for vector in interrupts.vectors %}
{% if vector.number >= 16 %}
    void {{ vector.name }}() __attribute__((weak, alias("Default_Handler")));
{% endif %}
{% endfor %}
```

### 3. Handle Missing Data

```jinja2
{% if mcu.clock is defined %}
#define SYSTEM_CLOCK_HZ {{ mcu.clock.max_freq_mhz * 1000000 }}
{% else %}
// Clock configuration not available
{% endif %}
```

### 4. Use Whitespace Control

```jinja2
{# Remove extra blank lines #}
{% for vector in interrupts.vectors -%}
void {{ vector.name }}();
{% endfor -%}
```

### 5. Format Output Nicely

```jinja2
{# Align definitions #}
{% for instance in periph.instances %}
#define {{ "%-20s" | format(instance.name + "_BASE") }} {{ instance.base }}
{% endfor %}
```

**Output:**
```c
#define GPIOA_BASE           0x40010800
#define GPIOB_BASE           0x40010C00
```

## Testing Templates

### Manual Test

```bash
python3 generator.py \
    --mcu STM32F103C8 \
    --database database/families/stm32f1xx.json \
    --output /tmp/test_templates \
    --verbose
```

### Automated Test

Add to `tests/test_generator.py`:

```python
def test_new_template_generation(self, example_database_file, temp_dir):
    """Test new template generates correctly"""
    generator = CodeGenerator(
        database_path=example_database_file,
        mcu_name="TEST_MCU",
        output_dir=temp_dir
    )

    generator.generate_registers()  # Your new method

    # Verify file exists
    assert (temp_dir / "registers.h").exists()

    # Verify content
    content = (temp_dir / "registers.h").read_text()
    assert "GPIOA_BASE" in content
    assert "#ifndef TEST_MCU_REGISTERS_H" in content
```

## Advanced Techniques

### Conditional Generation Based on Architecture

```jinja2
{% if architecture == "arm-cortex-m3" %}
    // Cortex-M3 specific code
    __asm__ volatile("wfi");
{% elif architecture == "arm-cortex-m4" %}
    // Cortex-M4 specific code
    __asm__ volatile("wfe");
{% endif %}
```

### Generating Multiple Files

```python
def generate_all(self):
    # Generate different files based on MCU features
    if "USB" in self.mcu.get("peripherals", {}):
        self.generate_usb_descriptor()

    if "CAN" in self.mcu.get("peripherals", {}):
        self.generate_can_config()
```

### Macros for Code Reuse

**`templates/common/macros.j2`:**
```jinja2
{% macro weak_handler(name) -%}
void {{ name }}() __attribute__((weak, alias("Default_Handler")));
{%- endmacro %}

{% macro peripheral_define(name, base) -%}
#define {{ name }}_BASE    {{ base }}
#define {{ name }}         (({{ name }}_TypeDef*){{ name }}_BASE)
{%- endmacro %}
```

**Usage:**
```jinja2
{% import 'common/macros.j2' as macros %}

{% for vector in interrupts.vectors %}
{{ macros.weak_handler(vector.name) }}
{% endfor %}
```

### Custom Filters

Add to `generator.py`:

```python
# Add custom filters to Jinja2 environment
self.jinja_env.filters['hex'] = lambda x: f"0x{x:08X}" if isinstance(x, int) else x
self.jinja_env.filters['upper_snake'] = lambda x: x.replace(' ', '_').upper()
self.jinja_env.filters['comment_wrap'] = lambda x: '\n/// '.join(textwrap.wrap(x, 70))
```

**Usage:**
```jinja2
{{ "my variable" | upper_snake }}
{# Output: MY_VARIABLE #}

/// {{ description | comment_wrap }}
{# Output: Wrapped comment #}
```

## Debugging Templates

### Enable Template Debugging

```python
# In generator.py
self.jinja_env = Environment(
    loader=FileSystemLoader(str(TEMPLATE_DIR)),
    undefined=jinja2.StrictUndefined  # Raise error on undefined variables
)
```

### Print Template Context

```jinja2
{# Debug: Print all available variables #}
{# {{ context }} #}
{# {{ mcu | tojson }} #}
```

### Use Template Comments

```jinja2
{# TODO: Add vector table generation #}
{# FIXME: Handle empty interrupt list #}
{# NOTE: This assumes Cortex-M3 architecture #}
```

## Contributing Templates

To contribute a new template:

1. Create template in appropriate directory
2. Add generation method to `generator.py`
3. Add tests in `tests/test_generator.py`
4. Document in this file
5. Update `README.md`

**Example PR description:**
```
Added template for generating peripheral register definitions

- New template: templates/peripherals/registers.h.j2
- New method: CodeGenerator.generate_registers()
- Tests: test_generator.py::test_register_generation
- Generates type-safe register access macros
```

## Template Reference

### Variables Always Available

```python
{
  "mcu_name": str,        # e.g., "STM32F103C8"
  "source_file": str,     # e.g., "stm32f1xx.json"
  "timestamp": str,       # e.g., "2025-10-30 21:15:03"
  "mcu": dict,            # Complete MCU config
  "interrupts": dict,     # mcu.interrupts (shortcut)
  "architecture": str     # e.g., "arm-cortex-m3"
}
```

### Filters Available

- `hex` - Format integer as 0xXXXXXXXX
- Standard Jinja2 filters (upper, lower, length, etc.)

### Template Directories

- `common/` - Shared templates (headers, macros)
- `startup/` - Startup code templates
- `peripherals/` - Peripheral-specific templates (future)
- `linker/` - Linker script templates (future)

## Examples Repository

See `examples/templates/` for more template examples:
- Vector table generation
- Peripheral wrappers
- Memory map headers
- System configuration

