# C++ Code Generation Reference

**Date**: 2025-11-19
**Purpose**: Definitive reference for how o c√≥digo C++ deve ser gerado
**Status**: ACTIVE REFERENCE

---

## üéØ Objective

Este documento define **exatamente** como o c√≥digo C++ gerado deve ser, servindo como refer√™ncia para:
1. Desenvolvedores que criam templates
2. Validadores que verificam c√≥digo gerado
3. CLI que gera projetos

---

## üìê Code Generation Principles

### Principle 1: Type Safety
‚úÖ **MUST**: Usar tipos fortemente tipados
‚úÖ **MUST**: Validar em compile-time sempre que poss√≠vel
‚úÖ **MUST**: Usar `constexpr` para valores conhecidos em compile-time
‚ùå **NEVER**: Usar void* ou casts sem seguran√ßa

### Principle 2: Zero Overhead
‚úÖ **MUST**: C√≥digo gerado deve compilar para o mesmo assembly que c√≥digo manual
‚úÖ **MUST**: Usar `inline` e `constexpr` adequadamente
‚úÖ **MUST**: Evitar v-tables (sem virtual) em c√≥digo cr√≠tico
‚ùå **NEVER**: Adicionar overhead desnecess√°rio

### Principle 3: Modern C++
‚úÖ **MUST**: Usar C++20/23 features (concepts, constexpr, consteval)
‚úÖ **MUST**: Usar `Result<T, E>` em vez de exce√ß√µes
‚úÖ **MUST**: Usar namespaces claramente definidos
‚ùå **NEVER**: Usar C-style code quando h√° alternativa C++

### Principle 4: Readability
‚úÖ **MUST**: C√≥digo gerado deve ser leg√≠vel
‚úÖ **MUST**: Incluir coment√°rios explicativos
‚úÖ **MUST**: Seguir conven√ß√µes de naming
‚ùå **NEVER**: Gerar c√≥digo ofuscado ou desnecessariamente complexo

---

## üèóÔ∏è Code Structure Templates

### Template 1: GPIO Pin Definition

**Target Output**:
```cpp
/**
 * @file gpio_pins.hpp
 * @brief GPIO pin definitions for STM32F4
 *
 * Auto-generated from: STM32F401.svd
 * Generator: alloy-codegen v2.0.0
 * Generated: 2025-11-19T10:30:00
 *
 * DO NOT EDIT THIS FILE MANUALLY
 */

#pragma once

#include "core/result.hpp"
#include "core/error.hpp"
#include "hal/types.hpp"

namespace alloy::hal::stm32f4 {

using namespace alloy::core;

/**
 * @brief GPIO Port A
 *
 * Base Address: 0x40020000
 * Pin Count: 16
 * Available Pins: 0-15
 */
template <uint8_t PIN_NUM>
class GpioPinA {
public:
    // Compile-time constants
    static constexpr uint32_t PORT_BASE = 0x40020000UL;
    static constexpr uint8_t PIN_NUMBER = PIN_NUM;
    static constexpr uint32_t PIN_MASK = (1UL << PIN_NUM);

    // Compile-time validation
    static_assert(PIN_NUM < 16, "Pin number must be 0-15 for Port A");

    /**
     * @brief Set pin HIGH (atomic operation)
     * @return Ok() on success
     *
     * Implementation: Uses BSRR register for atomic bit-set
     * Cycles: 1 (single register write)
     * Thread-safe: Yes
     */
    [[nodiscard]] static constexpr Result<void, ErrorCode> set() noexcept {
        auto* port = reinterpret_cast<volatile uint32_t*>(PORT_BASE);
        port[BSRR_OFFSET] = PIN_MASK;  // Atomic set
        return Ok();
    }

    /**
     * @brief Set pin LOW (atomic operation)
     * @return Ok() on success
     *
     * Implementation: Uses BSRR register for atomic bit-clear
     * Cycles: 1 (single register write)
     * Thread-safe: Yes
     */
    [[nodiscard]] static constexpr Result<void, ErrorCode> clear() noexcept {
        auto* port = reinterpret_cast<volatile uint32_t*>(PORT_BASE);
        port[BSRR_OFFSET] = (PIN_MASK << 16);  // Atomic clear
        return Ok();
    }

    /**
     * @brief Toggle pin state
     * @return Ok() on success
     *
     * Implementation: Read-modify-write on ODR register
     * Cycles: 3 (read + modify + write)
     * Thread-safe: No (use with caution in ISR)
     */
    [[nodiscard]] static Result<void, ErrorCode> toggle() noexcept {
        auto* port = reinterpret_cast<volatile uint32_t*>(PORT_BASE);

        // Read current state
        const uint32_t current = port[ODR_OFFSET];

        // Toggle bit
        if (current & PIN_MASK) {
            return clear();
        } else {
            return set();
        }
    }

    /**
     * @brief Read pin value
     * @return Ok(true) if HIGH, Ok(false) if LOW
     *
     * Implementation: Read IDR register
     * Cycles: 1 (single register read)
     * Thread-safe: Yes
     */
    [[nodiscard]] static Result<bool, ErrorCode> read() noexcept {
        auto* port = reinterpret_cast<volatile uint32_t*>(PORT_BASE);
        const bool value = (port[IDR_OFFSET] & PIN_MASK) != 0;
        return Ok(value);
    }

    /**
     * @brief Configure pin as output
     * @return Ok() on success
     *
     * Implementation: Modify MODER register (2 bits per pin)
     * Cycles: 3 (read-modify-write)
     * Thread-safe: No
     */
    [[nodiscard]] static Result<void, ErrorCode> set_output() noexcept {
        auto* port = reinterpret_cast<volatile uint32_t*>(PORT_BASE);

        // Calculate bit positions for this pin (2 bits per pin)
        constexpr uint32_t MODE_POS = PIN_NUM * 2;
        constexpr uint32_t MODE_MASK = 0x3UL << MODE_POS;
        constexpr uint32_t MODE_OUTPUT = 0x1UL << MODE_POS;

        // Read-modify-write
        const uint32_t current = port[MODER_OFFSET];
        port[MODER_OFFSET] = (current & ~MODE_MASK) | MODE_OUTPUT;

        return Ok();
    }

    /**
     * @brief Configure pin as input
     * @return Ok() on success
     */
    [[nodiscard]] static Result<void, ErrorCode> set_input() noexcept {
        auto* port = reinterpret_cast<volatile uint32_t*>(PORT_BASE);

        constexpr uint32_t MODE_POS = PIN_NUM * 2;
        constexpr uint32_t MODE_MASK = 0x3UL << MODE_POS;
        constexpr uint32_t MODE_INPUT = 0x0UL << MODE_POS;

        const uint32_t current = port[MODER_OFFSET];
        port[MODER_OFFSET] = (current & ~MODE_MASK) | MODE_INPUT;

        return Ok();
    }

private:
    // Register offsets (in 32-bit words)
    static constexpr uint8_t MODER_OFFSET = 0x00 / 4;
    static constexpr uint8_t ODR_OFFSET = 0x14 / 4;
    static constexpr uint8_t IDR_OFFSET = 0x10 / 4;
    static constexpr uint8_t BSRR_OFFSET = 0x18 / 4;
};

// Convenience aliases
using PA0 = GpioPinA<0>;
using PA1 = GpioPinA<1>;
using PA2 = GpioPinA<2>;
using PA3 = GpioPinA<3>;
using PA4 = GpioPinA<4>;
using PA5 = GpioPinA<5>;  // Often connected to LED on Nucleo boards
// ... PA6-PA15

} // namespace alloy::hal::stm32f4
```

**Key Features**:
- ‚úÖ Type-safe (template parameter)
- ‚úÖ Compile-time validation (static_assert)
- ‚úÖ Zero overhead (constexpr, inline)
- ‚úÖ Clear documentation
- ‚úÖ Thread-safety notes
- ‚úÖ Cycle counts
- ‚úÖ Result<T, E> error handling

---

### Template 2: Register Definitions

**Target Output**:
```cpp
/**
 * @file stm32f4_registers.hpp
 * @brief Register definitions for STM32F4
 *
 * Auto-generated from: STM32F401.svd
 */

#pragma once

#include <cstdint>

namespace alloy::hal::stm32f4::registers {

/**
 * @brief GPIO Port A Registers
 *
 * Base Address: 0x40020000
 * Size: 0x400 bytes
 */
struct GPIOA_Registers {
    /**
     * @brief GPIO port mode register
     * Offset: 0x00
     * Reset value: 0xA8000000
     *
     * Each pin uses 2 bits:
     * - 00: Input (reset state)
     * - 01: General purpose output mode
     * - 10: Alternate function mode
     * - 11: Analog mode
     */
    volatile uint32_t MODER;

    /**
     * @brief GPIO port output type register
     * Offset: 0x04
     * Reset value: 0x00000000
     *
     * Each pin uses 1 bit:
     * - 0: Output push-pull (reset state)
     * - 1: Output open-drain
     */
    volatile uint32_t OTYPER;

    /**
     * @brief GPIO port output speed register
     * Offset: 0x08
     * Reset value: 0x00000000
     */
    volatile uint32_t OSPEEDR;

    /**
     * @brief GPIO port pull-up/pull-down register
     * Offset: 0x0C
     * Reset value: 0x64000000
     */
    volatile uint32_t PUPDR;

    /**
     * @brief GPIO port input data register
     * Offset: 0x10
     * Reset value: 0x0000XXXX (X = undefined)
     * Access: Read-only
     */
    volatile const uint32_t IDR;

    /**
     * @brief GPIO port output data register
     * Offset: 0x14
     * Reset value: 0x00000000
     * Access: Read-write
     */
    volatile uint32_t ODR;

    /**
     * @brief GPIO port bit set/reset register
     * Offset: 0x18
     * Reset value: 0x00000000
     * Access: Write-only
     *
     * Bits 0-15: Set bits (write 1 to set corresponding ODR bit)
     * Bits 16-31: Reset bits (write 1 to clear corresponding ODR bit)
     *
     * This register allows atomic bit manipulation:
     * - Writing 1 to BSy (bit y) sets ODRy
     * - Writing 1 to BRy (bit y+16) clears ODRy
     * - Writing 0 has no effect
     * - Reading always returns 0x00000000
     */
    volatile uint32_t BSRR;

    /**
     * @brief GPIO port configuration lock register
     * Offset: 0x1C
     * Reset value: 0x00000000
     */
    volatile uint32_t LCKR;

    /**
     * @brief GPIO alternate function low register
     * Offset: 0x20
     * Reset value: 0x00000000
     *
     * Configures alternate functions for pins 0-7
     * Each pin uses 4 bits (16 possible alternate functions)
     */
    volatile uint32_t AFRL;

    /**
     * @brief GPIO alternate function high register
     * Offset: 0x24
     * Reset value: 0x00000000
     *
     * Configures alternate functions for pins 8-15
     */
    volatile uint32_t AFRH;
};

// Static assertions for register layout
static_assert(sizeof(GPIOA_Registers) == 0x28, "GPIOA_Registers size mismatch");
static_assert(offsetof(GPIOA_Registers, MODER) == 0x00, "MODER offset mismatch");
static_assert(offsetof(GPIOA_Registers, BSRR) == 0x18, "BSRR offset mismatch");

// Base addresses
constexpr uintptr_t GPIOA_BASE = 0x40020000UL;
constexpr uintptr_t GPIOB_BASE = 0x40020400UL;
constexpr uintptr_t GPIOC_BASE = 0x40020800UL;

// Register pointers
inline GPIOA_Registers* const GPIOA = reinterpret_cast<GPIOA_Registers*>(GPIOA_BASE);
inline GPIOA_Registers* const GPIOB = reinterpret_cast<GPIOA_Registers*>(GPIOB_BASE);
inline GPIOA_Registers* const GPIOC = reinterpret_cast<GPIOA_Registers*>(GPIOC_BASE);

} // namespace alloy::hal::stm32f4::registers
```

**Key Features**:
- ‚úÖ Precise register layout
- ‚úÖ Comprehensive documentation
- ‚úÖ Static assertions for validation
- ‚úÖ Reset values documented
- ‚úÖ Access types (RO, WO, RW) documented

---

### Template 3: Startup Code

**Target Output**:
```cpp
/**
 * @file startup_stm32f401.cpp
 * @brief Startup code for STM32F401
 *
 * Auto-generated from: STM32F401.svd
 *
 * This file contains:
 * - Vector table
 * - Reset handler
 * - Default interrupt handlers
 * - System initialization
 */

#include <cstdint>
#include <cstring>

// External symbols from linker script
extern uint32_t _sidata;  // Start of .data in flash
extern uint32_t _sdata;   // Start of .data in RAM
extern uint32_t _edata;   // End of .data in RAM
extern uint32_t _sbss;    // Start of .bss
extern uint32_t _ebss;    // End of .bss
extern uint32_t _estack;  // Initial stack pointer

// Main function
extern "C" int main();

// Interrupt handlers
extern "C" {

/**
 * @brief Reset Handler - Entry point after power-on or reset
 *
 * Sequence:
 * 1. Copy .data section from Flash to RAM
 * 2. Zero-initialize .bss section
 * 3. Initialize hardware (FPU, clocks)
 * 4. Call static constructors
 * 5. Call main()
 */
[[noreturn]] void Reset_Handler() {
    // 1. Copy .data section (initialized globals)
    uint32_t* src = &_sidata;
    uint32_t* dest = &_sdata;

    while (dest < &_edata) {
        *dest++ = *src++;
    }

    // 2. Zero .bss section (uninitialized globals)
    dest = &_sbss;
    while (dest < &_ebss) {
        *dest++ = 0;
    }

    // 3. Enable FPU (Cortex-M4F)
    constexpr uint32_t CPACR = 0xE000ED88;
    *reinterpret_cast<volatile uint32_t*>(CPACR) |= (0xF << 20);  // Enable CP10 and CP11

    // Data Synchronization Barrier
    __asm__ volatile("dsb");

    // Instruction Synchronization Barrier
    __asm__ volatile("isb");

    // 4. Call static constructors
    extern void (*__init_array_start[])();
    extern void (*__init_array_end[])();

    const size_t init_array_size = __init_array_end - __init_array_start;
    for (size_t i = 0; i < init_array_size; i++) {
        __init_array_start[i]();
    }

    // 5. Call main()
    main();

    // Should never return
    while (1) {
        __asm__ volatile("wfi");  // Wait for interrupt
    }
}

/**
 * @brief Default Handler for unhandled interrupts
 */
[[noreturn]] void Default_Handler() {
    while (1) {
        __asm__ volatile("wfi");
    }
}

// Weak alias all interrupt handlers to Default_Handler
void NMI_Handler() __attribute__((weak, alias("Default_Handler")));
void HardFault_Handler() __attribute__((weak, alias("Default_Handler")));
void MemManage_Handler() __attribute__((weak, alias("Default_Handler")));
void BusFault_Handler() __attribute__((weak, alias("Default_Handler")));
void UsageFault_Handler() __attribute__((weak, alias("Default_Handler")));
void SVC_Handler() __attribute__((weak, alias("Default_Handler")));
void PendSV_Handler() __attribute__((weak, alias("Default_Handler")));
void SysTick_Handler() __attribute__((weak, alias("Default_Handler")));

// Peripheral interrupt handlers (weak)
void WWDG_IRQHandler() __attribute__((weak, alias("Default_Handler")));
void EXTI0_IRQHandler() __attribute__((weak, alias("Default_Handler")));
void USART1_IRQHandler() __attribute__((weak, alias("Default_Handler")));
// ... more handlers

} // extern "C"

/**
 * @brief Vector Table
 *
 * Located at 0x08000000 (Flash start) by linker script
 * Total size: 98 entries √ó 4 bytes = 392 bytes
 */
__attribute__((section(".isr_vector")))
const void* vector_table[] = {
    // Core System Handlers
    reinterpret_cast<void*>(&_estack),          // 0: Initial stack pointer
    reinterpret_cast<void*>(Reset_Handler),      // 1: Reset handler
    reinterpret_cast<void*>(NMI_Handler),        // 2: NMI handler
    reinterpret_cast<void*>(HardFault_Handler),  // 3: Hard fault handler
    reinterpret_cast<void*>(MemManage_Handler),  // 4: MPU fault handler
    reinterpret_cast<void*>(BusFault_Handler),   // 5: Bus fault handler
    reinterpret_cast<void*>(UsageFault_Handler), // 6: Usage fault handler
    nullptr,                                      // 7: Reserved
    nullptr,                                      // 8: Reserved
    nullptr,                                      // 9: Reserved
    nullptr,                                      // 10: Reserved
    reinterpret_cast<void*>(SVC_Handler),        // 11: SVCall handler
    nullptr,                                      // 12: Reserved
    nullptr,                                      // 13: Reserved
    reinterpret_cast<void*>(PendSV_Handler),     // 14: PendSV handler
    reinterpret_cast<void*>(SysTick_Handler),    // 15: SysTick handler

    // External Interrupts
    reinterpret_cast<void*>(WWDG_IRQHandler),    // 16: Window Watchdog
    reinterpret_cast<void*>(EXTI0_IRQHandler),   // 17: EXTI Line 0
    reinterpret_cast<void*>(USART1_IRQHandler),  // 18: USART1
    // ... more interrupt handlers
};

// Validate vector table size at compile-time
static_assert(sizeof(vector_table) == 98 * 4, "Vector table size mismatch");
```

**Key Features**:
- ‚úÖ Complete initialization sequence
- ‚úÖ FPU initialization (Cortex-M4F)
- ‚úÖ Static constructor support
- ‚úÖ Weak interrupt handlers
- ‚úÖ Vector table validation

---

## üîç Code Validation Rules

### Rule 1: Compile-Time Checks
```cpp
// MUST have size validation
static_assert(sizeof(Register) == expected_size, "Size mismatch");

// MUST have offset validation
static_assert(offsetof(Struct, field) == expected_offset, "Offset mismatch");

// MUST have range validation
static_assert(PIN_NUM < MAX_PINS, "Pin out of range");
```

### Rule 2: Documentation
```cpp
// MUST have file header
/**
 * @file filename.hpp
 * @brief Brief description
 *
 * Auto-generated from: source.svd
 * Generator: tool version
 * Generated: timestamp
 */

// MUST have function documentation
/**
 * @brief What the function does
 * @param name Parameter description
 * @return What it returns
 *
 * Additional details:
 * - Implementation notes
 * - Cycle counts
 * - Thread-safety
 */
```

### Rule 3: Error Handling
```cpp
// MUST use Result<T, E>
[[nodiscard]] Result<void, ErrorCode> function();

// MUST mark as nodiscard
[[nodiscard]] Result<T, E> function();

// MUST be noexcept when possible
Result<void, ErrorCode> function() noexcept;
```

### Rule 4: Modern C++
```cpp
// MUST use constexpr for compile-time values
static constexpr uint32_t VALUE = 0x12345678;

// MUST use auto when type is obvious
const auto result = function();

// MUST use nullptr (not NULL or 0)
void* ptr = nullptr;

// MUST use <cstdint> types
uint32_t value;  // NOT unsigned int
```

---

## ‚úÖ Validation Checklist

Para cada arquivo gerado:

- [ ] Compila sem warnings com `-Wall -Wextra -Werror`
- [ ] Compila com C++20/23 (`-std=c++23`)
- [ ] Tem header guard ou `#pragma once`
- [ ] Tem documenta√ß√£o de arquivo
- [ ] Tem documenta√ß√£o de fun√ß√µes p√∫blicas
- [ ] Usa `Result<T, E>` para opera√ß√µes que podem falhar
- [ ] Marca fun√ß√µes `[[nodiscard]]` apropriadamente
- [ ] Usa `constexpr` para valores compile-time
- [ ] Usa `static_assert` para valida√ß√µes
- [ ] Usa namespaces corretos
- [ ] N√£o usa macros (exceto guards)
- [ ] N√£o usa casts inseguros
- [ ] N√£o tem c√≥digo duplicado

---

## üìö Examples of Generated Code

### Example 1: Simple Blink
```cpp
// User code (what we enable)
#include "board.hpp"

int main() {
    using LED = board::led;

    LED::set_output();

    while (true) {
        LED::set();
        board::delay_ms(500);

        LED::clear();
        board::delay_ms(500);
    }
}
```

### Example 2: Error Handling
```cpp
#include "board.hpp"
#include "hal/uart.hpp"

int main() {
    using UART = board::uart;

    // Initialize UART
    if (auto result = UART::configure(115200); result.is_err()) {
        // Handle error
        return -1;
    }

    // Send data
    const char* message = "Hello, World!\r\n";
    if (auto result = UART::send_string(message); result.is_err()) {
        // Handle error
        return -1;
    }

    return 0;
}
```

---

**Status**: Active Reference
**Last Updated**: 2025-11-19
**Next Review**: When adding new peripheral types
