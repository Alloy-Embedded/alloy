/**
 * @file gpio.hpp
 * @brief Template-based GPIO implementation for {{ family.upper() }} (Platform Layer)
 *
 * This file implements GPIO peripheral using templates with ZERO virtual
 * functions and ZERO runtime overhead. It automatically includes all
 * necessary vendor-specific headers.
 *
 * Design Principles:
 * - Template-based: Port address and pin number resolved at compile-time
 * - Zero overhead: Fully inlined, single instruction for read/write
 * - Compile-time masks: Pin masks computed at compile-time
 * - Type-safe: Strong typing prevents pin conflicts
 * - Error handling: Uses Result<T> for robust error handling
 * - Testable: Includes test hooks for unit testing
 *
 * Auto-generated from: {{ metadata.family }}
 * Generator: generate_platform_gpio.py
 * Generated: {{ generation_date }}
 *
 * @note Part of Alloy HAL Platform Abstraction Layer
 */

#pragma once

// ============================================================================
// Core Types
// ============================================================================

#include "core/error.hpp"
#include "core/result.hpp"
#include "core/types.hpp"
#include "hal/types.hpp"

// ============================================================================
// Vendor-Specific Includes (Auto-Generated)
// ============================================================================

// Register definitions from vendor (family-level)
#include "{{ metadata.register_include }}"

// Bitfields (family-level, if available)
{% if metadata.bitfield_include %}
// #include "{{ metadata.bitfield_include }}"
{% endif %}

// Hardware definitions (MCU-specific - port bases, etc)
// Note: Board files should include hardware.hpp from specific MCU if needed
// #include "hal/vendors/{{ metadata.vendor }}/{{ metadata.family }}/{{ mcu_name }}/hardware.hpp"

// Pin definitions and functions (MCU-specific)
// Note: These should be included by board files as they're MCU-specific
// Example: #include "hal/vendors/{{ metadata.vendor }}/{{ metadata.family }}/{{ mcu_name }}/pins.hpp"

namespace {{ metadata.platform_namespace }} {

using namespace alloy::core;
using namespace alloy::hal;

// Import vendor-specific register types (now from family-level namespace)
using namespace {{ metadata.vendor_namespace }};

// Note: GPIO configuration uses common HAL types from hal/types.hpp:
// - PinDirection (Input, Output)
// - PinPull (None, PullUp, PullDown)
// - PinDrive (PushPull, OpenDrain)

{% if metadata.additional_enums %}
// ============================================================================
// Platform-Specific Enums
// ============================================================================

{% for enum_def in metadata.additional_enums %}
/**
 * @brief {{ enum_def.description }}
 */
enum class {{ enum_def.name }} : {{ enum_def.type }} {
{% for enum_value in enum_def['values'] %}
    {{ enum_value.name }} = {{ enum_value.value }},  ///< {{ enum_value.description }}
{% endfor %}
};

{% endfor %}
{% endif %}

/**
 * @brief Template-based GPIO pin for {{ family.upper() }}
 *
 * This class provides a template-based GPIO implementation with ZERO runtime
 * overhead. All pin masks and operations are resolved at compile-time.
 *
 * Template Parameters:
 * - PORT_BASE: {{ metadata.peripheral_name }} port base address (compile-time constant)
 * - PIN_NUM: Pin number within port (0-31)
 *
 * Example usage:
 * @code
{% for example_name, example in metadata.examples.items() %}
 * // {{ example.description }}
 * {{ example.code }}
{% endfor %}
 * @endcode
 *
 * @tparam PORT_BASE {{ metadata.peripheral_name }} port base address
 * @tparam PIN_NUM Pin number (0-31)
 */
template <uint32_t PORT_BASE, uint8_t PIN_NUM>
class GpioPin {
public:
    // Compile-time constants
    static constexpr uint32_t port_base = PORT_BASE;
    static constexpr uint8_t pin_number = PIN_NUM;
    static constexpr uint32_t pin_mask = (1u << PIN_NUM);

    // Validate pin number at compile-time
    static_assert(PIN_NUM < 32, "Pin number must be 0-31");

    /**
     * @brief Get {{ metadata.peripheral_name }} port registers
     *
     * Returns pointer to {{ metadata.peripheral_name }} registers. Uses conditional compilation
     * for test hook injection.
     */
    static inline volatile {{ metadata.register_namespace }}::{{ metadata.register_type }}* get_port() {
#ifdef ALLOY_GPIO_MOCK_PORT
        // In tests, use the mock port pointer
        return ALLOY_GPIO_MOCK_PORT();
#else
        return reinterpret_cast<volatile {{ metadata.register_namespace }}::{{ metadata.register_type }}*>(PORT_BASE);
#endif
    }

{% for operation_name, operation in metadata.operations.items() %}
    /**
     * @brief {{ operation.description }}
     *
{% if operation.parameters %}
{% for param in operation.parameters %}
     * @param {{ param.name }} {{ param.description }}
{% endfor %}
{% endif %}
     * @return {{ operation.return_type }}{% if operation.returns %} {{ operation.description }}{% endif %}

{% if operation.note %}
     *
     * @note {{ operation.note }}
{% endif %}
     */
    {{ operation.return_type }} {{ operation_name }}({% if operation.parameters %}{% for param in operation.parameters %}{{ param.type }} {{ param.name }}{% if not loop.last %}, {% endif %}{% endfor %}{% endif %}){% if operation.const %} const{% endif %} {
        auto* port = get_port();

{% for step in operation.steps %}
{% if step.condition %}
        {{ step.condition }} {
{% if step.then %}
{% for substep in step.then %}
{% if substep.register %}
            {{ generate_register_access(metadata, substep) }}
{% if substep.test_hook %}
#ifdef {{ substep.test_hook }}
            {{ substep.test_hook }}();
#endif
{% endif %}
{% elif substep.comment %}
            // {{ substep.comment }}
{% endif %}
{% endfor %}
{% endif %}
        }{% if step.else %} else {
{% for substep in step.else %}
{% if substep.register %}
            {{ generate_register_access(metadata, substep) }}
{% if substep.test_hook %}
#ifdef {{ substep.test_hook }}
            {{ substep.test_hook }}();
#endif
{% endif %}
{% elif substep.comment %}
            // {{ substep.comment }}
{% endif %}
{% endfor %}
        }{% endif %}

{% elif step.switch %}
        switch ({{ step.switch }}) {
{% for case in step.cases %}
            case {{ case.value }}:
{% for substep in case.steps %}
{% if substep.register %}
                {{ generate_register_access(metadata, substep) }}
{% if substep.test_hook %}
#ifdef {{ substep.test_hook }}
                {{ substep.test_hook }}();
#endif
{% endif %}
{% elif substep.return_error %}
                return Err({{ substep.return_error }});
{% elif substep.comment %}
                // {{ substep.comment }}
{% endif %}
{% endfor %}
                break;

{% endfor %}
        }

{% elif step.then_call %}
        if ({{ step.condition.replace('if (', '').replace(')', '') }}) {
            return {{ step.then_call }}();
        } else {
            return {{ step.else_call }}();
        }

{% elif step.register %}
{% if step.operation == 'read' %}
        auto {{ step.store_as }} = port->{{ metadata.registers[step.register].name }};
{% elif step.operation == 'write' %}
        port->{{ metadata.registers[step.register].name }} = {{ step.value }};  // {{ step.comment }}
{% if step.test_hook %}
#ifdef {{ step.test_hook }}
        {{ step.test_hook }}();
#endif
{% endif %}
{% elif step.operation == 'modify_2bit' %}
        // {{ step.comment }}
        uint32_t temp = port->{{ metadata.registers[step.register].name }};
        temp &= ~{{ step.clear_mask }};
{% if step.compute_value %}
        uint32_t value = 0;
        switch ({{ operation.parameters[0].name }}) {
{% for switch_value, result in step.value_switch.items() %}
            case {{ switch_value }}: value = {{ result }} << (PIN_NUM * 2); break;
{% endfor %}
        }
        temp |= value;
{% else %}
        temp |= ({{ step.value }}) << (PIN_NUM * 2);
{% endif %}
        port->{{ metadata.registers[step.register].name }} = temp;
{% if step.test_hook %}
#ifdef {{ step.test_hook }}
        {{ step.test_hook }}();
#endif
{% endif %}
{% elif step.operation == 'modify_1bit' %}
        // {{ step.comment }}
        uint32_t temp = port->{{ metadata.registers[step.register].name }};
        temp &= ~{{ step.clear_mask }};
        temp |= {{ step.value }};
        port->{{ metadata.registers[step.register].name }} = temp;
{% if step.test_hook %}
#ifdef {{ step.test_hook }}
        {{ step.test_hook }}();
#endif
{% endif %}
{% else %}
        // Default: simple write operation
        port->{{ metadata.registers[step.register].name }} = {{ step.value }};  // {{ step.comment }}
{% if step.test_hook %}
#ifdef {{ step.test_hook }}
        {{ step.test_hook }}();
#endif
{% endif %}
{% endif %}

{% elif step.compute %}
        bool {{ step.store_as }} = {{ step.compute }};

{% endif %}
{% endfor %}
{% if operation.returns %}
{% if 'bool' in operation.return_type %}
        return Ok(bool({{ operation.returns }}));
{% else %}
        return Ok({{ operation.returns }});
{% endif %}
{% elif operation.always_succeeds %}
        return Ok();
{% endif %}
    }

{% endfor %}
};

// ==============================================================================
// Port Base Address Constants
// ==============================================================================

{% for port_name, port_addr in metadata.port_bases.items() %}
constexpr uint32_t {{ port_name }}_BASE = {{ port_addr }};
{% endfor %}

// ==============================================================================
// Common Pin Type Aliases
// ==============================================================================

// Board-specific pin definitions should be in board.hpp
// Example:
{% for example_name, example in metadata.examples.items() %}
{% for line in example.code.split('\n') %}
// {{ line }}
{% endfor %}
{% endfor %}

} // namespace {{ metadata.platform_namespace }}
